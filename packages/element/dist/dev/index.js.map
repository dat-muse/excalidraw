{
  "version": 3,
  "sources": [
    "<define:import.meta.env>",
    "../../../../node_modules/lodash.throttle/index.js",
    "../../src/index.ts",
    "../../src/sizeHelpers.ts",
    "../../src/bounds.ts",
    "../../../../node_modules/roughjs/bin/rough.js",
    "../../../../node_modules/roughjs/bin/canvas.js",
    "../../../../node_modules/roughjs/bin/generator.js",
    "../../../../node_modules/roughjs/bin/renderer.js",
    "../../../../node_modules/roughjs/bin/fillers/filler.js",
    "../../../../node_modules/roughjs/bin/fillers/hachure-filler.js",
    "../../../../node_modules/roughjs/bin/fillers/scan-line-hachure.js",
    "../../../../node_modules/hachure-fill/bin/hachure.js",
    "../../../../node_modules/roughjs/bin/fillers/zigzag-filler.js",
    "../../../../node_modules/roughjs/bin/geometry.js",
    "../../../../node_modules/roughjs/bin/fillers/hatch-filler.js",
    "../../../../node_modules/roughjs/bin/fillers/dot-filler.js",
    "../../../../node_modules/roughjs/bin/fillers/dashed-filler.js",
    "../../../../node_modules/roughjs/bin/fillers/zigzag-line-filler.js",
    "../../../../node_modules/roughjs/bin/math.js",
    "../../../../node_modules/path-data-parser/lib/index.js",
    "../../../../node_modules/path-data-parser/lib/parser.js",
    "../../../../node_modules/path-data-parser/lib/absolutize.js",
    "../../../../node_modules/path-data-parser/lib/normalize.js",
    "../../../../node_modules/points-on-curve/lib/curve-to-bezier.js",
    "../../../../node_modules/points-on-curve/lib/index.js",
    "../../../../node_modules/points-on-path/lib/index.js",
    "../../../../node_modules/roughjs/bin/svg.js",
    "../../../../node_modules/roughjs/bin/core.js",
    "../../../utils/src/shape.ts",
    "../../src/shape.ts",
    "../../src/renderElement.ts",
    "../../../../node_modules/perfect-freehand/dist/esm/index.js",
    "../../src/cropElement.ts",
    "../../src/linearElementEditor.ts",
    "../../src/binding.ts",
    "../../src/collision.ts",
    "../../src/utils.ts",
    "../../src/typeChecks.ts",
    "../../src/textElement.ts",
    "../../src/containerCache.ts",
    "../../src/textMeasurements.ts",
    "../../src/textWrapping.ts",
    "../../src/distance.ts",
    "../../src/heading.ts",
    "../../src/mutateElement.ts",
    "../../src/elbowArrow.ts",
    "../../src/frame.ts",
    "../../../utils/src/bbox.ts",
    "../../../utils/src/withinBounds.ts",
    "../../src/selection.ts",
    "../../src/groups.ts",
    "../../src/comparisons.ts",
    "../../src/align.ts",
    "../../src/delta.ts",
    "../../src/store.ts",
    "../../src/duplicate.ts",
    "../../src/sortElements.ts",
    "../../src/fractionalIndex.ts",
    "../../../../node_modules/fractional-indexing/src/index.js",
    "../../src/Scene.ts",
    "../../src/distribute.ts",
    "../../src/dragElements.ts",
    "../../src/elementLink.ts",
    "../../src/embeddable.ts",
    "../../src/newElement.ts",
    "../../src/flowchart.ts",
    "../../src/image.ts",
    "../../src/resizeElements.ts",
    "../../src/resizeTest.ts",
    "../../src/transformHandles.ts",
    "../../src/showSelectedShapeActions.ts",
    "../../src/zindex.ts"
  ],
  "sourcesContent": [
    "",
    "/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n",
    "import { toIterable } from \"@excalidraw/common\";\n\nimport { isInvisiblySmallElement } from \"./sizeHelpers\";\nimport { isLinearElementType } from \"./typeChecks\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ElementsMapOrArray,\n} from \"./types\";\n\n/**\n * @deprecated unsafe, use hashElementsVersion instead\n */\nexport const getSceneVersion = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce((acc, el) => acc + el.version, 0);\n\n/**\n * Hashes elements' versionNonce (using djb2 algo). Order of elements matters.\n */\nexport const hashElementsVersion = (elements: ElementsMapOrArray): number => {\n  let hash = 5381;\n  for (const element of toIterable(elements)) {\n    hash = (hash << 5) + hash + element.versionNonce;\n  }\n  return hash >>> 0; // Ensure unsigned 32-bit integer\n};\n\n// string hash function (using djb2). Not cryptographically secure, use only\n// for versioning and such.\nexport const hashString = (s: string): number => {\n  let hash: number = 5381;\n  for (let i = 0; i < s.length; i++) {\n    const char: number = s.charCodeAt(i);\n    hash = (hash << 5) + hash + char;\n  }\n  return hash >>> 0; // Ensure unsigned 32-bit integer\n};\n\nexport const getVisibleElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (el) => !el.isDeleted && !isInvisiblySmallElement(el),\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const getNonDeletedElements = <T extends ExcalidrawElement>(\n  elements: readonly T[],\n) =>\n  elements.filter((element) => !element.isDeleted) as readonly NonDeleted<T>[];\n\nexport const isNonDeletedElement = <T extends ExcalidrawElement>(\n  element: T,\n): element is NonDeleted<T> => !element.isDeleted;\n\nconst _clearElements = (\n  elements: readonly ExcalidrawElement[],\n): ExcalidrawElement[] =>\n  getNonDeletedElements(elements).map((element) =>\n    isLinearElementType(element.type)\n      ? { ...element, lastCommittedPoint: null }\n      : element,\n  );\n\nexport const clearElementsForDatabase = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n\nexport const clearElementsForExport = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n\nexport const clearElementsForLocalStorage = (\n  elements: readonly ExcalidrawElement[],\n) => _clearElements(elements);\n\nexport * from \"./align\";\nexport * from \"./binding\";\nexport * from \"./bounds\";\nexport * from \"./collision\";\nexport * from \"./comparisons\";\nexport * from \"./containerCache\";\nexport * from \"./cropElement\";\nexport * from \"./delta\";\nexport * from \"./distance\";\nexport * from \"./distribute\";\nexport * from \"./dragElements\";\nexport * from \"./duplicate\";\nexport * from \"./elbowArrow\";\nexport * from \"./elementLink\";\nexport * from \"./embeddable\";\nexport * from \"./flowchart\";\nexport * from \"./fractionalIndex\";\nexport * from \"./frame\";\nexport * from \"./groups\";\nexport * from \"./heading\";\nexport * from \"./image\";\nexport * from \"./linearElementEditor\";\nexport * from \"./mutateElement\";\nexport * from \"./newElement\";\nexport * from \"./renderElement\";\nexport * from \"./resizeElements\";\nexport * from \"./resizeTest\";\nexport * from \"./Scene\";\nexport * from \"./selection\";\nexport * from \"./shape\";\nexport * from \"./showSelectedShapeActions\";\nexport * from \"./sizeHelpers\";\nexport * from \"./sortElements\";\nexport * from \"./store\";\nexport * from \"./textElement\";\nexport * from \"./textMeasurements\";\nexport * from \"./textWrapping\";\nexport * from \"./transformHandles\";\nexport * from \"./typeChecks\";\nexport * from \"./utils\";\nexport * from \"./zindex\";\n",
    "import {\n  SHIFT_LOCKING_ANGLE,\n  viewportCoordsToSceneCoords,\n} from \"@excalidraw/common\";\nimport {\n  normalizeRadians,\n  radiansBetweenAngles,\n  radiansDifference,\n  type Radians,\n} from \"@excalidraw/math\";\n\nimport { pointsEqual } from \"@excalidraw/math\";\n\nimport type { AppState, Offsets, Zoom } from \"excalidraw-custom/types\";\n\nimport { getCommonBounds, getElementBounds } from \"./bounds\";\nimport {\n  isArrowElement,\n  isFreeDrawElement,\n  isLinearElement,\n} from \"./typeChecks\";\n\nimport type { ElementsMap, ExcalidrawElement } from \"./types\";\n\nexport const INVISIBLY_SMALL_ELEMENT_SIZE = 0.1;\n\n// TODO:  remove invisible elements consistently actions, so that invisible elements are not recorded by the store, exported, broadcasted or persisted\n//        - perhaps could be as part of a standalone 'cleanup' action, in addition to 'finalize'\n//        - could also be part of `_clearElements`\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return (\n      element.points.length < 2 ||\n      (element.points.length === 2 &&\n        isArrowElement(element) &&\n        pointsEqual(\n          element.points[0],\n          element.points[element.points.length - 1],\n          INVISIBLY_SMALL_ELEMENT_SIZE,\n        ))\n    );\n  }\n\n  return element.width === 0 && element.height === 0;\n};\n\nexport const isElementInViewport = (\n  element: ExcalidrawElement,\n  width: number,\n  height: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n  elementsMap: ElementsMap,\n) => {\n  const [x1, y1, x2, y2] = getElementBounds(element, elementsMap); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft,\n      clientY: viewTransformations.offsetTop,\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + width,\n      clientY: viewTransformations.offsetTop + height,\n    },\n    viewTransformations,\n  );\n\n  return (\n    topLeftSceneCoords.x <= x2 &&\n    topLeftSceneCoords.y <= y2 &&\n    bottomRightSceneCoords.x >= x1 &&\n    bottomRightSceneCoords.y >= y1\n  );\n};\n\nexport const isElementCompletelyInViewport = (\n  elements: ExcalidrawElement[],\n  width: number,\n  height: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n  elementsMap: ElementsMap,\n  padding?: Offsets,\n) => {\n  const [x1, y1, x2, y2] = getCommonBounds(elements, elementsMap); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + (padding?.left || 0),\n      clientY: viewTransformations.offsetTop + (padding?.top || 0),\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + width - (padding?.right || 0),\n      clientY: viewTransformations.offsetTop + height - (padding?.bottom || 0),\n    },\n    viewTransformations,\n  );\n\n  return (\n    x1 >= topLeftSceneCoords.x &&\n    y1 >= topLeftSceneCoords.y &&\n    x2 <= bottomRightSceneCoords.x &&\n    y2 <= bottomRightSceneCoords.y\n  );\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: AppState[\"activeTool\"][\"type\"],\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"freedraw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height = absWidth * Math.tan(lockedAngle) * Math.sign(height) || height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const getLockedLinearCursorAlignSize = (\n  originX: number,\n  originY: number,\n  x: number,\n  y: number,\n  customAngle?: number,\n) => {\n  let width = x - originX;\n  let height = y - originY;\n\n  const angle = Math.atan2(height, width) as Radians;\n  let lockedAngle = (Math.round(angle / SHIFT_LOCKING_ANGLE) *\n    SHIFT_LOCKING_ANGLE) as Radians;\n\n  if (customAngle) {\n    // If custom angle is provided, we check if the angle is close to the\n    // custom angle, snap to that if close engough, otherwise snap to the\n    // higher or lower angle depending on the current angle vs custom angle.\n    const lower = (Math.floor(customAngle / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE) as Radians;\n    if (\n      radiansBetweenAngles(\n        angle,\n        lower,\n        (lower + SHIFT_LOCKING_ANGLE) as Radians,\n      )\n    ) {\n      if (\n        radiansDifference(angle, customAngle as Radians) <\n        SHIFT_LOCKING_ANGLE / 6\n      ) {\n        lockedAngle = customAngle as Radians;\n      } else if (\n        normalizeRadians(angle) > normalizeRadians(customAngle as Radians)\n      ) {\n        lockedAngle = (lower + SHIFT_LOCKING_ANGLE) as Radians;\n      } else {\n        lockedAngle = lower;\n      }\n    }\n  }\n\n  if (lockedAngle === 0) {\n    height = 0;\n  } else if (lockedAngle === Math.PI / 2) {\n    width = 0;\n  } else {\n    // locked angle line, y = mx + b => mx - y + b = 0\n    const a1 = Math.tan(lockedAngle);\n    const b1 = -1;\n    const c1 = originY - a1 * originX;\n\n    // line through cursor, perpendicular to locked angle line\n    const a2 = -1 / a1;\n    const b2 = -1;\n    const c2 = y - a2 * x;\n\n    // intersection of the two lines above\n    const intersectX = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const intersectY = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);\n\n    // delta\n    width = intersectX - originX;\n    height = intersectY - originY;\n  }\n\n  return { width, height };\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n",
    "import rough from \"roughjs/bin/rough\";\n\nimport {\n  arrayToMap,\n  invariant,\n  rescalePoints,\n  sizeOf,\n} from \"@excalidraw/common\";\n\nimport {\n  degreesToRadians,\n  lineSegment,\n  pointDistance,\n  pointFrom,\n  pointFromArray,\n  pointRotateRads,\n} from \"@excalidraw/math\";\n\nimport { getCurvePathOps } from \"@excalidraw/utils/shape\";\n\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport type {\n  Curve,\n  Degrees,\n  GlobalPoint,\n  LineSegment,\n  LocalPoint,\n  Radians,\n} from \"@excalidraw/math\";\n\nimport type { AppState } from \"excalidraw-custom/types\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport { generateRoughOptions } from \"./shape\";\nimport { ShapeCache } from \"./shape\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\nimport {\n  isArrowElement,\n  isBoundToContainer,\n  isFreeDrawElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport { getElementShape } from \"./shape\";\n\nimport {\n  deconstructDiamondElement,\n  deconstructRectanguloidElement,\n} from \"./utils\";\n\nimport type { Drawable, Op } from \"roughjs/bin/core\";\nimport type { Point as RoughPoint } from \"roughjs/bin/geometry\";\nimport type {\n  Arrowhead,\n  ElementsMap,\n  ElementsMapOrArray,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n  ExcalidrawTextElementWithContainer,\n  NonDeleted,\n} from \"./types\";\n\nexport type RectangleBox = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  angle: number;\n};\n\ntype MaybeQuadraticSolution = [number | null, number | null] | false;\n\n/**\n * x and y position of top left corner, x and y position of bottom right corner\n */\nexport type Bounds = readonly [\n  minX: number,\n  minY: number,\n  maxX: number,\n  maxY: number,\n];\n\nexport type SceneBounds = readonly [\n  sceneX: number,\n  sceneY: number,\n  sceneX2: number,\n  sceneY2: number,\n];\n\nexport class ElementBounds {\n  private static boundsCache = new WeakMap<\n    ExcalidrawElement,\n    {\n      bounds: Bounds;\n      version: ExcalidrawElement[\"version\"];\n    }\n  >();\n  private static nonRotatedBoundsCache = new WeakMap<\n    ExcalidrawElement,\n    {\n      bounds: Bounds;\n      version: ExcalidrawElement[\"version\"];\n    }\n  >();\n\n  static getBounds(\n    element: ExcalidrawElement,\n    elementsMap: ElementsMap,\n    nonRotated: boolean = false,\n  ) {\n    const cachedBounds =\n      nonRotated && element.angle !== 0\n        ? ElementBounds.nonRotatedBoundsCache.get(element)\n        : ElementBounds.boundsCache.get(element);\n\n    if (\n      cachedBounds?.version &&\n      cachedBounds.version === element.version &&\n      // we don't invalidate cache when we update containers and not labels,\n      // which is causing problems down the line. Fix TBA.\n      !isBoundToContainer(element)\n    ) {\n      return cachedBounds.bounds;\n    }\n\n    if (nonRotated && element.angle !== 0) {\n      const nonRotatedBounds = ElementBounds.calculateBounds(\n        {\n          ...element,\n          angle: 0 as Radians,\n        },\n        elementsMap,\n      );\n      ElementBounds.nonRotatedBoundsCache.set(element, {\n        version: element.version,\n        bounds: nonRotatedBounds,\n      });\n\n      return nonRotatedBounds;\n    }\n\n    const bounds = ElementBounds.calculateBounds(element, elementsMap);\n\n    ElementBounds.boundsCache.set(element, {\n      version: element.version,\n      bounds,\n    });\n\n    return bounds;\n  }\n\n  private static calculateBounds(\n    element: ExcalidrawElement,\n    elementsMap: ElementsMap,\n  ): Bounds {\n    let bounds: Bounds;\n\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n      element,\n      elementsMap,\n    );\n    if (isFreeDrawElement(element)) {\n      const [minX, minY, maxX, maxY] = getBoundsFromPoints(\n        element.points.map(([x, y]) =>\n          pointRotateRads(\n            pointFrom(x, y),\n            pointFrom(cx - element.x, cy - element.y),\n            element.angle,\n          ),\n        ),\n      );\n\n      return [\n        minX + element.x,\n        minY + element.y,\n        maxX + element.x,\n        maxY + element.y,\n      ];\n    } else if (isLinearElement(element)) {\n      bounds = getLinearElementRotatedBounds(element, cx, cy, elementsMap);\n    } else if (element.type === \"diamond\") {\n      const [x11, y11] = pointRotateRads(\n        pointFrom(cx, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x12, y12] = pointRotateRads(\n        pointFrom(cx, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x22, y22] = pointRotateRads(\n        pointFrom(x1, cy),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x21, y21] = pointRotateRads(\n        pointFrom(x2, cy),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    } else if (element.type === \"ellipse\") {\n      const w = (x2 - x1) / 2;\n      const h = (y2 - y1) / 2;\n      const cos = Math.cos(element.angle);\n      const sin = Math.sin(element.angle);\n      const ww = Math.hypot(w * cos, h * sin);\n      const hh = Math.hypot(h * cos, w * sin);\n      bounds = [cx - ww, cy - hh, cx + ww, cy + hh];\n    } else {\n      const [x11, y11] = pointRotateRads(\n        pointFrom(x1, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x12, y12] = pointRotateRads(\n        pointFrom(x1, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x22, y22] = pointRotateRads(\n        pointFrom(x2, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x21, y21] = pointRotateRads(\n        pointFrom(x2, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    }\n\n    return bounds;\n  }\n}\n\n// Scene -> Scene coords, but in x1,x2,y1,y2 format.\n//\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  includeBoundText: boolean = false,\n): [number, number, number, number, number, number] => {\n  if (isFreeDrawElement(element)) {\n    return getFreeDrawElementAbsoluteCoords(element);\n  } else if (isLinearElement(element)) {\n    return LinearElementEditor.getElementAbsoluteCoords(\n      element,\n      elementsMap,\n      includeBoundText,\n    );\n  } else if (isTextElement(element)) {\n    const container = elementsMap\n      ? getContainerElement(element, elementsMap)\n      : null;\n    if (isArrowElement(container)) {\n      const { x, y } = LinearElementEditor.getBoundTextElementPosition(\n        container,\n        element as ExcalidrawTextElementWithContainer,\n        elementsMap,\n      );\n      return [\n        x,\n        y,\n        x + element.width,\n        y + element.height,\n        x + element.width / 2,\n        y + element.height / 2,\n      ];\n    }\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n    element.x + element.width / 2,\n    element.y + element.height / 2,\n  ];\n};\n\n/*\n * for a given element, `getElementLineSegments` returns line segments\n * that can be used for visual collision detection (useful for frames)\n * as opposed to bounding box collision detection\n */\n/**\n * Given an element, return the line segments that make up the element.\n *\n * Uses helpers from /math\n */\nexport const getElementLineSegments = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): LineSegment<GlobalPoint>[] => {\n  const shape = getElementShape(element, elementsMap);\n  const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n    element,\n    elementsMap,\n  );\n  const center = pointFrom<GlobalPoint>(cx, cy);\n\n  if (shape.type === \"polycurve\") {\n    const curves = shape.data;\n    const points = curves\n      .map((curve) => pointsOnBezierCurves(curve, 10))\n      .flat();\n    let i = 0;\n    const segments: LineSegment<GlobalPoint>[] = [];\n    while (i < points.length - 1) {\n      segments.push(\n        lineSegment(\n          pointFrom(points[i][0], points[i][1]),\n          pointFrom(points[i + 1][0], points[i + 1][1]),\n        ),\n      );\n      i++;\n    }\n\n    return segments;\n  } else if (shape.type === \"polyline\") {\n    return shape.data as LineSegment<GlobalPoint>[];\n  } else if (_isRectanguloidElement(element)) {\n    const [sides, corners] = deconstructRectanguloidElement(element);\n    const cornerSegments: LineSegment<GlobalPoint>[] = corners\n      .map((corner) => getSegmentsOnCurve(corner, center, element.angle))\n      .flat();\n    const rotatedSides = getRotatedSides(sides, center, element.angle);\n    return [...rotatedSides, ...cornerSegments];\n  } else if (element.type === \"diamond\") {\n    const [sides, corners] = deconstructDiamondElement(element);\n    const cornerSegments = corners\n      .map((corner) => getSegmentsOnCurve(corner, center, element.angle))\n      .flat();\n    const rotatedSides = getRotatedSides(sides, center, element.angle);\n\n    return [...rotatedSides, ...cornerSegments];\n  } else if (shape.type === \"polygon\") {\n    if (isTextElement(element)) {\n      const container = getContainerElement(element, elementsMap);\n      if (container && isLinearElement(container)) {\n        const segments: LineSegment<GlobalPoint>[] = [\n          lineSegment(pointFrom(x1, y1), pointFrom(x2, y1)),\n          lineSegment(pointFrom(x2, y1), pointFrom(x2, y2)),\n          lineSegment(pointFrom(x2, y2), pointFrom(x1, y2)),\n          lineSegment(pointFrom(x1, y2), pointFrom(x1, y1)),\n        ];\n        return segments;\n      }\n    }\n\n    const points = shape.data as GlobalPoint[];\n    const segments: LineSegment<GlobalPoint>[] = [];\n    for (let i = 0; i < points.length - 1; i++) {\n      segments.push(lineSegment(points[i], points[i + 1]));\n    }\n    return segments;\n  } else if (shape.type === \"ellipse\") {\n    return getSegmentsOnEllipse(element as ExcalidrawEllipseElement);\n  }\n\n  const [nw, ne, sw, se, , , w, e] = (\n    [\n      [x1, y1],\n      [x2, y1],\n      [x1, y2],\n      [x2, y2],\n      [cx, y1],\n      [cx, y2],\n      [x1, cy],\n      [x2, cy],\n    ] as GlobalPoint[]\n  ).map((point) => pointRotateRads(point, center, element.angle));\n\n  return [\n    lineSegment(nw, ne),\n    lineSegment(sw, se),\n    lineSegment(nw, sw),\n    lineSegment(ne, se),\n    lineSegment(nw, e),\n    lineSegment(sw, e),\n    lineSegment(ne, w),\n    lineSegment(se, w),\n  ];\n};\n\nconst _isRectanguloidElement = (\n  element: ExcalidrawElement,\n): element is ExcalidrawRectanguloidElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"image\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      (element.type === \"text\" && !element.containerId))\n  );\n};\n\nconst getRotatedSides = (\n  sides: LineSegment<GlobalPoint>[],\n  center: GlobalPoint,\n  angle: Radians,\n) => {\n  return sides.map((side) => {\n    return lineSegment(\n      pointRotateRads<GlobalPoint>(side[0], center, angle),\n      pointRotateRads<GlobalPoint>(side[1], center, angle),\n    );\n  });\n};\n\nconst getSegmentsOnCurve = (\n  curve: Curve<GlobalPoint>,\n  center: GlobalPoint,\n  angle: Radians,\n): LineSegment<GlobalPoint>[] => {\n  const points = pointsOnBezierCurves(curve, 10);\n  let i = 0;\n  const segments: LineSegment<GlobalPoint>[] = [];\n  while (i < points.length - 1) {\n    segments.push(\n      lineSegment(\n        pointRotateRads<GlobalPoint>(\n          pointFrom(points[i][0], points[i][1]),\n          center,\n          angle,\n        ),\n        pointRotateRads<GlobalPoint>(\n          pointFrom(points[i + 1][0], points[i + 1][1]),\n          center,\n          angle,\n        ),\n      ),\n    );\n    i++;\n  }\n\n  return segments;\n};\n\nconst getSegmentsOnEllipse = (\n  ellipse: ExcalidrawEllipseElement,\n): LineSegment<GlobalPoint>[] => {\n  const center = pointFrom<GlobalPoint>(\n    ellipse.x + ellipse.width / 2,\n    ellipse.y + ellipse.height / 2,\n  );\n\n  const a = ellipse.width / 2;\n  const b = ellipse.height / 2;\n\n  const segments: LineSegment<GlobalPoint>[] = [];\n  const points: GlobalPoint[] = [];\n  const n = 90;\n  const deltaT = (Math.PI * 2) / n;\n\n  for (let i = 0; i < n; i++) {\n    const t = i * deltaT;\n    const x = center[0] + a * Math.cos(t);\n    const y = center[1] + b * Math.sin(t);\n    points.push(pointRotateRads(pointFrom(x, y), center, ellipse.angle));\n  }\n\n  for (let i = 0; i < points.length - 1; i++) {\n    segments.push(lineSegment(points[i], points[i + 1]));\n  }\n\n  segments.push(lineSegment(points[points.length - 1], points[0]));\n  return segments;\n};\n\n/**\n * Scene -> Scene coords, but in x1,x2,y1,y2 format.\n *\n * Rectangle here means any rectangular frame, not an excalidraw element.\n */\nexport const getRectangleBoxAbsoluteCoords = (boxSceneCoords: RectangleBox) => {\n  return [\n    boxSceneCoords.x,\n    boxSceneCoords.y,\n    boxSceneCoords.x + boxSceneCoords.width,\n    boxSceneCoords.y + boxSceneCoords.height,\n    boxSceneCoords.x + boxSceneCoords.width / 2,\n    boxSceneCoords.y + boxSceneCoords.height / 2,\n  ];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\n// reference: https://eliot-jones.com/2019/12/cubic-bezier-curve-bounding-boxes\nconst getBezierValueForT = (\n  t: number,\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n) => {\n  const oneMinusT = 1 - t;\n  return (\n    Math.pow(oneMinusT, 3) * p0 +\n    3 * Math.pow(oneMinusT, 2) * t * p1 +\n    3 * oneMinusT * Math.pow(t, 2) * p2 +\n    Math.pow(t, 3) * p3\n  );\n};\n\nconst solveQuadratic = (\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n): MaybeQuadraticSolution => {\n  const i = p1 - p0;\n  const j = p2 - p1;\n  const k = p3 - p2;\n\n  const a = 3 * i - 6 * j + 3 * k;\n  const b = 6 * j - 6 * i;\n  const c = 3 * i;\n\n  const sqrtPart = b * b - 4 * a * c;\n  const hasSolution = sqrtPart >= 0;\n\n  if (!hasSolution) {\n    return false;\n  }\n\n  let s1 = null;\n  let s2 = null;\n\n  let t1 = Infinity;\n  let t2 = Infinity;\n\n  if (a === 0) {\n    t1 = t2 = -c / b;\n  } else {\n    t1 = (-b + Math.sqrt(sqrtPart)) / (2 * a);\n    t2 = (-b - Math.sqrt(sqrtPart)) / (2 * a);\n  }\n\n  if (t1 >= 0 && t1 <= 1) {\n    s1 = getBezierValueForT(t1, p0, p1, p2, p3);\n  }\n\n  if (t2 >= 0 && t2 <= 1) {\n    s2 = getBezierValueForT(t2, p0, p1, p2, p3);\n  }\n\n  return [s1, s2];\n};\n\nexport const getCubicBezierCurveBound = (\n  p0: GlobalPoint,\n  p1: GlobalPoint,\n  p2: GlobalPoint,\n  p3: GlobalPoint,\n): Bounds => {\n  const solX = solveQuadratic(p0[0], p1[0], p2[0], p3[0]);\n  const solY = solveQuadratic(p0[1], p1[1], p2[1], p3[1]);\n\n  let minX = Math.min(p0[0], p3[0]);\n  let maxX = Math.max(p0[0], p3[0]);\n\n  if (solX) {\n    const xs = solX.filter((x) => x !== null) as number[];\n    minX = Math.min(minX, ...xs);\n    maxX = Math.max(maxX, ...xs);\n  }\n\n  let minY = Math.min(p0[1], p3[1]);\n  let maxY = Math.max(p0[1], p3[1]);\n  if (solY) {\n    const ys = solY.filter((y) => y !== null) as number[];\n    minY = Math.min(minY, ...ys);\n    maxY = Math.max(maxY, ...ys);\n  }\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (p: GlobalPoint) => GlobalPoint,\n): Bounds => {\n  let currentP: GlobalPoint = pointFrom(0, 0);\n\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        const p: GlobalPoint | undefined = pointFromArray(data);\n        invariant(p != null, \"Op data is not a point\");\n        currentP = p;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        const _p1 = pointFrom<GlobalPoint>(data[0], data[1]);\n        const _p2 = pointFrom<GlobalPoint>(data[2], data[3]);\n        const _p3 = pointFrom<GlobalPoint>(data[4], data[5]);\n\n        const p1 = transformXY ? transformXY(_p1) : _p1;\n        const p2 = transformXY ? transformXY(_p2) : _p2;\n        const p3 = transformXY ? transformXY(_p3) : _p3;\n\n        const p0 = transformXY ? transformXY(currentP) : currentP;\n        currentP = _p3;\n\n        const [minX, minY, maxX, maxY] = getCubicBezierCurveBound(\n          p0,\n          p1,\n          p2,\n          p3,\n        );\n\n        limits.minX = Math.min(limits.minX, minX);\n        limits.minY = Math.min(limits.minY, minY);\n\n        limits.maxX = Math.max(limits.maxX, maxX);\n        limits.maxY = Math.max(limits.maxY, maxY);\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getBoundsFromPoints = (\n  points: ExcalidrawFreeDrawElement[\"points\"],\n): Bounds => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getFreeDrawElementAbsoluteCoords = (\n  element: ExcalidrawFreeDrawElement,\n): [number, number, number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);\n  const x1 = minX + element.x;\n  const y1 = minY + element.y;\n  const x2 = maxX + element.x;\n  const y2 = maxY + element.y;\n  return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];\n};\n\n/** @returns number in pixels */\nexport const getArrowheadSize = (arrowhead: Arrowhead): number => {\n  switch (arrowhead) {\n    case \"arrow\":\n      return 25;\n    case \"diamond\":\n    case \"diamond_outline\":\n      return 12;\n    case \"crowfoot_many\":\n    case \"crowfoot_one\":\n    case \"crowfoot_one_or_many\":\n      return 20;\n    default:\n      return 15;\n  }\n};\n\n/** @returns number in degrees */\nexport const getArrowheadAngle = (arrowhead: Arrowhead): Degrees => {\n  switch (arrowhead) {\n    case \"bar\":\n      return 90 as Degrees;\n    case \"arrow\":\n      return 20 as Degrees;\n    default:\n      return 25 as Degrees;\n  }\n};\n\nexport const getArrowheadPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n) => {\n  if (shape.length < 1) {\n    return null;\n  }\n\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n\n  const data = ops[index].data;\n\n  invariant(data.length === 6, \"Op data length is not 6\");\n\n  const p3 = pointFrom(data[4], data[5]);\n  const p2 = pointFrom(data[2], data[3]);\n  const p1 = pointFrom(data[0], data[1]);\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0 = pointFrom(0, 0);\n  if (prevOp.op === \"move\") {\n    const p = pointFromArray(prevOp.data);\n    invariant(p != null, \"Op data is not a point\");\n    p0 = p;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = pointFrom(prevOp.data[4], prevOp.data[5]);\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = getArrowheadSize(arrowhead);\n\n  let length = 0;\n\n  {\n    // Length for -> arrows is based on the length of the last section\n    const [cx, cy] =\n      position === \"end\"\n        ? element.points[element.points.length - 1]\n        : element.points[0];\n    const [px, py] =\n      element.points.length > 1\n        ? position === \"end\"\n          ? element.points[element.points.length - 2]\n          : element.points[1]\n        : [0, 0];\n\n    length = Math.hypot(cx - px, cy - py);\n  }\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the last segment of the arrowhead\n  const lengthMultiplier =\n    arrowhead === \"diamond\" || arrowhead === \"diamond_outline\" ? 0.25 : 0.5;\n  const minSize = Math.min(size, length * lengthMultiplier);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (\n    arrowhead === \"dot\" ||\n    arrowhead === \"circle\" ||\n    arrowhead === \"circle_outline\"\n  ) {\n    const diameter = Math.hypot(ys - y2, xs - x2) + element.strokeWidth - 2;\n    return [x2, y2, diameter];\n  }\n\n  const angle = getArrowheadAngle(arrowhead);\n\n  if (arrowhead === \"crowfoot_many\" || arrowhead === \"crowfoot_one_or_many\") {\n    // swap (xs, ys) with (x2, y2)\n    const [x3, y3] = pointRotateRads(\n      pointFrom(x2, y2),\n      pointFrom(xs, ys),\n      degreesToRadians(-angle as Degrees),\n    );\n    const [x4, y4] = pointRotateRads(\n      pointFrom(x2, y2),\n      pointFrom(xs, ys),\n      degreesToRadians(angle),\n    );\n    return [xs, ys, x3, y3, x4, y4];\n  }\n\n  // Return points\n  const [x3, y3] = pointRotateRads(\n    pointFrom(xs, ys),\n    pointFrom(x2, y2),\n    ((-angle * Math.PI) / 180) as Radians,\n  );\n  const [x4, y4] = pointRotateRads(\n    pointFrom(xs, ys),\n    pointFrom(x2, y2),\n    degreesToRadians(angle),\n  );\n\n  if (arrowhead === \"diamond\" || arrowhead === \"diamond_outline\") {\n    // point opposite to the arrowhead point\n    let ox;\n    let oy;\n\n    if (position === \"start\") {\n      const [px, py] = element.points.length > 1 ? element.points[1] : [0, 0];\n\n      [ox, oy] = pointRotateRads(\n        pointFrom(x2 + minSize * 2, y2),\n        pointFrom(x2, y2),\n        Math.atan2(py - y2, px - x2) as Radians,\n      );\n    } else {\n      const [px, py] =\n        element.points.length > 1\n          ? element.points[element.points.length - 2]\n          : [0, 0];\n\n      [ox, oy] = pointRotateRads(\n        pointFrom(x2 - minSize * 2, y2),\n        pointFrom(x2, y2),\n        Math.atan2(y2 - py, x2 - px) as Radians,\n      );\n    }\n\n    return [x2, y2, x3, y3, ox, oy, x4, y4];\n  }\n\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst generateLinearElementShape = (\n  element: ExcalidrawLinearElement,\n): Drawable => {\n  const generator = rough.generator();\n  const options = generateRoughOptions(element);\n\n  const method = (() => {\n    if (element.roundness) {\n      return \"curve\";\n    }\n    if (options.fill) {\n      return \"polygon\";\n    }\n    return \"linearPath\";\n  })();\n\n  return generator[method](\n    element.points as Mutable<LocalPoint>[] as RoughPoint[],\n    options,\n  );\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n  elementsMap: ElementsMap,\n): Bounds => {\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n\n  if (element.points.length < 2) {\n    const [pointX, pointY] = element.points[0];\n    const [x, y] = pointRotateRads(\n      pointFrom(element.x + pointX, element.y + pointY),\n      pointFrom(cx, cy),\n      element.angle,\n    );\n\n    let coords: Bounds = [x, y, x, y];\n    if (boundTextElement) {\n      const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(\n        element,\n        elementsMap,\n        [x, y, x, y],\n        boundTextElement,\n      );\n      coords = [\n        coordsWithBoundText[0],\n        coordsWithBoundText[1],\n        coordsWithBoundText[2],\n        coordsWithBoundText[3],\n      ];\n    }\n    return coords;\n  }\n\n  // first element is always the curve\n  const cachedShape = ShapeCache.get(element)?.[0];\n  const shape = cachedShape ?? generateLinearElementShape(element);\n  const ops = getCurvePathOps(shape);\n  const transformXY = ([x, y]: GlobalPoint) =>\n    pointRotateRads<GlobalPoint>(\n      pointFrom(element.x + x, element.y + y),\n      pointFrom(cx, cy),\n      element.angle,\n    );\n  const res = getMinMaxXYFromCurvePathOps(ops, transformXY);\n  let coords: Bounds = [res[0], res[1], res[2], res[3]];\n  if (boundTextElement) {\n    const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(\n      element,\n      elementsMap,\n      coords,\n      boundTextElement,\n    );\n    coords = [\n      coordsWithBoundText[0],\n      coordsWithBoundText[1],\n      coordsWithBoundText[2],\n      coordsWithBoundText[3],\n    ];\n  }\n  return coords;\n};\n\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  nonRotated: boolean = false,\n): Bounds => {\n  return ElementBounds.getBounds(element, elementsMap, nonRotated);\n};\n\nexport const getCommonBounds = (\n  elements: ElementsMapOrArray,\n  elementsMap?: ElementsMap,\n): Bounds => {\n  if (!sizeOf(elements)) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  const _elementsMap = elementsMap || arrayToMap(elements);\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element, _elementsMap);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getDraggedElementsBounds = (\n  elements: ExcalidrawElement[],\n  dragOffset: { x: number; y: number },\n) => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return [\n    minX + dragOffset.x,\n    minY + dragOffset.y,\n    maxX + dragOffset.x,\n    maxY + dragOffset.y,\n  ];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n  normalizePoints: boolean,\n): Bounds => {\n  if (!(isLinearElement(element) || isFreeDrawElement(element))) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points, normalizePoints),\n    normalizePoints,\n  );\n\n  let bounds: Bounds;\n\n  if (isFreeDrawElement(element)) {\n    // Free Draw\n    bounds = getBoundsFromPoints(points);\n  } else {\n    // Line\n    const gen = rough.generator();\n    const curve = !element.roundness\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n\n    const ops = getCurvePathOps(curve);\n    bounds = getMinMaxXYFromCurvePathOps(ops);\n  }\n\n  const [minX, minY, maxX, maxY] = bounds;\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n): Bounds => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve =\n    element.roundness == null\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): Bounds => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n  const elementsMap = arrayToMap(elements);\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);\n    const distance = pointDistance(\n      pointFrom((x1 + x2) / 2, (y1 + y2) / 2),\n      pointFrom(from.x, from.y),\n    );\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement, elementsMap);\n};\n\nexport interface BoundingBox {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  midX: number;\n  midY: number;\n  width: number;\n  height: number;\n}\n\nexport const getCommonBoundingBox = (\n  elements: ExcalidrawElement[] | readonly NonDeleted<ExcalidrawElement>[],\n): BoundingBox => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2,\n  };\n};\n\n/**\n * returns scene coords of user's editor viewport (visible canvas area) bounds\n */\nexport const getVisibleSceneBounds = ({\n  scrollX,\n  scrollY,\n  width,\n  height,\n  zoom,\n}: AppState): SceneBounds => {\n  return [\n    -scrollX,\n    -scrollY,\n    -scrollX + width / zoom.value,\n    -scrollY + height / zoom.value,\n  ];\n};\n\nexport const getCenterForBounds = (bounds: Bounds): GlobalPoint =>\n  pointFrom(\n    bounds[0] + (bounds[2] - bounds[0]) / 2,\n    bounds[1] + (bounds[3] - bounds[1]) / 2,\n  );\n\n/**\n * Get the axis-aligned bounding box for a given element\n */\nexport const aabbForElement = (\n  element: Readonly<ExcalidrawElement>,\n  elementsMap: ElementsMap,\n  offset?: [number, number, number, number],\n) => {\n  const bbox = {\n    minX: element.x,\n    minY: element.y,\n    maxX: element.x + element.width,\n    maxY: element.y + element.height,\n    midX: element.x + element.width / 2,\n    midY: element.y + element.height / 2,\n  };\n\n  const center = elementCenterPoint(element, elementsMap);\n  const [topLeftX, topLeftY] = pointRotateRads(\n    pointFrom(bbox.minX, bbox.minY),\n    center,\n    element.angle,\n  );\n  const [topRightX, topRightY] = pointRotateRads(\n    pointFrom(bbox.maxX, bbox.minY),\n    center,\n    element.angle,\n  );\n  const [bottomRightX, bottomRightY] = pointRotateRads(\n    pointFrom(bbox.maxX, bbox.maxY),\n    center,\n    element.angle,\n  );\n  const [bottomLeftX, bottomLeftY] = pointRotateRads(\n    pointFrom(bbox.minX, bbox.maxY),\n    center,\n    element.angle,\n  );\n\n  const bounds = [\n    Math.min(topLeftX, topRightX, bottomRightX, bottomLeftX),\n    Math.min(topLeftY, topRightY, bottomRightY, bottomLeftY),\n    Math.max(topLeftX, topRightX, bottomRightX, bottomLeftX),\n    Math.max(topLeftY, topRightY, bottomRightY, bottomLeftY),\n  ] as Bounds;\n\n  if (offset) {\n    const [topOffset, rightOffset, downOffset, leftOffset] = offset;\n    return [\n      bounds[0] - leftOffset,\n      bounds[1] - topOffset,\n      bounds[2] + rightOffset,\n      bounds[3] + downOffset,\n    ] as Bounds;\n  }\n\n  return bounds;\n};\n\nexport const pointInsideBounds = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  bounds: Bounds,\n): boolean =>\n  p[0] > bounds[0] && p[0] < bounds[2] && p[1] > bounds[1] && p[1] < bounds[3];\n\nexport const doBoundsIntersect = (\n  bounds1: Bounds | null,\n  bounds2: Bounds | null,\n): boolean => {\n  if (bounds1 == null || bounds2 == null) {\n    return false;\n  }\n\n  const [minX1, minY1, maxX1, maxY1] = bounds1;\n  const [minX2, minY2, maxX2, maxY2] = bounds2;\n\n  return minX1 < maxX2 && maxX1 > minX2 && minY1 < maxY2 && maxY1 > minY2;\n};\n\nexport const elementCenterPoint = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  xOffset: number = 0,\n  yOffset: number = 0,\n) => {\n  const [x, y] = getCenterForBounds(getElementBounds(element, elementsMap));\n\n  return pointFrom<GlobalPoint>(x + xOffset, y + yOffset);\n};\n",
    "import { RoughCanvas } from './canvas';\nimport { RoughGenerator } from './generator';\nimport { RoughSVG } from './svg';\nexport default {\n    canvas(canvas, config) {\n        return new RoughCanvas(canvas, config);\n    },\n    svg(svg, config) {\n        return new RoughSVG(svg, config);\n    },\n    generator(config) {\n        return new RoughGenerator(config);\n    },\n    newSeed() {\n        return RoughGenerator.newSeed();\n    },\n};\n",
    "import { RoughGenerator } from './generator';\nexport class RoughCanvas {\n    constructor(canvas, config) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n        this.gen = new RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    if (o.strokeLineDash) {\n                        ctx.setLineDash(o.strokeLineDash);\n                    }\n                    if (o.strokeLineDashOffset) {\n                        ctx.lineDashOffset = o.strokeLineDashOffset;\n                    }\n                    this._drawToContext(ctx, drawing, precision);\n                    ctx.restore();\n                    break;\n                case 'fillPath': {\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    const fillRule = (drawable.shape === 'curve' || drawable.shape === 'polygon' || drawable.shape === 'path') ? 'evenodd' : 'nonzero';\n                    this._drawToContext(ctx, drawing, precision, fillRule);\n                    ctx.restore();\n                    break;\n                }\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n            }\n        }\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        if (o.fillLineDash) {\n            ctx.setLineDash(o.fillLineDash);\n        }\n        if (o.fillLineDashOffset) {\n            ctx.lineDashOffset = o.fillLineDashOffset;\n        }\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing, o.fixedDecimalPlaceDigits);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing, fixedDecimals, rule = 'nonzero') {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill(rule);\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n",
    "import { line, solidFillPolygon, patternFillPolygons, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math.js';\nimport { curveToBezier } from 'points-on-curve/lib/curve-to-bezier.js';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { pointsOnPath } from 'points-on-path';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n            fillShapeRoughnessGain: 0.8,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = arc(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = curve(points, o);\n        if (o.fill && o.fill !== NOS && points.length >= 3) {\n            if (o.fillStyle === 'solid') {\n                const fillShape = curve(points, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                paths.push({\n                    type: 'fillPath',\n                    ops: this._mergedShape(fillShape.ops),\n                });\n            }\n            else {\n                const bcurve = curveToBezier(points);\n                const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o.roughness) / 2);\n                paths.push(patternFillPolygons([polyPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon([points], o));\n            }\n            else {\n                paths.push(patternFillPolygons([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification || 1)) : ((1 + o.roughness) / 2);\n        const sets = pointsOnPath(d, 1, distance);\n        const shape = svgPath(d, o);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                if (sets.length === 1) {\n                    const fillShape = svgPath(d, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                    paths.push({\n                        type: 'fillPath',\n                        ops: this._mergedShape(fillShape.ops),\n                    });\n                }\n                else {\n                    paths.push(solidFillPolygon(sets, o));\n                }\n            }\n            else {\n                paths.push(patternFillPolygons(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push(linearPath(set, false, o));\n                });\n            }\n            else {\n                paths.push(shape);\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n    _mergedShape(input) {\n        return input.filter((d, i) => {\n            if (i === 0) {\n                return true;\n            }\n            if (d.op === 'move') {\n                return false;\n            }\n            return true;\n        });\n    }\n}\n",
    "import { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nimport { parsePath, normalize, absolutize } from 'path-data-parser';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nexport function curve(points, o) {\n    let o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n    if (!o.disableMultiStroke) {\n        const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        o1 = o1.concat(o2);\n    }\n    return { type: 'path', ops: o1 };\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    const segments = normalize(absolutize(parsePath(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygons(polygonList, o) {\n    return getFiller(o, helper).fillPolygons(polygonList, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n",
    "import { HachureFiller } from './hachure-filler';\nimport { ZigZagFiller } from './zigzag-filler';\nimport { HatchFiller } from './hatch-filler';\nimport { DotFiller } from './dot-filler';\nimport { DashedFiller } from './dashed-filler';\nimport { ZigZagLineFiller } from './zigzag-line-filler';\nconst fillers = {};\nexport function getFiller(o, helper) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagFiller(helper);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HatchFiller(helper);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DotFiller(helper);\n                }\n                break;\n            case 'dashed':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DashedFiller(helper);\n                }\n                break;\n            case 'zigzag-line':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagLineFiller(helper);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HachureFiller(helper);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n",
    "import { polygonHachureLines } from './scan-line-hachure';\nexport class HachureFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        return this._fillPolygons(polygonList, o);\n    }\n    _fillPolygons(polygonList, o) {\n        const lines = polygonHachureLines(polygonList, o);\n        const ops = this.renderLines(lines, o);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o) {\n        const ops = [];\n        for (const line of lines) {\n            ops.push(...this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o));\n        }\n        return ops;\n    }\n}\n",
    "import { hachureLines } from 'hachure-fill';\nexport function polygonHachureLines(polygonList, o) {\n    var _a;\n    const angle = o.hachureAngle + 90;\n    let gap = o.hachureGap;\n    if (gap < 0) {\n        gap = o.strokeWidth * 4;\n    }\n    gap = Math.max(gap, 0.1);\n    let skipOffset = 1;\n    if (o.roughness >= 1) {\n        if ((((_a = o.randomizer) === null || _a === void 0 ? void 0 : _a.next()) || Math.random()) > 0.7) {\n            skipOffset = gap;\n        }\n    }\n    return hachureLines(polygonList, gap, angle, skipOffset || 1);\n}\n",
    "function rotatePoints(points, center, degrees) {\n    if (points && points.length) {\n        const [cx, cy] = center;\n        const angle = (Math.PI / 180) * degrees;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        for (const p of points) {\n            const [x, y] = p;\n            p[0] = ((x - cx) * cos) - ((y - cy) * sin) + cx;\n            p[1] = ((x - cx) * sin) + ((y - cy) * cos) + cy;\n        }\n    }\n}\nfunction rotateLines(lines, center, degrees) {\n    const points = [];\n    lines.forEach((line) => points.push(...line));\n    rotatePoints(points, center, degrees);\n}\nfunction areSamePoints(p1, p2) {\n    return p1[0] === p2[0] && p1[1] === p2[1];\n}\nexport function hachureLines(polygons, hachureGap, hachureAngle, hachureStepOffset = 1) {\n    const angle = hachureAngle;\n    const gap = Math.max(hachureGap, 0.1);\n    const polygonList = (polygons[0] && polygons[0][0] && (typeof polygons[0][0] === 'number')) ? [polygons] : polygons;\n    const rotationCenter = [0, 0];\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, angle);\n        }\n    }\n    const lines = straightHachureLines(polygonList, gap, hachureStepOffset);\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, -angle);\n        }\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(polygons, gap, hachureStepOffset) {\n    const vertexArray = [];\n    for (const polygon of polygons) {\n        const vertices = [...polygon];\n        if (!areSamePoints(vertices[0], vertices[vertices.length - 1])) {\n            vertices.push([vertices[0][0], vertices[0][1]]);\n        }\n        if (vertices.length > 2) {\n            vertexArray.push(vertices);\n        }\n    }\n    const lines = [];\n    gap = Math.max(gap, 0.1);\n    // Create sorted edges table\n    const edges = [];\n    for (const vertices of vertexArray) {\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1]),\n                });\n            }\n        }\n    }\n    edges.sort((e1, e2) => {\n        if (e1.ymin < e2.ymin) {\n            return -1;\n        }\n        if (e1.ymin > e2.ymin) {\n            return 1;\n        }\n        if (e1.x < e2.x) {\n            return -1;\n        }\n        if (e1.x > e2.x) {\n            return 1;\n        }\n        if (e1.ymax === e2.ymax) {\n            return 0;\n        }\n        return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n    });\n    if (!edges.length) {\n        return lines;\n    }\n    // Start scanning\n    let activeEdges = [];\n    let y = edges[0].ymin;\n    let iteration = 0;\n    while (activeEdges.length || edges.length) {\n        if (edges.length) {\n            let ix = -1;\n            for (let i = 0; i < edges.length; i++) {\n                if (edges[i].ymin > y) {\n                    break;\n                }\n                ix = i;\n            }\n            const removed = edges.splice(0, ix + 1);\n            removed.forEach((edge) => {\n                activeEdges.push({ s: y, edge });\n            });\n        }\n        activeEdges = activeEdges.filter((ae) => {\n            if (ae.edge.ymax <= y) {\n                return false;\n            }\n            return true;\n        });\n        activeEdges.sort((ae1, ae2) => {\n            if (ae1.edge.x === ae2.edge.x) {\n                return 0;\n            }\n            return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n        });\n        // fill between the edges\n        if ((hachureStepOffset !== 1) || (iteration % gap === 0)) {\n            if (activeEdges.length > 1) {\n                for (let i = 0; i < activeEdges.length; i = i + 2) {\n                    const nexti = i + 1;\n                    if (nexti >= activeEdges.length) {\n                        break;\n                    }\n                    const ce = activeEdges[i].edge;\n                    const ne = activeEdges[nexti].edge;\n                    lines.push([\n                        [Math.round(ce.x), y],\n                        [Math.round(ne.x), y],\n                    ]);\n                }\n            }\n        }\n        y += hachureStepOffset;\n        activeEdges.forEach((ae) => {\n            ae.edge.x = ae.edge.x + (hachureStepOffset * ae.edge.islope);\n        });\n        iteration++;\n    }\n    return lines;\n}\n",
    "import { HachureFiller } from './hachure-filler';\nimport { polygonHachureLines } from './scan-line-hachure';\nimport { lineLength } from '../geometry';\nexport class ZigZagFiller extends HachureFiller {\n    fillPolygons(polygonList, o) {\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const o2 = Object.assign({}, o, { hachureGap: gap });\n        const lines = polygonHachureLines(polygonList, o2);\n        const zigZagAngle = (Math.PI / 180) * o.hachureAngle;\n        const zigzagLines = [];\n        const dgx = gap * 0.5 * Math.cos(zigZagAngle);\n        const dgy = gap * 0.5 * Math.sin(zigZagAngle);\n        for (const [p1, p2] of lines) {\n            if (lineLength([p1, p2])) {\n                zigzagLines.push([\n                    [p1[0] - dgx, p1[1] + dgy],\n                    [...p2],\n                ], [\n                    [p1[0] + dgx, p1[1] - dgy],\n                    [...p2],\n                ]);\n            }\n        }\n        const ops = this.renderLines(zigzagLines, o);\n        return { type: 'fillSketch', ops };\n    }\n}\n",
    "export function lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\n",
    "import { HachureFiller } from './hachure-filler';\nexport class HatchFiller extends HachureFiller {\n    fillPolygons(polygonList, o) {\n        const set = this._fillPolygons(polygonList, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygons(polygonList, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n",
    "import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DotFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        o = Object.assign({}, o, { hachureAngle: 0 });\n        const lines = polygonHachureLines(polygonList, o);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        const ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const ro = gap / 4;\n        for (const line of lines) {\n            const length = lineLength(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const offset = length - (count * gap);\n            const x = ((line[0][0] + line[1][0]) / 2) - (gap / 4);\n            const minY = Math.min(line[0][1], line[1][1]);\n            for (let i = 0; i < count; i++) {\n                const y = minY + offset + (i * gap);\n                const cx = (x - ro) + Math.random() * 2 * ro;\n                const cy = (y - ro) + Math.random() * 2 * ro;\n                const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n                ops.push(...el.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n",
    "import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const lines = polygonHachureLines(polygonList, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        const ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n",
    "import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class ZigZagLineFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const gap = o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap;\n        const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n        o = Object.assign({}, o, { hachureGap: gap + zo });\n        const lines = polygonHachureLines(polygonList, o);\n        return { type: 'fillSketch', ops: this.zigzagLines(lines, zo, o) };\n    }\n    zigzagLines(lines, zo, o) {\n        const ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.round(length / (2 * zo));\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * 2 * zo;\n                const lend = (i + 1) * 2 * zo;\n                const dz = Math.sqrt(2 * Math.pow(zo, 2));\n                const start = [p1[0] + (lstart * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha)];\n                const end = [p1[0] + (lend * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha))];\n                const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o), ...this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n",
    "export function randomSeed() {\n    return Math.floor(Math.random() * 2 ** 31);\n}\nexport class Random {\n    constructor(seed) {\n        this.seed = seed;\n    }\n    next() {\n        if (this.seed) {\n            return ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;\n        }\n        else {\n            return Math.random();\n        }\n    }\n}\n",
    "export { parsePath, serialize } from './parser.js';\nexport { absolutize } from './absolutize.js';\nexport { normalize } from './normalize.js';\n",
    "const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };\nfunction tokenize(d) {\n    const tokens = new Array();\n    while (d !== '') {\n        if (d.match(/^([ \\t\\r\\n,]+)/)) {\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n            tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n            tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };\n            d = d.substr(RegExp.$1.length);\n        }\n        else {\n            return [];\n        }\n    }\n    tokens[tokens.length] = { type: EOD, text: '' };\n    return tokens;\n}\nfunction isType(token, type) {\n    return token.type === type;\n}\nexport function parsePath(d) {\n    const segments = [];\n    const tokens = tokenize(d);\n    let mode = 'BOD';\n    let index = 0;\n    let token = tokens[index];\n    while (!isType(token, EOD)) {\n        let paramsCount = 0;\n        const params = [];\n        if (mode === 'BOD') {\n            if (token.text === 'M' || token.text === 'm') {\n                index++;\n                paramsCount = PARAMS[token.text];\n                mode = token.text;\n            }\n            else {\n                return parsePath('M0,0' + d);\n            }\n        }\n        else if (isType(token, NUMBER)) {\n            paramsCount = PARAMS[mode];\n        }\n        else {\n            index++;\n            paramsCount = PARAMS[token.text];\n            mode = token.text;\n        }\n        if ((index + paramsCount) < tokens.length) {\n            for (let i = index; i < index + paramsCount; i++) {\n                const numbeToken = tokens[i];\n                if (isType(numbeToken, NUMBER)) {\n                    params[params.length] = +numbeToken.text;\n                }\n                else {\n                    throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n                }\n            }\n            if (typeof PARAMS[mode] === 'number') {\n                const segment = { key: mode, data: params };\n                segments.push(segment);\n                index += paramsCount;\n                token = tokens[index];\n                if (mode === 'M')\n                    mode = 'L';\n                if (mode === 'm')\n                    mode = 'l';\n            }\n            else {\n                throw new Error('Bad segment: ' + mode);\n            }\n        }\n        else {\n            throw new Error('Path data ended short');\n        }\n    }\n    return segments;\n}\nexport function serialize(segments) {\n    const tokens = [];\n    for (const { key, data } of segments) {\n        tokens.push(key);\n        switch (key) {\n            case 'C':\n            case 'c':\n                tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n                break;\n            case 'S':\n            case 's':\n            case 'Q':\n            case 'q':\n                tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n                break;\n            default:\n                tokens.push(...data);\n                break;\n        }\n    }\n    return tokens.join(' ');\n}\n",
    "// Translate relative commands to absolute commands\nexport function absolutize(segments) {\n    let cx = 0, cy = 0;\n    let subx = 0, suby = 0;\n    const out = [];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M':\n                out.push({ key: 'M', data: [...data] });\n                [cx, cy] = data;\n                [subx, suby] = data;\n                break;\n            case 'm':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'M', data: [cx, cy] });\n                subx = cx;\n                suby = cy;\n                break;\n            case 'L':\n                out.push({ key: 'L', data: [...data] });\n                [cx, cy] = data;\n                break;\n            case 'l':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'C':\n                out.push({ key: 'C', data: [...data] });\n                cx = data[4];\n                cy = data[5];\n                break;\n            case 'c': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'C', data: newdata });\n                cx = newdata[4];\n                cy = newdata[5];\n                break;\n            }\n            case 'Q':\n                out.push({ key: 'Q', data: [...data] });\n                cx = data[2];\n                cy = data[3];\n                break;\n            case 'q': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'Q', data: newdata });\n                cx = newdata[2];\n                cy = newdata[3];\n                break;\n            }\n            case 'A':\n                out.push({ key: 'A', data: [...data] });\n                cx = data[5];\n                cy = data[6];\n                break;\n            case 'a':\n                cx += data[5];\n                cy += data[6];\n                out.push({ key: 'A', data: [data[0], data[1], data[2], data[3], data[4], cx, cy] });\n                break;\n            case 'H':\n                out.push({ key: 'H', data: [...data] });\n                cx = data[0];\n                break;\n            case 'h':\n                cx += data[0];\n                out.push({ key: 'H', data: [cx] });\n                break;\n            case 'V':\n                out.push({ key: 'V', data: [...data] });\n                cy = data[0];\n                break;\n            case 'v':\n                cy += data[0];\n                out.push({ key: 'V', data: [cy] });\n                break;\n            case 'S':\n                out.push({ key: 'S', data: [...data] });\n                cx = data[2];\n                cy = data[3];\n                break;\n            case 's': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'S', data: newdata });\n                cx = newdata[2];\n                cy = newdata[3];\n                break;\n            }\n            case 'T':\n                out.push({ key: 'T', data: [...data] });\n                cx = data[0];\n                cy = data[1];\n                break;\n            case 't':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'T', data: [cx, cy] });\n                break;\n            case 'Z':\n            case 'z':\n                out.push({ key: 'Z', data: [] });\n                cx = subx;\n                cy = suby;\n                break;\n        }\n    }\n    return out;\n}\n",
    "// Normalize path to include only M, L, C, and Z commands\nexport function normalize(segments) {\n    const out = [];\n    let lastType = '';\n    let cx = 0, cy = 0;\n    let subx = 0, suby = 0;\n    let lcx = 0, lcy = 0;\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M':\n                out.push({ key: 'M', data: [...data] });\n                [cx, cy] = data;\n                [subx, suby] = data;\n                break;\n            case 'C':\n                out.push({ key: 'C', data: [...data] });\n                cx = data[4];\n                cy = data[5];\n                lcx = data[2];\n                lcy = data[3];\n                break;\n            case 'L':\n                out.push({ key: 'L', data: [...data] });\n                [cx, cy] = data;\n                break;\n            case 'H':\n                cx = data[0];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'V':\n                cy = data[0];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'S': {\n                let cx1 = 0, cy1 = 0;\n                if (lastType === 'C' || lastType === 'S') {\n                    cx1 = cx + (cx - lcx);\n                    cy1 = cy + (cy - lcy);\n                }\n                else {\n                    cx1 = cx;\n                    cy1 = cy;\n                }\n                out.push({ key: 'C', data: [cx1, cy1, ...data] });\n                lcx = data[0];\n                lcy = data[1];\n                cx = data[2];\n                cy = data[3];\n                break;\n            }\n            case 'T': {\n                const [x, y] = data;\n                let x1 = 0, y1 = 0;\n                if (lastType === 'Q' || lastType === 'T') {\n                    x1 = cx + (cx - lcx);\n                    y1 = cy + (cy - lcy);\n                }\n                else {\n                    x1 = cx;\n                    y1 = cy;\n                }\n                const cx1 = cx + 2 * (x1 - cx) / 3;\n                const cy1 = cy + 2 * (y1 - cy) / 3;\n                const cx2 = x + 2 * (x1 - x) / 3;\n                const cy2 = y + 2 * (y1 - y) / 3;\n                out.push({ key: 'C', data: [cx1, cy1, cx2, cy2, x, y] });\n                lcx = x1;\n                lcy = y1;\n                cx = x;\n                cy = y;\n                break;\n            }\n            case 'Q': {\n                const [x1, y1, x, y] = data;\n                const cx1 = cx + 2 * (x1 - cx) / 3;\n                const cy1 = cy + 2 * (y1 - cy) / 3;\n                const cx2 = x + 2 * (x1 - x) / 3;\n                const cy2 = y + 2 * (y1 - y) / 3;\n                out.push({ key: 'C', data: [cx1, cy1, cx2, cy2, x, y] });\n                lcx = x1;\n                lcy = y1;\n                cx = x;\n                cy = y;\n                break;\n            }\n            case 'A': {\n                const r1 = Math.abs(data[0]);\n                const r2 = Math.abs(data[1]);\n                const angle = data[2];\n                const largeArcFlag = data[3];\n                const sweepFlag = data[4];\n                const x = data[5];\n                const y = data[6];\n                if (r1 === 0 || r2 === 0) {\n                    out.push({ key: 'C', data: [cx, cy, x, y, x, y] });\n                    cx = x;\n                    cy = y;\n                }\n                else {\n                    if (cx !== x || cy !== y) {\n                        const curves = arcToCubicCurves(cx, cy, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n                        curves.forEach(function (curve) {\n                            out.push({ key: 'C', data: curve });\n                        });\n                        cx = x;\n                        cy = y;\n                    }\n                }\n                break;\n            }\n            case 'Z':\n                out.push({ key: 'Z', data: [] });\n                cx = subx;\n                cy = suby;\n                break;\n        }\n        lastType = key;\n    }\n    return out;\n}\nfunction degToRad(degrees) {\n    return (Math.PI * degrees) / 180;\n}\nfunction rotate(x, y, angleRad) {\n    const X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\n    const Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\n    return [X, Y];\n}\nfunction arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, recursive) {\n    const angleRad = degToRad(angle);\n    let params = [];\n    let f1 = 0, f2 = 0, cx = 0, cy = 0;\n    if (recursive) {\n        [f1, f2, cx, cy] = recursive;\n    }\n    else {\n        [x1, y1] = rotate(x1, y1, -angleRad);\n        [x2, y2] = rotate(x2, y2, -angleRad);\n        const x = (x1 - x2) / 2;\n        const y = (y1 - y2) / 2;\n        let h = (x * x) / (r1 * r1) + (y * y) / (r2 * r2);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            r1 = h * r1;\n            r2 = h * r2;\n        }\n        const sign = (largeArcFlag === sweepFlag) ? -1 : 1;\n        const r1Pow = r1 * r1;\n        const r2Pow = r2 * r2;\n        const left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;\n        const right = r1Pow * y * y + r2Pow * x * x;\n        const k = sign * Math.sqrt(Math.abs(left / right));\n        cx = k * r1 * y / r2 + (x1 + x2) / 2;\n        cy = k * -r2 * x / r1 + (y1 + y2) / 2;\n        f1 = Math.asin(parseFloat(((y1 - cy) / r2).toFixed(9)));\n        f2 = Math.asin(parseFloat(((y2 - cy) / r2).toFixed(9)));\n        if (x1 < cx) {\n            f1 = Math.PI - f1;\n        }\n        if (x2 < cx) {\n            f2 = Math.PI - f2;\n        }\n        if (f1 < 0) {\n            f1 = Math.PI * 2 + f1;\n        }\n        if (f2 < 0) {\n            f2 = Math.PI * 2 + f2;\n        }\n        if (sweepFlag && f1 > f2) {\n            f1 = f1 - Math.PI * 2;\n        }\n        if (!sweepFlag && f2 > f1) {\n            f2 = f2 - Math.PI * 2;\n        }\n    }\n    let df = f2 - f1;\n    if (Math.abs(df) > (Math.PI * 120 / 180)) {\n        const f2old = f2;\n        const x2old = x2;\n        const y2old = y2;\n        if (sweepFlag && f2 > f1) {\n            f2 = f1 + (Math.PI * 120 / 180) * (1);\n        }\n        else {\n            f2 = f1 + (Math.PI * 120 / 180) * (-1);\n        }\n        x2 = cx + r1 * Math.cos(f2);\n        y2 = cy + r2 * Math.sin(f2);\n        params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    const c1 = Math.cos(f1);\n    const s1 = Math.sin(f1);\n    const c2 = Math.cos(f2);\n    const s2 = Math.sin(f2);\n    const t = Math.tan(df / 4);\n    const hx = 4 / 3 * r1 * t;\n    const hy = 4 / 3 * r2 * t;\n    const m1 = [x1, y1];\n    const m2 = [x1 + hx * s1, y1 - hy * c1];\n    const m3 = [x2 + hx * s2, y2 - hy * c2];\n    const m4 = [x2, y2];\n    m2[0] = 2 * m1[0] - m2[0];\n    m2[1] = 2 * m1[1] - m2[1];\n    if (recursive) {\n        return [m2, m3, m4].concat(params);\n    }\n    else {\n        params = [m2, m3, m4].concat(params);\n        const curves = [];\n        for (let i = 0; i < params.length; i += 3) {\n            const r1 = rotate(params[i][0], params[i][1], angleRad);\n            const r2 = rotate(params[i + 1][0], params[i + 1][1], angleRad);\n            const r3 = rotate(params[i + 2][0], params[i + 2][1], angleRad);\n            curves.push([r1[0], r1[1], r2[0], r2[1], r3[0], r3[1]]);\n        }\n        return curves;\n    }\n}\n",
    "function clone(p) {\n    return [...p];\n}\nexport function curveToBezier(pointsIn, curveTightness = 0) {\n    const len = pointsIn.length;\n    if (len < 3) {\n        throw new Error('A curve must have at least three points.');\n    }\n    const out = [];\n    if (len === 3) {\n        out.push(clone(pointsIn[0]), clone(pointsIn[1]), clone(pointsIn[2]), clone(pointsIn[2]));\n    }\n    else {\n        const points = [];\n        points.push(pointsIn[0], pointsIn[0]);\n        for (let i = 1; i < pointsIn.length; i++) {\n            points.push(pointsIn[i]);\n            if (i === (pointsIn.length - 1)) {\n                points.push(pointsIn[i]);\n            }\n        }\n        const b = [];\n        const s = 1 - curveTightness;\n        out.push(clone(points[0]));\n        for (let i = 1; (i + 2) < points.length; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            out.push(b[1], b[2], b[3]);\n        }\n    }\n    return out;\n}\n",
    "// distance between 2 points\nfunction distance(p1, p2) {\n    return Math.sqrt(distanceSq(p1, p2));\n}\n// distance between 2 points squared\nfunction distanceSq(p1, p2) {\n    return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n}\n// Sistance squared from a point p to the line segment vw\nfunction distanceToSegmentSq(p, v, w) {\n    const l2 = distanceSq(v, w);\n    if (l2 === 0) {\n        return distanceSq(p, v);\n    }\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    return distanceSq(p, lerp(v, w, t));\n}\nfunction lerp(a, b, t) {\n    return [\n        a[0] + (b[0] - a[0]) * t,\n        a[1] + (b[1] - a[1]) * t,\n    ];\n}\n// Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\nfunction flatness(points, offset) {\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n    ux *= ux;\n    let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n    uy *= uy;\n    let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n    vx *= vx;\n    let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n    vy *= vy;\n    if (ux < vx) {\n        ux = vx;\n    }\n    if (uy < vy) {\n        uy = vy;\n    }\n    return ux + uy;\n}\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n    const outPoints = newPoints || [];\n    if (flatness(points, offset) < tolerance) {\n        const p0 = points[offset + 0];\n        if (outPoints.length) {\n            const d = distance(outPoints[outPoints.length - 1], p0);\n            if (d > 1) {\n                outPoints.push(p0);\n            }\n        }\n        else {\n            outPoints.push(p0);\n        }\n        outPoints.push(points[offset + 3]);\n    }\n    else {\n        // subdivide\n        const t = .5;\n        const p1 = points[offset + 0];\n        const p2 = points[offset + 1];\n        const p3 = points[offset + 2];\n        const p4 = points[offset + 3];\n        const q1 = lerp(p1, p2, t);\n        const q2 = lerp(p2, p3, t);\n        const q3 = lerp(p3, p4, t);\n        const r1 = lerp(q1, q2, t);\n        const r2 = lerp(q2, q3, t);\n        const red = lerp(r1, r2, t);\n        getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n        getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n    }\n    return outPoints;\n}\nexport function simplify(points, distance) {\n    return simplifyPoints(points, 0, points.length, distance);\n}\n// Ramer–Douglas–Peucker algorithm\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\n    const outPoints = newPoints || [];\n    // find the most distance point from the endpoints\n    const s = points[start];\n    const e = points[end - 1];\n    let maxDistSq = 0;\n    let maxNdx = 1;\n    for (let i = start + 1; i < end - 1; ++i) {\n        const distSq = distanceToSegmentSq(points[i], s, e);\n        if (distSq > maxDistSq) {\n            maxDistSq = distSq;\n            maxNdx = i;\n        }\n    }\n    // if that point is too far, split\n    if (Math.sqrt(maxDistSq) > epsilon) {\n        simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\n        simplifyPoints(points, maxNdx, end, epsilon, outPoints);\n    }\n    else {\n        if (!outPoints.length) {\n            outPoints.push(s);\n        }\n        outPoints.push(e);\n    }\n    return outPoints;\n}\nexport function pointsOnBezierCurves(points, tolerance = 0.15, distance) {\n    const newPoints = [];\n    const numSegments = (points.length - 1) / 3;\n    for (let i = 0; i < numSegments; i++) {\n        const offset = i * 3;\n        getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n    }\n    if (distance && distance > 0) {\n        return simplifyPoints(newPoints, 0, newPoints.length, distance);\n    }\n    return newPoints;\n}\n",
    "import { pointsOnBezierCurves, simplify } from 'points-on-curve';\nimport { parsePath, absolutize, normalize } from 'path-data-parser';\nexport function pointsOnPath(path, tolerance, distance) {\n    const segments = parsePath(path);\n    const normalized = normalize(absolutize(segments));\n    const sets = [];\n    let currentPoints = [];\n    let start = [0, 0];\n    let pendingCurve = [];\n    const appendPendingCurve = () => {\n        if (pendingCurve.length >= 4) {\n            currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));\n        }\n        pendingCurve = [];\n    };\n    const appendPendingPoints = () => {\n        appendPendingCurve();\n        if (currentPoints.length) {\n            sets.push(currentPoints);\n            currentPoints = [];\n        }\n    };\n    for (const { key, data } of normalized) {\n        switch (key) {\n            case 'M':\n                appendPendingPoints();\n                start = [data[0], data[1]];\n                currentPoints.push(start);\n                break;\n            case 'L':\n                appendPendingCurve();\n                currentPoints.push([data[0], data[1]]);\n                break;\n            case 'C':\n                if (!pendingCurve.length) {\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\n                }\n                pendingCurve.push([data[0], data[1]]);\n                pendingCurve.push([data[2], data[3]]);\n                pendingCurve.push([data[4], data[5]]);\n                break;\n            case 'Z':\n                appendPendingCurve();\n                currentPoints.push([start[0], start[1]]);\n                break;\n        }\n    }\n    appendPendingPoints();\n    if (!distance) {\n        return sets;\n    }\n    const out = [];\n    for (const set of sets) {\n        const simplifiedSet = simplify(set, distance);\n        if (simplifiedSet.length) {\n            out.push(simplifiedSet);\n        }\n    }\n    return out;\n}\n",
    "import { SVGNS } from './core';\nimport { RoughGenerator } from './generator';\nexport class RoughSVG {\n    constructor(svg, config) {\n        this.svg = svg;\n        this.gen = new RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const doc = this.svg.ownerDocument || window.document;\n        const g = doc.createElementNS(SVGNS, 'g');\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path': {\n                    path = doc.createElementNS(SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', o.stroke);\n                    path.setAttribute('stroke-width', o.strokeWidth + '');\n                    path.setAttribute('fill', 'none');\n                    if (o.strokeLineDash) {\n                        path.setAttribute('stroke-dasharray', o.strokeLineDash.join(' ').trim());\n                    }\n                    if (o.strokeLineDashOffset) {\n                        path.setAttribute('stroke-dashoffset', `${o.strokeLineDashOffset}`);\n                    }\n                    break;\n                }\n                case 'fillPath': {\n                    path = doc.createElementNS(SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', 'none');\n                    path.setAttribute('stroke-width', '0');\n                    path.setAttribute('fill', o.fill || '');\n                    if (drawable.shape === 'curve' || drawable.shape === 'polygon') {\n                        path.setAttribute('fill-rule', 'evenodd');\n                    }\n                    break;\n                }\n                case 'fillSketch': {\n                    path = this.fillSketch(doc, drawing, o);\n                    break;\n                }\n            }\n            if (path) {\n                g.appendChild(path);\n            }\n        }\n        return g;\n    }\n    fillSketch(doc, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const path = doc.createElementNS(SVGNS, 'path');\n        path.setAttribute('d', this.opsToPath(drawing, o.fixedDecimalPlaceDigits));\n        path.setAttribute('stroke', o.fill || '');\n        path.setAttribute('stroke-width', fweight + '');\n        path.setAttribute('fill', 'none');\n        if (o.fillLineDash) {\n            path.setAttribute('stroke-dasharray', o.fillLineDash.join(' ').trim());\n        }\n        if (o.fillLineDashOffset) {\n            path.setAttribute('stroke-dashoffset', `${o.fillLineDashOffset}`);\n        }\n        return path;\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    opsToPath(drawing, fixedDecimalPlaceDigits) {\n        return this.gen.opsToPath(drawing, fixedDecimalPlaceDigits);\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        return this.draw(d);\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        return this.draw(d);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        return this.draw(d);\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        return this.draw(drawing);\n    }\n}\n",
    "export const SVGNS = 'http://www.w3.org/2000/svg';\n",
    "/**\n * this file defines pure geometric shapes\n *\n * for instance, a cubic bezier curve is specified by its four control points and\n * an ellipse is defined by its center, angle, semi major axis and semi minor axis\n * (but in semi-width and semi-height so it's more relevant to Excalidraw)\n *\n * the idea with pure shapes is so that we can provide collision and other geoemtric methods not depending on\n * the specifics of roughjs or elements in Excalidraw; instead, we can focus on the pure shapes themselves\n *\n * also included in this file are methods for converting an Excalidraw element or a Drawable from roughjs\n * to pure shapes\n */\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport { invariant } from \"@excalidraw/common\";\nimport {\n  curve,\n  lineSegment,\n  pointFrom,\n  pointDistance,\n  pointFromArray,\n  pointFromVector,\n  pointRotateRads,\n  polygon,\n  polygonFromPoints,\n  PRECISION,\n  segmentsIntersectAt,\n  vector,\n  vectorAdd,\n  vectorFromPoint,\n  vectorScale,\n  type GlobalPoint,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport { getElementAbsoluteCoords } from \"@excalidraw/element\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawBindableElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawEmbeddableElement,\n  ExcalidrawFrameLikeElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawIframeElement,\n  ExcalidrawImageElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawSelectionElement,\n  ExcalidrawTextElement,\n} from \"@excalidraw/element/types\";\nimport type { Curve, LineSegment, Polygon, Radians } from \"@excalidraw/math\";\n\nimport type { Drawable, Op } from \"roughjs/bin/core\";\n\n// a polyline (made up term here) is a line consisting of other line segments\n// this corresponds to a straight line element in the editor but it could also\n// be used to model other elements\nexport type Polyline<Point extends GlobalPoint | LocalPoint> =\n  LineSegment<Point>[];\n\n// a polycurve is a curve consisting of ther curves, this corresponds to a complex\n// curve on the canvas\nexport type Polycurve<Point extends GlobalPoint | LocalPoint> = Curve<Point>[];\n\n// an ellipse is specified by its center, angle, and its major and minor axes\n// but for the sake of simplicity, we've used halfWidth and halfHeight instead\n// in replace of semi major and semi minor axes\nexport type Ellipse<Point extends GlobalPoint | LocalPoint> = {\n  center: Point;\n  angle: Radians;\n  halfWidth: number;\n  halfHeight: number;\n};\n\nexport type GeometricShape<Point extends GlobalPoint | LocalPoint> =\n  | {\n      type: \"line\";\n      data: LineSegment<Point>;\n    }\n  | {\n      type: \"polygon\";\n      data: Polygon<Point>;\n    }\n  | {\n      type: \"curve\";\n      data: Curve<Point>;\n    }\n  | {\n      type: \"ellipse\";\n      data: Ellipse<Point>;\n    }\n  | {\n      type: \"polyline\";\n      data: Polyline<Point>;\n    }\n  | {\n      type: \"polycurve\";\n      data: Polycurve<Point>;\n    };\n\ntype RectangularElement =\n  | ExcalidrawRectangleElement\n  | ExcalidrawDiamondElement\n  | ExcalidrawFrameLikeElement\n  | ExcalidrawEmbeddableElement\n  | ExcalidrawImageElement\n  | ExcalidrawIframeElement\n  | ExcalidrawTextElement\n  | ExcalidrawSelectionElement;\n\n// polygon\nexport const getPolygonShape = <Point extends GlobalPoint | LocalPoint>(\n  element: RectangularElement,\n): GeometricShape<Point> => {\n  const { angle, width, height, x, y } = element;\n\n  const cx = x + width / 2;\n  const cy = y + height / 2;\n\n  const center: Point = pointFrom(cx, cy);\n\n  let data: Polygon<Point>;\n\n  if (element.type === \"diamond\") {\n    data = polygon(\n      pointRotateRads(pointFrom(cx, y), center, angle),\n      pointRotateRads(pointFrom(x + width, cy), center, angle),\n      pointRotateRads(pointFrom(cx, y + height), center, angle),\n      pointRotateRads(pointFrom(x, cy), center, angle),\n    );\n  } else {\n    data = polygon(\n      pointRotateRads(pointFrom(x, y), center, angle),\n      pointRotateRads(pointFrom(x + width, y), center, angle),\n      pointRotateRads(pointFrom(x + width, y + height), center, angle),\n      pointRotateRads(pointFrom(x, y + height), center, angle),\n    );\n  }\n\n  return {\n    type: \"polygon\",\n    data,\n  };\n};\n\n// return the selection box for an element, possibly rotated as well\nexport const getSelectionBoxShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  padding = 10,\n) => {\n  let [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n    element,\n    elementsMap,\n    true,\n  );\n\n  x1 -= padding;\n  x2 += padding;\n  y1 -= padding;\n  y2 += padding;\n\n  //const angleInDegrees = angleToDegrees(element.angle);\n  const center = pointFrom(cx, cy);\n  const topLeft = pointRotateRads(pointFrom(x1, y1), center, element.angle);\n  const topRight = pointRotateRads(pointFrom(x2, y1), center, element.angle);\n  const bottomLeft = pointRotateRads(pointFrom(x1, y2), center, element.angle);\n  const bottomRight = pointRotateRads(pointFrom(x2, y2), center, element.angle);\n\n  return {\n    type: \"polygon\",\n    data: [topLeft, topRight, bottomRight, bottomLeft],\n  } as GeometricShape<Point>;\n};\n\n// ellipse\nexport const getEllipseShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawEllipseElement,\n): GeometricShape<Point> => {\n  const { width, height, angle, x, y } = element;\n\n  return {\n    type: \"ellipse\",\n    data: {\n      center: pointFrom(x + width / 2, y + height / 2),\n      angle,\n      halfWidth: width / 2,\n      halfHeight: height / 2,\n    },\n  };\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  // NOTE (mtolmacs): Temporary fix for extremely large elements\n  if (!shape) {\n    return [];\n  }\n\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\n// linear\nexport const getCurveShape = <Point extends GlobalPoint | LocalPoint>(\n  roughShape: Drawable,\n  startingPoint: Point = pointFrom(0, 0),\n  angleInRadian: Radians,\n  center: Point,\n): GeometricShape<Point> => {\n  const transform = (p: Point): Point =>\n    pointRotateRads(\n      pointFrom(p[0] + startingPoint[0], p[1] + startingPoint[1]),\n      center,\n      angleInRadian,\n    );\n\n  const ops = getCurvePathOps(roughShape);\n  const polycurve: Polycurve<Point> = [];\n  let p0 = pointFrom<Point>(0, 0);\n\n  for (const op of ops) {\n    if (op.op === \"move\") {\n      const p = pointFromArray<Point>(op.data);\n      invariant(p != null, \"Ops data is not a point\");\n      p0 = transform(p);\n    }\n    if (op.op === \"bcurveTo\") {\n      const p1 = transform(pointFrom<Point>(op.data[0], op.data[1]));\n      const p2 = transform(pointFrom<Point>(op.data[2], op.data[3]));\n      const p3 = transform(pointFrom<Point>(op.data[4], op.data[5]));\n      polycurve.push(curve<Point>(p0, p1, p2, p3));\n      p0 = p3;\n    }\n  }\n\n  return {\n    type: \"polycurve\",\n    data: polycurve,\n  };\n};\n\nconst polylineFromPoints = <Point extends GlobalPoint | LocalPoint>(\n  points: Point[],\n): Polyline<Point> => {\n  let previousPoint: Point = points[0];\n  const polyline: LineSegment<Point>[] = [];\n\n  for (let i = 1; i < points.length; i++) {\n    const nextPoint = points[i];\n    polyline.push(lineSegment<Point>(previousPoint, nextPoint));\n    previousPoint = nextPoint;\n  }\n\n  return polyline;\n};\n\nexport const getFreedrawShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawFreeDrawElement,\n  center: Point,\n  isClosed: boolean = false,\n): GeometricShape<Point> => {\n  const transform = (p: Point) =>\n    pointRotateRads(\n      pointFromVector(\n        vectorAdd(vectorFromPoint(p), vector(element.x, element.y)),\n      ),\n      center,\n      element.angle,\n    );\n\n  const polyline = polylineFromPoints(\n    element.points.map((p) => transform(p as Point)),\n  );\n\n  return (\n    isClosed\n      ? {\n          type: \"polygon\",\n          data: polygonFromPoints(polyline.flat()),\n        }\n      : {\n          type: \"polyline\",\n          data: polyline,\n        }\n  ) as GeometricShape<Point>;\n};\n\nexport const getClosedCurveShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawLinearElement,\n  roughShape: Drawable,\n  startingPoint: Point = pointFrom<Point>(0, 0),\n  angleInRadian: Radians,\n  center: Point,\n): GeometricShape<Point> => {\n  const transform = (p: Point) =>\n    pointRotateRads(\n      pointFrom(p[0] + startingPoint[0], p[1] + startingPoint[1]),\n      center,\n      angleInRadian,\n    );\n\n  if (element.roundness === null) {\n    return {\n      type: \"polygon\",\n      data: polygonFromPoints(\n        element.points.map((p) => transform(p as Point)) as Point[],\n      ),\n    };\n  }\n\n  const ops = getCurvePathOps(roughShape);\n\n  const points: Point[] = [];\n  let odd = false;\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push(pointFrom(operation.data[0], operation.data[1]));\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push(pointFrom(operation.data[0], operation.data[1]));\n        points.push(pointFrom(operation.data[2], operation.data[3]));\n        points.push(pointFrom(operation.data[4], operation.data[5]));\n      }\n    } else if (operation.op === \"lineTo\") {\n      if (odd) {\n        points.push(pointFrom(operation.data[0], operation.data[1]));\n      }\n    }\n  }\n\n  const polygonPoints = pointsOnBezierCurves(points, 10, 5).map((p) =>\n    transform(p as Point),\n  ) as Point[];\n\n  return {\n    type: \"polygon\",\n    data: polygonFromPoints<Point>(polygonPoints),\n  };\n};\n\n/**\n * Determine intersection of a rectangular shaped element and a\n * line segment.\n *\n * @param element The rectangular element to test against\n * @param segment The segment intersecting the element\n * @param gap Optional value to inflate the shape before testing\n * @returns An array of intersections\n */\n// TODO: Replace with final rounded rectangle code\nexport const segmentIntersectRectangleElement = <\n  Point extends LocalPoint | GlobalPoint,\n>(\n  element: ExcalidrawBindableElement,\n  segment: LineSegment<Point>,\n  gap: number = 0,\n): Point[] => {\n  const bounds = [\n    element.x - gap,\n    element.y - gap,\n    element.x + element.width + gap,\n    element.y + element.height + gap,\n  ];\n  const center = pointFrom(\n    (bounds[0] + bounds[2]) / 2,\n    (bounds[1] + bounds[3]) / 2,\n  );\n\n  return [\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[0], bounds[1]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[2], bounds[1]), center, element.angle),\n    ),\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[2], bounds[1]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[2], bounds[3]), center, element.angle),\n    ),\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[2], bounds[3]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[0], bounds[3]), center, element.angle),\n    ),\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[0], bounds[3]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[0], bounds[1]), center, element.angle),\n    ),\n  ]\n    .map((s) => segmentsIntersectAt(segment, s))\n    .filter((i): i is Point => !!i);\n};\n\nconst distanceToEllipse = <Point extends LocalPoint | GlobalPoint>(\n  p: Point,\n  ellipse: Ellipse<Point>,\n) => {\n  const { angle, halfWidth, halfHeight, center } = ellipse;\n  const a = halfWidth;\n  const b = halfHeight;\n  const translatedPoint = vectorAdd(\n    vectorFromPoint(p),\n    vectorScale(vectorFromPoint(center), -1),\n  );\n  const [rotatedPointX, rotatedPointY] = pointRotateRads(\n    pointFromVector(translatedPoint),\n    pointFrom(0, 0),\n    -angle as Radians,\n  );\n\n  const px = Math.abs(rotatedPointX);\n  const py = Math.abs(rotatedPointY);\n\n  let tx = 0.707;\n  let ty = 0.707;\n\n  for (let i = 0; i < 3; i++) {\n    const x = a * tx;\n    const y = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = x - ex;\n    const ry = y - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  }\n\n  const [minX, minY] = [\n    a * tx * Math.sign(rotatedPointX),\n    b * ty * Math.sign(rotatedPointY),\n  ];\n\n  return pointDistance(\n    pointFrom(rotatedPointX, rotatedPointY),\n    pointFrom(minX, minY),\n  );\n};\n\nexport const pointOnEllipse = <Point extends LocalPoint | GlobalPoint>(\n  point: Point,\n  ellipse: Ellipse<Point>,\n  threshold = PRECISION,\n) => {\n  return distanceToEllipse(point, ellipse) <= threshold;\n};\n\nexport const pointInEllipse = <Point extends LocalPoint | GlobalPoint>(\n  p: Point,\n  ellipse: Ellipse<Point>,\n) => {\n  const { center, angle, halfWidth, halfHeight } = ellipse;\n  const translatedPoint = vectorAdd(\n    vectorFromPoint(p),\n    vectorScale(vectorFromPoint(center), -1),\n  );\n  const [rotatedPointX, rotatedPointY] = pointRotateRads(\n    pointFromVector(translatedPoint),\n    pointFrom(0, 0),\n    -angle as Radians,\n  );\n\n  return (\n    (rotatedPointX / halfWidth) * (rotatedPointX / halfWidth) +\n      (rotatedPointY / halfHeight) * (rotatedPointY / halfHeight) <=\n    1\n  );\n};\n\nexport const ellipseAxes = <Point extends LocalPoint | GlobalPoint>(\n  ellipse: Ellipse<Point>,\n) => {\n  const widthGreaterThanHeight = ellipse.halfWidth > ellipse.halfHeight;\n\n  const majorAxis = widthGreaterThanHeight\n    ? ellipse.halfWidth * 2\n    : ellipse.halfHeight * 2;\n  const minorAxis = widthGreaterThanHeight\n    ? ellipse.halfHeight * 2\n    : ellipse.halfWidth * 2;\n\n  return {\n    majorAxis,\n    minorAxis,\n  };\n};\n\nexport const ellipseFocusToCenter = <Point extends LocalPoint | GlobalPoint>(\n  ellipse: Ellipse<Point>,\n) => {\n  const { majorAxis, minorAxis } = ellipseAxes(ellipse);\n\n  return Math.sqrt(majorAxis ** 2 - minorAxis ** 2);\n};\n\nexport const ellipseExtremes = <Point extends LocalPoint | GlobalPoint>(\n  ellipse: Ellipse<Point>,\n) => {\n  const { center, angle } = ellipse;\n  const { majorAxis, minorAxis } = ellipseAxes(ellipse);\n\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n\n  const sqSum = majorAxis ** 2 + minorAxis ** 2;\n  const sqDiff = (majorAxis ** 2 - minorAxis ** 2) * Math.cos(2 * angle);\n\n  const yMax = Math.sqrt((sqSum - sqDiff) / 2);\n  const xAtYMax =\n    (yMax * sqSum * sin * cos) /\n    (majorAxis ** 2 * sin ** 2 + minorAxis ** 2 * cos ** 2);\n\n  const xMax = Math.sqrt((sqSum + sqDiff) / 2);\n  const yAtXMax =\n    (xMax * sqSum * sin * cos) /\n    (majorAxis ** 2 * cos ** 2 + minorAxis ** 2 * sin ** 2);\n  const centerVector = vectorFromPoint(center);\n\n  return [\n    vectorAdd(vector(xAtYMax, yMax), centerVector),\n    vectorAdd(vectorScale(vector(xAtYMax, yMax), -1), centerVector),\n    vectorAdd(vector(xMax, yAtXMax), centerVector),\n    vectorAdd(vector(xMax, yAtXMax), centerVector),\n  ];\n};\n",
    "import { simplify } from \"points-on-curve\";\n\nimport {\n  type GeometricShape,\n  getClosedCurveShape,\n  getCurveShape,\n  getEllipseShape,\n  getFreedrawShape,\n  getPolygonShape,\n} from \"@excalidraw/utils/shape\";\n\nimport {\n  pointFrom,\n  pointDistance,\n  type LocalPoint,\n  pointRotateRads,\n} from \"@excalidraw/math\";\nimport {\n  ROUGHNESS,\n  isTransparent,\n  assertNever,\n  COLOR_PALETTE,\n  LINE_POLYGON_POINT_MERGE_DISTANCE,\n} from \"@excalidraw/common\";\n\nimport { RoughGenerator } from \"roughjs/bin/generator\";\n\nimport type { GlobalPoint } from \"@excalidraw/math\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport type {\n  AppState,\n  EmbedsValidationStatus,\n} from \"excalidraw-custom/types\";\nimport type {\n  ElementShape,\n  ElementShapes,\n} from \"excalidraw-custom/scene/types\";\n\nimport { elementWithCanvasCache } from \"./renderElement\";\n\nimport {\n  canBecomePolygon,\n  isElbowArrow,\n  isEmbeddableElement,\n  isIframeElement,\n  isIframeLikeElement,\n  isLinearElement,\n} from \"./typeChecks\";\nimport { getCornerRadius, isPathALoop } from \"./utils\";\nimport { headingForPointIsHorizontal } from \"./heading\";\n\nimport { canChangeRoundness } from \"./comparisons\";\nimport { generateFreeDrawShape } from \"./renderElement\";\nimport {\n  getArrowheadPoints,\n  getCenterForBounds,\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n} from \"./bounds\";\nimport { shouldTestInside } from \"./collision\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawSelectionElement,\n  ExcalidrawLinearElement,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n  ElementsMap,\n  ExcalidrawLineElement,\n} from \"./types\";\n\nimport type { Drawable, Options } from \"roughjs/bin/core\";\nimport type { Point as RoughPoint } from \"roughjs/bin/geometry\";\n\nexport class ShapeCache {\n  private static rg = new RoughGenerator();\n  private static cache = new WeakMap<ExcalidrawElement, ElementShape>();\n\n  /**\n   * Retrieves shape from cache if available. Use this only if shape\n   * is optional and you have a fallback in case it's not cached.\n   */\n  public static get = <T extends ExcalidrawElement>(element: T) => {\n    return ShapeCache.cache.get(\n      element,\n    ) as T[\"type\"] extends keyof ElementShapes\n      ? ElementShapes[T[\"type\"]] | undefined\n      : ElementShape | undefined;\n  };\n\n  public static set = <T extends ExcalidrawElement>(\n    element: T,\n    shape: T[\"type\"] extends keyof ElementShapes\n      ? ElementShapes[T[\"type\"]]\n      : Drawable,\n  ) => ShapeCache.cache.set(element, shape);\n\n  public static delete = (element: ExcalidrawElement) =>\n    ShapeCache.cache.delete(element);\n\n  public static destroy = () => {\n    ShapeCache.cache = new WeakMap();\n  };\n\n  /**\n   * Generates & caches shape for element if not already cached, otherwise\n   * returns cached shape.\n   */\n  public static generateElementShape = <\n    T extends Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n  >(\n    element: T,\n    renderConfig: {\n      isExporting: boolean;\n      canvasBackgroundColor: AppState[\"viewBackgroundColor\"];\n      embedsValidationStatus: EmbedsValidationStatus;\n    } | null,\n  ) => {\n    // when exporting, always regenerated to guarantee the latest shape\n    const cachedShape = renderConfig?.isExporting\n      ? undefined\n      : ShapeCache.get(element);\n\n    // `null` indicates no rc shape applicable for this element type,\n    // but it's considered a valid cache value (= do not regenerate)\n    if (cachedShape !== undefined) {\n      return cachedShape;\n    }\n\n    elementWithCanvasCache.delete(element);\n\n    const shape = generateElementShape(\n      element,\n      ShapeCache.rg,\n      renderConfig || {\n        isExporting: false,\n        canvasBackgroundColor: COLOR_PALETTE.white,\n        embedsValidationStatus: null,\n      },\n    ) as T[\"type\"] extends keyof ElementShapes\n      ? ElementShapes[T[\"type\"]]\n      : Drawable | null;\n\n    ShapeCache.cache.set(element, shape);\n\n    return shape;\n  };\n}\n\nconst getDashArrayDashed = (strokeWidth: number) => [8, 8 + strokeWidth];\n\nconst getDashArrayDotted = (strokeWidth: number) => [1.5, 6 + strokeWidth];\n\nfunction adjustRoughness(element: ExcalidrawElement): number {\n  const roughness = element.roughness;\n\n  const maxSize = Math.max(element.width, element.height);\n  const minSize = Math.min(element.width, element.height);\n\n  // don't reduce roughness if\n  if (\n    // both sides relatively big\n    (minSize >= 20 && maxSize >= 50) ||\n    // is round & both sides above 15px\n    (minSize >= 15 &&\n      !!element.roundness &&\n      canChangeRoundness(element.type)) ||\n    // relatively long linear element\n    (isLinearElement(element) && maxSize >= 50)\n  ) {\n    return roughness;\n  }\n\n  return Math.min(roughness / (maxSize < 10 ? 3 : 2), 2.5);\n}\n\nexport const generateRoughOptions = (\n  element: ExcalidrawElement,\n  continuousPath = false,\n): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? getDashArrayDashed(element.strokeWidth)\n        : element.strokeStyle === \"dotted\"\n        ? getDashArrayDotted(element.strokeWidth)\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: adjustRoughness(element),\n    stroke: element.strokeColor,\n    preserveVertices:\n      continuousPath || element.roughness < ROUGHNESS.cartoonist,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill = isTransparent(element.backgroundColor)\n        ? undefined\n        : element.backgroundColor;\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\":\n    case \"freedraw\": {\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nconst modifyIframeLikeForRoughOptions = (\n  element: NonDeletedExcalidrawElement,\n  isExporting: boolean,\n  embedsValidationStatus: EmbedsValidationStatus | null,\n) => {\n  if (\n    isIframeLikeElement(element) &&\n    (isExporting ||\n      (isEmbeddableElement(element) &&\n        embedsValidationStatus?.get(element.id) !== true)) &&\n    isTransparent(element.backgroundColor) &&\n    isTransparent(element.strokeColor)\n  ) {\n    return {\n      ...element,\n      roughness: 0,\n      backgroundColor: \"#d3d3d3\",\n      fillStyle: \"solid\",\n    } as const;\n  } else if (isIframeElement(element)) {\n    return {\n      ...element,\n      strokeColor: isTransparent(element.strokeColor)\n        ? \"#000000\"\n        : element.strokeColor,\n      backgroundColor: isTransparent(element.backgroundColor)\n        ? \"#f4f4f6\"\n        : element.backgroundColor,\n    };\n  }\n  return element;\n};\n\nconst getArrowheadShapes = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n  generator: RoughGenerator,\n  options: Options,\n  canvasBackgroundColor: string,\n) => {\n  const arrowheadPoints = getArrowheadPoints(\n    element,\n    shape,\n    position,\n    arrowhead,\n  );\n\n  if (arrowheadPoints === null) {\n    return [];\n  }\n\n  const generateCrowfootOne = (\n    arrowheadPoints: number[] | null,\n    options: Options,\n  ) => {\n    if (arrowheadPoints === null) {\n      return [];\n    }\n\n    const [, , x3, y3, x4, y4] = arrowheadPoints;\n\n    return [generator.line(x3, y3, x4, y4, options)];\n  };\n\n  switch (arrowhead) {\n    case \"dot\":\n    case \"circle\":\n    case \"circle_outline\": {\n      const [x, y, diameter] = arrowheadPoints;\n\n      // always use solid stroke for arrowhead\n      delete options.strokeLineDash;\n\n      return [\n        generator.circle(x, y, diameter, {\n          ...options,\n          fill:\n            arrowhead === \"circle_outline\"\n              ? canvasBackgroundColor\n              : element.strokeColor,\n\n          fillStyle: \"solid\",\n          stroke: element.strokeColor,\n          roughness: Math.min(0.5, options.roughness || 0),\n        }),\n      ];\n    }\n    case \"triangle\":\n    case \"triangle_outline\": {\n      const [x, y, x2, y2, x3, y3] = arrowheadPoints;\n\n      // always use solid stroke for arrowhead\n      delete options.strokeLineDash;\n\n      return [\n        generator.polygon(\n          [\n            [x, y],\n            [x2, y2],\n            [x3, y3],\n            [x, y],\n          ],\n          {\n            ...options,\n            fill:\n              arrowhead === \"triangle_outline\"\n                ? canvasBackgroundColor\n                : element.strokeColor,\n            fillStyle: \"solid\",\n            roughness: Math.min(1, options.roughness || 0),\n          },\n        ),\n      ];\n    }\n    case \"diamond\":\n    case \"diamond_outline\": {\n      const [x, y, x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n      // always use solid stroke for arrowhead\n      delete options.strokeLineDash;\n\n      return [\n        generator.polygon(\n          [\n            [x, y],\n            [x2, y2],\n            [x3, y3],\n            [x4, y4],\n            [x, y],\n          ],\n          {\n            ...options,\n            fill:\n              arrowhead === \"diamond_outline\"\n                ? canvasBackgroundColor\n                : element.strokeColor,\n            fillStyle: \"solid\",\n            roughness: Math.min(1, options.roughness || 0),\n          },\n        ),\n      ];\n    }\n    case \"crowfoot_one\":\n      return generateCrowfootOne(arrowheadPoints, options);\n    case \"bar\":\n    case \"arrow\":\n    case \"crowfoot_many\":\n    case \"crowfoot_one_or_many\":\n    default: {\n      const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n      if (element.strokeStyle === \"dotted\") {\n        // for dotted arrows caps, reduce gap to make it more legible\n        const dash = getDashArrayDotted(element.strokeWidth - 1);\n        options.strokeLineDash = [dash[0], dash[1] - 1];\n      } else {\n        // for solid/dashed, keep solid arrow cap\n        delete options.strokeLineDash;\n      }\n      options.roughness = Math.min(1, options.roughness || 0);\n      return [\n        generator.line(x3, y3, x2, y2, options),\n        generator.line(x4, y4, x2, y2, options),\n        ...(arrowhead === \"crowfoot_one_or_many\"\n          ? generateCrowfootOne(\n              getArrowheadPoints(element, shape, position, \"crowfoot_one\"),\n              options,\n            )\n          : []),\n      ];\n    }\n  }\n};\n\nexport const generateLinearCollisionShape = (\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n) => {\n  const generator = new RoughGenerator();\n  const options: Options = {\n    seed: element.seed,\n    disableMultiStroke: true,\n    disableMultiStrokeFill: true,\n    roughness: 0,\n    preserveVertices: true,\n  };\n  const center = getCenterForBounds(\n    // Need a non-rotated center point\n    element.points.reduce(\n      (acc, point) => {\n        return [\n          Math.min(element.x + point[0], acc[0]),\n          Math.min(element.y + point[1], acc[1]),\n          Math.max(element.x + point[0], acc[2]),\n          Math.max(element.y + point[1], acc[3]),\n        ];\n      },\n      [Infinity, Infinity, -Infinity, -Infinity],\n    ),\n  );\n\n  switch (element.type) {\n    case \"line\":\n    case \"arrow\": {\n      // points array can be empty in the beginning, so it is important to add\n      // initial position to it\n      const points = element.points.length\n        ? element.points\n        : [pointFrom<LocalPoint>(0, 0)];\n\n      if (isElbowArrow(element)) {\n        return generator.path(generateElbowArrowShape(points, 16), options)\n          .sets[0].ops;\n      } else if (!element.roundness) {\n        return points.map((point, idx) => {\n          const p = pointRotateRads(\n            pointFrom<GlobalPoint>(element.x + point[0], element.y + point[1]),\n            center,\n            element.angle,\n          );\n\n          return {\n            op: idx === 0 ? \"move\" : \"lineTo\",\n            data: pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n          };\n        });\n      }\n\n      return generator\n        .curve(points as unknown as RoughPoint[], options)\n        .sets[0].ops.slice(0, element.points.length)\n        .map((op, i) => {\n          if (i === 0) {\n            const p = pointRotateRads<GlobalPoint>(\n              pointFrom<GlobalPoint>(\n                element.x + op.data[0],\n                element.y + op.data[1],\n              ),\n              center,\n              element.angle,\n            );\n\n            return {\n              op: \"move\",\n              data: pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n            };\n          }\n\n          return {\n            op: \"bcurveTo\",\n            data: [\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[0],\n                  element.y + op.data[1],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[2],\n                  element.y + op.data[3],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[4],\n                  element.y + op.data[5],\n                ),\n                center,\n                element.angle,\n              ),\n            ]\n              .map((p) =>\n                pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n              )\n              .flat(),\n          };\n        });\n    }\n    case \"freedraw\": {\n      if (element.points.length < 2) {\n        return [];\n      }\n\n      const simplifiedPoints = simplify(\n        element.points as Mutable<LocalPoint[]>,\n        0.75,\n      );\n\n      return generator\n        .curve(simplifiedPoints as [number, number][], options)\n        .sets[0].ops.slice(0, element.points.length)\n        .map((op, i) => {\n          if (i === 0) {\n            const p = pointRotateRads<GlobalPoint>(\n              pointFrom<GlobalPoint>(\n                element.x + op.data[0],\n                element.y + op.data[1],\n              ),\n              center,\n              element.angle,\n            );\n\n            return {\n              op: \"move\",\n              data: pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n            };\n          }\n\n          return {\n            op: \"bcurveTo\",\n            data: [\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[0],\n                  element.y + op.data[1],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[2],\n                  element.y + op.data[3],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[4],\n                  element.y + op.data[5],\n                ),\n                center,\n                element.angle,\n              ),\n            ]\n              .map((p) =>\n                pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n              )\n              .flat(),\n          };\n        });\n    }\n  }\n};\n\n/**\n * Generates the roughjs shape for given element.\n *\n * Low-level. Use `ShapeCache.generateElementShape` instead.\n *\n * @private\n */\nconst generateElementShape = (\n  element: Exclude<NonDeletedExcalidrawElement, ExcalidrawSelectionElement>,\n  generator: RoughGenerator,\n  {\n    isExporting,\n    canvasBackgroundColor,\n    embedsValidationStatus,\n  }: {\n    isExporting: boolean;\n    canvasBackgroundColor: string;\n    embedsValidationStatus: EmbedsValidationStatus | null;\n  },\n): Drawable | Drawable[] | null => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\": {\n      let shape: ElementShapes[typeof element.type];\n      // this is for rendering the stroke/bg of the embeddable, especially\n      // when the src url is not set\n\n      if (element.roundness) {\n        const w = element.width;\n        const h = element.height;\n        const r = getCornerRadius(Math.min(w, h), element);\n        shape = generator.path(\n          `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${\n            h - r\n          } Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${\n            h - r\n          } L 0 ${r} Q 0 0, ${r} 0`,\n          generateRoughOptions(\n            modifyIframeLikeForRoughOptions(\n              element,\n              isExporting,\n              embedsValidationStatus,\n            ),\n            true,\n          ),\n        );\n      } else {\n        shape = generator.rectangle(\n          0,\n          0,\n          element.width,\n          element.height,\n          generateRoughOptions(\n            modifyIframeLikeForRoughOptions(\n              element,\n              isExporting,\n              embedsValidationStatus,\n            ),\n            false,\n          ),\n        );\n      }\n      return shape;\n    }\n    case \"diamond\": {\n      let shape: ElementShapes[typeof element.type];\n\n      const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] =\n        getDiamondPoints(element);\n      if (element.roundness) {\n        const verticalRadius = getCornerRadius(Math.abs(topX - leftX), element);\n\n        const horizontalRadius = getCornerRadius(\n          Math.abs(rightY - topY),\n          element,\n        );\n\n        shape = generator.path(\n          `M ${topX + verticalRadius} ${topY + horizontalRadius} L ${\n            rightX - verticalRadius\n          } ${rightY - horizontalRadius}\n            C ${rightX} ${rightY}, ${rightX} ${rightY}, ${\n            rightX - verticalRadius\n          } ${rightY + horizontalRadius}\n            L ${bottomX + verticalRadius} ${bottomY - horizontalRadius}\n            C ${bottomX} ${bottomY}, ${bottomX} ${bottomY}, ${\n            bottomX - verticalRadius\n          } ${bottomY - horizontalRadius}\n            L ${leftX + verticalRadius} ${leftY + horizontalRadius}\n            C ${leftX} ${leftY}, ${leftX} ${leftY}, ${leftX + verticalRadius} ${\n            leftY - horizontalRadius\n          }\n            L ${topX - verticalRadius} ${topY + horizontalRadius}\n            C ${topX} ${topY}, ${topX} ${topY}, ${topX + verticalRadius} ${\n            topY + horizontalRadius\n          }`,\n          generateRoughOptions(element, true),\n        );\n      } else {\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          generateRoughOptions(element),\n        );\n      }\n      return shape;\n    }\n    case \"ellipse\": {\n      const shape: ElementShapes[typeof element.type] = generator.ellipse(\n        element.width / 2,\n        element.height / 2,\n        element.width,\n        element.height,\n        generateRoughOptions(element),\n      );\n      return shape;\n    }\n    case \"line\":\n    case \"arrow\": {\n      let shape: ElementShapes[typeof element.type];\n      const options = generateRoughOptions(element);\n\n      // points array can be empty in the beginning, so it is important to add\n      // initial position to it\n      const points = element.points.length\n        ? element.points\n        : [pointFrom<LocalPoint>(0, 0)];\n\n      if (isElbowArrow(element)) {\n        // NOTE (mtolmacs): Temporary fix for extremely big arrow shapes\n        if (\n          !points.every(\n            (point) => Math.abs(point[0]) <= 1e6 && Math.abs(point[1]) <= 1e6,\n          )\n        ) {\n          console.error(\n            `Elbow arrow with extreme point positions detected. Arrow not rendered.`,\n            element.id,\n            JSON.stringify(points),\n          );\n          shape = [];\n        } else {\n          shape = [\n            generator.path(\n              generateElbowArrowShape(points, 16),\n              generateRoughOptions(element, true),\n            ),\n          ];\n        }\n      } else if (!element.roundness) {\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        if (options.fill) {\n          shape = [\n            generator.polygon(points as unknown as RoughPoint[], options),\n          ];\n        } else {\n          shape = [\n            generator.linearPath(points as unknown as RoughPoint[], options),\n          ];\n        }\n      } else {\n        shape = [generator.curve(points as unknown as RoughPoint[], options)];\n      }\n\n      // add lines only in arrow\n      if (element.type === \"arrow\") {\n        const { startArrowhead = null, endArrowhead = \"arrow\" } = element;\n\n        if (startArrowhead !== null) {\n          const shapes = getArrowheadShapes(\n            element,\n            shape,\n            \"start\",\n            startArrowhead,\n            generator,\n            options,\n            canvasBackgroundColor,\n          );\n          shape.push(...shapes);\n        }\n\n        if (endArrowhead !== null) {\n          if (endArrowhead === undefined) {\n            // Hey, we have an old arrow here!\n          }\n\n          const shapes = getArrowheadShapes(\n            element,\n            shape,\n            \"end\",\n            endArrowhead,\n            generator,\n            options,\n            canvasBackgroundColor,\n          );\n          shape.push(...shapes);\n        }\n      }\n      return shape;\n    }\n    case \"freedraw\": {\n      let shape: ElementShapes[typeof element.type];\n      generateFreeDrawShape(element);\n\n      if (isPathALoop(element.points)) {\n        // generate rough polygon to fill freedraw shape\n        const simplifiedPoints = simplify(\n          element.points as Mutable<LocalPoint[]>,\n          0.75,\n        );\n        shape = generator.curve(simplifiedPoints as [number, number][], {\n          ...generateRoughOptions(element),\n          stroke: \"none\",\n        });\n      } else {\n        shape = null;\n      }\n      return shape;\n    }\n    case \"frame\":\n    case \"magicframe\":\n    case \"text\":\n    case \"image\": {\n      const shape: ElementShapes[typeof element.type] = null;\n      // we return (and cache) `null` to make sure we don't regenerate\n      // `element.canvas` on rerenders\n      return shape;\n    }\n    default: {\n      assertNever(\n        element,\n        `generateElementShape(): Unimplemented type ${(element as any)?.type}`,\n      );\n      return null;\n    }\n  }\n};\n\nconst generateElbowArrowShape = (\n  points: readonly LocalPoint[],\n  radius: number,\n) => {\n  const subpoints = [] as [number, number][];\n  for (let i = 1; i < points.length - 1; i += 1) {\n    const prev = points[i - 1];\n    const next = points[i + 1];\n    const point = points[i];\n    const prevIsHorizontal = headingForPointIsHorizontal(point, prev);\n    const nextIsHorizontal = headingForPointIsHorizontal(next, point);\n    const corner = Math.min(\n      radius,\n      pointDistance(points[i], next) / 2,\n      pointDistance(points[i], prev) / 2,\n    );\n\n    if (prevIsHorizontal) {\n      if (prev[0] < point[0]) {\n        // LEFT\n        subpoints.push([points[i][0] - corner, points[i][1]]);\n      } else {\n        // RIGHT\n        subpoints.push([points[i][0] + corner, points[i][1]]);\n      }\n    } else if (prev[1] < point[1]) {\n      // UP\n      subpoints.push([points[i][0], points[i][1] - corner]);\n    } else {\n      subpoints.push([points[i][0], points[i][1] + corner]);\n    }\n\n    subpoints.push(points[i] as [number, number]);\n\n    if (nextIsHorizontal) {\n      if (next[0] < point[0]) {\n        // LEFT\n        subpoints.push([points[i][0] - corner, points[i][1]]);\n      } else {\n        // RIGHT\n        subpoints.push([points[i][0] + corner, points[i][1]]);\n      }\n    } else if (next[1] < point[1]) {\n      // UP\n      subpoints.push([points[i][0], points[i][1] - corner]);\n    } else {\n      // DOWN\n      subpoints.push([points[i][0], points[i][1] + corner]);\n    }\n  }\n\n  const d = [`M ${points[0][0]} ${points[0][1]}`];\n  for (let i = 0; i < subpoints.length; i += 3) {\n    d.push(`L ${subpoints[i][0]} ${subpoints[i][1]}`);\n    d.push(\n      `Q ${subpoints[i + 1][0]} ${subpoints[i + 1][1]}, ${\n        subpoints[i + 2][0]\n      } ${subpoints[i + 2][1]}`,\n    );\n  }\n  d.push(`L ${points[points.length - 1][0]} ${points[points.length - 1][1]}`);\n\n  return d.join(\" \");\n};\n\n/**\n * get the pure geometric shape of an excalidraw elementw\n * which is then used for hit detection\n */\nexport const getElementShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): GeometricShape<Point> => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"frame\":\n    case \"magicframe\":\n    case \"embeddable\":\n    case \"image\":\n    case \"iframe\":\n    case \"text\":\n    case \"selection\":\n      return getPolygonShape(element);\n    case \"arrow\":\n    case \"line\": {\n      const roughShape =\n        ShapeCache.get(element)?.[0] ??\n        ShapeCache.generateElementShape(element, null)[0];\n      const [, , , , cx, cy] = getElementAbsoluteCoords(element, elementsMap);\n\n      return shouldTestInside(element)\n        ? getClosedCurveShape<Point>(\n            element,\n            roughShape,\n            pointFrom<Point>(element.x, element.y),\n            element.angle,\n            pointFrom(cx, cy),\n          )\n        : getCurveShape<Point>(\n            roughShape,\n            pointFrom<Point>(element.x, element.y),\n            element.angle,\n            pointFrom(cx, cy),\n          );\n    }\n\n    case \"ellipse\":\n      return getEllipseShape(element);\n\n    case \"freedraw\": {\n      const [, , , , cx, cy] = getElementAbsoluteCoords(element, elementsMap);\n      return getFreedrawShape(\n        element,\n        pointFrom(cx, cy),\n        shouldTestInside(element),\n      );\n    }\n  }\n};\n\nexport const toggleLinePolygonState = (\n  element: ExcalidrawLineElement,\n  nextPolygonState: boolean,\n): {\n  polygon: ExcalidrawLineElement[\"polygon\"];\n  points: ExcalidrawLineElement[\"points\"];\n} | null => {\n  const updatedPoints = [...element.points];\n\n  if (nextPolygonState) {\n    if (!canBecomePolygon(element.points)) {\n      return null;\n    }\n\n    const firstPoint = updatedPoints[0];\n    const lastPoint = updatedPoints[updatedPoints.length - 1];\n\n    const distance = Math.hypot(\n      firstPoint[0] - lastPoint[0],\n      firstPoint[1] - lastPoint[1],\n    );\n\n    if (\n      distance > LINE_POLYGON_POINT_MERGE_DISTANCE ||\n      updatedPoints.length < 4\n    ) {\n      updatedPoints.push(pointFrom(firstPoint[0], firstPoint[1]));\n    } else {\n      updatedPoints[updatedPoints.length - 1] = pointFrom(\n        firstPoint[0],\n        firstPoint[1],\n      );\n    }\n  }\n\n  // TODO: satisfies ElementUpdate<ExcalidrawLineElement>\n  const ret = {\n    polygon: nextPolygonState,\n    points: updatedPoints,\n  };\n\n  return ret;\n};\n",
    "import rough from \"roughjs/bin/rough\";\nimport { getStroke } from \"perfect-freehand\";\n\nimport { isRightAngleRads } from \"@excalidraw/math\";\n\nimport {\n  BOUND_TEXT_PADDING,\n  DEFAULT_REDUCED_GLOBAL_ALPHA,\n  ELEMENT_READY_TO_ERASE_OPACITY,\n  FRAME_STYLE,\n  MIME_TYPES,\n  THEME,\n  distance,\n  getFontString,\n  isRTL,\n  getVerticalOffset,\n} from \"@excalidraw/common\";\n\nimport type {\n  AppState,\n  StaticCanvasAppState,\n  Zoom,\n  InteractiveCanvasAppState,\n  ElementsPendingErasure,\n  PendingExcalidrawElements,\n  NormalizedZoomValue,\n} from \"excalidraw-custom/types\";\n\nimport type {\n  StaticCanvasRenderConfig,\n  RenderableElementsMap,\n  InteractiveCanvasRenderConfig,\n} from \"excalidraw-custom/scene/types\";\n\nimport { getElementAbsoluteCoords } from \"./bounds\";\nimport { getUncroppedImageElement } from \"./cropElement\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport {\n  getBoundTextElement,\n  getContainerCoords,\n  getContainerElement,\n  getBoundTextMaxHeight,\n  getBoundTextMaxWidth,\n} from \"./textElement\";\nimport { getLineHeightInPx } from \"./textMeasurements\";\nimport {\n  isTextElement,\n  isLinearElement,\n  isFreeDrawElement,\n  isInitializedImageElement,\n  isArrowElement,\n  hasBoundTextElement,\n  isMagicFrameElement,\n  isImageElement,\n} from \"./typeChecks\";\nimport { getContainingFrame } from \"./frame\";\nimport { getCornerRadius } from \"./utils\";\n\nimport { ShapeCache } from \"./shape\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawFrameLikeElement,\n  NonDeletedSceneElementsMap,\n  ElementsMap,\n} from \"./types\";\n\nimport type { StrokeOptions } from \"perfect-freehand\";\nimport type { RoughCanvas } from \"roughjs/bin/canvas\";\n\n// using a stronger invert (100% vs our regular 93%) and saturate\n// as a temp hack to make images in dark theme look closer to original\n// color scheme (it's still not quite there and the colors look slightly\n// desatured, alas...)\nexport const IMAGE_INVERT_FILTER =\n  \"invert(100%) hue-rotate(180deg) saturate(1.25)\";\n\nconst isPendingImageElement = (\n  element: ExcalidrawElement,\n  renderConfig: StaticCanvasRenderConfig,\n) =>\n  isInitializedImageElement(element) &&\n  !renderConfig.imageCache.has(element.fileId);\n\nconst shouldResetImageFilter = (\n  element: ExcalidrawElement,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n) => {\n  return (\n    appState.theme === THEME.DARK &&\n    isInitializedImageElement(element) &&\n    !isPendingImageElement(element, renderConfig) &&\n    renderConfig.imageCache.get(element.fileId)?.mimeType !== MIME_TYPES.svg\n  );\n};\n\nconst getCanvasPadding = (element: ExcalidrawElement) => {\n  switch (element.type) {\n    case \"freedraw\":\n      return element.strokeWidth * 12;\n    case \"text\":\n      return element.fontSize / 2;\n    default:\n      return 20;\n  }\n};\n\nexport const getRenderOpacity = (\n  element: ExcalidrawElement,\n  containingFrame: ExcalidrawFrameLikeElement | null,\n  elementsPendingErasure: ElementsPendingErasure,\n  pendingNodes: Readonly<PendingExcalidrawElements> | null,\n  globalAlpha: number = 1,\n) => {\n  // multiplying frame opacity with element opacity to combine them\n  // (e.g. frame 50% and element 50% opacity should result in 25% opacity)\n  let opacity =\n    (((containingFrame?.opacity ?? 100) * element.opacity) / 10000) *\n    globalAlpha;\n\n  // if pending erasure, multiply again to combine further\n  // (so that erasing always results in lower opacity than original)\n  if (\n    elementsPendingErasure.has(element.id) ||\n    (pendingNodes && pendingNodes.some((node) => node.id === element.id)) ||\n    (containingFrame && elementsPendingErasure.has(containingFrame.id))\n  ) {\n    opacity *= ELEMENT_READY_TO_ERASE_OPACITY / 100;\n  }\n\n  return opacity;\n};\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  theme: AppState[\"theme\"];\n  scale: number;\n  angle: number;\n  zoomValue: AppState[\"zoom\"][\"value\"];\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n  boundTextElementVersion: number | null;\n  imageCrop: ExcalidrawImageElement[\"crop\"] | null;\n  containingFrameOpacity: number;\n  boundTextCanvas: HTMLCanvasElement;\n}\n\nconst cappedElementCanvasSize = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: ElementsMap,\n  zoom: Zoom,\n): {\n  width: number;\n  height: number;\n  scale: number;\n} => {\n  // these limits are ballpark, they depend on specific browsers and device.\n  // We've chosen lower limits to be safe. We might want to change these limits\n  // based on browser/device type, if we get reports of low quality rendering\n  // on zoom.\n  //\n  // ~ safari mobile canvas area limit\n  const AREA_LIMIT = 16777216;\n  // ~ safari width/height limit based on developer.mozilla.org.\n  const WIDTH_HEIGHT_LIMIT = 32767;\n\n  const padding = getCanvasPadding(element);\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n  const elementWidth =\n    isLinearElement(element) || isFreeDrawElement(element)\n      ? distance(x1, x2)\n      : element.width;\n  const elementHeight =\n    isLinearElement(element) || isFreeDrawElement(element)\n      ? distance(y1, y2)\n      : element.height;\n\n  let width = elementWidth * window.devicePixelRatio + padding * 2;\n  let height = elementHeight * window.devicePixelRatio + padding * 2;\n\n  let scale: number = zoom.value;\n\n  // rescale to ensure width and height is within limits\n  if (\n    width * scale > WIDTH_HEIGHT_LIMIT ||\n    height * scale > WIDTH_HEIGHT_LIMIT\n  ) {\n    scale = Math.min(WIDTH_HEIGHT_LIMIT / width, WIDTH_HEIGHT_LIMIT / height);\n  }\n\n  // rescale to ensure canvas area is within limits\n  if (width * height * scale * scale > AREA_LIMIT) {\n    scale = Math.sqrt(AREA_LIMIT / (width * height));\n  }\n\n  width = Math.floor(width * scale);\n  height = Math.floor(height * scale);\n\n  return { width, height, scale };\n};\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom: Zoom,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n): ExcalidrawElementWithCanvas | null => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n  const padding = getCanvasPadding(element);\n\n  const { width, height, scale } = cappedElementCanvasSize(\n    element,\n    elementsMap,\n    zoom,\n  );\n\n  if (!width || !height) {\n    return null;\n  }\n\n  canvas.width = width;\n  canvas.height = height;\n\n  let canvasOffsetX = -100;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);\n\n    canvasOffsetX =\n      element.x > x1\n        ? distance(element.x, x1) * window.devicePixelRatio * scale\n        : 0;\n\n    canvasOffsetY =\n      element.y > y1\n        ? distance(element.y, y1) * window.devicePixelRatio * scale\n        : 0;\n\n    context.translate(canvasOffsetX, canvasOffsetY);\n  }\n\n  context.save();\n  context.translate(padding * scale, padding * scale);\n  context.scale(\n    window.devicePixelRatio * scale,\n    window.devicePixelRatio * scale,\n  );\n\n  const rc = rough.canvas(canvas);\n\n  // in dark theme, revert the image color filter\n  if (shouldResetImageFilter(element, renderConfig, appState)) {\n    context.filter = IMAGE_INVERT_FILTER;\n  }\n\n  drawElementOnCanvas(element, rc, context, renderConfig, appState);\n\n  context.restore();\n\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n  const boundTextCanvas = document.createElement(\"canvas\");\n  const boundTextCanvasContext = boundTextCanvas.getContext(\"2d\")!;\n\n  if (isArrowElement(element) && boundTextElement) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    // Take max dimensions of arrow canvas so that when canvas is rotated\n    // the arrow doesn't get clipped\n    const maxDim = Math.max(distance(x1, x2), distance(y1, y2));\n    boundTextCanvas.width =\n      maxDim * window.devicePixelRatio * scale + padding * scale * 10;\n    boundTextCanvas.height =\n      maxDim * window.devicePixelRatio * scale + padding * scale * 10;\n    boundTextCanvasContext.translate(\n      boundTextCanvas.width / 2,\n      boundTextCanvas.height / 2,\n    );\n    boundTextCanvasContext.rotate(element.angle);\n    boundTextCanvasContext.drawImage(\n      canvas!,\n      -canvas.width / 2,\n      -canvas.height / 2,\n      canvas.width,\n      canvas.height,\n    );\n\n    const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(\n      boundTextElement,\n      elementsMap,\n    );\n\n    boundTextCanvasContext.rotate(-element.angle);\n    const offsetX = (boundTextCanvas.width - canvas!.width) / 2;\n    const offsetY = (boundTextCanvas.height - canvas!.height) / 2;\n    const shiftX =\n      boundTextCanvas.width / 2 -\n      (boundTextCx - x1) * window.devicePixelRatio * scale -\n      offsetX -\n      padding * scale;\n\n    const shiftY =\n      boundTextCanvas.height / 2 -\n      (boundTextCy - y1) * window.devicePixelRatio * scale -\n      offsetY -\n      padding * scale;\n    boundTextCanvasContext.translate(-shiftX, -shiftY);\n    // Clear the bound text area\n    boundTextCanvasContext.clearRect(\n      -(boundTextElement.width / 2 + BOUND_TEXT_PADDING) *\n        window.devicePixelRatio *\n        scale,\n      -(boundTextElement.height / 2 + BOUND_TEXT_PADDING) *\n        window.devicePixelRatio *\n        scale,\n      (boundTextElement.width + BOUND_TEXT_PADDING * 2) *\n        window.devicePixelRatio *\n        scale,\n      (boundTextElement.height + BOUND_TEXT_PADDING * 2) *\n        window.devicePixelRatio *\n        scale,\n    );\n  }\n\n  return {\n    element,\n    canvas,\n    theme: appState.theme,\n    scale,\n    zoomValue: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY,\n    boundTextElementVersion:\n      getBoundTextElement(element, elementsMap)?.version || null,\n    containingFrameOpacity:\n      getContainingFrame(element, elementsMap)?.opacity || 100,\n    boundTextCanvas,\n    angle: element.angle,\n    imageCrop: isImageElement(element) ? element.crop : null,\n  };\n};\n\nexport const DEFAULT_LINK_SIZE = 14;\n\nconst IMAGE_PLACEHOLDER_IMG =\n  typeof document !== \"undefined\"\n    ? document.createElement(\"img\")\n    : ({ src: \"\" } as HTMLImageElement); // mock image element outside of browser\n\nIMAGE_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(\n  `<svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"image\" class=\"svg-inline--fa fa-image fa-w-16\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path fill=\"#888\" d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z\"></path></svg>`,\n)}`;\n\nconst IMAGE_ERROR_PLACEHOLDER_IMG =\n  typeof document !== \"undefined\"\n    ? document.createElement(\"img\")\n    : ({ src: \"\" } as HTMLImageElement); // mock image element outside of browser\n\nIMAGE_ERROR_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(\n  `<svg viewBox=\"0 0 668 668\" xmlns=\"http://www.w3.org/2000/svg\" xml:space=\"preserve\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2\"><path d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.81709 0 0 .81709 124.825 145.825)\"/><path d=\"M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.30366 0 0 .30366 506.822 60.065)\"/></svg>`,\n)}`;\n\nconst drawImagePlaceholder = (\n  element: ExcalidrawImageElement,\n  context: CanvasRenderingContext2D,\n) => {\n  context.fillStyle = \"#E7E7E7\";\n  context.fillRect(0, 0, element.width, element.height);\n\n  const imageMinWidthOrHeight = Math.min(element.width, element.height);\n\n  const size = Math.min(\n    imageMinWidthOrHeight,\n    Math.min(imageMinWidthOrHeight * 0.4, 100),\n  );\n\n  context.drawImage(\n    element.status === \"error\"\n      ? IMAGE_ERROR_PLACEHOLDER_IMG\n      : IMAGE_PLACEHOLDER_IMG,\n    element.width / 2 - size / 2,\n    element.height / 2 - size / 2,\n    size,\n    size,\n  );\n};\n\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n) => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"diamond\":\n    case \"ellipse\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n      rc.draw(ShapeCache.get(element)!);\n      break;\n    }\n    case \"arrow\":\n    case \"line\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n\n      ShapeCache.get(element)!.forEach((shape) => {\n        rc.draw(shape);\n      });\n      break;\n    }\n    case \"freedraw\": {\n      // Draw directly to canvas\n      context.save();\n      context.fillStyle = element.strokeColor;\n\n      const path = getFreeDrawPath2D(element) as Path2D;\n      const fillShape = ShapeCache.get(element);\n\n      if (fillShape) {\n        rc.draw(fillShape);\n      }\n\n      context.fillStyle = element.strokeColor;\n      context.fill(path);\n\n      context.restore();\n      break;\n    }\n    case \"image\": {\n      const img = isInitializedImageElement(element)\n        ? renderConfig.imageCache.get(element.fileId)?.image\n        : undefined;\n      if (img != null && !(img instanceof Promise)) {\n        if (element.roundness && context.roundRect) {\n          context.beginPath();\n          context.roundRect(\n            0,\n            0,\n            element.width,\n            element.height,\n            getCornerRadius(Math.min(element.width, element.height), element),\n          );\n          context.clip();\n        }\n\n        const { x, y, width, height } = element.crop\n          ? element.crop\n          : {\n              x: 0,\n              y: 0,\n              width: img.naturalWidth,\n              height: img.naturalHeight,\n            };\n\n        context.drawImage(\n          img,\n          x,\n          y,\n          width,\n          height,\n          0 /* hardcoded for the selection box*/,\n          0,\n          element.width,\n          element.height,\n        );\n      } else {\n        drawImagePlaceholder(element, context);\n      }\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          // to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        context.save();\n        context.font = getFontString(element);\n        context.fillStyle = element.strokeColor;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n\n        const lineHeightPx = getLineHeightInPx(\n          element.fontSize,\n          element.lineHeight,\n        );\n\n        const verticalOffset = getVerticalOffset(\n          element.fontFamily,\n          element.fontSize,\n          lineHeightPx,\n        );\n\n        for (let index = 0; index < lines.length; index++) {\n          context.fillText(\n            lines[index],\n            horizontalOffset,\n            index * lineHeightPx + verticalOffset,\n          );\n        }\n        context.restore();\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n\nexport const elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: NonDeletedSceneElementsMap,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n) => {\n  const zoom: Zoom = renderConfig\n    ? appState.zoom\n    : {\n        value: 1 as NormalizedZoomValue,\n      };\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.zoomValue !== zoom.value &&\n    !appState?.shouldCacheIgnoreZoom;\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n  const boundTextElementVersion = boundTextElement?.version || null;\n  const imageCrop = isImageElement(element) ? element.crop : null;\n\n  const containingFrameOpacity =\n    getContainingFrame(element, elementsMap)?.opacity || 100;\n\n  if (\n    !prevElementWithCanvas ||\n    shouldRegenerateBecauseZoom ||\n    prevElementWithCanvas.theme !== appState.theme ||\n    prevElementWithCanvas.boundTextElementVersion !== boundTextElementVersion ||\n    prevElementWithCanvas.imageCrop !== imageCrop ||\n    prevElementWithCanvas.containingFrameOpacity !== containingFrameOpacity ||\n    // since we rotate the canvas when copying from cached canvas, we don't\n    // regenerate the cached canvas. But we need to in case of labels which are\n    // cached alongside the arrow, and we want the labels to remain unrotated\n    // with respect to the arrow.\n    (isArrowElement(element) &&\n      boundTextElement &&\n      element.angle !== prevElementWithCanvas.angle)\n  ) {\n    const elementWithCanvas = generateElementCanvas(\n      element,\n      elementsMap,\n      zoom,\n      renderConfig,\n      appState,\n    );\n\n    if (!elementWithCanvas) {\n      return null;\n    }\n\n    elementWithCanvasCache.set(element, elementWithCanvas);\n\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n  allElementsMap: NonDeletedSceneElementsMap,\n) => {\n  const element = elementWithCanvas.element;\n  const padding = getCanvasPadding(element);\n  const zoom = elementWithCanvas.scale;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, allElementsMap);\n  const cx = ((x1 + x2) / 2 + appState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + appState.scrollY) * window.devicePixelRatio;\n\n  context.save();\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n\n  const boundTextElement = getBoundTextElement(element, allElementsMap);\n\n  if (isArrowElement(element) && boundTextElement) {\n    const offsetX =\n      (elementWithCanvas.boundTextCanvas.width -\n        elementWithCanvas.canvas!.width) /\n      2;\n    const offsetY =\n      (elementWithCanvas.boundTextCanvas.height -\n        elementWithCanvas.canvas!.height) /\n      2;\n    context.translate(cx, cy);\n    context.drawImage(\n      elementWithCanvas.boundTextCanvas,\n      (-(x2 - x1) / 2) * window.devicePixelRatio - offsetX / zoom - padding,\n      (-(y2 - y1) / 2) * window.devicePixelRatio - offsetY / zoom - padding,\n      elementWithCanvas.boundTextCanvas.width / zoom,\n      elementWithCanvas.boundTextCanvas.height / zoom,\n    );\n  } else {\n    // we translate context to element center so that rotation and scale\n    // originates from the element center\n    context.translate(cx, cy);\n\n    context.rotate(element.angle);\n\n    if (\n      \"scale\" in elementWithCanvas.element &&\n      !isPendingImageElement(element, renderConfig)\n    ) {\n      context.scale(\n        elementWithCanvas.element.scale[0],\n        elementWithCanvas.element.scale[1],\n      );\n    }\n\n    // revert afterwards we don't have account for it during drawing\n    context.translate(-cx, -cy);\n\n    context.drawImage(\n      elementWithCanvas.canvas!,\n      (x1 + appState.scrollX) * window.devicePixelRatio -\n        (padding * elementWithCanvas.scale) / elementWithCanvas.scale,\n      (y1 + appState.scrollY) * window.devicePixelRatio -\n        (padding * elementWithCanvas.scale) / elementWithCanvas.scale,\n      elementWithCanvas.canvas!.width / elementWithCanvas.scale,\n      elementWithCanvas.canvas!.height / elementWithCanvas.scale,\n    );\n\n    if (\n      import.meta.env.VITE_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX ===\n        \"true\" &&\n      hasBoundTextElement(element)\n    ) {\n      const textElement = getBoundTextElement(\n        element,\n        allElementsMap,\n      ) as ExcalidrawTextElementWithContainer;\n      const coords = getContainerCoords(element);\n      context.strokeStyle = \"#c92a2a\";\n      context.lineWidth = 3;\n      context.strokeRect(\n        (coords.x + appState.scrollX) * window.devicePixelRatio,\n        (coords.y + appState.scrollY) * window.devicePixelRatio,\n        getBoundTextMaxWidth(element, textElement) * window.devicePixelRatio,\n        getBoundTextMaxHeight(element, textElement) * window.devicePixelRatio,\n      );\n    }\n  }\n  context.restore();\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderSelectionElement = (\n  element: NonDeletedExcalidrawElement,\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  selectionColor: InteractiveCanvasRenderConfig[\"selectionColor\"],\n) => {\n  context.save();\n  context.translate(element.x + appState.scrollX, element.y + appState.scrollY);\n  context.fillStyle = \"rgba(0, 0, 200, 0.04)\";\n\n  // render from 0.5px offset  to get 1px wide line\n  // https://stackoverflow.com/questions/7530593/html5-canvas-and-line-width/7531540#7531540\n  // TODO can be be improved by offseting to the negative when user selects\n  // from right to left\n  const offset = 0.5 / appState.zoom.value;\n\n  context.fillRect(offset, offset, element.width, element.height);\n  context.lineWidth = 1 / appState.zoom.value;\n  context.strokeStyle = selectionColor;\n  context.strokeRect(offset, offset, element.width, element.height);\n\n  context.restore();\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: RenderableElementsMap,\n  allElementsMap: NonDeletedSceneElementsMap,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n) => {\n  const reduceAlphaForSelection =\n    appState.openDialog?.name === \"elementLinkSelector\" &&\n    !appState.selectedElementIds[element.id] &&\n    !appState.hoveredElementIds[element.id];\n\n  context.globalAlpha = getRenderOpacity(\n    element,\n    getContainingFrame(element, elementsMap),\n    renderConfig.elementsPendingErasure,\n    renderConfig.pendingFlowchartNodes,\n    reduceAlphaForSelection ? DEFAULT_REDUCED_GLOBAL_ALPHA : 1,\n  );\n\n  switch (element.type) {\n    case \"magicframe\":\n    case \"frame\": {\n      if (appState.frameRendering.enabled && appState.frameRendering.outline) {\n        context.save();\n        context.translate(\n          element.x + appState.scrollX,\n          element.y + appState.scrollY,\n        );\n        context.fillStyle = \"rgba(0, 0, 200, 0.04)\";\n\n        context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;\n        context.strokeStyle = FRAME_STYLE.strokeColor;\n\n        // TODO change later to only affect AI frames\n        if (isMagicFrameElement(element)) {\n          context.strokeStyle =\n            appState.theme === THEME.LIGHT ? \"#7affd7\" : \"#1d8264\";\n        }\n\n        if (FRAME_STYLE.radius && context.roundRect) {\n          context.beginPath();\n          context.roundRect(\n            0,\n            0,\n            element.width,\n            element.height,\n            FRAME_STYLE.radius / appState.zoom.value,\n          );\n          context.stroke();\n          context.closePath();\n        } else {\n          context.strokeRect(0, 0, element.width, element.height);\n        }\n\n        context.restore();\n      }\n      break;\n    }\n    case \"freedraw\": {\n      // TODO investigate if we can do this in situ. Right now we need to call\n      // beforehand because math helpers (such as getElementAbsoluteCoords)\n      // rely on existing shapes\n      ShapeCache.generateElementShape(element, null);\n\n      if (renderConfig.isExporting) {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n        const cx = (x1 + x2) / 2 + appState.scrollX;\n        const cy = (y1 + y2) / 2 + appState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.save();\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context, renderConfig, appState);\n        context.restore();\n      } else {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          allElementsMap,\n          renderConfig,\n          appState,\n        );\n        if (!elementWithCanvas) {\n          return;\n        }\n\n        drawElementFromCanvas(\n          elementWithCanvas,\n          context,\n          renderConfig,\n          appState,\n          allElementsMap,\n        );\n      }\n\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"image\":\n    case \"text\":\n    case \"iframe\":\n    case \"embeddable\": {\n      // TODO investigate if we can do this in situ. Right now we need to call\n      // beforehand because math helpers (such as getElementAbsoluteCoords)\n      // rely on existing shapes\n      ShapeCache.generateElementShape(element, renderConfig);\n      if (renderConfig.isExporting) {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n        const cx = (x1 + x2) / 2 + appState.scrollX;\n        const cy = (y1 + y2) / 2 + appState.scrollY;\n        let shiftX = (x2 - x1) / 2 - (element.x - x1);\n        let shiftY = (y2 - y1) / 2 - (element.y - y1);\n        if (isTextElement(element)) {\n          const container = getContainerElement(element, elementsMap);\n          if (isArrowElement(container)) {\n            const boundTextCoords =\n              LinearElementEditor.getBoundTextElementPosition(\n                container,\n                element as ExcalidrawTextElementWithContainer,\n                elementsMap,\n              );\n            shiftX = (x2 - x1) / 2 - (boundTextCoords.x - x1);\n            shiftY = (y2 - y1) / 2 - (boundTextCoords.y - y1);\n          }\n        }\n        context.save();\n        context.translate(cx, cy);\n\n        if (shouldResetImageFilter(element, renderConfig, appState)) {\n          context.filter = \"none\";\n        }\n        const boundTextElement = getBoundTextElement(element, elementsMap);\n\n        if (isArrowElement(element) && boundTextElement) {\n          const tempCanvas = document.createElement(\"canvas\");\n\n          const tempCanvasContext = tempCanvas.getContext(\"2d\")!;\n\n          // Take max dimensions of arrow canvas so that when canvas is rotated\n          // the arrow doesn't get clipped\n          const maxDim = Math.max(distance(x1, x2), distance(y1, y2));\n          const padding = getCanvasPadding(element);\n          tempCanvas.width =\n            maxDim * appState.exportScale + padding * 10 * appState.exportScale;\n          tempCanvas.height =\n            maxDim * appState.exportScale + padding * 10 * appState.exportScale;\n\n          tempCanvasContext.translate(\n            tempCanvas.width / 2,\n            tempCanvas.height / 2,\n          );\n          tempCanvasContext.scale(appState.exportScale, appState.exportScale);\n\n          // Shift the canvas to left most point of the arrow\n          shiftX = element.width / 2 - (element.x - x1);\n          shiftY = element.height / 2 - (element.y - y1);\n\n          tempCanvasContext.rotate(element.angle);\n          const tempRc = rough.canvas(tempCanvas);\n\n          tempCanvasContext.translate(-shiftX, -shiftY);\n\n          drawElementOnCanvas(\n            element,\n            tempRc,\n            tempCanvasContext,\n            renderConfig,\n            appState,\n          );\n\n          tempCanvasContext.translate(shiftX, shiftY);\n\n          tempCanvasContext.rotate(-element.angle);\n\n          // Shift the canvas to center of bound text\n          const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(\n            boundTextElement,\n            elementsMap,\n          );\n          const boundTextShiftX = (x1 + x2) / 2 - boundTextCx;\n          const boundTextShiftY = (y1 + y2) / 2 - boundTextCy;\n          tempCanvasContext.translate(-boundTextShiftX, -boundTextShiftY);\n\n          // Clear the bound text area\n          tempCanvasContext.clearRect(\n            -boundTextElement.width / 2,\n            -boundTextElement.height / 2,\n            boundTextElement.width,\n            boundTextElement.height,\n          );\n          context.scale(1 / appState.exportScale, 1 / appState.exportScale);\n          context.drawImage(\n            tempCanvas,\n            -tempCanvas.width / 2,\n            -tempCanvas.height / 2,\n            tempCanvas.width,\n            tempCanvas.height,\n          );\n        } else {\n          context.rotate(element.angle);\n\n          if (element.type === \"image\") {\n            // note: scale must be applied *after* rotating\n            context.scale(element.scale[0], element.scale[1]);\n          }\n\n          context.translate(-shiftX, -shiftY);\n          drawElementOnCanvas(element, rc, context, renderConfig, appState);\n        }\n\n        context.restore();\n        // not exporting → optimized rendering (cache & render from element\n        // canvases)\n      } else {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          allElementsMap,\n          renderConfig,\n          appState,\n        );\n\n        if (!elementWithCanvas) {\n          return;\n        }\n\n        const currentImageSmoothingStatus = context.imageSmoothingEnabled;\n\n        if (\n          // do not disable smoothing during zoom as blurry shapes look better\n          // on low resolution (while still zooming in) than sharp ones\n          !appState?.shouldCacheIgnoreZoom &&\n          // angle is 0 -> always disable smoothing\n          (!element.angle ||\n            // or check if angle is a right angle in which case we can still\n            // disable smoothing without adversely affecting the result\n            // We need less-than comparison because of FP artihmetic\n            isRightAngleRads(element.angle))\n        ) {\n          // Disabling smoothing makes output much sharper, especially for\n          // text. Unless for non-right angles, where the aliasing is really\n          // terrible on Chromium.\n          //\n          // Note that `context.imageSmoothingQuality=\"high\"` has almost\n          // zero effect.\n          //\n          context.imageSmoothingEnabled = false;\n        }\n\n        if (\n          element.id === appState.croppingElementId &&\n          isImageElement(elementWithCanvas.element) &&\n          elementWithCanvas.element.crop !== null\n        ) {\n          context.save();\n          context.globalAlpha = 0.1;\n\n          const uncroppedElementCanvas = generateElementCanvas(\n            getUncroppedImageElement(elementWithCanvas.element, elementsMap),\n            allElementsMap,\n            appState.zoom,\n            renderConfig,\n            appState,\n          );\n\n          if (uncroppedElementCanvas) {\n            drawElementFromCanvas(\n              uncroppedElementCanvas,\n              context,\n              renderConfig,\n              appState,\n              allElementsMap,\n            );\n          }\n\n          context.restore();\n        }\n\n        drawElementFromCanvas(\n          elementWithCanvas,\n          context,\n          renderConfig,\n          appState,\n          allElementsMap,\n        );\n\n        // reset\n        context.imageSmoothingEnabled = currentImageSmoothingStatus;\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n\n  context.globalAlpha = 1;\n};\n\nexport const pathsCache = new WeakMap<ExcalidrawFreeDrawElement, Path2D>([]);\n\nexport function generateFreeDrawShape(element: ExcalidrawFreeDrawElement) {\n  const svgPathData = getFreeDrawSvgPath(element);\n  const path = new Path2D(svgPathData);\n  pathsCache.set(element, path);\n  return path;\n}\n\nexport function getFreeDrawPath2D(element: ExcalidrawFreeDrawElement) {\n  return pathsCache.get(element);\n}\n\nexport function getFreeDrawSvgPath(element: ExcalidrawFreeDrawElement) {\n  // If input points are empty (should they ever be?) return a dot\n  const inputPoints = element.simulatePressure\n    ? element.points\n    : element.points.length\n    ? element.points.map(([x, y], i) => [x, y, element.pressures[i]])\n    : [[0, 0, 0.5]];\n\n  // Consider changing the options for simulated pressure vs real pressure\n  const options: StrokeOptions = {\n    simulatePressure: element.simulatePressure,\n    size: element.strokeWidth * 4.25,\n    thinning: 0.6,\n    smoothing: 0.5,\n    streamline: 0.5,\n    easing: (t) => Math.sin((t * Math.PI) / 2), // https://easings.net/#easeOutSine\n    last: !!element.lastCommittedPoint, // LastCommittedPoint is added on pointerup\n  };\n\n  return getSvgPathFromStroke(getStroke(inputPoints as number[][], options));\n}\n\nfunction med(A: number[], B: number[]) {\n  return [(A[0] + B[0]) / 2, (A[1] + B[1]) / 2];\n}\n\n// Trim SVG path data so number are each two decimal points. This\n// improves SVG exports, and prevents rendering errors on points\n// with long decimals.\nconst TO_FIXED_PRECISION = /(\\s?[A-Z]?,?-?[0-9]*\\.[0-9]{0,2})(([0-9]|e|-)*)/g;\n\nfunction getSvgPathFromStroke(points: number[][]): string {\n  if (!points.length) {\n    return \"\";\n  }\n\n  const max = points.length - 1;\n\n  return points\n    .reduce(\n      (acc, point, i, arr) => {\n        if (i === max) {\n          acc.push(point, med(point, arr[0]), \"L\", arr[0], \"Z\");\n        } else {\n          acc.push(point, med(point, arr[i + 1]));\n        }\n        return acc;\n      },\n      [\"M\", points[0], \"Q\"],\n    )\n    .join(\" \")\n    .replace(TO_FIXED_PRECISION, \"$1\");\n}\n",
    "function $(e,t,u,x=h=>h){return e*x(.5-t*(.5-u))}function se(e){return[-e[0],-e[1]]}function l(e,t){return[e[0]+t[0],e[1]+t[1]]}function a(e,t){return[e[0]-t[0],e[1]-t[1]]}function b(e,t){return[e[0]*t,e[1]*t]}function he(e,t){return[e[0]/t,e[1]/t]}function R(e){return[e[1],-e[0]]}function B(e,t){return e[0]*t[0]+e[1]*t[1]}function ue(e,t){return e[0]===t[0]&&e[1]===t[1]}function ge(e){return Math.hypot(e[0],e[1])}function de(e){return e[0]*e[0]+e[1]*e[1]}function A(e,t){return de(a(e,t))}function G(e){return he(e,ge(e))}function ie(e,t){return Math.hypot(e[1]-t[1],e[0]-t[0])}function L(e,t,u){let x=Math.sin(u),h=Math.cos(u),y=e[0]-t[0],n=e[1]-t[1],f=y*h-n*x,d=y*x+n*h;return[f+t[0],d+t[1]]}function K(e,t,u){return l(e,b(a(t,e),u))}function ee(e,t,u){return l(e,b(t,u))}var{min:C,PI:xe}=Math,pe=.275,V=xe+1e-4;function ce(e,t={}){let{size:u=16,smoothing:x=.5,thinning:h=.5,simulatePressure:y=!0,easing:n=r=>r,start:f={},end:d={},last:D=!1}=t,{cap:S=!0,easing:j=r=>r*(2-r)}=f,{cap:q=!0,easing:c=r=>--r*r*r+1}=d;if(e.length===0||u<=0)return[];let p=e[e.length-1].runningLength,g=f.taper===!1?0:f.taper===!0?Math.max(u,p):f.taper,T=d.taper===!1?0:d.taper===!0?Math.max(u,p):d.taper,te=Math.pow(u*x,2),_=[],M=[],H=e.slice(0,10).reduce((r,i)=>{let o=i.pressure;if(y){let s=C(1,i.distance/u),W=C(1,1-s);o=C(1,r+(W-r)*(s*pe))}return(r+o)/2},e[0].pressure),m=$(u,h,e[e.length-1].pressure,n),U,X=e[0].vector,z=e[0].point,F=z,O=z,E=F,J=!1;for(let r=0;r<e.length;r++){let{pressure:i}=e[r],{point:o,vector:s,distance:W,runningLength:I}=e[r];if(r<e.length-1&&p-I<3)continue;if(h){if(y){let v=C(1,W/u),Z=C(1,1-v);i=C(1,H+(Z-H)*(v*pe))}m=$(u,h,i,n)}else m=u/2;U===void 0&&(U=m);let le=I<g?j(I/g):1,fe=p-I<T?c((p-I)/T):1;m=Math.max(.01,m*Math.min(le,fe));let re=(r<e.length-1?e[r+1]:e[r]).vector,Y=r<e.length-1?B(s,re):1,be=B(s,X)<0&&!J,ne=Y!==null&&Y<0;if(be||ne){let v=b(R(X),m);for(let Z=1/13,w=0;w<=1;w+=Z)O=L(a(o,v),o,V*w),_.push(O),E=L(l(o,v),o,V*-w),M.push(E);z=O,F=E,ne&&(J=!0);continue}if(J=!1,r===e.length-1){let v=b(R(s),m);_.push(a(o,v)),M.push(l(o,v));continue}let oe=b(R(K(re,s,Y)),m);O=a(o,oe),(r<=1||A(z,O)>te)&&(_.push(O),z=O),E=l(o,oe),(r<=1||A(F,E)>te)&&(M.push(E),F=E),H=i,X=s}let P=e[0].point.slice(0,2),k=e.length>1?e[e.length-1].point.slice(0,2):l(e[0].point,[1,1]),Q=[],N=[];if(e.length===1){if(!(g||T)||D){let r=ee(P,G(R(a(P,k))),-(U||m)),i=[];for(let o=1/13,s=o;s<=1;s+=o)i.push(L(r,P,V*2*s));return i}}else{if(!(g||T&&e.length===1))if(S)for(let i=1/13,o=i;o<=1;o+=i){let s=L(M[0],P,V*o);Q.push(s)}else{let i=a(_[0],M[0]),o=b(i,.5),s=b(i,.51);Q.push(a(P,o),a(P,s),l(P,s),l(P,o))}let r=R(se(e[e.length-1].vector));if(T||g&&e.length===1)N.push(k);else if(q){let i=ee(k,r,m);for(let o=1/29,s=o;s<1;s+=o)N.push(L(i,k,V*3*s))}else N.push(l(k,b(r,m)),l(k,b(r,m*.99)),a(k,b(r,m*.99)),a(k,b(r,m)))}return _.concat(N,M.reverse(),Q)}function me(e,t={}){var q;let{streamline:u=.5,size:x=16,last:h=!1}=t;if(e.length===0)return[];let y=.15+(1-u)*.85,n=Array.isArray(e[0])?e:e.map(({x:c,y:p,pressure:g=.5})=>[c,p,g]);if(n.length===2){let c=n[1];n=n.slice(0,-1);for(let p=1;p<5;p++)n.push(K(n[0],c,p/4))}n.length===1&&(n=[...n,[...l(n[0],[1,1]),...n[0].slice(2)]]);let f=[{point:[n[0][0],n[0][1]],pressure:n[0][2]>=0?n[0][2]:.25,vector:[1,1],distance:0,runningLength:0}],d=!1,D=0,S=f[0],j=n.length-1;for(let c=1;c<n.length;c++){let p=h&&c===j?n[c].slice(0,2):K(S.point,n[c],y);if(ue(S.point,p))continue;let g=ie(p,S.point);if(D+=g,c<j&&!d){if(D<x)continue;d=!0}S={point:p,pressure:n[c][2]>=0?n[c][2]:.5,vector:G(a(S.point,p)),distance:g,runningLength:D},f.push(S)}return f[0].vector=((q=f[1])==null?void 0:q.vector)||[0,0],f}function ae(e,t={}){return ce(me(e,t),t)}var _e=ae;export{_e as default,ae as getStroke,ce as getStrokeOutlinePoints,me as getStrokePoints};\n",
    "import {\n  type Radians,\n  pointFrom,\n  pointCenter,\n  pointRotateRads,\n  vectorFromPoint,\n  vectorNormalize,\n  vectorSubtract,\n  vectorAdd,\n  vectorScale,\n  pointFromVector,\n  clamp,\n  isCloseTo,\n} from \"@excalidraw/math\";\nimport { type Point } from \"points-on-curve\";\n\nimport {\n  elementCenterPoint,\n  getElementAbsoluteCoords,\n  getResizedElementAbsoluteCoords,\n} from \"./bounds\";\n\nimport type { TransformHandleType } from \"./transformHandles\";\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  ExcalidrawImageElement,\n  ImageCrop,\n  NonDeleted,\n} from \"./types\";\n\nexport const MINIMAL_CROP_SIZE = 10;\n\nexport const cropElement = (\n  element: ExcalidrawImageElement,\n  elementsMap: ElementsMap,\n  transformHandle: TransformHandleType,\n  naturalWidth: number,\n  naturalHeight: number,\n  pointerX: number,\n  pointerY: number,\n  widthAspectRatio?: number,\n) => {\n  const { width: uncroppedWidth, height: uncroppedHeight } =\n    getUncroppedWidthAndHeight(element);\n\n  const naturalWidthToUncropped = naturalWidth / uncroppedWidth;\n  const naturalHeightToUncropped = naturalHeight / uncroppedHeight;\n\n  const croppedLeft = (element.crop?.x ?? 0) / naturalWidthToUncropped;\n  const croppedTop = (element.crop?.y ?? 0) / naturalHeightToUncropped;\n\n  /**\n   *      uncropped width\n   * *––––––––––––––––––––––––*\n   * |     (x,y) (natural)    |\n   * |       *–––––––*        |\n   * |       |///////| height | uncropped height\n   * |       *–––––––*        |\n   * |    width (natural)     |\n   * *––––––––––––––––––––––––*\n   */\n\n  const rotatedPointer = pointRotateRads(\n    pointFrom(pointerX, pointerY),\n    elementCenterPoint(element, elementsMap),\n    -element.angle as Radians,\n  );\n\n  pointerX = rotatedPointer[0];\n  pointerY = rotatedPointer[1];\n\n  let nextWidth = element.width;\n  let nextHeight = element.height;\n\n  let crop: ImageCrop | null = element.crop ?? {\n    x: 0,\n    y: 0,\n    width: naturalWidth,\n    height: naturalHeight,\n    naturalWidth,\n    naturalHeight,\n  };\n\n  const previousCropHeight = crop.height;\n  const previousCropWidth = crop.width;\n\n  const isFlippedByX = element.scale[0] === -1;\n  const isFlippedByY = element.scale[1] === -1;\n\n  let changeInHeight = pointerY - element.y;\n  let changeInWidth = pointerX - element.x;\n\n  if (transformHandle.includes(\"n\")) {\n    nextHeight = clamp(\n      element.height - changeInHeight,\n      MINIMAL_CROP_SIZE,\n      isFlippedByY ? uncroppedHeight - croppedTop : element.height + croppedTop,\n    );\n  }\n\n  if (transformHandle.includes(\"s\")) {\n    changeInHeight = pointerY - element.y - element.height;\n    nextHeight = clamp(\n      element.height + changeInHeight,\n      MINIMAL_CROP_SIZE,\n      isFlippedByY ? element.height + croppedTop : uncroppedHeight - croppedTop,\n    );\n  }\n\n  if (transformHandle.includes(\"e\")) {\n    changeInWidth = pointerX - element.x - element.width;\n\n    nextWidth = clamp(\n      element.width + changeInWidth,\n      MINIMAL_CROP_SIZE,\n      isFlippedByX ? element.width + croppedLeft : uncroppedWidth - croppedLeft,\n    );\n  }\n\n  if (transformHandle.includes(\"w\")) {\n    nextWidth = clamp(\n      element.width - changeInWidth,\n      MINIMAL_CROP_SIZE,\n      isFlippedByX ? uncroppedWidth - croppedLeft : element.width + croppedLeft,\n    );\n  }\n\n  const updateCropWidthAndHeight = (crop: ImageCrop) => {\n    crop.height = nextHeight * naturalHeightToUncropped;\n    crop.width = nextWidth * naturalWidthToUncropped;\n  };\n\n  updateCropWidthAndHeight(crop);\n\n  const adjustFlipForHandle = (\n    handle: TransformHandleType,\n    crop: ImageCrop,\n  ) => {\n    updateCropWidthAndHeight(crop);\n    if (handle.includes(\"n\")) {\n      if (!isFlippedByY) {\n        crop.y += previousCropHeight - crop.height;\n      }\n    }\n    if (handle.includes(\"s\")) {\n      if (isFlippedByY) {\n        crop.y += previousCropHeight - crop.height;\n      }\n    }\n    if (handle.includes(\"e\")) {\n      if (isFlippedByX) {\n        crop.x += previousCropWidth - crop.width;\n      }\n    }\n    if (handle.includes(\"w\")) {\n      if (!isFlippedByX) {\n        crop.x += previousCropWidth - crop.width;\n      }\n    }\n  };\n\n  switch (transformHandle) {\n    case \"n\": {\n      if (widthAspectRatio) {\n        const distanceToLeft = croppedLeft + element.width / 2;\n        const distanceToRight =\n          uncroppedWidth - croppedLeft - element.width / 2;\n\n        const MAX_WIDTH = Math.min(distanceToLeft, distanceToRight) * 2;\n\n        nextWidth = clamp(\n          nextHeight * widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_WIDTH,\n        );\n        nextHeight = nextWidth / widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.x += (previousCropWidth - crop.width) / 2;\n      }\n\n      break;\n    }\n    case \"s\": {\n      if (widthAspectRatio) {\n        const distanceToLeft = croppedLeft + element.width / 2;\n        const distanceToRight =\n          uncroppedWidth - croppedLeft - element.width / 2;\n\n        const MAX_WIDTH = Math.min(distanceToLeft, distanceToRight) * 2;\n\n        nextWidth = clamp(\n          nextHeight * widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_WIDTH,\n        );\n        nextHeight = nextWidth / widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.x += (previousCropWidth - crop.width) / 2;\n      }\n\n      break;\n    }\n    case \"w\": {\n      if (widthAspectRatio) {\n        const distanceToTop = croppedTop + element.height / 2;\n        const distanceToBottom =\n          uncroppedHeight - croppedTop - element.height / 2;\n\n        const MAX_HEIGHT = Math.min(distanceToTop, distanceToBottom) * 2;\n\n        nextHeight = clamp(\n          nextWidth / widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_HEIGHT,\n        );\n        nextWidth = nextHeight * widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.y += (previousCropHeight - crop.height) / 2;\n      }\n\n      break;\n    }\n    case \"e\": {\n      if (widthAspectRatio) {\n        const distanceToTop = croppedTop + element.height / 2;\n        const distanceToBottom =\n          uncroppedHeight - croppedTop - element.height / 2;\n\n        const MAX_HEIGHT = Math.min(distanceToTop, distanceToBottom) * 2;\n\n        nextHeight = clamp(\n          nextWidth / widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_HEIGHT,\n        );\n        nextWidth = nextHeight * widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.y += (previousCropHeight - crop.height) / 2;\n      }\n\n      break;\n    }\n    case \"ne\": {\n      if (widthAspectRatio) {\n        if (changeInWidth > -changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? uncroppedHeight - croppedTop\n            : croppedTop + element.height;\n\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? croppedLeft + element.width\n            : uncroppedWidth - croppedLeft;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    case \"nw\": {\n      if (widthAspectRatio) {\n        if (changeInWidth < changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? uncroppedHeight - croppedTop\n            : croppedTop + element.height;\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? uncroppedWidth - croppedLeft\n            : croppedLeft + element.width;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    case \"se\": {\n      if (widthAspectRatio) {\n        if (changeInWidth > changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? croppedTop + element.height\n            : uncroppedHeight - croppedTop;\n\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? croppedLeft + element.width\n            : uncroppedWidth - croppedLeft;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    case \"sw\": {\n      if (widthAspectRatio) {\n        if (-changeInWidth > changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? croppedTop + element.height\n            : uncroppedHeight - croppedTop;\n\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? uncroppedWidth - croppedLeft\n            : croppedLeft + element.width;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    default:\n      break;\n  }\n\n  const newOrigin = recomputeOrigin(\n    element,\n    transformHandle,\n    nextWidth,\n    nextHeight,\n    !!widthAspectRatio,\n  );\n\n  // reset crop to null if we're back to orig size\n  if (\n    isCloseTo(crop.width, crop.naturalWidth) &&\n    isCloseTo(crop.height, crop.naturalHeight)\n  ) {\n    crop = null;\n  }\n\n  return {\n    x: newOrigin[0],\n    y: newOrigin[1],\n    width: nextWidth,\n    height: nextHeight,\n    crop,\n  };\n};\n\nconst recomputeOrigin = (\n  stateAtCropStart: NonDeleted<ExcalidrawElement>,\n  transformHandle: TransformHandleType,\n  width: number,\n  height: number,\n  shouldMaintainAspectRatio?: boolean,\n) => {\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    stateAtCropStart,\n    stateAtCropStart.width,\n    stateAtCropStart.height,\n    true,\n  );\n  const startTopLeft = pointFrom(x1, y1);\n  const startBottomRight = pointFrom(x2, y2);\n  const startCenter: any = pointCenter(startTopLeft, startBottomRight);\n\n  const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] =\n    getResizedElementAbsoluteCoords(stateAtCropStart, width, height, true);\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1;\n\n  // Calculate new topLeft based on fixed corner during resize\n  let newTopLeft = [...startTopLeft] as [number, number];\n\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandle)) {\n    newTopLeft = [\n      startBottomRight[0] - Math.abs(newBoundsWidth),\n      startBottomRight[1] - Math.abs(newBoundsHeight),\n    ];\n  }\n  if (transformHandle === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandle === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  }\n\n  if (shouldMaintainAspectRatio) {\n    if ([\"s\", \"n\"].includes(transformHandle)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n    if ([\"e\", \"w\"].includes(transformHandle)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  }\n\n  // adjust topLeft to new rotation point\n  const angle = stateAtCropStart.angle;\n  const rotatedTopLeft = pointRotateRads(newTopLeft, startCenter, angle);\n  const newCenter: Point = [\n    newTopLeft[0] + Math.abs(newBoundsWidth) / 2,\n    newTopLeft[1] + Math.abs(newBoundsHeight) / 2,\n  ];\n  const rotatedNewCenter = pointRotateRads(newCenter, startCenter, angle);\n  newTopLeft = pointRotateRads(\n    rotatedTopLeft,\n    rotatedNewCenter,\n    -angle as Radians,\n  );\n\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtCropStart.x - newBoundsX1;\n  newOrigin[1] += stateAtCropStart.y - newBoundsY1;\n\n  return newOrigin;\n};\n\n// refer to https://link.excalidraw.com/l/6rfy1007QOo/6stx5PmRn0k\nexport const getUncroppedImageElement = (\n  element: ExcalidrawImageElement,\n  elementsMap: ElementsMap,\n) => {\n  if (element.crop) {\n    const { width, height } = getUncroppedWidthAndHeight(element);\n\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n      element,\n      elementsMap,\n    );\n\n    const topLeftVector = vectorFromPoint(\n      pointRotateRads(pointFrom(x1, y1), pointFrom(cx, cy), element.angle),\n    );\n    const topRightVector = vectorFromPoint(\n      pointRotateRads(pointFrom(x2, y1), pointFrom(cx, cy), element.angle),\n    );\n    const topEdgeNormalized = vectorNormalize(\n      vectorSubtract(topRightVector, topLeftVector),\n    );\n    const bottomLeftVector = vectorFromPoint(\n      pointRotateRads(pointFrom(x1, y2), pointFrom(cx, cy), element.angle),\n    );\n    const leftEdgeVector = vectorSubtract(bottomLeftVector, topLeftVector);\n    const leftEdgeNormalized = vectorNormalize(leftEdgeVector);\n\n    const { cropX, cropY } = adjustCropPosition(element.crop, element.scale);\n\n    const rotatedTopLeft = vectorAdd(\n      vectorAdd(\n        topLeftVector,\n        vectorScale(\n          topEdgeNormalized,\n          (-cropX * width) / element.crop.naturalWidth,\n        ),\n      ),\n      vectorScale(\n        leftEdgeNormalized,\n        (-cropY * height) / element.crop.naturalHeight,\n      ),\n    );\n\n    const center = pointFromVector(\n      vectorAdd(\n        vectorAdd(rotatedTopLeft, vectorScale(topEdgeNormalized, width / 2)),\n        vectorScale(leftEdgeNormalized, height / 2),\n      ),\n    );\n\n    const unrotatedTopLeft = pointRotateRads(\n      pointFromVector(rotatedTopLeft),\n      center,\n      -element.angle as Radians,\n    );\n\n    const uncroppedElement: ExcalidrawImageElement = {\n      ...element,\n      x: unrotatedTopLeft[0],\n      y: unrotatedTopLeft[1],\n      width,\n      height,\n      crop: null,\n    };\n\n    return uncroppedElement;\n  }\n\n  return element;\n};\n\nexport const getUncroppedWidthAndHeight = (element: ExcalidrawImageElement) => {\n  if (element.crop) {\n    const width =\n      element.width / (element.crop.width / element.crop.naturalWidth);\n    const height =\n      element.height / (element.crop.height / element.crop.naturalHeight);\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  return {\n    width: element.width,\n    height: element.height,\n  };\n};\n\nconst adjustCropPosition = (\n  crop: ImageCrop,\n  scale: ExcalidrawImageElement[\"scale\"],\n) => {\n  let cropX = crop.x;\n  let cropY = crop.y;\n\n  const flipX = scale[0] === -1;\n  const flipY = scale[1] === -1;\n\n  if (flipX) {\n    cropX = crop.naturalWidth - Math.abs(cropX) - crop.width;\n  }\n\n  if (flipY) {\n    cropY = crop.naturalHeight - Math.abs(cropY) - crop.height;\n  }\n\n  return {\n    cropX,\n    cropY,\n  };\n};\n\nexport const getFlipAdjustedCropPosition = (\n  element: ExcalidrawImageElement,\n  natural = false,\n) => {\n  const crop = element.crop;\n  if (!crop) {\n    return null;\n  }\n\n  const isFlippedByX = element.scale[0] === -1;\n  const isFlippedByY = element.scale[1] === -1;\n\n  let cropX = crop.x;\n  let cropY = crop.y;\n\n  if (isFlippedByX) {\n    cropX = crop.naturalWidth - crop.width - crop.x;\n  }\n\n  if (isFlippedByY) {\n    cropY = crop.naturalHeight - crop.height - crop.y;\n  }\n\n  if (natural) {\n    return {\n      x: cropX,\n      y: cropY,\n    };\n  }\n\n  const { width, height } = getUncroppedWidthAndHeight(element);\n\n  return {\n    x: cropX / (crop.naturalWidth / width),\n    y: cropY / (crop.naturalHeight / height),\n  };\n};\n",
    "import {\n  pointCenter,\n  pointFrom,\n  pointRotateRads,\n  pointsEqual,\n  type GlobalPoint,\n  type LocalPoint,\n  pointDistance,\n  vectorFromPoint,\n  curveLength,\n  curvePointAtLength,\n} from \"@excalidraw/math\";\n\nimport { getCurvePathOps } from \"@excalidraw/utils/shape\";\n\nimport {\n  DRAGGING_THRESHOLD,\n  KEYS,\n  shouldRotateWithDiscreteAngle,\n  getGridPoint,\n  invariant,\n  tupleToCoors,\n  viewportCoordsToSceneCoords,\n} from \"@excalidraw/common\";\n\nimport {\n  deconstructLinearOrFreeDrawElement,\n  isPathALoop,\n  type Store,\n} from \"@excalidraw/element\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type {\n  AppState,\n  PointerCoords,\n  InteractiveCanvasAppState,\n  AppClassProperties,\n  NullableGridSize,\n  Zoom,\n} from \"excalidraw-custom/types\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport {\n  bindOrUnbindLinearElement,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n  maybeSuggestBindingsForLinearElementAtCoords,\n} from \"./binding\";\nimport {\n  getElementAbsoluteCoords,\n  getElementPointsCoords,\n  getMinMaxXYFromCurvePathOps,\n} from \"./bounds\";\n\nimport { headingIsHorizontal, vectorToHeading } from \"./heading\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\nimport {\n  isBindingElement,\n  isElbowArrow,\n  isFixedPointBinding,\n} from \"./typeChecks\";\n\nimport { ShapeCache, toggleLinePolygonState } from \"./shape\";\n\nimport { getLockedLinearCursorAlignSize } from \"./sizeHelpers\";\n\nimport { isLineElement } from \"./typeChecks\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { Bounds } from \"./bounds\";\nimport type {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n  PointBinding,\n  ExcalidrawBindableElement,\n  ExcalidrawTextElementWithContainer,\n  ElementsMap,\n  NonDeletedSceneElementsMap,\n  FixedPointBinding,\n  FixedSegment,\n  ExcalidrawElbowArrowElement,\n  PointsPositionUpdates,\n} from \"./types\";\n\n/**\n * Normalizes line points so that the start point is at [0,0]. This is\n * expected in various parts of the codebase.\n *\n * Also returns the offsets - [0,0] if no normalization needed.\n *\n * @private\n */\nconst getNormalizedPoints = ({\n  points,\n}: {\n  points: ExcalidrawLinearElement[\"points\"];\n}): {\n  points: LocalPoint[];\n  offsetX: number;\n  offsetY: number;\n} => {\n  const offsetX = points[0][0];\n  const offsetY = points[0][1];\n\n  return {\n    points: points.map((p) => {\n      return pointFrom(p[0] - offsetX, p[1] - offsetY);\n    }),\n    offsetX,\n    offsetY,\n  };\n};\n\nexport class LinearElementEditor {\n  public readonly elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  /** indices */\n  public readonly selectedPointsIndices: readonly number[] | null;\n\n  public readonly pointerDownState: Readonly<{\n    prevSelectedPointsIndices: readonly number[] | null;\n    /** index */\n    lastClickedPoint: number;\n    lastClickedIsEndPoint: boolean;\n    origin: Readonly<{ x: number; y: number }> | null;\n    segmentMidpoint: {\n      value: GlobalPoint | null;\n      index: number | null;\n      added: boolean;\n    };\n  }>;\n\n  /** whether you're dragging a point */\n  public readonly isDragging: boolean;\n  public readonly lastUncommittedPoint: LocalPoint | null;\n  public readonly pointerOffset: Readonly<{ x: number; y: number }>;\n  public readonly startBindingElement:\n    | ExcalidrawBindableElement\n    | null\n    | \"keep\";\n  public readonly endBindingElement: ExcalidrawBindableElement | null | \"keep\";\n  public readonly hoverPointIndex: number;\n  public readonly segmentMidPointHoveredCoords: GlobalPoint | null;\n  public readonly elbowed: boolean;\n  public readonly customLineAngle: number | null;\n\n  constructor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n  ) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    if (!pointsEqual(element.points[0], pointFrom(0, 0))) {\n      console.error(\"Linear element is not normalized\", Error().stack);\n      mutateElement(\n        element,\n        elementsMap,\n        LinearElementEditor.getNormalizeElementPointsAndCoords(element),\n      );\n    }\n    this.selectedPointsIndices = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n    this.pointerDownState = {\n      prevSelectedPointsIndices: null,\n      lastClickedPoint: -1,\n      lastClickedIsEndPoint: false,\n      origin: null,\n\n      segmentMidpoint: {\n        value: null,\n        index: null,\n        added: false,\n      },\n    };\n    this.hoverPointIndex = -1;\n    this.segmentMidPointHoveredCoords = null;\n    this.elbowed = isElbowArrow(element) && element.elbowed;\n    this.customLineAngle = null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 10;\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement<T extends ExcalidrawLinearElement>(\n    id: InstanceType<typeof LinearElementEditor>[\"elementId\"],\n    elementsMap: ElementsMap,\n  ): T | null {\n    const element = elementsMap.get(id);\n    if (element) {\n      return element as NonDeleted<T>;\n    }\n    return null;\n  }\n\n  static handleBoxSelection(\n    event: PointerEvent,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    elementsMap: NonDeletedSceneElementsMap,\n  ) {\n    if (!appState.editingLinearElement || !appState.selectionElement) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    const { selectedPointsIndices, elementId } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return false;\n    }\n\n    const [selectionX1, selectionY1, selectionX2, selectionY2] =\n      getElementAbsoluteCoords(appState.selectionElement, elementsMap);\n\n    const pointsSceneCoords = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n\n    const nextSelectedPoints = pointsSceneCoords\n      .reduce((acc: number[], point, index) => {\n        if (\n          (point[0] >= selectionX1 &&\n            point[0] <= selectionX2 &&\n            point[1] >= selectionY1 &&\n            point[1] <= selectionY2) ||\n          (event.shiftKey && selectedPointsIndices?.includes(index))\n        ) {\n          acc.push(index);\n        }\n\n        return acc;\n      }, [])\n      .filter((index) => {\n        if (\n          isElbowArrow(element) &&\n          index !== 0 &&\n          index !== element.points.length - 1\n        ) {\n          return false;\n        }\n        return true;\n      });\n\n    setState({\n      editingLinearElement: {\n        ...editingLinearElement,\n        selectedPointsIndices: nextSelectedPoints.length\n          ? nextSelectedPoints\n          : null,\n      },\n    });\n  }\n\n  /**\n   * @returns whether point was dragged\n   */\n  static handlePointDragging(\n    event: PointerEvent,\n    app: AppClassProperties,\n    scenePointerX: number,\n    scenePointerY: number,\n    linearElementEditor: LinearElementEditor,\n  ): Pick<AppState, keyof AppState> | null {\n    if (!linearElementEditor) {\n      return null;\n    }\n    const { elementId } = linearElementEditor;\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    let customLineAngle = linearElementEditor.customLineAngle;\n    if (!element) {\n      return null;\n    }\n\n    if (\n      isElbowArrow(element) &&\n      !linearElementEditor.pointerDownState.lastClickedIsEndPoint &&\n      linearElementEditor.pointerDownState.lastClickedPoint !== 0\n    ) {\n      return null;\n    }\n\n    const selectedPointsIndices = isElbowArrow(element)\n      ? [\n          !!linearElementEditor.selectedPointsIndices?.includes(0)\n            ? 0\n            : undefined,\n          !!linearElementEditor.selectedPointsIndices?.find((idx) => idx > 0)\n            ? element.points.length - 1\n            : undefined,\n        ].filter((idx): idx is number => idx !== undefined)\n      : linearElementEditor.selectedPointsIndices;\n    const lastClickedPoint = isElbowArrow(element)\n      ? linearElementEditor.pointerDownState.lastClickedPoint > 0\n        ? element.points.length - 1\n        : 0\n      : linearElementEditor.pointerDownState.lastClickedPoint;\n\n    // point that's being dragged (out of all selected points)\n    const draggingPoint = element.points[lastClickedPoint];\n\n    if (selectedPointsIndices && draggingPoint) {\n      if (\n        shouldRotateWithDiscreteAngle(event) &&\n        selectedPointsIndices.length === 1 &&\n        element.points.length > 1\n      ) {\n        const selectedIndex = selectedPointsIndices[0];\n        const referencePoint =\n          element.points[selectedIndex === 0 ? 1 : selectedIndex - 1];\n        customLineAngle =\n          linearElementEditor.customLineAngle ??\n          Math.atan2(\n            element.points[selectedIndex][1] - referencePoint[1],\n            element.points[selectedIndex][0] - referencePoint[0],\n          );\n\n        const [width, height] = LinearElementEditor._getShiftLockedDelta(\n          element,\n          elementsMap,\n          referencePoint,\n          pointFrom(scenePointerX, scenePointerY),\n          event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n          customLineAngle,\n        );\n\n        LinearElementEditor.movePoints(\n          element,\n          app.scene,\n          new Map([\n            [\n              selectedIndex,\n              {\n                point: pointFrom(\n                  width + referencePoint[0],\n                  height + referencePoint[1],\n                ),\n                isDragging: selectedIndex === lastClickedPoint,\n              },\n            ],\n          ]),\n        );\n      } else {\n        const newDraggingPointPosition = LinearElementEditor.createPointAt(\n          element,\n          elementsMap,\n          scenePointerX - linearElementEditor.pointerOffset.x,\n          scenePointerY - linearElementEditor.pointerOffset.y,\n          event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n        );\n\n        const deltaX = newDraggingPointPosition[0] - draggingPoint[0];\n        const deltaY = newDraggingPointPosition[1] - draggingPoint[1];\n\n        LinearElementEditor.movePoints(\n          element,\n          app.scene,\n          new Map(\n            selectedPointsIndices.map((pointIndex) => {\n              const newPointPosition: LocalPoint =\n                pointIndex === lastClickedPoint\n                  ? LinearElementEditor.createPointAt(\n                      element,\n                      elementsMap,\n                      scenePointerX - linearElementEditor.pointerOffset.x,\n                      scenePointerY - linearElementEditor.pointerOffset.y,\n                      event[KEYS.CTRL_OR_CMD]\n                        ? null\n                        : app.getEffectiveGridSize(),\n                    )\n                  : pointFrom(\n                      element.points[pointIndex][0] + deltaX,\n                      element.points[pointIndex][1] + deltaY,\n                    );\n              return [\n                pointIndex,\n                {\n                  point: newPointPosition,\n                  isDragging: pointIndex === lastClickedPoint,\n                },\n              ];\n            }),\n          ),\n        );\n      }\n\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n      if (boundTextElement) {\n        handleBindTextResize(element, app.scene, false);\n      }\n\n      // suggest bindings for first and last point if selected\n      let suggestedBindings: ExcalidrawBindableElement[] = [];\n      if (isBindingElement(element, false)) {\n        const firstSelectedIndex = selectedPointsIndices[0] === 0;\n        const lastSelectedIndex =\n          selectedPointsIndices[selectedPointsIndices.length - 1] ===\n          element.points.length - 1;\n        const coords: { x: number; y: number }[] = [];\n\n        if (!firstSelectedIndex !== !lastSelectedIndex) {\n          coords.push({ x: scenePointerX, y: scenePointerY });\n        } else {\n          if (firstSelectedIndex) {\n            coords.push(\n              tupleToCoors(\n                LinearElementEditor.getPointGlobalCoordinates(\n                  element,\n                  element.points[0],\n                  elementsMap,\n                ),\n              ),\n            );\n          }\n\n          if (lastSelectedIndex) {\n            coords.push(\n              tupleToCoors(\n                LinearElementEditor.getPointGlobalCoordinates(\n                  element,\n                  element.points[\n                    selectedPointsIndices[selectedPointsIndices.length - 1]\n                  ],\n                  elementsMap,\n                ),\n              ),\n            );\n          }\n        }\n\n        if (coords.length) {\n          suggestedBindings = maybeSuggestBindingsForLinearElementAtCoords(\n            element,\n            coords,\n            app.scene,\n            app.state.zoom,\n          );\n        }\n      }\n\n      const newLinearElementEditor = {\n        ...linearElementEditor,\n        selectedPointsIndices,\n        segmentMidPointHoveredCoords:\n          lastClickedPoint !== 0 &&\n          lastClickedPoint !== element.points.length - 1\n            ? this.getPointGlobalCoordinates(\n                element,\n                draggingPoint,\n                elementsMap,\n              )\n            : null,\n        hoverPointIndex:\n          lastClickedPoint === 0 ||\n          lastClickedPoint === element.points.length - 1\n            ? lastClickedPoint\n            : -1,\n        isDragging: true,\n        customLineAngle,\n      };\n\n      return {\n        ...app.state,\n        editingLinearElement: app.state.editingLinearElement\n          ? newLinearElementEditor\n          : null,\n        selectedLinearElement: newLinearElementEditor,\n        suggestedBindings,\n      };\n    }\n\n    return null;\n  }\n\n  static handlePointerUp(\n    event: PointerEvent,\n    editingLinearElement: LinearElementEditor,\n    appState: AppState,\n    scene: Scene,\n  ): LinearElementEditor {\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const elements = scene.getNonDeletedElements();\n    const pointerCoords = viewportCoordsToSceneCoords(event, appState);\n\n    const { elementId, selectedPointsIndices, isDragging, pointerDownState } =\n      editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const bindings: Mutable<\n      Partial<\n        Pick<\n          InstanceType<typeof LinearElementEditor>,\n          \"startBindingElement\" | \"endBindingElement\"\n        >\n      >\n    > = {};\n\n    if (isDragging && selectedPointsIndices) {\n      for (const selectedPoint of selectedPointsIndices) {\n        if (\n          selectedPoint === 0 ||\n          selectedPoint === element.points.length - 1\n        ) {\n          if (isPathALoop(element.points, appState.zoom.value)) {\n            if (isLineElement(element)) {\n              scene.mutateElement(\n                element,\n                {\n                  ...toggleLinePolygonState(element, true),\n                },\n                {\n                  informMutation: false,\n                  isDragging: false,\n                },\n              );\n            }\n            LinearElementEditor.movePoints(\n              element,\n              scene,\n              new Map([\n                [\n                  selectedPoint,\n                  {\n                    point:\n                      selectedPoint === 0\n                        ? element.points[element.points.length - 1]\n                        : element.points[0],\n                  },\n                ],\n              ]),\n            );\n          }\n\n          const bindingElement = isBindingEnabled(appState)\n            ? getHoveredElementForBinding(\n                (selectedPointsIndices?.length ?? 0) > 1\n                  ? tupleToCoors(\n                      LinearElementEditor.getPointAtIndexGlobalCoordinates(\n                        element,\n                        selectedPoint!,\n                        elementsMap,\n                      ),\n                    )\n                  : pointerCoords,\n                elements,\n                elementsMap,\n                appState.zoom,\n                isElbowArrow(element),\n                isElbowArrow(element),\n              )\n            : null;\n\n          bindings[\n            selectedPoint === 0 ? \"startBindingElement\" : \"endBindingElement\"\n          ] = bindingElement;\n        }\n      }\n    }\n\n    return {\n      ...editingLinearElement,\n      ...bindings,\n      segmentMidPointHoveredCoords: null,\n      hoverPointIndex: -1,\n      // if clicking without previously dragging a point(s), and not holding\n      // shift, deselect all points except the one clicked. If holding shift,\n      // toggle the point.\n      selectedPointsIndices:\n        isDragging || event.shiftKey\n          ? !isDragging &&\n            event.shiftKey &&\n            pointerDownState.prevSelectedPointsIndices?.includes(\n              pointerDownState.lastClickedPoint,\n            )\n            ? selectedPointsIndices &&\n              selectedPointsIndices.filter(\n                (pointIndex) =>\n                  pointIndex !== pointerDownState.lastClickedPoint,\n              )\n            : selectedPointsIndices\n          : selectedPointsIndices?.includes(pointerDownState.lastClickedPoint)\n          ? [pointerDownState.lastClickedPoint]\n          : selectedPointsIndices,\n      isDragging: false,\n      pointerOffset: { x: 0, y: 0 },\n      customLineAngle: null,\n    };\n  }\n\n  static getEditorMidPoints = (\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    appState: InteractiveCanvasAppState,\n  ): (GlobalPoint | null)[] => {\n    const boundText = getBoundTextElement(element, elementsMap);\n\n    // Since its not needed outside editor unless 2 pointer lines or bound text\n    if (\n      !isElbowArrow(element) &&\n      !appState.editingLinearElement &&\n      element.points.length > 2 &&\n      !boundText\n    ) {\n      return [];\n    }\n\n    const points = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n\n    let index = 0;\n    const midpoints: (GlobalPoint | null)[] = [];\n    while (index < points.length - 1) {\n      if (\n        LinearElementEditor.isSegmentTooShort(\n          element,\n          element.points[index],\n          element.points[index + 1],\n          index,\n          appState.zoom,\n        )\n      ) {\n        midpoints.push(null);\n        index++;\n        continue;\n      }\n      const segmentMidPoint = LinearElementEditor.getSegmentMidPoint(\n        element,\n        index + 1,\n      );\n      midpoints.push(segmentMidPoint);\n      index++;\n    }\n\n    return midpoints;\n  };\n\n  static getSegmentMidpointHitCoords = (\n    linearElementEditor: LinearElementEditor,\n    scenePointer: { x: number; y: number },\n    appState: AppState,\n    elementsMap: ElementsMap,\n  ): GlobalPoint | null => {\n    const { elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return null;\n    }\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      elementsMap,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    if (!isElbowArrow(element) && clickedPointIndex >= 0) {\n      return null;\n    }\n    const points = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n    if (\n      points.length >= 3 &&\n      !appState.editingLinearElement &&\n      !isElbowArrow(element)\n    ) {\n      return null;\n    }\n\n    const threshold =\n      (LinearElementEditor.POINT_HANDLE_SIZE + 1) / appState.zoom.value;\n\n    const existingSegmentMidpointHitCoords =\n      linearElementEditor.segmentMidPointHoveredCoords;\n    if (existingSegmentMidpointHitCoords) {\n      const distance = pointDistance(\n        pointFrom(\n          existingSegmentMidpointHitCoords[0],\n          existingSegmentMidpointHitCoords[1],\n        ),\n        pointFrom(scenePointer.x, scenePointer.y),\n      );\n      if (distance <= threshold) {\n        return existingSegmentMidpointHitCoords;\n      }\n    }\n    let index = 0;\n    const midPoints = LinearElementEditor.getEditorMidPoints(\n      element,\n      elementsMap,\n      appState,\n    );\n\n    while (index < midPoints.length) {\n      if (midPoints[index] !== null) {\n        const distance = pointDistance(\n          midPoints[index]!,\n          pointFrom(scenePointer.x, scenePointer.y),\n        );\n        if (distance <= threshold) {\n          return midPoints[index];\n        }\n      }\n\n      index++;\n    }\n    return null;\n  };\n\n  static isSegmentTooShort<P extends GlobalPoint | LocalPoint>(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    startPoint: P,\n    endPoint: P,\n    index: number,\n    zoom: Zoom,\n  ) {\n    if (isElbowArrow(element)) {\n      if (index >= 0 && index < element.points.length) {\n        return (\n          pointDistance(startPoint, endPoint) * zoom.value <\n          LinearElementEditor.POINT_HANDLE_SIZE / 2\n        );\n      }\n\n      return false;\n    }\n\n    let distance = pointDistance(startPoint, endPoint);\n    if (element.points.length > 2 && element.roundness) {\n      const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n\n      invariant(\n        lines.length === 0 && curves.length > 0,\n        \"Only linears built out of curves are supported\",\n      );\n      invariant(\n        lines.length + curves.length >= index,\n        \"Invalid segment index while calculating mid point\",\n      );\n\n      distance = curveLength<GlobalPoint>(curves[index]);\n    }\n\n    return distance * zoom.value < LinearElementEditor.POINT_HANDLE_SIZE * 4;\n  }\n\n  static getSegmentMidPoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    index: number,\n  ): GlobalPoint {\n    if (isElbowArrow(element)) {\n      invariant(\n        element.points.length >= index,\n        \"Invalid segment index while calculating elbow arrow mid point\",\n      );\n\n      const p = pointCenter(element.points[index - 1], element.points[index]);\n\n      return pointFrom<GlobalPoint>(element.x + p[0], element.y + p[1]);\n    }\n\n    const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n\n    invariant(\n      (lines.length === 0 && curves.length > 0) ||\n        (lines.length > 0 && curves.length === 0),\n      \"Only linears built out of either segments or curves are supported\",\n    );\n    invariant(\n      lines.length + curves.length >= index,\n      \"Invalid segment index while calculating mid point\",\n    );\n\n    if (lines.length) {\n      const segment = lines[index - 1];\n      return pointCenter(segment[0], segment[1]);\n    }\n\n    if (curves.length) {\n      const segment = curves[index - 1];\n      return curvePointAtLength(segment, 0.5);\n    }\n\n    invariant(false, \"Invalid segment type while calculating mid point\");\n  }\n\n  static getSegmentMidPointIndex(\n    linearElementEditor: LinearElementEditor,\n    appState: AppState,\n    midPoint: GlobalPoint,\n    elementsMap: ElementsMap,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n      elementsMap,\n    );\n    if (!element) {\n      return -1;\n    }\n    const midPoints = LinearElementEditor.getEditorMidPoints(\n      element,\n      elementsMap,\n      appState,\n    );\n    let index = 0;\n    while (index < midPoints.length) {\n      if (LinearElementEditor.arePointsEqual(midPoint, midPoints[index])) {\n        return index + 1;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLElement>,\n    app: AppClassProperties,\n    store: Store,\n    scenePointer: { x: number; y: number },\n    linearElementEditor: LinearElementEditor,\n    scene: Scene,\n  ): {\n    didAddPoint: boolean;\n    hitElement: NonDeleted<ExcalidrawElement> | null;\n    linearElementEditor: LinearElementEditor | null;\n  } {\n    const appState = app.state;\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const elements = scene.getNonDeletedElements();\n\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n      linearElementEditor: null,\n    };\n\n    if (!linearElementEditor) {\n      return ret;\n    }\n\n    const { elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n\n    if (!element) {\n      return ret;\n    }\n    const segmentMidpoint = LinearElementEditor.getSegmentMidpointHitCoords(\n      linearElementEditor,\n      scenePointer,\n      appState,\n      elementsMap,\n    );\n    let segmentMidpointIndex = null;\n    if (segmentMidpoint) {\n      segmentMidpointIndex = LinearElementEditor.getSegmentMidPointIndex(\n        linearElementEditor,\n        appState,\n        segmentMidpoint,\n        elementsMap,\n      );\n    } else if (event.altKey && appState.editingLinearElement) {\n      if (linearElementEditor.lastUncommittedPoint == null) {\n        scene.mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              elementsMap,\n              scenePointer.x,\n              scenePointer.y,\n              event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n            ),\n          ],\n        });\n        ret.didAddPoint = true;\n      }\n      store.scheduleCapture();\n      ret.linearElementEditor = {\n        ...linearElementEditor,\n        pointerDownState: {\n          prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n          lastClickedPoint: -1,\n          lastClickedIsEndPoint: false,\n          origin: { x: scenePointer.x, y: scenePointer.y },\n          segmentMidpoint: {\n            value: segmentMidpoint,\n            index: segmentMidpointIndex,\n            added: false,\n          },\n        },\n        selectedPointsIndices: [element.points.length - 1],\n        lastUncommittedPoint: null,\n        endBindingElement: getHoveredElementForBinding(\n          scenePointer,\n          elements,\n          elementsMap,\n          app.state.zoom,\n          linearElementEditor.elbowed,\n        ),\n      };\n\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      elementsMap,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex >= 0 || segmentMidpoint) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, instead of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const { startBindingElement, endBindingElement } = linearElementEditor;\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(\n          element,\n          startBindingElement,\n          endBindingElement,\n          scene,\n        );\n      }\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      pointRotateRads(\n        pointFrom(\n          element.x + element.points[clickedPointIndex][0],\n          element.y + element.points[clickedPointIndex][1],\n        ),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n\n    const nextSelectedPointsIndices =\n      clickedPointIndex > -1 || event.shiftKey\n        ? event.shiftKey ||\n          linearElementEditor.selectedPointsIndices?.includes(clickedPointIndex)\n          ? normalizeSelectedPoints([\n              ...(linearElementEditor.selectedPointsIndices || []),\n              clickedPointIndex,\n            ])\n          : [clickedPointIndex]\n        : null;\n    ret.linearElementEditor = {\n      ...linearElementEditor,\n      pointerDownState: {\n        prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n        lastClickedPoint: clickedPointIndex,\n        lastClickedIsEndPoint: clickedPointIndex === element.points.length - 1,\n        origin: { x: scenePointer.x, y: scenePointer.y },\n        segmentMidpoint: {\n          value: segmentMidpoint,\n          index: segmentMidpointIndex,\n          added: false,\n        },\n      },\n      selectedPointsIndices: nextSelectedPointsIndices,\n      pointerOffset: targetPoint\n        ? {\n            x: scenePointer.x - targetPoint[0],\n            y: scenePointer.y - targetPoint[1],\n          }\n        : { x: 0, y: 0 },\n    };\n\n    return ret;\n  }\n\n  static arePointsEqual<Point extends LocalPoint | GlobalPoint>(\n    point1: Point | null,\n    point2: Point | null,\n  ) {\n    if (!point1 && !point2) {\n      return true;\n    }\n    if (!point1 || !point2) {\n      return false;\n    }\n    return pointsEqual(point1, point2);\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    app: AppClassProperties,\n  ): LinearElementEditor | null {\n    const appState = app.state;\n    if (!appState.editingLinearElement) {\n      return null;\n    }\n    const { elementId, lastUncommittedPoint } = appState.editingLinearElement;\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return appState.editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.deletePoints(element, app, [points.length - 1]);\n      }\n      return {\n        ...appState.editingLinearElement,\n        lastUncommittedPoint: null,\n      };\n    }\n\n    let newPoint: LocalPoint;\n\n    if (shouldRotateWithDiscreteAngle(event) && points.length >= 2) {\n      const lastCommittedPoint = points[points.length - 2];\n\n      const [width, height] = LinearElementEditor._getShiftLockedDelta(\n        element,\n        elementsMap,\n        lastCommittedPoint,\n        pointFrom(scenePointerX, scenePointerY),\n        event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n      );\n\n      newPoint = pointFrom(\n        width + lastCommittedPoint[0],\n        height + lastCommittedPoint[1],\n      );\n    } else {\n      newPoint = LinearElementEditor.createPointAt(\n        element,\n        elementsMap,\n        scenePointerX - appState.editingLinearElement.pointerOffset.x,\n        scenePointerY - appState.editingLinearElement.pointerOffset.y,\n        event[KEYS.CTRL_OR_CMD] || isElbowArrow(element)\n          ? null\n          : app.getEffectiveGridSize(),\n      );\n    }\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoints(\n        element,\n        app.scene,\n        new Map([\n          [\n            element.points.length - 1,\n            {\n              point: newPoint,\n            },\n          ],\n        ]),\n      );\n    } else {\n      LinearElementEditor.addPoints(element, app.scene, [newPoint]);\n    }\n    return {\n      ...appState.editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  /** scene coords */\n  static getPointGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    p: LocalPoint,\n    elementsMap: ElementsMap,\n  ): GlobalPoint {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const { x, y } = element;\n    return pointRotateRads(\n      pointFrom(x + p[0], y + p[1]),\n      pointFrom(cx, cy),\n      element.angle,\n    );\n  }\n\n  /** scene coords */\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n  ): GlobalPoint[] {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((p) => {\n      const { x, y } = element;\n      return pointRotateRads(\n        pointFrom(x + p[0], y + p[1]),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n\n    indexMaybeFromEnd: number, // -1 for last element\n    elementsMap: ElementsMap,\n  ): GlobalPoint {\n    const index =\n      indexMaybeFromEnd < 0\n        ? element.points.length + indexMaybeFromEnd\n        : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const p = element.points[index];\n    const { x, y } = element;\n\n    return p\n      ? pointRotateRads(\n          pointFrom(x + p[0], y + p[1]),\n          pointFrom(cx, cy),\n          element.angle,\n        )\n      : pointRotateRads(pointFrom(x, y), pointFrom(cx, cy), element.angle);\n  }\n\n  static pointFromAbsoluteCoords(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    absoluteCoords: GlobalPoint,\n    elementsMap: ElementsMap,\n  ): LocalPoint {\n    if (isElbowArrow(element)) {\n      // No rotation for elbow arrows\n      return pointFrom(\n        absoluteCoords[0] - element.x,\n        absoluteCoords[1] - element.y,\n      );\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = pointRotateRads(\n      pointFrom(absoluteCoords[0], absoluteCoords[1]),\n      pointFrom(cx, cy),\n      -element.angle as Radians,\n    );\n    return pointFrom(x - element.x, y - element.y);\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const p = pointHandles[idx];\n      if (\n        pointDistance(pointFrom(x, y), pointFrom(p[0], p[1])) * zoom.value <\n        // +1px to account for outline stroke\n        LinearElementEditor.POINT_HANDLE_SIZE + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: NullableGridSize,\n  ): LocalPoint {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = pointRotateRads(\n      pointFrom(pointerOnGrid[0], pointerOnGrid[1]),\n      pointFrom(cx, cy),\n      -element.angle as Radians,\n    );\n\n    return pointFrom(rotatedX - element.x, rotatedY - element.y);\n  }\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   * expected in various parts of the codebase.\n   *\n   * Also returns normalized x and y coords to account for the normalization\n   * of the points.\n   */\n  static getNormalizeElementPointsAndCoords(element: ExcalidrawLinearElement) {\n    const { points, offsetX, offsetY } = getNormalizedPoints(element);\n\n    return {\n      points,\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    };\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n  static duplicateSelectedPoints(appState: AppState, scene: Scene): AppState {\n    invariant(\n      appState.editingLinearElement,\n      \"Not currently editing a linear element\",\n    );\n\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const { selectedPointsIndices, elementId } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n\n    invariant(\n      element,\n      \"The linear element does not exist in the provided Scene\",\n    );\n    invariant(\n      selectedPointsIndices != null,\n      \"There are no selected points to duplicate\",\n    );\n\n    const { points } = element;\n\n    const nextSelectedIndices: number[] = [];\n\n    let pointAddedToEnd = false;\n    let indexCursor = -1;\n    const nextPoints = points.reduce((acc: LocalPoint[], p, index) => {\n      ++indexCursor;\n      acc.push(p);\n\n      const isSelected = selectedPointsIndices.includes(index);\n      if (isSelected) {\n        const nextPoint = points[index + 1];\n\n        if (!nextPoint) {\n          pointAddedToEnd = true;\n        }\n        acc.push(\n          nextPoint\n            ? pointFrom((p[0] + nextPoint[0]) / 2, (p[1] + nextPoint[1]) / 2)\n            : pointFrom(p[0], p[1]),\n        );\n\n        nextSelectedIndices.push(indexCursor + 1);\n        ++indexCursor;\n      }\n\n      return acc;\n    }, []);\n\n    scene.mutateElement(element, { points: nextPoints });\n\n    // temp hack to ensure the line doesn't move when adding point to the end,\n    // potentially expanding the bounding box\n    if (pointAddedToEnd) {\n      const lastPoint = element.points[element.points.length - 1];\n      LinearElementEditor.movePoints(\n        element,\n        scene,\n        new Map([\n          [\n            element.points.length - 1,\n            { point: pointFrom(lastPoint[0] + 30, lastPoint[1] + 30) },\n          ],\n        ]),\n      );\n    }\n\n    return {\n      ...appState,\n      editingLinearElement: {\n        ...appState.editingLinearElement,\n        selectedPointsIndices: nextSelectedIndices,\n      },\n    };\n  }\n\n  static deletePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    app: AppClassProperties,\n    pointIndices: readonly number[],\n  ) {\n    const isUncommittedPoint =\n      app.state.editingLinearElement?.lastUncommittedPoint ===\n      element.points[element.points.length - 1];\n\n    const nextPoints = element.points.filter((_, idx) => {\n      return !pointIndices.includes(idx);\n    });\n\n    const isPolygon = isLineElement(element) && element.polygon;\n\n    // keep polygon intact if deleting start/end point or uncommitted point\n    if (\n      isPolygon &&\n      (isUncommittedPoint ||\n        pointIndices.includes(0) ||\n        pointIndices.includes(element.points.length - 1))\n    ) {\n      nextPoints[0] = pointFrom(\n        nextPoints[nextPoints.length - 1][0],\n        nextPoints[nextPoints.length - 1][1],\n      );\n    }\n\n    const {\n      points: normalizedPoints,\n      offsetX,\n      offsetY,\n    } = getNormalizedPoints({ points: nextPoints });\n\n    LinearElementEditor._updatePoints(\n      element,\n      app.scene,\n      normalizedPoints,\n      offsetX,\n      offsetY,\n    );\n  }\n\n  static addPoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scene: Scene,\n    addedPoints: LocalPoint[],\n  ) {\n    const nextPoints = [...element.points, ...addedPoints];\n\n    if (isLineElement(element) && element.polygon) {\n      nextPoints[0] = pointFrom(\n        nextPoints[nextPoints.length - 1][0],\n        nextPoints[nextPoints.length - 1][1],\n      );\n    }\n\n    const {\n      points: normalizedPoints,\n      offsetX,\n      offsetY,\n    } = getNormalizedPoints({ points: nextPoints });\n\n    LinearElementEditor._updatePoints(\n      element,\n      scene,\n      normalizedPoints,\n      offsetX,\n      offsetY,\n    );\n  }\n\n  static movePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scene: Scene,\n    pointUpdates: PointsPositionUpdates,\n    otherUpdates?: {\n      startBinding?: PointBinding | null;\n      endBinding?: PointBinding | null;\n    },\n  ) {\n    const { points } = element;\n\n    // if polygon, move start and end points together\n    if (isLineElement(element) && element.polygon) {\n      const firstPointUpdate = pointUpdates.get(0);\n      const lastPointUpdate = pointUpdates.get(points.length - 1);\n\n      if (firstPointUpdate) {\n        pointUpdates.set(points.length - 1, {\n          point: pointFrom(\n            firstPointUpdate.point[0],\n            firstPointUpdate.point[1],\n          ),\n          isDragging: firstPointUpdate.isDragging,\n        });\n      } else if (lastPointUpdate) {\n        pointUpdates.set(0, {\n          point: pointFrom(lastPointUpdate.point[0], lastPointUpdate.point[1]),\n          isDragging: lastPointUpdate.isDragging,\n        });\n      }\n    }\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n\n    const updatedOriginPoint =\n      pointUpdates.get(0)?.point ?? pointFrom<LocalPoint>(0, 0);\n\n    const [offsetX, offsetY] = updatedOriginPoint;\n\n    const nextPoints = isElbowArrow(element)\n      ? [\n          pointUpdates.get(0)?.point ?? points[0],\n          pointUpdates.get(points.length - 1)?.point ??\n            points[points.length - 1],\n        ]\n      : points.map((p, idx) => {\n          const current = pointUpdates.get(idx)?.point ?? p;\n\n          return pointFrom<LocalPoint>(\n            current[0] - offsetX,\n            current[1] - offsetY,\n          );\n        });\n\n    LinearElementEditor._updatePoints(\n      element,\n      scene,\n      nextPoints,\n      offsetX,\n      offsetY,\n      otherUpdates,\n      {\n        isDragging: Array.from(pointUpdates.values()).some((t) => t.isDragging),\n      },\n    );\n  }\n\n  static shouldAddMidpoint(\n    linearElementEditor: LinearElementEditor,\n    pointerCoords: PointerCoords,\n    appState: AppState,\n    elementsMap: ElementsMap,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n      elementsMap,\n    );\n\n    // Elbow arrows don't allow midpoints\n    if (element && isElbowArrow(element)) {\n      return false;\n    }\n\n    if (!element) {\n      return false;\n    }\n\n    const { segmentMidpoint } = linearElementEditor.pointerDownState;\n\n    if (\n      segmentMidpoint.added ||\n      segmentMidpoint.value === null ||\n      segmentMidpoint.index === null ||\n      linearElementEditor.pointerDownState.origin === null\n    ) {\n      return false;\n    }\n\n    const origin = linearElementEditor.pointerDownState.origin!;\n    const dist = pointDistance(\n      pointFrom(origin.x, origin.y),\n      pointFrom(pointerCoords.x, pointerCoords.y),\n    );\n    if (\n      !appState.editingLinearElement &&\n      dist < DRAGGING_THRESHOLD / appState.zoom.value\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  static addMidpoint(\n    linearElementEditor: LinearElementEditor,\n    pointerCoords: PointerCoords,\n    app: AppClassProperties,\n    snapToGrid: boolean,\n    scene: Scene,\n  ) {\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n      elementsMap,\n    );\n    if (!element) {\n      return;\n    }\n    const { segmentMidpoint } = linearElementEditor.pointerDownState;\n    const ret: {\n      pointerDownState: LinearElementEditor[\"pointerDownState\"];\n      selectedPointsIndices: LinearElementEditor[\"selectedPointsIndices\"];\n    } = {\n      pointerDownState: linearElementEditor.pointerDownState,\n      selectedPointsIndices: linearElementEditor.selectedPointsIndices,\n    };\n\n    const midpoint = LinearElementEditor.createPointAt(\n      element,\n      elementsMap,\n      pointerCoords.x,\n      pointerCoords.y,\n      snapToGrid && !isElbowArrow(element) ? app.getEffectiveGridSize() : null,\n    );\n    const points = [\n      ...element.points.slice(0, segmentMidpoint.index!),\n      midpoint,\n      ...element.points.slice(segmentMidpoint.index!),\n    ];\n\n    scene.mutateElement(element, { points });\n\n    ret.pointerDownState = {\n      ...linearElementEditor.pointerDownState,\n      segmentMidpoint: {\n        ...linearElementEditor.pointerDownState.segmentMidpoint,\n        added: true,\n      },\n      lastClickedPoint: segmentMidpoint.index!,\n    };\n    ret.selectedPointsIndices = [segmentMidpoint.index!];\n    return ret;\n  }\n\n  private static _updatePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scene: Scene,\n    nextPoints: readonly LocalPoint[],\n    offsetX: number,\n    offsetY: number,\n    otherUpdates?: {\n      startBinding?: PointBinding | null;\n      endBinding?: PointBinding | null;\n    },\n    options?: {\n      isDragging?: boolean;\n      zoom?: AppState[\"zoom\"];\n      sceneElementsMap?: NonDeletedSceneElementsMap;\n    },\n  ) {\n    if (isElbowArrow(element)) {\n      const updates: {\n        startBinding?: FixedPointBinding | null;\n        endBinding?: FixedPointBinding | null;\n        points?: LocalPoint[];\n      } = {};\n      if (otherUpdates?.startBinding !== undefined) {\n        updates.startBinding =\n          otherUpdates.startBinding !== null &&\n          isFixedPointBinding(otherUpdates.startBinding)\n            ? otherUpdates.startBinding\n            : null;\n      }\n      if (otherUpdates?.endBinding !== undefined) {\n        updates.endBinding =\n          otherUpdates.endBinding !== null &&\n          isFixedPointBinding(otherUpdates.endBinding)\n            ? otherUpdates.endBinding\n            : null;\n      }\n\n      updates.points = Array.from(nextPoints);\n\n      scene.mutateElement(element, updates, {\n        informMutation: true,\n        isDragging: options?.isDragging ?? false,\n      });\n    } else {\n      // TODO do we need to get precise coords here just to calc centers?\n      const nextCoords = getElementPointsCoords(element, nextPoints);\n      const prevCoords = getElementPointsCoords(element, element.points);\n      const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n      const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n      const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n      const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n      const dX = prevCenterX - nextCenterX;\n      const dY = prevCenterY - nextCenterY;\n      const rotatedOffset = pointRotateRads(\n        pointFrom(offsetX, offsetY),\n        pointFrom(dX, dY),\n        element.angle,\n      );\n      scene.mutateElement(element, {\n        ...otherUpdates,\n        points: nextPoints,\n        x: element.x + rotatedOffset[0],\n        y: element.y + rotatedOffset[1],\n      });\n    }\n  }\n\n  private static _getShiftLockedDelta(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    referencePoint: LocalPoint,\n    scenePointer: GlobalPoint,\n    gridSize: NullableGridSize,\n    customLineAngle?: number,\n  ) {\n    const referencePointCoords = LinearElementEditor.getPointGlobalCoordinates(\n      element,\n      referencePoint,\n      elementsMap,\n    );\n\n    if (isElbowArrow(element)) {\n      return [\n        scenePointer[0] - referencePointCoords[0],\n        scenePointer[1] - referencePointCoords[1],\n      ];\n    }\n\n    const [gridX, gridY] = getGridPoint(\n      scenePointer[0],\n      scenePointer[1],\n      gridSize,\n    );\n\n    const { width, height } = getLockedLinearCursorAlignSize(\n      referencePointCoords[0],\n      referencePointCoords[1],\n      gridX,\n      gridY,\n      customLineAngle,\n    );\n\n    return pointRotateRads(\n      pointFrom(width, height),\n      pointFrom(0, 0),\n      -element.angle as Radians,\n    );\n  }\n\n  static getBoundTextElementPosition = (\n    element: ExcalidrawLinearElement,\n    boundTextElement: ExcalidrawTextElementWithContainer,\n    elementsMap: ElementsMap,\n  ): { x: number; y: number } => {\n    const points = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n    if (points.length < 2) {\n      mutateElement(boundTextElement, elementsMap, { isDeleted: true });\n    }\n    let x = 0;\n    let y = 0;\n    if (element.points.length % 2 === 1) {\n      const index = Math.floor(element.points.length / 2);\n      const midPoint = LinearElementEditor.getPointGlobalCoordinates(\n        element,\n        element.points[index],\n        elementsMap,\n      );\n      x = midPoint[0] - boundTextElement.width / 2;\n      y = midPoint[1] - boundTextElement.height / 2;\n    } else {\n      const index = element.points.length / 2 - 1;\n      const midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(\n        element,\n        index + 1,\n      );\n\n      x = midSegmentMidpoint[0] - boundTextElement.width / 2;\n      y = midSegmentMidpoint[1] - boundTextElement.height / 2;\n    }\n    return { x, y };\n  };\n\n  static getMinMaxXYWithBoundText = (\n    element: ExcalidrawLinearElement,\n    elementsMap: ElementsMap,\n    elementBounds: Bounds,\n    boundTextElement: ExcalidrawTextElementWithContainer,\n  ): [number, number, number, number, number, number] => {\n    let [x1, y1, x2, y2] = elementBounds;\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const { x: boundTextX1, y: boundTextY1 } =\n      LinearElementEditor.getBoundTextElementPosition(\n        element,\n        boundTextElement,\n        elementsMap,\n      );\n    const boundTextX2 = boundTextX1 + boundTextElement.width;\n    const boundTextY2 = boundTextY1 + boundTextElement.height;\n    const centerPoint = pointFrom(cx, cy);\n\n    const topLeftRotatedPoint = pointRotateRads(\n      pointFrom(x1, y1),\n      centerPoint,\n      element.angle,\n    );\n    const topRightRotatedPoint = pointRotateRads(\n      pointFrom(x2, y1),\n      centerPoint,\n      element.angle,\n    );\n\n    const counterRotateBoundTextTopLeft = pointRotateRads(\n      pointFrom(boundTextX1, boundTextY1),\n      centerPoint,\n      -element.angle as Radians,\n    );\n    const counterRotateBoundTextTopRight = pointRotateRads(\n      pointFrom(boundTextX2, boundTextY1),\n      centerPoint,\n      -element.angle as Radians,\n    );\n    const counterRotateBoundTextBottomLeft = pointRotateRads(\n      pointFrom(boundTextX1, boundTextY2),\n      centerPoint,\n      -element.angle as Radians,\n    );\n    const counterRotateBoundTextBottomRight = pointRotateRads(\n      pointFrom(boundTextX2, boundTextY2),\n      centerPoint,\n      -element.angle as Radians,\n    );\n\n    if (\n      topLeftRotatedPoint[0] < topRightRotatedPoint[0] &&\n      topLeftRotatedPoint[1] >= topRightRotatedPoint[1]\n    ) {\n      x1 = Math.min(x1, counterRotateBoundTextBottomLeft[0]);\n      x2 = Math.max(\n        x2,\n        Math.max(\n          counterRotateBoundTextTopRight[0],\n          counterRotateBoundTextBottomRight[0],\n        ),\n      );\n      y1 = Math.min(y1, counterRotateBoundTextTopLeft[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextBottomRight[1]);\n    } else if (\n      topLeftRotatedPoint[0] >= topRightRotatedPoint[0] &&\n      topLeftRotatedPoint[1] > topRightRotatedPoint[1]\n    ) {\n      x1 = Math.min(x1, counterRotateBoundTextBottomRight[0]);\n      x2 = Math.max(\n        x2,\n        Math.max(\n          counterRotateBoundTextTopLeft[0],\n          counterRotateBoundTextTopRight[0],\n        ),\n      );\n      y1 = Math.min(y1, counterRotateBoundTextBottomLeft[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextTopRight[1]);\n    } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0]) {\n      x1 = Math.min(x1, counterRotateBoundTextTopRight[0]);\n      x2 = Math.max(x2, counterRotateBoundTextBottomLeft[0]);\n      y1 = Math.min(y1, counterRotateBoundTextBottomRight[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextTopLeft[1]);\n    } else if (topLeftRotatedPoint[1] <= topRightRotatedPoint[1]) {\n      x1 = Math.min(\n        x1,\n        Math.min(\n          counterRotateBoundTextTopRight[0],\n          counterRotateBoundTextTopLeft[0],\n        ),\n      );\n\n      x2 = Math.max(x2, counterRotateBoundTextBottomRight[0]);\n      y1 = Math.min(y1, counterRotateBoundTextTopRight[1]);\n      y2 = Math.max(y2, counterRotateBoundTextBottomLeft[1]);\n    }\n\n    return [x1, y1, x2, y2, cx, cy];\n  };\n\n  static getElementAbsoluteCoords = (\n    element: ExcalidrawLinearElement,\n    elementsMap: ElementsMap,\n    includeBoundText: boolean = false,\n  ): [number, number, number, number, number, number] => {\n    let coords: [number, number, number, number, number, number];\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    if (element.points.length < 2 || !ShapeCache.get(element)) {\n      // XXX this is just a poor estimate and not very useful\n      const { minX, minY, maxX, maxY } = element.points.reduce(\n        (limits, [x, y]) => {\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          return limits;\n        },\n        { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n      );\n      x1 = minX + element.x;\n      y1 = minY + element.y;\n      x2 = maxX + element.x;\n      y2 = maxY + element.y;\n    } else {\n      const shape = ShapeCache.generateElementShape(element, null);\n\n      // first element is always the curve\n      const ops = getCurvePathOps(shape[0]);\n\n      const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n      x1 = minX + element.x;\n      y1 = minY + element.y;\n      x2 = maxX + element.x;\n      y2 = maxY + element.y;\n    }\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    coords = [x1, y1, x2, y2, cx, cy];\n\n    if (!includeBoundText) {\n      return coords;\n    }\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n    if (boundTextElement) {\n      coords = LinearElementEditor.getMinMaxXYWithBoundText(\n        element,\n        elementsMap,\n        [x1, y1, x2, y2],\n        boundTextElement,\n      );\n    }\n\n    return coords;\n  };\n\n  static moveFixedSegment(\n    linearElement: LinearElementEditor,\n    index: number,\n    x: number,\n    y: number,\n    scene: Scene,\n  ): LinearElementEditor {\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(\n      linearElement.elementId,\n      elementsMap,\n    );\n\n    if (!element || !isElbowArrow(element)) {\n      return linearElement;\n    }\n\n    if (index && index > 0 && index < element.points.length) {\n      const isHorizontal = headingIsHorizontal(\n        vectorToHeading(\n          vectorFromPoint(element.points[index], element.points[index - 1]),\n        ),\n      );\n\n      const fixedSegments = (element.fixedSegments ?? []).reduce(\n        (segments, s) => {\n          segments[s.index] = s;\n          return segments;\n        },\n        {} as Record<number, FixedSegment>,\n      );\n      fixedSegments[index] = {\n        index,\n        start: pointFrom<LocalPoint>(\n          !isHorizontal ? x - element.x : element.points[index - 1][0],\n          isHorizontal ? y - element.y : element.points[index - 1][1],\n        ),\n        end: pointFrom<LocalPoint>(\n          !isHorizontal ? x - element.x : element.points[index][0],\n          isHorizontal ? y - element.y : element.points[index][1],\n        ),\n      };\n      const nextFixedSegments = Object.values(fixedSegments).sort(\n        (a, b) => a.index - b.index,\n      );\n\n      const offset = nextFixedSegments\n        .map((segment) => segment.index)\n        .reduce((count, idx) => (idx < index ? count + 1 : count), 0);\n\n      scene.mutateElement(element, {\n        fixedSegments: nextFixedSegments,\n      });\n\n      const point = pointFrom<GlobalPoint>(\n        element.x +\n          (element.fixedSegments![offset].start[0] +\n            element.fixedSegments![offset].end[0]) /\n            2,\n        element.y +\n          (element.fixedSegments![offset].start[1] +\n            element.fixedSegments![offset].end[1]) /\n            2,\n      );\n\n      return {\n        ...linearElement,\n        segmentMidPointHoveredCoords: point,\n        pointerDownState: {\n          ...linearElement.pointerDownState,\n          segmentMidpoint: {\n            added: false,\n            index: element.fixedSegments![offset].index,\n            value: point,\n          },\n        },\n      };\n    }\n\n    return linearElement;\n  }\n\n  static deleteFixedSegment(\n    element: ExcalidrawElbowArrowElement,\n    scene: Scene,\n    index: number,\n  ): void {\n    scene.mutateElement(element, {\n      fixedSegments: element.fixedSegments?.filter(\n        (segment) => segment.index !== index,\n      ),\n    });\n  }\n}\n\nconst normalizeSelectedPoints = (\n  points: (number | null)[],\n): number[] | null => {\n  let nextPoints = [\n    ...new Set(points.filter((p) => p !== null && p !== -1)),\n  ] as number[];\n  nextPoints = nextPoints.sort((a, b) => a - b);\n  return nextPoints.length ? nextPoints : null;\n};\n",
    "import {\n  KEYS,\n  arrayToMap,\n  isBindingFallthroughEnabled,\n  tupleToCoors,\n  invariant,\n  isDevEnv,\n  isTestEnv,\n} from \"@excalidraw/common\";\n\nimport {\n  lineSegment,\n  pointFrom,\n  pointRotateRads,\n  type GlobalPoint,\n  vectorFromPoint,\n  pointDistanceSq,\n  clamp,\n  pointDistance,\n  pointFromVector,\n  vectorScale,\n  vectorNormalize,\n  vectorCross,\n  pointsEqual,\n  lineSegmentIntersectionPoints,\n  PRECISION,\n} from \"@excalidraw/math\";\n\nimport type { LocalPoint, Radians } from \"@excalidraw/math\";\n\nimport type { AppState } from \"excalidraw-custom/types\";\n\nimport type { MapEntry, Mutable } from \"@excalidraw/common/utility-types\";\n\nimport {\n  doBoundsIntersect,\n  getCenterForBounds,\n  getElementBounds,\n} from \"./bounds\";\nimport { intersectElementWithLineSegment } from \"./collision\";\nimport { distanceToElement } from \"./distance\";\nimport {\n  headingForPointFromElement,\n  headingIsHorizontal,\n  vectorToHeading,\n  type Heading,\n} from \"./heading\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\nimport {\n  isArrowElement,\n  isBindableElement,\n  isBoundToContainer,\n  isElbowArrow,\n  isFixedPointBinding,\n  isFrameLikeElement,\n  isLinearElement,\n  isRectanguloidElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport { aabbForElement, elementCenterPoint } from \"./bounds\";\nimport { updateElbowArrowPoints } from \"./elbowArrow\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { Bounds } from \"./bounds\";\nimport type { ElementUpdate } from \"./mutateElement\";\nimport type {\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  NonDeleted,\n  ExcalidrawLinearElement,\n  PointBinding,\n  NonDeletedExcalidrawElement,\n  ElementsMap,\n  NonDeletedSceneElementsMap,\n  ExcalidrawTextElement,\n  ExcalidrawArrowElement,\n  ExcalidrawElbowArrowElement,\n  FixedPoint,\n  FixedPointBinding,\n  PointsPositionUpdates,\n} from \"./types\";\n\nexport type SuggestedBinding =\n  | NonDeleted<ExcalidrawBindableElement>\n  | SuggestedPointBinding;\n\nexport type SuggestedPointBinding = [\n  NonDeleted<ExcalidrawLinearElement>,\n  \"start\" | \"end\" | \"both\",\n  NonDeleted<ExcalidrawBindableElement>,\n];\n\nexport const shouldEnableBindingForPointerEvent = (\n  event: React.PointerEvent<HTMLElement>,\n) => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\n\nexport const isBindingEnabled = (appState: AppState): boolean => {\n  return appState.isBindingEnabled;\n};\n\nexport const FIXED_BINDING_DISTANCE = 5;\nexport const BINDING_HIGHLIGHT_THICKNESS = 10;\n\nconst getNonDeletedElements = (\n  scene: Scene,\n  ids: readonly ExcalidrawElement[\"id\"][],\n): NonDeleted<ExcalidrawElement>[] => {\n  const result: NonDeleted<ExcalidrawElement>[] = [];\n  ids.forEach((id) => {\n    const element = scene.getNonDeletedElement(id);\n    if (element != null) {\n      result.push(element);\n    }\n  });\n  return result;\n};\n\nexport const bindOrUnbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  endBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  scene: Scene,\n): void => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  const unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    startBindingElement,\n    endBindingElement,\n    \"start\",\n    boundToElementIds,\n    unboundFromElementIds,\n    scene,\n    elementsMap,\n  );\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    endBindingElement,\n    startBindingElement,\n    \"end\",\n    boundToElementIds,\n    unboundFromElementIds,\n    scene,\n    elementsMap,\n  );\n\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(\n    (id) => !boundToElementIds.has(id),\n  );\n\n  getNonDeletedElements(scene, onlyUnbound).forEach((element) => {\n    scene.mutateElement(element, {\n      boundElements: element.boundElements?.filter(\n        (element) =>\n          element.type !== \"arrow\" || element.id !== linearElement.id,\n      ),\n    });\n  });\n};\n\nconst bindOrUnbindLinearElementEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement | null | \"keep\",\n  otherEdgeBindableElement: ExcalidrawBindableElement | null | \"keep\",\n  startOrEnd: \"start\" | \"end\",\n  // Is mutated\n  boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  // Is mutated\n  unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  scene: Scene,\n  elementsMap: ElementsMap,\n): void => {\n  // \"keep\" is for method chaining convenience, a \"no-op\", so just bail out\n  if (bindableElement === \"keep\") {\n    return;\n  }\n\n  // null means break the bind, so nothing to consider here\n  if (bindableElement === null) {\n    const unbound = unbindLinearElement(linearElement, startOrEnd, scene);\n    if (unbound != null) {\n      unboundFromElementIds.add(unbound);\n    }\n    return;\n  }\n\n  // While complext arrows can do anything, simple arrow with both ends trying\n  // to bind to the same bindable should not be allowed, start binding takes\n  // precedence\n  if (isLinearElementSimple(linearElement)) {\n    if (\n      otherEdgeBindableElement == null ||\n      (otherEdgeBindableElement === \"keep\"\n        ? // TODO: Refactor - Needlessly complex\n          !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n            linearElement,\n            bindableElement,\n            startOrEnd,\n          )\n        : startOrEnd === \"start\" ||\n          otherEdgeBindableElement.id !== bindableElement.id)\n    ) {\n      bindLinearElement(linearElement, bindableElement, startOrEnd, scene);\n      boundToElementIds.add(bindableElement.id);\n    }\n  } else {\n    bindLinearElement(linearElement, bindableElement, startOrEnd, scene);\n    boundToElementIds.add(bindableElement.id);\n  }\n};\n\nconst getOriginalBindingsIfStillCloseToArrowEnds = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom?: AppState[\"zoom\"],\n): (NonDeleted<ExcalidrawElement> | null)[] =>\n  ([\"start\", \"end\"] as const).map((edge) => {\n    const coors = getLinearElementEdgeCoors(linearElement, edge, elementsMap);\n    const elementId =\n      edge === \"start\"\n        ? linearElement.startBinding?.elementId\n        : linearElement.endBinding?.elementId;\n    if (elementId) {\n      const element = elementsMap.get(elementId);\n      if (\n        isBindableElement(element) &&\n        bindingBorderTest(element, coors, elementsMap, zoom)\n      ) {\n        return element;\n      }\n    }\n\n    return null;\n  });\n\nconst getBindingStrategyForDraggingArrowEndpoints = (\n  selectedElement: NonDeleted<ExcalidrawLinearElement>,\n  isBindingEnabled: boolean,\n  draggingPoints: readonly number[],\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly NonDeletedExcalidrawElement[],\n  zoom?: AppState[\"zoom\"],\n): (NonDeleted<ExcalidrawBindableElement> | null | \"keep\")[] => {\n  const startIdx = 0;\n  const endIdx = selectedElement.points.length - 1;\n  const startDragged = draggingPoints.findIndex((i) => i === startIdx) > -1;\n  const endDragged = draggingPoints.findIndex((i) => i === endIdx) > -1;\n  const start = startDragged\n    ? isBindingEnabled\n      ? getEligibleElementForBindingElement(\n          selectedElement,\n          \"start\",\n          elementsMap,\n          elements,\n          zoom,\n        )\n      : null // If binding is disabled and start is dragged, break all binds\n    : \"keep\";\n  const end = endDragged\n    ? isBindingEnabled\n      ? getEligibleElementForBindingElement(\n          selectedElement,\n          \"end\",\n          elementsMap,\n          elements,\n          zoom,\n        )\n      : null // If binding is disabled and end is dragged, break all binds\n    : \"keep\";\n\n  return [start, end];\n};\n\nconst getBindingStrategyForDraggingArrowOrJoints = (\n  selectedElement: NonDeleted<ExcalidrawLinearElement>,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly NonDeletedExcalidrawElement[],\n  isBindingEnabled: boolean,\n  zoom?: AppState[\"zoom\"],\n): (NonDeleted<ExcalidrawBindableElement> | null | \"keep\")[] => {\n  // Elbow arrows don't bind when dragged as a whole\n  if (isElbowArrow(selectedElement)) {\n    return [\"keep\", \"keep\"];\n  }\n\n  const [startIsClose, endIsClose] = getOriginalBindingsIfStillCloseToArrowEnds(\n    selectedElement,\n    elementsMap,\n    zoom,\n  );\n  const start = startIsClose\n    ? isBindingEnabled\n      ? getEligibleElementForBindingElement(\n          selectedElement,\n          \"start\",\n          elementsMap,\n          elements,\n          zoom,\n        )\n      : null\n    : null;\n  const end = endIsClose\n    ? isBindingEnabled\n      ? getEligibleElementForBindingElement(\n          selectedElement,\n          \"end\",\n          elementsMap,\n          elements,\n          zoom,\n        )\n      : null\n    : null;\n\n  return [start, end];\n};\n\nexport const bindOrUnbindLinearElements = (\n  selectedElements: NonDeleted<ExcalidrawLinearElement>[],\n  isBindingEnabled: boolean,\n  draggingPoints: readonly number[] | null,\n  scene: Scene,\n  zoom?: AppState[\"zoom\"],\n): void => {\n  selectedElements.forEach((selectedElement) => {\n    const [start, end] = draggingPoints?.length\n      ? // The arrow edge points are dragged (i.e. start, end)\n        getBindingStrategyForDraggingArrowEndpoints(\n          selectedElement,\n          isBindingEnabled,\n          draggingPoints ?? [],\n          scene.getNonDeletedElementsMap(),\n          scene.getNonDeletedElements(),\n          zoom,\n        )\n      : // The arrow itself (the shaft) or the inner joins are dragged\n        getBindingStrategyForDraggingArrowOrJoints(\n          selectedElement,\n          scene.getNonDeletedElementsMap(),\n          scene.getNonDeletedElements(),\n          isBindingEnabled,\n          zoom,\n        );\n\n    bindOrUnbindLinearElement(selectedElement, start, end, scene);\n  });\n};\n\nexport const getSuggestedBindingsForArrows = (\n  selectedElements: NonDeleted<ExcalidrawElement>[],\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom: AppState[\"zoom\"],\n): SuggestedBinding[] => {\n  // HOT PATH: Bail out if selected elements list is too large\n  if (selectedElements.length > 50) {\n    return [];\n  }\n\n  return (\n    selectedElements\n      .filter(isLinearElement)\n      .flatMap((element) =>\n        getOriginalBindingsIfStillCloseToArrowEnds(element, elementsMap, zoom),\n      )\n      .filter(\n        (element): element is NonDeleted<ExcalidrawBindableElement> =>\n          element !== null,\n      )\n      // Filter out bind candidates which are in the\n      // same selection / group with the arrow\n      //\n      // TODO: Is it worth turning the list into a set to avoid dupes?\n      .filter(\n        (element) =>\n          selectedElements.filter((selected) => selected.id === element?.id)\n            .length === 0,\n      )\n  );\n};\n\nexport const maybeSuggestBindingsForLinearElementAtCoords = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  /** scene coords */\n  pointerCoords: {\n    x: number;\n    y: number;\n  }[],\n  scene: Scene,\n  zoom: AppState[\"zoom\"],\n  // During line creation the start binding hasn't been written yet\n  // into `linearElement`\n  oppositeBindingBoundElement?: ExcalidrawBindableElement | null,\n): ExcalidrawBindableElement[] =>\n  Array.from(\n    pointerCoords.reduce(\n      (acc: Set<NonDeleted<ExcalidrawBindableElement>>, coords) => {\n        const hoveredBindableElement = getHoveredElementForBinding(\n          coords,\n          scene.getNonDeletedElements(),\n          scene.getNonDeletedElementsMap(),\n          zoom,\n          isElbowArrow(linearElement),\n          isElbowArrow(linearElement),\n        );\n\n        if (\n          hoveredBindableElement != null &&\n          !isLinearElementSimpleAndAlreadyBound(\n            linearElement,\n            oppositeBindingBoundElement?.id,\n            hoveredBindableElement,\n          )\n        ) {\n          acc.add(hoveredBindableElement);\n        }\n\n        return acc;\n      },\n      new Set() as Set<NonDeleted<ExcalidrawBindableElement>>,\n    ),\n  );\n\nexport const maybeBindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  appState: AppState,\n  pointerCoords: { x: number; y: number },\n  scene: Scene,\n): void => {\n  const elements = scene.getNonDeletedElements();\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  if (appState.startBoundElement != null) {\n    bindLinearElement(\n      linearElement,\n      appState.startBoundElement,\n      \"start\",\n      scene,\n    );\n  }\n\n  const hoveredElement = getHoveredElementForBinding(\n    pointerCoords,\n    elements,\n    elementsMap,\n    appState.zoom,\n    isElbowArrow(linearElement),\n    isElbowArrow(linearElement),\n  );\n\n  if (hoveredElement !== null) {\n    if (\n      !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n        linearElement,\n        hoveredElement,\n        \"end\",\n      )\n    ) {\n      bindLinearElement(linearElement, hoveredElement, \"end\", scene);\n    }\n  }\n};\n\nconst normalizePointBinding = (\n  binding: { focus: number; gap: number },\n  hoveredElement: ExcalidrawBindableElement,\n) => ({\n  ...binding,\n  gap: Math.min(\n    binding.gap,\n    maxBindingGap(hoveredElement, hoveredElement.width, hoveredElement.height),\n  ),\n});\n\nexport const bindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  scene: Scene,\n): void => {\n  if (!isArrowElement(linearElement)) {\n    return;\n  }\n\n  let binding: PointBinding | FixedPointBinding = {\n    elementId: hoveredElement.id,\n    ...normalizePointBinding(\n      calculateFocusAndGap(\n        linearElement,\n        hoveredElement,\n        startOrEnd,\n        scene.getNonDeletedElementsMap(),\n      ),\n      hoveredElement,\n    ),\n  };\n\n  if (isElbowArrow(linearElement)) {\n    binding = {\n      ...binding,\n      ...calculateFixedPointForElbowArrowBinding(\n        linearElement,\n        hoveredElement,\n        startOrEnd,\n        scene.getNonDeletedElementsMap(),\n      ),\n    };\n  }\n\n  scene.mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding,\n  });\n\n  const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);\n  if (!boundElementsMap.has(linearElement.id)) {\n    scene.mutateElement(hoveredElement, {\n      boundElements: (hoveredElement.boundElements || []).concat({\n        id: linearElement.id,\n        type: \"arrow\",\n      }),\n    });\n  }\n};\n\n// Don't bind both ends of a simple segment\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): boolean => {\n  const otherBinding =\n    linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(\n    linearElement,\n    otherBinding?.elementId,\n    bindableElement,\n  );\n};\n\nexport const isLinearElementSimpleAndAlreadyBound = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  alreadyBoundToId: ExcalidrawBindableElement[\"id\"] | undefined,\n  bindableElement: ExcalidrawBindableElement,\n): boolean => {\n  return (\n    alreadyBoundToId === bindableElement.id &&\n    isLinearElementSimple(linearElement)\n  );\n};\n\nconst isLinearElementSimple = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n): boolean => linearElement.points.length < 3 && !isElbowArrow(linearElement);\n\nconst unbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  scene: Scene,\n): ExcalidrawBindableElement[\"id\"] | null => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n  if (binding == null) {\n    return null;\n  }\n  scene.mutateElement(linearElement, { [field]: null });\n  return binding.elementId;\n};\n\nexport const getHoveredElementForBinding = (\n  pointerCoords: {\n    x: number;\n    y: number;\n  },\n  elements: readonly NonDeletedExcalidrawElement[],\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom?: AppState[\"zoom\"],\n  fullShape?: boolean,\n  considerAllElements?: boolean,\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  if (considerAllElements) {\n    let cullRest = false;\n    const candidateElements = getAllElementsAtPositionForBinding(\n      elements,\n      (element) =>\n        isBindableElement(element, false) &&\n        bindingBorderTest(\n          element,\n          pointerCoords,\n          elementsMap,\n          zoom,\n          (fullShape ||\n            !isBindingFallthroughEnabled(\n              element as ExcalidrawBindableElement,\n            )) &&\n            // disable fullshape snapping for frame elements so we\n            // can bind to frame children\n            !isFrameLikeElement(element),\n        ),\n    ).filter((element) => {\n      if (cullRest) {\n        return false;\n      }\n\n      if (!isBindingFallthroughEnabled(element as ExcalidrawBindableElement)) {\n        cullRest = true;\n      }\n\n      return true;\n    }) as NonDeleted<ExcalidrawBindableElement>[] | null;\n\n    // Return early if there are no candidates or just one candidate\n    if (!candidateElements || candidateElements.length === 0) {\n      return null;\n    }\n\n    if (candidateElements.length === 1) {\n      return candidateElements[0] as NonDeleted<ExcalidrawBindableElement>;\n    }\n\n    // Prefer the shape with the border being tested (if any)\n    const borderTestElements = candidateElements.filter((element) =>\n      bindingBorderTest(element, pointerCoords, elementsMap, zoom, false),\n    );\n    if (borderTestElements.length === 1) {\n      return borderTestElements[0];\n    }\n\n    // Prefer smaller shapes\n    return candidateElements\n      .sort(\n        (a, b) => b.width ** 2 + b.height ** 2 - (a.width ** 2 + a.height ** 2),\n      )\n      .pop() as NonDeleted<ExcalidrawBindableElement>;\n  }\n\n  const hoveredElement = getElementAtPositionForBinding(\n    elements,\n    (element) =>\n      isBindableElement(element, false) &&\n      bindingBorderTest(\n        element,\n        pointerCoords,\n        elementsMap,\n        zoom,\n        // disable fullshape snapping for frame elements so we\n        // can bind to frame children\n        (fullShape || !isBindingFallthroughEnabled(element)) &&\n          !isFrameLikeElement(element),\n      ),\n  );\n\n  return hoveredElement as NonDeleted<ExcalidrawBindableElement> | null;\n};\n\nconst getElementAtPositionForBinding = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n    if (isAtPositionFn(element)) {\n      hitElement = element;\n      break;\n    }\n  }\n\n  return hitElement;\n};\n\nconst getAllElementsAtPositionForBinding = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  const elementsAtPosition: NonDeletedExcalidrawElement[] = [];\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n\n    if (isAtPositionFn(element)) {\n      elementsAtPosition.push(element);\n    }\n  }\n\n  return elementsAtPosition;\n};\n\nconst calculateFocusAndGap = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: NonDeletedSceneElementsMap,\n): { focus: number; gap: number } => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    edgePointIndex,\n    elementsMap,\n  );\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n    elementsMap,\n  );\n\n  return {\n    focus: determineFocusDistance(\n      hoveredElement,\n      elementsMap,\n      adjacentPoint,\n      edgePoint,\n    ),\n    gap: Math.max(1, distanceToElement(hoveredElement, elementsMap, edgePoint)),\n  };\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\nexport const updateBoundElements = (\n  changedElement: NonDeletedExcalidrawElement,\n  scene: Scene,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n    changedElements?: Map<string, ExcalidrawElement>;\n  },\n) => {\n  if (!isBindableElement(changedElement)) {\n    return;\n  }\n\n  const { newSize, simultaneouslyUpdated } = options ?? {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n    simultaneouslyUpdated,\n  );\n\n  let elementsMap: ElementsMap = scene.getNonDeletedElementsMap();\n  if (options?.changedElements) {\n    elementsMap = new Map(elementsMap) as typeof elementsMap;\n    options.changedElements.forEach((element) => {\n      elementsMap.set(element.id, element);\n    });\n  }\n\n  boundElementsVisitor(elementsMap, changedElement, (element) => {\n    if (!isLinearElement(element) || element.isDeleted) {\n      return;\n    }\n\n    // In case the boundElements are stale\n    if (!doesNeedUpdate(element, changedElement)) {\n      return;\n    }\n\n    // Check for intersections before updating bound elements incase connected elements overlap\n    const startBindingElement = element.startBinding\n      ? elementsMap.get(element.startBinding.elementId)\n      : null;\n    const endBindingElement = element.endBinding\n      ? elementsMap.get(element.endBinding.elementId)\n      : null;\n\n    let startBounds: Bounds | null = null;\n    let endBounds: Bounds | null = null;\n    if (startBindingElement && endBindingElement) {\n      startBounds = getElementBounds(startBindingElement, elementsMap);\n      endBounds = getElementBounds(endBindingElement, elementsMap);\n    }\n\n    const bindings = {\n      startBinding: maybeCalculateNewGapWhenScaling(\n        changedElement,\n        element.startBinding,\n        newSize,\n      ),\n      endBinding: maybeCalculateNewGapWhenScaling(\n        changedElement,\n        element.endBinding,\n        newSize,\n      ),\n    };\n\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(element.id)) {\n      scene.mutateElement(element, bindings);\n      return;\n    }\n\n    const updates = bindableElementsVisitor(\n      elementsMap,\n      element,\n      (bindableElement, bindingProp) => {\n        if (\n          bindableElement &&\n          isBindableElement(bindableElement) &&\n          (bindingProp === \"startBinding\" || bindingProp === \"endBinding\") &&\n          (changedElement.id === element[bindingProp]?.elementId ||\n            (changedElement.id ===\n              element[\n                bindingProp === \"startBinding\" ? \"endBinding\" : \"startBinding\"\n              ]?.elementId &&\n              !doBoundsIntersect(startBounds, endBounds)))\n        ) {\n          const point = updateBoundPoint(\n            element,\n            bindingProp,\n            bindings[bindingProp],\n            bindableElement,\n            elementsMap,\n          );\n\n          if (point) {\n            return [\n              bindingProp === \"startBinding\" ? 0 : element.points.length - 1,\n              { point },\n            ] as MapEntry<PointsPositionUpdates>;\n          }\n        }\n\n        return null;\n      },\n    ).filter(\n      (update): update is MapEntry<PointsPositionUpdates> => update !== null,\n    );\n\n    LinearElementEditor.movePoints(element, scene, new Map(updates), {\n      ...(changedElement.id === element.startBinding?.elementId\n        ? { startBinding: bindings.startBinding }\n        : {}),\n      ...(changedElement.id === element.endBinding?.elementId\n        ? { endBinding: bindings.endBinding }\n        : {}),\n    });\n\n    const boundText = getBoundTextElement(element, elementsMap);\n    if (boundText && !boundText.isDeleted) {\n      handleBindTextResize(element, scene, false);\n    }\n  });\n};\n\nexport const updateBindings = (\n  latestElement: ExcalidrawElement,\n  scene: Scene,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n    zoom?: AppState[\"zoom\"];\n  },\n) => {\n  if (isLinearElement(latestElement)) {\n    bindOrUnbindLinearElements([latestElement], true, [], scene, options?.zoom);\n  } else {\n    updateBoundElements(latestElement, scene, {\n      ...options,\n      changedElements: new Map([[latestElement.id, latestElement]]),\n    });\n  }\n};\n\nconst doesNeedUpdate = (\n  boundElement: NonDeleted<ExcalidrawLinearElement>,\n  changedElement: ExcalidrawBindableElement,\n) => {\n  return (\n    boundElement.startBinding?.elementId === changedElement.id ||\n    boundElement.endBinding?.elementId === changedElement.id\n  );\n};\n\nconst getSimultaneouslyUpdatedElementIds = (\n  simultaneouslyUpdated: readonly ExcalidrawElement[] | undefined,\n): Set<ExcalidrawElement[\"id\"]> => {\n  return new Set((simultaneouslyUpdated || []).map((element) => element.id));\n};\n\nexport const getHeadingForElbowArrowSnap = (\n  p: Readonly<GlobalPoint>,\n  otherPoint: Readonly<GlobalPoint>,\n  bindableElement: ExcalidrawBindableElement | undefined | null,\n  aabb: Bounds | undefined | null,\n  origPoint: GlobalPoint,\n  elementsMap: ElementsMap,\n  zoom?: AppState[\"zoom\"],\n): Heading => {\n  const otherPointHeading = vectorToHeading(vectorFromPoint(otherPoint, p));\n\n  if (!bindableElement || !aabb) {\n    return otherPointHeading;\n  }\n\n  const distance = getDistanceForBinding(\n    origPoint,\n    bindableElement,\n    elementsMap,\n    zoom,\n  );\n\n  if (!distance) {\n    return vectorToHeading(\n      vectorFromPoint(p, elementCenterPoint(bindableElement, elementsMap)),\n    );\n  }\n\n  return headingForPointFromElement(bindableElement, aabb, p);\n};\n\nconst getDistanceForBinding = (\n  point: Readonly<GlobalPoint>,\n  bindableElement: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  zoom?: AppState[\"zoom\"],\n) => {\n  const distance = distanceToElement(bindableElement, elementsMap, point);\n  const bindDistance = maxBindingGap(\n    bindableElement,\n    bindableElement.width,\n    bindableElement.height,\n    zoom,\n  );\n\n  return distance > bindDistance ? null : distance;\n};\n\nexport const bindPointToSnapToElementOutline = (\n  arrow: ExcalidrawElbowArrowElement,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: ElementsMap,\n): GlobalPoint => {\n  if (isDevEnv() || isTestEnv()) {\n    invariant(arrow.points.length > 1, \"Arrow should have at least 2 points\");\n  }\n\n  const aabb = aabbForElement(bindableElement, elementsMap);\n  const localP =\n    arrow.points[startOrEnd === \"start\" ? 0 : arrow.points.length - 1];\n  const globalP = pointFrom<GlobalPoint>(\n    arrow.x + localP[0],\n    arrow.y + localP[1],\n  );\n  const edgePoint = isRectanguloidElement(bindableElement)\n    ? avoidRectangularCorner(bindableElement, elementsMap, globalP)\n    : globalP;\n  const elbowed = isElbowArrow(arrow);\n  const center = getCenterForBounds(aabb);\n  const adjacentPointIdx = startOrEnd === \"start\" ? 1 : arrow.points.length - 2;\n  const adjacentPoint = pointRotateRads(\n    pointFrom<GlobalPoint>(\n      arrow.x + arrow.points[adjacentPointIdx][0],\n      arrow.y + arrow.points[adjacentPointIdx][1],\n    ),\n    center,\n    arrow.angle ?? 0,\n  );\n\n  let intersection: GlobalPoint | null = null;\n  if (elbowed) {\n    const isHorizontal = headingIsHorizontal(\n      headingForPointFromElement(bindableElement, aabb, globalP),\n    );\n    const snapPoint = snapToMid(bindableElement, elementsMap, edgePoint);\n    const otherPoint = pointFrom<GlobalPoint>(\n      isHorizontal ? center[0] : snapPoint[0],\n      !isHorizontal ? center[1] : snapPoint[1],\n    );\n    const intersector = lineSegment(\n      otherPoint,\n      pointFromVector(\n        vectorScale(\n          vectorNormalize(vectorFromPoint(snapPoint, otherPoint)),\n          Math.max(bindableElement.width, bindableElement.height) * 2,\n        ),\n        otherPoint,\n      ),\n    );\n    intersection = intersectElementWithLineSegment(\n      bindableElement,\n      elementsMap,\n      intersector,\n      FIXED_BINDING_DISTANCE,\n    ).sort(pointDistanceSq)[0];\n  } else {\n    intersection = intersectElementWithLineSegment(\n      bindableElement,\n      elementsMap,\n      lineSegment(\n        adjacentPoint,\n        pointFromVector(\n          vectorScale(\n            vectorNormalize(vectorFromPoint(edgePoint, adjacentPoint)),\n            pointDistance(edgePoint, adjacentPoint) +\n              Math.max(bindableElement.width, bindableElement.height) * 2,\n          ),\n          adjacentPoint,\n        ),\n      ),\n      FIXED_BINDING_DISTANCE,\n    ).sort(\n      (g, h) =>\n        pointDistanceSq(g, adjacentPoint) - pointDistanceSq(h, adjacentPoint),\n    )[0];\n  }\n\n  if (\n    !intersection ||\n    // Too close to determine vector from intersection to edgePoint\n    pointDistanceSq(edgePoint, intersection) < PRECISION\n  ) {\n    return edgePoint;\n  }\n\n  return elbowed ? intersection : edgePoint;\n};\n\nexport const avoidRectangularCorner = (\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): GlobalPoint => {\n  const center = elementCenterPoint(element, elementsMap);\n  const nonRotatedPoint = pointRotateRads(p, center, -element.angle as Radians);\n\n  if (nonRotatedPoint[0] < element.x && nonRotatedPoint[1] < element.y) {\n    // Top left\n    if (nonRotatedPoint[1] - element.y > -FIXED_BINDING_DISTANCE) {\n      return pointRotateRads<GlobalPoint>(\n        pointFrom(element.x - FIXED_BINDING_DISTANCE, element.y),\n        center,\n        element.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(element.x, element.y - FIXED_BINDING_DISTANCE),\n      center,\n      element.angle,\n    );\n  } else if (\n    nonRotatedPoint[0] < element.x &&\n    nonRotatedPoint[1] > element.y + element.height\n  ) {\n    // Bottom left\n    if (nonRotatedPoint[0] - element.x > -FIXED_BINDING_DISTANCE) {\n      return pointRotateRads(\n        pointFrom(\n          element.x,\n          element.y + element.height + FIXED_BINDING_DISTANCE,\n        ),\n        center,\n        element.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(element.x - FIXED_BINDING_DISTANCE, element.y + element.height),\n      center,\n      element.angle,\n    );\n  } else if (\n    nonRotatedPoint[0] > element.x + element.width &&\n    nonRotatedPoint[1] > element.y + element.height\n  ) {\n    // Bottom right\n    if (\n      nonRotatedPoint[0] - element.x <\n      element.width + FIXED_BINDING_DISTANCE\n    ) {\n      return pointRotateRads(\n        pointFrom(\n          element.x + element.width,\n          element.y + element.height + FIXED_BINDING_DISTANCE,\n        ),\n        center,\n        element.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(\n        element.x + element.width + FIXED_BINDING_DISTANCE,\n        element.y + element.height,\n      ),\n      center,\n      element.angle,\n    );\n  } else if (\n    nonRotatedPoint[0] > element.x + element.width &&\n    nonRotatedPoint[1] < element.y\n  ) {\n    // Top right\n    if (\n      nonRotatedPoint[0] - element.x <\n      element.width + FIXED_BINDING_DISTANCE\n    ) {\n      return pointRotateRads(\n        pointFrom(\n          element.x + element.width,\n          element.y - FIXED_BINDING_DISTANCE,\n        ),\n        center,\n        element.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(element.x + element.width + FIXED_BINDING_DISTANCE, element.y),\n      center,\n      element.angle,\n    );\n  }\n\n  return p;\n};\n\nexport const snapToMid = (\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n  tolerance: number = 0.05,\n): GlobalPoint => {\n  const { x, y, width, height, angle } = element;\n  const center = elementCenterPoint(element, elementsMap, -0.1, -0.1);\n  const nonRotated = pointRotateRads(p, center, -angle as Radians);\n\n  // snap-to-center point is adaptive to element size, but we don't want to go\n  // above and below certain px distance\n  const verticalThreshold = clamp(tolerance * height, 5, 80);\n  const horizontalThreshold = clamp(tolerance * width, 5, 80);\n\n  if (\n    nonRotated[0] <= x + width / 2 &&\n    nonRotated[1] > center[1] - verticalThreshold &&\n    nonRotated[1] < center[1] + verticalThreshold\n  ) {\n    // LEFT\n    return pointRotateRads<GlobalPoint>(\n      pointFrom(x - FIXED_BINDING_DISTANCE, center[1]),\n      center,\n      angle,\n    );\n  } else if (\n    nonRotated[1] <= y + height / 2 &&\n    nonRotated[0] > center[0] - horizontalThreshold &&\n    nonRotated[0] < center[0] + horizontalThreshold\n  ) {\n    // TOP\n    return pointRotateRads(\n      pointFrom(center[0], y - FIXED_BINDING_DISTANCE),\n      center,\n      angle,\n    );\n  } else if (\n    nonRotated[0] >= x + width / 2 &&\n    nonRotated[1] > center[1] - verticalThreshold &&\n    nonRotated[1] < center[1] + verticalThreshold\n  ) {\n    // RIGHT\n    return pointRotateRads(\n      pointFrom(x + width + FIXED_BINDING_DISTANCE, center[1]),\n      center,\n      angle,\n    );\n  } else if (\n    nonRotated[1] >= y + height / 2 &&\n    nonRotated[0] > center[0] - horizontalThreshold &&\n    nonRotated[0] < center[0] + horizontalThreshold\n  ) {\n    // DOWN\n    return pointRotateRads(\n      pointFrom(center[0], y + height + FIXED_BINDING_DISTANCE),\n      center,\n      angle,\n    );\n  } else if (element.type === \"diamond\") {\n    const distance = FIXED_BINDING_DISTANCE;\n    const topLeft = pointFrom<GlobalPoint>(\n      x + width / 4 - distance,\n      y + height / 4 - distance,\n    );\n    const topRight = pointFrom<GlobalPoint>(\n      x + (3 * width) / 4 + distance,\n      y + height / 4 - distance,\n    );\n    const bottomLeft = pointFrom<GlobalPoint>(\n      x + width / 4 - distance,\n      y + (3 * height) / 4 + distance,\n    );\n    const bottomRight = pointFrom<GlobalPoint>(\n      x + (3 * width) / 4 + distance,\n      y + (3 * height) / 4 + distance,\n    );\n\n    if (\n      pointDistance(topLeft, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(topLeft, center, angle);\n    }\n    if (\n      pointDistance(topRight, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(topRight, center, angle);\n    }\n    if (\n      pointDistance(bottomLeft, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(bottomLeft, center, angle);\n    }\n    if (\n      pointDistance(bottomRight, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(bottomRight, center, angle);\n    }\n  }\n\n  return p;\n};\n\nconst updateBoundPoint = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"startBinding\" | \"endBinding\",\n  binding: PointBinding | null | undefined,\n  bindableElement: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n): LocalPoint | null => {\n  if (\n    binding == null ||\n    // We only need to update the other end if this is a 2 point line element\n    (binding.elementId !== bindableElement.id &&\n      linearElement.points.length > 2)\n  ) {\n    return null;\n  }\n\n  const direction = startOrEnd === \"startBinding\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n\n  if (isElbowArrow(linearElement) && isFixedPointBinding(binding)) {\n    const fixedPoint =\n      normalizeFixedPoint(binding.fixedPoint) ??\n      calculateFixedPointForElbowArrowBinding(\n        linearElement,\n        bindableElement,\n        startOrEnd === \"startBinding\" ? \"start\" : \"end\",\n        elementsMap,\n      ).fixedPoint;\n    const globalMidPoint = elementCenterPoint(bindableElement, elementsMap);\n    const global = pointFrom<GlobalPoint>(\n      bindableElement.x + fixedPoint[0] * bindableElement.width,\n      bindableElement.y + fixedPoint[1] * bindableElement.height,\n    );\n    const rotatedGlobal = pointRotateRads(\n      global,\n      globalMidPoint,\n      bindableElement.angle,\n    );\n\n    return LinearElementEditor.pointFromAbsoluteCoords(\n      linearElement,\n      rotatedGlobal,\n      elementsMap,\n    );\n  }\n\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n    elementsMap,\n  );\n  const focusPointAbsolute = determineFocusPoint(\n    bindableElement,\n    elementsMap,\n    binding.focus,\n    adjacentPoint,\n  );\n\n  let newEdgePoint: GlobalPoint;\n\n  // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const edgePointAbsolute =\n      LinearElementEditor.getPointAtIndexGlobalCoordinates(\n        linearElement,\n        edgePointIndex,\n        elementsMap,\n      );\n\n    const center = elementCenterPoint(bindableElement, elementsMap);\n    const interceptorLength =\n      pointDistance(adjacentPoint, edgePointAbsolute) +\n      pointDistance(adjacentPoint, center) +\n      Math.max(bindableElement.width, bindableElement.height) * 2;\n    const intersections = [\n      ...intersectElementWithLineSegment(\n        bindableElement,\n        elementsMap,\n        lineSegment<GlobalPoint>(\n          adjacentPoint,\n          pointFromVector(\n            vectorScale(\n              vectorNormalize(\n                vectorFromPoint(focusPointAbsolute, adjacentPoint),\n              ),\n              interceptorLength,\n            ),\n            adjacentPoint,\n          ),\n        ),\n        binding.gap,\n      ).sort(\n        (g, h) =>\n          pointDistanceSq(g, adjacentPoint) - pointDistanceSq(h, adjacentPoint),\n      ),\n      // Fallback when arrow doesn't point to the shape\n      pointFromVector(\n        vectorScale(\n          vectorNormalize(vectorFromPoint(focusPointAbsolute, adjacentPoint)),\n          pointDistance(adjacentPoint, edgePointAbsolute),\n        ),\n        adjacentPoint,\n      ),\n    ];\n\n    if (intersections.length > 1) {\n      // The adjacent point is outside the shape (+ gap)\n      newEdgePoint = intersections[0];\n    } else if (intersections.length === 1) {\n      // The adjacent point is inside the shape (+ gap)\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Shouldn't happend, but just in case\n      newEdgePoint = edgePointAbsolute;\n    }\n  }\n\n  return LinearElementEditor.pointFromAbsoluteCoords(\n    linearElement,\n    newEdgePoint,\n    elementsMap,\n  );\n};\n\nexport const calculateFixedPointForElbowArrowBinding = (\n  linearElement: NonDeleted<ExcalidrawElbowArrowElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: ElementsMap,\n): { fixedPoint: FixedPoint } => {\n  const bounds = [\n    hoveredElement.x,\n    hoveredElement.y,\n    hoveredElement.x + hoveredElement.width,\n    hoveredElement.y + hoveredElement.height,\n  ] as Bounds;\n  const snappedPoint = bindPointToSnapToElementOutline(\n    linearElement,\n    hoveredElement,\n    startOrEnd,\n    elementsMap,\n  );\n  const globalMidPoint = pointFrom(\n    bounds[0] + (bounds[2] - bounds[0]) / 2,\n    bounds[1] + (bounds[3] - bounds[1]) / 2,\n  );\n  const nonRotatedSnappedGlobalPoint = pointRotateRads(\n    snappedPoint,\n    globalMidPoint,\n    -hoveredElement.angle as Radians,\n  );\n\n  return {\n    fixedPoint: normalizeFixedPoint([\n      (nonRotatedSnappedGlobalPoint[0] - hoveredElement.x) /\n        hoveredElement.width,\n      (nonRotatedSnappedGlobalPoint[1] - hoveredElement.y) /\n        hoveredElement.height,\n    ]),\n  };\n};\n\nconst maybeCalculateNewGapWhenScaling = (\n  changedElement: ExcalidrawBindableElement,\n  currentBinding: PointBinding | null | undefined,\n  newSize: { width: number; height: number } | undefined,\n): PointBinding | null | undefined => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n  const { width: newWidth, height: newHeight } = newSize;\n  const { width, height } = changedElement;\n  const newGap = Math.max(\n    1,\n    Math.min(\n      maxBindingGap(changedElement, newWidth, newHeight),\n      currentBinding.gap *\n        (newWidth < newHeight ? newWidth / width : newHeight / height),\n    ),\n  );\n\n  return { ...currentBinding, gap: newGap };\n};\n\nconst getEligibleElementForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly NonDeletedExcalidrawElement[],\n  zoom?: AppState[\"zoom\"],\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  return getHoveredElementForBinding(\n    getLinearElementEdgeCoors(linearElement, startOrEnd, elementsMap),\n    elements,\n    elementsMap,\n    zoom,\n    isElbowArrow(linearElement),\n    isElbowArrow(linearElement),\n  );\n};\n\nconst getLinearElementEdgeCoors = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: NonDeletedSceneElementsMap,\n): { x: number; y: number } => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(\n    LinearElementEditor.getPointAtIndexGlobalCoordinates(\n      linearElement,\n      index,\n      elementsMap,\n    ),\n  );\n};\n\nexport const fixDuplicatedBindingsAfterDuplication = (\n  duplicatedElements: ExcalidrawElement[],\n  origIdToDuplicateId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n  duplicateElementsMap: NonDeletedSceneElementsMap,\n) => {\n  for (const duplicateElement of duplicatedElements) {\n    if (\"boundElements\" in duplicateElement && duplicateElement.boundElements) {\n      Object.assign(duplicateElement, {\n        boundElements: duplicateElement.boundElements.reduce(\n          (\n            acc: Mutable<NonNullable<ExcalidrawElement[\"boundElements\"]>>,\n            binding,\n          ) => {\n            const newBindingId = origIdToDuplicateId.get(binding.id);\n            if (newBindingId) {\n              acc.push({ ...binding, id: newBindingId });\n            }\n            return acc;\n          },\n          [],\n        ),\n      });\n    }\n\n    if (\"containerId\" in duplicateElement && duplicateElement.containerId) {\n      Object.assign(duplicateElement, {\n        containerId:\n          origIdToDuplicateId.get(duplicateElement.containerId) ?? null,\n      });\n    }\n\n    if (\"endBinding\" in duplicateElement && duplicateElement.endBinding) {\n      const newEndBindingId = origIdToDuplicateId.get(\n        duplicateElement.endBinding.elementId,\n      );\n      Object.assign(duplicateElement, {\n        endBinding: newEndBindingId\n          ? {\n              ...duplicateElement.endBinding,\n              elementId: newEndBindingId,\n            }\n          : null,\n      });\n    }\n    if (\"startBinding\" in duplicateElement && duplicateElement.startBinding) {\n      const newEndBindingId = origIdToDuplicateId.get(\n        duplicateElement.startBinding.elementId,\n      );\n      Object.assign(duplicateElement, {\n        startBinding: newEndBindingId\n          ? {\n              ...duplicateElement.startBinding,\n              elementId: newEndBindingId,\n            }\n          : null,\n      });\n    }\n\n    if (isElbowArrow(duplicateElement)) {\n      Object.assign(\n        duplicateElement,\n        updateElbowArrowPoints(duplicateElement, duplicateElementsMap, {\n          points: [\n            duplicateElement.points[0],\n            duplicateElement.points[duplicateElement.points.length - 1],\n          ],\n        }),\n      );\n    }\n  }\n};\n\nexport const fixBindingsAfterDeletion = (\n  sceneElements: readonly ExcalidrawElement[],\n  deletedElements: readonly ExcalidrawElement[],\n): void => {\n  const elements = arrayToMap(sceneElements);\n\n  for (const element of deletedElements) {\n    BoundElement.unbindAffected(elements, element, (element, updates) =>\n      mutateElement(element, elements, updates),\n    );\n    BindableElement.unbindAffected(elements, element, (element, updates) =>\n      mutateElement(element, elements, updates),\n    );\n  }\n};\n\nconst newBoundElements = (\n  boundElements: ExcalidrawElement[\"boundElements\"],\n  idsToRemove: Set<ExcalidrawElement[\"id\"]>,\n  elementsToAdd: Array<ExcalidrawElement> = [],\n) => {\n  if (!boundElements) {\n    return null;\n  }\n\n  const nextBoundElements = boundElements.filter(\n    (boundElement) => !idsToRemove.has(boundElement.id),\n  );\n\n  nextBoundElements.push(\n    ...elementsToAdd.map(\n      (x) =>\n        ({ id: x.id, type: x.type } as\n          | ExcalidrawArrowElement\n          | ExcalidrawTextElement),\n    ),\n  );\n\n  return nextBoundElements;\n};\n\nexport const bindingBorderTest = (\n  element: NonDeleted<ExcalidrawBindableElement>,\n  { x, y }: { x: number; y: number },\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom?: AppState[\"zoom\"],\n  fullShape?: boolean,\n): boolean => {\n  const p = pointFrom<GlobalPoint>(x, y);\n  const threshold = maxBindingGap(element, element.width, element.height, zoom);\n  const shouldTestInside =\n    // disable fullshape snapping for frame elements so we\n    // can bind to frame children\n    (fullShape || !isBindingFallthroughEnabled(element)) &&\n    !isFrameLikeElement(element);\n\n  // PERF: Run a cheap test to see if the binding element\n  // is even close to the element\n  const bounds = [\n    x - threshold,\n    y - threshold,\n    x + threshold,\n    y + threshold,\n  ] as Bounds;\n  const elementBounds = getElementBounds(element, elementsMap);\n  if (!doBoundsIntersect(bounds, elementBounds)) {\n    return false;\n  }\n\n  // Do the intersection test against the element since it's close enough\n  const intersections = intersectElementWithLineSegment(\n    element,\n    elementsMap,\n    lineSegment(elementCenterPoint(element, elementsMap), p),\n  );\n  const distance = distanceToElement(element, elementsMap, p);\n\n  return shouldTestInside\n    ? intersections.length === 0 || distance <= threshold\n    : intersections.length > 0 && distance <= threshold;\n};\n\nexport const maxBindingGap = (\n  element: ExcalidrawElement,\n  elementWidth: number,\n  elementHeight: number,\n  zoom?: AppState[\"zoom\"],\n): number => {\n  const zoomValue = zoom?.value && zoom.value < 1 ? zoom.value : 1;\n\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n\n  return Math.max(\n    16,\n    // bigger bindable boundary for bigger elements\n    Math.min(0.25 * smallerDimension, 32),\n    // keep in sync with the zoomed highlight\n    BINDING_HIGHLIGHT_THICKNESS / zoomValue + FIXED_BINDING_DISTANCE,\n  );\n};\n\n// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nconst determineFocusDistance = (\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  // Point on the line, in absolute coordinates\n  a: GlobalPoint,\n  // Another point on the line, in absolute coordinates (closer to element)\n  b: GlobalPoint,\n): number => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  if (pointsEqual(a, b)) {\n    return 0;\n  }\n\n  const rotatedA = pointRotateRads(a, center, -element.angle as Radians);\n  const rotatedB = pointRotateRads(b, center, -element.angle as Radians);\n  const sign =\n    Math.sign(\n      vectorCross(\n        vectorFromPoint(rotatedB, a),\n        vectorFromPoint(rotatedB, center),\n      ),\n    ) * -1;\n  const rotatedInterceptor = lineSegment(\n    rotatedB,\n    pointFromVector(\n      vectorScale(\n        vectorNormalize(vectorFromPoint(rotatedB, rotatedA)),\n        Math.max(element.width * 2, element.height * 2),\n      ),\n      rotatedB,\n    ),\n  );\n  const axes =\n    element.type === \"diamond\"\n      ? [\n          lineSegment(\n            pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n            pointFrom<GlobalPoint>(\n              element.x + element.width / 2,\n              element.y + element.height,\n            ),\n          ),\n          lineSegment(\n            pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n            pointFrom<GlobalPoint>(\n              element.x + element.width,\n              element.y + element.height / 2,\n            ),\n          ),\n        ]\n      : [\n          lineSegment(\n            pointFrom<GlobalPoint>(element.x, element.y),\n            pointFrom<GlobalPoint>(\n              element.x + element.width,\n              element.y + element.height,\n            ),\n          ),\n          lineSegment(\n            pointFrom<GlobalPoint>(element.x + element.width, element.y),\n            pointFrom<GlobalPoint>(element.x, element.y + element.height),\n          ),\n        ];\n  const interceptees =\n    element.type === \"diamond\"\n      ? [\n          lineSegment(\n            pointFrom<GlobalPoint>(\n              element.x + element.width / 2,\n              element.y - element.height,\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + element.width / 2,\n              element.y + element.height * 2,\n            ),\n          ),\n          lineSegment(\n            pointFrom<GlobalPoint>(\n              element.x - element.width,\n              element.y + element.height / 2,\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + element.width * 2,\n              element.y + element.height / 2,\n            ),\n          ),\n        ]\n      : [\n          lineSegment(\n            pointFrom<GlobalPoint>(\n              element.x - element.width,\n              element.y - element.height,\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + element.width * 2,\n              element.y + element.height * 2,\n            ),\n          ),\n          lineSegment(\n            pointFrom<GlobalPoint>(\n              element.x + element.width * 2,\n              element.y - element.height,\n            ),\n            pointFrom<GlobalPoint>(\n              element.x - element.width,\n              element.y + element.height * 2,\n            ),\n          ),\n        ];\n\n  const ordered = [\n    lineSegmentIntersectionPoints(rotatedInterceptor, interceptees[0]),\n    lineSegmentIntersectionPoints(rotatedInterceptor, interceptees[1]),\n  ]\n    .filter((p): p is GlobalPoint => p !== null)\n    .sort((g, h) => pointDistanceSq(g, b) - pointDistanceSq(h, b))\n    .map(\n      (p, idx): number =>\n        (sign * pointDistance(center, p)) /\n        (element.type === \"diamond\"\n          ? pointDistance(axes[idx][0], axes[idx][1]) / 2\n          : Math.sqrt(element.width ** 2 + element.height ** 2) / 2),\n    )\n    .sort((g, h) => Math.abs(g) - Math.abs(h));\n\n  const signedDistanceRatio = ordered[0] ?? 0;\n\n  return signedDistanceRatio;\n};\n\nconst determineFocusPoint = (\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  // The oriented, relative distance from the center of `element` of the\n  // returned focusPoint\n  focus: number,\n  adjacentPoint: GlobalPoint,\n): GlobalPoint => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  if (focus === 0) {\n    return center;\n  }\n\n  const candidates = (\n    element.type === \"diamond\"\n      ? [\n          pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n          pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n          pointFrom<GlobalPoint>(\n            element.x + element.width,\n            element.y + element.height / 2,\n          ),\n          pointFrom<GlobalPoint>(\n            element.x + element.width / 2,\n            element.y + element.height,\n          ),\n        ]\n      : [\n          pointFrom<GlobalPoint>(element.x, element.y),\n          pointFrom<GlobalPoint>(element.x + element.width, element.y),\n          pointFrom<GlobalPoint>(\n            element.x + element.width,\n            element.y + element.height,\n          ),\n          pointFrom<GlobalPoint>(element.x, element.y + element.height),\n        ]\n  )\n    .map((p) =>\n      pointFromVector(\n        vectorScale(vectorFromPoint(p, center), Math.abs(focus)),\n        center,\n      ),\n    )\n    .map((p) => pointRotateRads(p, center, element.angle as Radians));\n\n  const selected = [\n    vectorCross(\n      vectorFromPoint(adjacentPoint, candidates[0]),\n      vectorFromPoint(candidates[1], candidates[0]),\n    ) > 0 && // TOP\n      (focus > 0\n        ? vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[1]),\n            vectorFromPoint(candidates[2], candidates[1]),\n          ) < 0\n        : vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[3]),\n            vectorFromPoint(candidates[0], candidates[3]),\n          ) < 0),\n    vectorCross(\n      vectorFromPoint(adjacentPoint, candidates[1]),\n      vectorFromPoint(candidates[2], candidates[1]),\n    ) > 0 && // RIGHT\n      (focus > 0\n        ? vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[2]),\n            vectorFromPoint(candidates[3], candidates[2]),\n          ) < 0\n        : vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[0]),\n            vectorFromPoint(candidates[1], candidates[0]),\n          ) < 0),\n    vectorCross(\n      vectorFromPoint(adjacentPoint, candidates[2]),\n      vectorFromPoint(candidates[3], candidates[2]),\n    ) > 0 && // BOTTOM\n      (focus > 0\n        ? vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[3]),\n            vectorFromPoint(candidates[0], candidates[3]),\n          ) < 0\n        : vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[1]),\n            vectorFromPoint(candidates[2], candidates[1]),\n          ) < 0),\n    vectorCross(\n      vectorFromPoint(adjacentPoint, candidates[3]),\n      vectorFromPoint(candidates[0], candidates[3]),\n    ) > 0 && // LEFT\n      (focus > 0\n        ? vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[0]),\n            vectorFromPoint(candidates[1], candidates[0]),\n          ) < 0\n        : vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[2]),\n            vectorFromPoint(candidates[3], candidates[2]),\n          ) < 0),\n  ];\n\n  const focusPoint = selected[0]\n    ? focus > 0\n      ? candidates[1]\n      : candidates[0]\n    : selected[1]\n    ? focus > 0\n      ? candidates[2]\n      : candidates[1]\n    : selected[2]\n    ? focus > 0\n      ? candidates[3]\n      : candidates[2]\n    : focus > 0\n    ? candidates[0]\n    : candidates[3];\n\n  return focusPoint;\n};\n\nexport const bindingProperties: Set<BindableProp | BindingProp> = new Set([\n  \"boundElements\",\n  \"frameId\",\n  \"containerId\",\n  \"startBinding\",\n  \"endBinding\",\n]);\n\nexport type BindableProp = \"boundElements\";\n\nexport type BindingProp =\n  | \"frameId\"\n  | \"containerId\"\n  | \"startBinding\"\n  | \"endBinding\";\n\ntype BoundElementsVisitingFunc = (\n  boundElement: ExcalidrawElement | undefined,\n  bindingProp: BindableProp,\n  bindingId: string,\n) => void;\n\ntype BindableElementVisitingFunc<T> = (\n  bindableElement: ExcalidrawElement | undefined,\n  bindingProp: BindingProp,\n  bindingId: string,\n) => T;\n\n/**\n * Tries to visit each bound element (does not have to be found).\n */\nconst boundElementsVisitor = (\n  elements: ElementsMap,\n  element: ExcalidrawElement,\n  visit: BoundElementsVisitingFunc,\n) => {\n  if (isBindableElement(element)) {\n    // create new instance so that possible mutations won't play a role in visiting order\n    const boundElements = element.boundElements?.slice() ?? [];\n\n    // last added text should be the one we keep (~previous are duplicates)\n    boundElements.forEach(({ id }) => {\n      visit(elements.get(id), \"boundElements\", id);\n    });\n  }\n};\n\n/**\n * Tries to visit each bindable element (does not have to be found).\n */\nconst bindableElementsVisitor = <T>(\n  elements: ElementsMap,\n  element: ExcalidrawElement,\n  visit: BindableElementVisitingFunc<T>,\n): T[] => {\n  const result: T[] = [];\n\n  if (element.frameId) {\n    const id = element.frameId;\n    result.push(visit(elements.get(id), \"frameId\", id));\n  }\n\n  if (isBoundToContainer(element)) {\n    const id = element.containerId;\n    result.push(visit(elements.get(id), \"containerId\", id));\n  }\n\n  if (isArrowElement(element)) {\n    if (element.startBinding) {\n      const id = element.startBinding.elementId;\n      result.push(visit(elements.get(id), \"startBinding\", id));\n    }\n\n    if (element.endBinding) {\n      const id = element.endBinding.elementId;\n      result.push(visit(elements.get(id), \"endBinding\", id));\n    }\n  }\n\n  return result;\n};\n\n/**\n * Bound element containing bindings to `frameId`, `containerId`, `startBinding` or `endBinding`.\n */\nexport class BoundElement {\n  /**\n   * Unbind the affected non deleted bindable elements (removing element from `boundElements`).\n   * - iterates non deleted bindable elements (`containerId` | `startBinding.elementId` | `endBinding.elementId`) of the current element\n   * - prepares updates to unbind each bindable element's `boundElements` from the current element\n   */\n  public static unbindAffected(\n    elements: ElementsMap,\n    boundElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) {\n    if (!boundElement) {\n      return;\n    }\n\n    bindableElementsVisitor(elements, boundElement, (bindableElement) => {\n      // bindable element is deleted, this is fine\n      if (!bindableElement || bindableElement.isDeleted) {\n        return;\n      }\n\n      boundElementsVisitor(\n        elements,\n        bindableElement,\n        (_, __, boundElementId) => {\n          if (boundElementId === boundElement.id) {\n            updateElementWith(bindableElement, {\n              boundElements: newBoundElements(\n                bindableElement.boundElements,\n                new Set([boundElementId]),\n              ),\n            });\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Rebind the next affected non deleted bindable elements (adding element to `boundElements`).\n   * - iterates non deleted bindable elements (`containerId` | `startBinding.elementId` | `endBinding.elementId`) of the current element\n   * - prepares updates to rebind each bindable element's `boundElements` to the current element\n   *\n   * NOTE: rebind expects that affected elements were previously unbound with `BoundElement.unbindAffected`\n   */\n  public static rebindAffected = (\n    elements: ElementsMap,\n    boundElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) => {\n    // don't try to rebind element that is deleted\n    if (!boundElement || boundElement.isDeleted) {\n      return;\n    }\n\n    bindableElementsVisitor(\n      elements,\n      boundElement,\n      (bindableElement, bindingProp) => {\n        // unbind from bindable elements, as bindings from non deleted elements into deleted elements are incorrect\n        if (!bindableElement || bindableElement.isDeleted) {\n          updateElementWith(boundElement, { [bindingProp]: null });\n          return;\n        }\n\n        // frame bindings are unidirectional, there is nothing to rebind\n        if (bindingProp === \"frameId\") {\n          return;\n        }\n\n        if (\n          bindableElement.boundElements?.find((x) => x.id === boundElement.id)\n        ) {\n          return;\n        }\n\n        if (isArrowElement(boundElement)) {\n          // rebind if not found!\n          updateElementWith(bindableElement, {\n            boundElements: newBoundElements(\n              bindableElement.boundElements,\n              new Set(),\n              new Array(boundElement),\n            ),\n          });\n        }\n\n        if (isTextElement(boundElement)) {\n          if (!bindableElement.boundElements?.find((x) => x.type === \"text\")) {\n            // rebind only if there is no other text bound already\n            updateElementWith(bindableElement, {\n              boundElements: newBoundElements(\n                bindableElement.boundElements,\n                new Set(),\n                new Array(boundElement),\n              ),\n            });\n          } else {\n            // unbind otherwise\n            updateElementWith(boundElement, { [bindingProp]: null });\n          }\n        }\n      },\n    );\n  };\n}\n\n/**\n * Bindable element containing bindings to `boundElements`.\n */\nexport class BindableElement {\n  /**\n   * Unbind the affected non deleted bound elements (resetting `containerId`, `startBinding`, `endBinding` to `null`).\n   * - iterates through non deleted `boundElements` of the current element\n   * - prepares updates to unbind each bound element from the current element\n   */\n  public static unbindAffected(\n    elements: ElementsMap,\n    bindableElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) {\n    if (!bindableElement) {\n      return;\n    }\n\n    boundElementsVisitor(elements, bindableElement, (boundElement) => {\n      // bound element is deleted, this is fine\n      if (!boundElement || boundElement.isDeleted) {\n        return;\n      }\n\n      bindableElementsVisitor(\n        elements,\n        boundElement,\n        (_, bindingProp, bindableElementId) => {\n          // making sure there is an element to be unbound\n          if (bindableElementId === bindableElement.id) {\n            updateElementWith(boundElement, { [bindingProp]: null });\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Rebind the affected non deleted bound elements (for now setting only `containerId`, as we cannot rebind arrows atm).\n   * - iterates through non deleted `boundElements` of the current element\n   * - prepares updates to rebind each bound element to the current element or unbind it from `boundElements` in case of conflicts\n   *\n   * NOTE: rebind expects that affected elements were previously unbound with `BindaleElement.unbindAffected`\n   */\n  public static rebindAffected = (\n    elements: ElementsMap,\n    bindableElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) => {\n    // don't try to rebind element that is deleted (i.e. updated as deleted)\n    if (!bindableElement || bindableElement.isDeleted) {\n      return;\n    }\n\n    boundElementsVisitor(\n      elements,\n      bindableElement,\n      (boundElement, _, boundElementId) => {\n        // unbind from bindable elements, as bindings from non deleted elements into deleted elements are incorrect\n        if (!boundElement || boundElement.isDeleted) {\n          updateElementWith(bindableElement, {\n            boundElements: newBoundElements(\n              bindableElement.boundElements,\n              new Set([boundElementId]),\n            ),\n          });\n          return;\n        }\n\n        if (isTextElement(boundElement)) {\n          const boundElements = bindableElement.boundElements?.slice() ?? [];\n          // check if this is the last element in the array, if not, there is an previously bound text which should be unbound\n          if (\n            boundElements.reverse().find((x) => x.type === \"text\")?.id ===\n            boundElement.id\n          ) {\n            if (boundElement.containerId !== bindableElement.id) {\n              // rebind if not bound already!\n              updateElementWith(boundElement, {\n                containerId: bindableElement.id,\n              } as ElementUpdate<ExcalidrawTextElement>);\n            }\n          } else {\n            if (boundElement.containerId !== null) {\n              // unbind if not unbound already\n              updateElementWith(boundElement, {\n                containerId: null,\n              } as ElementUpdate<ExcalidrawTextElement>);\n            }\n\n            // unbind from boundElements as the element got bound to some other element in the meantime\n            updateElementWith(bindableElement, {\n              boundElements: newBoundElements(\n                bindableElement.boundElements,\n                new Set([boundElement.id]),\n              ),\n            });\n          }\n        }\n      },\n    );\n  };\n}\n\nexport const getGlobalFixedPointForBindableElement = (\n  fixedPointRatio: [number, number],\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n): GlobalPoint => {\n  const [fixedX, fixedY] = normalizeFixedPoint(fixedPointRatio);\n\n  return pointRotateRads(\n    pointFrom(\n      element.x + element.width * fixedX,\n      element.y + element.height * fixedY,\n    ),\n    elementCenterPoint(element, elementsMap),\n    element.angle,\n  );\n};\n\nexport const getGlobalFixedPoints = (\n  arrow: ExcalidrawElbowArrowElement,\n  elementsMap: ElementsMap,\n): [GlobalPoint, GlobalPoint] => {\n  const startElement =\n    arrow.startBinding &&\n    (elementsMap.get(arrow.startBinding.elementId) as\n      | ExcalidrawBindableElement\n      | undefined);\n  const endElement =\n    arrow.endBinding &&\n    (elementsMap.get(arrow.endBinding.elementId) as\n      | ExcalidrawBindableElement\n      | undefined);\n  const startPoint =\n    startElement && arrow.startBinding\n      ? getGlobalFixedPointForBindableElement(\n          arrow.startBinding.fixedPoint,\n          startElement as ExcalidrawBindableElement,\n          elementsMap,\n        )\n      : pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[0][0],\n          arrow.y + arrow.points[0][1],\n        );\n  const endPoint =\n    endElement && arrow.endBinding\n      ? getGlobalFixedPointForBindableElement(\n          arrow.endBinding.fixedPoint,\n          endElement as ExcalidrawBindableElement,\n          elementsMap,\n        )\n      : pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[arrow.points.length - 1][0],\n          arrow.y + arrow.points[arrow.points.length - 1][1],\n        );\n\n  return [startPoint, endPoint];\n};\n\nexport const getArrowLocalFixedPoints = (\n  arrow: ExcalidrawElbowArrowElement,\n  elementsMap: ElementsMap,\n) => {\n  const [startPoint, endPoint] = getGlobalFixedPoints(arrow, elementsMap);\n\n  return [\n    LinearElementEditor.pointFromAbsoluteCoords(arrow, startPoint, elementsMap),\n    LinearElementEditor.pointFromAbsoluteCoords(arrow, endPoint, elementsMap),\n  ];\n};\n\nexport const normalizeFixedPoint = <T extends FixedPoint | null>(\n  fixedPoint: T,\n): T extends null ? null : FixedPoint => {\n  // Do not allow a precise 0.5 for fixed point ratio\n  // to avoid jumping arrow heading due to floating point imprecision\n  if (\n    fixedPoint &&\n    (Math.abs(fixedPoint[0] - 0.5) < 0.0001 ||\n      Math.abs(fixedPoint[1] - 0.5) < 0.0001)\n  ) {\n    return fixedPoint.map((ratio) =>\n      Math.abs(ratio - 0.5) < 0.0001 ? 0.5001 : ratio,\n    ) as T extends null ? null : FixedPoint;\n  }\n  return fixedPoint as any as T extends null ? null : FixedPoint;\n};\n",
    "import { isTransparent } from \"@excalidraw/common\";\nimport {\n  curveIntersectLineSegment,\n  isPointWithinBounds,\n  lineSegment,\n  lineSegmentIntersectionPoints,\n  pointFrom,\n  pointFromVector,\n  pointRotateRads,\n  pointsEqual,\n  vectorFromPoint,\n  vectorNormalize,\n  vectorScale,\n} from \"@excalidraw/math\";\n\nimport {\n  ellipse,\n  ellipseSegmentInterceptPoints,\n} from \"@excalidraw/math/ellipse\";\n\nimport type {\n  Curve,\n  GlobalPoint,\n  LineSegment,\n  Radians,\n} from \"@excalidraw/math\";\n\nimport type { FrameNameBounds } from \"excalidraw-custom/types\";\n\nimport { isPathALoop } from \"./utils\";\nimport {\n  type Bounds,\n  doBoundsIntersect,\n  elementCenterPoint,\n  getCenterForBounds,\n  getCubicBezierCurveBound,\n  getElementBounds,\n} from \"./bounds\";\nimport {\n  hasBoundTextElement,\n  isFreeDrawElement,\n  isIframeLikeElement,\n  isImageElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\nimport {\n  deconstructDiamondElement,\n  deconstructLinearOrFreeDrawElement,\n  deconstructRectanguloidElement,\n} from \"./utils\";\n\nimport { getBoundTextElement } from \"./textElement\";\n\nimport { LinearElementEditor } from \"./linearElementEditor\";\n\nimport { distanceToElement } from \"./distance\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n} from \"./types\";\n\nexport const shouldTestInside = (element: ExcalidrawElement) => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n\n  const isDraggableFromInside =\n    !isTransparent(element.backgroundColor) ||\n    hasBoundTextElement(element) ||\n    isIframeLikeElement(element) ||\n    isTextElement(element);\n\n  if (element.type === \"line\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n\n  if (element.type === \"freedraw\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n\n  return isDraggableFromInside || isImageElement(element);\n};\n\nexport type HitTestArgs = {\n  point: GlobalPoint;\n  element: ExcalidrawElement;\n  threshold: number;\n  elementsMap: ElementsMap;\n  frameNameBound?: FrameNameBounds | null;\n};\n\nexport const hitElementItself = ({\n  point,\n  element,\n  threshold,\n  elementsMap,\n  frameNameBound = null,\n}: HitTestArgs) => {\n  // Hit test against a frame's name\n  const hitFrameName = frameNameBound\n    ? isPointWithinBounds(\n        pointFrom(frameNameBound.x - threshold, frameNameBound.y - threshold),\n        point,\n        pointFrom(\n          frameNameBound.x + frameNameBound.width + threshold,\n          frameNameBound.y + frameNameBound.height + threshold,\n        ),\n      )\n    : false;\n\n  // Hit test against the extended, rotated bounding box of the element first\n  const bounds = getElementBounds(element, elementsMap, true);\n  const hitBounds = isPointWithinBounds(\n    pointFrom(bounds[0] - threshold, bounds[1] - threshold),\n    pointRotateRads(\n      point,\n      getCenterForBounds(bounds),\n      -element.angle as Radians,\n    ),\n    pointFrom(bounds[2] + threshold, bounds[3] + threshold),\n  );\n\n  // PERF: Bail out early if the point is not even in the\n  // rotated bounding box or not hitting the frame name (saves 99%)\n  if (!hitBounds && !hitFrameName) {\n    return false;\n  }\n\n  // Do the precise (and relatively costly) hit test\n  const hitElement = shouldTestInside(element)\n    ? // Since `inShape` tests STRICTLY againt the insides of a shape\n      // we would need `onShape` as well to include the \"borders\"\n      isPointInElement(point, element, elementsMap) ||\n      isPointOnElementOutline(point, element, elementsMap, threshold)\n    : isPointOnElementOutline(point, element, elementsMap, threshold);\n\n  return hitElement || hitFrameName;\n};\n\nexport const hitElementBoundingBox = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  tolerance = 0,\n) => {\n  let [x1, y1, x2, y2] = getElementBounds(element, elementsMap);\n  x1 -= tolerance;\n  y1 -= tolerance;\n  x2 += tolerance;\n  y2 += tolerance;\n  return isPointWithinBounds(pointFrom(x1, y1), point, pointFrom(x2, y2));\n};\n\nexport const hitElementBoundingBoxOnly = (\n  hitArgs: HitTestArgs,\n  elementsMap: ElementsMap,\n) =>\n  !hitElementItself(hitArgs) &&\n  // bound text is considered part of the element (even if it's outside the bounding box)\n  !hitElementBoundText(hitArgs.point, hitArgs.element, elementsMap) &&\n  hitElementBoundingBox(hitArgs.point, hitArgs.element, elementsMap);\n\nexport const hitElementBoundText = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): boolean => {\n  const boundTextElementCandidate = getBoundTextElement(element, elementsMap);\n\n  if (!boundTextElementCandidate) {\n    return false;\n  }\n  const boundTextElement = isLinearElement(element)\n    ? {\n        ...boundTextElementCandidate,\n        // arrow's bound text accurate position is not stored in the element's property\n        // but rather calculated and returned from the following static method\n        ...LinearElementEditor.getBoundTextElementPosition(\n          element,\n          boundTextElementCandidate,\n          elementsMap,\n        ),\n      }\n    : boundTextElementCandidate;\n\n  return isPointInElement(point, boundTextElement, elementsMap);\n};\n\n/**\n * Intersect a line with an element for binding test\n *\n * @param element\n * @param line\n * @param offset\n * @returns\n */\nexport const intersectElementWithLineSegment = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  line: LineSegment<GlobalPoint>,\n  offset: number = 0,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  // First check if the line intersects the element's axis-aligned bounding box\n  // as it is much faster than checking intersection against the element's shape\n  const intersectorBounds = [\n    Math.min(line[0][0] - offset, line[1][0] - offset),\n    Math.min(line[0][1] - offset, line[1][1] - offset),\n    Math.max(line[0][0] + offset, line[1][0] + offset),\n    Math.max(line[0][1] + offset, line[1][1] + offset),\n  ] as Bounds;\n  const elementBounds = getElementBounds(element, elementsMap);\n\n  if (!doBoundsIntersect(intersectorBounds, elementBounds)) {\n    return [];\n  }\n\n  // Do the actual intersection test against the element's shape\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"frame\":\n    case \"selection\":\n    case \"magicframe\":\n      return intersectRectanguloidWithLineSegment(\n        element,\n        elementsMap,\n        line,\n        offset,\n        onlyFirst,\n      );\n    case \"diamond\":\n      return intersectDiamondWithLineSegment(\n        element,\n        elementsMap,\n        line,\n        offset,\n        onlyFirst,\n      );\n    case \"ellipse\":\n      return intersectEllipseWithLineSegment(\n        element,\n        elementsMap,\n        line,\n        offset,\n      );\n    case \"line\":\n    case \"freedraw\":\n    case \"arrow\":\n      return intersectLinearOrFreeDrawWithLineSegment(element, line, onlyFirst);\n  }\n};\n\nconst curveIntersections = (\n  curves: Curve<GlobalPoint>[],\n  segment: LineSegment<GlobalPoint>,\n  intersections: GlobalPoint[],\n  center: GlobalPoint,\n  angle: Radians,\n  onlyFirst = false,\n) => {\n  for (const c of curves) {\n    // Optimize by doing a cheap bounding box check first\n    const b1 = getCubicBezierCurveBound(c[0], c[1], c[2], c[3]);\n    const b2 = [\n      Math.min(segment[0][0], segment[1][0]),\n      Math.min(segment[0][1], segment[1][1]),\n      Math.max(segment[0][0], segment[1][0]),\n      Math.max(segment[0][1], segment[1][1]),\n    ] as Bounds;\n\n    if (!doBoundsIntersect(b1, b2)) {\n      continue;\n    }\n\n    const hits = curveIntersectLineSegment(c, segment);\n\n    if (hits.length > 0) {\n      for (const j of hits) {\n        intersections.push(pointRotateRads(j, center, angle));\n      }\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  return intersections;\n};\n\nconst lineIntersections = (\n  lines: LineSegment<GlobalPoint>[],\n  segment: LineSegment<GlobalPoint>,\n  intersections: GlobalPoint[],\n  center: GlobalPoint,\n  angle: Radians,\n  onlyFirst = false,\n) => {\n  for (const l of lines) {\n    const intersection = lineSegmentIntersectionPoints(l, segment);\n    if (intersection) {\n      intersections.push(pointRotateRads(intersection, center, angle));\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  return intersections;\n};\n\nconst intersectLinearOrFreeDrawWithLineSegment = (\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n  segment: LineSegment<GlobalPoint>,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  // NOTE: This is the only one which return the decomposed elements\n  // rotated! This is due to taking advantage of roughjs definitions.\n  const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n  const intersections: GlobalPoint[] = [];\n\n  for (const l of lines) {\n    const intersection = lineSegmentIntersectionPoints(l, segment);\n    if (intersection) {\n      intersections.push(intersection);\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  for (const c of curves) {\n    // Optimize by doing a cheap bounding box check first\n    const b1 = getCubicBezierCurveBound(c[0], c[1], c[2], c[3]);\n    const b2 = [\n      Math.min(segment[0][0], segment[1][0]),\n      Math.min(segment[0][1], segment[1][1]),\n      Math.max(segment[0][0], segment[1][0]),\n      Math.max(segment[0][1], segment[1][1]),\n    ] as Bounds;\n\n    if (!doBoundsIntersect(b1, b2)) {\n      continue;\n    }\n\n    const hits = curveIntersectLineSegment(c, segment);\n\n    if (hits.length > 0) {\n      intersections.push(...hits);\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  return intersections;\n};\n\nconst intersectRectanguloidWithLineSegment = (\n  element: ExcalidrawRectanguloidElement,\n  elementsMap: ElementsMap,\n  segment: LineSegment<GlobalPoint>,\n  offset: number = 0,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  const center = elementCenterPoint(element, elementsMap);\n  // To emulate a rotated rectangle we rotate the point in the inverse angle\n  // instead. It's all the same distance-wise.\n  const rotatedA = pointRotateRads<GlobalPoint>(\n    segment[0],\n    center,\n    -element.angle as Radians,\n  );\n  const rotatedB = pointRotateRads<GlobalPoint>(\n    segment[1],\n    center,\n    -element.angle as Radians,\n  );\n  const rotatedIntersector = lineSegment(rotatedA, rotatedB);\n\n  // Get the element's building components we can test against\n  const [sides, corners] = deconstructRectanguloidElement(element, offset);\n\n  const intersections: GlobalPoint[] = [];\n\n  lineIntersections(\n    sides,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  if (onlyFirst && intersections.length > 0) {\n    return intersections;\n  }\n\n  curveIntersections(\n    corners,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  return intersections;\n};\n\n/**\n *\n * @param element\n * @param a\n * @param b\n * @returns\n */\nconst intersectDiamondWithLineSegment = (\n  element: ExcalidrawDiamondElement,\n  elementsMap: ElementsMap,\n  l: LineSegment<GlobalPoint>,\n  offset: number = 0,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  // Rotate the point to the inverse direction to simulate the rotated diamond\n  // points. It's all the same distance-wise.\n  const rotatedA = pointRotateRads(l[0], center, -element.angle as Radians);\n  const rotatedB = pointRotateRads(l[1], center, -element.angle as Radians);\n  const rotatedIntersector = lineSegment(rotatedA, rotatedB);\n\n  const [sides, corners] = deconstructDiamondElement(element, offset);\n  const intersections: GlobalPoint[] = [];\n\n  lineIntersections(\n    sides,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  if (onlyFirst && intersections.length > 0) {\n    return intersections;\n  }\n\n  curveIntersections(\n    corners,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  return intersections;\n};\n\n/**\n *\n * @param element\n * @param a\n * @param b\n * @returns\n */\nconst intersectEllipseWithLineSegment = (\n  element: ExcalidrawEllipseElement,\n  elementsMap: ElementsMap,\n  l: LineSegment<GlobalPoint>,\n  offset: number = 0,\n): GlobalPoint[] => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  const rotatedA = pointRotateRads(l[0], center, -element.angle as Radians);\n  const rotatedB = pointRotateRads(l[1], center, -element.angle as Radians);\n\n  return ellipseSegmentInterceptPoints(\n    ellipse(center, element.width / 2 + offset, element.height / 2 + offset),\n    lineSegment(rotatedA, rotatedB),\n  ).map((p) => pointRotateRads(p, center, element.angle));\n};\n\n/**\n * Check if the given point is considered on the given shape's border\n *\n * @param point\n * @param element\n * @param tolerance\n * @returns\n */\nconst isPointOnElementOutline = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  tolerance = 1,\n) => distanceToElement(element, elementsMap, point) <= tolerance;\n\n/**\n * Check if the given point is considered inside the element's border\n *\n * @param point\n * @param element\n * @returns\n */\nexport const isPointInElement = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n) => {\n  if (\n    (isLinearElement(element) || isFreeDrawElement(element)) &&\n    !isPathALoop(element.points)\n  ) {\n    // There isn't any \"inside\" for a non-looping path\n    return false;\n  }\n\n  const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);\n\n  if (!isPointWithinBounds(pointFrom(x1, y1), point, pointFrom(x2, y2))) {\n    return false;\n  }\n\n  const center = pointFrom<GlobalPoint>((x1 + x2) / 2, (y1 + y2) / 2);\n  const otherPoint = pointFromVector(\n    vectorScale(\n      vectorNormalize(vectorFromPoint(point, center, 0.1)),\n      Math.max(element.width, element.height) * 2,\n    ),\n    center,\n  );\n  const intersector = lineSegment(point, otherPoint);\n  const intersections = intersectElementWithLineSegment(\n    element,\n    elementsMap,\n    intersector,\n  ).filter((p, pos, arr) => arr.findIndex((q) => pointsEqual(q, p)) === pos);\n\n  return intersections.length % 2 === 1;\n};\n",
    "import {\n  DEFAULT_ADAPTIVE_RADIUS,\n  DEFAULT_PROPORTIONAL_RADIUS,\n  LINE_CONFIRM_THRESHOLD,\n  ROUNDNESS,\n} from \"@excalidraw/common\";\n\nimport {\n  curve,\n  curveCatmullRomCubicApproxPoints,\n  curveOffsetPoints,\n  lineSegment,\n  pointDistance,\n  pointFrom,\n  pointFromArray,\n  rectangle,\n  type GlobalPoint,\n} from \"@excalidraw/math\";\n\nimport type { Curve, LineSegment, LocalPoint } from \"@excalidraw/math\";\n\nimport type { NormalizedZoomValue, Zoom } from \"excalidraw-custom/types\";\n\nimport { getDiamondPoints } from \"./bounds\";\n\nimport { generateLinearCollisionShape } from \"./shape\";\n\nimport type {\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n} from \"./types\";\n\ntype ElementShape = [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]];\n\nconst ElementShapesCache = new WeakMap<\n  ExcalidrawElement,\n  { version: ExcalidrawElement[\"version\"]; shapes: Map<number, ElementShape> }\n>();\n\nconst getElementShapesCacheEntry = <T extends ExcalidrawElement>(\n  element: T,\n  offset: number,\n): ElementShape | undefined => {\n  const record = ElementShapesCache.get(element);\n\n  if (!record) {\n    return undefined;\n  }\n\n  const { version, shapes } = record;\n\n  if (version !== element.version) {\n    ElementShapesCache.delete(element);\n    return undefined;\n  }\n\n  return shapes.get(offset);\n};\n\nconst setElementShapesCacheEntry = <T extends ExcalidrawElement>(\n  element: T,\n  shape: ElementShape,\n  offset: number,\n) => {\n  const record = ElementShapesCache.get(element);\n\n  if (!record) {\n    ElementShapesCache.set(element, {\n      version: element.version,\n      shapes: new Map([[offset, shape]]),\n    });\n\n    return;\n  }\n\n  const { version, shapes } = record;\n\n  if (version !== element.version) {\n    ElementShapesCache.set(element, {\n      version: element.version,\n      shapes: new Map([[offset, shape]]),\n    });\n\n    return;\n  }\n\n  shapes.set(offset, shape);\n};\n\n/**\n * Returns the **rotated** components of freedraw, line or arrow elements.\n *\n * @param element The linear element to deconstruct\n * @returns The rotated in components.\n */\nexport function deconstructLinearOrFreeDrawElement(\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n): [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]] {\n  const cachedShape = getElementShapesCacheEntry(element, 0);\n\n  if (cachedShape) {\n    return cachedShape;\n  }\n\n  const ops = generateLinearCollisionShape(element) as {\n    op: string;\n    data: number[];\n  }[];\n  const lines = [];\n  const curves = [];\n\n  for (let idx = 0; idx < ops.length; idx += 1) {\n    const op = ops[idx];\n    const prevPoint =\n      ops[idx - 1] && pointFromArray<LocalPoint>(ops[idx - 1].data.slice(-2));\n    switch (op.op) {\n      case \"move\":\n        continue;\n      case \"lineTo\":\n        if (!prevPoint) {\n          throw new Error(\"prevPoint is undefined\");\n        }\n\n        lines.push(\n          lineSegment<GlobalPoint>(\n            pointFrom<GlobalPoint>(\n              element.x + prevPoint[0],\n              element.y + prevPoint[1],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[0],\n              element.y + op.data[1],\n            ),\n          ),\n        );\n        continue;\n      case \"bcurveTo\":\n        if (!prevPoint) {\n          throw new Error(\"prevPoint is undefined\");\n        }\n\n        curves.push(\n          curve<GlobalPoint>(\n            pointFrom<GlobalPoint>(\n              element.x + prevPoint[0],\n              element.y + prevPoint[1],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[0],\n              element.y + op.data[1],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[2],\n              element.y + op.data[3],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[4],\n              element.y + op.data[5],\n            ),\n          ),\n        );\n        continue;\n      default: {\n        console.error(\"Unknown op type\", op.op);\n      }\n    }\n  }\n\n  const shape = [lines, curves] as ElementShape;\n  setElementShapesCacheEntry(element, shape, 0);\n\n  return shape;\n}\n\n/**\n * Get the building components of a rectanguloid element in the form of\n * line segments and curves **unrotated**.\n *\n * @param element Target rectanguloid element\n * @param offset Optional offset to expand the rectanguloid shape\n * @returns Tuple of **unrotated** line segments (0) and curves (1)\n */\nexport function deconstructRectanguloidElement(\n  element: ExcalidrawRectanguloidElement,\n  offset: number = 0,\n): [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]] {\n  const cachedShape = getElementShapesCacheEntry(element, offset);\n\n  if (cachedShape) {\n    return cachedShape;\n  }\n\n  let radius = getCornerRadius(\n    Math.min(element.width, element.height),\n    element,\n  );\n\n  if (radius === 0) {\n    radius = 0.01;\n  }\n\n  const r = rectangle(\n    pointFrom(element.x, element.y),\n    pointFrom(element.x + element.width, element.y + element.height),\n  );\n\n  const top = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[0][0] + radius, r[0][1]),\n    pointFrom<GlobalPoint>(r[1][0] - radius, r[0][1]),\n  );\n  const right = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[1][0], r[0][1] + radius),\n    pointFrom<GlobalPoint>(r[1][0], r[1][1] - radius),\n  );\n  const bottom = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[0][0] + radius, r[1][1]),\n    pointFrom<GlobalPoint>(r[1][0] - radius, r[1][1]),\n  );\n  const left = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[0][0], r[1][1] - radius),\n    pointFrom<GlobalPoint>(r[0][0], r[0][1] + radius),\n  );\n\n  const baseCorners = [\n    curve(\n      left[1],\n      pointFrom<GlobalPoint>(\n        left[1][0] + (2 / 3) * (r[0][0] - left[1][0]),\n        left[1][1] + (2 / 3) * (r[0][1] - left[1][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        top[0][0] + (2 / 3) * (r[0][0] - top[0][0]),\n        top[0][1] + (2 / 3) * (r[0][1] - top[0][1]),\n      ),\n      top[0],\n    ), // TOP LEFT\n    curve(\n      top[1],\n      pointFrom<GlobalPoint>(\n        top[1][0] + (2 / 3) * (r[1][0] - top[1][0]),\n        top[1][1] + (2 / 3) * (r[0][1] - top[1][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        right[0][0] + (2 / 3) * (r[1][0] - right[0][0]),\n        right[0][1] + (2 / 3) * (r[0][1] - right[0][1]),\n      ),\n      right[0],\n    ), // TOP RIGHT\n    curve(\n      right[1],\n      pointFrom<GlobalPoint>(\n        right[1][0] + (2 / 3) * (r[1][0] - right[1][0]),\n        right[1][1] + (2 / 3) * (r[1][1] - right[1][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        bottom[1][0] + (2 / 3) * (r[1][0] - bottom[1][0]),\n        bottom[1][1] + (2 / 3) * (r[1][1] - bottom[1][1]),\n      ),\n      bottom[1],\n    ), // BOTTOM RIGHT\n    curve(\n      bottom[0],\n      pointFrom<GlobalPoint>(\n        bottom[0][0] + (2 / 3) * (r[0][0] - bottom[0][0]),\n        bottom[0][1] + (2 / 3) * (r[1][1] - bottom[0][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        left[0][0] + (2 / 3) * (r[0][0] - left[0][0]),\n        left[0][1] + (2 / 3) * (r[1][1] - left[0][1]),\n      ),\n      left[0],\n    ), // BOTTOM LEFT\n  ];\n\n  const corners =\n    offset > 0\n      ? baseCorners.map(\n          (corner) =>\n            curveCatmullRomCubicApproxPoints(\n              curveOffsetPoints(corner, offset),\n            )!,\n        )\n      : [\n          [baseCorners[0]],\n          [baseCorners[1]],\n          [baseCorners[2]],\n          [baseCorners[3]],\n        ];\n\n  const sides = [\n    lineSegment<GlobalPoint>(\n      corners[0][corners[0].length - 1][3],\n      corners[1][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[1][corners[1].length - 1][3],\n      corners[2][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[2][corners[2].length - 1][3],\n      corners[3][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[3][corners[3].length - 1][3],\n      corners[0][0][0],\n    ),\n  ];\n  const shape = [sides, corners.flat()] as ElementShape;\n\n  setElementShapesCacheEntry(element, shape, offset);\n\n  return shape;\n}\n\n/**\n * Get the **unrotated** building components of a diamond element\n * in the form of line segments and curves as a tuple, in this order.\n *\n * @param element The element to deconstruct\n * @param offset An optional offset\n * @returns Tuple of line **unrotated** segments (0) and curves (1)\n */\nexport function deconstructDiamondElement(\n  element: ExcalidrawDiamondElement,\n  offset: number = 0,\n): [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]] {\n  const cachedShape = getElementShapesCacheEntry(element, offset);\n\n  if (cachedShape) {\n    return cachedShape;\n  }\n\n  const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] =\n    getDiamondPoints(element);\n  const verticalRadius = element.roundness\n    ? getCornerRadius(Math.abs(topX - leftX), element)\n    : (topX - leftX) * 0.01;\n  const horizontalRadius = element.roundness\n    ? getCornerRadius(Math.abs(rightY - topY), element)\n    : (rightY - topY) * 0.01;\n\n  const [top, right, bottom, left]: GlobalPoint[] = [\n    pointFrom(element.x + topX, element.y + topY),\n    pointFrom(element.x + rightX, element.y + rightY),\n    pointFrom(element.x + bottomX, element.y + bottomY),\n    pointFrom(element.x + leftX, element.y + leftY),\n  ];\n\n  const baseCorners = [\n    curve(\n      pointFrom<GlobalPoint>(\n        right[0] - verticalRadius,\n        right[1] - horizontalRadius,\n      ),\n      right,\n      right,\n      pointFrom<GlobalPoint>(\n        right[0] - verticalRadius,\n        right[1] + horizontalRadius,\n      ),\n    ), // RIGHT\n    curve(\n      pointFrom<GlobalPoint>(\n        bottom[0] + verticalRadius,\n        bottom[1] - horizontalRadius,\n      ),\n      bottom,\n      bottom,\n      pointFrom<GlobalPoint>(\n        bottom[0] - verticalRadius,\n        bottom[1] - horizontalRadius,\n      ),\n    ), // BOTTOM\n    curve(\n      pointFrom<GlobalPoint>(\n        left[0] + verticalRadius,\n        left[1] + horizontalRadius,\n      ),\n      left,\n      left,\n      pointFrom<GlobalPoint>(\n        left[0] + verticalRadius,\n        left[1] - horizontalRadius,\n      ),\n    ), // LEFT\n    curve(\n      pointFrom<GlobalPoint>(\n        top[0] - verticalRadius,\n        top[1] + horizontalRadius,\n      ),\n      top,\n      top,\n      pointFrom<GlobalPoint>(\n        top[0] + verticalRadius,\n        top[1] + horizontalRadius,\n      ),\n    ), // TOP\n  ];\n\n  const corners =\n    offset > 0\n      ? baseCorners.map(\n          (corner) =>\n            curveCatmullRomCubicApproxPoints(\n              curveOffsetPoints(corner, offset),\n            )!,\n        )\n      : [\n          [baseCorners[0]],\n          [baseCorners[1]],\n          [baseCorners[2]],\n          [baseCorners[3]],\n        ];\n\n  const sides = [\n    lineSegment<GlobalPoint>(\n      corners[0][corners[0].length - 1][3],\n      corners[1][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[1][corners[1].length - 1][3],\n      corners[2][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[2][corners[2].length - 1][3],\n      corners[3][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[3][corners[3].length - 1][3],\n      corners[0][0][0],\n    ),\n  ];\n\n  const shape = [sides, corners.flat()] as ElementShape;\n\n  setElementShapesCacheEntry(element, shape, offset);\n\n  return shape;\n}\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n  /** supply if you want the loop detection to account for current zoom */\n  zoomValue: Zoom[\"value\"] = 1 as NormalizedZoomValue,\n): boolean => {\n  if (points.length >= 3) {\n    const [first, last] = [points[0], points[points.length - 1]];\n    const distance = pointDistance(first, last);\n\n    // Adjusting LINE_CONFIRM_THRESHOLD to current zoom so that when zoomed in\n    // really close we make the threshold smaller, and vice versa.\n    return distance <= LINE_CONFIRM_THRESHOLD / zoomValue;\n  }\n  return false;\n};\n\nexport const getCornerRadius = (x: number, element: ExcalidrawElement) => {\n  if (\n    element.roundness?.type === ROUNDNESS.PROPORTIONAL_RADIUS ||\n    element.roundness?.type === ROUNDNESS.LEGACY\n  ) {\n    return x * DEFAULT_PROPORTIONAL_RADIUS;\n  }\n\n  if (element.roundness?.type === ROUNDNESS.ADAPTIVE_RADIUS) {\n    const fixedRadiusSize = element.roundness?.value ?? DEFAULT_ADAPTIVE_RADIUS;\n\n    const CUTOFF_SIZE = fixedRadiusSize / DEFAULT_PROPORTIONAL_RADIUS;\n\n    if (x <= CUTOFF_SIZE) {\n      return x * DEFAULT_PROPORTIONAL_RADIUS;\n    }\n\n    return fixedRadiusSize;\n  }\n\n  return 0;\n};\n",
    "import { ROUNDNESS, assertNever } from \"@excalidraw/common\";\n\nimport { pointsEqual } from \"@excalidraw/math\";\n\nimport type { ElementOrToolType } from \"excalidraw-custom/types\";\n\nimport type { MarkNonNullable } from \"@excalidraw/common/utility-types\";\n\nimport type { Bounds } from \"./bounds\";\nimport type {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawEmbeddableElement,\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  ExcalidrawFreeDrawElement,\n  InitializedExcalidrawImageElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawTextContainer,\n  ExcalidrawFrameElement,\n  RoundnessType,\n  ExcalidrawFrameLikeElement,\n  ExcalidrawElementType,\n  ExcalidrawIframeElement,\n  ExcalidrawIframeLikeElement,\n  ExcalidrawMagicFrameElement,\n  ExcalidrawArrowElement,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawLineElement,\n  PointBinding,\n  FixedPointBinding,\n  ExcalidrawFlowchartNodeElement,\n  ExcalidrawLinearElementSubType,\n} from \"./types\";\n\nexport const isInitializedImageElement = (\n  element: ExcalidrawElement | null,\n): element is InitializedExcalidrawImageElement => {\n  return !!element && element.type === \"image\" && !!element.fileId;\n};\n\nexport const isImageElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawImageElement => {\n  return !!element && element.type === \"image\";\n};\n\nexport const isEmbeddableElement = (\n  element: ExcalidrawElement | null | undefined,\n): element is ExcalidrawEmbeddableElement => {\n  return !!element && element.type === \"embeddable\";\n};\n\nexport const isIframeElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawIframeElement => {\n  return !!element && element.type === \"iframe\";\n};\n\nexport const isIframeLikeElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawIframeLikeElement => {\n  return (\n    !!element && (element.type === \"iframe\" || element.type === \"embeddable\")\n  );\n};\n\nexport const isTextElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElement => {\n  return element != null && element.type === \"text\";\n};\n\nexport const isFrameElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawFrameElement => {\n  return element != null && element.type === \"frame\";\n};\n\nexport const isMagicFrameElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawMagicFrameElement => {\n  return element != null && element.type === \"magicframe\";\n};\n\nexport const isFrameLikeElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawFrameLikeElement => {\n  return (\n    element != null &&\n    (element.type === \"frame\" || element.type === \"magicframe\")\n  );\n};\n\nexport const isFreeDrawElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawFreeDrawElement => {\n  return element != null && isFreeDrawElementType(element.type);\n};\n\nexport const isFreeDrawElementType = (\n  elementType: ExcalidrawElementType,\n): boolean => {\n  return elementType === \"freedraw\";\n};\n\nexport const isLinearElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isLinearElementType(element.type);\n};\n\nexport const isLineElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLineElement => {\n  return element != null && element.type === \"line\";\n};\n\nexport const isArrowElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawArrowElement => {\n  return element != null && element.type === \"arrow\";\n};\n\nexport const isElbowArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawElbowArrowElement => {\n  return isArrowElement(element) && element.elbowed;\n};\n\n/**\n * sharp or curved arrow, but not elbow\n */\nexport const isSimpleArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawArrowElement => {\n  return isArrowElement(element) && !element.elbowed;\n};\n\nexport const isSharpArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawArrowElement => {\n  return isArrowElement(element) && !element.elbowed && !element.roundness;\n};\n\nexport const isCurvedArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawArrowElement => {\n  return (\n    isArrowElement(element) && !element.elbowed && element.roundness !== null\n  );\n};\n\nexport const isLinearElementType = (\n  elementType: ElementOrToolType,\n): boolean => {\n  return (\n    elementType === \"arrow\" || elementType === \"line\" // || elementType === \"freedraw\"\n  );\n};\n\nexport const isBindingElement = (\n  element?: ExcalidrawElement | null,\n  includeLocked = true,\n): element is ExcalidrawLinearElement => {\n  return (\n    element != null &&\n    (!element.locked || includeLocked === true) &&\n    isBindingElementType(element.type)\n  );\n};\n\nexport const isBindingElementType = (\n  elementType: ElementOrToolType,\n): boolean => {\n  return elementType === \"arrow\";\n};\n\nexport const isBindableElement = (\n  element: ExcalidrawElement | null | undefined,\n  includeLocked = true,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (!element.locked || includeLocked === true) &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\" ||\n      element.type === \"image\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      (element.type === \"text\" && !element.containerId))\n  );\n};\n\nexport const isRectanguloidElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"image\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      (element.type === \"text\" && !element.containerId))\n  );\n};\n\n// TODO: Remove this when proper distance calculation is introduced\n// @see binding.ts:distanceToBindableElement()\nexport const isRectangularElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"image\" ||\n      element.type === \"text\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      element.type === \"freedraw\")\n  );\n};\n\nexport const isTextBindableContainer = (\n  element: ExcalidrawElement | null,\n  includeLocked = true,\n): element is ExcalidrawTextContainer => {\n  return (\n    element != null &&\n    (!element.locked || includeLocked === true) &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\" ||\n      isArrowElement(element))\n  );\n};\n\nexport const isExcalidrawElement = (\n  element: any,\n): element is ExcalidrawElement => {\n  const type: ExcalidrawElementType | undefined = element?.type;\n  if (!type) {\n    return false;\n  }\n  switch (type) {\n    case \"text\":\n    case \"diamond\":\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"ellipse\":\n    case \"arrow\":\n    case \"freedraw\":\n    case \"line\":\n    case \"frame\":\n    case \"magicframe\":\n    case \"image\":\n    case \"selection\": {\n      return true;\n    }\n    default: {\n      assertNever(type, null);\n      return false;\n    }\n  }\n};\n\nexport const isFlowchartNodeElement = (\n  element: ExcalidrawElement,\n): element is ExcalidrawFlowchartNodeElement => {\n  return (\n    element.type === \"rectangle\" ||\n    element.type === \"ellipse\" ||\n    element.type === \"diamond\"\n  );\n};\n\nexport const hasBoundTextElement = (\n  element: ExcalidrawElement | null,\n): element is MarkNonNullable<ExcalidrawBindableElement, \"boundElements\"> => {\n  return (\n    isTextBindableContainer(element) &&\n    !!element.boundElements?.some(({ type }) => type === \"text\")\n  );\n};\n\nexport const isBoundToContainer = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElementWithContainer => {\n  return (\n    element !== null &&\n    \"containerId\" in element &&\n    element.containerId !== null &&\n    isTextElement(element)\n  );\n};\n\nexport const isArrowBoundToElement = (element: ExcalidrawArrowElement) => {\n  return !!element.startBinding || !!element.endBinding;\n};\n\nexport const isUsingAdaptiveRadius = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"embeddable\" ||\n  type === \"iframe\" ||\n  type === \"image\";\n\nexport const isUsingProportionalRadius = (type: string) =>\n  type === \"line\" || type === \"arrow\" || type === \"diamond\";\n\nexport const canApplyRoundnessTypeToElement = (\n  roundnessType: RoundnessType,\n  element: ExcalidrawElement,\n) => {\n  if (\n    (roundnessType === ROUNDNESS.ADAPTIVE_RADIUS ||\n      // if legacy roundness, it can be applied to elements that currently\n      // use adaptive radius\n      roundnessType === ROUNDNESS.LEGACY) &&\n    isUsingAdaptiveRadius(element.type)\n  ) {\n    return true;\n  }\n  if (\n    roundnessType === ROUNDNESS.PROPORTIONAL_RADIUS &&\n    isUsingProportionalRadius(element.type)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const getDefaultRoundnessTypeForElement = (\n  element: ExcalidrawElement,\n) => {\n  if (isUsingProportionalRadius(element.type)) {\n    return {\n      type: ROUNDNESS.PROPORTIONAL_RADIUS,\n    };\n  }\n\n  if (isUsingAdaptiveRadius(element.type)) {\n    return {\n      type: ROUNDNESS.ADAPTIVE_RADIUS,\n    };\n  }\n\n  return null;\n};\n\nexport const isFixedPointBinding = (\n  binding: PointBinding | FixedPointBinding,\n): binding is FixedPointBinding => {\n  return (\n    Object.hasOwn(binding, \"fixedPoint\") &&\n    (binding as FixedPointBinding).fixedPoint != null\n  );\n};\n\n// TODO: Move this to @excalidraw/math\nexport const isBounds = (box: unknown): box is Bounds =>\n  Array.isArray(box) &&\n  box.length === 4 &&\n  typeof box[0] === \"number\" &&\n  typeof box[1] === \"number\" &&\n  typeof box[2] === \"number\" &&\n  typeof box[3] === \"number\";\n\nexport const getLinearElementSubType = (\n  element: ExcalidrawLinearElement,\n): ExcalidrawLinearElementSubType => {\n  if (isSharpArrow(element)) {\n    return \"sharpArrow\";\n  }\n  if (isCurvedArrow(element)) {\n    return \"curvedArrow\";\n  }\n  if (isElbowArrow(element)) {\n    return \"elbowArrow\";\n  }\n  return \"line\";\n};\n\n/**\n * Checks if current element points meet all the conditions for polygon=true\n * (this isn't a element type check, for that use isLineElement).\n *\n * If you want to check if points *can* be turned into a polygon, use\n *  canBecomePolygon(points).\n */\nexport const isValidPolygon = (\n  points: ExcalidrawLineElement[\"points\"],\n): boolean => {\n  return points.length > 3 && pointsEqual(points[0], points[points.length - 1]);\n};\n\nexport const canBecomePolygon = (\n  points: ExcalidrawLineElement[\"points\"],\n): boolean => {\n  return (\n    points.length > 3 ||\n    // 3-point polygons can't have all points in a single line\n    (points.length === 3 && !pointsEqual(points[0], points[points.length - 1]))\n  );\n};\n",
    "import {\n  ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO,\n  ARROW_LABEL_WIDTH_FRACTION,\n  BOUND_TEXT_PADDING,\n  DEFAULT_FONT_SIZE,\n  TEXT_ALIGN,\n  VERTICAL_ALIGN,\n  getFontString,\n  isProdEnv,\n  invariant,\n} from \"@excalidraw/common\";\n\nimport type { AppState } from \"excalidraw-custom/types\";\n\nimport type { ExtractSetType } from \"@excalidraw/common/utility-types\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport {\n  resetOriginalContainerCache,\n  updateOriginalContainerCache,\n} from \"./containerCache\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\n\nimport { measureText } from \"./textMeasurements\";\nimport { wrapText } from \"./textWrapping\";\nimport {\n  isBoundToContainer,\n  isArrowElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { MaybeTransformHandleType } from \"./transformHandles\";\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  ExcalidrawElementType,\n  ExcalidrawTextContainer,\n  ExcalidrawTextElement,\n  ExcalidrawTextElementWithContainer,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\nexport const redrawTextBoundingBox = (\n  textElement: ExcalidrawTextElement,\n  container: ExcalidrawElement | null,\n  scene: Scene,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  let maxWidth = undefined;\n\n  if (!isProdEnv()) {\n    invariant(\n      !container || !isArrowElement(container) || textElement.angle === 0,\n      \"text element angle must be 0 if bound to arrow container\",\n    );\n  }\n\n  const boundTextUpdates = {\n    x: textElement.x,\n    y: textElement.y,\n    text: textElement.text,\n    width: textElement.width,\n    height: textElement.height,\n    angle: (container\n      ? isArrowElement(container)\n        ? 0\n        : container.angle\n      : textElement.angle) as Radians,\n  };\n\n  boundTextUpdates.text = textElement.text;\n\n  if (container || !textElement.autoResize) {\n    maxWidth = container\n      ? getBoundTextMaxWidth(container, textElement)\n      : textElement.width;\n    boundTextUpdates.text = wrapText(\n      textElement.originalText,\n      getFontString(textElement),\n      maxWidth,\n    );\n  }\n\n  const metrics = measureText(\n    boundTextUpdates.text,\n    getFontString(textElement),\n    textElement.lineHeight,\n  );\n\n  // Note: only update width for unwrapped text and bound texts (which always have autoResize set to true)\n  if (textElement.autoResize) {\n    boundTextUpdates.width = metrics.width;\n  }\n  boundTextUpdates.height = metrics.height;\n\n  if (container) {\n    const maxContainerHeight = getBoundTextMaxHeight(\n      container,\n      textElement as ExcalidrawTextElementWithContainer,\n    );\n    const maxContainerWidth = getBoundTextMaxWidth(container, textElement);\n\n    if (!isArrowElement(container) && metrics.height > maxContainerHeight) {\n      const nextHeight = computeContainerDimensionForBoundText(\n        metrics.height,\n        container.type,\n      );\n      scene.mutateElement(container, { height: nextHeight });\n      updateOriginalContainerCache(container.id, nextHeight);\n    }\n\n    if (metrics.width > maxContainerWidth) {\n      const nextWidth = computeContainerDimensionForBoundText(\n        metrics.width,\n        container.type,\n      );\n      scene.mutateElement(container, { width: nextWidth });\n    }\n\n    const updatedTextElement = {\n      ...textElement,\n      ...boundTextUpdates,\n    } as ExcalidrawTextElementWithContainer;\n\n    const { x, y } = computeBoundTextPosition(\n      container,\n      updatedTextElement,\n      elementsMap,\n    );\n\n    boundTextUpdates.x = x;\n    boundTextUpdates.y = y;\n  }\n\n  scene.mutateElement(textElement, boundTextUpdates);\n};\n\nexport const handleBindTextResize = (\n  container: NonDeletedExcalidrawElement,\n  scene: Scene,\n  transformHandleType: MaybeTransformHandleType,\n  shouldMaintainAspectRatio = false,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const boundTextElementId = getBoundTextElementId(container);\n  if (!boundTextElementId) {\n    return;\n  }\n  resetOriginalContainerCache(container.id);\n  const textElement = getBoundTextElement(container, elementsMap);\n  if (textElement && textElement.text) {\n    if (!container) {\n      return;\n    }\n\n    let text = textElement.text;\n    let nextHeight = textElement.height;\n    let nextWidth = textElement.width;\n    const maxWidth = getBoundTextMaxWidth(container, textElement);\n    const maxHeight = getBoundTextMaxHeight(container, textElement);\n    let containerHeight = container.height;\n    if (\n      shouldMaintainAspectRatio ||\n      (transformHandleType !== \"n\" && transformHandleType !== \"s\")\n    ) {\n      if (text) {\n        text = wrapText(\n          textElement.originalText,\n          getFontString(textElement),\n          maxWidth,\n        );\n      }\n      const metrics = measureText(\n        text,\n        getFontString(textElement),\n        textElement.lineHeight,\n      );\n      nextHeight = metrics.height;\n      nextWidth = metrics.width;\n    }\n    // increase height in case text element height exceeds\n    if (nextHeight > maxHeight) {\n      containerHeight = computeContainerDimensionForBoundText(\n        nextHeight,\n        container.type,\n      );\n\n      const diff = containerHeight - container.height;\n      // fix the y coord when resizing from ne/nw/n\n      const updatedY =\n        !isArrowElement(container) &&\n        (transformHandleType === \"ne\" ||\n          transformHandleType === \"nw\" ||\n          transformHandleType === \"n\")\n          ? container.y - diff\n          : container.y;\n      scene.mutateElement(container, {\n        height: containerHeight,\n        y: updatedY,\n      });\n    }\n\n    scene.mutateElement(textElement, {\n      text,\n      width: nextWidth,\n      height: nextHeight,\n    });\n\n    if (!isArrowElement(container)) {\n      scene.mutateElement(\n        textElement,\n        computeBoundTextPosition(container, textElement, elementsMap),\n      );\n    }\n  }\n};\n\nexport const computeBoundTextPosition = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n  elementsMap: ElementsMap,\n) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(\n      container,\n      boundTextElement,\n      elementsMap,\n    );\n  }\n  const containerCoords = getContainerCoords(container);\n  const maxContainerHeight = getBoundTextMaxHeight(container, boundTextElement);\n  const maxContainerWidth = getBoundTextMaxWidth(container, boundTextElement);\n\n  let x;\n  let y;\n  if (boundTextElement.verticalAlign === VERTICAL_ALIGN.TOP) {\n    y = containerCoords.y;\n  } else if (boundTextElement.verticalAlign === VERTICAL_ALIGN.BOTTOM) {\n    y = containerCoords.y + (maxContainerHeight - boundTextElement.height);\n  } else {\n    y =\n      containerCoords.y +\n      (maxContainerHeight / 2 - boundTextElement.height / 2);\n  }\n  if (boundTextElement.textAlign === TEXT_ALIGN.LEFT) {\n    x = containerCoords.x;\n  } else if (boundTextElement.textAlign === TEXT_ALIGN.RIGHT) {\n    x = containerCoords.x + (maxContainerWidth - boundTextElement.width);\n  } else {\n    x =\n      containerCoords.x + (maxContainerWidth / 2 - boundTextElement.width / 2);\n  }\n  return { x, y };\n};\n\nexport const getBoundTextElementId = (container: ExcalidrawElement | null) => {\n  return container?.boundElements?.length\n    ? container?.boundElements?.find((ele) => ele.type === \"text\")?.id || null\n    : null;\n};\n\nexport const getBoundTextElement = (\n  element: ExcalidrawElement | null,\n  elementsMap: ElementsMap,\n) => {\n  if (!element) {\n    return null;\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n\n  if (boundTextElementId) {\n    return (elementsMap.get(boundTextElementId) ||\n      null) as ExcalidrawTextElementWithContainer | null;\n  }\n  return null;\n};\n\nexport const getContainerElement = (\n  element: ExcalidrawTextElement | null,\n  elementsMap: ElementsMap,\n): ExcalidrawTextContainer | null => {\n  if (!element) {\n    return null;\n  }\n  if (element.containerId) {\n    return (elementsMap.get(element.containerId) ||\n      null) as ExcalidrawTextContainer | null;\n  }\n  return null;\n};\n\nexport const getContainerCenter = (\n  container: ExcalidrawElement,\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  if (!isArrowElement(container)) {\n    return {\n      x: container.x + container.width / 2,\n      y: container.y + container.height / 2,\n    };\n  }\n  const points = LinearElementEditor.getPointsGlobalCoordinates(\n    container,\n    elementsMap,\n  );\n  if (points.length % 2 === 1) {\n    const index = Math.floor(container.points.length / 2);\n    const midPoint = LinearElementEditor.getPointGlobalCoordinates(\n      container,\n      container.points[index],\n      elementsMap,\n    );\n    return { x: midPoint[0], y: midPoint[1] };\n  }\n  const index = container.points.length / 2 - 1;\n  let midSegmentMidpoint = LinearElementEditor.getEditorMidPoints(\n    container,\n    elementsMap,\n    appState,\n  )[index];\n  if (!midSegmentMidpoint) {\n    midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(\n      container,\n      index + 1,\n    );\n  }\n  return { x: midSegmentMidpoint[0], y: midSegmentMidpoint[1] };\n};\n\nexport const getContainerCoords = (container: NonDeletedExcalidrawElement) => {\n  let offsetX = BOUND_TEXT_PADDING;\n  let offsetY = BOUND_TEXT_PADDING;\n\n  if (container.type === \"ellipse\") {\n    // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6172\n    offsetX += (container.width / 2) * (1 - Math.sqrt(2) / 2);\n    offsetY += (container.height / 2) * (1 - Math.sqrt(2) / 2);\n  }\n  // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6265\n  if (container.type === \"diamond\") {\n    offsetX += container.width / 4;\n    offsetY += container.height / 4;\n  }\n  return {\n    x: container.x + offsetX,\n    y: container.y + offsetY,\n  };\n};\n\nexport const getTextElementAngle = (\n  textElement: ExcalidrawTextElement,\n  container: ExcalidrawTextContainer | null,\n) => {\n  if (isArrowElement(container)) {\n    return 0;\n  }\n  if (!container) {\n    return textElement.angle;\n  }\n  return container.angle;\n};\n\nexport const getBoundTextElementPosition = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n  elementsMap: ElementsMap,\n) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(\n      container,\n      boundTextElement,\n      elementsMap,\n    );\n  }\n};\n\nexport const shouldAllowVerticalAlign = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  elementsMap: ElementsMap,\n) => {\n  return selectedElements.some((element) => {\n    if (isBoundToContainer(element)) {\n      const container = getContainerElement(element, elementsMap);\n      if (isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  });\n};\n\nexport const suppportsHorizontalAlign = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  elementsMap: ElementsMap,\n) => {\n  return selectedElements.some((element) => {\n    if (isBoundToContainer(element)) {\n      const container = getContainerElement(element, elementsMap);\n      if (isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n\n    return isTextElement(element);\n  });\n};\n\nconst VALID_CONTAINER_TYPES = new Set([\n  \"rectangle\",\n  \"ellipse\",\n  \"diamond\",\n  \"arrow\",\n]);\n\nexport const isValidTextContainer = (element: {\n  type: ExcalidrawElementType;\n}) => VALID_CONTAINER_TYPES.has(element.type);\n\nexport const computeContainerDimensionForBoundText = (\n  dimension: number,\n  containerType: ExtractSetType<typeof VALID_CONTAINER_TYPES>,\n) => {\n  dimension = Math.ceil(dimension);\n  const padding = BOUND_TEXT_PADDING * 2;\n\n  if (containerType === \"ellipse\") {\n    return Math.round(((dimension + padding) / Math.sqrt(2)) * 2);\n  }\n  if (containerType === \"arrow\") {\n    return dimension + padding * 8;\n  }\n  if (containerType === \"diamond\") {\n    return 2 * (dimension + padding);\n  }\n  return dimension + padding;\n};\n\nexport const getBoundTextMaxWidth = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElement | null,\n) => {\n  const { width } = container;\n  if (isArrowElement(container)) {\n    const minWidth =\n      (boundTextElement?.fontSize ?? DEFAULT_FONT_SIZE) *\n      ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO;\n    return Math.max(ARROW_LABEL_WIDTH_FRACTION * width, minWidth);\n  }\n  if (container.type === \"ellipse\") {\n    // The width of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.width / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse -https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round((width / 2) * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The width of the largest rectangle inscribed inside a rhombus is\n    // Math.round(width / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(width / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  return width - BOUND_TEXT_PADDING * 2;\n};\n\nexport const getBoundTextMaxHeight = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n) => {\n  const { height } = container;\n  if (isArrowElement(container)) {\n    const containerHeight = height - BOUND_TEXT_PADDING * 8 * 2;\n    if (containerHeight <= 0) {\n      return boundTextElement.height;\n    }\n    return height;\n  }\n  if (container.type === \"ellipse\") {\n    // The height of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.height / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse - https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round((height / 2) * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The height of the largest rectangle inscribed inside a rhombus is\n    // Math.round(height / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(height / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  return height - BOUND_TEXT_PADDING * 2;\n};\n\n/** retrieves text from text elements and concatenates to a single string */\nexport const getTextFromElements = (\n  elements: readonly ExcalidrawElement[],\n  separator = \"\\n\\n\",\n) => {\n  const text = elements\n    .reduce((acc: string[], element) => {\n      if (isTextElement(element)) {\n        acc.push(element.text);\n      }\n      return acc;\n    }, [])\n    .join(separator);\n  return text;\n};\n",
    "import type { ExcalidrawTextContainer } from \"./types\";\n\nexport const originalContainerCache: {\n  [id: ExcalidrawTextContainer[\"id\"]]:\n    | {\n        height: ExcalidrawTextContainer[\"height\"];\n      }\n    | undefined;\n} = {};\n\nexport const updateOriginalContainerCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n  height: ExcalidrawTextContainer[\"height\"],\n) => {\n  const data =\n    originalContainerCache[id] || (originalContainerCache[id] = { height });\n  data.height = height;\n  return data;\n};\n\nexport const resetOriginalContainerCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n) => {\n  if (originalContainerCache[id]) {\n    delete originalContainerCache[id];\n  }\n};\n\nexport const getOriginalContainerHeightFromCache = (\n  id: ExcalidrawTextContainer[\"id\"],\n) => {\n  return originalContainerCache[id]?.height ?? null;\n};\n",
    "import {\n  BOUND_TEXT_PADDING,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_FONT_FAMILY,\n  getFontString,\n  isTestEnv,\n  normalizeEOL,\n} from \"@excalidraw/common\";\n\nimport type { FontString, ExcalidrawTextElement } from \"./types\";\n\nexport const measureText = (\n  text: string,\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const _text = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    // lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const fontSize = parseFloat(font);\n  const height = getTextHeight(_text, fontSize, lineHeight);\n  const width = getTextWidth(_text, font);\n  return { width, height };\n};\n\nconst DUMMY_TEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toLocaleUpperCase();\n\n// FIXME rename to getApproxMinContainerWidth\nexport const getApproxMinLineWidth = (\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const maxCharWidth = getMaxCharWidth(font);\n  if (maxCharWidth === 0) {\n    return (\n      measureText(DUMMY_TEXT.split(\"\").join(\"\\n\"), font, lineHeight).width +\n      BOUND_TEXT_PADDING * 2\n    );\n  }\n  return maxCharWidth + BOUND_TEXT_PADDING * 2;\n};\n\nexport const getMinTextElementWidth = (\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return measureText(\"\", font, lineHeight).width + BOUND_TEXT_PADDING * 2;\n};\n\nexport const isMeasureTextSupported = () => {\n  const width = getTextWidth(\n    DUMMY_TEXT,\n    getFontString({\n      fontSize: DEFAULT_FONT_SIZE,\n      fontFamily: DEFAULT_FONT_FAMILY,\n    }),\n  );\n  return width > 0;\n};\n\nexport const normalizeText = (text: string) => {\n  return (\n    normalizeEOL(text)\n      // replace tabs with spaces so they render and measure correctly\n      .replace(/\\t/g, \"        \")\n  );\n};\n\nconst splitIntoLines = (text: string) => {\n  return normalizeText(text).split(\"\\n\");\n};\n\n/**\n * To get unitless line-height (if unknown) we can calculate it by dividing\n * height-per-line by fontSize.\n */\nexport const detectLineHeight = (textElement: ExcalidrawTextElement) => {\n  const lineCount = splitIntoLines(textElement.text).length;\n  return (textElement.height /\n    lineCount /\n    textElement.fontSize) as ExcalidrawTextElement[\"lineHeight\"];\n};\n\n/**\n * We calculate the line height from the font size and the unitless line height,\n * aligning with the W3C spec.\n */\nexport const getLineHeightInPx = (\n  fontSize: ExcalidrawTextElement[\"fontSize\"],\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return fontSize * lineHeight;\n};\n\n// FIXME rename to getApproxMinContainerHeight\nexport const getApproxMinLineHeight = (\n  fontSize: ExcalidrawTextElement[\"fontSize\"],\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return getLineHeightInPx(fontSize, lineHeight) + BOUND_TEXT_PADDING * 2;\n};\n\nlet textMetricsProvider: TextMetricsProvider | undefined;\n\n/**\n * Set a custom text metrics provider.\n *\n * Useful for overriding the width calculation algorithm where canvas API is not available / desired.\n */\nexport const setCustomTextMetricsProvider = (provider: TextMetricsProvider) => {\n  textMetricsProvider = provider;\n};\n\nexport interface TextMetricsProvider {\n  getLineWidth(text: string, fontString: FontString): number;\n}\n\nclass CanvasTextMetricsProvider implements TextMetricsProvider {\n  private canvas: HTMLCanvasElement;\n\n  constructor() {\n    this.canvas = document.createElement(\"canvas\");\n  }\n\n  /**\n   * We need to use the advance width as that's the closest thing to the browser wrapping algo, hence using it for:\n   * - text wrapping\n   * - wysiwyg editor (+padding)\n   *\n   * > The advance width is the distance between the glyph's initial pen position and the next glyph's initial pen position.\n   */\n  public getLineWidth(text: string, fontString: FontString): number {\n    const context = this.canvas.getContext(\"2d\")!;\n    context.font = fontString;\n    const metrics = context.measureText(text);\n    const advanceWidth = metrics.width;\n\n    // since in test env the canvas measureText algo\n    // doesn't measure text and instead just returns number of\n    // characters hence we assume that each letteris 10px\n    if (isTestEnv()) {\n      return advanceWidth * 10;\n    }\n\n    return advanceWidth;\n  }\n}\n\nexport const getLineWidth = (text: string, font: FontString) => {\n  if (!textMetricsProvider) {\n    textMetricsProvider = new CanvasTextMetricsProvider();\n  }\n\n  return textMetricsProvider.getLineWidth(text, font);\n};\n\nexport const getTextWidth = (text: string, font: FontString) => {\n  const lines = splitIntoLines(text);\n  let width = 0;\n  lines.forEach((line) => {\n    width = Math.max(width, getLineWidth(line, font));\n  });\n\n  return width;\n};\n\nexport const getTextHeight = (\n  text: string,\n  fontSize: number,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const lineCount = splitIntoLines(text).length;\n  return getLineHeightInPx(fontSize, lineHeight) * lineCount;\n};\n\nexport const charWidth = (() => {\n  const cachedCharWidth: { [key: FontString]: Array<number> } = {};\n\n  const calculate = (char: string, font: FontString) => {\n    const unicode = char.charCodeAt(0);\n    if (!cachedCharWidth[font]) {\n      cachedCharWidth[font] = [];\n    }\n    if (!cachedCharWidth[font][unicode]) {\n      const width = getLineWidth(char, font);\n      cachedCharWidth[font][unicode] = width;\n    }\n\n    return cachedCharWidth[font][unicode];\n  };\n\n  const getCache = (font: FontString) => {\n    return cachedCharWidth[font];\n  };\n\n  const clearCache = (font: FontString) => {\n    cachedCharWidth[font] = [];\n  };\n\n  return {\n    calculate,\n    getCache,\n    clearCache,\n  };\n})();\n\nexport const getMinCharWidth = (font: FontString) => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter((val) => val !== undefined);\n\n  return Math.min(...cacheWithOutEmpty);\n};\n\nexport const getMaxCharWidth = (font: FontString) => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter((val) => val !== undefined);\n  return Math.max(...cacheWithOutEmpty);\n};\n",
    "import { isDevEnv, isTestEnv } from \"@excalidraw/common\";\n\nimport { charWidth, getLineWidth } from \"./textMeasurements\";\n\nimport type { FontString } from \"./types\";\n\nlet cachedCjkRegex: RegExp | undefined;\nlet cachedLineBreakRegex: RegExp | undefined;\nlet cachedEmojiRegex: RegExp | undefined;\n\n/**\n * Test if a given text contains any CJK characters (including symbols, punctuation, etc,).\n */\nexport const containsCJK = (text: string) => {\n  if (!cachedCjkRegex) {\n    cachedCjkRegex = Regex.class(...Object.values(CJK));\n  }\n\n  return cachedCjkRegex.test(text);\n};\n\nconst getLineBreakRegex = () => {\n  if (!cachedLineBreakRegex) {\n    try {\n      cachedLineBreakRegex = getLineBreakRegexAdvanced();\n    } catch {\n      cachedLineBreakRegex = getLineBreakRegexSimple();\n    }\n  }\n\n  return cachedLineBreakRegex;\n};\n\nconst getEmojiRegex = () => {\n  if (!cachedEmojiRegex) {\n    cachedEmojiRegex = getEmojiRegexUnicode();\n  }\n\n  return cachedEmojiRegex;\n};\n\n/**\n * Common symbols used across different languages.\n */\nconst COMMON = {\n  /**\n   * Natural breaking points for any grammars.\n   *\n   * Hello world\n   *      ↑ BREAK ALWAYS \" \" → [\"Hello\", \" \", \"world\"]\n   * Hello-world\n   *       ↑ BREAK AFTER \"-\" → [\"Hello-\", \"world\"]\n   */\n  WHITESPACE: /\\s/u,\n  HYPHEN: /-/u,\n  /**\n   * Generally do not break, unless closed symbol is followed by an opening symbol.\n   *\n   * Also, western punctation is often used in modern Korean and expects to be treated\n   * similarly to the CJK opening and closing symbols.\n   *\n   * Hello(한글)→ [\"Hello\", \"(한\", \"글)\"]\n   *      ↑ BREAK BEFORE \"(\"\n   *          ↑ BREAK AFTER \")\"\n   */\n  OPENING: /<\\(\\[\\{/u,\n  CLOSING: />\\)\\]\\}.,:;!\\?…\\//u,\n};\n\n/**\n * Characters and symbols used in Chinese, Japanese and Korean.\n */\nconst CJK = {\n  /**\n   * Every CJK breaks before and after, unless it's paired with an opening or closing symbol.\n   *\n   * Does not include every possible char used in CJK texts, such as currency, parentheses or punctuation.\n   */\n  CHAR: /\\p{Script=Han}\\p{Script=Hiragana}\\p{Script=Katakana}\\p{Script=Hangul}｀＇＾〃〰〆＃＆＊＋－ー／＼＝｜￤〒￢￣/u,\n  /**\n   * Opening and closing CJK punctuation breaks before and after all such characters (in case of many),\n   * and creates pairs with neighboring characters.\n   *\n   * Hello た。→ [\"Hello\", \"た。\"]\n   *        ↑ DON'T BREAK \"た。\"\n   * * Hello「た」 World → [\"Hello\", \"「た」\", \"World\"]\n   *       ↑ DON'T BREAK \"「た\"\n   *        ↑ DON'T BREAK \"た\"\n   *      ↑ BREAK BEFORE \"「\"\n   *         ↑ BREAK AFTER \"」\"\n   */\n  // eslint-disable-next-line prettier/prettier\n  OPENING:/（［｛〈《｟｢「『【〖〔〘〚＜〝/u,\n  CLOSING: /）］｝〉》｠｣」』】〗〕〙〛＞。．，、〟‥？！：；・〜〞/u,\n  /**\n   * Currency symbols break before, not after\n   *\n   * Price￥100 → [\"Price\", \"￥100\"]\n   *      ↑ BREAK BEFORE \"￥\"\n   */\n  CURRENCY: /￥￦￡￠＄/u,\n};\n\nconst EMOJI = {\n  FLAG: /\\p{RI}\\p{RI}/u,\n  JOINER:\n    /(?:\\p{Emoji_Modifier}|\\uFE0F\\u20E3?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?/u,\n  ZWJ: /\\u200D/u,\n  ANY: /[\\p{Emoji}]/u,\n  MOST: /[\\p{Extended_Pictographic}\\p{Emoji_Presentation}]/u,\n};\n\n/**\n * Simple fallback for browsers (mainly Safari < 16.4) that don't support \"Lookbehind assertion\".\n *\n * Browser support as of 10/2024:\n * - 91% Lookbehind assertion https://caniuse.com/mdn-javascript_regular_expressions_lookbehind_assertion\n * - 94% Unicode character class escape https://caniuse.com/mdn-javascript_regular_expressions_unicode_character_class_escape\n *\n * Does not include advanced CJK breaking rules, but covers most of the core cases, especially for latin.\n */\nconst getLineBreakRegexSimple = () =>\n  Regex.or(\n    getEmojiRegex(),\n    Break.On(COMMON.HYPHEN, COMMON.WHITESPACE, CJK.CHAR),\n  );\n\n/**\n * Specifies the line breaking rules based for alphabetic-based languages,\n * Chinese, Japanese, Korean and Emojis.\n *\n * \"Hello-world\" → [\"Hello-\", \"world\"]\n * \"Hello 「世界。」🌎🗺\" → [\"Hello\", \" \", \"「世\", \"界。」\", \"🌎\", \"🗺\"]\n */\nconst getLineBreakRegexAdvanced = () =>\n  Regex.or(\n    // Unicode-defined regex for (multi-codepoint) Emojis\n    getEmojiRegex(),\n    // Rules for whitespace and hyphen\n    Break.Before(COMMON.WHITESPACE).Build(),\n    Break.After(COMMON.WHITESPACE, COMMON.HYPHEN).Build(),\n    // Rules for CJK (chars, symbols, currency)\n    Break.Before(CJK.CHAR, CJK.CURRENCY)\n      .NotPrecededBy(COMMON.OPENING, CJK.OPENING)\n      .Build(),\n    Break.After(CJK.CHAR)\n      .NotFollowedBy(COMMON.HYPHEN, COMMON.CLOSING, CJK.CLOSING)\n      .Build(),\n    // Rules for opening and closing punctuation\n    Break.BeforeMany(CJK.OPENING).NotPrecededBy(COMMON.OPENING).Build(),\n    Break.AfterMany(CJK.CLOSING).NotFollowedBy(COMMON.CLOSING).Build(),\n    Break.AfterMany(COMMON.CLOSING).FollowedBy(COMMON.OPENING).Build(),\n  );\n\n/**\n * Matches various emoji types.\n *\n * 1. basic emojis (😀, 🌍)\n * 2. flags (🇨🇿)\n * 3. multi-codepoint emojis:\n *    - skin tones (👍🏽)\n *    - variation selectors (☂️)\n *    - keycaps (1️⃣)\n *    - tag sequences (🏴󠁧󠁢󠁥󠁮󠁧󠁿)\n *    - emoji sequences (👨‍👩‍👧‍👦, 👩‍🚀, 🏳️‍🌈)\n *\n * Unicode points:\n * - \\uFE0F: presentation selector\n * - \\u20E3: enclosing keycap\n * - \\u200D: zero width joiner\n * - \\u{E0020}-\\u{E007E}: tags\n * - \\u{E007F}: cancel tag\n *\n * @see https://unicode.org/reports/tr51/#EBNF_and_Regex, with changes:\n * - replaced \\p{Emoji} with [\\p{Extended_Pictographic}\\p{Emoji_Presentation}], see more in `should tokenize emojis mixed with mixed text` test\n * - replaced \\p{Emod} with \\p{Emoji_Modifier} as some engines do not understand the abbreviation (i.e. https://devina.io/redos-checker)\n */\nconst getEmojiRegexUnicode = () =>\n  Regex.group(\n    Regex.or(\n      EMOJI.FLAG,\n      Regex.and(\n        EMOJI.MOST,\n        EMOJI.JOINER,\n        Regex.build(\n          `(?:${EMOJI.ZWJ.source}(?:${EMOJI.FLAG.source}|${EMOJI.ANY.source}${EMOJI.JOINER.source}))*`,\n        ),\n      ),\n    ),\n  );\n\n/**\n * Regex utilities for unicode character classes.\n */\nconst Regex = {\n  /**\n   * Builds a regex from a string.\n   */\n  build: (regex: string): RegExp => new RegExp(regex, \"u\"),\n  /**\n   * Joins regexes into a single string.\n   */\n  join: (...regexes: RegExp[]): string => regexes.map((x) => x.source).join(\"\"),\n  /**\n   * Joins regexes into a single regex as with \"and\" operator.\n   */\n  and: (...regexes: RegExp[]): RegExp => Regex.build(Regex.join(...regexes)),\n  /**\n   * Joins regexes into a single regex with \"or\" operator.\n   */\n  or: (...regexes: RegExp[]): RegExp =>\n    Regex.build(regexes.map((x) => x.source).join(\"|\")),\n  /**\n   * Puts regexes into a matching group.\n   */\n  group: (...regexes: RegExp[]): RegExp =>\n    Regex.build(`(${Regex.join(...regexes)})`),\n  /**\n   * Puts regexes into a character class.\n   */\n  class: (...regexes: RegExp[]): RegExp =>\n    Regex.build(`[${Regex.join(...regexes)}]`),\n};\n\n/**\n * Human-readable lookahead and lookbehind utilities for defining line break\n * opportunities between pairs of character classes.\n */\nconst Break = {\n  /**\n   * Break on the given class of characters.\n   */\n  On: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    return Regex.build(`([${joined}])`);\n  },\n  /**\n   * Break before the given class of characters.\n   */\n  Before: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?=[${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"FollowedBy\"\n    >;\n  },\n  /**\n   * Break after the given class of characters.\n   */\n  After: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<=[${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"PreceededBy\"\n    >;\n  },\n  /**\n   * Break before one or multiple characters of the same class.\n   */\n  BeforeMany: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<![${joined}])(?=[${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"FollowedBy\"\n    >;\n  },\n  /**\n   * Break after one or multiple character from the same class.\n   */\n  AfterMany: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<=[${joined}])(?![${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"PreceededBy\"\n    >;\n  },\n  /**\n   * Do not break before the given class of characters.\n   */\n  NotBefore: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?![${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"NotFollowedBy\"\n    >;\n  },\n  /**\n   * Do not break after the given class of characters.\n   */\n  NotAfter: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<![${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"NotPrecededBy\"\n    >;\n  },\n  Chain: (rootBuilder: () => RegExp) => ({\n    /**\n     * Build the root regex.\n     */\n    Build: rootBuilder,\n    /**\n     * Specify additional class of characters that should precede the root regex.\n     */\n    PreceededBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const preceeded = Break.After(...regexes).Build();\n      const builder = () => Regex.and(preceeded, root);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"PreceededBy\"\n      >;\n    },\n    /**\n     * Specify additional class of characters that should follow the root regex.\n     */\n    FollowedBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const followed = Break.Before(...regexes).Build();\n      const builder = () => Regex.and(root, followed);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"FollowedBy\"\n      >;\n    },\n    /**\n     * Specify additional class of characters that should not precede the root regex.\n     */\n    NotPrecededBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const notPreceeded = Break.NotAfter(...regexes).Build();\n      const builder = () => Regex.and(notPreceeded, root);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"NotPrecededBy\"\n      >;\n    },\n    /**\n     * Specify additional class of characters that should not follow the root regex.\n     */\n    NotFollowedBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const notFollowed = Break.NotBefore(...regexes).Build();\n      const builder = () => Regex.and(root, notFollowed);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"NotFollowedBy\"\n      >;\n    },\n  }),\n};\n\n/**\n * Breaks the line into the tokens based on the found line break opporutnities.\n */\nexport const parseTokens = (line: string) => {\n  const breakLineRegex = getLineBreakRegex();\n\n  // normalizing to single-codepoint composed chars due to canonical equivalence\n  // of multi-codepoint versions for chars like č, で (~ so that we don't break a line in between c and ˇ)\n  // filtering due to multi-codepoint chars like 👨‍👩‍👧‍👦, 👩🏽‍🦰\n  return line.normalize(\"NFC\").split(breakLineRegex).filter(Boolean);\n};\n\n/**\n * Wraps the original text into the lines based on the given width.\n */\nexport const wrapText = (\n  text: string,\n  font: FontString,\n  maxWidth: number,\n): string => {\n  // if maxWidth is not finite or NaN which can happen in case of bugs in\n  // computation, we need to make sure we don't continue as we'll end up\n  // in an infinite loop\n  if (!Number.isFinite(maxWidth) || maxWidth < 0) {\n    return text;\n  }\n\n  const lines: Array<string> = [];\n  const originalLines = text.split(\"\\n\");\n\n  for (const originalLine of originalLines) {\n    const currentLineWidth = getLineWidth(originalLine, font);\n\n    if (currentLineWidth <= maxWidth) {\n      lines.push(originalLine);\n      continue;\n    }\n\n    const wrappedLine = wrapLine(originalLine, font, maxWidth);\n    lines.push(...wrappedLine);\n  }\n\n  return lines.join(\"\\n\");\n};\n\n/**\n * Wraps the original line into the lines based on the given width.\n */\nconst wrapLine = (\n  line: string,\n  font: FontString,\n  maxWidth: number,\n): string[] => {\n  const lines: Array<string> = [];\n  const tokens = parseTokens(line);\n  const tokenIterator = tokens[Symbol.iterator]();\n\n  let currentLine = \"\";\n  let currentLineWidth = 0;\n\n  let iterator = tokenIterator.next();\n\n  while (!iterator.done) {\n    const token = iterator.value;\n    const testLine = currentLine + token;\n\n    // cache single codepoint whitespace, CJK or emoji width calc. as kerning should not apply here\n    const testLineWidth = isSingleCharacter(token)\n      ? currentLineWidth + charWidth.calculate(token, font)\n      : getLineWidth(testLine, font);\n\n    // build up the current line, skipping length check for possibly trailing whitespaces\n    if (/\\s/.test(token) || testLineWidth <= maxWidth) {\n      currentLine = testLine;\n      currentLineWidth = testLineWidth;\n      iterator = tokenIterator.next();\n      continue;\n    }\n\n    // current line is empty => just the token (word) is longer than `maxWidth` and needs to be wrapped\n    if (!currentLine) {\n      const wrappedWord = wrapWord(token, font, maxWidth);\n      const trailingLine = wrappedWord[wrappedWord.length - 1] ?? \"\";\n      const precedingLines = wrappedWord.slice(0, -1);\n\n      lines.push(...precedingLines);\n\n      // trailing line of the wrapped word might still be joined with next token/s\n      currentLine = trailingLine;\n      currentLineWidth = getLineWidth(trailingLine, font);\n      iterator = tokenIterator.next();\n    } else {\n      // push & reset, but don't iterate on the next token, as we didn't use it yet!\n      lines.push(currentLine.trimEnd());\n\n      // purposefully not iterating and not setting `currentLine` to `token`, so that we could use a simple !currentLine check above\n      currentLine = \"\";\n      currentLineWidth = 0;\n    }\n  }\n\n  // iterator done, push the trailing line if exists\n  if (currentLine) {\n    const trailingLine = trimLine(currentLine, font, maxWidth);\n    lines.push(trailingLine);\n  }\n\n  return lines;\n};\n\n/**\n * Wraps the word into the lines based on the given width.\n */\nconst wrapWord = (\n  word: string,\n  font: FontString,\n  maxWidth: number,\n): Array<string> => {\n  // multi-codepoint emojis are already broken apart and shouldn't be broken further\n  if (getEmojiRegex().test(word)) {\n    return [word];\n  }\n\n  satisfiesWordInvariant(word);\n\n  const lines: Array<string> = [];\n  const chars = Array.from(word);\n\n  let currentLine = \"\";\n  let currentLineWidth = 0;\n\n  for (const char of chars) {\n    const _charWidth = charWidth.calculate(char, font);\n    const testLineWidth = currentLineWidth + _charWidth;\n\n    if (testLineWidth <= maxWidth) {\n      currentLine = currentLine + char;\n      currentLineWidth = testLineWidth;\n      continue;\n    }\n\n    if (currentLine) {\n      lines.push(currentLine);\n    }\n\n    currentLine = char;\n    currentLineWidth = _charWidth;\n  }\n\n  if (currentLine) {\n    lines.push(currentLine);\n  }\n\n  return lines;\n};\n\n/**\n * Similarly to browsers, does not trim all trailing whitespaces, but only those exceeding the `maxWidth`.\n */\nconst trimLine = (line: string, font: FontString, maxWidth: number) => {\n  const shouldTrimWhitespaces = getLineWidth(line, font) > maxWidth;\n\n  if (!shouldTrimWhitespaces) {\n    return line;\n  }\n\n  // defensively default to `trimeEnd` in case the regex does not match\n  let [, trimmedLine, whitespaces] = line.match(/^(.+?)(\\s+)$/) ?? [\n    line,\n    line.trimEnd(),\n    \"\",\n  ];\n\n  let trimmedLineWidth = getLineWidth(trimmedLine, font);\n\n  for (const whitespace of Array.from(whitespaces)) {\n    const _charWidth = charWidth.calculate(whitespace, font);\n    const testLineWidth = trimmedLineWidth + _charWidth;\n\n    if (testLineWidth > maxWidth) {\n      break;\n    }\n\n    trimmedLine = trimmedLine + whitespace;\n    trimmedLineWidth = testLineWidth;\n  }\n\n  return trimmedLine;\n};\n\n/**\n * Check if the given string is a single character.\n *\n * Handles multi-byte chars (é, 中) and purposefully does not handle multi-codepoint char (👨‍👩‍👧‍👦, 👩🏽‍🦰).\n */\nconst isSingleCharacter = (maybeSingleCharacter: string) => {\n  return (\n    maybeSingleCharacter.codePointAt(0) !== undefined &&\n    maybeSingleCharacter.codePointAt(1) === undefined\n  );\n};\n\n/**\n * Invariant for the word wrapping algorithm.\n */\nconst satisfiesWordInvariant = (word: string) => {\n  if (isTestEnv() || isDevEnv()) {\n    if (/\\s/.test(word)) {\n      throw new Error(\"Word should not contain any whitespaces!\");\n    }\n  }\n};\n",
    "import {\n  curvePointDistance,\n  distanceToLineSegment,\n  pointRotateRads,\n} from \"@excalidraw/math\";\n\nimport { ellipse, ellipseDistanceFromPoint } from \"@excalidraw/math/ellipse\";\n\nimport type { GlobalPoint, Radians } from \"@excalidraw/math\";\n\nimport {\n  deconstructDiamondElement,\n  deconstructLinearOrFreeDrawElement,\n  deconstructRectanguloidElement,\n} from \"./utils\";\n\nimport { elementCenterPoint } from \"./bounds\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n} from \"./types\";\n\nexport const distanceToElement = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): number => {\n  switch (element.type) {\n    case \"selection\":\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"frame\":\n    case \"magicframe\":\n      return distanceToRectanguloidElement(element, elementsMap, p);\n    case \"diamond\":\n      return distanceToDiamondElement(element, elementsMap, p);\n    case \"ellipse\":\n      return distanceToEllipseElement(element, elementsMap, p);\n    case \"line\":\n    case \"arrow\":\n    case \"freedraw\":\n      return distanceToLinearOrFreeDraElement(element, p);\n  }\n};\n\n/**\n * Returns the distance of a point and the provided rectangular-shaped element,\n * accounting for roundness and rotation\n *\n * @param element The rectanguloid element\n * @param p The point to consider\n * @returns The eucledian distance to the outline of the rectanguloid element\n */\nconst distanceToRectanguloidElement = (\n  element: ExcalidrawRectanguloidElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n) => {\n  const center = elementCenterPoint(element, elementsMap);\n  // To emulate a rotated rectangle we rotate the point in the inverse angle\n  // instead. It's all the same distance-wise.\n  const rotatedPoint = pointRotateRads(p, center, -element.angle as Radians);\n\n  // Get the element's building components we can test against\n  const [sides, corners] = deconstructRectanguloidElement(element);\n\n  return Math.min(\n    ...sides.map((s) => distanceToLineSegment(rotatedPoint, s)),\n    ...corners\n      .map((a) => curvePointDistance(a, rotatedPoint))\n      .filter((d): d is number => d !== null),\n  );\n};\n\n/**\n * Returns the distance of a point and the provided diamond element, accounting\n * for roundness and rotation\n *\n * @param element The diamond element\n * @param p The point to consider\n * @returns The eucledian distance to the outline of the diamond\n */\nconst distanceToDiamondElement = (\n  element: ExcalidrawDiamondElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): number => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  // Rotate the point to the inverse direction to simulate the rotated diamond\n  // points. It's all the same distance-wise.\n  const rotatedPoint = pointRotateRads(p, center, -element.angle as Radians);\n\n  const [sides, curves] = deconstructDiamondElement(element);\n\n  return Math.min(\n    ...sides.map((s) => distanceToLineSegment(rotatedPoint, s)),\n    ...curves\n      .map((a) => curvePointDistance(a, rotatedPoint))\n      .filter((d): d is number => d !== null),\n  );\n};\n\n/**\n * Returns the distance of a point and the provided ellipse element, accounting\n * for roundness and rotation\n *\n * @param element The ellipse element\n * @param p The point to consider\n * @returns The eucledian distance to the outline of the ellipse\n */\nconst distanceToEllipseElement = (\n  element: ExcalidrawEllipseElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): number => {\n  const center = elementCenterPoint(element, elementsMap);\n  return ellipseDistanceFromPoint(\n    // Instead of rotating the ellipse, rotate the point to the inverse angle\n    pointRotateRads(p, center, -element.angle as Radians),\n    ellipse(center, element.width / 2, element.height / 2),\n  );\n};\n\nconst distanceToLinearOrFreeDraElement = (\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n  p: GlobalPoint,\n) => {\n  const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n  return Math.min(\n    ...lines.map((s) => distanceToLineSegment(p, s)),\n    ...curves.map((a) => curvePointDistance(a, p)),\n  );\n};\n",
    "import { invariant, isDevEnv, isTestEnv } from \"@excalidraw/common\";\n\nimport {\n  pointFrom,\n  pointFromVector,\n  pointRotateRads,\n  pointScaleFromOrigin,\n  pointsEqual,\n  triangleIncludesPoint,\n  vectorCross,\n  vectorFromPoint,\n  vectorScale,\n} from \"@excalidraw/math\";\n\nimport type {\n  LocalPoint,\n  GlobalPoint,\n  Triangle,\n  Vector,\n} from \"@excalidraw/math\";\n\nimport { getCenterForBounds, type Bounds } from \"./bounds\";\n\nimport type { ExcalidrawBindableElement } from \"./types\";\n\nexport const HEADING_RIGHT = [1, 0] as Heading;\nexport const HEADING_DOWN = [0, 1] as Heading;\nexport const HEADING_LEFT = [-1, 0] as Heading;\nexport const HEADING_UP = [0, -1] as Heading;\nexport type Heading = [1, 0] | [0, 1] | [-1, 0] | [0, -1];\n\nexport const vectorToHeading = (vec: Vector): Heading => {\n  const [x, y] = vec;\n  const absX = Math.abs(x);\n  const absY = Math.abs(y);\n  if (x > absY) {\n    return HEADING_RIGHT;\n  } else if (x <= -absY) {\n    return HEADING_LEFT;\n  } else if (y > absX) {\n    return HEADING_DOWN;\n  }\n  return HEADING_UP;\n};\n\nexport const headingForPoint = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  o: P,\n) => vectorToHeading(vectorFromPoint<P>(p, o));\n\nexport const headingForPointIsHorizontal = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  o: P,\n) => headingIsHorizontal(headingForPoint<P>(p, o));\n\nexport const compareHeading = (a: Heading, b: Heading) =>\n  a[0] === b[0] && a[1] === b[1];\n\nexport const headingIsHorizontal = (a: Heading) =>\n  compareHeading(a, HEADING_RIGHT) || compareHeading(a, HEADING_LEFT);\n\nexport const headingIsVertical = (a: Heading) => !headingIsHorizontal(a);\n\nconst headingForPointFromDiamondElement = (\n  element: Readonly<ExcalidrawBindableElement>,\n  aabb: Readonly<Bounds>,\n  point: Readonly<GlobalPoint>,\n): Heading => {\n  const midPoint = getCenterForBounds(aabb);\n\n  if (isDevEnv() || isTestEnv()) {\n    invariant(\n      element.width > 0 && element.height > 0,\n      \"Diamond element has no width or height\",\n    );\n    invariant(\n      !pointsEqual(midPoint, point),\n      \"The point is too close to the element mid point to determine heading\",\n    );\n  }\n\n  const SHRINK = 0.95; // Rounded elements tolerance\n  const top = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n  const right = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(\n            element.x + element.width,\n            element.y + element.height / 2,\n          ),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n  const bottom = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(\n            element.x + element.width / 2,\n            element.y + element.height,\n          ),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n  const left = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n\n  // Corners\n  if (\n    vectorCross(vectorFromPoint(point, top), vectorFromPoint(top, right)) <=\n      0 &&\n    vectorCross(vectorFromPoint(point, top), vectorFromPoint(top, left)) > 0\n  ) {\n    return headingForPoint(top, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, right),\n      vectorFromPoint(right, bottom),\n    ) <= 0 &&\n    vectorCross(vectorFromPoint(point, right), vectorFromPoint(right, top)) > 0\n  ) {\n    return headingForPoint(right, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, bottom),\n      vectorFromPoint(bottom, left),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, bottom),\n      vectorFromPoint(bottom, right),\n    ) > 0\n  ) {\n    return headingForPoint(bottom, midPoint);\n  } else if (\n    vectorCross(vectorFromPoint(point, left), vectorFromPoint(left, top)) <=\n      0 &&\n    vectorCross(vectorFromPoint(point, left), vectorFromPoint(left, bottom)) > 0\n  ) {\n    return headingForPoint(left, midPoint);\n  }\n\n  // Sides\n  if (\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(top, midPoint),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(right, midPoint),\n    ) > 0\n  ) {\n    const p = element.width > element.height ? top : right;\n    return headingForPoint(p, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(right, midPoint),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(bottom, midPoint),\n    ) > 0\n  ) {\n    const p = element.width > element.height ? bottom : right;\n    return headingForPoint(p, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(bottom, midPoint),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(left, midPoint),\n    ) > 0\n  ) {\n    const p = element.width > element.height ? bottom : left;\n    return headingForPoint(p, midPoint);\n  }\n\n  const p = element.width > element.height ? top : left;\n  return headingForPoint(p, midPoint);\n};\n\n// Gets the heading for the point by creating a bounding box around the rotated\n// close fitting bounding box, then creating 4 search cones around the center of\n// the external bbox.\nexport const headingForPointFromElement = <Point extends GlobalPoint>(\n  element: Readonly<ExcalidrawBindableElement>,\n  aabb: Readonly<Bounds>,\n  p: Readonly<Point>,\n): Heading => {\n  const SEARCH_CONE_MULTIPLIER = 2;\n\n  const midPoint = getCenterForBounds(aabb);\n\n  if (element.type === \"diamond\") {\n    return headingForPointFromDiamondElement(element, aabb, p);\n  }\n\n  const topLeft = pointScaleFromOrigin(\n    pointFrom(aabb[0], aabb[1]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n  const topRight = pointScaleFromOrigin(\n    pointFrom(aabb[2], aabb[1]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n  const bottomLeft = pointScaleFromOrigin(\n    pointFrom(aabb[0], aabb[3]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n  const bottomRight = pointScaleFromOrigin(\n    pointFrom(aabb[2], aabb[3]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n\n  return triangleIncludesPoint<Point>(\n    [topLeft, topRight, midPoint] as Triangle<Point>,\n    p,\n  )\n    ? HEADING_UP\n    : triangleIncludesPoint<Point>(\n        [topRight, bottomRight, midPoint] as Triangle<Point>,\n        p,\n      )\n    ? HEADING_RIGHT\n    : triangleIncludesPoint<Point>(\n        [bottomRight, bottomLeft, midPoint] as Triangle<Point>,\n        p,\n      )\n    ? HEADING_DOWN\n    : HEADING_LEFT;\n};\n\nexport const flipHeading = (h: Heading): Heading =>\n  [\n    h[0] === 0 ? 0 : h[0] > 0 ? -1 : 1,\n    h[1] === 0 ? 0 : h[1] > 0 ? -1 : 1,\n  ] as Heading;\n",
    "import {\n  getSizeFromPoints,\n  randomInteger,\n  getUpdatedTimestamp,\n} from \"@excalidraw/common\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport { ShapeCache } from \"./shape\";\n\nimport { updateElbowArrowPoints } from \"./elbowArrow\";\n\nimport { isElbowArrow } from \"./typeChecks\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawElement,\n  NonDeletedSceneElementsMap,\n} from \"./types\";\n\nexport type ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"updated\"\n>;\n\n/**\n * This function tracks updates of text elements for the purposes for collaboration.\n * The version is used to compare updates when more than one user is working in\n * the same drawing.\n *\n * WARNING: this won't trigger the component to update, so if you need to trigger component update,\n * use `scene.mutateElement` or `ExcalidrawImperativeAPI.mutateElement` instead.\n */\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  elementsMap: ElementsMap,\n  updates: ElementUpdate<TElement>,\n  options?: {\n    isDragging?: boolean;\n  },\n) => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points, fixedSegments, startBinding, endBinding, fileId } =\n    updates as any;\n\n  if (\n    isElbowArrow(element) &&\n    (Object.keys(updates).length === 0 || // normalization case\n      typeof points !== \"undefined\" || // repositioning\n      typeof fixedSegments !== \"undefined\" || // segment fixing\n      typeof startBinding !== \"undefined\" ||\n      typeof endBinding !== \"undefined\") // manual binding to element\n  ) {\n    updates = {\n      ...updates,\n      angle: 0 as Radians,\n      ...updateElbowArrowPoints(\n        {\n          ...element,\n          x: updates.x || element.x,\n          y: updates.y || element.y,\n        },\n        elementsMap as NonDeletedSceneElementsMap,\n        updates as ElementUpdate<ExcalidrawElbowArrowElement>,\n        options,\n      ),\n    };\n  } else if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update because its attrs could have changed\n        // (except for specific keys we handle below)\n        (typeof value !== \"object\" ||\n          value === null ||\n          key === \"groupIds\" ||\n          key === \"scale\")\n      ) {\n        continue;\n      }\n\n      if (key === \"scale\") {\n        const prevScale = (element as any)[key];\n        const nextScale = value;\n        if (prevScale[0] === nextScale[0] && prevScale[1] === nextScale[1]) {\n          continue;\n        }\n      } else if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n          while (--index) {\n            const prevPoint = prevPoints[index];\n            const nextPoint = nextPoints[index];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return element;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof fileId != \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    ShapeCache.delete(element);\n  }\n\n  element.version = updates.version ?? element.version + 1;\n  element.versionNonce = updates.versionNonce ?? randomInteger();\n  element.updated = getUpdatedTimestamp();\n\n  return element;\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n  /** pass `true` to always regenerate */\n  force = false,\n): TElement => {\n  let didChange = false;\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update because its attrs could have changed\n        (typeof value !== \"object\" || value === null)\n      ) {\n        continue;\n      }\n      didChange = true;\n    }\n  }\n\n  if (!didChange && !force) {\n    return element;\n  }\n\n  return {\n    ...element,\n    ...updates,\n    version: updates.version ?? element.version + 1,\n    versionNonce: updates.versionNonce ?? randomInteger(),\n    updated: getUpdatedTimestamp(),\n  };\n};\n\n/**\n * Mutates element, bumping `version`, `versionNonce`, and `updated`.\n *\n * NOTE: does not trigger re-render.\n */\nexport const bumpVersion = <T extends Mutable<ExcalidrawElement>>(\n  element: T,\n  version?: ExcalidrawElement[\"version\"],\n) => {\n  element.version = (version ?? element.version) + 1;\n  element.versionNonce = randomInteger();\n  element.updated = getUpdatedTimestamp();\n  return element;\n};\n",
    "import {\n  clamp,\n  pointDistance,\n  pointFrom,\n  pointScaleFromOrigin,\n  pointsEqual,\n  pointTranslate,\n  vector,\n  vectorCross,\n  vectorFromPoint,\n  vectorScale,\n  type GlobalPoint,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport {\n  BinaryHeap,\n  invariant,\n  isAnyTrue,\n  tupleToCoors,\n  getSizeFromPoints,\n  isDevEnv,\n  arrayToMap,\n} from \"@excalidraw/common\";\n\nimport type { AppState } from \"excalidraw-custom/types\";\n\nimport {\n  bindPointToSnapToElementOutline,\n  FIXED_BINDING_DISTANCE,\n  getHeadingForElbowArrowSnap,\n  getGlobalFixedPointForBindableElement,\n  getHoveredElementForBinding,\n} from \"./binding\";\nimport { distanceToElement } from \"./distance\";\nimport {\n  compareHeading,\n  flipHeading,\n  HEADING_DOWN,\n  HEADING_LEFT,\n  HEADING_RIGHT,\n  HEADING_UP,\n  headingForPointIsHorizontal,\n  headingIsHorizontal,\n  vectorToHeading,\n  headingForPoint,\n} from \"./heading\";\nimport { type ElementUpdate } from \"./mutateElement\";\nimport { isBindableElement } from \"./typeChecks\";\nimport {\n  type ExcalidrawElbowArrowElement,\n  type NonDeletedSceneElementsMap,\n} from \"./types\";\n\nimport { aabbForElement, pointInsideBounds } from \"./bounds\";\n\nimport type { Bounds } from \"./bounds\";\nimport type { Heading } from \"./heading\";\nimport type {\n  Arrowhead,\n  ElementsMap,\n  ExcalidrawBindableElement,\n  FixedPointBinding,\n  FixedSegment,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\ntype GridAddress = [number, number] & { _brand: \"gridaddress\" };\n\ntype Node = {\n  f: number;\n  g: number;\n  h: number;\n  closed: boolean;\n  visited: boolean;\n  parent: Node | null;\n  pos: GlobalPoint;\n  addr: GridAddress;\n};\n\ntype Grid = {\n  row: number;\n  col: number;\n  data: (Node | null)[];\n};\n\ntype ElbowArrowState = {\n  x: number;\n  y: number;\n  startBinding: FixedPointBinding | null;\n  endBinding: FixedPointBinding | null;\n  startArrowhead: Arrowhead | null;\n  endArrowhead: Arrowhead | null;\n};\n\ntype ElbowArrowData = {\n  dynamicAABBs: Bounds[];\n  startDonglePosition: GlobalPoint | null;\n  startGlobalPoint: GlobalPoint;\n  startHeading: Heading;\n  endDonglePosition: GlobalPoint | null;\n  endGlobalPoint: GlobalPoint;\n  endHeading: Heading;\n  commonBounds: Bounds;\n  hoveredStartElement: ExcalidrawBindableElement | null;\n  hoveredEndElement: ExcalidrawBindableElement | null;\n};\n\nconst DEDUP_TRESHOLD = 1;\nexport const BASE_PADDING = 40;\n\nconst handleSegmentRenormalization = (\n  arrow: ExcalidrawElbowArrowElement,\n  elementsMap: NonDeletedSceneElementsMap,\n) => {\n  const nextFixedSegments: FixedSegment[] | null = arrow.fixedSegments\n    ? arrow.fixedSegments.slice()\n    : null;\n\n  if (nextFixedSegments) {\n    const _nextPoints: GlobalPoint[] = [];\n\n    arrow.points\n      .map((p) => pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]))\n      .forEach((p, i, points) => {\n        if (i < 2) {\n          return _nextPoints.push(p);\n        }\n\n        const currentSegmentIsHorizontal = headingForPoint(p, points[i - 1]);\n        const prevSegmentIsHorizontal = headingForPoint(\n          points[i - 1],\n          points[i - 2],\n        );\n\n        if (\n          // Check if previous two points are on the same line\n          compareHeading(currentSegmentIsHorizontal, prevSegmentIsHorizontal)\n        ) {\n          const prevSegmentIdx =\n            nextFixedSegments?.findIndex(\n              (segment) => segment.index === i - 1,\n            ) ?? -1;\n          const segmentIdx =\n            nextFixedSegments?.findIndex((segment) => segment.index === i) ??\n            -1;\n\n          // If the current segment is a fixed segment, update its start point\n          if (segmentIdx !== -1) {\n            nextFixedSegments[segmentIdx].start = pointFrom<LocalPoint>(\n              points[i - 2][0] - arrow.x,\n              points[i - 2][1] - arrow.y,\n            );\n          }\n\n          // Remove the fixed segment status from the previous segment if it is\n          // a fixed segment, because we are going to unify that segment with\n          // the current one\n          if (prevSegmentIdx !== -1) {\n            nextFixedSegments.splice(prevSegmentIdx, 1);\n          }\n\n          // Remove the duplicate point\n          _nextPoints.splice(-1, 1);\n\n          // Update fixed point indices\n          nextFixedSegments.forEach((segment) => {\n            if (segment.index > i - 1) {\n              segment.index -= 1;\n            }\n          });\n        }\n\n        return _nextPoints.push(p);\n      });\n\n    const nextPoints: GlobalPoint[] = [];\n\n    _nextPoints.forEach((p, i, points) => {\n      if (i < 3) {\n        return nextPoints.push(p);\n      }\n\n      if (\n        // Remove segments that are too short\n        pointDistance(points[i - 2], points[i - 1]) < DEDUP_TRESHOLD\n      ) {\n        const prevPrevSegmentIdx =\n          nextFixedSegments?.findIndex((segment) => segment.index === i - 2) ??\n          -1;\n        const prevSegmentIdx =\n          nextFixedSegments?.findIndex((segment) => segment.index === i - 1) ??\n          -1;\n\n        // Remove the previous fixed segment if it exists (i.e. the segment\n        // which will be removed due to being parallel or too short)\n        if (prevSegmentIdx !== -1) {\n          nextFixedSegments.splice(prevSegmentIdx, 1);\n        }\n\n        // Remove the fixed segment status from the segment 2 steps back\n        // if it is a fixed segment, because we are going to unify that\n        // segment with the current one\n        if (prevPrevSegmentIdx !== -1) {\n          nextFixedSegments.splice(prevPrevSegmentIdx, 1);\n        }\n\n        nextPoints.splice(-2, 2);\n\n        // Since we have to remove two segments, update any fixed segment\n        nextFixedSegments.forEach((segment) => {\n          if (segment.index > i - 2) {\n            segment.index -= 2;\n          }\n        });\n\n        // Remove aligned segment points\n        const isHorizontal = headingForPointIsHorizontal(p, points[i - 1]);\n\n        return nextPoints.push(\n          pointFrom<GlobalPoint>(\n            !isHorizontal ? points[i - 2][0] : p[0],\n            isHorizontal ? points[i - 2][1] : p[1],\n          ),\n        );\n      }\n\n      nextPoints.push(p);\n    });\n\n    const filteredNextFixedSegments = nextFixedSegments.filter(\n      (segment) =>\n        segment.index !== 1 && segment.index !== nextPoints.length - 1,\n    );\n    if (filteredNextFixedSegments.length === 0) {\n      return normalizeArrowElementUpdate(\n        getElbowArrowCornerPoints(\n          removeElbowArrowShortSegments(\n            routeElbowArrow(\n              arrow,\n              getElbowArrowData(\n                arrow,\n                elementsMap,\n                nextPoints.map((p) =>\n                  pointFrom<LocalPoint>(p[0] - arrow.x, p[1] - arrow.y),\n                ),\n              ),\n            ) ?? [],\n          ),\n        ),\n        filteredNextFixedSegments,\n        null,\n        null,\n      );\n    }\n\n    isDevEnv() &&\n      invariant(\n        validateElbowPoints(nextPoints),\n        \"Invalid elbow points with fixed segments\",\n      );\n\n    return normalizeArrowElementUpdate(\n      nextPoints,\n      filteredNextFixedSegments,\n      arrow.startIsSpecial,\n      arrow.endIsSpecial,\n    );\n  }\n\n  return {\n    x: arrow.x,\n    y: arrow.y,\n    points: arrow.points,\n    fixedSegments: arrow.fixedSegments,\n    startIsSpecial: arrow.startIsSpecial,\n    endIsSpecial: arrow.endIsSpecial,\n  };\n};\n\nconst handleSegmentRelease = (\n  arrow: ExcalidrawElbowArrowElement,\n  fixedSegments: readonly FixedSegment[],\n  elementsMap: NonDeletedSceneElementsMap,\n) => {\n  const newFixedSegmentIndices = fixedSegments.map((segment) => segment.index);\n  const oldFixedSegmentIndices =\n    arrow.fixedSegments?.map((segment) => segment.index) ?? [];\n  const deletedSegmentIdx = oldFixedSegmentIndices.findIndex(\n    (idx) => !newFixedSegmentIndices.includes(idx),\n  );\n\n  if (deletedSegmentIdx === -1 || !arrow.fixedSegments?.[deletedSegmentIdx]) {\n    return {\n      points: arrow.points,\n    };\n  }\n\n  const deletedIdx = arrow.fixedSegments[deletedSegmentIdx].index;\n\n  // Find prev and next fixed segments\n  const prevSegment = arrow.fixedSegments[deletedSegmentIdx - 1];\n  const nextSegment = arrow.fixedSegments[deletedSegmentIdx + 1];\n\n  // We need to render a sub-arrow path to restore deleted segments\n  const x = arrow.x + (prevSegment ? prevSegment.end[0] : 0);\n  const y = arrow.y + (prevSegment ? prevSegment.end[1] : 0);\n  const startBinding = prevSegment ? null : arrow.startBinding;\n  const endBinding = nextSegment ? null : arrow.endBinding;\n  const {\n    startHeading,\n    endHeading,\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    hoveredEndElement,\n    ...rest\n  } = getElbowArrowData(\n    {\n      x,\n      y,\n      startBinding,\n      endBinding,\n      startArrowhead: null,\n      endArrowhead: null,\n      points: arrow.points,\n    },\n    elementsMap,\n    [\n      pointFrom<LocalPoint>(0, 0),\n      pointFrom<LocalPoint>(\n        arrow.x +\n          (nextSegment?.start[0] ?? arrow.points[arrow.points.length - 1][0]) -\n          x,\n        arrow.y +\n          (nextSegment?.start[1] ?? arrow.points[arrow.points.length - 1][1]) -\n          y,\n      ),\n    ],\n    { isDragging: false },\n  );\n\n  const { points: restoredPoints } = normalizeArrowElementUpdate(\n    getElbowArrowCornerPoints(\n      removeElbowArrowShortSegments(\n        routeElbowArrow(arrow, {\n          startHeading,\n          endHeading,\n          startGlobalPoint,\n          endGlobalPoint,\n          hoveredStartElement,\n          hoveredEndElement,\n          ...rest,\n        }) ?? [],\n      ),\n    ),\n    fixedSegments,\n    null,\n    null,\n  );\n\n  const nextPoints: GlobalPoint[] = [];\n\n  // First part of the arrow are the old points\n  if (prevSegment) {\n    for (let i = 0; i < prevSegment.index; i++) {\n      nextPoints.push(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[i][0],\n          arrow.y + arrow.points[i][1],\n        ),\n      );\n    }\n  }\n\n  restoredPoints.forEach((p) => {\n    nextPoints.push(\n      pointFrom<GlobalPoint>(\n        arrow.x + (prevSegment ? prevSegment.end[0] : 0) + p[0],\n        arrow.y + (prevSegment ? prevSegment.end[1] : 0) + p[1],\n      ),\n    );\n  });\n\n  // Last part of the arrow are the old points too\n  if (nextSegment) {\n    for (let i = nextSegment.index; i < arrow.points.length; i++) {\n      nextPoints.push(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[i][0],\n          arrow.y + arrow.points[i][1],\n        ),\n      );\n    }\n  }\n\n  // Update nextFixedSegments\n  const originalSegmentCountDiff =\n    (nextSegment?.index ?? arrow.points.length) - (prevSegment?.index ?? 0) - 1;\n\n  const nextFixedSegments = fixedSegments.map((segment) => {\n    if (segment.index > deletedIdx) {\n      return {\n        ...segment,\n        index:\n          segment.index -\n          originalSegmentCountDiff +\n          (restoredPoints.length - 1),\n      };\n    }\n\n    return segment;\n  });\n\n  const simplifiedPoints = nextPoints.flatMap((p, i) => {\n    const prev = nextPoints[i - 1];\n    const next = nextPoints[i + 1];\n\n    if (prev && next) {\n      const prevHeading = headingForPoint(p, prev);\n      const nextHeading = headingForPoint(next, p);\n\n      if (compareHeading(prevHeading, nextHeading)) {\n        // Update subsequent fixed segment indices\n        nextFixedSegments.forEach((segment) => {\n          if (segment.index > i) {\n            segment.index -= 1;\n          }\n        });\n\n        return [];\n      } else if (compareHeading(prevHeading, flipHeading(nextHeading))) {\n        // Update subsequent fixed segment indices\n        nextFixedSegments.forEach((segment) => {\n          if (segment.index > i) {\n            segment.index += 1;\n          }\n        });\n\n        return [p, p];\n      }\n    }\n\n    return [p];\n  });\n\n  return normalizeArrowElementUpdate(\n    simplifiedPoints,\n    nextFixedSegments,\n    false,\n    false,\n  );\n};\n\n/**\n *\n */\nconst handleSegmentMove = (\n  arrow: ExcalidrawElbowArrowElement,\n  fixedSegments: readonly FixedSegment[],\n  startHeading: Heading,\n  endHeading: Heading,\n  hoveredStartElement: ExcalidrawBindableElement | null,\n  hoveredEndElement: ExcalidrawBindableElement | null,\n): ElementUpdate<ExcalidrawElbowArrowElement> => {\n  const activelyModifiedSegmentIdx = fixedSegments\n    .map((segment, i) => {\n      if (\n        arrow.fixedSegments == null ||\n        arrow.fixedSegments[i] === undefined ||\n        arrow.fixedSegments[i].index !== segment.index\n      ) {\n        return i;\n      }\n\n      return (segment.start[0] !== arrow.fixedSegments![i].start[0] &&\n        segment.end[0] !== arrow.fixedSegments![i].end[0]) !==\n        (segment.start[1] !== arrow.fixedSegments![i].start[1] &&\n          segment.end[1] !== arrow.fixedSegments![i].end[1])\n        ? i\n        : null;\n    })\n    .filter((idx) => idx !== null)\n    .shift();\n\n  if (activelyModifiedSegmentIdx == null) {\n    return { points: arrow.points };\n  }\n\n  const firstSegmentIdx =\n    arrow.fixedSegments?.findIndex((segment) => segment.index === 1) ?? -1;\n  const lastSegmentIdx =\n    arrow.fixedSegments?.findIndex(\n      (segment) => segment.index === arrow.points.length - 1,\n    ) ?? -1;\n\n  // Handle special case for first segment move\n  const segmentLength = pointDistance(\n    fixedSegments[activelyModifiedSegmentIdx].start,\n    fixedSegments[activelyModifiedSegmentIdx].end,\n  );\n  const segmentIsTooShort = segmentLength < BASE_PADDING + 5;\n  if (\n    firstSegmentIdx === -1 &&\n    fixedSegments[activelyModifiedSegmentIdx].index === 1 &&\n    hoveredStartElement\n  ) {\n    const startIsHorizontal = headingIsHorizontal(startHeading);\n    const startIsPositive = startIsHorizontal\n      ? compareHeading(startHeading, HEADING_RIGHT)\n      : compareHeading(startHeading, HEADING_DOWN);\n    const padding = startIsPositive\n      ? segmentIsTooShort\n        ? segmentLength / 2\n        : BASE_PADDING\n      : segmentIsTooShort\n      ? -segmentLength / 2\n      : -BASE_PADDING;\n    fixedSegments[activelyModifiedSegmentIdx].start = pointFrom<LocalPoint>(\n      fixedSegments[activelyModifiedSegmentIdx].start[0] +\n        (startIsHorizontal ? padding : 0),\n      fixedSegments[activelyModifiedSegmentIdx].start[1] +\n        (!startIsHorizontal ? padding : 0),\n    );\n  }\n\n  // Handle special case for last segment move\n  if (\n    lastSegmentIdx === -1 &&\n    fixedSegments[activelyModifiedSegmentIdx].index ===\n      arrow.points.length - 1 &&\n    hoveredEndElement\n  ) {\n    const endIsHorizontal = headingIsHorizontal(endHeading);\n    const endIsPositive = endIsHorizontal\n      ? compareHeading(endHeading, HEADING_RIGHT)\n      : compareHeading(endHeading, HEADING_DOWN);\n    const padding = endIsPositive\n      ? segmentIsTooShort\n        ? segmentLength / 2\n        : BASE_PADDING\n      : segmentIsTooShort\n      ? -segmentLength / 2\n      : -BASE_PADDING;\n    fixedSegments[activelyModifiedSegmentIdx].end = pointFrom<LocalPoint>(\n      fixedSegments[activelyModifiedSegmentIdx].end[0] +\n        (endIsHorizontal ? padding : 0),\n      fixedSegments[activelyModifiedSegmentIdx].end[1] +\n        (!endIsHorizontal ? padding : 0),\n    );\n  }\n\n  // Translate all fixed segments to global coordinates\n  const nextFixedSegments = fixedSegments.map((segment) => ({\n    ...segment,\n    start: pointFrom<GlobalPoint>(\n      arrow.x + segment.start[0],\n      arrow.y + segment.start[1],\n    ),\n    end: pointFrom<GlobalPoint>(\n      arrow.x + segment.end[0],\n      arrow.y + segment.end[1],\n    ),\n  }));\n\n  // For start, clone old arrow points\n  const newPoints: GlobalPoint[] = arrow.points.map((p, i) =>\n    pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]),\n  );\n\n  const startIdx = nextFixedSegments[activelyModifiedSegmentIdx].index - 1;\n  const endIdx = nextFixedSegments[activelyModifiedSegmentIdx].index;\n  const start = nextFixedSegments[activelyModifiedSegmentIdx].start;\n  const end = nextFixedSegments[activelyModifiedSegmentIdx].end;\n  const prevSegmentIsHorizontal =\n    newPoints[startIdx - 1] &&\n    !pointsEqual(newPoints[startIdx], newPoints[startIdx - 1])\n      ? headingForPointIsHorizontal(\n          newPoints[startIdx - 1],\n          newPoints[startIdx],\n        )\n      : undefined;\n  const nextSegmentIsHorizontal =\n    newPoints[endIdx + 1] &&\n    !pointsEqual(newPoints[endIdx], newPoints[endIdx + 1])\n      ? headingForPointIsHorizontal(newPoints[endIdx + 1], newPoints[endIdx])\n      : undefined;\n\n  // Override the segment points with the actively moved fixed segment\n  if (prevSegmentIsHorizontal !== undefined) {\n    const dir = prevSegmentIsHorizontal ? 1 : 0;\n    newPoints[startIdx - 1][dir] = start[dir];\n  }\n  newPoints[startIdx] = start;\n  newPoints[endIdx] = end;\n  if (nextSegmentIsHorizontal !== undefined) {\n    const dir = nextSegmentIsHorizontal ? 1 : 0;\n    newPoints[endIdx + 1][dir] = end[dir];\n  }\n\n  // Override neighboring fixedSegment start/end points, if any\n  const prevSegmentIdx = nextFixedSegments.findIndex(\n    (segment) => segment.index === startIdx,\n  );\n  if (prevSegmentIdx !== -1) {\n    // Align the next segment points with the moved segment\n    const dir = headingForPointIsHorizontal(\n      nextFixedSegments[prevSegmentIdx].end,\n      nextFixedSegments[prevSegmentIdx].start,\n    )\n      ? 1\n      : 0;\n    nextFixedSegments[prevSegmentIdx].start[dir] = start[dir];\n    nextFixedSegments[prevSegmentIdx].end = start;\n  }\n\n  const nextSegmentIdx = nextFixedSegments.findIndex(\n    (segment) => segment.index === endIdx + 1,\n  );\n  if (nextSegmentIdx !== -1) {\n    // Align the next segment points with the moved segment\n    const dir = headingForPointIsHorizontal(\n      nextFixedSegments[nextSegmentIdx].end,\n      nextFixedSegments[nextSegmentIdx].start,\n    )\n      ? 1\n      : 0;\n    nextFixedSegments[nextSegmentIdx].end[dir] = end[dir];\n    nextFixedSegments[nextSegmentIdx].start = end;\n  }\n\n  // First segment move needs an additional segment\n  if (firstSegmentIdx === -1 && startIdx === 0) {\n    const startIsHorizontal = hoveredStartElement\n      ? headingIsHorizontal(startHeading)\n      : headingForPointIsHorizontal(newPoints[1], newPoints[0]);\n    newPoints.unshift(\n      pointFrom<GlobalPoint>(\n        startIsHorizontal ? start[0] : arrow.x + arrow.points[0][0],\n        !startIsHorizontal ? start[1] : arrow.y + arrow.points[0][1],\n      ),\n    );\n\n    if (hoveredStartElement) {\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[0][0],\n          arrow.y + arrow.points[0][1],\n        ),\n      );\n    }\n\n    for (const segment of nextFixedSegments) {\n      segment.index += hoveredStartElement ? 2 : 1;\n    }\n  }\n\n  // Last segment move needs an additional segment\n  if (lastSegmentIdx === -1 && endIdx === arrow.points.length - 1) {\n    const endIsHorizontal = headingIsHorizontal(endHeading);\n    newPoints.push(\n      pointFrom<GlobalPoint>(\n        endIsHorizontal\n          ? end[0]\n          : arrow.x + arrow.points[arrow.points.length - 1][0],\n        !endIsHorizontal\n          ? end[1]\n          : arrow.y + arrow.points[arrow.points.length - 1][1],\n      ),\n    );\n    if (hoveredEndElement) {\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[arrow.points.length - 1][0],\n          arrow.y + arrow.points[arrow.points.length - 1][1],\n        ),\n      );\n    }\n  }\n\n  return normalizeArrowElementUpdate(\n    newPoints,\n    nextFixedSegments.map((segment) => ({\n      ...segment,\n      start: pointFrom<LocalPoint>(\n        segment.start[0] - arrow.x,\n        segment.start[1] - arrow.y,\n      ),\n      end: pointFrom<LocalPoint>(\n        segment.end[0] - arrow.x,\n        segment.end[1] - arrow.y,\n      ),\n    })),\n    false, // If you move a segment, there is no special point anymore\n    false, // If you move a segment, there is no special point anymore\n  );\n};\n\nconst handleEndpointDrag = (\n  arrow: ExcalidrawElbowArrowElement,\n  updatedPoints: readonly LocalPoint[],\n  fixedSegments: readonly FixedSegment[],\n  startHeading: Heading,\n  endHeading: Heading,\n  startGlobalPoint: GlobalPoint,\n  endGlobalPoint: GlobalPoint,\n  hoveredStartElement: ExcalidrawBindableElement | null,\n  hoveredEndElement: ExcalidrawBindableElement | null,\n) => {\n  let startIsSpecial = arrow.startIsSpecial ?? null;\n  let endIsSpecial = arrow.endIsSpecial ?? null;\n  const globalUpdatedPoints = updatedPoints.map((p, i) =>\n    i === 0\n      ? pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1])\n      : i === updatedPoints.length - 1\n      ? pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1])\n      : pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[i][0],\n          arrow.y + arrow.points[i][1],\n        ),\n  );\n  const nextFixedSegments = fixedSegments.map((segment) => ({\n    ...segment,\n    start: pointFrom<GlobalPoint>(\n      arrow.x + (segment.start[0] - updatedPoints[0][0]),\n      arrow.y + (segment.start[1] - updatedPoints[0][1]),\n    ),\n    end: pointFrom<GlobalPoint>(\n      arrow.x + (segment.end[0] - updatedPoints[0][0]),\n      arrow.y + (segment.end[1] - updatedPoints[0][1]),\n    ),\n  }));\n  const newPoints: GlobalPoint[] = [];\n\n  // Add the inside points\n  const offset = 2 + (startIsSpecial ? 1 : 0);\n  const endOffset = 2 + (endIsSpecial ? 1 : 0);\n  while (newPoints.length + offset < globalUpdatedPoints.length - endOffset) {\n    newPoints.push(globalUpdatedPoints[newPoints.length + offset]);\n  }\n\n  // Calculate the moving second point connection and add the start point\n  {\n    const secondPoint = globalUpdatedPoints[startIsSpecial ? 2 : 1];\n    const thirdPoint = globalUpdatedPoints[startIsSpecial ? 3 : 2];\n    const startIsHorizontal = headingIsHorizontal(startHeading);\n    const secondIsHorizontal = headingIsHorizontal(\n      vectorToHeading(vectorFromPoint(secondPoint, thirdPoint)),\n    );\n\n    if (hoveredStartElement && startIsHorizontal === secondIsHorizontal) {\n      const positive = startIsHorizontal\n        ? compareHeading(startHeading, HEADING_RIGHT)\n        : compareHeading(startHeading, HEADING_DOWN);\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal\n            ? thirdPoint[0]\n            : startGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING),\n          secondIsHorizontal\n            ? thirdPoint[1]\n            : startGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING),\n        ),\n      );\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          startIsHorizontal\n            ? startGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : startGlobalPoint[0],\n          !startIsHorizontal\n            ? startGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : startGlobalPoint[1],\n        ),\n      );\n      if (!startIsSpecial) {\n        startIsSpecial = true;\n        for (const segment of nextFixedSegments) {\n          if (segment.index > 1) {\n            segment.index += 1;\n          }\n        }\n      }\n    } else {\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal ? secondPoint[0] : startGlobalPoint[0],\n          secondIsHorizontal ? secondPoint[1] : startGlobalPoint[1],\n        ),\n      );\n      if (startIsSpecial) {\n        startIsSpecial = false;\n        for (const segment of nextFixedSegments) {\n          if (segment.index > 1) {\n            segment.index -= 1;\n          }\n        }\n      }\n    }\n    newPoints.unshift(startGlobalPoint);\n  }\n\n  // Calculate the moving second to last point connection\n  {\n    const secondToLastPoint =\n      globalUpdatedPoints[globalUpdatedPoints.length - (endIsSpecial ? 3 : 2)];\n    const thirdToLastPoint =\n      globalUpdatedPoints[globalUpdatedPoints.length - (endIsSpecial ? 4 : 3)];\n    const endIsHorizontal = headingIsHorizontal(endHeading);\n    const secondIsHorizontal = headingForPointIsHorizontal(\n      thirdToLastPoint,\n      secondToLastPoint,\n    );\n    if (hoveredEndElement && endIsHorizontal === secondIsHorizontal) {\n      const positive = endIsHorizontal\n        ? compareHeading(endHeading, HEADING_RIGHT)\n        : compareHeading(endHeading, HEADING_DOWN);\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal\n            ? thirdToLastPoint[0]\n            : endGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING),\n          secondIsHorizontal\n            ? thirdToLastPoint[1]\n            : endGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING),\n        ),\n      );\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          endIsHorizontal\n            ? endGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : endGlobalPoint[0],\n          !endIsHorizontal\n            ? endGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : endGlobalPoint[1],\n        ),\n      );\n      if (!endIsSpecial) {\n        endIsSpecial = true;\n      }\n    } else {\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal ? secondToLastPoint[0] : endGlobalPoint[0],\n          secondIsHorizontal ? secondToLastPoint[1] : endGlobalPoint[1],\n        ),\n      );\n      if (endIsSpecial) {\n        endIsSpecial = false;\n      }\n    }\n  }\n\n  newPoints.push(endGlobalPoint);\n\n  return normalizeArrowElementUpdate(\n    newPoints,\n    nextFixedSegments\n      .map(({ index }) => ({\n        index,\n        start: newPoints[index - 1],\n        end: newPoints[index],\n      }))\n      .map((segment) => ({\n        ...segment,\n        start: pointFrom<LocalPoint>(\n          segment.start[0] - startGlobalPoint[0],\n          segment.start[1] - startGlobalPoint[1],\n        ),\n        end: pointFrom<LocalPoint>(\n          segment.end[0] - startGlobalPoint[0],\n          segment.end[1] - startGlobalPoint[1],\n        ),\n      })),\n    startIsSpecial,\n    endIsSpecial,\n  );\n};\n\nconst MAX_POS = 1e6;\n\n/**\n *\n */\nexport const updateElbowArrowPoints = (\n  arrow: Readonly<ExcalidrawElbowArrowElement>,\n  elementsMap: NonDeletedSceneElementsMap,\n  updates: {\n    points?: readonly LocalPoint[];\n    fixedSegments?: readonly FixedSegment[] | null;\n    startBinding?: FixedPointBinding | null;\n    endBinding?: FixedPointBinding | null;\n  },\n  options?: {\n    isDragging?: boolean;\n  },\n): ElementUpdate<ExcalidrawElbowArrowElement> => {\n  if (arrow.points.length < 2) {\n    return { points: updates.points ?? arrow.points };\n  }\n\n  if (!import.meta.env.PROD) {\n    invariant(\n      !updates.points || updates.points.length >= 2,\n      \"Updated point array length must match the arrow point length, contain \" +\n        \"exactly the new start and end points or not be specified at all (i.e. \" +\n        \"you can't add new points between start and end manually to elbow arrows)\",\n    );\n\n    invariant(\n      !arrow.fixedSegments ||\n        arrow.fixedSegments\n          .map((s) => s.start[0] === s.end[0] || s.start[1] === s.end[1])\n          .every(Boolean),\n      \"Fixed segments must be either horizontal or vertical\",\n    );\n\n    invariant(\n      !updates.fixedSegments ||\n        updates.fixedSegments\n          .map((s) => s.start[0] === s.end[0] || s.start[1] === s.end[1])\n          .every(Boolean),\n      \"Updates to fixed segments must be either horizontal or vertical\",\n    );\n\n    invariant(\n      arrow.points\n        .slice(1)\n        .map(\n          (p, i) => p[0] === arrow.points[i][0] || p[1] === arrow.points[i][1],\n        ),\n      \"Elbow arrow segments must be either horizontal or vertical\",\n    );\n\n    invariant(\n      updates.fixedSegments?.find(\n        (segment) =>\n          segment.index === 1 &&\n          pointsEqual(segment.start, (updates.points ?? arrow.points)[0]),\n      ) == null &&\n        updates.fixedSegments?.find(\n          (segment) =>\n            segment.index === (updates.points ?? arrow.points).length - 1 &&\n            pointsEqual(\n              segment.end,\n              (updates.points ?? arrow.points)[\n                (updates.points ?? arrow.points).length - 1\n              ],\n            ),\n        ) == null,\n      \"The first and last segments cannot be fixed\",\n    );\n  }\n\n  const fixedSegments = updates.fixedSegments ?? arrow.fixedSegments ?? [];\n\n  const updatedPoints: readonly LocalPoint[] = updates.points\n    ? updates.points && updates.points.length === 2\n      ? arrow.points.map((p, idx) =>\n          idx === 0\n            ? updates.points![0]\n            : idx === arrow.points.length - 1\n            ? updates.points![1]\n            : p,\n        )\n      : updates.points.slice()\n    : arrow.points.slice();\n\n  // During all element replacement in the scene, we just need to renormalize\n  // the arrow\n  // TODO (dwelle,mtolmacs): Remove this once Scene.getScene() is removed\n  const {\n    startBinding: updatedStartBinding,\n    endBinding: updatedEndBinding,\n    ...restOfTheUpdates\n  } = updates;\n  const startBinding =\n    typeof updatedStartBinding !== \"undefined\"\n      ? updatedStartBinding\n      : arrow.startBinding;\n  const endBinding =\n    typeof updatedEndBinding !== \"undefined\"\n      ? updatedEndBinding\n      : arrow.endBinding;\n  const startElement =\n    startBinding &&\n    getBindableElementForId(startBinding.elementId, elementsMap);\n  const endElement =\n    endBinding && getBindableElementForId(endBinding.elementId, elementsMap);\n  const areUpdatedPointsValid = validateElbowPoints(updatedPoints);\n\n  if (\n    (startBinding && !startElement && areUpdatedPointsValid) ||\n    (endBinding && !endElement && areUpdatedPointsValid) ||\n    (elementsMap.size === 0 && areUpdatedPointsValid) ||\n    (Object.keys(restOfTheUpdates).length === 0 &&\n      (startElement?.id !== startBinding?.elementId ||\n        endElement?.id !== endBinding?.elementId))\n  ) {\n    return normalizeArrowElementUpdate(\n      updatedPoints.map((p) =>\n        pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]),\n      ),\n      arrow.fixedSegments,\n      arrow.startIsSpecial,\n      arrow.endIsSpecial,\n    );\n  }\n\n  const {\n    startHeading,\n    endHeading,\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    hoveredEndElement,\n    ...rest\n  } = getElbowArrowData(\n    {\n      x: arrow.x,\n      y: arrow.y,\n      startBinding,\n      endBinding,\n      startArrowhead: arrow.startArrowhead,\n      endArrowhead: arrow.endArrowhead,\n      points: arrow.points,\n    },\n    elementsMap,\n    updatedPoints,\n    options,\n  );\n\n  // 0. During all element replacement in the scene, we just need to renormalize\n  // the arrow\n  // TODO (dwelle,mtolmacs): Remove this once Scene.getScene() is removed\n  if (elementsMap.size === 0 && areUpdatedPointsValid) {\n    return normalizeArrowElementUpdate(\n      updatedPoints.map((p) =>\n        pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]),\n      ),\n      arrow.fixedSegments,\n      arrow.startIsSpecial,\n      arrow.endIsSpecial,\n    );\n  }\n\n  ////\n  // 1. Renormalize the arrow\n  ////\n  if (\n    !updates.points &&\n    !updates.fixedSegments &&\n    !updates.startBinding &&\n    !updates.endBinding\n  ) {\n    return handleSegmentRenormalization(arrow, elementsMap);\n  }\n\n  // Short circuit on no-op to avoid huge performance hit\n  if (\n    updates.startBinding === arrow.startBinding &&\n    updates.endBinding === arrow.endBinding &&\n    (updates.points ?? []).every((p, i) =>\n      pointsEqual(\n        p,\n        arrow.points[i] ?? pointFrom<LocalPoint>(Infinity, Infinity),\n      ),\n    ) &&\n    areUpdatedPointsValid\n  ) {\n    return {};\n  }\n\n  ////\n  // 2. Just normal elbow arrow things\n  ////\n  if (fixedSegments.length === 0) {\n    return normalizeArrowElementUpdate(\n      getElbowArrowCornerPoints(\n        removeElbowArrowShortSegments(\n          routeElbowArrow(arrow, {\n            startHeading,\n            endHeading,\n            startGlobalPoint,\n            endGlobalPoint,\n            hoveredStartElement,\n            hoveredEndElement,\n            ...rest,\n          }) ?? [],\n        ),\n      ),\n      fixedSegments,\n      null,\n      null,\n    );\n  }\n\n  ////\n  // 3. Handle releasing a fixed segment\n  if ((arrow.fixedSegments?.length ?? 0) > fixedSegments.length) {\n    return handleSegmentRelease(arrow, fixedSegments, elementsMap);\n  }\n\n  ////\n  // 4. Handle manual segment move\n  ////\n  if (!updates.points) {\n    return handleSegmentMove(\n      arrow,\n      fixedSegments,\n      startHeading,\n      endHeading,\n      hoveredStartElement,\n      hoveredEndElement,\n    );\n  }\n\n  ////\n  // 5. Handle resize\n  ////\n  if (updates.points && updates.fixedSegments) {\n    return updates;\n  }\n\n  ////\n  // 6. One or more segments are fixed and endpoints are moved\n  //\n  // The key insights are:\n  // - When segments are fixed, the arrow will keep the exact amount of segments\n  // - Fixed segments are \"replacements\" for exactly one segment in the old arrow\n  ////\n  return handleEndpointDrag(\n    arrow,\n    updatedPoints,\n    fixedSegments,\n    startHeading,\n    endHeading,\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    hoveredEndElement,\n  );\n};\n\n/**\n * Retrieves data necessary for calculating the elbow arrow path.\n *\n * @param arrow - The arrow object containing its properties.\n * @param elementsMap - A map of elements in the scene.\n * @param nextPoints - The next set of points for the arrow.\n * @param options - Optional parameters for the calculation.\n * @param options.isDragging - Indicates if the arrow is being dragged.\n * @param options.startIsMidPoint - Indicates if the start point is a midpoint.\n * @param options.endIsMidPoint - Indicates if the end point is a midpoint.\n *\n * @returns An object containing various properties needed for elbow arrow calculations:\n * - dynamicAABBs: Dynamically generated axis-aligned bounding boxes.\n * - startDonglePosition: The position of the start dongle.\n * - startGlobalPoint: The global coordinates of the start point.\n * - startHeading: The heading direction from the start point.\n * - endDonglePosition: The position of the end dongle.\n * - endGlobalPoint: The global coordinates of the end point.\n * - endHeading: The heading direction from the end point.\n * - commonBounds: The common bounding box that encompasses both start and end points.\n * - hoveredStartElement: The element being hovered over at the start point.\n * - hoveredEndElement: The element being hovered over at the end point.\n */\nconst getElbowArrowData = (\n  arrow: {\n    x: number;\n    y: number;\n    startBinding: FixedPointBinding | null;\n    endBinding: FixedPointBinding | null;\n    startArrowhead: Arrowhead | null;\n    endArrowhead: Arrowhead | null;\n    points: readonly LocalPoint[];\n  },\n  elementsMap: NonDeletedSceneElementsMap,\n  nextPoints: readonly LocalPoint[],\n  options?: {\n    isDragging?: boolean;\n    zoom?: AppState[\"zoom\"];\n  },\n) => {\n  const origStartGlobalPoint: GlobalPoint = pointTranslate<\n    LocalPoint,\n    GlobalPoint\n  >(nextPoints[0], vector(arrow.x, arrow.y));\n  const origEndGlobalPoint: GlobalPoint = pointTranslate<\n    LocalPoint,\n    GlobalPoint\n  >(nextPoints[nextPoints.length - 1], vector(arrow.x, arrow.y));\n\n  let hoveredStartElement = null;\n  let hoveredEndElement = null;\n  if (options?.isDragging) {\n    const elements = Array.from(elementsMap.values());\n    hoveredStartElement =\n      getHoveredElement(\n        origStartGlobalPoint,\n        elementsMap,\n        elements,\n        options?.zoom,\n      ) || null;\n    hoveredEndElement =\n      getHoveredElement(\n        origEndGlobalPoint,\n        elementsMap,\n        elements,\n        options?.zoom,\n      ) || null;\n  } else {\n    hoveredStartElement = arrow.startBinding\n      ? getBindableElementForId(arrow.startBinding.elementId, elementsMap) ||\n        null\n      : null;\n    hoveredEndElement = arrow.endBinding\n      ? getBindableElementForId(arrow.endBinding.elementId, elementsMap) || null\n      : null;\n  }\n\n  const startGlobalPoint = getGlobalPoint(\n    {\n      ...arrow,\n      type: \"arrow\",\n      elbowed: true,\n      points: nextPoints,\n    } as ExcalidrawElbowArrowElement,\n    \"start\",\n    arrow.startBinding?.fixedPoint,\n    origStartGlobalPoint,\n    hoveredStartElement,\n    elementsMap,\n    options?.isDragging,\n  );\n  const endGlobalPoint = getGlobalPoint(\n    {\n      ...arrow,\n      type: \"arrow\",\n      elbowed: true,\n      points: nextPoints,\n    } as ExcalidrawElbowArrowElement,\n    \"end\",\n    arrow.endBinding?.fixedPoint,\n    origEndGlobalPoint,\n    hoveredEndElement,\n    elementsMap,\n    options?.isDragging,\n  );\n  const startHeading = getBindPointHeading(\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    origStartGlobalPoint,\n    elementsMap,\n  );\n  const endHeading = getBindPointHeading(\n    endGlobalPoint,\n    startGlobalPoint,\n    hoveredEndElement,\n    origEndGlobalPoint,\n    elementsMap,\n  );\n  const startPointBounds = [\n    startGlobalPoint[0] - 2,\n    startGlobalPoint[1] - 2,\n    startGlobalPoint[0] + 2,\n    startGlobalPoint[1] + 2,\n  ] as Bounds;\n  const endPointBounds = [\n    endGlobalPoint[0] - 2,\n    endGlobalPoint[1] - 2,\n    endGlobalPoint[0] + 2,\n    endGlobalPoint[1] + 2,\n  ] as Bounds;\n  const startElementBounds = hoveredStartElement\n    ? aabbForElement(\n        hoveredStartElement,\n        elementsMap,\n        offsetFromHeading(\n          startHeading,\n          arrow.startArrowhead\n            ? FIXED_BINDING_DISTANCE * 6\n            : FIXED_BINDING_DISTANCE * 2,\n          1,\n        ),\n      )\n    : startPointBounds;\n  const endElementBounds = hoveredEndElement\n    ? aabbForElement(\n        hoveredEndElement,\n        elementsMap,\n        offsetFromHeading(\n          endHeading,\n          arrow.endArrowhead\n            ? FIXED_BINDING_DISTANCE * 6\n            : FIXED_BINDING_DISTANCE * 2,\n          1,\n        ),\n      )\n    : endPointBounds;\n  const boundsOverlap =\n    pointInsideBounds(\n      startGlobalPoint,\n      hoveredEndElement\n        ? aabbForElement(\n            hoveredEndElement,\n            elementsMap,\n            offsetFromHeading(endHeading, BASE_PADDING, BASE_PADDING),\n          )\n        : endPointBounds,\n    ) ||\n    pointInsideBounds(\n      endGlobalPoint,\n      hoveredStartElement\n        ? aabbForElement(\n            hoveredStartElement,\n            elementsMap,\n            offsetFromHeading(startHeading, BASE_PADDING, BASE_PADDING),\n          )\n        : startPointBounds,\n    );\n  const commonBounds = commonAABB(\n    boundsOverlap\n      ? [startPointBounds, endPointBounds]\n      : [startElementBounds, endElementBounds],\n  );\n  const dynamicAABBs = generateDynamicAABBs(\n    boundsOverlap ? startPointBounds : startElementBounds,\n    boundsOverlap ? endPointBounds : endElementBounds,\n    commonBounds,\n    boundsOverlap\n      ? offsetFromHeading(\n          startHeading,\n          !hoveredStartElement && !hoveredEndElement ? 0 : BASE_PADDING,\n          0,\n        )\n      : offsetFromHeading(\n          startHeading,\n          !hoveredStartElement && !hoveredEndElement\n            ? 0\n            : BASE_PADDING -\n                (arrow.startArrowhead\n                  ? FIXED_BINDING_DISTANCE * 6\n                  : FIXED_BINDING_DISTANCE * 2),\n          BASE_PADDING,\n        ),\n    boundsOverlap\n      ? offsetFromHeading(\n          endHeading,\n          !hoveredStartElement && !hoveredEndElement ? 0 : BASE_PADDING,\n          0,\n        )\n      : offsetFromHeading(\n          endHeading,\n          !hoveredStartElement && !hoveredEndElement\n            ? 0\n            : BASE_PADDING -\n                (arrow.endArrowhead\n                  ? FIXED_BINDING_DISTANCE * 6\n                  : FIXED_BINDING_DISTANCE * 2),\n          BASE_PADDING,\n        ),\n    boundsOverlap,\n    hoveredStartElement && aabbForElement(hoveredStartElement, elementsMap),\n    hoveredEndElement && aabbForElement(hoveredEndElement, elementsMap),\n  );\n  const startDonglePosition = getDonglePosition(\n    dynamicAABBs[0],\n    startHeading,\n    startGlobalPoint,\n  );\n  const endDonglePosition = getDonglePosition(\n    dynamicAABBs[1],\n    endHeading,\n    endGlobalPoint,\n  );\n\n  return {\n    dynamicAABBs,\n    startDonglePosition,\n    startGlobalPoint,\n    startHeading,\n    endDonglePosition,\n    endGlobalPoint,\n    endHeading,\n    commonBounds,\n    hoveredStartElement,\n    hoveredEndElement,\n    boundsOverlap,\n    startElementBounds,\n    endElementBounds,\n  };\n};\n\n/**\n * Generate the elbow arrow segments\n *\n * @param arrow\n * @param elementsMap\n * @param nextPoints\n * @param options\n * @returns\n */\nconst routeElbowArrow = (\n  arrow: ElbowArrowState,\n  elbowArrowData: ElbowArrowData,\n): GlobalPoint[] | null => {\n  const {\n    dynamicAABBs,\n    startDonglePosition,\n    startGlobalPoint,\n    startHeading,\n    endDonglePosition,\n    endGlobalPoint,\n    endHeading,\n    commonBounds,\n    hoveredEndElement,\n  } = elbowArrowData;\n\n  // Canculate Grid positions\n  const grid = calculateGrid(\n    dynamicAABBs,\n    startDonglePosition ? startDonglePosition : startGlobalPoint,\n    startHeading,\n    endDonglePosition ? endDonglePosition : endGlobalPoint,\n    endHeading,\n    commonBounds,\n  );\n\n  const startDongle =\n    startDonglePosition && pointToGridNode(startDonglePosition, grid);\n  const endDongle =\n    endDonglePosition && pointToGridNode(endDonglePosition, grid);\n\n  // Do not allow stepping on the true end or true start points\n  const endNode = pointToGridNode(endGlobalPoint, grid);\n  if (endNode && hoveredEndElement) {\n    endNode.closed = true;\n  }\n  const startNode = pointToGridNode(startGlobalPoint, grid);\n  if (startNode && arrow.startBinding) {\n    startNode.closed = true;\n  }\n  const dongleOverlap =\n    startDongle &&\n    endDongle &&\n    (pointInsideBounds(startDongle.pos, dynamicAABBs[1]) ||\n      pointInsideBounds(endDongle.pos, dynamicAABBs[0]));\n\n  // Create path to end dongle from start dongle\n  const path = astar(\n    startDongle ? startDongle : startNode!,\n    endDongle ? endDongle : endNode!,\n    grid,\n    startHeading ? startHeading : HEADING_RIGHT,\n    endHeading ? endHeading : HEADING_RIGHT,\n    dongleOverlap ? [] : dynamicAABBs,\n  );\n\n  if (path) {\n    const points = path.map((node) => [\n      node.pos[0],\n      node.pos[1],\n    ]) as GlobalPoint[];\n    startDongle && points.unshift(startGlobalPoint);\n    endDongle && points.push(endGlobalPoint);\n\n    return points;\n  }\n\n  return null;\n};\n\nconst offsetFromHeading = (\n  heading: Heading,\n  head: number,\n  side: number,\n): [number, number, number, number] => {\n  switch (heading) {\n    case HEADING_UP:\n      return [head, side, side, side];\n    case HEADING_RIGHT:\n      return [side, head, side, side];\n    case HEADING_DOWN:\n      return [side, side, head, side];\n  }\n\n  return [side, side, side, head];\n};\n\n/**\n * Routing algorithm based on the A* path search algorithm.\n * @see https://www.geeksforgeeks.org/a-search-algorithm/\n *\n * Binary heap is used to optimize node lookup.\n * See {@link calculateGrid} for the grid calculation details.\n *\n * Additional modifications added due to aesthetic route reasons:\n * 1) Arrow segment direction change is penalized by specific linear constant (bendMultiplier)\n * 2) Arrow segments are not allowed to go \"backwards\", overlapping with the previous segment\n */\nconst astar = (\n  start: Node,\n  end: Node,\n  grid: Grid,\n  startHeading: Heading,\n  endHeading: Heading,\n  aabbs: Bounds[],\n) => {\n  const bendMultiplier = m_dist(start.pos, end.pos);\n  const open = new BinaryHeap<Node>((node) => node.f);\n\n  open.push(start);\n\n  while (open.size() > 0) {\n    // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n    const current = open.pop();\n\n    if (!current || current.closed) {\n      // Current is not passable, continue with next element\n      continue;\n    }\n\n    // End case -- result has been found, return the traced path.\n    if (current === end) {\n      return pathTo(start, current);\n    }\n\n    // Normal case -- move current from open to closed, process each of its neighbors.\n    current.closed = true;\n\n    // Find all neighbors for the current node.\n    const neighbors = getNeighbors(current.addr, grid);\n\n    for (let i = 0; i < 4; i++) {\n      const neighbor = neighbors[i];\n\n      if (!neighbor || neighbor.closed) {\n        // Not a valid node to process, skip to next neighbor.\n        continue;\n      }\n\n      // Intersect\n      const neighborHalfPoint = pointScaleFromOrigin(\n        neighbor.pos,\n        current.pos,\n        0.5,\n      );\n      if (\n        isAnyTrue(\n          ...aabbs.map((aabb) => pointInsideBounds(neighborHalfPoint, aabb)),\n        )\n      ) {\n        continue;\n      }\n\n      // The g score is the shortest distance from start to current node.\n      // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n      const neighborHeading = neighborIndexToHeading(i as 0 | 1 | 2 | 3);\n      const previousDirection = current.parent\n        ? vectorToHeading(vectorFromPoint(current.pos, current.parent.pos))\n        : startHeading;\n\n      // Do not allow going in reverse\n      const reverseHeading = flipHeading(previousDirection);\n      const neighborIsReverseRoute =\n        compareHeading(reverseHeading, neighborHeading) ||\n        (gridAddressesEqual(start.addr, neighbor.addr) &&\n          compareHeading(neighborHeading, startHeading)) ||\n        (gridAddressesEqual(end.addr, neighbor.addr) &&\n          compareHeading(neighborHeading, endHeading));\n      if (neighborIsReverseRoute) {\n        continue;\n      }\n\n      const directionChange = previousDirection !== neighborHeading;\n      const gScore =\n        current.g +\n        m_dist(neighbor.pos, current.pos) +\n        (directionChange ? Math.pow(bendMultiplier, 3) : 0);\n\n      const beenVisited = neighbor.visited;\n\n      if (!beenVisited || gScore < neighbor.g) {\n        const estBendCount = estimateSegmentCount(\n          neighbor,\n          end,\n          neighborHeading,\n          endHeading,\n        );\n        // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n        neighbor.visited = true;\n        neighbor.parent = current;\n        neighbor.h =\n          m_dist(end.pos, neighbor.pos) +\n          estBendCount * Math.pow(bendMultiplier, 2);\n        neighbor.g = gScore;\n        neighbor.f = neighbor.g + neighbor.h;\n        if (!beenVisited) {\n          // Pushing to heap will put it in proper place based on the 'f' value.\n          open.push(neighbor);\n        } else {\n          // Already seen the node, but since it has been rescored we need to reorder it in the heap\n          open.rescoreElement(neighbor);\n        }\n      }\n    }\n  }\n\n  return null;\n};\n\nconst pathTo = (start: Node, node: Node) => {\n  let curr = node;\n  const path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  path.unshift(start);\n\n  return path;\n};\n\nconst m_dist = (a: GlobalPoint | LocalPoint, b: GlobalPoint | LocalPoint) =>\n  Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\n\n/**\n * Create dynamically resizing, always touching\n * bounding boxes having a minimum extent represented\n * by the given static bounds.\n */\nconst generateDynamicAABBs = (\n  a: Bounds,\n  b: Bounds,\n  common: Bounds,\n  startDifference?: [number, number, number, number],\n  endDifference?: [number, number, number, number],\n  disableSideHack?: boolean,\n  startElementBounds?: Bounds | null,\n  endElementBounds?: Bounds | null,\n): Bounds[] => {\n  const startEl = startElementBounds ?? a;\n  const endEl = endElementBounds ?? b;\n  const [startUp, startRight, startDown, startLeft] = startDifference ?? [\n    0, 0, 0, 0,\n  ];\n  const [endUp, endRight, endDown, endLeft] = endDifference ?? [0, 0, 0, 0];\n\n  const first = [\n    a[0] > b[2]\n      ? a[1] > b[3] || a[3] < b[1]\n        ? Math.min((startEl[0] + endEl[2]) / 2, a[0] - startLeft)\n        : (startEl[0] + endEl[2]) / 2\n      : a[0] > b[0]\n      ? a[0] - startLeft\n      : common[0] - startLeft,\n    a[1] > b[3]\n      ? a[0] > b[2] || a[2] < b[0]\n        ? Math.min((startEl[1] + endEl[3]) / 2, a[1] - startUp)\n        : (startEl[1] + endEl[3]) / 2\n      : a[1] > b[1]\n      ? a[1] - startUp\n      : common[1] - startUp,\n    a[2] < b[0]\n      ? a[1] > b[3] || a[3] < b[1]\n        ? Math.max((startEl[2] + endEl[0]) / 2, a[2] + startRight)\n        : (startEl[2] + endEl[0]) / 2\n      : a[2] < b[2]\n      ? a[2] + startRight\n      : common[2] + startRight,\n    a[3] < b[1]\n      ? a[0] > b[2] || a[2] < b[0]\n        ? Math.max((startEl[3] + endEl[1]) / 2, a[3] + startDown)\n        : (startEl[3] + endEl[1]) / 2\n      : a[3] < b[3]\n      ? a[3] + startDown\n      : common[3] + startDown,\n  ] as Bounds;\n  const second = [\n    b[0] > a[2]\n      ? b[1] > a[3] || b[3] < a[1]\n        ? Math.min((endEl[0] + startEl[2]) / 2, b[0] - endLeft)\n        : (endEl[0] + startEl[2]) / 2\n      : b[0] > a[0]\n      ? b[0] - endLeft\n      : common[0] - endLeft,\n    b[1] > a[3]\n      ? b[0] > a[2] || b[2] < a[0]\n        ? Math.min((endEl[1] + startEl[3]) / 2, b[1] - endUp)\n        : (endEl[1] + startEl[3]) / 2\n      : b[1] > a[1]\n      ? b[1] - endUp\n      : common[1] - endUp,\n    b[2] < a[0]\n      ? b[1] > a[3] || b[3] < a[1]\n        ? Math.max((endEl[2] + startEl[0]) / 2, b[2] + endRight)\n        : (endEl[2] + startEl[0]) / 2\n      : b[2] < a[2]\n      ? b[2] + endRight\n      : common[2] + endRight,\n    b[3] < a[1]\n      ? b[0] > a[2] || b[2] < a[0]\n        ? Math.max((endEl[3] + startEl[1]) / 2, b[3] + endDown)\n        : (endEl[3] + startEl[1]) / 2\n      : b[3] < a[3]\n      ? b[3] + endDown\n      : common[3] + endDown,\n  ] as Bounds;\n\n  const c = commonAABB([first, second]);\n  if (\n    !disableSideHack &&\n    first[2] - first[0] + second[2] - second[0] > c[2] - c[0] + 0.00000000001 &&\n    first[3] - first[1] + second[3] - second[1] > c[3] - c[1] + 0.00000000001\n  ) {\n    const [endCenterX, endCenterY] = [\n      (second[0] + second[2]) / 2,\n      (second[1] + second[3]) / 2,\n    ];\n    if (b[0] > a[2] && a[1] > b[3]) {\n      // BOTTOM LEFT\n      const cX = first[2] + (second[0] - first[2]) / 2;\n      const cY = second[3] + (first[1] - second[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[2] - endCenterX, a[1] - endCenterY),\n          vector(a[0] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [first[0], first[1], cX, first[3]],\n          [cX, second[1], second[2], second[3]],\n        ];\n      }\n\n      return [\n        [first[0], cY, first[2], first[3]],\n        [second[0], second[1], second[2], cY],\n      ];\n    } else if (a[2] < b[0] && a[3] < b[1]) {\n      // TOP LEFT\n      const cX = first[2] + (second[0] - first[2]) / 2;\n      const cY = first[3] + (second[1] - first[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[0] - endCenterX, a[1] - endCenterY),\n          vector(a[2] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [first[0], first[1], first[2], cY],\n          [second[0], cY, second[2], second[3]],\n        ];\n      }\n\n      return [\n        [first[0], first[1], cX, first[3]],\n        [cX, second[1], second[2], second[3]],\n      ];\n    } else if (a[0] > b[2] && a[3] < b[1]) {\n      // TOP RIGHT\n      const cX = second[2] + (first[0] - second[2]) / 2;\n      const cY = first[3] + (second[1] - first[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[2] - endCenterX, a[1] - endCenterY),\n          vector(a[0] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [cX, first[1], first[2], first[3]],\n          [second[0], second[1], cX, second[3]],\n        ];\n      }\n\n      return [\n        [first[0], first[1], first[2], cY],\n        [second[0], cY, second[2], second[3]],\n      ];\n    } else if (a[0] > b[2] && a[1] > b[3]) {\n      // BOTTOM RIGHT\n      const cX = second[2] + (first[0] - second[2]) / 2;\n      const cY = second[3] + (first[1] - second[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[0] - endCenterX, a[1] - endCenterY),\n          vector(a[2] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [cX, first[1], first[2], first[3]],\n          [second[0], second[1], cX, second[3]],\n        ];\n      }\n\n      return [\n        [first[0], cY, first[2], first[3]],\n        [second[0], second[1], second[2], cY],\n      ];\n    }\n  }\n\n  return [first, second];\n};\n\n/**\n * Calculates the grid which is used as nodes at\n * the grid line intersections by the A* algorithm.\n *\n * NOTE: This is not a uniform grid. It is built at\n * various intersections of bounding boxes.\n */\nconst calculateGrid = (\n  aabbs: Bounds[],\n  start: GlobalPoint,\n  startHeading: Heading,\n  end: GlobalPoint,\n  endHeading: Heading,\n  common: Bounds,\n): Grid => {\n  const horizontal = new Set<number>();\n  const vertical = new Set<number>();\n\n  if (startHeading === HEADING_LEFT || startHeading === HEADING_RIGHT) {\n    vertical.add(start[1]);\n  } else {\n    horizontal.add(start[0]);\n  }\n  if (endHeading === HEADING_LEFT || endHeading === HEADING_RIGHT) {\n    vertical.add(end[1]);\n  } else {\n    horizontal.add(end[0]);\n  }\n\n  aabbs.forEach((aabb) => {\n    horizontal.add(aabb[0]);\n    horizontal.add(aabb[2]);\n    vertical.add(aabb[1]);\n    vertical.add(aabb[3]);\n  });\n\n  horizontal.add(common[0]);\n  horizontal.add(common[2]);\n  vertical.add(common[1]);\n  vertical.add(common[3]);\n\n  const _vertical = Array.from(vertical).sort((a, b) => a - b);\n  const _horizontal = Array.from(horizontal).sort((a, b) => a - b);\n\n  return {\n    row: _vertical.length,\n    col: _horizontal.length,\n    data: _vertical.flatMap((y, row) =>\n      _horizontal.map(\n        (x, col): Node => ({\n          f: 0,\n          g: 0,\n          h: 0,\n          closed: false,\n          visited: false,\n          parent: null,\n          addr: [col, row] as GridAddress,\n          pos: [x, y] as GlobalPoint,\n        }),\n      ),\n    ),\n  };\n};\n\nconst getDonglePosition = (\n  bounds: Bounds,\n  heading: Heading,\n  p: GlobalPoint,\n): GlobalPoint => {\n  switch (heading) {\n    case HEADING_UP:\n      return pointFrom(p[0], bounds[1]);\n    case HEADING_RIGHT:\n      return pointFrom(bounds[2], p[1]);\n    case HEADING_DOWN:\n      return pointFrom(p[0], bounds[3]);\n  }\n  return pointFrom(bounds[0], p[1]);\n};\n\nconst estimateSegmentCount = (\n  start: Node,\n  end: Node,\n  startHeading: Heading,\n  endHeading: Heading,\n) => {\n  if (endHeading === HEADING_RIGHT) {\n    switch (startHeading) {\n      case HEADING_RIGHT: {\n        if (start.pos[0] >= end.pos[0]) {\n          return 4;\n        }\n        if (start.pos[1] === end.pos[1]) {\n          return 0;\n        }\n        return 2;\n      }\n      case HEADING_UP:\n        if (start.pos[1] > end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_DOWN:\n        if (start.pos[1] < end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_LEFT:\n        if (start.pos[1] === end.pos[1]) {\n          return 4;\n        }\n        return 2;\n    }\n  } else if (endHeading === HEADING_LEFT) {\n    switch (startHeading) {\n      case HEADING_RIGHT:\n        if (start.pos[1] === end.pos[1]) {\n          return 4;\n        }\n        return 2;\n      case HEADING_UP:\n        if (start.pos[1] > end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_DOWN:\n        if (start.pos[1] < end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_LEFT:\n        if (start.pos[0] <= end.pos[0]) {\n          return 4;\n        }\n        if (start.pos[1] === end.pos[1]) {\n          return 0;\n        }\n        return 2;\n    }\n  } else if (endHeading === HEADING_UP) {\n    switch (startHeading) {\n      case HEADING_RIGHT:\n        if (start.pos[1] > end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_UP:\n        if (start.pos[1] >= end.pos[1]) {\n          return 4;\n        }\n        if (start.pos[0] === end.pos[0]) {\n          return 0;\n        }\n        return 2;\n      case HEADING_DOWN:\n        if (start.pos[0] === end.pos[0]) {\n          return 4;\n        }\n        return 2;\n      case HEADING_LEFT:\n        if (start.pos[1] > end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n    }\n  } else if (endHeading === HEADING_DOWN) {\n    switch (startHeading) {\n      case HEADING_RIGHT:\n        if (start.pos[1] < end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_UP:\n        if (start.pos[0] === end.pos[0]) {\n          return 4;\n        }\n        return 2;\n      case HEADING_DOWN:\n        if (start.pos[1] <= end.pos[1]) {\n          return 4;\n        }\n        if (start.pos[0] === end.pos[0]) {\n          return 0;\n        }\n        return 2;\n      case HEADING_LEFT:\n        if (start.pos[1] < end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n    }\n  }\n  return 0;\n};\n\n/**\n * Get neighboring points for a gived grid address\n */\nconst getNeighbors = ([col, row]: [number, number], grid: Grid) =>\n  [\n    gridNodeFromAddr([col, row - 1], grid),\n    gridNodeFromAddr([col + 1, row], grid),\n    gridNodeFromAddr([col, row + 1], grid),\n    gridNodeFromAddr([col - 1, row], grid),\n  ] as [Node | null, Node | null, Node | null, Node | null];\n\nconst gridNodeFromAddr = (\n  [col, row]: [col: number, row: number],\n  grid: Grid,\n): Node | null => {\n  if (col < 0 || col >= grid.col || row < 0 || row >= grid.row) {\n    return null;\n  }\n\n  return grid.data[row * grid.col + col] ?? null;\n};\n\n/**\n * Get node for global point on canvas (if exists)\n */\nconst pointToGridNode = (point: GlobalPoint, grid: Grid): Node | null => {\n  for (let col = 0; col < grid.col; col++) {\n    for (let row = 0; row < grid.row; row++) {\n      const candidate = gridNodeFromAddr([col, row], grid);\n      if (\n        candidate &&\n        point[0] === candidate.pos[0] &&\n        point[1] === candidate.pos[1]\n      ) {\n        return candidate;\n      }\n    }\n  }\n\n  return null;\n};\n\nconst commonAABB = (aabbs: Bounds[]): Bounds => [\n  Math.min(...aabbs.map((aabb) => aabb[0])),\n  Math.min(...aabbs.map((aabb) => aabb[1])),\n  Math.max(...aabbs.map((aabb) => aabb[2])),\n  Math.max(...aabbs.map((aabb) => aabb[3])),\n];\n\n/// #region Utils\n\nconst getBindableElementForId = (\n  id: string,\n  elementsMap: ElementsMap,\n): ExcalidrawBindableElement | null => {\n  const element = elementsMap.get(id);\n  if (element && isBindableElement(element)) {\n    return element;\n  }\n\n  return null;\n};\n\nconst normalizeArrowElementUpdate = (\n  global: GlobalPoint[],\n  nextFixedSegments: readonly FixedSegment[] | null,\n  startIsSpecial?: ExcalidrawElbowArrowElement[\"startIsSpecial\"],\n  endIsSpecial?: ExcalidrawElbowArrowElement[\"startIsSpecial\"],\n): {\n  points: LocalPoint[];\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  fixedSegments: readonly FixedSegment[] | null;\n  startIsSpecial?: ExcalidrawElbowArrowElement[\"startIsSpecial\"];\n  endIsSpecial?: ExcalidrawElbowArrowElement[\"startIsSpecial\"];\n} => {\n  const offsetX = global[0][0];\n  const offsetY = global[0][1];\n  let points = global.map((p) =>\n    pointTranslate<GlobalPoint, LocalPoint>(\n      p,\n      vectorScale(vectorFromPoint(global[0]), -1),\n    ),\n  );\n\n  // NOTE (mtolmacs): This is a temporary check to see if the normalization\n  // creates an overly large arrow. This should be removed once we have an answer.\n  if (\n    offsetX < -MAX_POS ||\n    offsetX > MAX_POS ||\n    offsetY < -MAX_POS ||\n    offsetY > MAX_POS ||\n    offsetX + points[points.length - 1][0] < -MAX_POS ||\n    offsetY + points[points.length - 1][0] > MAX_POS ||\n    offsetX + points[points.length - 1][1] < -MAX_POS ||\n    offsetY + points[points.length - 1][1] > MAX_POS\n  ) {\n    console.error(\n      \"Elbow arrow normalization is outside reasonable bounds (> 1e6)\",\n      {\n        x: offsetX,\n        y: offsetY,\n        points,\n        ...getSizeFromPoints(points),\n      },\n    );\n  }\n\n  points = points.map(([x, y]) =>\n    pointFrom<LocalPoint>(clamp(x, -1e6, 1e6), clamp(y, -1e6, 1e6)),\n  );\n\n  return {\n    points,\n    x: clamp(offsetX, -1e6, 1e6),\n    y: clamp(offsetY, -1e6, 1e6),\n    fixedSegments:\n      (nextFixedSegments?.length ?? 0) > 0 ? nextFixedSegments : null,\n    ...getSizeFromPoints(points),\n    startIsSpecial,\n    endIsSpecial,\n  };\n};\n\nconst getElbowArrowCornerPoints = (points: GlobalPoint[]): GlobalPoint[] => {\n  if (points.length > 1) {\n    let previousHorizontal =\n      Math.abs(points[0][1] - points[1][1]) <\n      Math.abs(points[0][0] - points[1][0]);\n\n    return points.filter((p, idx) => {\n      // The very first and last points are always kept\n      if (idx === 0 || idx === points.length - 1) {\n        return true;\n      }\n\n      const next = points[idx + 1];\n      const nextHorizontal =\n        Math.abs(p[1] - next[1]) < Math.abs(p[0] - next[0]);\n      if (previousHorizontal === nextHorizontal) {\n        previousHorizontal = nextHorizontal;\n        return false;\n      }\n\n      previousHorizontal = nextHorizontal;\n      return true;\n    });\n  }\n\n  return points;\n};\n\nconst removeElbowArrowShortSegments = (\n  points: GlobalPoint[],\n): GlobalPoint[] => {\n  if (points.length >= 4) {\n    return points.filter((p, idx) => {\n      if (idx === 0 || idx === points.length - 1) {\n        return true;\n      }\n\n      const prev = points[idx - 1];\n      const prevDist = pointDistance(prev, p);\n      return prevDist > DEDUP_TRESHOLD;\n    });\n  }\n\n  return points;\n};\n\nconst neighborIndexToHeading = (idx: number): Heading => {\n  switch (idx) {\n    case 0:\n      return HEADING_UP;\n    case 1:\n      return HEADING_RIGHT;\n    case 2:\n      return HEADING_DOWN;\n  }\n  return HEADING_LEFT;\n};\n\nconst getGlobalPoint = (\n  arrow: ExcalidrawElbowArrowElement,\n  startOrEnd: \"start\" | \"end\",\n  fixedPointRatio: [number, number] | undefined | null,\n  initialPoint: GlobalPoint,\n  element?: ExcalidrawBindableElement | null,\n  elementsMap?: ElementsMap,\n  isDragging?: boolean,\n): GlobalPoint => {\n  if (isDragging) {\n    if (element && elementsMap) {\n      return bindPointToSnapToElementOutline(\n        arrow,\n        element,\n        startOrEnd,\n        elementsMap,\n      );\n    }\n\n    return initialPoint;\n  }\n\n  if (element) {\n    return getGlobalFixedPointForBindableElement(\n      fixedPointRatio || [0, 0],\n      element,\n      elementsMap ?? arrayToMap([element]),\n    );\n  }\n\n  return initialPoint;\n};\n\nconst getBindPointHeading = (\n  p: GlobalPoint,\n  otherPoint: GlobalPoint,\n  hoveredElement: ExcalidrawBindableElement | null | undefined,\n  origPoint: GlobalPoint,\n  elementsMap: ElementsMap,\n): Heading =>\n  getHeadingForElbowArrowSnap(\n    p,\n    otherPoint,\n    hoveredElement,\n    hoveredElement &&\n      aabbForElement(\n        hoveredElement,\n        elementsMap,\n        Array(4).fill(distanceToElement(hoveredElement, elementsMap, p)) as [\n          number,\n          number,\n          number,\n          number,\n        ],\n      ),\n    origPoint,\n    elementsMap,\n  );\n\nconst getHoveredElement = (\n  origPoint: GlobalPoint,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly NonDeletedExcalidrawElement[],\n  zoom?: AppState[\"zoom\"],\n) => {\n  return getHoveredElementForBinding(\n    tupleToCoors(origPoint),\n    elements,\n    elementsMap,\n    zoom,\n    true,\n    true,\n  );\n};\n\nconst gridAddressesEqual = (a: GridAddress, b: GridAddress): boolean =>\n  a[0] === b[0] && a[1] === b[1];\n\nexport const validateElbowPoints = <P extends GlobalPoint | LocalPoint>(\n  points: readonly P[],\n  tolerance: number = DEDUP_TRESHOLD,\n) =>\n  points\n    .slice(1)\n    .map(\n      (p, i) =>\n        Math.abs(p[0] - points[i][0]) < tolerance ||\n        Math.abs(p[1] - points[i][1]) < tolerance,\n    )\n    .every(Boolean);\n",
    "import { arrayToMap } from \"@excalidraw/common\";\nimport { isPointWithinBounds, pointFrom } from \"@excalidraw/math\";\nimport { doLineSegmentsIntersect } from \"@excalidraw/utils/bbox\";\nimport { elementsOverlappingBBox } from \"@excalidraw/utils/withinBounds\";\n\nimport type {\n  AppClassProperties,\n  AppState,\n  StaticCanvasAppState,\n} from \"excalidraw-custom/types\";\n\nimport type { ReadonlySetLike } from \"@excalidraw/common/utility-types\";\n\nimport { getElementsWithinSelection, getSelectedElements } from \"./selection\";\nimport { getElementsInGroup, selectGroupsFromGivenElements } from \"./groups\";\n\nimport {\n  getElementLineSegments,\n  getCommonBounds,\n  getElementAbsoluteCoords,\n} from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\nimport {\n  isFrameElement,\n  isFrameLikeElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport type { ExcalidrawElementsIncludingDeleted } from \"./Scene\";\n\nimport type {\n  ElementsMap,\n  ElementsMapOrArray,\n  ExcalidrawElement,\n  ExcalidrawFrameLikeElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\n// --------------------------- Frame State ------------------------------------\nexport const bindElementsToFramesAfterDuplication = (\n  nextElements: readonly ExcalidrawElement[],\n  origElements: readonly ExcalidrawElement[],\n  origIdToDuplicateId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n) => {\n  const nextElementMap = arrayToMap(nextElements) as Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >;\n\n  for (const element of origElements) {\n    if (element.frameId) {\n      // use its frameId to get the new frameId\n      const nextElementId = origIdToDuplicateId.get(element.id);\n      const nextFrameId = origIdToDuplicateId.get(element.frameId);\n      const nextElement = nextElementId && nextElementMap.get(nextElementId);\n      if (nextElement) {\n        mutateElement(nextElement, nextElementMap, {\n          frameId: nextFrameId ?? null,\n        });\n      }\n    }\n  }\n};\n\nexport function isElementIntersectingFrame(\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) {\n  const frameLineSegments = getElementLineSegments(frame, elementsMap);\n\n  const elementLineSegments = getElementLineSegments(element, elementsMap);\n\n  const intersecting = frameLineSegments.some((frameLineSegment) =>\n    elementLineSegments.some((elementLineSegment) =>\n      doLineSegmentsIntersect(frameLineSegment, elementLineSegment),\n    ),\n  );\n\n  return intersecting;\n}\n\nexport const getElementsCompletelyInFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) =>\n  omitGroupsContainingFrameLikes(\n    getElementsWithinSelection(elements, frame, elementsMap, false),\n  ).filter(\n    (element) =>\n      (!isFrameLikeElement(element) && !element.frameId) ||\n      element.frameId === frame.id,\n  );\n\nexport const isElementContainingFrame = (\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  return getElementsWithinSelection([frame], element, elementsMap).some(\n    (e) => e.id === frame.id,\n  );\n};\n\nexport const getElementsIntersectingFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsMap = arrayToMap(elements);\n  return elements.filter((element) =>\n    isElementIntersectingFrame(element, frame, elementsMap),\n  );\n};\n\nexport const elementsAreInFrameBounds = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  const [frameX1, frameY1, frameX2, frameY2] = getElementAbsoluteCoords(\n    frame,\n    elementsMap,\n  );\n\n  const [elementX1, elementY1, elementX2, elementY2] =\n    getCommonBounds(elements);\n\n  return (\n    frameX1 <= elementX1 &&\n    frameY1 <= elementY1 &&\n    frameX2 >= elementX2 &&\n    frameY2 >= elementY2\n  );\n};\n\nexport const elementOverlapsWithFrame = (\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  return (\n    elementsAreInFrameBounds([element], frame, elementsMap) ||\n    isElementIntersectingFrame(element, frame, elementsMap) ||\n    isElementContainingFrame(element, frame, elementsMap)\n  );\n};\n\nexport const isCursorInFrame = (\n  cursorCoords: {\n    x: number;\n    y: number;\n  },\n  frame: NonDeleted<ExcalidrawFrameLikeElement>,\n  elementsMap: ElementsMap,\n) => {\n  const [fx1, fy1, fx2, fy2] = getElementAbsoluteCoords(frame, elementsMap);\n\n  return isPointWithinBounds(\n    pointFrom(fx1, fy1),\n    pointFrom(cursorCoords.x, cursorCoords.y),\n    pointFrom(fx2, fy2),\n  );\n};\n\nexport const groupsAreAtLeastIntersectingTheFrame = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  groupIds: readonly string[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsMap = arrayToMap(elements);\n  const elementsInGroup = groupIds.flatMap((groupId) =>\n    getElementsInGroup(elements, groupId),\n  );\n\n  if (elementsInGroup.length === 0) {\n    return true;\n  }\n\n  return !!elementsInGroup.find(\n    (element) =>\n      elementsAreInFrameBounds([element], frame, elementsMap) ||\n      isElementIntersectingFrame(element, frame, elementsMap),\n  );\n};\n\nexport const groupsAreCompletelyOutOfFrame = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  groupIds: readonly string[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsMap = arrayToMap(elements);\n  const elementsInGroup = groupIds.flatMap((groupId) =>\n    getElementsInGroup(elements, groupId),\n  );\n\n  if (elementsInGroup.length === 0) {\n    return true;\n  }\n\n  return (\n    elementsInGroup.find(\n      (element) =>\n        elementsAreInFrameBounds([element], frame, elementsMap) ||\n        isElementIntersectingFrame(element, frame, elementsMap),\n    ) === undefined\n  );\n};\n\n// --------------------------- Frame Utils ------------------------------------\n\n/**\n * Returns a map of frameId to frame elements. Includes empty frames.\n */\nexport const groupByFrameLikes = (elements: readonly ExcalidrawElement[]) => {\n  const frameElementsMap = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement[]\n  >();\n\n  for (const element of elements) {\n    const frameId = isFrameLikeElement(element) ? element.id : element.frameId;\n    if (frameId && !frameElementsMap.has(frameId)) {\n      frameElementsMap.set(frameId, getFrameChildren(elements, frameId));\n    }\n  }\n\n  return frameElementsMap;\n};\n\nexport const getFrameChildren = (\n  allElements: ElementsMapOrArray,\n  frameId: string,\n) => {\n  const frameChildren: ExcalidrawElement[] = [];\n  for (const element of allElements.values()) {\n    if (element.frameId === frameId) {\n      frameChildren.push(element);\n    }\n  }\n  return frameChildren;\n};\n\nexport const getFrameLikeElements = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n): ExcalidrawFrameLikeElement[] => {\n  return allElements.filter((element): element is ExcalidrawFrameLikeElement =>\n    isFrameLikeElement(element),\n  );\n};\n\n/**\n * Returns ExcalidrawFrameElements and non-frame-children elements.\n *\n * Considers children as root elements if they point to a frame parent\n * non-existing in the elements set.\n *\n * Considers non-frame bound elements (container or arrow labels) as root.\n */\nexport const getRootElements = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n) => {\n  const frameElements = arrayToMap(getFrameLikeElements(allElements));\n  return allElements.filter(\n    (element) =>\n      frameElements.has(element.id) ||\n      !element.frameId ||\n      !frameElements.has(element.frameId),\n  );\n};\n\nexport const getElementsInResizingFrame = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  frame: ExcalidrawFrameLikeElement,\n  appState: AppState,\n  elementsMap: ElementsMap,\n): ExcalidrawElement[] => {\n  const prevElementsInFrame = getFrameChildren(allElements, frame.id);\n  const nextElementsInFrame = new Set<ExcalidrawElement>(prevElementsInFrame);\n\n  const elementsCompletelyInFrame = new Set([\n    ...getElementsCompletelyInFrame(allElements, frame, elementsMap),\n    ...prevElementsInFrame.filter((element) =>\n      isElementContainingFrame(element, frame, elementsMap),\n    ),\n  ]);\n\n  const elementsNotCompletelyInFrame = prevElementsInFrame.filter(\n    (element) => !elementsCompletelyInFrame.has(element),\n  );\n\n  // for elements that are completely in the frame\n  // if they are part of some groups, then those groups are still\n  // considered to belong to the frame\n  const groupsToKeep = new Set<string>(\n    Array.from(elementsCompletelyInFrame).flatMap(\n      (element) => element.groupIds,\n    ),\n  );\n\n  for (const element of elementsNotCompletelyInFrame) {\n    if (!isElementIntersectingFrame(element, frame, elementsMap)) {\n      if (element.groupIds.length === 0) {\n        nextElementsInFrame.delete(element);\n      }\n    } else if (element.groupIds.length > 0) {\n      // group element intersects with the frame, we should keep the groups\n      // that this element is part of\n      for (const id of element.groupIds) {\n        groupsToKeep.add(id);\n      }\n    }\n  }\n\n  for (const element of elementsNotCompletelyInFrame) {\n    if (element.groupIds.length > 0) {\n      let shouldRemoveElement = true;\n\n      for (const id of element.groupIds) {\n        if (groupsToKeep.has(id)) {\n          shouldRemoveElement = false;\n        }\n      }\n\n      if (shouldRemoveElement) {\n        nextElementsInFrame.delete(element);\n      }\n    }\n  }\n\n  const individualElementsCompletelyInFrame = Array.from(\n    elementsCompletelyInFrame,\n  ).filter((element) => element.groupIds.length === 0);\n\n  for (const element of individualElementsCompletelyInFrame) {\n    nextElementsInFrame.add(element);\n  }\n\n  const newGroupElementsCompletelyInFrame = Array.from(\n    elementsCompletelyInFrame,\n  ).filter((element) => element.groupIds.length > 0);\n\n  const groupIds = selectGroupsFromGivenElements(\n    newGroupElementsCompletelyInFrame,\n    appState,\n  );\n\n  // new group elements\n  for (const [id, isSelected] of Object.entries(groupIds)) {\n    if (isSelected) {\n      const elementsInGroup = getElementsInGroup(allElements, id);\n\n      if (elementsAreInFrameBounds(elementsInGroup, frame, elementsMap)) {\n        for (const element of elementsInGroup) {\n          nextElementsInFrame.add(element);\n        }\n      }\n    }\n  }\n\n  return [...nextElementsInFrame].filter((element) => {\n    return !(isTextElement(element) && element.containerId);\n  });\n};\n\nexport const getElementsInNewFrame = (\n  elements: ExcalidrawElementsIncludingDeleted,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  return omitPartialGroups(\n    omitGroupsContainingFrameLikes(\n      elements,\n      getElementsCompletelyInFrame(elements, frame, elementsMap),\n    ),\n    frame,\n    elementsMap,\n  );\n};\n\nexport const omitPartialGroups = (\n  elements: ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  allElementsMap: ElementsMap,\n) => {\n  const elementsToReturn = [];\n  const checkedGroups = new Map<string, boolean>();\n\n  for (const element of elements) {\n    let shouldOmit = false;\n    if (element.groupIds.length > 0) {\n      // if some partial group should be omitted, then all elements in that group should be omitted\n      if (element.groupIds.some((gid) => checkedGroups.get(gid))) {\n        shouldOmit = true;\n      } else {\n        const allElementsInGroup = new Set(\n          element.groupIds.flatMap((gid) =>\n            getElementsInGroup(allElementsMap, gid),\n          ),\n        );\n\n        shouldOmit = !elementsAreInFrameBounds(\n          Array.from(allElementsInGroup),\n          frame,\n          allElementsMap,\n        );\n      }\n\n      element.groupIds.forEach((gid) => {\n        checkedGroups.set(gid, shouldOmit);\n      });\n    }\n\n    if (!shouldOmit) {\n      elementsToReturn.push(element);\n    }\n  }\n\n  return elementsToReturn;\n};\n\nexport const getContainingFrame = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n) => {\n  if (!element.frameId) {\n    return null;\n  }\n  return (elementsMap.get(element.frameId) ||\n    null) as null | ExcalidrawFrameLikeElement;\n};\n\n// --------------------------- Frame Operations -------------------------------\n\n/** */\nexport const filterElementsEligibleAsFrameChildren = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const otherFrames = new Set<ExcalidrawFrameLikeElement[\"id\"]>();\n  const elementsMap = arrayToMap(elements);\n  elements = omitGroupsContainingFrameLikes(elements);\n\n  for (const element of elements) {\n    if (isFrameLikeElement(element) && element.id !== frame.id) {\n      otherFrames.add(element.id);\n    }\n  }\n\n  const processedGroups = new Set<ExcalidrawElement[\"id\"]>();\n\n  const eligibleElements: ExcalidrawElement[] = [];\n\n  for (const element of elements) {\n    // don't add frames or their children\n    if (\n      isFrameLikeElement(element) ||\n      (element.frameId && otherFrames.has(element.frameId))\n    ) {\n      continue;\n    }\n\n    if (element.groupIds.length) {\n      const shallowestGroupId = element.groupIds.at(-1)!;\n      if (!processedGroups.has(shallowestGroupId)) {\n        processedGroups.add(shallowestGroupId);\n        const groupElements = getElementsInGroup(elements, shallowestGroupId);\n        if (\n          groupElements.some((el) =>\n            elementOverlapsWithFrame(el, frame, elementsMap),\n          )\n        ) {\n          for (const child of groupElements) {\n            eligibleElements.push(child);\n          }\n        }\n      }\n    } else {\n      const overlaps = elementOverlapsWithFrame(element, frame, elementsMap);\n      if (overlaps) {\n        eligibleElements.push(element);\n      }\n    }\n  }\n\n  return eligibleElements;\n};\n\n/**\n * Retains (or repairs for target frame) the ordering invriant where children\n * elements come right before the parent frame:\n * [el, el, child, child, frame, el]\n *\n * @returns mutated allElements (same data structure)\n */\nexport const addElementsToFrame = <T extends ElementsMapOrArray>(\n  allElements: T,\n  elementsToAdd: NonDeletedExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  appState: AppState,\n): T => {\n  const elementsMap = arrayToMap(allElements);\n  const currTargetFrameChildrenMap = new Map<ExcalidrawElement[\"id\"], true>();\n  for (const element of allElements.values()) {\n    if (element.frameId === frame.id) {\n      currTargetFrameChildrenMap.set(element.id, true);\n    }\n  }\n\n  const suppliedElementsToAddSet = new Set(elementsToAdd.map((el) => el.id));\n\n  const finalElementsToAdd: ExcalidrawElement[] = [];\n\n  const otherFrames = new Set<ExcalidrawFrameLikeElement[\"id\"]>();\n\n  for (const element of elementsToAdd) {\n    if (isFrameLikeElement(element) && element.id !== frame.id) {\n      otherFrames.add(element.id);\n    }\n  }\n\n  // - add bound text elements if not already in the array\n  // - filter out elements that are already in the frame\n  for (const element of omitGroupsContainingFrameLikes(\n    allElements,\n    elementsToAdd,\n  )) {\n    // don't add frames or their children\n    if (\n      isFrameLikeElement(element) ||\n      (element.frameId && otherFrames.has(element.frameId))\n    ) {\n      continue;\n    }\n\n    // if the element is already in another frame (which is also in elementsToAdd),\n    // it means that frame and children are selected at the same time\n    // => keep original frame membership, do not add to the target frame\n    if (\n      element.frameId &&\n      appState.selectedElementIds[element.id] &&\n      appState.selectedElementIds[element.frameId]\n    ) {\n      continue;\n    }\n\n    if (!currTargetFrameChildrenMap.has(element.id)) {\n      finalElementsToAdd.push(element);\n    }\n\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n    if (\n      boundTextElement &&\n      !suppliedElementsToAddSet.has(boundTextElement.id) &&\n      !currTargetFrameChildrenMap.has(boundTextElement.id)\n    ) {\n      finalElementsToAdd.push(boundTextElement);\n    }\n  }\n\n  for (const element of finalElementsToAdd) {\n    mutateElement(element, elementsMap, {\n      frameId: frame.id,\n    });\n  }\n\n  return allElements;\n};\n\nexport const removeElementsFromFrame = (\n  elementsToRemove: ReadonlySetLike<NonDeletedExcalidrawElement>,\n  elementsMap: ElementsMap,\n) => {\n  const _elementsToRemove = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >();\n\n  const toRemoveElementsByFrame = new Map<\n    ExcalidrawFrameLikeElement[\"id\"],\n    ExcalidrawElement[]\n  >();\n\n  for (const element of elementsToRemove) {\n    if (element.frameId) {\n      _elementsToRemove.set(element.id, element);\n\n      const arr = toRemoveElementsByFrame.get(element.frameId) || [];\n      arr.push(element);\n\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n      if (boundTextElement) {\n        _elementsToRemove.set(boundTextElement.id, boundTextElement);\n        arr.push(boundTextElement);\n      }\n\n      toRemoveElementsByFrame.set(element.frameId, arr);\n    }\n  }\n\n  for (const [, element] of _elementsToRemove) {\n    mutateElement(element, elementsMap, {\n      frameId: null,\n    });\n  }\n};\n\nexport const removeAllElementsFromFrame = <T extends ExcalidrawElement>(\n  allElements: readonly T[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsInFrame = getFrameChildren(allElements, frame.id);\n  removeElementsFromFrame(elementsInFrame, arrayToMap(allElements));\n  return allElements;\n};\n\nexport const replaceAllElementsInFrame = <T extends ExcalidrawElement>(\n  allElements: readonly T[],\n  nextElementsInFrame: ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  app: AppClassProperties,\n): T[] => {\n  return addElementsToFrame(\n    removeAllElementsFromFrame(allElements, frame),\n    nextElementsInFrame,\n    frame,\n    app.state,\n  ).slice();\n};\n\n/** does not mutate elements, but returns new ones */\nexport const updateFrameMembershipOfSelectedElements = <\n  T extends ElementsMapOrArray,\n>(\n  allElements: T,\n  appState: AppState,\n  app: AppClassProperties,\n) => {\n  const selectedElements = app.scene.getSelectedElements({\n    selectedElementIds: appState.selectedElementIds,\n    // supplying elements explicitly in case we're passed non-state elements\n    elements: allElements,\n  });\n  const elementsToFilter = new Set<ExcalidrawElement>(selectedElements);\n\n  if (appState.editingGroupId) {\n    for (const element of selectedElements) {\n      if (element.groupIds.length === 0) {\n        elementsToFilter.add(element);\n      } else {\n        element.groupIds\n          .flatMap((gid) => getElementsInGroup(allElements, gid))\n          .forEach((element) => elementsToFilter.add(element));\n      }\n    }\n  }\n\n  const elementsToRemove = new Set<ExcalidrawElement>();\n\n  const elementsMap = arrayToMap(allElements);\n\n  elementsToFilter.forEach((element) => {\n    if (\n      element.frameId &&\n      !isFrameLikeElement(element) &&\n      !isElementInFrame(element, elementsMap, appState)\n    ) {\n      elementsToRemove.add(element);\n    }\n  });\n\n  if (elementsToRemove.size > 0) {\n    removeElementsFromFrame(elementsToRemove, elementsMap);\n  }\n  return allElements;\n};\n\n/**\n * filters out elements that are inside groups that contain a frame element\n * anywhere in the group tree\n */\nexport const omitGroupsContainingFrameLikes = (\n  allElements: ElementsMapOrArray,\n  /** subset of elements you want to filter. Optional perf optimization so we\n   * don't have to filter all elements unnecessarily\n   */\n  selectedElements?: readonly ExcalidrawElement[],\n) => {\n  const uniqueGroupIds = new Set<string>();\n  const elements = selectedElements || allElements;\n\n  for (const el of elements.values()) {\n    const topMostGroupId = el.groupIds[el.groupIds.length - 1];\n    if (topMostGroupId) {\n      uniqueGroupIds.add(topMostGroupId);\n    }\n  }\n\n  const rejectedGroupIds = new Set<string>();\n  for (const groupId of uniqueGroupIds) {\n    if (\n      getElementsInGroup(allElements, groupId).some((el) =>\n        isFrameLikeElement(el),\n      )\n    ) {\n      rejectedGroupIds.add(groupId);\n    }\n  }\n\n  const ret: ExcalidrawElement[] = [];\n\n  for (const element of elements.values()) {\n    if (!rejectedGroupIds.has(element.groupIds[element.groupIds.length - 1])) {\n      ret.push(element);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * depending on the appState, return target frame, which is the frame the given element\n * is going to be added to or remove from\n */\nexport const getTargetFrame = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  appState: StaticCanvasAppState,\n) => {\n  const _element = isTextElement(element)\n    ? getContainerElement(element, elementsMap) || element\n    : element;\n\n  // if the element and its containing frame are both selected, then\n  // the containing frame is the target frame\n  if (\n    _element.frameId &&\n    appState.selectedElementIds[_element.id] &&\n    appState.selectedElementIds[_element.frameId]\n  ) {\n    return getContainingFrame(_element, elementsMap);\n  }\n\n  return appState.selectedElementIds[_element.id] &&\n    appState.selectedElementsAreBeingDragged\n    ? appState.frameToHighlight\n    : getContainingFrame(_element, elementsMap);\n};\n\n// TODO: this a huge bottleneck for large scenes, optimise\n// given an element, return if the element is in some frame\nexport const isElementInFrame = (\n  element: ExcalidrawElement,\n  allElementsMap: ElementsMap,\n  appState: StaticCanvasAppState,\n  opts?: {\n    targetFrame?: ExcalidrawFrameLikeElement;\n    checkedGroups?: Map<string, boolean>;\n  },\n) => {\n  const frame =\n    opts?.targetFrame ?? getTargetFrame(element, allElementsMap, appState);\n\n  if (!frame) {\n    return false;\n  }\n\n  const _element = isTextElement(element)\n    ? getContainerElement(element, allElementsMap) || element\n    : element;\n\n  const setGroupsInFrame = (isInFrame: boolean) => {\n    if (opts?.checkedGroups) {\n      _element.groupIds.forEach((groupId) => {\n        opts.checkedGroups?.set(groupId, isInFrame);\n      });\n    }\n  };\n\n  if (\n    // if the element is not selected, or it is selected but not being dragged,\n    // frame membership won't update, so return true\n    !appState.selectedElementIds[_element.id] ||\n    !appState.selectedElementsAreBeingDragged ||\n    // if both frame and element are selected, won't update membership, so return true\n    (appState.selectedElementIds[_element.id] &&\n      appState.selectedElementIds[frame.id])\n  ) {\n    return true;\n  }\n\n  if (_element.groupIds.length === 0) {\n    return elementOverlapsWithFrame(_element, frame, allElementsMap);\n  }\n\n  for (const gid of _element.groupIds) {\n    if (opts?.checkedGroups?.has(gid)) {\n      return opts.checkedGroups.get(gid)!!;\n    }\n  }\n\n  const allElementsInGroup = new Set(\n    _element.groupIds\n      .filter((gid) => {\n        if (opts?.checkedGroups) {\n          return !opts.checkedGroups.has(gid);\n        }\n        return true;\n      })\n      .flatMap((gid) => getElementsInGroup(allElementsMap, gid)),\n  );\n\n  if (appState.editingGroupId && appState.selectedElementsAreBeingDragged) {\n    const selectedElements = new Set(\n      getSelectedElements(allElementsMap, appState),\n    );\n\n    const editingGroupOverlapsFrame = appState.frameToHighlight !== null;\n\n    if (editingGroupOverlapsFrame) {\n      return true;\n    }\n\n    selectedElements.forEach((selectedElement) => {\n      allElementsInGroup.delete(selectedElement);\n    });\n  }\n\n  for (const elementInGroup of allElementsInGroup) {\n    if (isFrameLikeElement(elementInGroup)) {\n      setGroupsInFrame(false);\n      return false;\n    }\n  }\n\n  for (const elementInGroup of allElementsInGroup) {\n    if (elementOverlapsWithFrame(elementInGroup, frame, allElementsMap)) {\n      setGroupsInFrame(true);\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport const shouldApplyFrameClip = (\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  appState: StaticCanvasAppState,\n  elementsMap: ElementsMap,\n  checkedGroups?: Map<string, boolean>,\n) => {\n  if (!appState.frameRendering || !appState.frameRendering.clip) {\n    return false;\n  }\n\n  // for individual elements, only clip when the element is\n  // a. overlapping with the frame, or\n  // b. containing the frame, for example when an element is used as a background\n  //    and is therefore bigger than the frame and completely contains the frame\n  const shouldClipElementItself =\n    isElementIntersectingFrame(element, frame, elementsMap) ||\n    isElementContainingFrame(element, frame, elementsMap);\n\n  if (shouldClipElementItself) {\n    for (const groupId of element.groupIds) {\n      checkedGroups?.set(groupId, true);\n    }\n\n    return true;\n  }\n\n  // if an element is outside the frame, but is part of a group that has some elements\n  // \"in\" the frame, we should clip the element\n  if (\n    !shouldClipElementItself &&\n    element.groupIds.length > 0 &&\n    !elementsAreInFrameBounds([element], frame, elementsMap)\n  ) {\n    let shouldClip = false;\n\n    // if no elements are being dragged, we can skip the geometry check\n    // because we know if the element is in the given frame or not\n    if (!appState.selectedElementsAreBeingDragged) {\n      shouldClip = element.frameId === frame.id;\n      for (const groupId of element.groupIds) {\n        checkedGroups?.set(groupId, shouldClip);\n      }\n    } else {\n      shouldClip = isElementInFrame(element, elementsMap, appState, {\n        targetFrame: frame,\n        checkedGroups,\n      });\n    }\n\n    for (const groupId of element.groupIds) {\n      checkedGroups?.set(groupId, shouldClip);\n    }\n\n    return shouldClip;\n  }\n\n  return false;\n};\n\nconst DEFAULT_FRAME_NAME = \"Frame\";\nconst DEFAULT_AI_FRAME_NAME = \"AI Frame\";\n\nexport const getDefaultFrameName = (element: ExcalidrawFrameLikeElement) => {\n  // TODO name frames \"AI\" only if specific to AI frames\n  return isFrameElement(element) ? DEFAULT_FRAME_NAME : DEFAULT_AI_FRAME_NAME;\n};\n\nexport const getFrameLikeTitle = (element: ExcalidrawFrameLikeElement) => {\n  return element.name === null ? getDefaultFrameName(element) : element.name;\n};\n\nexport const getElementsOverlappingFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  return (\n    elementsOverlappingBBox({\n      elements,\n      bounds: frame,\n      type: \"overlap\",\n    })\n      // removes elements who are overlapping, but are in a different frame,\n      // and thus invisible in target frame\n      .filter((el) => !el.frameId || el.frameId === frame.id)\n  );\n};\n\nexport const frameAndChildrenSelectedTogether = (\n  selectedElements: readonly ExcalidrawElement[],\n) => {\n  const selectedElementsMap = arrayToMap(selectedElements);\n\n  return (\n    selectedElements.length > 1 &&\n    selectedElements.some(\n      (element) => element.frameId && selectedElementsMap.has(element.frameId),\n    )\n  );\n};\n",
    "import {\n  vectorCross,\n  vectorFromPoint,\n  type GlobalPoint,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport type { Bounds } from \"@excalidraw/element\";\n\nexport type LineSegment<P extends LocalPoint | GlobalPoint> = [P, P];\n\nexport function getBBox<P extends LocalPoint | GlobalPoint>(\n  line: LineSegment<P>,\n): Bounds {\n  return [\n    Math.min(line[0][0], line[1][0]),\n    Math.min(line[0][1], line[1][1]),\n    Math.max(line[0][0], line[1][0]),\n    Math.max(line[0][1], line[1][1]),\n  ];\n}\n\nexport function doBBoxesIntersect(a: Bounds, b: Bounds) {\n  return a[0] <= b[2] && a[2] >= b[0] && a[1] <= b[3] && a[3] >= b[1];\n}\n\nconst EPSILON = 0.000001;\n\nexport function isPointOnLine<P extends GlobalPoint | LocalPoint>(\n  l: LineSegment<P>,\n  p: P,\n) {\n  const p1 = vectorFromPoint(l[1], l[0]);\n  const p2 = vectorFromPoint(p, l[0]);\n\n  const r = vectorCross(p1, p2);\n\n  return Math.abs(r) < EPSILON;\n}\n\nexport function isPointRightOfLine<P extends GlobalPoint | LocalPoint>(\n  l: LineSegment<P>,\n  p: P,\n) {\n  const p1 = vectorFromPoint(l[1], l[0]);\n  const p2 = vectorFromPoint(p, l[0]);\n\n  return vectorCross(p1, p2) < 0;\n}\n\nexport function isLineSegmentTouchingOrCrossingLine<\n  P extends GlobalPoint | LocalPoint,\n>(a: LineSegment<P>, b: LineSegment<P>) {\n  return (\n    isPointOnLine(a, b[0]) ||\n    isPointOnLine(a, b[1]) ||\n    (isPointRightOfLine(a, b[0])\n      ? !isPointRightOfLine(a, b[1])\n      : isPointRightOfLine(a, b[1]))\n  );\n}\n\n// https://martin-thoma.com/how-to-check-if-two-line-segments-intersect/\nexport function doLineSegmentsIntersect<P extends GlobalPoint | LocalPoint>(\n  a: LineSegment<P>,\n  b: LineSegment<P>,\n) {\n  return (\n    doBBoxesIntersect(getBBox(a), getBBox(b)) &&\n    isLineSegmentTouchingOrCrossingLine(a, b) &&\n    isLineSegmentTouchingOrCrossingLine(b, a)\n  );\n}\n",
    "import { arrayToMap } from \"@excalidraw/common\";\nimport { getElementBounds } from \"@excalidraw/element\";\nimport {\n  isArrowElement,\n  isExcalidrawElement,\n  isFreeDrawElement,\n  isLinearElement,\n  isTextElement,\n} from \"@excalidraw/element\";\nimport {\n  rangeIncludesValue,\n  pointFrom,\n  pointRotateRads,\n  rangeInclusive,\n} from \"@excalidraw/math\";\n\nimport type { Bounds } from \"@excalidraw/element\";\nimport type {\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\nimport type { LocalPoint } from \"@excalidraw/math\";\n\ntype Element = NonDeletedExcalidrawElement;\ntype Elements = readonly NonDeletedExcalidrawElement[];\n\ntype Points = readonly LocalPoint[];\n\n/** @returns vertices relative to element's top-left [0,0] position  */\nconst getNonLinearElementRelativePoints = (\n  element: Exclude<\n    Element,\n    ExcalidrawLinearElement | ExcalidrawFreeDrawElement\n  >,\n): [\n  TopLeft: LocalPoint,\n  TopRight: LocalPoint,\n  BottomRight: LocalPoint,\n  BottomLeft: LocalPoint,\n] => {\n  if (element.type === \"diamond\") {\n    return [\n      pointFrom(element.width / 2, 0),\n      pointFrom(element.width, element.height / 2),\n      pointFrom(element.width / 2, element.height),\n      pointFrom(0, element.height / 2),\n    ];\n  }\n  return [\n    pointFrom(0, 0),\n    pointFrom(0 + element.width, 0),\n    pointFrom(0 + element.width, element.height),\n    pointFrom(0, element.height),\n  ];\n};\n\n/** @returns vertices relative to element's top-left [0,0] position  */\nconst getElementRelativePoints = (element: ExcalidrawElement): Points => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return element.points;\n  }\n  return getNonLinearElementRelativePoints(element);\n};\n\nconst getMinMaxPoints = (points: Points) => {\n  const ret = points.reduce(\n    (limits, [x, y]) => {\n      limits.minY = Math.min(limits.minY, y);\n      limits.minX = Math.min(limits.minX, x);\n\n      limits.maxX = Math.max(limits.maxX, x);\n      limits.maxY = Math.max(limits.maxY, y);\n\n      return limits;\n    },\n    {\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity,\n      cx: 0,\n      cy: 0,\n    },\n  );\n\n  ret.cx = (ret.maxX + ret.minX) / 2;\n  ret.cy = (ret.maxY + ret.minY) / 2;\n\n  return ret;\n};\n\nconst getRotatedBBox = (element: Element): Bounds => {\n  const points = getElementRelativePoints(element);\n\n  const { cx, cy } = getMinMaxPoints(points);\n  const centerPoint = pointFrom<LocalPoint>(cx, cy);\n\n  const rotatedPoints = points.map((p) =>\n    pointRotateRads(p, centerPoint, element.angle),\n  );\n  const { minX, minY, maxX, maxY } = getMinMaxPoints(rotatedPoints);\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const isElementInsideBBox = (\n  element: Element,\n  bbox: Bounds,\n  eitherDirection = false,\n): boolean => {\n  const elementBBox = getRotatedBBox(element);\n\n  const elementInsideBbox =\n    bbox[0] <= elementBBox[0] &&\n    bbox[2] >= elementBBox[2] &&\n    bbox[1] <= elementBBox[1] &&\n    bbox[3] >= elementBBox[3];\n\n  if (!eitherDirection) {\n    return elementInsideBbox;\n  }\n\n  if (elementInsideBbox) {\n    return true;\n  }\n\n  return (\n    elementBBox[0] <= bbox[0] &&\n    elementBBox[2] >= bbox[2] &&\n    elementBBox[1] <= bbox[1] &&\n    elementBBox[3] >= bbox[3]\n  );\n};\n\nexport const elementPartiallyOverlapsWithOrContainsBBox = (\n  element: Element,\n  bbox: Bounds,\n): boolean => {\n  const elementBBox = getRotatedBBox(element);\n\n  return (\n    (rangeIncludesValue(elementBBox[0], rangeInclusive(bbox[0], bbox[2])) ||\n      rangeIncludesValue(\n        bbox[0],\n        rangeInclusive(elementBBox[0], elementBBox[2]),\n      )) &&\n    (rangeIncludesValue(elementBBox[1], rangeInclusive(bbox[1], bbox[3])) ||\n      rangeIncludesValue(\n        bbox[1],\n        rangeInclusive(elementBBox[1], elementBBox[3]),\n      ))\n  );\n};\n\nexport const elementsOverlappingBBox = ({\n  elements,\n  bounds,\n  type,\n  errorMargin = 0,\n}: {\n  elements: Elements;\n  bounds: Bounds | ExcalidrawElement;\n  /** safety offset. Defaults to 0. */\n  errorMargin?: number;\n  /**\n   * - overlap: elements overlapping or inside bounds\n   * - contain: elements inside bounds or bounds inside elements\n   * - inside: elements inside bounds\n   **/\n  type: \"overlap\" | \"contain\" | \"inside\";\n}) => {\n  if (isExcalidrawElement(bounds)) {\n    bounds = getElementBounds(bounds, arrayToMap(elements));\n  }\n  const adjustedBBox: Bounds = [\n    bounds[0] - errorMargin,\n    bounds[1] - errorMargin,\n    bounds[2] + errorMargin,\n    bounds[3] + errorMargin,\n  ];\n\n  const includedElementSet = new Set<string>();\n\n  for (const element of elements) {\n    if (includedElementSet.has(element.id)) {\n      continue;\n    }\n\n    const isOverlaping =\n      type === \"overlap\"\n        ? elementPartiallyOverlapsWithOrContainsBBox(element, adjustedBBox)\n        : type === \"inside\"\n        ? isElementInsideBBox(element, adjustedBBox)\n        : isElementInsideBBox(element, adjustedBBox, true);\n\n    if (isOverlaping) {\n      includedElementSet.add(element.id);\n\n      if (element.boundElements) {\n        for (const boundElement of element.boundElements) {\n          includedElementSet.add(boundElement.id);\n        }\n      }\n\n      if (isTextElement(element) && element.containerId) {\n        includedElementSet.add(element.containerId);\n      }\n\n      if (isArrowElement(element)) {\n        if (element.startBinding) {\n          includedElementSet.add(element.startBinding.elementId);\n        }\n\n        if (element.endBinding) {\n          includedElementSet.add(element.endBinding?.elementId);\n        }\n      }\n    }\n  }\n\n  return elements.filter((element) => includedElementSet.has(element.id));\n};\n",
    "import { arrayToMap, isShallowEqual } from \"@excalidraw/common\";\n\nimport type {\n  AppState,\n  InteractiveCanvasAppState,\n} from \"excalidraw-custom/types\";\n\nimport { getElementAbsoluteCoords, getElementBounds } from \"./bounds\";\nimport { isElementInViewport } from \"./sizeHelpers\";\nimport {\n  isBoundToContainer,\n  isFrameLikeElement,\n  isLinearElement,\n} from \"./typeChecks\";\nimport {\n  elementOverlapsWithFrame,\n  getContainingFrame,\n  getFrameChildren,\n} from \"./frame\";\n\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { selectGroupsForSelectedElements } from \"./groups\";\n\nimport type {\n  ElementsMap,\n  ElementsMapOrArray,\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\n/**\n * Frames and their containing elements are not to be selected at the same time.\n * Given an array of selected elements, if there are frames and their containing elements\n * we only keep the frames.\n * @param selectedElements\n */\nexport const excludeElementsInFramesFromSelection = <\n  T extends ExcalidrawElement,\n>(\n  selectedElements: readonly T[],\n) => {\n  const framesInSelection = new Set<T[\"id\"]>();\n\n  selectedElements.forEach((element) => {\n    if (isFrameLikeElement(element)) {\n      framesInSelection.add(element.id);\n    }\n  });\n\n  return selectedElements.filter((element) => {\n    if (element.frameId && framesInSelection.has(element.frameId)) {\n      return false;\n    }\n    return true;\n  });\n};\n\nexport const getElementsWithinSelection = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selection: NonDeletedExcalidrawElement,\n  elementsMap: ElementsMap,\n  excludeElementsInFrames: boolean = true,\n) => {\n  const [selectionX1, selectionY1, selectionX2, selectionY2] =\n    getElementAbsoluteCoords(selection, elementsMap);\n\n  let elementsInSelection = elements.filter((element) => {\n    let [elementX1, elementY1, elementX2, elementY2] = getElementBounds(\n      element,\n      elementsMap,\n    );\n\n    const containingFrame = getContainingFrame(element, elementsMap);\n    if (containingFrame) {\n      const [fx1, fy1, fx2, fy2] = getElementBounds(\n        containingFrame,\n        elementsMap,\n      );\n\n      elementX1 = Math.max(fx1, elementX1);\n      elementY1 = Math.max(fy1, elementY1);\n      elementX2 = Math.min(fx2, elementX2);\n      elementY2 = Math.min(fy2, elementY2);\n    }\n\n    return (\n      element.locked === false &&\n      element.type !== \"selection\" &&\n      !isBoundToContainer(element) &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2\n    );\n  });\n\n  elementsInSelection = excludeElementsInFrames\n    ? excludeElementsInFramesFromSelection(elementsInSelection)\n    : elementsInSelection;\n\n  elementsInSelection = elementsInSelection.filter((element) => {\n    const containingFrame = getContainingFrame(element, elementsMap);\n\n    if (containingFrame) {\n      return elementOverlapsWithFrame(element, containingFrame, elementsMap);\n    }\n\n    return true;\n  });\n\n  return elementsInSelection;\n};\n\nexport const getVisibleAndNonSelectedElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  const selectedElementsSet = new Set(\n    selectedElements.map((element) => element.id),\n  );\n  return elements.filter((element) => {\n    const isVisible = isElementInViewport(\n      element,\n      appState.width,\n      appState.height,\n      appState,\n      elementsMap,\n    );\n\n    return !selectedElementsSet.has(element.id) && isVisible;\n  });\n};\n\n// FIXME move this into the editor instance to keep utility methods stateless\nexport const isSomeElementSelected = (function () {\n  let lastElements: readonly NonDeletedExcalidrawElement[] | null = null;\n  let lastSelectedElementIds: AppState[\"selectedElementIds\"] | null = null;\n  let isSelected: boolean | null = null;\n\n  const ret = (\n    elements: readonly NonDeletedExcalidrawElement[],\n    appState: Pick<AppState, \"selectedElementIds\">,\n  ): boolean => {\n    if (\n      isSelected != null &&\n      elements === lastElements &&\n      appState.selectedElementIds === lastSelectedElementIds\n    ) {\n      return isSelected;\n    }\n\n    isSelected = elements.some(\n      (element) => appState.selectedElementIds[element.id],\n    );\n    lastElements = elements;\n    lastSelectedElementIds = appState.selectedElementIds;\n\n    return isSelected;\n  };\n\n  ret.clearCache = () => {\n    lastElements = null;\n    lastSelectedElementIds = null;\n    isSelected = null;\n  };\n\n  return ret;\n})();\n\nexport const getSelectedElements = (\n  elements: ElementsMapOrArray,\n  appState: Pick<InteractiveCanvasAppState, \"selectedElementIds\">,\n  opts?: {\n    includeBoundTextElement?: boolean;\n    includeElementsInFrames?: boolean;\n  },\n) => {\n  const addedElements = new Set<ExcalidrawElement[\"id\"]>();\n  const selectedElements: ExcalidrawElement[] = [];\n  for (const element of elements.values()) {\n    if (appState.selectedElementIds[element.id]) {\n      selectedElements.push(element);\n      addedElements.add(element.id);\n      continue;\n    }\n    if (\n      opts?.includeBoundTextElement &&\n      isBoundToContainer(element) &&\n      appState.selectedElementIds[element?.containerId]\n    ) {\n      selectedElements.push(element);\n      addedElements.add(element.id);\n      continue;\n    }\n  }\n\n  if (opts?.includeElementsInFrames) {\n    const elementsToInclude: ExcalidrawElement[] = [];\n    selectedElements.forEach((element) => {\n      if (isFrameLikeElement(element)) {\n        getFrameChildren(elements, element.id).forEach(\n          (e) => !addedElements.has(e.id) && elementsToInclude.push(e),\n        );\n      }\n      elementsToInclude.push(element);\n    });\n\n    return elementsToInclude;\n  }\n\n  return selectedElements;\n};\n\nexport const getTargetElements = (\n  elements: ElementsMapOrArray,\n  appState: Pick<\n    AppState,\n    \"selectedElementIds\" | \"editingTextElement\" | \"newElement\"\n  >,\n) =>\n  appState.editingTextElement\n    ? [appState.editingTextElement]\n    : appState.newElement\n    ? [appState.newElement]\n    : getSelectedElements(elements, appState, {\n        includeBoundTextElement: true,\n      });\n\n/**\n * returns prevState's selectedElementids if no change from previous, so as to\n * retain reference identity for memoization\n */\nexport const makeNextSelectedElementIds = (\n  nextSelectedElementIds: AppState[\"selectedElementIds\"],\n  prevState: Pick<AppState, \"selectedElementIds\">,\n) => {\n  if (isShallowEqual(prevState.selectedElementIds, nextSelectedElementIds)) {\n    return prevState.selectedElementIds;\n  }\n\n  return nextSelectedElementIds;\n};\n\nconst _getLinearElementEditor = (\n  targetElements: readonly ExcalidrawElement[],\n  allElements: readonly NonDeletedExcalidrawElement[],\n) => {\n  const linears = targetElements.filter(isLinearElement);\n  if (linears.length === 1) {\n    const linear = linears[0];\n    const boundElements = linear.boundElements?.map((def) => def.id) ?? [];\n    const onlySingleLinearSelected = targetElements.every(\n      (el) => el.id === linear.id || boundElements.includes(el.id),\n    );\n\n    if (onlySingleLinearSelected) {\n      return new LinearElementEditor(linear, arrayToMap(allElements));\n    }\n  }\n\n  return null;\n};\n\nexport const getSelectionStateForElements = (\n  targetElements: readonly ExcalidrawElement[],\n  allElements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  return {\n    selectedLinearElement: _getLinearElementEditor(targetElements, allElements),\n    ...selectGroupsForSelectedElements(\n      {\n        editingGroupId: appState.editingGroupId,\n        selectedElementIds: excludeElementsInFramesFromSelection(\n          targetElements,\n        ).reduce((acc: Record<ExcalidrawElement[\"id\"], true>, element) => {\n          if (!isBoundToContainer(element)) {\n            acc[element.id] = true;\n          }\n          return acc;\n        }, {}),\n      },\n      allElements,\n      appState,\n      null,\n    ),\n  };\n};\n",
    "import type {\n  AppClassProperties,\n  AppState,\n  InteractiveCanvasAppState,\n} from \"excalidraw-custom/types\";\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport { getBoundTextElement } from \"./textElement\";\n\nimport { makeNextSelectedElementIds, getSelectedElements } from \"./selection\";\n\nimport type {\n  GroupId,\n  ExcalidrawElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  ElementsMapOrArray,\n  ElementsMap,\n} from \"./types\";\n\nexport const selectGroup = (\n  groupId: GroupId,\n  appState: InteractiveCanvasAppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): Pick<\n  InteractiveCanvasAppState,\n  \"selectedGroupIds\" | \"selectedElementIds\" | \"editingGroupId\"\n> => {\n  const elementsInGroup = elements.reduce(\n    (acc: Record<string, true>, element) => {\n      if (element.groupIds.includes(groupId)) {\n        acc[element.id] = true;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  if (Object.keys(elementsInGroup).length < 2) {\n    if (\n      appState.selectedGroupIds[groupId] ||\n      appState.editingGroupId === groupId\n    ) {\n      return {\n        selectedElementIds: appState.selectedElementIds,\n        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },\n        editingGroupId: null,\n      };\n    }\n    return appState;\n  }\n\n  return {\n    editingGroupId: appState.editingGroupId,\n    selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },\n    selectedElementIds: {\n      ...appState.selectedElementIds,\n      ...elementsInGroup,\n    },\n  };\n};\n\nexport const selectGroupsForSelectedElements = (function () {\n  type SelectGroupsReturnType = Pick<\n    InteractiveCanvasAppState,\n    \"selectedGroupIds\" | \"editingGroupId\" | \"selectedElementIds\"\n  >;\n\n  let lastSelectedElements: readonly NonDeleted<ExcalidrawElement>[] | null =\n    null;\n  let lastElements: readonly NonDeleted<ExcalidrawElement>[] | null = null;\n  let lastReturnValue: SelectGroupsReturnType | null = null;\n\n  const _selectGroups = (\n    selectedElements: readonly NonDeleted<ExcalidrawElement>[],\n    elements: readonly NonDeleted<ExcalidrawElement>[],\n    appState: Pick<AppState, \"selectedElementIds\" | \"editingGroupId\">,\n    prevAppState: InteractiveCanvasAppState,\n  ): SelectGroupsReturnType => {\n    if (\n      lastReturnValue !== undefined &&\n      elements === lastElements &&\n      selectedElements === lastSelectedElements &&\n      appState.editingGroupId === lastReturnValue?.editingGroupId\n    ) {\n      return lastReturnValue;\n    }\n\n    const selectedGroupIds: Record<GroupId, boolean> = {};\n    // Gather all the groups withing selected elements\n    for (const selectedElement of selectedElements) {\n      let groupIds = selectedElement.groupIds;\n      if (appState.editingGroupId) {\n        // handle the case where a group is nested within a group\n        const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n        if (indexOfEditingGroup > -1) {\n          groupIds = groupIds.slice(0, indexOfEditingGroup);\n        }\n      }\n      if (groupIds.length > 0) {\n        const lastSelectedGroup = groupIds[groupIds.length - 1];\n        selectedGroupIds[lastSelectedGroup] = true;\n      }\n    }\n\n    // Gather all the elements within selected groups\n    const groupElementsIndex: Record<GroupId, string[]> = {};\n    const selectedElementIdsInGroups = elements.reduce(\n      (acc: Record<string, true>, element) => {\n        if (element.isDeleted) {\n          return acc;\n        }\n\n        const groupId = element.groupIds.find((id) => selectedGroupIds[id]);\n\n        if (groupId) {\n          acc[element.id] = true;\n\n          // Populate the index\n          if (!Array.isArray(groupElementsIndex[groupId])) {\n            groupElementsIndex[groupId] = [element.id];\n          } else {\n            groupElementsIndex[groupId].push(element.id);\n          }\n        }\n        return acc;\n      },\n      {},\n    );\n\n    for (const groupId of Object.keys(groupElementsIndex)) {\n      // If there is one element in the group, and the group is selected or it's being edited, it's not a group\n      if (groupElementsIndex[groupId].length < 2) {\n        if (selectedGroupIds[groupId]) {\n          selectedGroupIds[groupId] = false;\n        }\n      }\n    }\n\n    lastElements = elements;\n    lastSelectedElements = selectedElements;\n\n    lastReturnValue = {\n      editingGroupId: appState.editingGroupId,\n      selectedGroupIds,\n      selectedElementIds: makeNextSelectedElementIds(\n        {\n          ...appState.selectedElementIds,\n          ...selectedElementIdsInGroups,\n        },\n        prevAppState,\n      ),\n    };\n\n    return lastReturnValue;\n  };\n\n  /**\n   * When you select an element, you often want to actually select the whole group it's in, unless\n   * you're currently editing that group.\n   */\n  const selectGroupsForSelectedElements = (\n    appState: Pick<AppState, \"selectedElementIds\" | \"editingGroupId\">,\n    elements: readonly NonDeletedExcalidrawElement[],\n    prevAppState: InteractiveCanvasAppState,\n    /**\n     * supply null in cases where you don't have access to App instance and\n     * you don't care about optimizing selectElements retrieval\n     */\n    app: AppClassProperties | null,\n  ): Mutable<\n    Pick<\n      InteractiveCanvasAppState,\n      \"selectedGroupIds\" | \"editingGroupId\" | \"selectedElementIds\"\n    >\n  > => {\n    const selectedElements = app\n      ? app.scene.getSelectedElements({\n          selectedElementIds: appState.selectedElementIds,\n          // supplying elements explicitly in case we're passed non-state elements\n          elements,\n        })\n      : getSelectedElements(elements, appState);\n\n    if (!selectedElements.length) {\n      return {\n        selectedGroupIds: {},\n        editingGroupId: null,\n        selectedElementIds: makeNextSelectedElementIds(\n          appState.selectedElementIds,\n          prevAppState,\n        ),\n      };\n    }\n\n    return _selectGroups(selectedElements, elements, appState, prevAppState);\n  };\n\n  selectGroupsForSelectedElements.clearCache = () => {\n    lastElements = null;\n    lastSelectedElements = null;\n    lastReturnValue = null;\n  };\n\n  return selectGroupsForSelectedElements;\n})();\n\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\nexport const isSelectedViaGroup = (\n  appState: InteractiveCanvasAppState,\n  element: ExcalidrawElement,\n) => getSelectedGroupForElement(appState, element) != null;\n\nexport const getSelectedGroupForElement = (\n  appState: Pick<\n    InteractiveCanvasAppState,\n    \"editingGroupId\" | \"selectedGroupIds\"\n  >,\n  element: ExcalidrawElement,\n) =>\n  element.groupIds\n    .filter((groupId) => groupId !== appState.editingGroupId)\n    .find((groupId) => appState.selectedGroupIds[groupId]);\n\nexport const getSelectedGroupIds = (\n  appState: InteractiveCanvasAppState,\n): GroupId[] =>\n  Object.entries(appState.selectedGroupIds)\n    .filter(([groupId, isSelected]) => isSelected)\n    .map(([groupId, isSelected]) => groupId);\n\n// given a list of elements, return the the actual group ids that should be selected\n// or used to update the elements\nexport const selectGroupsFromGivenElements = (\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n  appState: InteractiveCanvasAppState,\n) => {\n  let nextAppState: InteractiveCanvasAppState = {\n    ...appState,\n    selectedGroupIds: {},\n  };\n\n  for (const element of elements) {\n    let groupIds = element.groupIds;\n    if (appState.editingGroupId) {\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = {\n        ...nextAppState,\n        ...selectGroup(groupId, nextAppState, elements),\n      };\n    }\n  }\n\n  return nextAppState.selectedGroupIds;\n};\n\nexport const editGroupForSelectedElement = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n): AppState => {\n  return {\n    ...appState,\n    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,\n    selectedGroupIds: {},\n    selectedElementIds: {\n      [element.id]: true,\n    },\n  };\n};\n\nexport const isElementInGroup = (element: ExcalidrawElement, groupId: string) =>\n  element.groupIds.includes(groupId);\n\nexport const getElementsInGroup = (\n  elements: ElementsMapOrArray,\n  groupId: string,\n) => {\n  const elementsInGroup: ExcalidrawElement[] = [];\n  for (const element of elements.values()) {\n    if (isElementInGroup(element, groupId)) {\n      elementsInGroup.push(element);\n    }\n  }\n  return elementsInGroup;\n};\n\nexport const getSelectedGroupIdForElement = (\n  element: ExcalidrawElement,\n  selectedGroupIds: { [groupId: string]: boolean },\n) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);\n\nexport const addToGroup = (\n  prevGroupIds: ExcalidrawElement[\"groupIds\"],\n  newGroupId: GroupId,\n  editingGroupId: AppState[\"editingGroupId\"],\n) => {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const positionToInsert =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n};\n\nexport const removeFromSelectedGroups = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  selectedGroupIds: { [groupId: string]: boolean },\n) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n  elementsMap: ElementsMap,\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    // Include bound text if present when grouping\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n    if (boundTextElement) {\n      currentGroupMembers.push(boundTextElement);\n    }\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nexport const getNonDeletedGroupIds = (elements: ElementsMap) => {\n  const nonDeletedGroupIds = new Set<string>();\n\n  for (const [, element] of elements) {\n    // defensive check\n    if (element.isDeleted) {\n      continue;\n    }\n\n    // defensive fallback\n    for (const groupId of element.groupIds ?? []) {\n      nonDeletedGroupIds.add(groupId);\n    }\n  }\n\n  return nonDeletedGroupIds;\n};\n\nexport const elementsAreInSameGroup = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  const allGroups = elements.flatMap((element) => element.groupIds);\n  const groupCount = new Map<string, number>();\n  let maxGroup = 0;\n\n  for (const group of allGroups) {\n    groupCount.set(group, (groupCount.get(group) ?? 0) + 1);\n    if (groupCount.get(group)! > maxGroup) {\n      maxGroup = groupCount.get(group)!;\n    }\n  }\n\n  return maxGroup === elements.length;\n};\n\nexport const isInGroup = (element: NonDeletedExcalidrawElement) => {\n  return element.groupIds.length > 0;\n};\n\nexport const getNewGroupIdsForDuplication = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  editingGroupId: AppState[\"editingGroupId\"],\n  mapper: (groupId: GroupId) => GroupId,\n) => {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const endIndex =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  for (let index = 0; index < endIndex; index++) {\n    copy[index] = mapper(copy[index]);\n  }\n\n  return copy;\n};\n",
    "import type { ElementOrToolType } from \"excalidraw-custom/types\";\n\nexport const hasBackground = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"line\" ||\n  type === \"freedraw\";\n\nexport const hasStrokeColor = (type: ElementOrToolType) =>\n  type !== \"image\" && type !== \"frame\" && type !== \"magicframe\";\n\nexport const hasStrokeWidth = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"freedraw\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const hasStrokeStyle = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const canChangeRoundness = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"line\" ||\n  type === \"diamond\" ||\n  type === \"image\";\n\nexport const toolIsArrow = (type: ElementOrToolType) => type === \"arrow\";\n\nexport const canHaveArrowheads = (type: ElementOrToolType) => type === \"arrow\";\n",
    "import { updateBoundElements } from \"./binding\";\nimport { getCommonBoundingBox } from \"./bounds\";\nimport { getMaximumGroups } from \"./groups\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { BoundingBox } from \"./bounds\";\nimport type { ExcalidrawElement } from \"./types\";\n\nexport interface Alignment {\n  position: \"start\" | \"center\" | \"end\";\n  axis: \"x\" | \"y\";\n}\n\nexport const alignElements = (\n  selectedElements: ExcalidrawElement[],\n  alignment: Alignment,\n  scene: Scene,\n): ExcalidrawElement[] => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const groups: ExcalidrawElement[][] = getMaximumGroups(\n    selectedElements,\n    elementsMap,\n  );\n  const selectionBoundingBox = getCommonBoundingBox(selectedElements);\n\n  return groups.flatMap((group) => {\n    const translation = calculateTranslation(\n      group,\n      selectionBoundingBox,\n      alignment,\n    );\n    return group.map((element) => {\n      // update element\n      const updatedEle = scene.mutateElement(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      });\n\n      // update bound elements\n      updateBoundElements(element, scene, {\n        simultaneouslyUpdated: group,\n      });\n      return updatedEle;\n    });\n  });\n};\n\nconst calculateTranslation = (\n  group: ExcalidrawElement[],\n  selectionBoundingBox: BoundingBox,\n  { axis, position }: Alignment,\n): { x: number; y: number } => {\n  const groupBoundingBox = getCommonBoundingBox(group);\n\n  const [min, max]: [\"minX\" | \"minY\", \"maxX\" | \"maxY\"] =\n    axis === \"x\" ? [\"minX\", \"maxX\"] : [\"minY\", \"maxY\"];\n\n  const noTranslation = { x: 0, y: 0 };\n  if (position === \"start\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[min] - groupBoundingBox[min],\n    };\n  } else if (position === \"end\") {\n    return {\n      ...noTranslation,\n      [axis]: selectionBoundingBox[max] - groupBoundingBox[max],\n    };\n  } // else if (position === \"center\") {\n  return {\n    ...noTranslation,\n    [axis]:\n      (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 -\n      (groupBoundingBox[min] + groupBoundingBox[max]) / 2,\n  };\n};\n",
    "import {\n  arrayToMap,\n  arrayToObject,\n  assertNever,\n  isDevEnv,\n  isShallowEqual,\n  isTestEnv,\n  randomInteger,\n} from \"@excalidraw/common\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeleted,\n  Ordered,\n  OrderedExcalidrawElement,\n  SceneElementsMap,\n} from \"@excalidraw/element/types\";\n\nimport type {\n  DTO,\n  Mutable,\n  SubtypeOf,\n  ValueOf,\n} from \"@excalidraw/common/utility-types\";\n\nimport type {\n  AppState,\n  ObservedAppState,\n  ObservedElementsAppState,\n  ObservedStandaloneAppState,\n} from \"excalidraw-custom/types\";\n\nimport { getObservedAppState } from \"./store\";\n\nimport {\n  BoundElement,\n  BindableElement,\n  bindingProperties,\n  updateBoundElements,\n} from \"./binding\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { mutateElement, newElementWith } from \"./mutateElement\";\nimport { getBoundTextElementId, redrawTextBoundingBox } from \"./textElement\";\nimport {\n  hasBoundTextElement,\n  isBindableElement,\n  isBoundToContainer,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport { getNonDeletedGroupIds } from \"./groups\";\n\nimport { orderByFractionalIndex, syncMovedIndices } from \"./fractionalIndex\";\n\nimport { Scene } from \"./Scene\";\n\nimport { StoreSnapshot } from \"./store\";\n\nimport type { BindableProp, BindingProp } from \"./binding\";\n\nimport type { ElementUpdate } from \"./mutateElement\";\n\n/**\n * Represents the difference between two objects of the same type.\n *\n * Both `deleted` and `inserted` partials represent the same set of added, removed or updated properties, where:\n * - `deleted` is a set of all the deleted values\n * - `inserted` is a set of all the inserted (added, updated) values\n *\n * Keeping it as pure object (without transient state, side-effects, etc.), so we won't have to instantiate it on load.\n */\nexport class Delta<T> {\n  private constructor(\n    public readonly deleted: Partial<T>,\n    public readonly inserted: Partial<T>,\n  ) {}\n\n  public static create<T>(\n    deleted: Partial<T>,\n    inserted: Partial<T>,\n    modifier?: (\n      delta: Partial<T>,\n      partialType: \"deleted\" | \"inserted\",\n    ) => Partial<T>,\n    modifierOptions?: \"deleted\" | \"inserted\" | \"both\",\n  ) {\n    const modifiedDeleted =\n      modifier && modifierOptions !== \"inserted\"\n        ? modifier(deleted, \"deleted\")\n        : deleted;\n    const modifiedInserted =\n      modifier && modifierOptions !== \"deleted\"\n        ? modifier(inserted, \"inserted\")\n        : inserted;\n\n    return new Delta(modifiedDeleted, modifiedInserted);\n  }\n\n  /**\n   * Calculates the delta between two objects.\n   *\n   * @param prevObject - The previous state of the object.\n   * @param nextObject - The next state of the object.\n   *\n   * @returns new delta instance.\n   */\n  public static calculate<T extends { [key: string]: any }>(\n    prevObject: T,\n    nextObject: T,\n    modifier?: (partial: Partial<T>) => Partial<T>,\n    postProcess?: (\n      deleted: Partial<T>,\n      inserted: Partial<T>,\n    ) => [Partial<T>, Partial<T>],\n  ): Delta<T> {\n    if (prevObject === nextObject) {\n      return Delta.empty();\n    }\n\n    const deleted = {} as Partial<T>;\n    const inserted = {} as Partial<T>;\n\n    // O(n^3) here for elements, but it's not as bad as it looks:\n    // - we do this only on store recordings, not on every frame (not for ephemerals)\n    // - we do this only on previously detected changed elements\n    // - we do shallow compare only on the first level of properties (not going any deeper)\n    // - # of properties is reasonably small\n    for (const key of this.getDifferences(prevObject, nextObject)) {\n      deleted[key as keyof T] = prevObject[key];\n      inserted[key as keyof T] = nextObject[key];\n    }\n\n    const [processedDeleted, processedInserted] = postProcess\n      ? postProcess(deleted, inserted)\n      : [deleted, inserted];\n\n    return Delta.create(processedDeleted, processedInserted, modifier);\n  }\n\n  public static empty() {\n    return new Delta({}, {});\n  }\n\n  public static isEmpty<T>(delta: Delta<T>): boolean {\n    return (\n      !Object.keys(delta.deleted).length && !Object.keys(delta.inserted).length\n    );\n  }\n\n  /**\n   * Merges deleted and inserted object partials.\n   */\n  public static mergeObjects<T extends { [key: string]: unknown }>(\n    prev: T,\n    added: T,\n    removed: T,\n  ) {\n    const cloned = { ...prev };\n\n    for (const key of Object.keys(removed)) {\n      delete cloned[key];\n    }\n\n    return { ...cloned, ...added };\n  }\n\n  /**\n   * Merges deleted and inserted array partials.\n   */\n  public static mergeArrays<T>(\n    prev: readonly T[] | null,\n    added: readonly T[] | null | undefined,\n    removed: readonly T[] | null | undefined,\n    predicate?: (value: T) => string,\n  ) {\n    return Object.values(\n      Delta.mergeObjects(\n        arrayToObject(prev ?? [], predicate),\n        arrayToObject(added ?? [], predicate),\n        arrayToObject(removed ?? [], predicate),\n      ),\n    );\n  }\n\n  /**\n   * Diff object partials as part of the `postProcess`.\n   */\n  public static diffObjects<T, K extends keyof T, V extends ValueOf<T[K]>>(\n    deleted: Partial<T>,\n    inserted: Partial<T>,\n    property: K,\n    setValue: (prevValue: V | undefined) => V,\n  ) {\n    if (!deleted[property] && !inserted[property]) {\n      return;\n    }\n\n    const isDeletedObject =\n      deleted[property] !== null && typeof deleted[property] === \"object\";\n    const isInsertedObject =\n      inserted[property] !== null && typeof inserted[property] === \"object\";\n\n    if (isDeletedObject || isInsertedObject) {\n      type RecordLike = Record<string, V | undefined>;\n\n      const deletedObject: RecordLike = deleted[property] ?? {};\n      const insertedObject: RecordLike = inserted[property] ?? {};\n\n      const deletedDifferences = Delta.getLeftDifferences(\n        deletedObject,\n        insertedObject,\n      ).reduce((acc, curr) => {\n        acc[curr] = setValue(deletedObject[curr]);\n        return acc;\n      }, {} as RecordLike);\n\n      const insertedDifferences = Delta.getRightDifferences(\n        deletedObject,\n        insertedObject,\n      ).reduce((acc, curr) => {\n        acc[curr] = setValue(insertedObject[curr]);\n        return acc;\n      }, {} as RecordLike);\n\n      if (\n        Object.keys(deletedDifferences).length ||\n        Object.keys(insertedDifferences).length\n      ) {\n        Reflect.set(deleted, property, deletedDifferences);\n        Reflect.set(inserted, property, insertedDifferences);\n      } else {\n        Reflect.deleteProperty(deleted, property);\n        Reflect.deleteProperty(inserted, property);\n      }\n    } else if (deleted[property] === inserted[property]) {\n      Reflect.deleteProperty(deleted, property);\n      Reflect.deleteProperty(inserted, property);\n    }\n  }\n\n  /**\n   * Diff array partials as part of the `postProcess`.\n   */\n  public static diffArrays<T, K extends keyof T, V extends T[K]>(\n    deleted: Partial<T>,\n    inserted: Partial<T>,\n    property: K,\n    groupBy: (value: V extends ArrayLike<infer T> ? T : never) => string,\n  ) {\n    if (!deleted[property] && !inserted[property]) {\n      return;\n    }\n\n    if (Array.isArray(deleted[property]) || Array.isArray(inserted[property])) {\n      const deletedArray = (\n        Array.isArray(deleted[property]) ? deleted[property] : []\n      ) as [];\n      const insertedArray = (\n        Array.isArray(inserted[property]) ? inserted[property] : []\n      ) as [];\n\n      const deletedDifferences = arrayToObject(\n        Delta.getLeftDifferences(\n          arrayToObject(deletedArray, groupBy),\n          arrayToObject(insertedArray, groupBy),\n        ),\n        (x) => x,\n      );\n      const insertedDifferences = arrayToObject(\n        Delta.getRightDifferences(\n          arrayToObject(deletedArray, groupBy),\n          arrayToObject(insertedArray, groupBy),\n        ),\n        (x) => x,\n      );\n\n      if (\n        Object.keys(deletedDifferences).length ||\n        Object.keys(insertedDifferences).length\n      ) {\n        const deletedValue = deletedArray.filter(\n          (x) => deletedDifferences[groupBy ? groupBy(x) : String(x)],\n        );\n        const insertedValue = insertedArray.filter(\n          (x) => insertedDifferences[groupBy ? groupBy(x) : String(x)],\n        );\n\n        Reflect.set(deleted, property, deletedValue);\n        Reflect.set(inserted, property, insertedValue);\n      } else {\n        Reflect.deleteProperty(deleted, property);\n        Reflect.deleteProperty(inserted, property);\n      }\n    }\n  }\n\n  /**\n   * Compares if object1 contains any different value compared to the object2.\n   */\n  public static isLeftDifferent<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ): boolean {\n    const anyDistinctKey = this.distinctKeysIterator(\n      \"left\",\n      object1,\n      object2,\n      skipShallowCompare,\n    ).next().value;\n\n    return !!anyDistinctKey;\n  }\n\n  /**\n   * Compares if object2 contains any different value compared to the object1.\n   */\n  public static isRightDifferent<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ): boolean {\n    const anyDistinctKey = this.distinctKeysIterator(\n      \"right\",\n      object1,\n      object2,\n      skipShallowCompare,\n    ).next().value;\n\n    return !!anyDistinctKey;\n  }\n\n  /**\n   * Compares if shared properties of object1 and object2 contain any different value (aka inner join).\n   */\n  public static isInnerDifferent<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ): boolean {\n    const anyDistinctKey = !!this.distinctKeysIterator(\n      \"inner\",\n      object1,\n      object2,\n      skipShallowCompare,\n    ).next().value;\n\n    return !!anyDistinctKey;\n  }\n\n  /**\n   * Compares if any properties of object1 and object2 contain any different value (aka full join).\n   */\n  public static isDifferent<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ): boolean {\n    const anyDistinctKey = !!this.distinctKeysIterator(\n      \"full\",\n      object1,\n      object2,\n      skipShallowCompare,\n    ).next().value;\n\n    return !!anyDistinctKey;\n  }\n\n  /**\n   * Returns sorted object1 keys that have distinct values.\n   */\n  public static getLeftDifferences<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ) {\n    return Array.from(\n      this.distinctKeysIterator(\"left\", object1, object2, skipShallowCompare),\n    ).sort();\n  }\n\n  /**\n   * Returns sorted object2 keys that have distinct values.\n   */\n  public static getRightDifferences<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ) {\n    return Array.from(\n      this.distinctKeysIterator(\"right\", object1, object2, skipShallowCompare),\n    ).sort();\n  }\n\n  /**\n   * Returns sorted keys of shared object1 and object2 properties that have distinct values (aka inner join).\n   */\n  public static getInnerDifferences<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ) {\n    return Array.from(\n      this.distinctKeysIterator(\"inner\", object1, object2, skipShallowCompare),\n    ).sort();\n  }\n\n  /**\n   * Returns sorted keys that have distinct values between object1 and object2 (aka full join).\n   */\n  public static getDifferences<T extends {}>(\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ) {\n    return Array.from(\n      this.distinctKeysIterator(\"full\", object1, object2, skipShallowCompare),\n    ).sort();\n  }\n\n  /**\n   * Iterator comparing values of object properties based on the passed joining strategy.\n   *\n   * @yields keys of properties with different values\n   *\n   * WARN: it's based on shallow compare performed only on the first level and doesn't go deeper than that.\n   */\n  private static *distinctKeysIterator<T extends {}>(\n    join: \"left\" | \"right\" | \"inner\" | \"full\",\n    object1: T,\n    object2: T,\n    skipShallowCompare = false,\n  ) {\n    if (object1 === object2) {\n      return;\n    }\n\n    let keys: string[] = [];\n\n    if (join === \"left\") {\n      keys = Object.keys(object1);\n    } else if (join === \"right\") {\n      keys = Object.keys(object2);\n    } else if (join === \"inner\") {\n      keys = Object.keys(object1).filter((key) => key in object2);\n    } else if (join === \"full\") {\n      keys = Array.from(\n        new Set([...Object.keys(object1), ...Object.keys(object2)]),\n      );\n    } else {\n      assertNever(\n        join,\n        `Unknown distinctKeysIterator's join param \"${join}\"`,\n        true,\n      );\n    }\n\n    for (const key of keys) {\n      const value1 = object1[key as keyof T];\n      const value2 = object2[key as keyof T];\n\n      if (value1 !== value2) {\n        if (\n          !skipShallowCompare &&\n          typeof value1 === \"object\" &&\n          typeof value2 === \"object\" &&\n          value1 !== null &&\n          value2 !== null &&\n          isShallowEqual(value1, value2)\n        ) {\n          continue;\n        }\n\n        yield key;\n      }\n    }\n  }\n}\n\n/**\n * Encapsulates a set of application-level `Delta`s.\n */\nexport interface DeltaContainer<T> {\n  /**\n   * Inverses the `Delta`s while creating a new `DeltaContainer` instance.\n   */\n  inverse(): DeltaContainer<T>;\n\n  /**\n   * Applies the `Delta`s to the previous object.\n   *\n   * @returns a tuple of the next object `T` with applied `Delta`s, and `boolean`, indicating whether the applied deltas resulted in a visible change.\n   */\n  applyTo(previous: T, ...options: unknown[]): [T, boolean];\n\n  /**\n   * Checks whether all `Delta`s are empty.\n   */\n  isEmpty(): boolean;\n}\n\nexport class AppStateDelta implements DeltaContainer<AppState> {\n  private constructor(public readonly delta: Delta<ObservedAppState>) {}\n\n  public static calculate<T extends ObservedAppState>(\n    prevAppState: T,\n    nextAppState: T,\n  ): AppStateDelta {\n    const delta = Delta.calculate(\n      prevAppState,\n      nextAppState,\n      // making the order of keys in deltas stable for hashing purposes\n      AppStateDelta.orderAppStateKeys,\n      AppStateDelta.postProcess,\n    );\n\n    return new AppStateDelta(delta);\n  }\n\n  public static restore(appStateDeltaDTO: DTO<AppStateDelta>): AppStateDelta {\n    const { delta } = appStateDeltaDTO;\n    return new AppStateDelta(delta);\n  }\n\n  public static empty() {\n    return new AppStateDelta(Delta.create({}, {}));\n  }\n\n  public inverse(): AppStateDelta {\n    const inversedDelta = Delta.create(this.delta.inserted, this.delta.deleted);\n    return new AppStateDelta(inversedDelta);\n  }\n\n  public applyTo(\n    appState: AppState,\n    nextElements: SceneElementsMap,\n  ): [AppState, boolean] {\n    try {\n      const {\n        selectedElementIds: removedSelectedElementIds = {},\n        selectedGroupIds: removedSelectedGroupIds = {},\n      } = this.delta.deleted;\n\n      const {\n        selectedElementIds: addedSelectedElementIds = {},\n        selectedGroupIds: addedSelectedGroupIds = {},\n        selectedLinearElementId,\n        editingLinearElementId,\n        ...directlyApplicablePartial\n      } = this.delta.inserted;\n\n      const mergedSelectedElementIds = Delta.mergeObjects(\n        appState.selectedElementIds,\n        addedSelectedElementIds,\n        removedSelectedElementIds,\n      );\n\n      const mergedSelectedGroupIds = Delta.mergeObjects(\n        appState.selectedGroupIds,\n        addedSelectedGroupIds,\n        removedSelectedGroupIds,\n      );\n\n      const selectedLinearElement =\n        selectedLinearElementId && nextElements.has(selectedLinearElementId)\n          ? new LinearElementEditor(\n              nextElements.get(\n                selectedLinearElementId,\n              ) as NonDeleted<ExcalidrawLinearElement>,\n              nextElements,\n            )\n          : null;\n\n      const editingLinearElement =\n        editingLinearElementId && nextElements.has(editingLinearElementId)\n          ? new LinearElementEditor(\n              nextElements.get(\n                editingLinearElementId,\n              ) as NonDeleted<ExcalidrawLinearElement>,\n              nextElements,\n            )\n          : null;\n\n      const nextAppState = {\n        ...appState,\n        ...directlyApplicablePartial,\n        selectedElementIds: mergedSelectedElementIds,\n        selectedGroupIds: mergedSelectedGroupIds,\n        selectedLinearElement:\n          typeof selectedLinearElementId !== \"undefined\"\n            ? selectedLinearElement // element was either inserted or deleted\n            : appState.selectedLinearElement, // otherwise assign what we had before\n        editingLinearElement:\n          typeof editingLinearElementId !== \"undefined\"\n            ? editingLinearElement // element was either inserted or deleted\n            : appState.editingLinearElement, // otherwise assign what we had before\n      };\n\n      const constainsVisibleChanges = this.filterInvisibleChanges(\n        appState,\n        nextAppState,\n        nextElements,\n      );\n\n      return [nextAppState, constainsVisibleChanges];\n    } catch (e) {\n      // shouldn't really happen, but just in case\n      console.error(`Couldn't apply appstate change`, e);\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n\n      return [appState, false];\n    }\n  }\n\n  public isEmpty(): boolean {\n    return Delta.isEmpty(this.delta);\n  }\n\n  /**\n   * Mutates `nextAppState` be filtering out state related to deleted elements.\n   *\n   * @returns `true` if a visible change is found, `false` otherwise.\n   */\n  private filterInvisibleChanges(\n    prevAppState: AppState,\n    nextAppState: AppState,\n    nextElements: SceneElementsMap,\n  ): boolean {\n    // TODO: #7348 we could still get an empty undo/redo, as we assume that previous appstate does not contain references to deleted elements\n    // which is not always true - i.e. now we do cleanup appstate during history, but we do not do it during remote updates\n    const prevObservedAppState = getObservedAppState(prevAppState);\n    const nextObservedAppState = getObservedAppState(nextAppState);\n\n    const containsStandaloneDifference = Delta.isRightDifferent(\n      AppStateDelta.stripElementsProps(prevObservedAppState),\n      AppStateDelta.stripElementsProps(nextObservedAppState),\n    );\n\n    const containsElementsDifference = Delta.isRightDifferent(\n      AppStateDelta.stripStandaloneProps(prevObservedAppState),\n      AppStateDelta.stripStandaloneProps(nextObservedAppState),\n    );\n\n    if (!containsStandaloneDifference && !containsElementsDifference) {\n      // no change in appstate was detected\n      return false;\n    }\n\n    const visibleDifferenceFlag = {\n      value: containsStandaloneDifference,\n    };\n\n    if (containsElementsDifference) {\n      // filter invisible changes on each iteration\n      const changedElementsProps = Delta.getRightDifferences(\n        AppStateDelta.stripStandaloneProps(prevObservedAppState),\n        AppStateDelta.stripStandaloneProps(nextObservedAppState),\n      ) as Array<keyof ObservedElementsAppState>;\n\n      let nonDeletedGroupIds = new Set<string>();\n\n      if (\n        changedElementsProps.includes(\"editingGroupId\") ||\n        changedElementsProps.includes(\"selectedGroupIds\")\n      ) {\n        // this one iterates through all the non deleted elements, so make sure it's not done twice\n        nonDeletedGroupIds = getNonDeletedGroupIds(nextElements);\n      }\n\n      // check whether delta properties are related to the existing non-deleted elements\n      for (const key of changedElementsProps) {\n        switch (key) {\n          case \"selectedElementIds\":\n            nextAppState[key] = AppStateDelta.filterSelectedElements(\n              nextAppState[key],\n              nextElements,\n              visibleDifferenceFlag,\n            );\n\n            break;\n          case \"selectedGroupIds\":\n            nextAppState[key] = AppStateDelta.filterSelectedGroups(\n              nextAppState[key],\n              nonDeletedGroupIds,\n              visibleDifferenceFlag,\n            );\n\n            break;\n          case \"croppingElementId\": {\n            const croppingElementId = nextAppState[key];\n\n            if (!croppingElementId) {\n              // previously there was a croppingElementId (assuming visible), now there is none\n              visibleDifferenceFlag.value = true;\n            } else {\n              const element = nextElements.get(croppingElementId);\n\n              if (element && !element.isDeleted) {\n                visibleDifferenceFlag.value = true;\n              } else {\n                nextAppState[key] = null;\n              }\n            }\n\n            break;\n          }\n          case \"editingGroupId\":\n            const editingGroupId = nextAppState[key];\n\n            if (!editingGroupId) {\n              // previously there was an editingGroup (assuming visible), now there is none\n              visibleDifferenceFlag.value = true;\n            } else if (nonDeletedGroupIds.has(editingGroupId)) {\n              // previously there wasn't an editingGroup, now there is one which is visible\n              visibleDifferenceFlag.value = true;\n            } else {\n              // there was assigned an editingGroup now, but it's related to deleted element\n              nextAppState[key] = null;\n            }\n\n            break;\n          case \"selectedLinearElementId\":\n          case \"editingLinearElementId\":\n            const appStateKey = AppStateDelta.convertToAppStateKey(key);\n            const linearElement = nextAppState[appStateKey];\n\n            if (!linearElement) {\n              // previously there was a linear element (assuming visible), now there is none\n              visibleDifferenceFlag.value = true;\n            } else {\n              const element = nextElements.get(linearElement.elementId);\n\n              if (element && !element.isDeleted) {\n                // previously there wasn't a linear element, now there is one which is visible\n                visibleDifferenceFlag.value = true;\n              } else {\n                // there was assigned a linear element now, but it's deleted\n                nextAppState[appStateKey] = null;\n              }\n            }\n\n            break;\n          case \"lockedMultiSelections\": {\n            const prevLockedUnits = prevAppState[key] || {};\n            const nextLockedUnits = nextAppState[key] || {};\n\n            if (!isShallowEqual(prevLockedUnits, nextLockedUnits)) {\n              visibleDifferenceFlag.value = true;\n            }\n            break;\n          }\n          case \"activeLockedId\": {\n            const prevHitLockedId = prevAppState[key] || null;\n            const nextHitLockedId = nextAppState[key] || null;\n\n            if (prevHitLockedId !== nextHitLockedId) {\n              visibleDifferenceFlag.value = true;\n            }\n            break;\n          }\n          default: {\n            assertNever(\n              key,\n              `Unknown ObservedElementsAppState's key \"${key}\"`,\n              true,\n            );\n          }\n        }\n      }\n    }\n\n    return visibleDifferenceFlag.value;\n  }\n\n  private static convertToAppStateKey(\n    key: keyof Pick<\n      ObservedElementsAppState,\n      \"selectedLinearElementId\" | \"editingLinearElementId\"\n    >,\n  ): keyof Pick<AppState, \"selectedLinearElement\" | \"editingLinearElement\"> {\n    switch (key) {\n      case \"selectedLinearElementId\":\n        return \"selectedLinearElement\";\n      case \"editingLinearElementId\":\n        return \"editingLinearElement\";\n    }\n  }\n\n  private static filterSelectedElements(\n    selectedElementIds: AppState[\"selectedElementIds\"],\n    elements: SceneElementsMap,\n    visibleDifferenceFlag: { value: boolean },\n  ) {\n    const ids = Object.keys(selectedElementIds);\n\n    if (!ids.length) {\n      // previously there were ids (assuming related to visible elements), now there are none\n      visibleDifferenceFlag.value = true;\n      return selectedElementIds;\n    }\n\n    const nextSelectedElementIds = { ...selectedElementIds };\n\n    for (const id of ids) {\n      const element = elements.get(id);\n\n      if (element && !element.isDeleted) {\n        // there is a selected element id related to a visible element\n        visibleDifferenceFlag.value = true;\n      } else {\n        delete nextSelectedElementIds[id];\n      }\n    }\n\n    return nextSelectedElementIds;\n  }\n\n  private static filterSelectedGroups(\n    selectedGroupIds: AppState[\"selectedGroupIds\"],\n    nonDeletedGroupIds: Set<string>,\n    visibleDifferenceFlag: { value: boolean },\n  ) {\n    const ids = Object.keys(selectedGroupIds);\n\n    if (!ids.length) {\n      // previously there were ids (assuming related to visible groups), now there are none\n      visibleDifferenceFlag.value = true;\n      return selectedGroupIds;\n    }\n\n    const nextSelectedGroupIds = { ...selectedGroupIds };\n\n    for (const id of Object.keys(nextSelectedGroupIds)) {\n      if (nonDeletedGroupIds.has(id)) {\n        // there is a selected group id related to a visible group\n        visibleDifferenceFlag.value = true;\n      } else {\n        delete nextSelectedGroupIds[id];\n      }\n    }\n\n    return nextSelectedGroupIds;\n  }\n\n  private static stripElementsProps(\n    delta: Partial<ObservedAppState>,\n  ): Partial<ObservedStandaloneAppState> {\n    // WARN: Do not remove the type-casts as they here to ensure proper type checks\n    const {\n      editingGroupId,\n      selectedGroupIds,\n      selectedElementIds,\n      editingLinearElementId,\n      selectedLinearElementId,\n      croppingElementId,\n      lockedMultiSelections,\n      activeLockedId,\n      ...standaloneProps\n    } = delta as ObservedAppState;\n\n    return standaloneProps as SubtypeOf<\n      typeof standaloneProps,\n      ObservedStandaloneAppState\n    >;\n  }\n\n  private static stripStandaloneProps(\n    delta: Partial<ObservedAppState>,\n  ): Partial<ObservedElementsAppState> {\n    // WARN: Do not remove the type-casts as they here to ensure proper type checks\n    const { name, viewBackgroundColor, ...elementsProps } =\n      delta as ObservedAppState;\n\n    return elementsProps as SubtypeOf<\n      typeof elementsProps,\n      ObservedElementsAppState\n    >;\n  }\n\n  /**\n   * It is necessary to post process the partials in case of reference values,\n   * for which we need to calculate the real diff between `deleted` and `inserted`.\n   */\n  private static postProcess<T extends ObservedAppState>(\n    deleted: Partial<T>,\n    inserted: Partial<T>,\n  ): [Partial<T>, Partial<T>] {\n    try {\n      Delta.diffObjects(\n        deleted,\n        inserted,\n        \"selectedElementIds\",\n        // ts language server has a bit trouble resolving this, so we are giving it a little push\n        (_) => true as ValueOf<T[\"selectedElementIds\"]>,\n      );\n      Delta.diffObjects(\n        deleted,\n        inserted,\n        \"selectedGroupIds\",\n        (prevValue) => (prevValue ?? false) as ValueOf<T[\"selectedGroupIds\"]>,\n      );\n      Delta.diffObjects(\n        deleted,\n        inserted,\n        \"lockedMultiSelections\",\n        (prevValue) => (prevValue ?? {}) as ValueOf<T[\"lockedMultiSelections\"]>,\n      );\n      Delta.diffObjects(\n        deleted,\n        inserted,\n        \"activeLockedId\",\n        (prevValue) => (prevValue ?? null) as ValueOf<T[\"activeLockedId\"]>,\n      );\n    } catch (e) {\n      // if postprocessing fails it does not make sense to bubble up, but let's make sure we know about it\n      console.error(`Couldn't postprocess appstate change deltas.`);\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n    } finally {\n      return [deleted, inserted];\n    }\n  }\n\n  private static orderAppStateKeys(partial: Partial<ObservedAppState>) {\n    const orderedPartial: { [key: string]: unknown } = {};\n\n    for (const key of Object.keys(partial).sort()) {\n      // relying on insertion order\n      orderedPartial[key] = partial[key as keyof ObservedAppState];\n    }\n\n    return orderedPartial as Partial<ObservedAppState>;\n  }\n}\n\ntype ElementPartial<TElement extends ExcalidrawElement = ExcalidrawElement> =\n  Omit<Partial<Ordered<TElement>>, \"id\" | \"updated\" | \"seed\">;\n\nexport type ApplyToOptions = {\n  excludedProperties: Set<keyof ElementPartial>;\n};\n\ntype ApplyToFlags = {\n  containsVisibleDifference: boolean;\n  containsZindexDifference: boolean;\n};\n\n/**\n * Elements change is a low level primitive to capture a change between two sets of elements.\n * It does so by encapsulating forward and backward `Delta`s, allowing to time-travel in both directions.\n */\nexport class ElementsDelta implements DeltaContainer<SceneElementsMap> {\n  private constructor(\n    public readonly added: Record<string, Delta<ElementPartial>>,\n    public readonly removed: Record<string, Delta<ElementPartial>>,\n    public readonly updated: Record<string, Delta<ElementPartial>>,\n  ) {}\n\n  public static create(\n    added: Record<string, Delta<ElementPartial>>,\n    removed: Record<string, Delta<ElementPartial>>,\n    updated: Record<string, Delta<ElementPartial>>,\n    options: {\n      shouldRedistribute: boolean;\n    } = {\n      shouldRedistribute: false,\n    },\n  ) {\n    let delta: ElementsDelta;\n\n    if (options.shouldRedistribute) {\n      const nextAdded: Record<string, Delta<ElementPartial>> = {};\n      const nextRemoved: Record<string, Delta<ElementPartial>> = {};\n      const nextUpdated: Record<string, Delta<ElementPartial>> = {};\n\n      const deltas = [\n        ...Object.entries(added),\n        ...Object.entries(removed),\n        ...Object.entries(updated),\n      ];\n\n      for (const [id, delta] of deltas) {\n        if (this.satisfiesAddition(delta)) {\n          nextAdded[id] = delta;\n        } else if (this.satisfiesRemoval(delta)) {\n          nextRemoved[id] = delta;\n        } else {\n          nextUpdated[id] = delta;\n        }\n      }\n\n      delta = new ElementsDelta(nextAdded, nextRemoved, nextUpdated);\n    } else {\n      delta = new ElementsDelta(added, removed, updated);\n    }\n\n    if (isTestEnv() || isDevEnv()) {\n      ElementsDelta.validate(delta, \"added\", this.satisfiesAddition);\n      ElementsDelta.validate(delta, \"removed\", this.satisfiesRemoval);\n      ElementsDelta.validate(delta, \"updated\", this.satisfiesUpdate);\n    }\n\n    return delta;\n  }\n\n  public static restore(elementsDeltaDTO: DTO<ElementsDelta>): ElementsDelta {\n    const { added, removed, updated } = elementsDeltaDTO;\n    return ElementsDelta.create(added, removed, updated);\n  }\n\n  private static satisfiesAddition = ({\n    deleted,\n    inserted,\n  }: Delta<ElementPartial>) =>\n    // dissallowing added as \"deleted\", which could cause issues when resolving conflicts\n    deleted.isDeleted === true && !inserted.isDeleted;\n\n  private static satisfiesRemoval = ({\n    deleted,\n    inserted,\n  }: Delta<ElementPartial>) =>\n    !deleted.isDeleted && inserted.isDeleted === true;\n\n  private static satisfiesUpdate = ({\n    deleted,\n    inserted,\n  }: Delta<ElementPartial>) => !!deleted.isDeleted === !!inserted.isDeleted;\n\n  private static satisfiesCommmonInvariants = ({\n    deleted,\n    inserted,\n  }: Delta<ElementPartial>) =>\n    !!(\n      deleted.version &&\n      inserted.version &&\n      // versions are required integers\n      Number.isInteger(deleted.version) &&\n      Number.isInteger(inserted.version) &&\n      // versions should be positive, zero included\n      deleted.version >= 0 &&\n      inserted.version >= 0 &&\n      // versions should never be the same\n      deleted.version !== inserted.version\n    );\n\n  private static validate(\n    elementsDelta: ElementsDelta,\n    type: \"added\" | \"removed\" | \"updated\",\n    satifiesSpecialInvariants: (delta: Delta<ElementPartial>) => boolean,\n  ) {\n    for (const [id, delta] of Object.entries(elementsDelta[type])) {\n      if (\n        !this.satisfiesCommmonInvariants(delta) ||\n        !satifiesSpecialInvariants(delta)\n      ) {\n        console.error(\n          `Broken invariant for \"${type}\" delta, element \"${id}\", delta:`,\n          delta,\n        );\n        throw new Error(`ElementsDelta invariant broken for element \"${id}\".`);\n      }\n    }\n  }\n\n  /**\n   * Calculates the `Delta`s between the previous and next set of elements.\n   *\n   * @param prevElements - Map representing the previous state of elements.\n   * @param nextElements - Map representing the next state of elements.\n   *\n   * @returns `ElementsDelta` instance representing the `Delta` changes between the two sets of elements.\n   */\n  public static calculate<T extends OrderedExcalidrawElement>(\n    prevElements: Map<string, T>,\n    nextElements: Map<string, T>,\n  ): ElementsDelta {\n    if (prevElements === nextElements) {\n      return ElementsDelta.empty();\n    }\n\n    const added: Record<string, Delta<ElementPartial>> = {};\n    const removed: Record<string, Delta<ElementPartial>> = {};\n    const updated: Record<string, Delta<ElementPartial>> = {};\n\n    // this might be needed only in same edge cases, like during collab, when `isDeleted` elements get removed or when we (un)intentionally remove the elements\n    for (const prevElement of prevElements.values()) {\n      const nextElement = nextElements.get(prevElement.id);\n\n      if (!nextElement) {\n        const deleted = { ...prevElement, isDeleted: false } as ElementPartial;\n\n        const inserted = {\n          isDeleted: true,\n          version: prevElement.version + 1,\n          versionNonce: randomInteger(),\n        } as ElementPartial;\n\n        const delta = Delta.create(\n          deleted,\n          inserted,\n          ElementsDelta.stripIrrelevantProps,\n        );\n\n        removed[prevElement.id] = delta;\n      }\n    }\n\n    for (const nextElement of nextElements.values()) {\n      const prevElement = prevElements.get(nextElement.id);\n\n      if (!prevElement) {\n        const deleted = {\n          isDeleted: true,\n          version: nextElement.version - 1,\n          versionNonce: randomInteger(),\n        } as ElementPartial;\n\n        const inserted = {\n          ...nextElement,\n          isDeleted: false,\n        } as ElementPartial;\n\n        const delta = Delta.create(\n          deleted,\n          inserted,\n          ElementsDelta.stripIrrelevantProps,\n        );\n\n        added[nextElement.id] = delta;\n\n        continue;\n      }\n\n      if (prevElement.versionNonce !== nextElement.versionNonce) {\n        const delta = Delta.calculate<ElementPartial>(\n          prevElement,\n          nextElement,\n          ElementsDelta.stripIrrelevantProps,\n          ElementsDelta.postProcess,\n        );\n\n        if (\n          // making sure we don't get here some non-boolean values (i.e. undefined, null, etc.)\n          typeof prevElement.isDeleted === \"boolean\" &&\n          typeof nextElement.isDeleted === \"boolean\" &&\n          prevElement.isDeleted !== nextElement.isDeleted\n        ) {\n          // notice that other props could have been updated as well\n          if (prevElement.isDeleted && !nextElement.isDeleted) {\n            added[nextElement.id] = delta;\n          } else {\n            removed[nextElement.id] = delta;\n          }\n\n          continue;\n        }\n\n        // making sure there are at least some changes\n        if (!Delta.isEmpty(delta)) {\n          updated[nextElement.id] = delta;\n        }\n      }\n    }\n\n    return ElementsDelta.create(added, removed, updated);\n  }\n\n  public static empty() {\n    return ElementsDelta.create({}, {}, {});\n  }\n\n  public inverse(): ElementsDelta {\n    const inverseInternal = (deltas: Record<string, Delta<ElementPartial>>) => {\n      const inversedDeltas: Record<string, Delta<ElementPartial>> = {};\n\n      for (const [id, delta] of Object.entries(deltas)) {\n        inversedDeltas[id] = Delta.create(delta.inserted, delta.deleted);\n      }\n\n      return inversedDeltas;\n    };\n\n    const added = inverseInternal(this.added);\n    const removed = inverseInternal(this.removed);\n    const updated = inverseInternal(this.updated);\n\n    // notice we inverse removed with added not to break the invariants\n    return ElementsDelta.create(removed, added, updated);\n  }\n\n  public isEmpty(): boolean {\n    return (\n      Object.keys(this.added).length === 0 &&\n      Object.keys(this.removed).length === 0 &&\n      Object.keys(this.updated).length === 0\n    );\n  }\n\n  /**\n   * Update delta/s based on the existing elements.\n   *\n   * @param nextElements current elements\n   * @param modifierOptions defines which of the delta (`deleted` or `inserted`) will be updated\n   * @returns new instance with modified delta/s\n   */\n  public applyLatestChanges(\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n    modifierOptions?: \"deleted\" | \"inserted\",\n  ): ElementsDelta {\n    const modifier =\n      (\n        prevElement: OrderedExcalidrawElement | undefined,\n        nextElement: OrderedExcalidrawElement | undefined,\n      ) =>\n      (partial: ElementPartial, partialType: \"deleted\" | \"inserted\") => {\n        let element: OrderedExcalidrawElement | undefined;\n\n        switch (partialType) {\n          case \"deleted\":\n            element = prevElement;\n            break;\n          case \"inserted\":\n            element = nextElement;\n            break;\n        }\n\n        // the element wasn't found -> don't update the partial\n        if (!element) {\n          console.error(\n            `Element not found when trying to apply latest changes`,\n          );\n          return partial;\n        }\n\n        const latestPartial: { [key: string]: unknown } = {};\n\n        for (const key of Object.keys(partial) as Array<keyof typeof partial>) {\n          // do not update following props:\n          // - `boundElements`, as it is a reference value which is postprocessed to contain only deleted/inserted keys\n          switch (key) {\n            case \"boundElements\":\n              latestPartial[key] = partial[key];\n              break;\n            default:\n              latestPartial[key] = element[key];\n          }\n        }\n\n        return latestPartial;\n      };\n\n    const applyLatestChangesInternal = (\n      deltas: Record<string, Delta<ElementPartial>>,\n    ) => {\n      const modifiedDeltas: Record<string, Delta<ElementPartial>> = {};\n\n      for (const [id, delta] of Object.entries(deltas)) {\n        const prevElement = prevElements.get(id);\n        const nextElement = nextElements.get(id);\n\n        let latestDelta: Delta<ElementPartial> | null = null;\n\n        if (prevElement || nextElement) {\n          latestDelta = Delta.create(\n            delta.deleted,\n            delta.inserted,\n            modifier(prevElement, nextElement),\n            modifierOptions,\n          );\n        } else {\n          latestDelta = delta;\n        }\n\n        // it might happen that after applying latest changes the delta itself does not contain any changes\n        if (Delta.isInnerDifferent(latestDelta.deleted, latestDelta.inserted)) {\n          modifiedDeltas[id] = latestDelta;\n        }\n      }\n\n      return modifiedDeltas;\n    };\n\n    const added = applyLatestChangesInternal(this.added);\n    const removed = applyLatestChangesInternal(this.removed);\n    const updated = applyLatestChangesInternal(this.updated);\n\n    return ElementsDelta.create(added, removed, updated, {\n      shouldRedistribute: true, // redistribute the deltas as `isDeleted` could have been updated\n    });\n  }\n\n  public applyTo(\n    elements: SceneElementsMap,\n    snapshot: StoreSnapshot[\"elements\"] = StoreSnapshot.empty().elements,\n    options: ApplyToOptions = {\n      excludedProperties: new Set(),\n    },\n  ): [SceneElementsMap, boolean] {\n    let nextElements = new Map(elements) as SceneElementsMap;\n    let changedElements: Map<string, OrderedExcalidrawElement>;\n\n    const flags: ApplyToFlags = {\n      containsVisibleDifference: false,\n      containsZindexDifference: false,\n    };\n\n    // mimic a transaction by applying deltas into `nextElements` (always new instance, no mutation)\n    try {\n      const applyDeltas = ElementsDelta.createApplier(\n        nextElements,\n        snapshot,\n        options,\n        flags,\n      );\n\n      const addedElements = applyDeltas(this.added);\n      const removedElements = applyDeltas(this.removed);\n      const updatedElements = applyDeltas(this.updated);\n\n      const affectedElements = this.resolveConflicts(elements, nextElements);\n\n      // TODO: #7348 validate elements semantically and syntactically the changed elements, in case they would result data integrity issues\n      changedElements = new Map([\n        ...addedElements,\n        ...removedElements,\n        ...updatedElements,\n        ...affectedElements,\n      ]);\n    } catch (e) {\n      console.error(`Couldn't apply elements delta`, e);\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n\n      // should not really happen, but just in case we cannot apply deltas, let's return the previous elements with visible change set to `true`\n      // even though there is obviously no visible change, returning `false` could be dangerous, as i.e.:\n      // in the worst case, it could lead into iterating through the whole stack with no possibility to redo\n      // instead, the worst case when returning `true` is an empty undo / redo\n      return [elements, true];\n    }\n\n    try {\n      // the following reorder performs also mutations, but only on new instances of changed elements\n      // (unless something goes really bad and it fallbacks to fixing all invalid indices)\n      nextElements = ElementsDelta.reorderElements(\n        nextElements,\n        changedElements,\n        flags,\n      );\n\n      // we don't have an up-to-date scene, as we can be just in the middle of applying history entry\n      // we also don't have a scene on the server\n      // so we are creating a temp scene just to query and mutate elements\n      const tempScene = new Scene(nextElements);\n\n      ElementsDelta.redrawTextBoundingBoxes(tempScene, changedElements);\n      // Need ordered nextElements to avoid z-index binding issues\n      ElementsDelta.redrawBoundArrows(tempScene, changedElements);\n    } catch (e) {\n      console.error(\n        `Couldn't mutate elements after applying elements change`,\n        e,\n      );\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n    } finally {\n      return [nextElements, flags.containsVisibleDifference];\n    }\n  }\n\n  private static createApplier =\n    (\n      nextElements: SceneElementsMap,\n      snapshot: StoreSnapshot[\"elements\"],\n      options: ApplyToOptions,\n      flags: ApplyToFlags,\n    ) =>\n    (deltas: Record<string, Delta<ElementPartial>>) => {\n      const getElement = ElementsDelta.createGetter(\n        nextElements,\n        snapshot,\n        flags,\n      );\n\n      return Object.entries(deltas).reduce((acc, [id, delta]) => {\n        const element = getElement(id, delta.inserted);\n\n        if (element) {\n          const newElement = ElementsDelta.applyDelta(\n            element,\n            delta,\n            options,\n            flags,\n          );\n\n          nextElements.set(newElement.id, newElement);\n          acc.set(newElement.id, newElement);\n        }\n\n        return acc;\n      }, new Map<string, OrderedExcalidrawElement>());\n    };\n\n  private static createGetter =\n    (\n      elements: SceneElementsMap,\n      snapshot: StoreSnapshot[\"elements\"],\n      flags: ApplyToFlags,\n    ) =>\n    (id: string, partial: ElementPartial) => {\n      let element = elements.get(id);\n\n      if (!element) {\n        // always fallback to the local snapshot, in cases when we cannot find the element in the elements array\n        element = snapshot.get(id);\n\n        if (element) {\n          // as the element was brought from the snapshot, it automatically results in a possible zindex difference\n          flags.containsZindexDifference = true;\n\n          // as the element was force deleted, we need to check if adding it back results in a visible change\n          if (!partial.isDeleted || (partial.isDeleted && !element.isDeleted)) {\n            flags.containsVisibleDifference = true;\n          }\n        } else {\n          // not in elements, not in snapshot? element might have been added remotely!\n          element = newElementWith(\n            { id, version: 1 } as OrderedExcalidrawElement,\n            {\n              ...partial,\n            },\n          );\n        }\n      }\n\n      return element;\n    };\n\n  private static applyDelta(\n    element: OrderedExcalidrawElement,\n    delta: Delta<ElementPartial>,\n    options: ApplyToOptions,\n    flags: ApplyToFlags,\n  ) {\n    const directlyApplicablePartial: Mutable<ElementPartial> = {};\n\n    // some properties are not directly applicable, such as:\n    // - boundElements which contains only diff)\n    // - version & versionNonce, if we don't want to return to previous versions\n    for (const key of Object.keys(delta.inserted) as Array<\n      keyof typeof delta.inserted\n    >) {\n      if (key === \"boundElements\") {\n        continue;\n      }\n\n      if (options.excludedProperties.has(key)) {\n        continue;\n      }\n\n      const value = delta.inserted[key];\n      Reflect.set(directlyApplicablePartial, key, value);\n    }\n\n    if (\n      delta.deleted.boundElements?.length ||\n      delta.inserted.boundElements?.length\n    ) {\n      const mergedBoundElements = Delta.mergeArrays(\n        element.boundElements,\n        delta.inserted.boundElements,\n        delta.deleted.boundElements,\n        (x) => x.id,\n      );\n\n      Object.assign(directlyApplicablePartial, {\n        boundElements: mergedBoundElements,\n      });\n    }\n\n    if (!flags.containsVisibleDifference) {\n      // strip away fractional index, as even if it would be different, it doesn't have to result in visible change\n      const { index, ...rest } = directlyApplicablePartial;\n      const containsVisibleDifference = ElementsDelta.checkForVisibleDifference(\n        element,\n        rest,\n      );\n\n      flags.containsVisibleDifference = containsVisibleDifference;\n    }\n\n    if (!flags.containsZindexDifference) {\n      flags.containsZindexDifference =\n        delta.deleted.index !== delta.inserted.index;\n    }\n\n    return newElementWith(element, directlyApplicablePartial);\n  }\n\n  /**\n   * Check for visible changes regardless of whether they were removed, added or updated.\n   */\n  private static checkForVisibleDifference(\n    element: OrderedExcalidrawElement,\n    partial: ElementPartial,\n  ) {\n    if (element.isDeleted && partial.isDeleted !== false) {\n      // when it's deleted and partial is not false, it cannot end up with a visible change\n      return false;\n    }\n\n    if (element.isDeleted && partial.isDeleted === false) {\n      // when we add an element, it results in a visible change\n      return true;\n    }\n\n    if (element.isDeleted === false && partial.isDeleted) {\n      // when we remove an element, it results in a visible change\n      return true;\n    }\n\n    // check for any difference on a visible element\n    return Delta.isRightDifferent(element, partial);\n  }\n\n  /**\n   * Resolves conflicts for all previously added, removed and updated elements.\n   * Updates the previous deltas with all the changes after conflict resolution.\n   *\n   * // TODO: revisit since some bound arrows seem to be often redrawn incorrectly\n   *\n   * @returns all elements affected by the conflict resolution\n   */\n  private resolveConflicts(\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n  ) {\n    const nextAffectedElements = new Map<string, OrderedExcalidrawElement>();\n    const updater = (\n      element: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => {\n      const nextElement = nextElements.get(element.id); // only ever modify next element!\n      if (!nextElement) {\n        return;\n      }\n\n      let affectedElement: OrderedExcalidrawElement;\n\n      if (prevElements.get(element.id) === nextElement) {\n        // create the new element instance in case we didn't modify the element yet\n        // so that we won't end up in an incosistent state in case we would fail in the middle of mutations\n        affectedElement = newElementWith(\n          nextElement,\n          updates as ElementUpdate<OrderedExcalidrawElement>,\n        );\n      } else {\n        affectedElement = mutateElement(\n          nextElement,\n          nextElements,\n          updates as ElementUpdate<OrderedExcalidrawElement>,\n        );\n      }\n\n      nextAffectedElements.set(affectedElement.id, affectedElement);\n      nextElements.set(affectedElement.id, affectedElement);\n    };\n\n    // removed delta is affecting the bindings always, as all the affected elements of the removed elements need to be unbound\n    for (const id of Object.keys(this.removed)) {\n      ElementsDelta.unbindAffected(prevElements, nextElements, id, updater);\n    }\n\n    // added delta is affecting the bindings always, all the affected elements of the added elements need to be rebound\n    for (const id of Object.keys(this.added)) {\n      ElementsDelta.rebindAffected(prevElements, nextElements, id, updater);\n    }\n\n    // updated delta is affecting the binding only in case it contains changed binding or bindable property\n    for (const [id] of Array.from(Object.entries(this.updated)).filter(\n      ([_, delta]) =>\n        Object.keys({ ...delta.deleted, ...delta.inserted }).find((prop) =>\n          bindingProperties.has(prop as BindingProp | BindableProp),\n        ),\n    )) {\n      const updatedElement = nextElements.get(id);\n      if (!updatedElement || updatedElement.isDeleted) {\n        // skip fixing bindings for updates on deleted elements\n        continue;\n      }\n\n      ElementsDelta.rebindAffected(prevElements, nextElements, id, updater);\n    }\n\n    // filter only previous elements, which were now affected\n    const prevAffectedElements = new Map(\n      Array.from(prevElements).filter(([id]) => nextAffectedElements.has(id)),\n    );\n\n    // calculate complete deltas for affected elements, and assign them back to all the deltas\n    // technically we could do better here if perf. would become an issue\n    const { added, removed, updated } = ElementsDelta.calculate(\n      prevAffectedElements,\n      nextAffectedElements,\n    );\n\n    for (const [id, delta] of Object.entries(added)) {\n      this.added[id] = delta;\n    }\n\n    for (const [id, delta] of Object.entries(removed)) {\n      this.removed[id] = delta;\n    }\n\n    for (const [id, delta] of Object.entries(updated)) {\n      this.updated[id] = delta;\n    }\n\n    return nextAffectedElements;\n  }\n\n  /**\n   * Non deleted affected elements of removed elements (before and after applying delta),\n   * should be unbound ~ bindings should not point from non deleted into the deleted element/s.\n   */\n  private static unbindAffected(\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n    id: string,\n    updater: (\n      element: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) {\n    // the instance could have been updated, so make sure we are passing the latest element to each function below\n    const prevElement = () => prevElements.get(id); // element before removal\n    const nextElement = () => nextElements.get(id); // element after removal\n\n    BoundElement.unbindAffected(nextElements, prevElement(), updater);\n    BoundElement.unbindAffected(nextElements, nextElement(), updater);\n\n    BindableElement.unbindAffected(nextElements, prevElement(), updater);\n    BindableElement.unbindAffected(nextElements, nextElement(), updater);\n  }\n\n  /**\n   * Non deleted affected elements of added or updated element/s (before and after applying delta),\n   * should be rebound (if possible) with the current element ~ bindings should be bidirectional.\n   */\n  private static rebindAffected(\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n    id: string,\n    updater: (\n      element: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) {\n    // the instance could have been updated, so make sure we are passing the latest element to each function below\n    const prevElement = () => prevElements.get(id); // element before addition / update\n    const nextElement = () => nextElements.get(id); // element after addition / update\n\n    BoundElement.unbindAffected(nextElements, prevElement(), updater);\n    BoundElement.rebindAffected(nextElements, nextElement(), updater);\n\n    BindableElement.unbindAffected(\n      nextElements,\n      prevElement(),\n      (element, updates) => {\n        // we cannot rebind arrows with bindable element so we don't unbind them at all during rebind (we still need to unbind them on removal)\n        // TODO: #7348 add startBinding / endBinding to the `BoundElement` context so that we could rebind arrows and remove this condition\n        if (isTextElement(element)) {\n          updater(element, updates);\n        }\n      },\n    );\n    BindableElement.rebindAffected(nextElements, nextElement(), updater);\n  }\n\n  private static redrawTextBoundingBoxes(\n    scene: Scene,\n    changed: Map<string, OrderedExcalidrawElement>,\n  ) {\n    const elements = scene.getNonDeletedElementsMap();\n    const boxesToRedraw = new Map<\n      string,\n      { container: OrderedExcalidrawElement; boundText: ExcalidrawTextElement }\n    >();\n\n    for (const element of changed.values()) {\n      if (isBoundToContainer(element)) {\n        const { containerId } = element as ExcalidrawTextElement;\n        const container = containerId ? elements.get(containerId) : undefined;\n\n        if (container) {\n          boxesToRedraw.set(container.id, {\n            container,\n            boundText: element as ExcalidrawTextElement,\n          });\n        }\n      }\n\n      if (hasBoundTextElement(element)) {\n        const boundTextElementId = getBoundTextElementId(element);\n        const boundText = boundTextElementId\n          ? elements.get(boundTextElementId)\n          : undefined;\n\n        if (boundText) {\n          boxesToRedraw.set(element.id, {\n            container: element,\n            boundText: boundText as ExcalidrawTextElement,\n          });\n        }\n      }\n    }\n\n    for (const { container, boundText } of boxesToRedraw.values()) {\n      if (container.isDeleted || boundText.isDeleted) {\n        // skip redraw if one of them is deleted, as it would not result in a meaningful redraw\n        continue;\n      }\n\n      redrawTextBoundingBox(boundText, container, scene);\n    }\n  }\n\n  private static redrawBoundArrows(\n    scene: Scene,\n    changed: Map<string, OrderedExcalidrawElement>,\n  ) {\n    for (const element of changed.values()) {\n      if (!element.isDeleted && isBindableElement(element)) {\n        updateBoundElements(element, scene, {\n          changedElements: changed,\n        });\n      }\n    }\n  }\n\n  private static reorderElements(\n    elements: SceneElementsMap,\n    changed: Map<string, OrderedExcalidrawElement>,\n    flags: {\n      containsVisibleDifference: boolean;\n      containsZindexDifference: boolean;\n    },\n  ) {\n    if (!flags.containsZindexDifference) {\n      return elements;\n    }\n\n    const unordered = Array.from(elements.values());\n    const ordered = orderByFractionalIndex([...unordered]);\n    const moved = Delta.getRightDifferences(unordered, ordered, true).reduce(\n      (acc, arrayIndex) => {\n        const candidate = unordered[Number(arrayIndex)];\n        if (candidate && changed.has(candidate.id)) {\n          acc.set(candidate.id, candidate);\n        }\n\n        return acc;\n      },\n      new Map(),\n    );\n\n    if (!flags.containsVisibleDifference && moved.size) {\n      // we found a difference in order!\n      flags.containsVisibleDifference = true;\n    }\n\n    // synchronize all elements that were actually moved\n    // could fallback to synchronizing all invalid indices\n    return arrayToMap(syncMovedIndices(ordered, moved)) as typeof elements;\n  }\n\n  /**\n   * It is necessary to post process the partials in case of reference values,\n   * for which we need to calculate the real diff between `deleted` and `inserted`.\n   */\n  private static postProcess(\n    deleted: ElementPartial,\n    inserted: ElementPartial,\n  ): [ElementPartial, ElementPartial] {\n    try {\n      Delta.diffArrays(deleted, inserted, \"boundElements\", (x) => x.id);\n\n      // don't diff the points as:\n      // - we can't ensure the multiplayer order consistency without fractional index on each point\n      // - we prefer to not merge the points, as it might just lead to unexpected / incosistent results\n      const deletedPoints =\n        (\n          deleted as ElementPartial<\n            ExcalidrawFreeDrawElement | ExcalidrawLinearElement\n          >\n        ).points ?? [];\n\n      const insertedPoints =\n        (\n          inserted as ElementPartial<\n            ExcalidrawFreeDrawElement | ExcalidrawLinearElement\n          >\n        ).points ?? [];\n\n      if (!Delta.isDifferent(deletedPoints, insertedPoints)) {\n        // delete the points from delta if there is no difference, otherwise leave them as they were captured due to consistency\n        Reflect.deleteProperty(deleted, \"points\");\n        Reflect.deleteProperty(inserted, \"points\");\n      }\n    } catch (e) {\n      // if postprocessing fails, it does not make sense to bubble up, but let's make sure we know about it\n      console.error(`Couldn't postprocess elements delta.`);\n\n      if (isTestEnv() || isDevEnv()) {\n        throw e;\n      }\n    } finally {\n      return [deleted, inserted];\n    }\n  }\n\n  private static stripIrrelevantProps(\n    partial: Partial<OrderedExcalidrawElement>,\n  ): ElementPartial {\n    const { id, updated, ...strippedPartial } = partial;\n\n    return strippedPartial;\n  }\n}\n",
    "import {\n  assertNever,\n  COLOR_PALETTE,\n  isDevEnv,\n  isTestEnv,\n  randomId,\n  Emitter,\n  toIterable,\n} from \"@excalidraw/common\";\n\nimport type App from \"excalidraw-custom/components/App\";\n\nimport type { DTO, ValueOf } from \"@excalidraw/common/utility-types\";\n\nimport type { AppState, ObservedAppState } from \"excalidraw-custom/types\";\n\nimport { deepCopyElement } from \"./duplicate\";\nimport { newElementWith } from \"./mutateElement\";\n\nimport { ElementsDelta, AppStateDelta, Delta } from \"./delta\";\n\nimport {\n  syncInvalidIndicesImmutable,\n  hashElementsVersion,\n  hashString,\n  isInitializedImageElement,\n  isImageElement,\n} from \"./index\";\n\nimport type {\n  ExcalidrawElement,\n  OrderedExcalidrawElement,\n  SceneElementsMap,\n} from \"./types\";\n\nexport const CaptureUpdateAction = {\n  /**\n   * Immediately undoable.\n   *\n   * Use for updates which should be captured.\n   * Should be used for most of the local updates, except ephemerals such as dragging or resizing.\n   *\n   * These updates will _immediately_ make it to the local undo / redo stacks.\n   */\n  IMMEDIATELY: \"IMMEDIATELY\",\n  /**\n   * Never undoable.\n   *\n   * Use for updates which should never be recorded, such as remote updates\n   * or scene initialization.\n   *\n   * These updates will _never_ make it to the local undo / redo stacks.\n   */\n  NEVER: \"NEVER\",\n  /**\n   * Eventually undoable.\n   *\n   * Use for updates which should not be captured immediately - likely\n   * exceptions which are part of some async multi-step process. Otherwise, all\n   * such updates would end up being captured with the next\n   * `CaptureUpdateAction.IMMEDIATELY` - triggered either by the next `updateScene`\n   * or internally by the editor.\n   *\n   * These updates will _eventually_ make it to the local undo / redo stacks.\n   */\n  EVENTUALLY: \"EVENTUALLY\",\n} as const;\n\nexport type CaptureUpdateActionType = ValueOf<typeof CaptureUpdateAction>;\n\ntype MicroActionsQueue = (() => void)[];\n\n/**\n * Store which captures the observed changes and emits them as `StoreIncrement` events.\n */\nexport class Store {\n  // internally used by history\n  public readonly onDurableIncrementEmitter = new Emitter<[DurableIncrement]>();\n  public readonly onStoreIncrementEmitter = new Emitter<\n    [DurableIncrement | EphemeralIncrement]\n  >();\n\n  private scheduledMacroActions: Set<CaptureUpdateActionType> = new Set();\n  private scheduledMicroActions: MicroActionsQueue = [];\n\n  private _snapshot = StoreSnapshot.empty();\n\n  public get snapshot() {\n    return this._snapshot;\n  }\n\n  public set snapshot(snapshot: StoreSnapshot) {\n    this._snapshot = snapshot;\n  }\n\n  constructor(private readonly app: App) {}\n\n  public scheduleAction(action: CaptureUpdateActionType) {\n    this.scheduledMacroActions.add(action);\n    this.satisfiesScheduledActionsInvariant();\n  }\n\n  /**\n   * Use to schedule a delta calculation, which will consquentially be emitted as `DurableStoreIncrement` and pushed in the undo stack.\n   */\n  // TODO: Suspicious that this is called so many places. Seems error-prone.\n  public scheduleCapture() {\n    this.scheduleAction(CaptureUpdateAction.IMMEDIATELY);\n  }\n\n  /**\n   * Schedule special \"micro\" actions, to-be executed before the next commit, before it executes a scheduled \"macro\" action.\n   */\n  public scheduleMicroAction(\n    params:\n      | {\n          action: CaptureUpdateActionType;\n          elements: readonly ExcalidrawElement[] | undefined;\n          appState: AppState | ObservedAppState | undefined;\n        }\n      | {\n          action: typeof CaptureUpdateAction.IMMEDIATELY;\n          change: StoreChange;\n          delta: StoreDelta;\n        }\n      | {\n          action:\n            | typeof CaptureUpdateAction.NEVER\n            | typeof CaptureUpdateAction.EVENTUALLY;\n          change: StoreChange;\n        },\n  ) {\n    const { action } = params;\n\n    let change: StoreChange;\n\n    if (\"change\" in params) {\n      change = params.change;\n    } else {\n      // immediately create an immutable change of the scheduled updates,\n      // compared to the current state, so that they won't mutate later on during batching\n      // also, we have to compare against the current state,\n      // as comparing against the snapshot might include yet uncomitted changes (i.e. async freedraw / text / image, etc.)\n      const currentSnapshot = StoreSnapshot.create(\n        this.app.scene.getElementsMapIncludingDeleted(),\n        this.app.state,\n      );\n\n      const scheduledSnapshot = currentSnapshot.maybeClone(\n        action,\n        // let's sync invalid indices first, so that we could detect this change\n        // also have the synced elements immutable, so that we don't mutate elements,\n        // that are already in the scene, otherwise we wouldn't see any change\n        params.elements\n          ? syncInvalidIndicesImmutable(params.elements)\n          : undefined,\n        params.appState,\n      );\n\n      change = StoreChange.create(currentSnapshot, scheduledSnapshot);\n    }\n\n    const delta = \"delta\" in params ? params.delta : undefined;\n\n    this.scheduledMicroActions.push(() =>\n      this.processAction({\n        action,\n        change,\n        delta,\n      }),\n    );\n  }\n\n  /**\n   * Performs the incoming `CaptureUpdateAction` and emits the corresponding `StoreIncrement`.\n   * Emits `DurableStoreIncrement` when action is \"capture\", emits `EphemeralStoreIncrement` otherwise.\n   *\n   * @emits StoreIncrement\n   */\n  public commit(\n    elements: SceneElementsMap | undefined,\n    appState: AppState | ObservedAppState | undefined,\n  ): void {\n    // execute all scheduled micro actions first\n    // similar to microTasks, there can be many\n    this.flushMicroActions();\n\n    try {\n      // execute a single scheduled \"macro\" function\n      // similar to macro tasks, there can be only one within a single commit (loop)\n      const action = this.getScheduledMacroAction();\n      this.processAction({ action, elements, appState });\n    } finally {\n      this.satisfiesScheduledActionsInvariant();\n      // defensively reset all scheduled \"macro\" actions, possibly cleans up other runtime garbage\n      this.scheduledMacroActions = new Set();\n    }\n  }\n\n  /**\n   * Clears the store instance.\n   */\n  public clear(): void {\n    this.snapshot = StoreSnapshot.empty();\n    this.scheduledMacroActions = new Set();\n  }\n\n  /**\n   * Performs delta & change calculation and emits a durable increment.\n   *\n   * @emits StoreIncrement.\n   */\n  private emitDurableIncrement(\n    snapshot: StoreSnapshot,\n    change: StoreChange | undefined = undefined,\n    delta: StoreDelta | undefined = undefined,\n  ) {\n    const prevSnapshot = this.snapshot;\n\n    let storeChange: StoreChange;\n    let storeDelta: StoreDelta;\n\n    if (change) {\n      storeChange = change;\n    } else {\n      storeChange = StoreChange.create(prevSnapshot, snapshot);\n    }\n\n    if (delta) {\n      // we might have the delta already (i.e. when applying history entry), thus we don't need to calculate it again\n      // using the same instance, since in history we have a check against `HistoryEntry`, so that we don't re-record the same delta again\n      storeDelta = delta;\n    } else {\n      storeDelta = StoreDelta.calculate(prevSnapshot, snapshot);\n    }\n\n    if (!storeDelta.isEmpty()) {\n      const increment = new DurableIncrement(storeChange, storeDelta);\n\n      // Notify listeners with the increment\n      this.onDurableIncrementEmitter.trigger(increment);\n      this.onStoreIncrementEmitter.trigger(increment);\n    }\n  }\n\n  /**\n   * Performs change calculation and emits an ephemeral increment.\n   *\n   * @emits EphemeralStoreIncrement\n   */\n  private emitEphemeralIncrement(\n    snapshot: StoreSnapshot,\n    change: StoreChange | undefined = undefined,\n  ) {\n    let storeChange: StoreChange;\n\n    if (change) {\n      storeChange = change;\n    } else {\n      const prevSnapshot = this.snapshot;\n      storeChange = StoreChange.create(prevSnapshot, snapshot);\n    }\n\n    const increment = new EphemeralIncrement(storeChange);\n\n    // Notify listeners with the increment\n    this.onStoreIncrementEmitter.trigger(increment);\n  }\n\n  private applyChangeToSnapshot(change: StoreChange) {\n    const prevSnapshot = this.snapshot;\n    const nextSnapshot = this.snapshot.applyChange(change);\n\n    if (prevSnapshot === nextSnapshot) {\n      return null;\n    }\n\n    return nextSnapshot;\n  }\n\n  /**\n   * Clones the snapshot if there are changes detected.\n   */\n  private maybeCloneSnapshot(\n    action: CaptureUpdateActionType,\n    elements: SceneElementsMap | undefined,\n    appState: AppState | ObservedAppState | undefined,\n  ) {\n    if (!elements && !appState) {\n      return null;\n    }\n\n    const prevSnapshot = this.snapshot;\n    const nextSnapshot = this.snapshot.maybeClone(action, elements, appState);\n\n    if (prevSnapshot === nextSnapshot) {\n      return null;\n    }\n\n    return nextSnapshot;\n  }\n\n  private flushMicroActions() {\n    for (const microAction of this.scheduledMicroActions) {\n      try {\n        microAction();\n      } catch (error) {\n        console.error(`Failed to execute scheduled micro action`, error);\n      }\n    }\n\n    this.scheduledMicroActions = [];\n  }\n\n  private processAction(\n    params:\n      | {\n          action: CaptureUpdateActionType;\n          elements: SceneElementsMap | undefined;\n          appState: AppState | ObservedAppState | undefined;\n        }\n      | {\n          action: CaptureUpdateActionType;\n          change: StoreChange;\n          delta: StoreDelta | undefined;\n        },\n  ) {\n    const { action } = params;\n\n    // perf. optimisation, since \"EVENTUALLY\" does not update the snapshot,\n    // so if nobody is listening for increments, we don't need to even clone the snapshot\n    // as it's only needed for `StoreChange` computation inside `EphemeralIncrement`\n    if (\n      action === CaptureUpdateAction.EVENTUALLY &&\n      !this.onStoreIncrementEmitter.subscribers.length\n    ) {\n      return;\n    }\n\n    let nextSnapshot: StoreSnapshot | null;\n\n    if (\"change\" in params) {\n      nextSnapshot = this.applyChangeToSnapshot(params.change);\n    } else {\n      nextSnapshot = this.maybeCloneSnapshot(\n        action,\n        params.elements,\n        params.appState,\n      );\n    }\n\n    if (!nextSnapshot) {\n      // don't continue if there is not change detected\n      return;\n    }\n\n    const change = \"change\" in params ? params.change : undefined;\n    const delta = \"delta\" in params ? params.delta : undefined;\n\n    try {\n      switch (action) {\n        // only immediately emits a durable increment\n        case CaptureUpdateAction.IMMEDIATELY:\n          this.emitDurableIncrement(nextSnapshot, change, delta);\n          break;\n        // both never and eventually emit an ephemeral increment\n        case CaptureUpdateAction.NEVER:\n        case CaptureUpdateAction.EVENTUALLY:\n          this.emitEphemeralIncrement(nextSnapshot, change);\n          break;\n        default:\n          assertNever(action, `Unknown store action`);\n      }\n    } finally {\n      // update the snapshot no-matter what, as it would mess up with the next action\n      switch (action) {\n        // both immediately and never update the snapshot, unlike eventually\n        case CaptureUpdateAction.IMMEDIATELY:\n        case CaptureUpdateAction.NEVER:\n          this.snapshot = nextSnapshot;\n          break;\n      }\n    }\n  }\n\n  /**\n   * Returns the scheduled macro action.\n   */\n  private getScheduledMacroAction() {\n    let scheduledAction: CaptureUpdateActionType;\n\n    if (this.scheduledMacroActions.has(CaptureUpdateAction.IMMEDIATELY)) {\n      // Capture has a precedence over update, since it also performs snapshot update\n      scheduledAction = CaptureUpdateAction.IMMEDIATELY;\n    } else if (this.scheduledMacroActions.has(CaptureUpdateAction.NEVER)) {\n      // Update has a precedence over none, since it also emits an (ephemeral) increment\n      scheduledAction = CaptureUpdateAction.NEVER;\n    } else {\n      // Default is to emit ephemeral increment and don't update the snapshot\n      scheduledAction = CaptureUpdateAction.EVENTUALLY;\n    }\n\n    return scheduledAction;\n  }\n\n  /**\n   * Ensures that the scheduled actions invariant is satisfied.\n   */\n  private satisfiesScheduledActionsInvariant() {\n    if (\n      !(\n        this.scheduledMacroActions.size >= 0 &&\n        this.scheduledMacroActions.size <=\n          Object.keys(CaptureUpdateAction).length\n      )\n    ) {\n      const message = `There can be at most three store actions scheduled at the same time, but there are \"${this.scheduledMacroActions.size}\".`;\n      console.error(message, this.scheduledMacroActions.values());\n\n      if (isTestEnv() || isDevEnv()) {\n        throw new Error(message);\n      }\n    }\n  }\n}\n\n/**\n * Repsents a change to the store containing changed elements and appState.\n */\nexport class StoreChange {\n  // so figuring out what has changed should ideally be just quick reference checks\n  // TODO: we might need to have binary files here as well, in order to be drop-in replacement for `onChange`\n  private constructor(\n    public readonly elements: Record<string, OrderedExcalidrawElement>,\n    public readonly appState: Partial<ObservedAppState>,\n  ) {}\n\n  public static create(\n    prevSnapshot: StoreSnapshot,\n    nextSnapshot: StoreSnapshot,\n  ) {\n    const changedElements = nextSnapshot.getChangedElements(prevSnapshot);\n    const changedAppState = nextSnapshot.getChangedAppState(prevSnapshot);\n\n    return new StoreChange(changedElements, changedAppState);\n  }\n}\n\n/**\n * Encpasulates any change to the store (durable or ephemeral).\n */\nexport abstract class StoreIncrement {\n  protected constructor(\n    public readonly type: \"durable\" | \"ephemeral\",\n    public readonly change: StoreChange,\n  ) {}\n\n  public static isDurable(\n    increment: StoreIncrement,\n  ): increment is DurableIncrement {\n    return increment.type === \"durable\";\n  }\n\n  public static isEphemeral(\n    increment: StoreIncrement,\n  ): increment is EphemeralIncrement {\n    return increment.type === \"ephemeral\";\n  }\n}\n\n/**\n * Represents a durable change to the store.\n */\nexport class DurableIncrement extends StoreIncrement {\n  constructor(\n    public readonly change: StoreChange,\n    public readonly delta: StoreDelta,\n  ) {\n    super(\"durable\", change);\n  }\n}\n\n/**\n * Represents an ephemeral change to the store.\n */\nexport class EphemeralIncrement extends StoreIncrement {\n  constructor(public readonly change: StoreChange) {\n    super(\"ephemeral\", change);\n  }\n}\n\n/**\n * Represents a captured delta by the Store.\n */\nexport class StoreDelta {\n  protected constructor(\n    public readonly id: string,\n    public readonly elements: ElementsDelta,\n    public readonly appState: AppStateDelta,\n  ) {}\n\n  /**\n   * Create a new instance of `StoreDelta`.\n   */\n  public static create(\n    elements: ElementsDelta,\n    appState: AppStateDelta,\n    opts: {\n      id: string;\n    } = {\n      id: randomId(),\n    },\n  ) {\n    return new this(opts.id, elements, appState);\n  }\n\n  /**\n   * Calculate the delta between the previous and next snapshot.\n   */\n  public static calculate(\n    prevSnapshot: StoreSnapshot,\n    nextSnapshot: StoreSnapshot,\n  ) {\n    const elementsDelta = nextSnapshot.metadata.didElementsChange\n      ? ElementsDelta.calculate(prevSnapshot.elements, nextSnapshot.elements)\n      : ElementsDelta.empty();\n\n    const appStateDelta = nextSnapshot.metadata.didAppStateChange\n      ? AppStateDelta.calculate(prevSnapshot.appState, nextSnapshot.appState)\n      : AppStateDelta.empty();\n\n    return this.create(elementsDelta, appStateDelta);\n  }\n\n  /**\n   * Restore a store delta instance from a DTO.\n   */\n  public static restore(storeDeltaDTO: DTO<StoreDelta>) {\n    const { id, elements, appState } = storeDeltaDTO;\n    return new this(\n      id,\n      ElementsDelta.restore(elements),\n      AppStateDelta.restore(appState),\n    );\n  }\n\n  /**\n   * Parse and load the delta from the remote payload.\n   */\n  public static load({\n    id,\n    elements: { added, removed, updated },\n  }: DTO<StoreDelta>) {\n    const elements = ElementsDelta.create(added, removed, updated);\n\n    return new this(id, elements, AppStateDelta.empty());\n  }\n\n  /**\n   * Inverse store delta, creates new instance of `StoreDelta`.\n   */\n  public static inverse(delta: StoreDelta) {\n    return this.create(delta.elements.inverse(), delta.appState.inverse());\n  }\n\n  /**\n   * Apply the delta to the passed elements and appState, does not modify the snapshot.\n   */\n  public static applyTo(\n    delta: StoreDelta,\n    elements: SceneElementsMap,\n    appState: AppState,\n  ): [SceneElementsMap, AppState, boolean] {\n    const [nextElements, elementsContainVisibleChange] =\n      delta.elements.applyTo(elements);\n\n    const [nextAppState, appStateContainsVisibleChange] =\n      delta.appState.applyTo(appState, nextElements);\n\n    const appliedVisibleChanges =\n      elementsContainVisibleChange || appStateContainsVisibleChange;\n\n    return [nextElements, nextAppState, appliedVisibleChanges];\n  }\n\n  /**\n   * Apply latest (remote) changes to the delta, creates new instance of `StoreDelta`.\n   */\n  public static applyLatestChanges(\n    delta: StoreDelta,\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n    modifierOptions?: \"deleted\" | \"inserted\",\n  ): StoreDelta {\n    return this.create(\n      delta.elements.applyLatestChanges(\n        prevElements,\n        nextElements,\n        modifierOptions,\n      ),\n      delta.appState,\n      {\n        id: delta.id,\n      },\n    );\n  }\n\n  public isEmpty() {\n    return this.elements.isEmpty() && this.appState.isEmpty();\n  }\n}\n\n/**\n * Represents a snapshot of the captured or updated changes in the store,\n * used for producing deltas and emitting `DurableStoreIncrement`s.\n */\nexport class StoreSnapshot {\n  private _lastChangedElementsHash: number = 0;\n  private _lastChangedAppStateHash: number = 0;\n\n  private constructor(\n    public readonly elements: SceneElementsMap,\n    public readonly appState: ObservedAppState,\n    public readonly metadata: {\n      didElementsChange: boolean;\n      didAppStateChange: boolean;\n      isEmpty?: boolean;\n    } = {\n      didElementsChange: false,\n      didAppStateChange: false,\n      isEmpty: false,\n    },\n  ) {}\n\n  public static create(\n    elements: SceneElementsMap,\n    appState: AppState | ObservedAppState,\n    metadata: {\n      didElementsChange: boolean;\n      didAppStateChange: boolean;\n    } = {\n      didElementsChange: false,\n      didAppStateChange: false,\n    },\n  ) {\n    return new StoreSnapshot(\n      elements,\n      isObservedAppState(appState) ? appState : getObservedAppState(appState),\n      metadata,\n    );\n  }\n\n  public static empty() {\n    return new StoreSnapshot(\n      new Map() as SceneElementsMap,\n      getDefaultObservedAppState(),\n      {\n        didElementsChange: false,\n        didAppStateChange: false,\n        isEmpty: true,\n      },\n    );\n  }\n\n  public getChangedElements(prevSnapshot: StoreSnapshot) {\n    const changedElements: Record<string, OrderedExcalidrawElement> = {};\n\n    for (const prevElement of toIterable(prevSnapshot.elements)) {\n      const nextElement = this.elements.get(prevElement.id);\n\n      if (!nextElement) {\n        changedElements[prevElement.id] = newElementWith(prevElement, {\n          isDeleted: true,\n        });\n      }\n    }\n\n    for (const nextElement of toIterable(this.elements)) {\n      // Due to the structural clone inside `maybeClone`, we can perform just these reference checks\n      if (prevSnapshot.elements.get(nextElement.id) !== nextElement) {\n        changedElements[nextElement.id] = nextElement;\n      }\n    }\n\n    return changedElements;\n  }\n\n  public getChangedAppState(\n    prevSnapshot: StoreSnapshot,\n  ): Partial<ObservedAppState> {\n    return Delta.getRightDifferences(\n      prevSnapshot.appState,\n      this.appState,\n    ).reduce(\n      (acc, key) =>\n        Object.assign(acc, {\n          [key]: this.appState[key as keyof ObservedAppState],\n        }),\n      {} as Partial<ObservedAppState>,\n    );\n  }\n\n  public isEmpty() {\n    return this.metadata.isEmpty;\n  }\n\n  /**\n   * Apply the change and return a new snapshot instance.\n   */\n  public applyChange(change: StoreChange): StoreSnapshot {\n    const nextElements = new Map(this.elements) as SceneElementsMap;\n\n    for (const [id, changedElement] of Object.entries(change.elements)) {\n      nextElements.set(id, changedElement);\n    }\n\n    const nextAppState = getObservedAppState({\n      ...this.appState,\n      ...change.appState,\n    });\n\n    return StoreSnapshot.create(nextElements, nextAppState, {\n      // by default we assume that change is different from what we have in the snapshot\n      // so that we trigger the delta calculation and if it isn't different, delta will be empty\n      didElementsChange: Object.keys(change.elements).length > 0,\n      didAppStateChange: Object.keys(change.appState).length > 0,\n    });\n  }\n\n  /**\n   * Efficiently clone the existing snapshot, only if we detected changes.\n   *\n   * @returns same instance if there are no changes detected, new instance otherwise.\n   */\n  public maybeClone(\n    action: CaptureUpdateActionType,\n    elements: SceneElementsMap | undefined,\n    appState: AppState | ObservedAppState | undefined,\n  ) {\n    const options = {\n      shouldCompareHashes: false,\n    };\n\n    if (action === CaptureUpdateAction.EVENTUALLY) {\n      // actions that do not update the snapshot immediately, must be additionally checked for changes against the latest hash\n      // as we are always comparing against the latest snapshot, so they would emit elements or appState as changed on every component update\n      // instead of just the first time the elements or appState actually changed\n      options.shouldCompareHashes = true;\n    }\n\n    const nextElementsSnapshot = this.maybeCreateElementsSnapshot(\n      elements,\n      options,\n    );\n    const nextAppStateSnapshot = this.maybeCreateAppStateSnapshot(\n      appState,\n      options,\n    );\n\n    let didElementsChange = false;\n    let didAppStateChange = false;\n\n    if (this.elements !== nextElementsSnapshot) {\n      didElementsChange = true;\n    }\n\n    if (this.appState !== nextAppStateSnapshot) {\n      didAppStateChange = true;\n    }\n\n    if (!didElementsChange && !didAppStateChange) {\n      return this;\n    }\n\n    const snapshot = new StoreSnapshot(\n      nextElementsSnapshot,\n      nextAppStateSnapshot,\n      {\n        didElementsChange,\n        didAppStateChange,\n      },\n    );\n\n    return snapshot;\n  }\n\n  private maybeCreateAppStateSnapshot(\n    appState: AppState | ObservedAppState | undefined,\n    options: {\n      shouldCompareHashes: boolean;\n    } = {\n      shouldCompareHashes: false,\n    },\n  ): ObservedAppState {\n    if (!appState) {\n      return this.appState;\n    }\n\n    // Not watching over everything from the app state, just the relevant props\n    const nextAppStateSnapshot = !isObservedAppState(appState)\n      ? getObservedAppState(appState)\n      : appState;\n\n    const didAppStateChange = this.detectChangedAppState(\n      nextAppStateSnapshot,\n      options,\n    );\n\n    if (!didAppStateChange) {\n      return this.appState;\n    }\n\n    return nextAppStateSnapshot;\n  }\n\n  private maybeCreateElementsSnapshot(\n    elements: SceneElementsMap | undefined,\n    options: {\n      shouldCompareHashes: boolean;\n    } = {\n      shouldCompareHashes: false,\n    },\n  ): SceneElementsMap {\n    if (!elements) {\n      return this.elements;\n    }\n\n    const changedElements = this.detectChangedElements(elements, options);\n\n    if (!changedElements?.size) {\n      return this.elements;\n    }\n\n    const elementsSnapshot = this.createElementsSnapshot(changedElements);\n    return elementsSnapshot;\n  }\n\n  private detectChangedAppState(\n    nextObservedAppState: ObservedAppState,\n    options: {\n      shouldCompareHashes: boolean;\n    } = {\n      shouldCompareHashes: false,\n    },\n  ): boolean | undefined {\n    if (this.appState === nextObservedAppState) {\n      return;\n    }\n\n    const didAppStateChange = Delta.isRightDifferent(\n      this.appState,\n      nextObservedAppState,\n    );\n\n    if (!didAppStateChange) {\n      return;\n    }\n\n    const changedAppStateHash = hashString(\n      JSON.stringify(nextObservedAppState),\n    );\n\n    if (\n      options.shouldCompareHashes &&\n      this._lastChangedAppStateHash === changedAppStateHash\n    ) {\n      return;\n    }\n\n    this._lastChangedAppStateHash = changedAppStateHash;\n\n    return didAppStateChange;\n  }\n\n  /**\n   * Detect if there are any changed elements.\n   */\n  private detectChangedElements(\n    nextElements: SceneElementsMap,\n    options: {\n      shouldCompareHashes: boolean;\n    } = {\n      shouldCompareHashes: false,\n    },\n  ): SceneElementsMap | undefined {\n    if (this.elements === nextElements) {\n      return;\n    }\n\n    const changedElements: SceneElementsMap = new Map() as SceneElementsMap;\n\n    for (const prevElement of toIterable(this.elements)) {\n      const nextElement = nextElements.get(prevElement.id);\n\n      if (!nextElement) {\n        // element was deleted\n        changedElements.set(\n          prevElement.id,\n          newElementWith(prevElement, { isDeleted: true }),\n        );\n      }\n    }\n\n    for (const nextElement of toIterable(nextElements)) {\n      const prevElement = this.elements.get(nextElement.id);\n\n      if (\n        !prevElement || // element was added\n        prevElement.version < nextElement.version // element was updated\n      ) {\n        if (\n          isImageElement(nextElement) &&\n          !isInitializedImageElement(nextElement)\n        ) {\n          // ignore any updates on uninitialized image elements\n          continue;\n        }\n\n        changedElements.set(nextElement.id, nextElement);\n      }\n    }\n\n    if (!changedElements.size) {\n      return;\n    }\n\n    const changedElementsHash = hashElementsVersion(changedElements);\n\n    if (\n      options.shouldCompareHashes &&\n      this._lastChangedElementsHash === changedElementsHash\n    ) {\n      return;\n    }\n\n    this._lastChangedElementsHash = changedElementsHash;\n\n    return changedElements;\n  }\n\n  /**\n   * Perform structural clone, deep cloning only elements that changed.\n   */\n  private createElementsSnapshot(changedElements: SceneElementsMap) {\n    const clonedElements = new Map() as SceneElementsMap;\n\n    for (const prevElement of toIterable(this.elements)) {\n      // Clone previous elements, never delete, in case nextElements would be just a subset of previous elements\n      // i.e. during collab, persist or whenenever isDeleted elements get cleared\n      clonedElements.set(prevElement.id, prevElement);\n    }\n\n    for (const changedElement of toIterable(changedElements)) {\n      // TODO: consider just creating new instance, once we can ensure that all reference properties on every element are immutable\n      // TODO: consider creating a lazy deep clone, having a one-time-usage proxy over the snapshotted element and deep cloning only if it gets mutated\n      clonedElements.set(changedElement.id, deepCopyElement(changedElement));\n    }\n\n    return clonedElements;\n  }\n}\n\n// hidden non-enumerable property for runtime checks\nconst hiddenObservedAppStateProp = \"__observedAppState\";\n\nconst getDefaultObservedAppState = (): ObservedAppState => {\n  return {\n    name: null,\n    editingGroupId: null,\n    viewBackgroundColor: COLOR_PALETTE.white,\n    selectedElementIds: {},\n    selectedGroupIds: {},\n    editingLinearElementId: null,\n    selectedLinearElementId: null,\n    croppingElementId: null,\n    activeLockedId: null,\n    lockedMultiSelections: {},\n  };\n};\n\nexport const getObservedAppState = (\n  appState: AppState | ObservedAppState,\n): ObservedAppState => {\n  const observedAppState = {\n    name: appState.name,\n    editingGroupId: appState.editingGroupId,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    selectedElementIds: appState.selectedElementIds,\n    selectedGroupIds: appState.selectedGroupIds,\n    croppingElementId: appState.croppingElementId,\n    activeLockedId: appState.activeLockedId,\n    lockedMultiSelections: appState.lockedMultiSelections,\n    editingLinearElementId:\n      (appState as AppState).editingLinearElement?.elementId ?? // prefer app state, as it's likely newer\n      (appState as ObservedAppState).editingLinearElementId ?? // fallback to observed app state, as it's likely older coming from a previous snapshot\n      null,\n    selectedLinearElementId:\n      (appState as AppState).selectedLinearElement?.elementId ??\n      (appState as ObservedAppState).selectedLinearElementId ??\n      null,\n  };\n\n  Reflect.defineProperty(observedAppState, hiddenObservedAppStateProp, {\n    value: true,\n    enumerable: false,\n  });\n\n  return observedAppState;\n};\n\nconst isObservedAppState = (\n  appState: AppState | ObservedAppState,\n): appState is ObservedAppState =>\n  !!Reflect.get(appState, hiddenObservedAppStateProp);\n",
    "import {\n  ORIG_ID,\n  randomId,\n  randomInteger,\n  arrayToMap,\n  castArray,\n  findLastIndex,\n  getUpdatedTimestamp,\n  isTestEnv,\n} from \"@excalidraw/common\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport type { AppState } from \"excalidraw-custom/types\";\n\nimport {\n  getElementsInGroup,\n  getNewGroupIdsForDuplication,\n  getSelectedGroupForElement,\n} from \"./groups\";\n\nimport {\n  bindElementsToFramesAfterDuplication,\n  getFrameChildren,\n} from \"./frame\";\n\nimport { normalizeElementOrder } from \"./sortElements\";\n\nimport { bumpVersion } from \"./mutateElement\";\n\nimport {\n  hasBoundTextElement,\n  isBoundToContainer,\n  isFrameLikeElement,\n} from \"./typeChecks\";\n\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\n\nimport { fixDuplicatedBindingsAfterDuplication } from \"./binding\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  GroupId,\n  NonDeletedSceneElementsMap,\n} from \"./types\";\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n */\nexport const duplicateElement = <TElement extends ExcalidrawElement>(\n  editingGroupId: AppState[\"editingGroupId\"],\n  groupIdMapForOperation: Map<GroupId, GroupId>,\n  element: TElement,\n  randomizeSeed?: boolean,\n): Readonly<TElement> => {\n  const copy = deepCopyElement(element);\n\n  if (isTestEnv()) {\n    __test__defineOrigId(copy, element.id);\n  }\n\n  copy.id = randomId();\n  copy.updated = getUpdatedTimestamp();\n  if (randomizeSeed) {\n    copy.seed = randomInteger();\n    bumpVersion(copy);\n  }\n\n  copy.groupIds = getNewGroupIdsForDuplication(\n    copy.groupIds,\n    editingGroupId,\n    (groupId) => {\n      if (!groupIdMapForOperation.has(groupId)) {\n        groupIdMapForOperation.set(groupId, randomId());\n      }\n      return groupIdMapForOperation.get(groupId)!;\n    },\n  );\n  return copy;\n};\n\nexport const duplicateElements = (\n  opts: {\n    elements: readonly ExcalidrawElement[];\n    randomizeSeed?: boolean;\n    overrides?: (data: {\n      duplicateElement: ExcalidrawElement;\n      origElement: ExcalidrawElement;\n      origIdToDuplicateId: Map<\n        ExcalidrawElement[\"id\"],\n        ExcalidrawElement[\"id\"]\n      >;\n    }) => Partial<ExcalidrawElement>;\n  } & (\n    | {\n        /**\n         * Duplicates all elements in array.\n         *\n         * Use this when programmaticaly duplicating elements, without direct\n         * user interaction.\n         */\n        type: \"everything\";\n      }\n    | {\n        /**\n         * Duplicates specified elements and inserts them back into the array\n         * in specified order.\n         *\n         * Use this when duplicating Scene elements, during user interaction\n         * such as alt-drag or on duplicate action.\n         */\n        type: \"in-place\";\n        idsOfElementsToDuplicate: Map<\n          ExcalidrawElement[\"id\"],\n          ExcalidrawElement\n        >;\n        appState: {\n          editingGroupId: AppState[\"editingGroupId\"];\n          selectedGroupIds: AppState[\"selectedGroupIds\"];\n        };\n      }\n  ),\n) => {\n  let { elements } = opts;\n\n  const appState =\n    \"appState\" in opts\n      ? opts.appState\n      : ({\n          editingGroupId: null,\n          selectedGroupIds: {},\n        } as const);\n\n  // Ids of elements that have already been processed so we don't push them\n  // into the array twice if we end up backtracking when retrieving\n  // discontiguous group of elements (can happen due to a bug, or in edge\n  // cases such as a group containing deleted elements which were not selected).\n  //\n  // This is not enough to prevent duplicates, so we do a second loop afterwards\n  // to remove them.\n  //\n  // For convenience we mark even the newly created ones even though we don't\n  // loop over them.\n  const processedIds = new Map<ExcalidrawElement[\"id\"], true>();\n  const groupIdMap = new Map();\n  const duplicatedElements: ExcalidrawElement[] = [];\n  const origElements: ExcalidrawElement[] = [];\n  const origIdToDuplicateId = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement[\"id\"]\n  >();\n  const duplicateIdToOrigElement = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >();\n  const duplicateElementsMap = new Map<string, ExcalidrawElement>();\n  const elementsMap = arrayToMap(elements) as ElementsMap;\n  const _idsOfElementsToDuplicate =\n    opts.type === \"in-place\"\n      ? opts.idsOfElementsToDuplicate\n      : new Map(elements.map((el) => [el.id, el]));\n\n  // For sanity\n  if (opts.type === \"in-place\") {\n    for (const groupId of Object.keys(opts.appState.selectedGroupIds)) {\n      elements\n        .filter((el) => el.groupIds?.includes(groupId))\n        .forEach((el) => _idsOfElementsToDuplicate.set(el.id, el));\n    }\n  }\n\n  elements = normalizeElementOrder(elements);\n\n  const elementsWithDuplicates: ExcalidrawElement[] = elements.slice();\n\n  // helper functions\n  // -------------------------------------------------------------------------\n\n  // Used for the heavy lifing of copying a single element, a group of elements\n  // an element with bound text etc.\n  const copyElements = <T extends ExcalidrawElement | ExcalidrawElement[]>(\n    element: T,\n  ): T extends ExcalidrawElement[]\n    ? ExcalidrawElement[]\n    : ExcalidrawElement | null => {\n    const elements = castArray(element);\n\n    const _newElements = elements.reduce(\n      (acc: ExcalidrawElement[], element) => {\n        if (processedIds.has(element.id)) {\n          return acc;\n        }\n\n        processedIds.set(element.id, true);\n\n        const newElement = duplicateElement(\n          appState.editingGroupId,\n          groupIdMap,\n          element,\n          opts.randomizeSeed,\n        );\n\n        processedIds.set(newElement.id, true);\n\n        duplicateElementsMap.set(newElement.id, newElement);\n        origIdToDuplicateId.set(element.id, newElement.id);\n        duplicateIdToOrigElement.set(newElement.id, element);\n\n        origElements.push(element);\n        duplicatedElements.push(newElement);\n\n        acc.push(newElement);\n        return acc;\n      },\n      [],\n    );\n\n    return (\n      Array.isArray(element) ? _newElements : _newElements[0] || null\n    ) as T extends ExcalidrawElement[]\n      ? ExcalidrawElement[]\n      : ExcalidrawElement | null;\n  };\n\n  // Helper to position cloned elements in the Z-order the product needs it\n  const insertBeforeOrAfterIndex = (\n    index: number,\n    elements: ExcalidrawElement | null | ExcalidrawElement[],\n  ) => {\n    if (!elements) {\n      return;\n    }\n\n    if (index > elementsWithDuplicates.length - 1) {\n      elementsWithDuplicates.push(...castArray(elements));\n      return;\n    }\n\n    elementsWithDuplicates.splice(index + 1, 0, ...castArray(elements));\n  };\n\n  const frameIdsToDuplicate = new Set(\n    elements\n      .filter(\n        (el) => _idsOfElementsToDuplicate.has(el.id) && isFrameLikeElement(el),\n      )\n      .map((el) => el.id),\n  );\n\n  for (const element of elements) {\n    if (processedIds.has(element.id)) {\n      continue;\n    }\n\n    if (!_idsOfElementsToDuplicate.has(element.id)) {\n      continue;\n    }\n\n    // groups\n    // -------------------------------------------------------------------------\n\n    const groupId = getSelectedGroupForElement(appState, element);\n    if (groupId) {\n      const groupElements = getElementsInGroup(elements, groupId).flatMap(\n        (element) =>\n          isFrameLikeElement(element)\n            ? [...getFrameChildren(elements, element.id), element]\n            : [element],\n      );\n\n      const targetIndex = findLastIndex(elementsWithDuplicates, (el) => {\n        return el.groupIds?.includes(groupId);\n      });\n\n      insertBeforeOrAfterIndex(targetIndex, copyElements(groupElements));\n      continue;\n    }\n\n    // frame duplication\n    // -------------------------------------------------------------------------\n\n    if (element.frameId && frameIdsToDuplicate.has(element.frameId)) {\n      continue;\n    }\n\n    if (isFrameLikeElement(element)) {\n      const frameId = element.id;\n\n      const frameChildren = getFrameChildren(elements, frameId);\n\n      const targetIndex = findLastIndex(elementsWithDuplicates, (el) => {\n        return el.frameId === frameId || el.id === frameId;\n      });\n\n      insertBeforeOrAfterIndex(\n        targetIndex,\n        copyElements([...frameChildren, element]),\n      );\n      continue;\n    }\n\n    // text container\n    // -------------------------------------------------------------------------\n\n    if (hasBoundTextElement(element)) {\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n\n      const targetIndex = findLastIndex(elementsWithDuplicates, (el) => {\n        return (\n          el.id === element.id ||\n          (\"containerId\" in el && el.containerId === element.id)\n        );\n      });\n\n      if (boundTextElement) {\n        insertBeforeOrAfterIndex(\n          targetIndex,\n          copyElements([element, boundTextElement]),\n        );\n      } else {\n        insertBeforeOrAfterIndex(targetIndex, copyElements(element));\n      }\n\n      continue;\n    }\n\n    if (isBoundToContainer(element)) {\n      const container = getContainerElement(element, elementsMap);\n\n      const targetIndex = findLastIndex(elementsWithDuplicates, (el) => {\n        return el.id === element.id || el.id === container?.id;\n      });\n\n      if (container) {\n        insertBeforeOrAfterIndex(\n          targetIndex,\n          copyElements([container, element]),\n        );\n      } else {\n        insertBeforeOrAfterIndex(targetIndex, copyElements(element));\n      }\n\n      continue;\n    }\n\n    // default duplication (regular elements)\n    // -------------------------------------------------------------------------\n\n    insertBeforeOrAfterIndex(\n      findLastIndex(elementsWithDuplicates, (el) => el.id === element.id),\n      copyElements(element),\n    );\n  }\n\n  // ---------------------------------------------------------------------------\n\n  fixDuplicatedBindingsAfterDuplication(\n    duplicatedElements,\n    origIdToDuplicateId,\n    duplicateElementsMap as NonDeletedSceneElementsMap,\n  );\n\n  bindElementsToFramesAfterDuplication(\n    elementsWithDuplicates,\n    origElements,\n    origIdToDuplicateId,\n  );\n\n  if (opts.overrides) {\n    for (const duplicateElement of duplicatedElements) {\n      const origElement = duplicateIdToOrigElement.get(duplicateElement.id);\n      if (origElement) {\n        Object.assign(\n          duplicateElement,\n          opts.overrides({\n            duplicateElement,\n            origElement,\n            origIdToDuplicateId,\n          }),\n        );\n      }\n    }\n  }\n\n  return {\n    duplicatedElements,\n    duplicateElementsMap,\n    elementsWithDuplicates,\n    origIdToDuplicateId,\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement.\n//\n// Only clones plain objects and arrays. Doesn't clone Date, RegExp, Map, Set,\n// Typed arrays and other non-null objects.\n//\n// Adapted from https://github.com/lukeed/klona\n//\n// The reason for `deepCopyElement()` wrapper is type safety (only allow\n// passing ExcalidrawElement as the top-level argument).\nconst _deepCopyElement = (val: any, depth: number = 0) => {\n  // only clone non-primitives\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  const objectType = Object.prototype.toString.call(val);\n\n  if (objectType === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy non-serializable objects like these caches. They'll be\n        // populated when the element is rendered.\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = _deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = _deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  // we're not cloning non-array & non-plain-object objects because we\n  // don't support them on excalidraw elements yet. If we do, we need to make\n  // sure we start cloning them, so let's warn about it.\n  if (import.meta.env.DEV) {\n    if (\n      objectType !== \"[object Object]\" &&\n      objectType !== \"[object Array]\" &&\n      objectType.startsWith(\"[object \")\n    ) {\n      console.warn(\n        `_deepCloneElement: unexpected object type ${objectType}. This value will not be cloned!`,\n      );\n    }\n  }\n\n  return val;\n};\n\n/**\n * Clones ExcalidrawElement data structure. Does not regenerate id, nonce, or\n * any value. The purpose is to to break object references for immutability\n * reasons, whenever we want to keep the original element, but ensure it's not\n * mutated.\n *\n * Only clones plain objects and arrays. Doesn't clone Date, RegExp, Map, Set,\n * Typed arrays and other non-null objects.\n */\nexport const deepCopyElement = <T extends ExcalidrawElement>(\n  val: T,\n): Mutable<T> => {\n  return _deepCopyElement(val);\n};\n\nconst __test__defineOrigId = (clonedObj: object, origId: string) => {\n  Object.defineProperty(clonedObj, ORIG_ID, {\n    value: origId,\n    writable: false,\n    enumerable: false,\n  });\n};\n",
    "import { arrayToMapWithIndex } from \"@excalidraw/common\";\n\nimport type { ExcalidrawElement } from \"./types\";\n\nconst normalizeGroupElementOrder = (elements: readonly ExcalidrawElement[]) => {\n  const origElements: ExcalidrawElement[] = elements.slice();\n  const sortedElements = new Set<ExcalidrawElement>();\n\n  const orderInnerGroups = (\n    elements: readonly ExcalidrawElement[],\n  ): ExcalidrawElement[] => {\n    const firstGroupSig = elements[0]?.groupIds?.join(\"\");\n    const aGroup: ExcalidrawElement[] = [elements[0]];\n    const bGroup: ExcalidrawElement[] = [];\n    for (const element of elements.slice(1)) {\n      if (element.groupIds?.join(\"\") === firstGroupSig) {\n        aGroup.push(element);\n      } else {\n        bGroup.push(element);\n      }\n    }\n    return bGroup.length ? [...aGroup, ...orderInnerGroups(bGroup)] : aGroup;\n  };\n\n  const groupHandledElements = new Map<string, true>();\n\n  origElements.forEach((element, idx) => {\n    if (groupHandledElements.has(element.id)) {\n      return;\n    }\n    if (element.groupIds?.length) {\n      const topGroup = element.groupIds[element.groupIds.length - 1];\n      const groupElements = origElements.slice(idx).filter((element) => {\n        const ret = element?.groupIds?.some((id) => id === topGroup);\n        if (ret) {\n          groupHandledElements.set(element!.id, true);\n        }\n        return ret;\n      });\n\n      for (const elem of orderInnerGroups(groupElements)) {\n        sortedElements.add(elem);\n      }\n    } else {\n      sortedElements.add(element);\n    }\n  });\n\n  // if there's a bug which resulted in losing some of the elements, return\n  // original instead as that's better than losing data\n  if (sortedElements.size !== elements.length) {\n    console.error(\"normalizeGroupElementOrder: lost some elements... bailing!\");\n    return elements;\n  }\n\n  return [...sortedElements];\n};\n\n/**\n * In theory, when we have text elements bound to a container, they\n * should be right after the container element in the elements array.\n * However, this is not guaranteed due to old and potential future bugs.\n *\n * This function sorts containers and their bound texts together. It prefers\n * original z-index of container (i.e. it moves bound text elements after\n * containers).\n */\nconst normalizeBoundElementsOrder = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  const elementsMap = arrayToMapWithIndex(elements);\n\n  const origElements: (ExcalidrawElement | null)[] = elements.slice();\n  const sortedElements = new Set<ExcalidrawElement>();\n\n  origElements.forEach((element, idx) => {\n    if (!element) {\n      return;\n    }\n    if (element.boundElements?.length) {\n      sortedElements.add(element);\n      origElements[idx] = null;\n      element.boundElements.forEach((boundElement) => {\n        const child = elementsMap.get(boundElement.id);\n        if (child && boundElement.type === \"text\") {\n          sortedElements.add(child[0]);\n          origElements[child[1]] = null;\n        }\n      });\n    } else if (element.type === \"text\" && element.containerId) {\n      const parent = elementsMap.get(element.containerId);\n      if (!parent?.[0].boundElements?.find((x) => x.id === element.id)) {\n        sortedElements.add(element);\n        origElements[idx] = null;\n\n        // if element has a container and container lists it, skip this element\n        // as it'll be taken care of by the container\n      }\n    } else {\n      sortedElements.add(element);\n      origElements[idx] = null;\n    }\n  });\n\n  // if there's a bug which resulted in losing some of the elements, return\n  // original instead as that's better than losing data\n  if (sortedElements.size !== elements.length) {\n    console.error(\n      \"normalizeBoundElementsOrder: lost some elements... bailing!\",\n    );\n    return elements;\n  }\n\n  return [...sortedElements];\n};\n\nexport const normalizeElementOrder = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  return normalizeBoundElementsOrder(normalizeGroupElementOrder(elements));\n};\n",
    "import { generateNKeysBetween } from \"fractional-indexing\";\n\nimport { arrayToMap } from \"@excalidraw/common\";\n\nimport { mutateElement, newElementWith } from \"./mutateElement\";\nimport { getBoundTextElement } from \"./textElement\";\nimport { hasBoundTextElement } from \"./typeChecks\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  FractionalIndex,\n  OrderedExcalidrawElement,\n  SceneElementsMap,\n} from \"./types\";\n\nexport class InvalidFractionalIndexError extends Error {\n  public code = \"ELEMENT_HAS_INVALID_INDEX\" as const;\n}\n\n/**\n * Envisioned relation between array order and fractional indices:\n *\n * 1) Array (or array-like ordered data structure) should be used as a cache of elements order, hiding the internal fractional indices implementation.\n * - it's undesirable to perform reorder for each related operation, therefore it's necessary to cache the order defined by fractional indices into an ordered data structure\n * - it's easy enough to define the order of the elements from the outside (boundaries), without worrying about the underlying structure of fractional indices (especially for the host apps)\n * - it's necessary to always keep the array support for backwards compatibility (restore) - old scenes, old libraries, supporting multiple excalidraw versions etc.\n * - it's necessary to always keep the fractional indices in sync with the array order\n * - elements with invalid indices should be detected and synced, without altering the already valid indices\n *\n * 2) Fractional indices should be used to reorder the elements, whenever the cached order is expected to be invalidated.\n * - as the fractional indices are encoded as part of the elements, it opens up possibilities for incremental-like APIs\n * - re-order based on fractional indices should be part of (multiplayer) operations such as reconciliation & undo/redo\n * - technically all the z-index actions could perform also re-order based on fractional indices,but in current state it would not bring much benefits,\n *   as it's faster & more efficient to perform re-order based on array manipulation and later synchronisation of moved indices with the array order\n */\n\n/**\n * Ensure that all elements have valid fractional indices.\n *\n * @throws `InvalidFractionalIndexError` if invalid index is detected.\n */\nexport const validateFractionalIndices = (\n  elements: readonly ExcalidrawElement[],\n  {\n    shouldThrow = false,\n    includeBoundTextValidation = false,\n    ignoreLogs,\n    reconciliationContext,\n  }: {\n    shouldThrow: boolean;\n    includeBoundTextValidation: boolean;\n    ignoreLogs?: true;\n    reconciliationContext?: {\n      localElements: ReadonlyArray<ExcalidrawElement>;\n      remoteElements: ReadonlyArray<ExcalidrawElement>;\n    };\n  },\n) => {\n  const errorMessages = [];\n  const stringifyElement = (element: ExcalidrawElement | void) =>\n    `${element?.index}:${element?.id}:${element?.type}:${element?.isDeleted}:${element?.version}:${element?.versionNonce}`;\n\n  const indices = elements.map((x) => x.index);\n  for (const [i, index] of indices.entries()) {\n    const predecessorIndex = indices[i - 1];\n    const successorIndex = indices[i + 1];\n\n    if (!isValidFractionalIndex(index, predecessorIndex, successorIndex)) {\n      errorMessages.push(\n        `Fractional indices invariant has been compromised: \"${stringifyElement(\n          elements[i - 1],\n        )}\", \"${stringifyElement(elements[i])}\", \"${stringifyElement(\n          elements[i + 1],\n        )}\"`,\n      );\n    }\n\n    // disabled by default, as we don't fix it\n    if (includeBoundTextValidation && hasBoundTextElement(elements[i])) {\n      const container = elements[i];\n      const text = getBoundTextElement(container, arrayToMap(elements));\n\n      if (text && text.index! <= container.index!) {\n        errorMessages.push(\n          `Fractional indices invariant for bound elements has been compromised: \"${stringifyElement(\n            text,\n          )}\", \"${stringifyElement(container)}\"`,\n        );\n      }\n    }\n  }\n\n  if (errorMessages.length) {\n    const error = new InvalidFractionalIndexError();\n    const additionalContext = [];\n\n    if (reconciliationContext) {\n      additionalContext.push(\"Additional reconciliation context:\");\n      additionalContext.push(\n        reconciliationContext.localElements.map((x) => stringifyElement(x)),\n      );\n      additionalContext.push(\n        reconciliationContext.remoteElements.map((x) => stringifyElement(x)),\n      );\n    }\n\n    if (!ignoreLogs) {\n      // report just once and with the stacktrace\n      console.error(\n        errorMessages.join(\"\\n\\n\"),\n        error.stack,\n        elements.map((x) => stringifyElement(x)),\n        ...additionalContext,\n      );\n    }\n\n    if (shouldThrow) {\n      // if enabled, gather all the errors first, throw once\n      throw error;\n    }\n  }\n};\n\n/**\n * Order the elements based on the fractional indices.\n * - when fractional indices are identical, break the tie based on the element id\n * - when there is no fractional index in one of the elements, respect the order of the array\n */\nexport const orderByFractionalIndex = (\n  elements: OrderedExcalidrawElement[],\n) => {\n  return elements.sort((a, b) => {\n    // in case the indices are not the defined at runtime\n    if (isOrderedElement(a) && isOrderedElement(b)) {\n      if (a.index < b.index) {\n        return -1;\n      } else if (a.index > b.index) {\n        return 1;\n      }\n\n      // break ties based on the element id\n      return a.id < b.id ? -1 : 1;\n    }\n\n    // defensively keep the array order\n    return 1;\n  });\n};\n\n/**\n * Synchronizes invalid fractional indices of moved elements with the array order by mutating passed elements.\n * If the synchronization fails or the result is invalid, it fallbacks to `syncInvalidIndices`.\n */\nexport const syncMovedIndices = (\n  elements: readonly ExcalidrawElement[],\n  movedElements: ElementsMap,\n): OrderedExcalidrawElement[] => {\n  try {\n    const elementsMap = arrayToMap(elements);\n    const indicesGroups = getMovedIndicesGroups(elements, movedElements);\n\n    // try generatating indices, throws on invalid movedElements\n    const elementsUpdates = generateIndices(elements, indicesGroups);\n    const elementsCandidates = elements.map((x) => {\n      const elementUpdates = elementsUpdates.get(x);\n\n      if (elementUpdates) {\n        return { ...x, index: elementUpdates.index };\n      }\n\n      return x;\n    });\n\n    // ensure next indices are valid before mutation, throws on invalid ones\n    validateFractionalIndices(\n      elementsCandidates,\n      // we don't autofix invalid bound text indices, hence don't include it in the validation\n      {\n        includeBoundTextValidation: false,\n        shouldThrow: true,\n        ignoreLogs: true,\n      },\n    );\n\n    // split mutation so we don't end up in an incosistent state\n    for (const [element, { index }] of elementsUpdates) {\n      mutateElement(element, elementsMap, { index });\n    }\n  } catch (e) {\n    // fallback to default sync\n    syncInvalidIndices(elements);\n  }\n\n  return elements as OrderedExcalidrawElement[];\n};\n\n/**\n * Synchronizes all invalid fractional indices within the array order by mutating elements in the passed array.\n *\n * WARN: in edge cases it could modify the elements which were not moved, as it's impossible to guess the actually moved elements from the elements array itself.\n */\nexport const syncInvalidIndices = (\n  elements: readonly ExcalidrawElement[],\n): OrderedExcalidrawElement[] => {\n  const elementsMap = arrayToMap(elements);\n  const indicesGroups = getInvalidIndicesGroups(elements);\n  const elementsUpdates = generateIndices(elements, indicesGroups);\n\n  for (const [element, { index }] of elementsUpdates) {\n    mutateElement(element, elementsMap, { index });\n  }\n\n  return elements as OrderedExcalidrawElement[];\n};\n\n/**\n * Synchronizes all invalid fractional indices within the array order by creating new instances of elements with corrected indices.\n *\n * WARN: in edge cases it could modify the elements which were not moved, as it's impossible to guess the actually moved elements from the elements array itself.\n */\nexport const syncInvalidIndicesImmutable = (\n  elements: readonly ExcalidrawElement[],\n): SceneElementsMap | undefined => {\n  const syncedElements = arrayToMap(elements);\n  const indicesGroups = getInvalidIndicesGroups(elements);\n  const elementsUpdates = generateIndices(elements, indicesGroups);\n\n  for (const [element, { index }] of elementsUpdates) {\n    syncedElements.set(element.id, newElementWith(element, { index }));\n  }\n\n  return syncedElements as SceneElementsMap;\n};\n\n/**\n * Get contiguous groups of indices of passed moved elements.\n *\n * NOTE: First and last elements within the groups are indices of lower and upper bounds.\n */\nconst getMovedIndicesGroups = (\n  elements: readonly ExcalidrawElement[],\n  movedElements: ElementsMap,\n) => {\n  const indicesGroups: number[][] = [];\n\n  let i = 0;\n\n  while (i < elements.length) {\n    if (movedElements.has(elements[i].id)) {\n      const indicesGroup = [i - 1, i]; // push the lower bound index as the first item\n\n      while (++i < elements.length) {\n        if (!movedElements.has(elements[i].id)) {\n          break;\n        }\n\n        indicesGroup.push(i);\n      }\n\n      indicesGroup.push(i); // push the upper bound index as the last item\n      indicesGroups.push(indicesGroup);\n    } else {\n      i++;\n    }\n  }\n\n  return indicesGroups;\n};\n\n/**\n * Gets contiguous groups of all invalid indices automatically detected inside the elements array.\n *\n * WARN: First and last items within the groups do NOT have to be contiguous, those are the found lower and upper bounds!\n */\nconst getInvalidIndicesGroups = (elements: readonly ExcalidrawElement[]) => {\n  const indicesGroups: number[][] = [];\n\n  // once we find lowerBound / upperBound, it cannot be lower than that, so we cache it for better perf.\n  let lowerBound: ExcalidrawElement[\"index\"] | undefined = undefined;\n  let upperBound: ExcalidrawElement[\"index\"] | undefined = undefined;\n  let lowerBoundIndex: number = -1;\n  let upperBoundIndex: number = 0;\n\n  /** @returns maybe valid lowerBound */\n  const getLowerBound = (\n    index: number,\n  ): [ExcalidrawElement[\"index\"] | undefined, number] => {\n    const lowerBound = elements[lowerBoundIndex]\n      ? elements[lowerBoundIndex].index\n      : undefined;\n\n    // we are already iterating left to right, therefore there is no need for additional looping\n    const candidate = elements[index - 1]?.index;\n\n    if (\n      (!lowerBound && candidate) || // first lowerBound\n      (lowerBound && candidate && candidate > lowerBound) // next lowerBound\n    ) {\n      // WARN: candidate's index could be higher or same as the current element's index\n      return [candidate, index - 1];\n    }\n\n    // cache hit! take the last lower bound\n    return [lowerBound, lowerBoundIndex];\n  };\n\n  /** @returns always valid upperBound */\n  const getUpperBound = (\n    index: number,\n  ): [ExcalidrawElement[\"index\"] | undefined, number] => {\n    const upperBound = elements[upperBoundIndex]\n      ? elements[upperBoundIndex].index\n      : undefined;\n\n    // cache hit! don't let it find the upper bound again\n    if (upperBound && index < upperBoundIndex) {\n      return [upperBound, upperBoundIndex];\n    }\n\n    // set the current upperBoundIndex as the starting point\n    let i = upperBoundIndex;\n    while (++i < elements.length) {\n      const candidate = elements[i]?.index;\n\n      if (\n        (!upperBound && candidate) || // first upperBound\n        (upperBound && candidate && candidate > upperBound) // next upperBound\n      ) {\n        return [candidate, i];\n      }\n    }\n\n    // we reached the end, sky is the limit\n    return [undefined, i];\n  };\n\n  let i = 0;\n\n  while (i < elements.length) {\n    const current = elements[i].index;\n    [lowerBound, lowerBoundIndex] = getLowerBound(i);\n    [upperBound, upperBoundIndex] = getUpperBound(i);\n\n    if (!isValidFractionalIndex(current, lowerBound, upperBound)) {\n      // push the lower bound index as the first item\n      const indicesGroup = [lowerBoundIndex, i];\n\n      while (++i < elements.length) {\n        const current = elements[i].index;\n        const [nextLowerBound, nextLowerBoundIndex] = getLowerBound(i);\n        const [nextUpperBound, nextUpperBoundIndex] = getUpperBound(i);\n\n        if (isValidFractionalIndex(current, nextLowerBound, nextUpperBound)) {\n          break;\n        }\n\n        // assign bounds only for the moved elements\n        [lowerBound, lowerBoundIndex] = [nextLowerBound, nextLowerBoundIndex];\n        [upperBound, upperBoundIndex] = [nextUpperBound, nextUpperBoundIndex];\n\n        indicesGroup.push(i);\n      }\n\n      // push the upper bound index as the last item\n      indicesGroup.push(upperBoundIndex);\n      indicesGroups.push(indicesGroup);\n    } else {\n      i++;\n    }\n  }\n\n  return indicesGroups;\n};\n\nconst isValidFractionalIndex = (\n  index: ExcalidrawElement[\"index\"] | undefined,\n  predecessor: ExcalidrawElement[\"index\"] | undefined,\n  successor: ExcalidrawElement[\"index\"] | undefined,\n) => {\n  if (!index) {\n    return false;\n  }\n\n  if (predecessor && successor) {\n    return predecessor < index && index < successor;\n  }\n\n  if (!predecessor && successor) {\n    // first element\n    return index < successor;\n  }\n\n  if (predecessor && !successor) {\n    // last element\n    return predecessor < index;\n  }\n\n  // only element in the array\n  return !!index;\n};\n\nconst generateIndices = (\n  elements: readonly ExcalidrawElement[],\n  indicesGroups: number[][],\n) => {\n  const elementsUpdates = new Map<\n    ExcalidrawElement,\n    { index: FractionalIndex }\n  >();\n\n  for (const indices of indicesGroups) {\n    const lowerBoundIndex = indices.shift()!;\n    const upperBoundIndex = indices.pop()!;\n\n    const fractionalIndices = generateNKeysBetween(\n      elements[lowerBoundIndex]?.index,\n      elements[upperBoundIndex]?.index,\n      indices.length,\n    ) as FractionalIndex[];\n\n    for (let i = 0; i < indices.length; i++) {\n      const element = elements[indices[i]];\n\n      elementsUpdates.set(element, {\n        index: fractionalIndices[i],\n      });\n    }\n  }\n\n  return elementsUpdates;\n};\n\nconst isOrderedElement = (\n  element: ExcalidrawElement,\n): element is OrderedExcalidrawElement => {\n  // for now it's sufficient whether the index is there\n  // meaning, the element was already ordered in the past\n  // meaning, it is not a newly inserted element, not an unrestored element, etc.\n  // it does not have to mean that the index itself is valid\n  if (element.index) {\n    return true;\n  }\n\n  return false;\n};\n",
    "// License: CC0 (no rights reserved).\n\n// This is based on https://observablehq.com/@dgreensp/implementing-fractional-indexing\n\nexport const BASE_62_DIGITS =\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n// `a` may be empty string, `b` is null or non-empty string.\n// `a < b` lexicographically if `b` is non-null.\n// no trailing zeros allowed.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string} a\n * @param {string | null | undefined} b\n * @param {string} digits\n * @returns {string}\n */\nfunction midpoint(a, b, digits) {\n  const zero = digits[0];\n  if (b != null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (a.slice(-1) === zero || (b && b.slice(-1) === zero)) {\n    throw new Error(\"trailing zero\");\n  }\n  if (b) {\n    // remove longest common prefix.  pad `a` with 0s as we\n    // go.  note that we don't need to pad `b`, because it can't\n    // end before `a` while traversing the common prefix.\n    let n = 0;\n    while ((a[n] || zero) === b[n]) {\n      n++;\n    }\n    if (n > 0) {\n      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits);\n    }\n  }\n  // first digits (or lack of digit) are different\n  const digitA = a ? digits.indexOf(a[0]) : 0;\n  const digitB = b != null ? digits.indexOf(b[0]) : digits.length;\n  if (digitB - digitA > 1) {\n    const midDigit = Math.round(0.5 * (digitA + digitB));\n    return digits[midDigit];\n  } else {\n    // first digits are consecutive\n    if (b && b.length > 1) {\n      return b.slice(0, 1);\n    } else {\n      // `b` is null or has length 1 (a single digit).\n      // the first digit of `a` is the previous digit to `b`,\n      // or 9 if `b` is null.\n      // given, for example, midpoint('49', '5'), return\n      // '4' + midpoint('9', null), which will become\n      // '4' + '9' + midpoint('', null), which is '495'\n      return digits[digitA] + midpoint(a.slice(1), null, digits);\n    }\n  }\n}\n\n/**\n * @param {string} int\n * @return {void}\n */\n\nfunction validateInteger(int) {\n  if (int.length !== getIntegerLength(int[0])) {\n    throw new Error(\"invalid integer part of order key: \" + int);\n  }\n}\n\n/**\n * @param {string} head\n * @return {number}\n */\n\nfunction getIntegerLength(head) {\n  if (head >= \"a\" && head <= \"z\") {\n    return head.charCodeAt(0) - \"a\".charCodeAt(0) + 2;\n  } else if (head >= \"A\" && head <= \"Z\") {\n    return \"Z\".charCodeAt(0) - head.charCodeAt(0) + 2;\n  } else {\n    throw new Error(\"invalid order key head: \" + head);\n  }\n}\n\n/**\n * @param {string} key\n * @return {string}\n */\n\nfunction getIntegerPart(key) {\n  const integerPartLength = getIntegerLength(key[0]);\n  if (integerPartLength > key.length) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n  return key.slice(0, integerPartLength);\n}\n\n/**\n * @param {string} key\n * @param {string} digits\n * @return {void}\n */\n\nfunction validateOrderKey(key, digits) {\n  if (key === \"A\" + digits[0].repeat(26)) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n  // getIntegerPart will throw if the first character is bad,\n  // or the key is too short.  we'd call it to check these things\n  // even if we didn't need the result\n  const i = getIntegerPart(key);\n  const f = key.slice(i.length);\n  if (f.slice(-1) === digits[0]) {\n    throw new Error(\"invalid order key: \" + key);\n  }\n}\n\n// note that this may return null, as there is a largest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\nfunction incrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split(\"\");\n  let carry = true;\n  for (let i = digs.length - 1; carry && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) + 1;\n    if (d === digits.length) {\n      digs[i] = digits[0];\n    } else {\n      digs[i] = digits[d];\n      carry = false;\n    }\n  }\n  if (carry) {\n    if (head === \"Z\") {\n      return \"a\" + digits[0];\n    }\n    if (head === \"z\") {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) + 1);\n    if (h > \"a\") {\n      digs.push(digits[0]);\n    } else {\n      digs.pop();\n    }\n    return h + digs.join(\"\");\n  } else {\n    return head + digs.join(\"\");\n  }\n}\n\n// note that this may return null, as there is a smallest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\n\nfunction decrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split(\"\");\n  let borrow = true;\n  for (let i = digs.length - 1; borrow && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) - 1;\n    if (d === -1) {\n      digs[i] = digits.slice(-1);\n    } else {\n      digs[i] = digits[d];\n      borrow = false;\n    }\n  }\n  if (borrow) {\n    if (head === \"a\") {\n      return \"Z\" + digits.slice(-1);\n    }\n    if (head === \"A\") {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) - 1);\n    if (h < \"Z\") {\n      digs.push(digits.slice(-1));\n    } else {\n      digs.pop();\n    }\n    return h + digs.join(\"\");\n  } else {\n    return head + digs.join(\"\");\n  }\n}\n\n// `a` is an order key or null (START).\n// `b` is an order key or null (END).\n// `a < b` lexicographically if both are non-null.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {string=} digits\n * @return {string}\n */\nexport function generateKeyBetween(a, b, digits = BASE_62_DIGITS) {\n  if (a != null) {\n    validateOrderKey(a, digits);\n  }\n  if (b != null) {\n    validateOrderKey(b, digits);\n  }\n  if (a != null && b != null && a >= b) {\n    throw new Error(a + \" >= \" + b);\n  }\n  if (a == null) {\n    if (b == null) {\n      return \"a\" + digits[0];\n    }\n\n    const ib = getIntegerPart(b);\n    const fb = b.slice(ib.length);\n    if (ib === \"A\" + digits[0].repeat(26)) {\n      return ib + midpoint(\"\", fb, digits);\n    }\n    if (ib < b) {\n      return ib;\n    }\n    const res = decrementInteger(ib, digits);\n    if (res == null) {\n      throw new Error(\"cannot decrement any more\");\n    }\n    return res;\n  }\n\n  if (b == null) {\n    const ia = getIntegerPart(a);\n    const fa = a.slice(ia.length);\n    const i = incrementInteger(ia, digits);\n    return i == null ? ia + midpoint(fa, null, digits) : i;\n  }\n\n  const ia = getIntegerPart(a);\n  const fa = a.slice(ia.length);\n  const ib = getIntegerPart(b);\n  const fb = b.slice(ib.length);\n  if (ia === ib) {\n    return ia + midpoint(fa, fb, digits);\n  }\n  const i = incrementInteger(ia, digits);\n  if (i == null) {\n    throw new Error(\"cannot increment any more\");\n  }\n  if (i < b) {\n    return i;\n  }\n  return ia + midpoint(fa, null, digits);\n}\n\n/**\n * same preconditions as generateKeysBetween.\n * n >= 0.\n * Returns an array of n distinct keys in sorted order.\n * If a and b are both null, returns [a0, a1, ...]\n * If one or the other is null, returns consecutive \"integer\"\n * keys.  Otherwise, returns relatively short keys between\n * a and b.\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {number} n\n * @param {string} digits\n * @return {string[]}\n */\nexport function generateNKeysBetween(a, b, n, digits = BASE_62_DIGITS) {\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [generateKeyBetween(a, b, digits)];\n  }\n  if (b == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(c, b, digits);\n      result.push(c);\n    }\n    return result;\n  }\n  if (a == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(a, c, digits);\n      result.push(c);\n    }\n    result.reverse();\n    return result;\n  }\n  const mid = Math.floor(n / 2);\n  const c = generateKeyBetween(a, b, digits);\n  return [\n    ...generateNKeysBetween(a, c, mid, digits),\n    c,\n    ...generateNKeysBetween(c, b, n - mid - 1, digits),\n  ];\n}\n",
    "import throttle from \"lodash.throttle\";\n\nimport {\n  randomInteger,\n  arrayToMap,\n  toBrandedType,\n  isDevEnv,\n  isTestEnv,\n  toArray,\n} from \"@excalidraw/common\";\nimport { isNonDeletedElement } from \"@excalidraw/element\";\nimport { isFrameLikeElement } from \"@excalidraw/element\";\nimport { getElementsInGroup } from \"@excalidraw/element\";\n\nimport {\n  syncInvalidIndices,\n  syncMovedIndices,\n  validateFractionalIndices,\n} from \"@excalidraw/element\";\n\nimport { getSelectedElements } from \"@excalidraw/element\";\n\nimport { mutateElement, type ElementUpdate } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawFrameLikeElement,\n  ElementsMapOrArray,\n  SceneElementsMap,\n  NonDeletedSceneElementsMap,\n  OrderedExcalidrawElement,\n  Ordered,\n} from \"@excalidraw/element/types\";\n\nimport type {\n  Assert,\n  Mutable,\n  SameType,\n} from \"@excalidraw/common/utility-types\";\n\nimport type { AppState } from \"../../excalidraw/types\";\n\ntype SceneStateCallback = () => void;\ntype SceneStateCallbackRemover = () => void;\n\ntype SelectionHash = string & { __brand: \"selectionHash\" };\n\nconst getNonDeletedElements = <T extends ExcalidrawElement>(\n  allElements: readonly T[],\n) => {\n  const elementsMap = new Map() as NonDeletedSceneElementsMap;\n  const elements: T[] = [];\n  for (const element of allElements) {\n    if (!element.isDeleted) {\n      elements.push(element as NonDeleted<T>);\n      elementsMap.set(\n        element.id,\n        element as Ordered<NonDeletedExcalidrawElement>,\n      );\n    }\n  }\n  return { elementsMap, elements };\n};\n\nconst validateIndicesThrottled = throttle(\n  (elements: readonly ExcalidrawElement[]) => {\n    if (isDevEnv() || isTestEnv() || window?.DEBUG_FRACTIONAL_INDICES) {\n      validateFractionalIndices(elements, {\n        // throw only in dev & test, to remain functional on `DEBUG_FRACTIONAL_INDICES`\n        shouldThrow: isDevEnv() || isTestEnv(),\n        includeBoundTextValidation: true,\n      });\n    }\n  },\n  1000 * 60,\n  { leading: true, trailing: false },\n);\n\nconst hashSelectionOpts = (\n  opts: Parameters<InstanceType<typeof Scene>[\"getSelectedElements\"]>[0],\n) => {\n  const keys = [\"includeBoundTextElement\", \"includeElementsInFrames\"] as const;\n\n  type HashableKeys = Omit<typeof opts, \"selectedElementIds\" | \"elements\">;\n\n  // just to ensure we're hashing all expected keys\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  type _ = Assert<\n    SameType<\n      Required<HashableKeys>,\n      Pick<Required<HashableKeys>, typeof keys[number]>\n    >\n  >;\n\n  let hash = \"\";\n  for (const key of keys) {\n    hash += `${key}:${opts[key] ? \"1\" : \"0\"}`;\n  }\n  return hash as SelectionHash;\n};\n\n// ideally this would be a branded type but it'd be insanely hard to work with\n// in our codebase\nexport type ExcalidrawElementsIncludingDeleted = readonly ExcalidrawElement[];\n\nexport class Scene {\n  // ---------------------------------------------------------------------------\n  // instance methods/props\n  // ---------------------------------------------------------------------------\n\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly Ordered<NonDeletedExcalidrawElement>[] =\n    [];\n  private nonDeletedElementsMap = toBrandedType<NonDeletedSceneElementsMap>(\n    new Map(),\n  );\n  // ideally all elements within the scene should be wrapped around with `Ordered` type, but right now there is no real benefit doing so\n  private elements: readonly OrderedExcalidrawElement[] = [];\n  private nonDeletedFramesLikes: readonly NonDeleted<ExcalidrawFrameLikeElement>[] =\n    [];\n  private frames: readonly ExcalidrawFrameLikeElement[] = [];\n  private elementsMap = toBrandedType<SceneElementsMap>(new Map());\n  private selectedElementsCache: {\n    selectedElementIds: AppState[\"selectedElementIds\"] | null;\n    elements: readonly NonDeletedExcalidrawElement[] | null;\n    cache: Map<SelectionHash, NonDeletedExcalidrawElement[]>;\n  } = {\n    selectedElementIds: null,\n    elements: null,\n    cache: new Map(),\n  };\n  /**\n   * Random integer regenerated each scene update.\n   *\n   * Does not relate to elements versions, it's only a renderer\n   * cache-invalidation nonce at the moment.\n   */\n  private sceneNonce: number | undefined;\n\n  getSceneNonce() {\n    return this.sceneNonce;\n  }\n\n  getNonDeletedElementsMap() {\n    return this.nonDeletedElementsMap;\n  }\n\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  getElementsMapIncludingDeleted() {\n    return this.elementsMap;\n  }\n\n  getNonDeletedElements() {\n    return this.nonDeletedElements;\n  }\n\n  getFramesIncludingDeleted() {\n    return this.frames;\n  }\n\n  constructor(elements: ElementsMapOrArray | null = null) {\n    if (elements) {\n      this.replaceAllElements(elements);\n    }\n  }\n\n  getSelectedElements(opts: {\n    // NOTE can be ommitted by making Scene constructor require App instance\n    selectedElementIds: AppState[\"selectedElementIds\"];\n    /**\n     * for specific cases where you need to use elements not from current\n     * scene state. This in effect will likely result in cache-miss, and\n     * the cache won't be updated in this case.\n     */\n    elements?: ElementsMapOrArray;\n    // selection-related options\n    includeBoundTextElement?: boolean;\n    includeElementsInFrames?: boolean;\n  }): NonDeleted<ExcalidrawElement>[] {\n    const hash = hashSelectionOpts(opts);\n\n    const elements = opts?.elements || this.nonDeletedElements;\n    if (\n      this.selectedElementsCache.elements === elements &&\n      this.selectedElementsCache.selectedElementIds === opts.selectedElementIds\n    ) {\n      const cached = this.selectedElementsCache.cache.get(hash);\n      if (cached) {\n        return cached;\n      }\n    } else if (opts?.elements == null) {\n      // if we're operating on latest scene elements and the cache is not\n      //  storing the latest elements, clear the cache\n      this.selectedElementsCache.cache.clear();\n    }\n\n    const selectedElements = getSelectedElements(\n      elements,\n      { selectedElementIds: opts.selectedElementIds },\n      opts,\n    );\n\n    // cache only if we're not using custom elements\n    if (opts?.elements == null) {\n      this.selectedElementsCache.selectedElementIds = opts.selectedElementIds;\n      this.selectedElementsCache.elements = this.nonDeletedElements;\n      this.selectedElementsCache.cache.set(hash, selectedElements);\n    }\n\n    return selectedElements;\n  }\n\n  getNonDeletedFramesLikes(): readonly NonDeleted<ExcalidrawFrameLikeElement>[] {\n    return this.nonDeletedFramesLikes;\n  }\n\n  getElement<T extends ExcalidrawElement>(id: T[\"id\"]): T | null {\n    return (this.elementsMap.get(id) as T | undefined) || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  /**\n   * A utility method to help with updating all scene elements, with the added\n   * performance optimization of not renewing the array if no change is made.\n   *\n   * Maps all current excalidraw elements, invoking the callback for each\n   * element. The callback should either return a new mapped element, or the\n   * original element if no changes are made. If no changes are made to any\n   * element, this results in a no-op. Otherwise, the newly mapped elements\n   * are set as the next scene's elements.\n   *\n   * @returns whether a change was made\n   */\n  mapElements(\n    iteratee: (element: ExcalidrawElement) => ExcalidrawElement,\n  ): boolean {\n    let didChange = false;\n    const newElements = this.elements.map((element) => {\n      const nextElement = iteratee(element);\n      if (nextElement !== element) {\n        didChange = true;\n      }\n      return nextElement;\n    });\n    if (didChange) {\n      this.replaceAllElements(newElements);\n    }\n    return didChange;\n  }\n\n  replaceAllElements(nextElements: ElementsMapOrArray) {\n    // we do trust the insertion order on the map, though maybe we shouldn't and should prefer order defined by fractional indices\n    const _nextElements = toArray(nextElements);\n    const nextFrameLikes: ExcalidrawFrameLikeElement[] = [];\n\n    validateIndicesThrottled(_nextElements);\n\n    this.elements = syncInvalidIndices(_nextElements);\n    this.elementsMap.clear();\n    this.elements.forEach((element) => {\n      if (isFrameLikeElement(element)) {\n        nextFrameLikes.push(element);\n      }\n      this.elementsMap.set(element.id, element);\n    });\n    const nonDeletedElements = getNonDeletedElements(this.elements);\n    this.nonDeletedElements = nonDeletedElements.elements;\n    this.nonDeletedElementsMap = nonDeletedElements.elementsMap;\n\n    this.frames = nextFrameLikes;\n    this.nonDeletedFramesLikes = getNonDeletedElements(this.frames).elements;\n\n    this.triggerUpdate();\n  }\n\n  triggerUpdate() {\n    this.sceneNonce = randomInteger();\n\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  onUpdate(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n\n  destroy() {\n    this.elements = [];\n    this.nonDeletedElements = [];\n    this.nonDeletedFramesLikes = [];\n    this.frames = [];\n    this.elementsMap.clear();\n    this.selectedElementsCache.selectedElementIds = null;\n    this.selectedElementsCache.elements = null;\n    this.selectedElementsCache.cache.clear();\n\n    // done not for memory leaks, but to guard against possible late fires\n    // (I guess?)\n    this.callbacks.clear();\n  }\n\n  insertElementAtIndex(element: ExcalidrawElement, index: number) {\n    if (!Number.isFinite(index) || index < 0) {\n      throw new Error(\n        \"insertElementAtIndex can only be called with index >= 0\",\n      );\n    }\n\n    const nextElements = [\n      ...this.elements.slice(0, index),\n      element,\n      ...this.elements.slice(index),\n    ];\n\n    syncMovedIndices(nextElements, arrayToMap([element]));\n\n    this.replaceAllElements(nextElements);\n  }\n\n  insertElementsAtIndex(elements: ExcalidrawElement[], index: number) {\n    if (!elements.length) {\n      return;\n    }\n\n    if (!Number.isFinite(index) || index < 0) {\n      throw new Error(\n        \"insertElementAtIndex can only be called with index >= 0\",\n      );\n    }\n\n    const nextElements = [\n      ...this.elements.slice(0, index),\n      ...elements,\n      ...this.elements.slice(index),\n    ];\n\n    syncMovedIndices(nextElements, arrayToMap(elements));\n\n    this.replaceAllElements(nextElements);\n  }\n\n  insertElement = (element: ExcalidrawElement) => {\n    const index = element.frameId\n      ? this.getElementIndex(element.frameId)\n      : this.elements.length;\n\n    this.insertElementAtIndex(element, index);\n  };\n\n  insertElements = (elements: ExcalidrawElement[]) => {\n    if (!elements.length) {\n      return;\n    }\n\n    const index = elements[0]?.frameId\n      ? this.getElementIndex(elements[0].frameId)\n      : this.elements.length;\n\n    this.insertElementsAtIndex(elements, index);\n  };\n\n  getElementIndex(elementId: string) {\n    return this.elements.findIndex((element) => element.id === elementId);\n  }\n\n  getContainerElement = (\n    element:\n      | (ExcalidrawElement & {\n          containerId: ExcalidrawElement[\"id\"] | null;\n        })\n      | null,\n  ) => {\n    if (!element) {\n      return null;\n    }\n    if (element.containerId) {\n      return this.getElement(element.containerId) || null;\n    }\n    return null;\n  };\n\n  getElementsFromId = (id: string): ExcalidrawElement[] => {\n    const elementsMap = this.getNonDeletedElementsMap();\n    // first check if the id is an element\n    const el = elementsMap.get(id);\n    if (el) {\n      return [el];\n    }\n\n    // then, check if the id is a group\n    return getElementsInGroup(elementsMap, id);\n  };\n\n  // Mutate an element with passed updates and trigger the component to update. Make sure you\n  // are calling it either from a React event handler or within unstable_batchedUpdates().\n  mutateElement<TElement extends Mutable<ExcalidrawElement>>(\n    element: TElement,\n    updates: ElementUpdate<TElement>,\n    options: {\n      informMutation: boolean;\n      isDragging: boolean;\n    } = {\n      informMutation: true,\n      isDragging: false,\n    },\n  ) {\n    const elementsMap = this.getNonDeletedElementsMap();\n\n    const { version: prevVersion } = element;\n    const { version: nextVersion } = mutateElement(\n      element,\n      elementsMap,\n      updates,\n      options,\n    );\n\n    if (\n      // skip if the element is not in the scene (i.e. selection)\n      this.elementsMap.has(element.id) &&\n      // skip if the element's version hasn't changed, as mutateElement returned the same element\n      prevVersion !== nextVersion &&\n      options.informMutation\n    ) {\n      this.triggerUpdate();\n    }\n\n    return element;\n  }\n}\n",
    "import { getCommonBoundingBox } from \"./bounds\";\nimport { newElementWith } from \"./mutateElement\";\n\nimport { getMaximumGroups } from \"./groups\";\n\nimport type { ElementsMap, ExcalidrawElement } from \"./types\";\n\nexport interface Distribution {\n  space: \"between\";\n  axis: \"x\" | \"y\";\n}\n\nexport const distributeElements = (\n  selectedElements: ExcalidrawElement[],\n  elementsMap: ElementsMap,\n  distribution: Distribution,\n): ExcalidrawElement[] => {\n  const [start, mid, end, extent] =\n    distribution.axis === \"x\"\n      ? ([\"minX\", \"midX\", \"maxX\", \"width\"] as const)\n      : ([\"minY\", \"midY\", \"maxY\", \"height\"] as const);\n\n  const bounds = getCommonBoundingBox(selectedElements);\n  const groups = getMaximumGroups(selectedElements, elementsMap)\n    .map((group) => [group, getCommonBoundingBox(group)] as const)\n    .sort((a, b) => a[1][mid] - b[1][mid]);\n\n  let span = 0;\n  for (const group of groups) {\n    span += group[1][extent];\n  }\n\n  const step = (bounds[extent] - span) / (groups.length - 1);\n\n  if (step < 0) {\n    // If we have a negative step, we'll need to distribute from centers\n    // rather than from gaps. Buckle up, this is a weird one.\n\n    // Get indices of boxes that define start and end of our bounding box\n    const index0 = groups.findIndex((g) => g[1][start] === bounds[start]);\n    const index1 = groups.findIndex((g) => g[1][end] === bounds[end]);\n\n    // Get our step, based on the distance between the center points of our\n    // start and end boxes\n    const step =\n      (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);\n\n    let pos = groups[index0][1][mid];\n\n    return groups.flatMap(([group, box], index) => {\n      const translation = {\n        x: 0,\n        y: 0,\n      };\n\n      // Don't move our start and end boxes\n      if (index !== index0 && index !== index1) {\n        pos += step;\n        translation[distribution.axis] = pos - box[mid];\n      }\n\n      return group.map((element) =>\n        newElementWith(element, {\n          x: element.x + translation.x,\n          y: element.y + translation.y,\n        }),\n      );\n    });\n  }\n\n  // Distribute from gaps\n\n  let pos = bounds[start];\n\n  return groups.flatMap(([group, box]) => {\n    const translation = {\n      x: 0,\n      y: 0,\n    };\n\n    translation[distribution.axis] = pos - box[start];\n\n    pos += step;\n    pos += box[extent];\n\n    return group.map((element) =>\n      newElementWith(element, {\n        x: element.x + translation.x,\n        y: element.y + translation.y,\n      }),\n    );\n  });\n};\n",
    "import {\n  TEXT_AUTOWRAP_THRESHOLD,\n  getGridPoint,\n  getFontString,\n} from \"@excalidraw/common\";\n\nimport type {\n  AppState,\n  NormalizedZoomValue,\n  NullableGridSize,\n  PointerDownState,\n} from \"excalidraw-custom/types\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { updateBoundElements } from \"./binding\";\nimport { getCommonBounds } from \"./bounds\";\nimport { getPerfectElementSize } from \"./sizeHelpers\";\nimport { getBoundTextElement } from \"./textElement\";\nimport { getMinTextElementWidth } from \"./textMeasurements\";\nimport {\n  isArrowElement,\n  isElbowArrow,\n  isFrameLikeElement,\n  isImageElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { Bounds } from \"./bounds\";\nimport type { ExcalidrawElement } from \"./types\";\n\nexport const dragSelectedElements = (\n  pointerDownState: PointerDownState,\n  _selectedElements: NonDeletedExcalidrawElement[],\n  offset: { x: number; y: number },\n  scene: Scene,\n  snapOffset: {\n    x: number;\n    y: number;\n  },\n  gridSize: NullableGridSize,\n) => {\n  if (\n    _selectedElements.length === 1 &&\n    isElbowArrow(_selectedElements[0]) &&\n    (_selectedElements[0].startBinding || _selectedElements[0].endBinding)\n  ) {\n    return;\n  }\n\n  const selectedElements = _selectedElements.filter((element) => {\n    if (isElbowArrow(element) && element.startBinding && element.endBinding) {\n      const startElement = _selectedElements.find(\n        (el) => el.id === element.startBinding?.elementId,\n      );\n      const endElement = _selectedElements.find(\n        (el) => el.id === element.endBinding?.elementId,\n      );\n\n      return startElement && endElement;\n    }\n\n    return true;\n  });\n\n  // we do not want a frame and its elements to be selected at the same time\n  // but when it happens (due to some bug), we want to avoid updating element\n  // in the frame twice, hence the use of set\n  const elementsToUpdate = new Set<NonDeletedExcalidrawElement>(\n    selectedElements,\n  );\n  const frames = selectedElements\n    .filter((e) => isFrameLikeElement(e))\n    .map((f) => f.id);\n\n  if (frames.length > 0) {\n    for (const element of scene.getNonDeletedElements()) {\n      if (element.frameId !== null && frames.includes(element.frameId)) {\n        elementsToUpdate.add(element);\n      }\n    }\n  }\n\n  const origElements: ExcalidrawElement[] = [];\n\n  for (const element of elementsToUpdate) {\n    const origElement = pointerDownState.originalElements.get(element.id);\n    // if original element is not set (e.g. when you duplicate during a drag\n    // operation), exit to avoid undefined behavior\n    if (!origElement) {\n      return;\n    }\n    origElements.push(origElement);\n  }\n\n  const adjustedOffset = calculateOffset(\n    getCommonBounds(origElements),\n    offset,\n    snapOffset,\n    gridSize,\n  );\n\n  elementsToUpdate.forEach((element) => {\n    updateElementCoords(pointerDownState, element, scene, adjustedOffset);\n    if (!isArrowElement(element)) {\n      // skip arrow labels since we calculate its position during render\n      const textElement = getBoundTextElement(\n        element,\n        scene.getNonDeletedElementsMap(),\n      );\n      if (textElement) {\n        updateElementCoords(\n          pointerDownState,\n          textElement,\n          scene,\n          adjustedOffset,\n        );\n      }\n      updateBoundElements(element, scene, {\n        simultaneouslyUpdated: Array.from(elementsToUpdate),\n      });\n    }\n  });\n};\n\nconst calculateOffset = (\n  commonBounds: Bounds,\n  dragOffset: { x: number; y: number },\n  snapOffset: { x: number; y: number },\n  gridSize: NullableGridSize,\n): { x: number; y: number } => {\n  const [x, y] = commonBounds;\n  let nextX = x + dragOffset.x + snapOffset.x;\n  let nextY = y + dragOffset.y + snapOffset.y;\n\n  if (snapOffset.x === 0 || snapOffset.y === 0) {\n    const [nextGridX, nextGridY] = getGridPoint(\n      x + dragOffset.x,\n      y + dragOffset.y,\n      gridSize,\n    );\n\n    if (snapOffset.x === 0) {\n      nextX = nextGridX;\n    }\n\n    if (snapOffset.y === 0) {\n      nextY = nextGridY;\n    }\n  }\n  return {\n    x: nextX - x,\n    y: nextY - y,\n  };\n};\n\nconst updateElementCoords = (\n  pointerDownState: PointerDownState,\n  element: NonDeletedExcalidrawElement,\n  scene: Scene,\n  dragOffset: { x: number; y: number },\n) => {\n  const originalElement =\n    pointerDownState.originalElements.get(element.id) ?? element;\n\n  const nextX = originalElement.x + dragOffset.x;\n  const nextY = originalElement.y + dragOffset.y;\n\n  scene.mutateElement(element, {\n    x: nextX,\n    y: nextY,\n  });\n};\n\nexport const getDragOffsetXY = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1] = getCommonBounds(selectedElements);\n  return [x - x1, y - y1];\n};\n\nexport const dragNewElement = ({\n  newElement,\n  elementType,\n  originX,\n  originY,\n  x,\n  y,\n  width,\n  height,\n  shouldMaintainAspectRatio,\n  shouldResizeFromCenter,\n  zoom,\n  scene,\n  widthAspectRatio = null,\n  originOffset = null,\n  informMutation = true,\n}: {\n  newElement: NonDeletedExcalidrawElement;\n  elementType: AppState[\"activeTool\"][\"type\"];\n  originX: number;\n  originY: number;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  shouldMaintainAspectRatio: boolean;\n  shouldResizeFromCenter: boolean;\n  zoom: NormalizedZoomValue;\n  scene: Scene;\n  /** whether to keep given aspect ratio when `isResizeWithSidesSameLength` is\n      true */\n  widthAspectRatio?: number | null;\n  originOffset?: {\n    x: number;\n    y: number;\n  } | null;\n  informMutation?: boolean;\n}) => {\n  if (shouldMaintainAspectRatio && newElement.type !== \"selection\") {\n    if (widthAspectRatio) {\n      height = width / widthAspectRatio;\n    } else {\n      // Depending on where the cursor is at (x, y) relative to where the starting point is\n      // (originX, originY), we use ONLY width or height to control size increase.\n      // This allows the cursor to always \"stick\" to one of the sides of the bounding box.\n      if (Math.abs(y - originY) > Math.abs(x - originX)) {\n        ({ width, height } = getPerfectElementSize(\n          elementType,\n          height,\n          x < originX ? -width : width,\n        ));\n      } else {\n        ({ width, height } = getPerfectElementSize(\n          elementType,\n          width,\n          y < originY ? -height : height,\n        ));\n      }\n\n      if (height < 0) {\n        height = -height;\n      }\n    }\n  }\n\n  let newX = x < originX ? originX - width : originX;\n  let newY = y < originY ? originY - height : originY;\n\n  if (shouldResizeFromCenter) {\n    width += width;\n    height += height;\n    newX = originX - width / 2;\n    newY = originY - height / 2;\n  }\n\n  let textAutoResize = null;\n\n  if (isTextElement(newElement)) {\n    height = newElement.height;\n    const minWidth = getMinTextElementWidth(\n      getFontString({\n        fontSize: newElement.fontSize,\n        fontFamily: newElement.fontFamily,\n      }),\n      newElement.lineHeight,\n    );\n    width = Math.max(width, minWidth);\n\n    if (Math.abs(x - originX) > TEXT_AUTOWRAP_THRESHOLD / zoom) {\n      textAutoResize = {\n        autoResize: false,\n      };\n    }\n\n    newY = originY;\n    if (shouldResizeFromCenter) {\n      newX = originX - width / 2;\n    }\n  }\n\n  if (width !== 0 && height !== 0) {\n    let imageInitialDimension = null;\n    if (isImageElement(newElement)) {\n      imageInitialDimension = {\n        initialWidth: width,\n        initialHeight: height,\n      };\n    }\n\n    scene.mutateElement(\n      newElement,\n      {\n        x: newX + (originOffset?.x ?? 0),\n        y: newY + (originOffset?.y ?? 0),\n        width,\n        height,\n        ...textAutoResize,\n        ...imageInitialDimension,\n      },\n      { informMutation, isDragging: false },\n    );\n  }\n};\n",
    "/**\n * Create and link between shapes.\n */\n\nimport { ELEMENT_LINK_KEY, normalizeLink } from \"@excalidraw/common\";\n\nimport type { AppProps, AppState } from \"excalidraw-custom/types\";\n\nimport { elementsAreInSameGroup } from \"./groups\";\n\nimport type { ExcalidrawElement } from \"./types\";\n\nexport const defaultGetElementLinkFromSelection: Exclude<\n  AppProps[\"generateLinkForSelection\"],\n  undefined\n> = (id, type) => {\n  const url = window.location.href;\n\n  try {\n    const link = new URL(url);\n    link.searchParams.set(ELEMENT_LINK_KEY, id);\n\n    return normalizeLink(link.toString());\n  } catch (error) {\n    console.error(error);\n  }\n\n  return normalizeLink(url);\n};\n\nexport const getLinkIdAndTypeFromSelection = (\n  selectedElements: ExcalidrawElement[],\n  appState: AppState,\n): {\n  id: string;\n  type: \"element\" | \"group\";\n} | null => {\n  if (\n    selectedElements.length > 0 &&\n    canCreateLinkFromElements(selectedElements)\n  ) {\n    if (selectedElements.length === 1) {\n      return {\n        id: selectedElements[0].id,\n        type: \"element\",\n      };\n    }\n\n    if (selectedElements.length > 1) {\n      const selectedGroupId = Object.keys(appState.selectedGroupIds)[0];\n\n      if (selectedGroupId) {\n        return {\n          id: selectedGroupId,\n          type: \"group\",\n        };\n      }\n      return {\n        id: selectedElements[0].groupIds[0],\n        type: \"group\",\n      };\n    }\n  }\n\n  return null;\n};\n\nexport const canCreateLinkFromElements = (\n  selectedElements: ExcalidrawElement[],\n) => {\n  if (selectedElements.length === 1) {\n    return true;\n  }\n\n  if (selectedElements.length > 1 && elementsAreInSameGroup(selectedElements)) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const isElementLink = (url: string) => {\n  try {\n    const _url = new URL(url);\n    return (\n      _url.searchParams.has(ELEMENT_LINK_KEY) &&\n      _url.host === window.location.host\n    );\n  } catch (error) {\n    return false;\n  }\n};\n\nexport const parseElementLinkFromURL = (url: string) => {\n  try {\n    const { searchParams } = new URL(url);\n    if (searchParams.has(ELEMENT_LINK_KEY)) {\n      const id = searchParams.get(ELEMENT_LINK_KEY);\n      return id;\n    }\n  } catch {}\n\n  return null;\n};\n",
    "import {\n  FONT_FAMILY,\n  VERTICAL_ALIGN,\n  escapeDoubleQuotes,\n  getFontString,\n} from \"@excalidraw/common\";\n\nimport type { ExcalidrawProps } from \"excalidraw-custom/types\";\nimport type { MarkRequired } from \"@excalidraw/common/utility-types\";\n\nimport { newTextElement } from \"./newElement\";\nimport { wrapText } from \"./textWrapping\";\nimport { isIframeElement } from \"./typeChecks\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawIframeLikeElement,\n  IframeData,\n} from \"./types\";\n\ntype IframeDataWithSandbox = MarkRequired<IframeData, \"sandbox\">;\n\nconst embeddedLinkCache = new Map<string, IframeDataWithSandbox>();\n\nconst RE_YOUTUBE =\n  /^(?:http(?:s)?:\\/\\/)?(?:www\\.)?youtu(?:be\\.com|\\.be)\\/(embed\\/|watch\\?v=|shorts\\/|playlist\\?list=|embed\\/videoseries\\?list=)?([a-zA-Z0-9_-]+)(?:\\?t=|&t=|\\?start=|&start=)?([a-zA-Z0-9_-]+)?[^\\s]*$/;\n\nconst RE_VIMEO =\n  /^(?:http(?:s)?:\\/\\/)?(?:(?:w){3}\\.)?(?:player\\.)?vimeo\\.com\\/(?:video\\/)?([^?\\s]+)(?:\\?.*)?$/;\nconst RE_FIGMA = /^https:\\/\\/(?:www\\.)?figma\\.com/;\n\nconst RE_GH_GIST = /^https:\\/\\/gist\\.github\\.com\\/([\\w_-]+)\\/([\\w_-]+)/;\nconst RE_GH_GIST_EMBED =\n  /^<script[\\s\\S]*?\\ssrc=[\"'](https:\\/\\/gist\\.github\\.com\\/.*?)\\.js[\"']/i;\n\nconst RE_MSFORMS = /^(?:https?:\\/\\/)?forms\\.microsoft\\.com\\//;\n\n// not anchored to start to allow <blockquote> twitter embeds\nconst RE_TWITTER =\n  /(?:https?:\\/\\/)?(?:(?:w){3}\\.)?(?:twitter|x)\\.com\\/[^/]+\\/status\\/(\\d+)/;\nconst RE_TWITTER_EMBED =\n  /^<blockquote[\\s\\S]*?\\shref=[\"'](https?:\\/\\/(?:twitter|x)\\.com\\/[^\"']*)/i;\n\nconst RE_VALTOWN =\n  /^https:\\/\\/(?:www\\.)?val\\.town\\/(v|embed)\\/[a-zA-Z_$][0-9a-zA-Z_$]+\\.[a-zA-Z_$][0-9a-zA-Z_$]+/;\n\nconst RE_GENERIC_EMBED =\n  /^<(?:iframe|blockquote)[\\s\\S]*?\\s(?:src|href)=[\"']([^\"']*)[\"'][\\s\\S]*?>$/i;\n\nconst RE_GIPHY =\n  /giphy.com\\/(?:clips|embed|gifs)\\/[a-zA-Z0-9]*?-?([a-zA-Z0-9]+)(?:[^a-zA-Z0-9]|$)/;\n\nconst RE_REDDIT =\n  /^(?:http(?:s)?:\\/\\/)?(?:www\\.)?reddit\\.com\\/r\\/([a-zA-Z0-9_]+)\\/comments\\/([a-zA-Z0-9_]+)\\/([a-zA-Z0-9_]+)\\/?(?:\\?[^#\\s]*)?(?:#[^\\s]*)?$/;\n\nconst RE_REDDIT_EMBED =\n  /^<blockquote[\\s\\S]*?\\shref=[\"'](https?:\\/\\/(?:www\\.)?reddit\\.com\\/[^\"']*)/i;\n\nconst ALLOWED_DOMAINS = new Set([\n  \"youtube.com\",\n  \"youtu.be\",\n  \"vimeo.com\",\n  \"player.vimeo.com\",\n  \"figma.com\",\n  \"link.excalidraw.com\",\n  \"gist.github.com\",\n  \"twitter.com\",\n  \"x.com\",\n  \"*.simplepdf.eu\",\n  \"stackblitz.com\",\n  \"val.town\",\n  \"giphy.com\",\n  \"reddit.com\",\n  \"forms.microsoft.com\",\n]);\n\nconst ALLOW_SAME_ORIGIN = new Set([\n  \"youtube.com\",\n  \"youtu.be\",\n  \"vimeo.com\",\n  \"player.vimeo.com\",\n  \"figma.com\",\n  \"twitter.com\",\n  \"x.com\",\n  \"*.simplepdf.eu\",\n  \"stackblitz.com\",\n  \"reddit.com\",\n  \"forms.microsoft.com\",\n]);\n\nexport const createSrcDoc = (body: string) => {\n  return `<html><body>${body}</body></html>`;\n};\n\nexport const getEmbedLink = (\n  link: string | null | undefined,\n): IframeDataWithSandbox | null => {\n  if (!link) {\n    return null;\n  }\n\n  if (embeddedLinkCache.has(link)) {\n    return embeddedLinkCache.get(link)!;\n  }\n\n  const originalLink = link;\n\n  const allowSameOrigin = ALLOW_SAME_ORIGIN.has(\n    matchHostname(link, ALLOW_SAME_ORIGIN) || \"\",\n  );\n\n  let type: \"video\" | \"generic\" = \"generic\";\n  let aspectRatio = { w: 560, h: 840 };\n  const ytLink = link.match(RE_YOUTUBE);\n  if (ytLink?.[2]) {\n    const time = ytLink[3] ? `&start=${ytLink[3]}` : ``;\n    const isPortrait = link.includes(\"shorts\");\n    type = \"video\";\n    switch (ytLink[1]) {\n      case \"embed/\":\n      case \"watch?v=\":\n      case \"shorts/\":\n        link = `https://www.youtube.com/embed/${ytLink[2]}?enablejsapi=1${time}`;\n        break;\n      case \"playlist?list=\":\n      case \"embed/videoseries?list=\":\n        link = `https://www.youtube.com/embed/videoseries?list=${ytLink[2]}&enablejsapi=1${time}`;\n        break;\n      default:\n        link = `https://www.youtube.com/embed/${ytLink[2]}?enablejsapi=1${time}`;\n        break;\n    }\n    aspectRatio = isPortrait ? { w: 315, h: 560 } : { w: 560, h: 315 };\n    embeddedLinkCache.set(originalLink, {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    });\n    return {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    };\n  }\n\n  const vimeoLink = link.match(RE_VIMEO);\n  if (vimeoLink?.[1]) {\n    const target = vimeoLink?.[1];\n    const error = !/^\\d+$/.test(target)\n      ? new URIError(\"Invalid embed link format\")\n      : undefined;\n    type = \"video\";\n    link = `https://player.vimeo.com/video/${target}?api=1`;\n    aspectRatio = { w: 560, h: 315 };\n    //warning deliberately ommited so it is displayed only once per link\n    //same link next time will be served from cache\n    embeddedLinkCache.set(originalLink, {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    });\n    return {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      error,\n      sandbox: { allowSameOrigin },\n    };\n  }\n\n  const figmaLink = link.match(RE_FIGMA);\n  if (figmaLink) {\n    type = \"generic\";\n    link = `https://www.figma.com/embed?embed_host=share&url=${encodeURIComponent(\n      link,\n    )}`;\n    aspectRatio = { w: 550, h: 550 };\n    embeddedLinkCache.set(originalLink, {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    });\n    return {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    };\n  }\n\n  const valLink = link.match(RE_VALTOWN);\n  if (valLink) {\n    link =\n      valLink[1] === \"embed\" ? valLink[0] : valLink[0].replace(\"/v\", \"/embed\");\n    embeddedLinkCache.set(originalLink, {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    });\n    return {\n      link,\n      intrinsicSize: aspectRatio,\n      type,\n      sandbox: { allowSameOrigin },\n    };\n  }\n\n  if (RE_MSFORMS.test(link) && !link.includes(\"embed=true\")) {\n    link += link.includes(\"?\") ? \"&embed=true\" : \"?embed=true\";\n  }\n\n  if (RE_TWITTER.test(link)) {\n    const postId = link.match(RE_TWITTER)![1];\n    // the embed srcdoc still supports twitter.com domain only.\n    // Note that we don't attempt to parse the username as it can consist of\n    // non-latin1 characters, and the username in the url can be set to anything\n    // without affecting the embed.\n    const safeURL = escapeDoubleQuotes(\n      `https://twitter.com/x/status/${postId}`,\n    );\n\n    const ret: IframeDataWithSandbox = {\n      type: \"document\",\n      srcdoc: (theme: string) =>\n        createSrcDoc(\n          `<blockquote class=\"twitter-tweet\" data-dnt=\"true\" data-theme=\"${theme}\"><a href=\"${safeURL}\"></a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>`,\n        ),\n      intrinsicSize: { w: 480, h: 480 },\n      sandbox: { allowSameOrigin },\n    };\n    embeddedLinkCache.set(originalLink, ret);\n    return ret;\n  }\n\n  if (RE_REDDIT.test(link)) {\n    const [, page, postId, title] = link.match(RE_REDDIT)!;\n    const safeURL = escapeDoubleQuotes(\n      `https://reddit.com/r/${page}/comments/${postId}/${title}`,\n    );\n    const ret: IframeDataWithSandbox = {\n      type: \"document\",\n      srcdoc: (theme: string) =>\n        createSrcDoc(\n          `<blockquote class=\"reddit-embed-bq\" data-embed-theme=\"${theme}\"><a href=\"${safeURL}\"></a><br></blockquote><script async=\"\" src=\"https://embed.reddit.com/widgets.js\" charset=\"UTF-8\"></script>`,\n        ),\n      intrinsicSize: { w: 480, h: 480 },\n      sandbox: { allowSameOrigin },\n    };\n    embeddedLinkCache.set(originalLink, ret);\n    return ret;\n  }\n\n  if (RE_GH_GIST.test(link)) {\n    const [, user, gistId] = link.match(RE_GH_GIST)!;\n    const safeURL = escapeDoubleQuotes(\n      `https://gist.github.com/${user}/${gistId}`,\n    );\n    const ret: IframeDataWithSandbox = {\n      type: \"document\",\n      srcdoc: () =>\n        createSrcDoc(`\n          <script src=\"${safeURL}.js\"></script>\n          <style type=\"text/css\">\n            * { margin: 0px; }\n            table, .gist { height: 100%; }\n            .gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }\n          </style>\n        `),\n      intrinsicSize: { w: 550, h: 720 },\n      sandbox: { allowSameOrigin },\n    };\n    embeddedLinkCache.set(link, ret);\n    return ret;\n  }\n\n  embeddedLinkCache.set(link, {\n    link,\n    intrinsicSize: aspectRatio,\n    type,\n    sandbox: { allowSameOrigin },\n  });\n  return {\n    link,\n    intrinsicSize: aspectRatio,\n    type,\n    sandbox: { allowSameOrigin },\n  };\n};\n\nexport const createPlaceholderEmbeddableLabel = (\n  element: ExcalidrawIframeLikeElement,\n): ExcalidrawElement => {\n  let text: string;\n  if (isIframeElement(element)) {\n    text = \"IFrame element\";\n  } else {\n    text =\n      !element.link || element?.link === \"\" ? \"Empty Web-Embed\" : element.link;\n  }\n\n  const fontSize = Math.max(\n    Math.min(element.width / 2, element.width / text.length),\n    element.width / 30,\n  );\n  const fontFamily = FONT_FAMILY.Helvetica;\n\n  const fontString = getFontString({\n    fontSize,\n    fontFamily,\n  });\n\n  return newTextElement({\n    x: element.x + element.width / 2,\n    y: element.y + element.height / 2,\n    strokeColor:\n      element.strokeColor !== \"transparent\" ? element.strokeColor : \"black\",\n    backgroundColor: \"transparent\",\n    fontFamily,\n    fontSize,\n    text: wrapText(text, fontString, element.width - 20),\n    textAlign: \"center\",\n    verticalAlign: VERTICAL_ALIGN.MIDDLE,\n    angle: element.angle ?? 0,\n  });\n};\n\nconst matchHostname = (\n  url: string,\n  /** using a Set assumes it already contains normalized bare domains */\n  allowedHostnames: Set<string> | string,\n): string | null => {\n  try {\n    const { hostname } = new URL(url);\n\n    const bareDomain = hostname.replace(/^www\\./, \"\");\n\n    if (allowedHostnames instanceof Set) {\n      if (ALLOWED_DOMAINS.has(bareDomain)) {\n        return bareDomain;\n      }\n\n      const bareDomainWithFirstSubdomainWildcarded = bareDomain.replace(\n        /^([^.]+)/,\n        \"*\",\n      );\n      if (ALLOWED_DOMAINS.has(bareDomainWithFirstSubdomainWildcarded)) {\n        return bareDomainWithFirstSubdomainWildcarded;\n      }\n      return null;\n    }\n\n    const bareAllowedHostname = allowedHostnames.replace(/^www\\./, \"\");\n    if (bareDomain === bareAllowedHostname) {\n      return bareAllowedHostname;\n    }\n  } catch (error) {\n    // ignore\n  }\n  return null;\n};\n\nexport const maybeParseEmbedSrc = (str: string): string => {\n  const twitterMatch = str.match(RE_TWITTER_EMBED);\n  if (twitterMatch && twitterMatch.length === 2) {\n    return twitterMatch[1];\n  }\n\n  const redditMatch = str.match(RE_REDDIT_EMBED);\n  if (redditMatch && redditMatch.length === 2) {\n    return redditMatch[1];\n  }\n\n  const gistMatch = str.match(RE_GH_GIST_EMBED);\n  if (gistMatch && gistMatch.length === 2) {\n    return gistMatch[1];\n  }\n\n  if (RE_GIPHY.test(str)) {\n    return `https://giphy.com/embed/${RE_GIPHY.exec(str)![1]}`;\n  }\n\n  const match = str.match(RE_GENERIC_EMBED);\n  if (match && match.length === 2) {\n    return match[1];\n  }\n\n  return str;\n};\n\nexport const embeddableURLValidator = (\n  url: string | null | undefined,\n  validateEmbeddable: ExcalidrawProps[\"validateEmbeddable\"],\n): boolean => {\n  if (!url) {\n    return false;\n  }\n  if (validateEmbeddable != null) {\n    if (typeof validateEmbeddable === \"function\") {\n      const ret = validateEmbeddable(url);\n      // if return value is undefined, leave validation to default\n      if (typeof ret === \"boolean\") {\n        return ret;\n      }\n    } else if (typeof validateEmbeddable === \"boolean\") {\n      return validateEmbeddable;\n    } else if (validateEmbeddable instanceof RegExp) {\n      return validateEmbeddable.test(url);\n    } else if (Array.isArray(validateEmbeddable)) {\n      for (const domain of validateEmbeddable) {\n        if (domain instanceof RegExp) {\n          if (url.match(domain)) {\n            return true;\n          }\n        } else if (matchHostname(url, domain)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  return !!matchHostname(url, ALLOWED_DOMAINS);\n};\n",
    "import {\n  DEFAULT_ELEMENT_PROPS,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n  VERTICAL_ALIGN,\n  randomInteger,\n  randomId,\n  getFontString,\n  getUpdatedTimestamp,\n  getLineHeight,\n} from \"@excalidraw/common\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type { MarkOptional, Merge } from \"@excalidraw/common/utility-types\";\n\nimport {\n  getElementAbsoluteCoords,\n  getResizedElementAbsoluteCoords,\n} from \"./bounds\";\nimport { newElementWith } from \"./mutateElement\";\nimport { getBoundTextMaxWidth } from \"./textElement\";\nimport { normalizeText, measureText } from \"./textMeasurements\";\nimport { wrapText } from \"./textWrapping\";\n\nimport { isLineElement } from \"./typeChecks\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawGenericElement,\n  NonDeleted,\n  TextAlign,\n  VerticalAlign,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n  FontFamilyValues,\n  ExcalidrawTextContainer,\n  ExcalidrawFrameElement,\n  ExcalidrawEmbeddableElement,\n  ExcalidrawMagicFrameElement,\n  ExcalidrawIframeElement,\n  ElementsMap,\n  ExcalidrawArrowElement,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawLineElement,\n} from \"./types\";\n\nexport type ElementConstructorOpts = MarkOptional<\n  Omit<ExcalidrawGenericElement, \"id\" | \"type\" | \"isDeleted\" | \"updated\">,\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"groupIds\"\n  | \"frameId\"\n  | \"index\"\n  | \"boundElements\"\n  | \"seed\"\n  | \"version\"\n  | \"versionNonce\"\n  | \"link\"\n  | \"strokeStyle\"\n  | \"fillStyle\"\n  | \"strokeColor\"\n  | \"backgroundColor\"\n  | \"roughness\"\n  | \"strokeWidth\"\n  | \"roundness\"\n  | \"locked\"\n  | \"opacity\"\n  | \"customData\"\n>;\n\nconst _newElementBase = <T extends ExcalidrawElement>(\n  type: T[\"type\"],\n  {\n    x,\n    y,\n    strokeColor = DEFAULT_ELEMENT_PROPS.strokeColor,\n    backgroundColor = DEFAULT_ELEMENT_PROPS.backgroundColor,\n    fillStyle = DEFAULT_ELEMENT_PROPS.fillStyle,\n    strokeWidth = DEFAULT_ELEMENT_PROPS.strokeWidth,\n    strokeStyle = DEFAULT_ELEMENT_PROPS.strokeStyle,\n    roughness = DEFAULT_ELEMENT_PROPS.roughness,\n    opacity = DEFAULT_ELEMENT_PROPS.opacity,\n    width = 0,\n    height = 0,\n    angle = 0 as Radians,\n    groupIds = [],\n    frameId = null,\n    index = null,\n    roundness = null,\n    boundElements = null,\n    link = null,\n    locked = DEFAULT_ELEMENT_PROPS.locked,\n    ...rest\n  }: ElementConstructorOpts & Omit<Partial<ExcalidrawGenericElement>, \"type\">,\n) => {\n  // NOTE (mtolmacs): This is a temporary check to detect extremely large\n  // element position or sizing\n  if (\n    x < -1e6 ||\n    x > 1e6 ||\n    y < -1e6 ||\n    y > 1e6 ||\n    width < -1e6 ||\n    width > 1e6 ||\n    height < -1e6 ||\n    height > 1e6\n  ) {\n    console.error(\"New element size or position is too large\", {\n      x,\n      y,\n      width,\n      height,\n      // @ts-ignore\n      points: rest.points,\n    });\n  }\n\n  // assign type to guard against excess properties\n  const element: Merge<ExcalidrawGenericElement, { type: T[\"type\"] }> = {\n    id: rest.id || randomId(),\n    type,\n    x,\n    y,\n    width,\n    height,\n    angle,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    groupIds,\n    frameId,\n    index,\n    roundness,\n    seed: rest.seed ?? randomInteger(),\n    version: rest.version || 1,\n    versionNonce: rest.versionNonce ?? 0,\n    isDeleted: false as false,\n    boundElements,\n    updated: getUpdatedTimestamp(),\n    link,\n    locked,\n    customData: rest.customData,\n  };\n  return element;\n};\n\nexport const newElement = (\n  opts: {\n    type: ExcalidrawGenericElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawGenericElement> =>\n  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);\n\nexport const newEmbeddableElement = (\n  opts: {\n    type: \"embeddable\";\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawEmbeddableElement> => {\n  return _newElementBase<ExcalidrawEmbeddableElement>(\"embeddable\", opts);\n};\n\nexport const newIframeElement = (\n  opts: {\n    type: \"iframe\";\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawIframeElement> => {\n  return {\n    ..._newElementBase<ExcalidrawIframeElement>(\"iframe\", opts),\n  };\n};\n\nexport const newFrameElement = (\n  opts: {\n    name?: string;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawFrameElement> => {\n  const frameElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawFrameElement>(\"frame\", opts),\n      type: \"frame\",\n      name: opts?.name || null,\n    },\n    {},\n  );\n\n  return frameElement;\n};\n\nexport const newMagicFrameElement = (\n  opts: {\n    name?: string;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawMagicFrameElement> => {\n  const frameElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawMagicFrameElement>(\"magicframe\", opts),\n      type: \"magicframe\",\n      name: opts?.name || null,\n    },\n    {},\n  );\n\n  return frameElement;\n};\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nconst getTextElementPositionOffsets = (\n  opts: {\n    textAlign: ExcalidrawTextElement[\"textAlign\"];\n    verticalAlign: ExcalidrawTextElement[\"verticalAlign\"];\n  },\n  metrics: {\n    width: number;\n    height: number;\n  },\n) => {\n  return {\n    x:\n      opts.textAlign === \"center\"\n        ? metrics.width / 2\n        : opts.textAlign === \"right\"\n        ? metrics.width\n        : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0,\n  };\n};\n\nexport const newTextElement = (\n  opts: {\n    text: string;\n    originalText?: string;\n    fontSize?: number;\n    fontFamily?: FontFamilyValues;\n    textAlign?: TextAlign;\n    verticalAlign?: VerticalAlign;\n    containerId?: ExcalidrawTextContainer[\"id\"] | null;\n    lineHeight?: ExcalidrawTextElement[\"lineHeight\"];\n    autoResize?: ExcalidrawTextElement[\"autoResize\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawTextElement> => {\n  const fontFamily = opts.fontFamily || DEFAULT_FONT_FAMILY;\n  const fontSize = opts.fontSize || DEFAULT_FONT_SIZE;\n  const lineHeight = opts.lineHeight || getLineHeight(fontFamily);\n  const text = normalizeText(opts.text);\n  const metrics = measureText(\n    text,\n    getFontString({ fontFamily, fontSize }),\n    lineHeight,\n  );\n  const textAlign = opts.textAlign || DEFAULT_TEXT_ALIGN;\n  const verticalAlign = opts.verticalAlign || DEFAULT_VERTICAL_ALIGN;\n  const offsets = getTextElementPositionOffsets(\n    { textAlign, verticalAlign },\n    metrics,\n  );\n\n  const textElementProps: ExcalidrawTextElement = {\n    ..._newElementBase<ExcalidrawTextElement>(\"text\", opts),\n    text,\n    fontSize,\n    fontFamily,\n    textAlign,\n    verticalAlign,\n    x: opts.x - offsets.x,\n    y: opts.y - offsets.y,\n    width: metrics.width,\n    height: metrics.height,\n    containerId: opts.containerId || null,\n    originalText: opts.originalText ?? text,\n    autoResize: opts.autoResize ?? true,\n    lineHeight,\n  };\n\n  const textElement: ExcalidrawTextElement = newElementWith(\n    textElementProps,\n    {},\n  );\n\n  return textElement;\n};\n\nconst getAdjustedDimensions = (\n  element: ExcalidrawTextElement,\n  elementsMap: ElementsMap,\n  nextText: string,\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n} => {\n  let { width: nextWidth, height: nextHeight } = measureText(\n    nextText,\n    getFontString(element),\n    element.lineHeight,\n  );\n\n  // wrapped text\n  if (!element.autoResize) {\n    nextWidth = element.width;\n  }\n\n  const { textAlign, verticalAlign } = element;\n  let x: number;\n  let y: number;\n  if (\n    textAlign === \"center\" &&\n    verticalAlign === VERTICAL_ALIGN.MIDDLE &&\n    !element.containerId &&\n    element.autoResize\n  ) {\n    const prevMetrics = measureText(\n      element.text,\n      getFontString(element),\n      element.lineHeight,\n    );\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height,\n    });\n\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n      false,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n\n    [x, y] = adjustXYWithRotation(\n      {\n        s: true,\n        e: textAlign === \"center\" || textAlign === \"left\",\n        w: textAlign === \"center\" || textAlign === \"right\",\n      },\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n  };\n};\n\nconst adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const refreshTextDimensions = (\n  textElement: ExcalidrawTextElement,\n  container: ExcalidrawTextContainer | null,\n  elementsMap: ElementsMap,\n  text = textElement.text,\n) => {\n  if (textElement.isDeleted) {\n    return;\n  }\n  if (container || !textElement.autoResize) {\n    text = wrapText(\n      text,\n      getFontString(textElement),\n      container\n        ? getBoundTextMaxWidth(container, textElement)\n        : textElement.width,\n    );\n  }\n  const dimensions = getAdjustedDimensions(textElement, elementsMap, text);\n  return { text, ...dimensions };\n};\n\nexport const newFreeDrawElement = (\n  opts: {\n    type: \"freedraw\";\n    points?: ExcalidrawFreeDrawElement[\"points\"];\n    simulatePressure: boolean;\n    pressures?: ExcalidrawFreeDrawElement[\"pressures\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawFreeDrawElement> => {\n  return {\n    ..._newElementBase<ExcalidrawFreeDrawElement>(opts.type, opts),\n    points: opts.points || [],\n    pressures: opts.pressures || [],\n    simulatePressure: opts.simulatePressure,\n    lastCommittedPoint: null,\n  };\n};\n\nexport const newLinearElement = (\n  opts: {\n    type: ExcalidrawLinearElement[\"type\"];\n    points?: ExcalidrawLinearElement[\"points\"];\n    polygon?: ExcalidrawLineElement[\"polygon\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawLinearElement> => {\n  const element = {\n    ..._newElementBase<ExcalidrawLinearElement>(opts.type, opts),\n    points: opts.points || [],\n    lastCommittedPoint: null,\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: null,\n    endArrowhead: null,\n  };\n\n  if (isLineElement(element)) {\n    const lineElement: NonDeleted<ExcalidrawLineElement> = {\n      ...element,\n      polygon: opts.polygon ?? false,\n    };\n\n    return lineElement;\n  }\n\n  return element;\n};\n\nexport const newArrowElement = <T extends boolean>(\n  opts: {\n    type: ExcalidrawArrowElement[\"type\"];\n    startArrowhead?: Arrowhead | null;\n    endArrowhead?: Arrowhead | null;\n    points?: ExcalidrawArrowElement[\"points\"];\n    elbowed?: T;\n    fixedSegments?: ExcalidrawElbowArrowElement[\"fixedSegments\"] | null;\n  } & ElementConstructorOpts,\n): T extends true\n  ? NonDeleted<ExcalidrawElbowArrowElement>\n  : NonDeleted<ExcalidrawArrowElement> => {\n  if (opts.elbowed) {\n    return {\n      ..._newElementBase<ExcalidrawElbowArrowElement>(opts.type, opts),\n      points: opts.points || [],\n      lastCommittedPoint: null,\n      startBinding: null,\n      endBinding: null,\n      startArrowhead: opts.startArrowhead || null,\n      endArrowhead: opts.endArrowhead || null,\n      elbowed: true,\n      fixedSegments: opts.fixedSegments || [],\n      startIsSpecial: false,\n      endIsSpecial: false,\n    } as NonDeleted<ExcalidrawElbowArrowElement>;\n  }\n\n  return {\n    ..._newElementBase<ExcalidrawArrowElement>(opts.type, opts),\n    points: opts.points || [],\n    lastCommittedPoint: null,\n    startBinding: null,\n    endBinding: null,\n    startArrowhead: opts.startArrowhead || null,\n    endArrowhead: opts.endArrowhead || null,\n    elbowed: false,\n  } as T extends true\n    ? NonDeleted<ExcalidrawElbowArrowElement>\n    : NonDeleted<ExcalidrawArrowElement>;\n};\n\nexport const newImageElement = (\n  opts: {\n    type: ExcalidrawImageElement[\"type\"];\n    status?: ExcalidrawImageElement[\"status\"];\n    fileId?: ExcalidrawImageElement[\"fileId\"];\n    scale?: ExcalidrawImageElement[\"scale\"];\n    crop?: ExcalidrawImageElement[\"crop\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawImageElement> => {\n  return {\n    ..._newElementBase<ExcalidrawImageElement>(\"image\", opts),\n    // in the future we'll support changing stroke color for some SVG elements,\n    // and `transparent` will likely mean \"use original colors of the image\"\n    strokeColor: \"transparent\",\n    status: opts.status ?? \"pending\",\n    fileId: opts.fileId ?? null,\n    scale: opts.scale ?? [1, 1],\n    crop: opts.crop ?? null,\n  };\n};\n",
    "import { KEYS, invariant, toBrandedType } from \"@excalidraw/common\";\n\nimport { type GlobalPoint, pointFrom, type LocalPoint } from \"@excalidraw/math\";\n\nimport type {\n  AppState,\n  PendingExcalidrawElements,\n} from \"excalidraw-custom/types\";\n\nimport { bindLinearElement } from \"./binding\";\nimport { updateElbowArrowPoints } from \"./elbowArrow\";\nimport {\n  HEADING_DOWN,\n  HEADING_LEFT,\n  HEADING_RIGHT,\n  HEADING_UP,\n  compareHeading,\n  headingForPointFromElement,\n  type Heading,\n} from \"./heading\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { mutateElement } from \"./mutateElement\";\nimport { newArrowElement, newElement } from \"./newElement\";\nimport { aabbForElement } from \"./bounds\";\nimport { elementsAreInFrameBounds, elementOverlapsWithFrame } from \"./frame\";\nimport {\n  isBindableElement,\n  isElbowArrow,\n  isFrameElement,\n  isFlowchartNodeElement,\n} from \"./typeChecks\";\nimport {\n  type ElementsMap,\n  type ExcalidrawBindableElement,\n  type ExcalidrawElement,\n  type ExcalidrawFlowchartNodeElement,\n  type NonDeletedSceneElementsMap,\n  type Ordered,\n  type OrderedExcalidrawElement,\n} from \"./types\";\n\nimport type { Scene } from \"./Scene\";\n\ntype LinkDirection = \"up\" | \"right\" | \"down\" | \"left\";\n\nconst VERTICAL_OFFSET = 100;\nconst HORIZONTAL_OFFSET = 100;\n\nexport const getLinkDirectionFromKey = (key: string): LinkDirection => {\n  switch (key) {\n    case KEYS.ARROW_UP:\n      return \"up\";\n    case KEYS.ARROW_DOWN:\n      return \"down\";\n    case KEYS.ARROW_RIGHT:\n      return \"right\";\n    case KEYS.ARROW_LEFT:\n      return \"left\";\n    default:\n      return \"right\";\n  }\n};\n\nconst getNodeRelatives = (\n  type: \"predecessors\" | \"successors\",\n  node: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  direction: LinkDirection,\n) => {\n  const items = [...elementsMap.values()].reduce(\n    (acc: { relative: ExcalidrawBindableElement; heading: Heading }[], el) => {\n      let oppositeBinding;\n      if (\n        isElbowArrow(el) &&\n        // we want check existence of the opposite binding, in the direction\n        // we're interested in\n        (oppositeBinding =\n          el[type === \"predecessors\" ? \"startBinding\" : \"endBinding\"]) &&\n        // similarly, we need to filter only arrows bound to target node\n        el[type === \"predecessors\" ? \"endBinding\" : \"startBinding\"]\n          ?.elementId === node.id\n      ) {\n        const relative = elementsMap.get(oppositeBinding.elementId);\n\n        if (!relative) {\n          return acc;\n        }\n\n        invariant(\n          isBindableElement(relative),\n          \"not an ExcalidrawBindableElement\",\n        );\n\n        const edgePoint = (\n          type === \"predecessors\" ? el.points[el.points.length - 1] : [0, 0]\n        ) as Readonly<LocalPoint>;\n\n        const heading = headingForPointFromElement(\n          node,\n          aabbForElement(node, elementsMap),\n          [edgePoint[0] + el.x, edgePoint[1] + el.y] as Readonly<GlobalPoint>,\n        );\n\n        acc.push({\n          relative,\n          heading,\n        });\n      }\n      return acc;\n    },\n    [],\n  );\n\n  switch (direction) {\n    case \"up\":\n      return items\n        .filter((item) => compareHeading(item.heading, HEADING_UP))\n        .map((item) => item.relative);\n    case \"down\":\n      return items\n        .filter((item) => compareHeading(item.heading, HEADING_DOWN))\n        .map((item) => item.relative);\n    case \"right\":\n      return items\n        .filter((item) => compareHeading(item.heading, HEADING_RIGHT))\n        .map((item) => item.relative);\n    case \"left\":\n      return items\n        .filter((item) => compareHeading(item.heading, HEADING_LEFT))\n        .map((item) => item.relative);\n  }\n};\n\nconst getSuccessors = (\n  node: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  direction: LinkDirection,\n) => {\n  return getNodeRelatives(\"successors\", node, elementsMap, direction);\n};\n\nexport const getPredecessors = (\n  node: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  direction: LinkDirection,\n) => {\n  return getNodeRelatives(\"predecessors\", node, elementsMap, direction);\n};\n\nconst getOffsets = (\n  element: ExcalidrawFlowchartNodeElement,\n  linkedNodes: ExcalidrawElement[],\n  direction: LinkDirection,\n) => {\n  const _HORIZONTAL_OFFSET = HORIZONTAL_OFFSET + element.width;\n\n  // check if vertical space or horizontal space is available first\n  if (direction === \"up\" || direction === \"down\") {\n    const _VERTICAL_OFFSET = VERTICAL_OFFSET + element.height;\n    // check vertical space\n    const minX = element.x;\n    const maxX = element.x + element.width;\n\n    // vertical space is available\n    if (\n      linkedNodes.every(\n        (linkedNode) =>\n          linkedNode.x + linkedNode.width < minX || linkedNode.x > maxX,\n      )\n    ) {\n      return {\n        x: 0,\n        y: _VERTICAL_OFFSET * (direction === \"up\" ? -1 : 1),\n      };\n    }\n  } else if (direction === \"right\" || direction === \"left\") {\n    const minY = element.y;\n    const maxY = element.y + element.height;\n\n    if (\n      linkedNodes.every(\n        (linkedNode) =>\n          linkedNode.y + linkedNode.height < minY || linkedNode.y > maxY,\n      )\n    ) {\n      return {\n        x:\n          (HORIZONTAL_OFFSET + element.width) * (direction === \"left\" ? -1 : 1),\n        y: 0,\n      };\n    }\n  }\n\n  if (direction === \"up\" || direction === \"down\") {\n    const _VERTICAL_OFFSET = VERTICAL_OFFSET + element.height;\n    const y = linkedNodes.length === 0 ? _VERTICAL_OFFSET : _VERTICAL_OFFSET;\n    const x =\n      linkedNodes.length === 0\n        ? 0\n        : (linkedNodes.length + 1) % 2 === 0\n        ? ((linkedNodes.length + 1) / 2) * _HORIZONTAL_OFFSET\n        : (linkedNodes.length / 2) * _HORIZONTAL_OFFSET * -1;\n\n    if (direction === \"up\") {\n      return {\n        x,\n        y: y * -1,\n      };\n    }\n\n    return {\n      x,\n      y,\n    };\n  }\n\n  const _VERTICAL_OFFSET = VERTICAL_OFFSET + element.height;\n  const x =\n    (linkedNodes.length === 0 ? HORIZONTAL_OFFSET : HORIZONTAL_OFFSET) +\n    element.width;\n  const y =\n    linkedNodes.length === 0\n      ? 0\n      : (linkedNodes.length + 1) % 2 === 0\n      ? ((linkedNodes.length + 1) / 2) * _VERTICAL_OFFSET\n      : (linkedNodes.length / 2) * _VERTICAL_OFFSET * -1;\n\n  if (direction === \"left\") {\n    return {\n      x: x * -1,\n      y,\n    };\n  }\n  return {\n    x,\n    y,\n  };\n};\n\nconst addNewNode = (\n  element: ExcalidrawFlowchartNodeElement,\n  appState: AppState,\n  direction: LinkDirection,\n  scene: Scene,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const successors = getSuccessors(element, elementsMap, direction);\n  const predeccessors = getPredecessors(element, elementsMap, direction);\n\n  const offsets = getOffsets(\n    element,\n    [...successors, ...predeccessors],\n    direction,\n  );\n\n  const nextNode = newElement({\n    type: element.type,\n    x: element.x + offsets.x,\n    y: element.y + offsets.y,\n    // TODO: extract this to a util\n    width: element.width,\n    height: element.height,\n    roundness: element.roundness,\n    roughness: element.roughness,\n    backgroundColor: element.backgroundColor,\n    strokeColor: element.strokeColor,\n    strokeWidth: element.strokeWidth,\n    opacity: element.opacity,\n    fillStyle: element.fillStyle,\n    strokeStyle: element.strokeStyle,\n  });\n\n  invariant(\n    isFlowchartNodeElement(nextNode),\n    \"not an ExcalidrawFlowchartNodeElement\",\n  );\n\n  const bindingArrow = createBindingArrow(\n    element,\n    nextNode,\n    direction,\n    appState,\n    scene,\n  );\n\n  return {\n    nextNode,\n    bindingArrow,\n  };\n};\n\nexport const addNewNodes = (\n  startNode: ExcalidrawFlowchartNodeElement,\n  appState: AppState,\n  direction: LinkDirection,\n  scene: Scene,\n  numberOfNodes: number,\n) => {\n  // always start from 0 and distribute evenly\n  const newNodes: ExcalidrawElement[] = [];\n\n  for (let i = 0; i < numberOfNodes; i++) {\n    let nextX: number;\n    let nextY: number;\n    if (direction === \"left\" || direction === \"right\") {\n      const totalHeight =\n        VERTICAL_OFFSET * (numberOfNodes - 1) +\n        numberOfNodes * startNode.height;\n\n      const startY = startNode.y + startNode.height / 2 - totalHeight / 2;\n\n      let offsetX = HORIZONTAL_OFFSET + startNode.width;\n      if (direction === \"left\") {\n        offsetX *= -1;\n      }\n      nextX = startNode.x + offsetX;\n      const offsetY = (VERTICAL_OFFSET + startNode.height) * i;\n      nextY = startY + offsetY;\n    } else {\n      const totalWidth =\n        HORIZONTAL_OFFSET * (numberOfNodes - 1) +\n        numberOfNodes * startNode.width;\n      const startX = startNode.x + startNode.width / 2 - totalWidth / 2;\n      let offsetY = VERTICAL_OFFSET + startNode.height;\n\n      if (direction === \"up\") {\n        offsetY *= -1;\n      }\n      nextY = startNode.y + offsetY;\n      const offsetX = (HORIZONTAL_OFFSET + startNode.width) * i;\n      nextX = startX + offsetX;\n    }\n\n    const nextNode = newElement({\n      type: startNode.type,\n      x: nextX,\n      y: nextY,\n      // TODO: extract this to a util\n      width: startNode.width,\n      height: startNode.height,\n      roundness: startNode.roundness,\n      roughness: startNode.roughness,\n      backgroundColor: startNode.backgroundColor,\n      strokeColor: startNode.strokeColor,\n      strokeWidth: startNode.strokeWidth,\n      opacity: startNode.opacity,\n      fillStyle: startNode.fillStyle,\n      strokeStyle: startNode.strokeStyle,\n    });\n\n    invariant(\n      isFlowchartNodeElement(nextNode),\n      \"not an ExcalidrawFlowchartNodeElement\",\n    );\n\n    const bindingArrow = createBindingArrow(\n      startNode,\n      nextNode,\n      direction,\n      appState,\n      scene,\n    );\n\n    newNodes.push(nextNode);\n    newNodes.push(bindingArrow);\n  }\n\n  return newNodes;\n};\n\nconst createBindingArrow = (\n  startBindingElement: ExcalidrawFlowchartNodeElement,\n  endBindingElement: ExcalidrawFlowchartNodeElement,\n  direction: LinkDirection,\n  appState: AppState,\n  scene: Scene,\n) => {\n  let startX: number;\n  let startY: number;\n\n  const PADDING = 6;\n\n  switch (direction) {\n    case \"up\": {\n      startX = startBindingElement.x + startBindingElement.width / 2;\n      startY = startBindingElement.y - PADDING;\n      break;\n    }\n    case \"down\": {\n      startX = startBindingElement.x + startBindingElement.width / 2;\n      startY = startBindingElement.y + startBindingElement.height + PADDING;\n      break;\n    }\n    case \"right\": {\n      startX = startBindingElement.x + startBindingElement.width + PADDING;\n      startY = startBindingElement.y + startBindingElement.height / 2;\n      break;\n    }\n    case \"left\": {\n      startX = startBindingElement.x - PADDING;\n      startY = startBindingElement.y + startBindingElement.height / 2;\n      break;\n    }\n  }\n\n  let endX: number;\n  let endY: number;\n\n  switch (direction) {\n    case \"up\": {\n      endX = endBindingElement.x + endBindingElement.width / 2 - startX;\n      endY = endBindingElement.y + endBindingElement.height - startY + PADDING;\n      break;\n    }\n    case \"down\": {\n      endX = endBindingElement.x + endBindingElement.width / 2 - startX;\n      endY = endBindingElement.y - startY - PADDING;\n      break;\n    }\n    case \"right\": {\n      endX = endBindingElement.x - startX - PADDING;\n      endY = endBindingElement.y - startY + endBindingElement.height / 2;\n      break;\n    }\n    case \"left\": {\n      endX = endBindingElement.x + endBindingElement.width - startX + PADDING;\n      endY = endBindingElement.y - startY + endBindingElement.height / 2;\n      break;\n    }\n  }\n\n  const bindingArrow = newArrowElement({\n    type: \"arrow\",\n    x: startX,\n    y: startY,\n    startArrowhead: null,\n    endArrowhead: appState.currentItemEndArrowhead,\n    strokeColor: startBindingElement.strokeColor,\n    strokeStyle: startBindingElement.strokeStyle,\n    strokeWidth: startBindingElement.strokeWidth,\n    opacity: startBindingElement.opacity,\n    roughness: startBindingElement.roughness,\n    points: [pointFrom(0, 0), pointFrom(endX, endY)],\n    elbowed: true,\n  });\n\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  bindLinearElement(bindingArrow, startBindingElement, \"start\", scene);\n  bindLinearElement(bindingArrow, endBindingElement, \"end\", scene);\n\n  const changedElements = new Map<string, OrderedExcalidrawElement>();\n  changedElements.set(\n    startBindingElement.id,\n    startBindingElement as OrderedExcalidrawElement,\n  );\n  changedElements.set(\n    endBindingElement.id,\n    endBindingElement as OrderedExcalidrawElement,\n  );\n  changedElements.set(\n    bindingArrow.id,\n    bindingArrow as OrderedExcalidrawElement,\n  );\n\n  LinearElementEditor.movePoints(\n    bindingArrow,\n    scene,\n    new Map([\n      [\n        1,\n        {\n          point: bindingArrow.points[1],\n        },\n      ],\n    ]),\n  );\n\n  const update = updateElbowArrowPoints(\n    bindingArrow,\n    toBrandedType<NonDeletedSceneElementsMap>(\n      new Map([\n        ...elementsMap.entries(),\n        [startBindingElement.id, startBindingElement],\n        [endBindingElement.id, endBindingElement],\n        [bindingArrow.id, bindingArrow],\n      ] as [string, Ordered<ExcalidrawElement>][]),\n    ),\n    { points: bindingArrow.points },\n  );\n\n  return {\n    ...bindingArrow,\n    ...update,\n  };\n};\n\nexport class FlowChartNavigator {\n  isExploring: boolean = false;\n  // nodes that are ONE link away (successor and predecessor both included)\n  private sameLevelNodes: ExcalidrawElement[] = [];\n  private sameLevelIndex: number = 0;\n  // set it to the opposite of the defalut creation direction\n  private direction: LinkDirection | null = null;\n  // for speedier navigation\n  private visitedNodes: Set<ExcalidrawElement[\"id\"]> = new Set();\n\n  clear() {\n    this.isExploring = false;\n    this.sameLevelNodes = [];\n    this.sameLevelIndex = 0;\n    this.direction = null;\n    this.visitedNodes.clear();\n  }\n\n  exploreByDirection(\n    element: ExcalidrawElement,\n    elementsMap: ElementsMap,\n    direction: LinkDirection,\n  ): ExcalidrawElement[\"id\"] | null {\n    if (!isBindableElement(element)) {\n      return null;\n    }\n\n    // clear if going at a different direction\n    if (direction !== this.direction) {\n      this.clear();\n    }\n\n    // add the current node to the visited\n    if (!this.visitedNodes.has(element.id)) {\n      this.visitedNodes.add(element.id);\n    }\n\n    /**\n     * CASE:\n     * - already started exploring, AND\n     * - there are multiple nodes at the same level, AND\n     * - still going at the same direction, AND\n     *\n     * RESULT:\n     * - loop through nodes at the same level\n     *\n     * WHY:\n     * - provides user the capability to loop through nodes at the same level\n     */\n    if (\n      this.isExploring &&\n      direction === this.direction &&\n      this.sameLevelNodes.length > 1\n    ) {\n      this.sameLevelIndex =\n        (this.sameLevelIndex + 1) % this.sameLevelNodes.length;\n\n      return this.sameLevelNodes[this.sameLevelIndex].id;\n    }\n\n    const nodes = [\n      ...getSuccessors(element, elementsMap, direction),\n      ...getPredecessors(element, elementsMap, direction),\n    ];\n\n    /**\n     * CASE:\n     * - just started exploring at the given direction\n     *\n     * RESULT:\n     * - go to the first node in the given direction\n     */\n    if (nodes.length > 0) {\n      this.sameLevelIndex = 0;\n      this.isExploring = true;\n      this.sameLevelNodes = nodes;\n      this.direction = direction;\n      this.visitedNodes.add(nodes[0].id);\n\n      return nodes[0].id;\n    }\n\n    /**\n     * CASE:\n     * - (just started exploring or still going at the same direction) OR\n     * - there're no nodes at the given direction\n     *\n     * RESULT:\n     * - go to some other unvisited linked node\n     *\n     * WHY:\n     * - provide a speedier navigation from a given node to some predecessor\n     *   without the user having to change arrow key\n     */\n    if (direction === this.direction || !this.isExploring) {\n      if (!this.isExploring) {\n        // just started and no other nodes at the given direction\n        // so the current node is technically the first visited node\n        // (this is needed so that we don't get stuck between looping through )\n        this.visitedNodes.add(element.id);\n      }\n\n      const otherDirections: LinkDirection[] = [\n        \"up\",\n        \"right\",\n        \"down\",\n        \"left\",\n      ].filter((dir): dir is LinkDirection => dir !== direction);\n\n      const otherLinkedNodes = otherDirections\n        .map((dir) => [\n          ...getSuccessors(element, elementsMap, dir),\n          ...getPredecessors(element, elementsMap, dir),\n        ])\n        .flat()\n        .filter((linkedNode) => !this.visitedNodes.has(linkedNode.id));\n\n      for (const linkedNode of otherLinkedNodes) {\n        if (!this.visitedNodes.has(linkedNode.id)) {\n          this.visitedNodes.add(linkedNode.id);\n          this.isExploring = true;\n          this.direction = direction;\n          return linkedNode.id;\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\nexport class FlowChartCreator {\n  isCreatingChart: boolean = false;\n  private numberOfNodes: number = 0;\n  private direction: LinkDirection | null = \"right\";\n  pendingNodes: PendingExcalidrawElements | null = null;\n\n  createNodes(\n    startNode: ExcalidrawFlowchartNodeElement,\n    appState: AppState,\n    direction: LinkDirection,\n    scene: Scene,\n  ) {\n    const elementsMap = scene.getNonDeletedElementsMap();\n    if (direction !== this.direction) {\n      const { nextNode, bindingArrow } = addNewNode(\n        startNode,\n        appState,\n        direction,\n        scene,\n      );\n\n      this.numberOfNodes = 1;\n      this.isCreatingChart = true;\n      this.direction = direction;\n      this.pendingNodes = [nextNode, bindingArrow];\n    } else {\n      this.numberOfNodes += 1;\n      const newNodes = addNewNodes(\n        startNode,\n        appState,\n        direction,\n        scene,\n        this.numberOfNodes,\n      );\n\n      this.isCreatingChart = true;\n      this.direction = direction;\n      this.pendingNodes = newNodes;\n    }\n\n    // add pending nodes to the same frame as the start node\n    // if every pending node is at least intersecting with the frame\n    if (startNode.frameId) {\n      const frame = elementsMap.get(startNode.frameId);\n\n      invariant(\n        frame && isFrameElement(frame),\n        \"not an ExcalidrawFrameElement\",\n      );\n\n      if (\n        frame &&\n        this.pendingNodes.every(\n          (node) =>\n            elementsAreInFrameBounds([node], frame, elementsMap) ||\n            elementOverlapsWithFrame(node, frame, elementsMap),\n        )\n      ) {\n        this.pendingNodes = this.pendingNodes.map((node) =>\n          mutateElement(node, elementsMap, {\n            frameId: startNode.frameId,\n          }),\n        );\n      }\n    }\n  }\n\n  clear() {\n    this.isCreatingChart = false;\n    this.pendingNodes = null;\n    this.direction = null;\n    this.numberOfNodes = 0;\n  }\n}\n\nexport const isNodeInFlowchart = (\n  element: ExcalidrawFlowchartNodeElement,\n  elementsMap: ElementsMap,\n) => {\n  for (const [, el] of elementsMap) {\n    if (\n      el.type === \"arrow\" &&\n      (el.startBinding?.elementId === element.id ||\n        el.endBinding?.elementId === element.id)\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n};\n",
    "// -----------------------------------------------------------------------------\n// ExcalidrawImageElement & related helpers\n// -----------------------------------------------------------------------------\n\nimport { MIME_TYPES, SVG_NS } from \"@excalidraw/common\";\n\nimport type {\n  AppClassProperties,\n  DataURL,\n  BinaryFiles,\n} from \"excalidraw-custom/types\";\n\nimport { isInitializedImageElement } from \"./typeChecks\";\n\nimport type {\n  ExcalidrawElement,\n  FileId,\n  InitializedExcalidrawImageElement,\n} from \"./types\";\n\nexport const loadHTMLImageElement = (dataURL: DataURL) => {\n  return new Promise<HTMLImageElement>((resolve, reject) => {\n    const image = new Image();\n    image.onload = () => {\n      resolve(image);\n    };\n    image.onerror = (error) => {\n      reject(error);\n    };\n    image.src = dataURL;\n  });\n};\n\n/** NOTE: updates cache even if already populated with given image. Thus,\n * you should filter out the images upstream if you want to optimize this. */\nexport const updateImageCache = async ({\n  fileIds,\n  files,\n  imageCache,\n}: {\n  fileIds: FileId[];\n  files: BinaryFiles;\n  imageCache: AppClassProperties[\"imageCache\"];\n}) => {\n  const updatedFiles = new Map<FileId, true>();\n  const erroredFiles = new Map<FileId, true>();\n\n  await Promise.all(\n    fileIds.reduce((promises, fileId) => {\n      const fileData = files[fileId as string];\n      if (fileData && !updatedFiles.has(fileId)) {\n        updatedFiles.set(fileId, true);\n        return promises.concat(\n          (async () => {\n            try {\n              if (fileData.mimeType === MIME_TYPES.binary) {\n                throw new Error(\"Only images can be added to ImageCache\");\n              }\n\n              const imagePromise = loadHTMLImageElement(fileData.dataURL);\n              const data = {\n                image: imagePromise,\n                mimeType: fileData.mimeType,\n              } as const;\n              // store the promise immediately to indicate there's an in-progress\n              // initialization\n              imageCache.set(fileId, data);\n\n              const image = await imagePromise;\n\n              imageCache.set(fileId, { ...data, image });\n            } catch (error: any) {\n              erroredFiles.set(fileId, true);\n            }\n          })(),\n        );\n      }\n      return promises;\n    }, [] as Promise<any>[]),\n  );\n\n  return {\n    imageCache,\n    /** includes errored files because they cache was updated nonetheless */\n    updatedFiles,\n    /** files that failed when creating HTMLImageElement */\n    erroredFiles,\n  };\n};\n\nexport const getInitializedImageElements = (\n  elements: readonly ExcalidrawElement[],\n) =>\n  elements.filter((element) =>\n    isInitializedImageElement(element),\n  ) as InitializedExcalidrawImageElement[];\n\nexport const isHTMLSVGElement = (node: Node | null): node is SVGElement => {\n  // lower-casing due to XML/HTML convention differences\n  // https://johnresig.com/blog/nodename-case-sensitivity\n  return node?.nodeName.toLowerCase() === \"svg\";\n};\n\nexport const normalizeSVG = (SVGString: string) => {\n  const doc = new DOMParser().parseFromString(SVGString, MIME_TYPES.svg);\n  const svg = doc.querySelector(\"svg\");\n  const errorNode = doc.querySelector(\"parsererror\");\n  if (errorNode || !isHTMLSVGElement(svg)) {\n    throw new Error(\"Invalid SVG\");\n  } else {\n    if (!svg.hasAttribute(\"xmlns\")) {\n      svg.setAttribute(\"xmlns\", SVG_NS);\n    }\n\n    let width = svg.getAttribute(\"width\");\n    let height = svg.getAttribute(\"height\");\n\n    // Do not use % or auto values for width/height\n    // to avoid scaling issues when rendering at different sizes/zoom levels\n    if (width?.includes(\"%\") || width === \"auto\") {\n      width = null;\n    }\n    if (height?.includes(\"%\") || height === \"auto\") {\n      height = null;\n    }\n\n    const viewBox = svg.getAttribute(\"viewBox\");\n\n    if (!width || !height) {\n      width = width || \"50\";\n      height = height || \"50\";\n\n      if (viewBox) {\n        const match = viewBox.match(\n          /\\d+ +\\d+ +(\\d+(?:\\.\\d+)?) +(\\d+(?:\\.\\d+)?)/,\n        );\n        if (match) {\n          [, width, height] = match;\n        }\n      }\n\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n\n    // Make sure viewBox is set\n    if (!viewBox) {\n      svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    }\n\n    return svg.outerHTML;\n  }\n};\n",
    "import {\n  pointCenter,\n  normalizeRadians,\n  pointFrom,\n  pointRotateRads,\n  type Radians,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport {\n  MIN_FONT_SIZE,\n  SHIFT_LOCKING_ANGLE,\n  rescalePoints,\n  getFontString,\n} from \"@excalidraw/common\";\n\nimport type { GlobalPoint } from \"@excalidraw/math\";\n\nimport type { PointerDownState } from \"excalidraw-custom/types\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport { getArrowLocalFixedPoints, updateBoundElements } from \"./binding\";\nimport {\n  getElementAbsoluteCoords,\n  getCommonBounds,\n  getResizedElementAbsoluteCoords,\n  getCommonBoundingBox,\n  getElementBounds,\n} from \"./bounds\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport {\n  getBoundTextElement,\n  getBoundTextElementId,\n  getContainerElement,\n  handleBindTextResize,\n  getBoundTextMaxWidth,\n} from \"./textElement\";\nimport {\n  getMinTextElementWidth,\n  measureText,\n  getApproxMinLineWidth,\n  getApproxMinLineHeight,\n} from \"./textMeasurements\";\nimport { wrapText } from \"./textWrapping\";\nimport {\n  isArrowElement,\n  isBoundToContainer,\n  isElbowArrow,\n  isFrameLikeElement,\n  isFreeDrawElement,\n  isImageElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport { isInGroup } from \"./groups\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { BoundingBox } from \"./bounds\";\nimport type {\n  MaybeTransformHandleType,\n  TransformHandleDirection,\n} from \"./transformHandles\";\nimport type {\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ExcalidrawElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawImageElement,\n  ElementsMap,\n  ExcalidrawElbowArrowElement,\n} from \"./types\";\n\n// Returns true when transform (resizing/rotation) happened\nexport const transformElements = (\n  originalElements: PointerDownState[\"originalElements\"],\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  scene: Scene,\n  shouldRotateWithDiscreteAngle: boolean,\n  shouldResizeFromCenter: boolean,\n  shouldMaintainAspectRatio: boolean,\n  pointerX: number,\n  pointerY: number,\n  centerX: number,\n  centerY: number,\n): boolean => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n    if (transformHandleType === \"rotation\") {\n      if (!isElbowArrow(element)) {\n        rotateSingleElement(\n          element,\n          scene,\n          pointerX,\n          pointerY,\n          shouldRotateWithDiscreteAngle,\n        );\n        updateBoundElements(element, scene);\n      }\n    } else if (transformHandleType) {\n      const elementId = selectedElements[0].id;\n      const latestElement = elementsMap.get(elementId);\n      const origElement = originalElements.get(elementId);\n\n      if (latestElement && origElement) {\n        const { nextWidth, nextHeight } =\n          getNextSingleWidthAndHeightFromPointer(\n            latestElement,\n            origElement,\n            transformHandleType,\n            pointerX,\n            pointerY,\n            {\n              shouldMaintainAspectRatio,\n              shouldResizeFromCenter,\n            },\n          );\n\n        resizeSingleElement(\n          nextWidth,\n          nextHeight,\n          latestElement,\n          origElement,\n          originalElements,\n          scene,\n          transformHandleType,\n          {\n            shouldMaintainAspectRatio,\n            shouldResizeFromCenter,\n          },\n        );\n      }\n    }\n    if (isTextElement(element)) {\n      updateBoundElements(element, scene);\n    }\n    return true;\n  } else if (selectedElements.length > 1) {\n    if (transformHandleType === \"rotation\") {\n      rotateMultipleElements(\n        originalElements,\n        selectedElements,\n        scene,\n        pointerX,\n        pointerY,\n        shouldRotateWithDiscreteAngle,\n        centerX,\n        centerY,\n      );\n      return true;\n    } else if (transformHandleType) {\n      const { nextWidth, nextHeight, flipByX, flipByY, originalBoundingBox } =\n        getNextMultipleWidthAndHeightFromPointer(\n          selectedElements,\n          originalElements,\n          elementsMap,\n          transformHandleType,\n          pointerX,\n          pointerY,\n          {\n            shouldMaintainAspectRatio,\n            shouldResizeFromCenter,\n          },\n        );\n\n      resizeMultipleElements(\n        selectedElements,\n        elementsMap,\n        transformHandleType,\n        scene,\n        originalElements,\n        {\n          shouldResizeFromCenter,\n          shouldMaintainAspectRatio,\n          flipByX,\n          flipByY,\n          nextWidth,\n          nextHeight,\n          originalBoundingBox,\n        },\n      );\n\n      return true;\n    }\n  }\n  return false;\n};\n\nconst rotateSingleElement = (\n  element: NonDeletedExcalidrawElement,\n  scene: Scene,\n  pointerX: number,\n  pointerY: number,\n  shouldRotateWithDiscreteAngle: boolean,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(\n    element,\n    scene.getNonDeletedElementsMap(),\n  );\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  let angle: Radians;\n  if (isFrameLikeElement(element)) {\n    angle = 0 as Radians;\n  } else {\n    angle = ((5 * Math.PI) / 2 +\n      Math.atan2(pointerY - cy, pointerX - cx)) as Radians;\n    if (shouldRotateWithDiscreteAngle) {\n      angle = (angle + SHIFT_LOCKING_ANGLE / 2) as Radians;\n      angle = (angle - (angle % SHIFT_LOCKING_ANGLE)) as Radians;\n    }\n    angle = normalizeRadians(angle as Radians);\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n\n  scene.mutateElement(element, { angle });\n  if (boundTextElementId) {\n    const textElement =\n      scene.getElement<ExcalidrawTextElementWithContainer>(boundTextElementId);\n\n    if (textElement && !isArrowElement(element)) {\n      scene.mutateElement(textElement, { angle });\n    }\n  }\n};\n\nexport const rescalePointsInElement = (\n  element: NonDeletedExcalidrawElement,\n  width: number,\n  height: number,\n  normalizePoints: boolean,\n) =>\n  isLinearElement(element) || isFreeDrawElement(element)\n    ? {\n        points: rescalePoints(\n          0,\n          width,\n          rescalePoints(1, height, element.points, normalizePoints),\n          normalizePoints,\n        ),\n      }\n    : {};\n\nexport const measureFontSizeFromWidth = (\n  element: NonDeleted<ExcalidrawTextElement>,\n  elementsMap: ElementsMap,\n  nextWidth: number,\n): { size: number } | null => {\n  // We only use width to scale font on resize\n  let width = element.width;\n\n  const hasContainer = isBoundToContainer(element);\n  if (hasContainer) {\n    const container = getContainerElement(element, elementsMap);\n    if (container) {\n      width = getBoundTextMaxWidth(container, element);\n    }\n  }\n  const nextFontSize = element.fontSize * (nextWidth / width);\n  if (nextFontSize < MIN_FONT_SIZE) {\n    return null;\n  }\n\n  return {\n    size: nextFontSize,\n  };\n};\n\nexport const resizeSingleTextElement = (\n  origElement: NonDeleted<ExcalidrawTextElement>,\n  element: NonDeleted<ExcalidrawTextElement>,\n  scene: Scene,\n  transformHandleType: TransformHandleDirection,\n  shouldResizeFromCenter: boolean,\n  nextWidth: number,\n  nextHeight: number,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  const metricsWidth = element.width * (nextHeight / element.height);\n\n  const metrics = measureFontSizeFromWidth(element, elementsMap, metricsWidth);\n  if (metrics === null) {\n    return;\n  }\n\n  if (transformHandleType.includes(\"n\") || transformHandleType.includes(\"s\")) {\n    const previousOrigin = pointFrom<GlobalPoint>(origElement.x, origElement.y);\n\n    const newOrigin = getResizedOrigin(\n      previousOrigin,\n      origElement.width,\n      origElement.height,\n      metricsWidth,\n      nextHeight,\n      origElement.angle,\n      transformHandleType,\n      false,\n      shouldResizeFromCenter,\n    );\n\n    scene.mutateElement(element, {\n      fontSize: metrics.size,\n      width: metricsWidth,\n      height: nextHeight,\n      x: newOrigin.x,\n      y: newOrigin.y,\n    });\n    return;\n  }\n\n  if (transformHandleType === \"e\" || transformHandleType === \"w\") {\n    const minWidth = getMinTextElementWidth(\n      getFontString({\n        fontSize: element.fontSize,\n        fontFamily: element.fontFamily,\n      }),\n      element.lineHeight,\n    );\n\n    const newWidth = Math.max(minWidth, nextWidth);\n\n    const text = wrapText(\n      element.originalText,\n      getFontString(element),\n      Math.abs(newWidth),\n    );\n    const metrics = measureText(\n      text,\n      getFontString(element),\n      element.lineHeight,\n    );\n\n    const newHeight = metrics.height;\n\n    const previousOrigin = pointFrom<GlobalPoint>(origElement.x, origElement.y);\n\n    const newOrigin = getResizedOrigin(\n      previousOrigin,\n      origElement.width,\n      origElement.height,\n      newWidth,\n      newHeight,\n      element.angle,\n      transformHandleType,\n      false,\n      shouldResizeFromCenter,\n    );\n\n    const resizedElement: Partial<ExcalidrawTextElement> = {\n      width: Math.abs(newWidth),\n      height: Math.abs(metrics.height),\n      x: newOrigin.x,\n      y: newOrigin.y,\n      text,\n      autoResize: false,\n    };\n\n    scene.mutateElement(element, resizedElement);\n  }\n};\n\nconst rotateMultipleElements = (\n  originalElements: PointerDownState[\"originalElements\"],\n  elements: readonly NonDeletedExcalidrawElement[],\n  scene: Scene,\n  pointerX: number,\n  pointerY: number,\n  shouldRotateWithDiscreteAngle: boolean,\n  centerX: number,\n  centerY: number,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  let centerAngle =\n    (5 * Math.PI) / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);\n  if (shouldRotateWithDiscreteAngle) {\n    centerAngle += SHIFT_LOCKING_ANGLE / 2;\n    centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;\n  }\n\n  for (const element of elements) {\n    if (!isFrameLikeElement(element)) {\n      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n      const cx = (x1 + x2) / 2;\n      const cy = (y1 + y2) / 2;\n      const origAngle =\n        originalElements.get(element.id)?.angle ?? element.angle;\n      const [rotatedCX, rotatedCY] = pointRotateRads(\n        pointFrom(cx, cy),\n        pointFrom(centerX, centerY),\n        (centerAngle + origAngle - element.angle) as Radians,\n      );\n\n      const updates = isElbowArrow(element)\n        ? {\n            // Needed to re-route the arrow\n            points: getArrowLocalFixedPoints(element, elementsMap),\n          }\n        : {\n            x: element.x + (rotatedCX - cx),\n            y: element.y + (rotatedCY - cy),\n            angle: normalizeRadians((centerAngle + origAngle) as Radians),\n          };\n\n      scene.mutateElement(element, updates);\n\n      updateBoundElements(element, scene, {\n        simultaneouslyUpdated: elements,\n      });\n\n      const boundText = getBoundTextElement(element, elementsMap);\n      if (boundText && !isArrowElement(element)) {\n        scene.mutateElement(boundText, {\n          x: boundText.x + (rotatedCX - cx),\n          y: boundText.y + (rotatedCY - cy),\n          angle: normalizeRadians((centerAngle + origAngle) as Radians),\n        });\n      }\n    }\n  }\n\n  scene.triggerUpdate();\n};\n\nexport const getResizeOffsetXY = (\n  transformHandleType: MaybeTransformHandleType,\n  selectedElements: NonDeletedExcalidrawElement[],\n  elementsMap: ElementsMap,\n  x: number,\n  y: number,\n): [number, number] => {\n  const [x1, y1, x2, y2] =\n    selectedElements.length === 1\n      ? getElementAbsoluteCoords(selectedElements[0], elementsMap)\n      : getCommonBounds(selectedElements);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const angle = (\n    selectedElements.length === 1 ? selectedElements[0].angle : 0\n  ) as Radians;\n  [x, y] = pointRotateRads(\n    pointFrom(x, y),\n    pointFrom(cx, cy),\n    -angle as Radians,\n  );\n  switch (transformHandleType) {\n    case \"n\":\n      return pointRotateRads(\n        pointFrom(x - (x1 + x2) / 2, y - y1),\n        pointFrom(0, 0),\n        angle,\n      );\n    case \"s\":\n      return pointRotateRads(\n        pointFrom(x - (x1 + x2) / 2, y - y2),\n        pointFrom(0, 0),\n        angle,\n      );\n    case \"w\":\n      return pointRotateRads(\n        pointFrom(x - x1, y - (y1 + y2) / 2),\n        pointFrom(0, 0),\n        angle,\n      );\n    case \"e\":\n      return pointRotateRads(\n        pointFrom(x - x2, y - (y1 + y2) / 2),\n        pointFrom(0, 0),\n        angle,\n      );\n    case \"nw\":\n      return pointRotateRads(pointFrom(x - x1, y - y1), pointFrom(0, 0), angle);\n    case \"ne\":\n      return pointRotateRads(pointFrom(x - x2, y - y1), pointFrom(0, 0), angle);\n    case \"sw\":\n      return pointRotateRads(pointFrom(x - x1, y - y2), pointFrom(0, 0), angle);\n    case \"se\":\n      return pointRotateRads(pointFrom(x - x2, y - y2), pointFrom(0, 0), angle);\n    default:\n      return [0, 0];\n  }\n};\n\nexport const getResizeArrowDirection = (\n  transformHandleType: MaybeTransformHandleType,\n  element: NonDeleted<ExcalidrawLinearElement>,\n): \"origin\" | \"end\" => {\n  const [, [px, py]] = element.points;\n  const isResizeEnd =\n    (transformHandleType === \"nw\" && (px < 0 || py < 0)) ||\n    (transformHandleType === \"ne\" && px >= 0) ||\n    (transformHandleType === \"sw\" && px <= 0) ||\n    (transformHandleType === \"se\" && (px > 0 || py > 0));\n  return isResizeEnd ? \"end\" : \"origin\";\n};\n\ntype ResizeAnchor =\n  | \"top-left\"\n  | \"top-right\"\n  | \"bottom-left\"\n  | \"bottom-right\"\n  | \"west-side\"\n  | \"north-side\"\n  | \"east-side\"\n  | \"south-side\"\n  | \"center\";\n\nconst getResizeAnchor = (\n  handleDirection: TransformHandleDirection,\n  shouldMaintainAspectRatio: boolean,\n  shouldResizeFromCenter: boolean,\n): ResizeAnchor => {\n  if (shouldResizeFromCenter) {\n    return \"center\";\n  }\n\n  if (shouldMaintainAspectRatio) {\n    switch (handleDirection) {\n      case \"n\":\n        return \"south-side\";\n      case \"e\": {\n        return \"west-side\";\n      }\n      case \"s\":\n        return \"north-side\";\n      case \"w\":\n        return \"east-side\";\n      case \"ne\":\n        return \"bottom-left\";\n      case \"nw\":\n        return \"bottom-right\";\n      case \"se\":\n        return \"top-left\";\n      case \"sw\":\n        return \"top-right\";\n    }\n  }\n\n  if ([\"e\", \"se\", \"s\"].includes(handleDirection)) {\n    return \"top-left\";\n  } else if ([\"n\", \"nw\", \"w\"].includes(handleDirection)) {\n    return \"bottom-right\";\n  } else if (handleDirection === \"ne\") {\n    return \"bottom-left\";\n  }\n  return \"top-right\";\n};\n\nconst getResizedOrigin = (\n  prevOrigin: GlobalPoint,\n  prevWidth: number,\n  prevHeight: number,\n  newWidth: number,\n  newHeight: number,\n  angle: number,\n  handleDirection: TransformHandleDirection,\n  shouldMaintainAspectRatio: boolean,\n  shouldResizeFromCenter: boolean,\n): { x: number; y: number } => {\n  const anchor = getResizeAnchor(\n    handleDirection,\n    shouldMaintainAspectRatio,\n    shouldResizeFromCenter,\n  );\n\n  const [x, y] = prevOrigin;\n\n  switch (anchor) {\n    case \"top-left\":\n      return {\n        x:\n          x +\n          (prevWidth - newWidth) / 2 +\n          ((newWidth - prevWidth) / 2) * Math.cos(angle) +\n          ((prevHeight - newHeight) / 2) * Math.sin(angle),\n        y:\n          y +\n          (prevHeight - newHeight) / 2 +\n          ((newWidth - prevWidth) / 2) * Math.sin(angle) +\n          ((newHeight - prevHeight) / 2) * Math.cos(angle),\n      };\n    case \"top-right\":\n      return {\n        x:\n          x +\n          ((prevWidth - newWidth) / 2) * (Math.cos(angle) + 1) +\n          ((prevHeight - newHeight) / 2) * Math.sin(angle),\n        y:\n          y +\n          (prevHeight - newHeight) / 2 +\n          ((prevWidth - newWidth) / 2) * Math.sin(angle) +\n          ((newHeight - prevHeight) / 2) * Math.cos(angle),\n      };\n\n    case \"bottom-left\":\n      return {\n        x:\n          x +\n          ((prevWidth - newWidth) / 2) * (1 - Math.cos(angle)) +\n          ((newHeight - prevHeight) / 2) * Math.sin(angle),\n        y:\n          y +\n          ((prevHeight - newHeight) / 2) * (Math.cos(angle) + 1) +\n          ((newWidth - prevWidth) / 2) * Math.sin(angle),\n      };\n    case \"bottom-right\":\n      return {\n        x:\n          x +\n          ((prevWidth - newWidth) / 2) * (Math.cos(angle) + 1) +\n          ((newHeight - prevHeight) / 2) * Math.sin(angle),\n        y:\n          y +\n          ((prevHeight - newHeight) / 2) * (Math.cos(angle) + 1) +\n          ((prevWidth - newWidth) / 2) * Math.sin(angle),\n      };\n    case \"center\":\n      return {\n        x: x - (newWidth - prevWidth) / 2,\n        y: y - (newHeight - prevHeight) / 2,\n      };\n    case \"east-side\":\n      return {\n        x: x + ((prevWidth - newWidth) / 2) * (Math.cos(angle) + 1),\n        y:\n          y +\n          ((prevWidth - newWidth) / 2) * Math.sin(angle) +\n          (prevHeight - newHeight) / 2,\n      };\n    case \"west-side\":\n      return {\n        x: x + ((prevWidth - newWidth) / 2) * (1 - Math.cos(angle)),\n        y:\n          y +\n          ((newWidth - prevWidth) / 2) * Math.sin(angle) +\n          (prevHeight - newHeight) / 2,\n      };\n    case \"north-side\":\n      return {\n        x:\n          x +\n          (prevWidth - newWidth) / 2 +\n          ((prevHeight - newHeight) / 2) * Math.sin(angle),\n        y: y + ((newHeight - prevHeight) / 2) * (Math.cos(angle) - 1),\n      };\n    case \"south-side\":\n      return {\n        x:\n          x +\n          (prevWidth - newWidth) / 2 +\n          ((newHeight - prevHeight) / 2) * Math.sin(angle),\n        y: y + ((prevHeight - newHeight) / 2) * (Math.cos(angle) + 1),\n      };\n  }\n};\n\nexport const resizeSingleElement = (\n  nextWidth: number,\n  nextHeight: number,\n  latestElement: ExcalidrawElement,\n  origElement: ExcalidrawElement,\n  originalElementsMap: ElementsMap,\n  scene: Scene,\n  handleDirection: TransformHandleDirection,\n  {\n    shouldInformMutation = true,\n    shouldMaintainAspectRatio = false,\n    shouldResizeFromCenter = false,\n  }: {\n    shouldMaintainAspectRatio?: boolean;\n    shouldResizeFromCenter?: boolean;\n    shouldInformMutation?: boolean;\n  } = {},\n) => {\n  if (isTextElement(latestElement) && isTextElement(origElement)) {\n    return resizeSingleTextElement(\n      origElement,\n      latestElement,\n      scene,\n      handleDirection,\n      shouldResizeFromCenter,\n      nextWidth,\n      nextHeight,\n    );\n  }\n\n  let boundTextFont: { fontSize?: number } = {};\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const boundTextElement = getBoundTextElement(latestElement, elementsMap);\n\n  if (boundTextElement) {\n    const stateOfBoundTextElementAtResize = originalElementsMap.get(\n      boundTextElement.id,\n    ) as typeof boundTextElement | undefined;\n    if (stateOfBoundTextElementAtResize) {\n      boundTextFont = {\n        fontSize: stateOfBoundTextElementAtResize.fontSize,\n      };\n    }\n    if (shouldMaintainAspectRatio) {\n      const updatedElement = {\n        ...latestElement,\n        width: nextWidth,\n        height: nextHeight,\n      };\n\n      const nextFont = measureFontSizeFromWidth(\n        boundTextElement,\n        elementsMap,\n        getBoundTextMaxWidth(updatedElement, boundTextElement),\n      );\n      if (nextFont === null) {\n        return;\n      }\n      boundTextFont = {\n        fontSize: nextFont.size,\n      };\n    } else {\n      const minWidth = getApproxMinLineWidth(\n        getFontString(boundTextElement),\n        boundTextElement.lineHeight,\n      );\n      const minHeight = getApproxMinLineHeight(\n        boundTextElement.fontSize,\n        boundTextElement.lineHeight,\n      );\n      nextWidth = Math.max(nextWidth, minWidth);\n      nextHeight = Math.max(nextHeight, minHeight);\n    }\n  }\n\n  const rescaledPoints = rescalePointsInElement(\n    origElement,\n    nextWidth,\n    nextHeight,\n    true,\n  );\n\n  let previousOrigin = pointFrom<GlobalPoint>(origElement.x, origElement.y);\n\n  if (isLinearElement(origElement)) {\n    const [x1, y1] = getElementBounds(origElement, originalElementsMap);\n    previousOrigin = pointFrom<GlobalPoint>(x1, y1);\n  }\n\n  const newOrigin: {\n    x: number;\n    y: number;\n  } = getResizedOrigin(\n    previousOrigin,\n    origElement.width,\n    origElement.height,\n    nextWidth,\n    nextHeight,\n    origElement.angle,\n    handleDirection,\n    shouldMaintainAspectRatio!!,\n    shouldResizeFromCenter!!,\n  );\n\n  if (isLinearElement(origElement) && rescaledPoints.points) {\n    const offsetX = origElement.x - previousOrigin[0];\n    const offsetY = origElement.y - previousOrigin[1];\n\n    newOrigin.x += offsetX;\n    newOrigin.y += offsetY;\n\n    const scaledX = rescaledPoints.points[0][0];\n    const scaledY = rescaledPoints.points[0][1];\n\n    newOrigin.x += scaledX;\n    newOrigin.y += scaledY;\n\n    rescaledPoints.points = rescaledPoints.points.map((p) =>\n      pointFrom<LocalPoint>(p[0] - scaledX, p[1] - scaledY),\n    );\n  }\n\n  // flipping\n  if (nextWidth < 0) {\n    newOrigin.x = newOrigin.x + nextWidth;\n  }\n  if (nextHeight < 0) {\n    newOrigin.y = newOrigin.y + nextHeight;\n  }\n\n  if (\"scale\" in latestElement && \"scale\" in origElement) {\n    scene.mutateElement(latestElement, {\n      scale: [\n        // defaulting because scaleX/Y can be 0/-0\n        (Math.sign(nextWidth) || origElement.scale[0]) * origElement.scale[0],\n        (Math.sign(nextHeight) || origElement.scale[1]) * origElement.scale[1],\n      ],\n    });\n  }\n\n  if (\n    isArrowElement(latestElement) &&\n    boundTextElement &&\n    shouldMaintainAspectRatio\n  ) {\n    const fontSize =\n      (nextWidth / latestElement.width) * boundTextElement.fontSize;\n    if (fontSize < MIN_FONT_SIZE) {\n      return;\n    }\n    boundTextFont.fontSize = fontSize;\n  }\n\n  if (\n    nextWidth !== 0 &&\n    nextHeight !== 0 &&\n    Number.isFinite(newOrigin.x) &&\n    Number.isFinite(newOrigin.y)\n  ) {\n    const updates = {\n      ...newOrigin,\n      width: Math.abs(nextWidth),\n      height: Math.abs(nextHeight),\n      ...rescaledPoints,\n    };\n\n    scene.mutateElement(latestElement, updates, {\n      informMutation: shouldInformMutation,\n      isDragging: false,\n    });\n\n    if (boundTextElement && boundTextFont != null) {\n      scene.mutateElement(boundTextElement, {\n        fontSize: boundTextFont.fontSize,\n      });\n    }\n    handleBindTextResize(\n      latestElement,\n      scene,\n      handleDirection,\n      shouldMaintainAspectRatio,\n    );\n\n    updateBoundElements(latestElement, scene, {\n      // TODO: confirm with MARK if this actually makes sense\n      newSize: { width: nextWidth, height: nextHeight },\n    });\n  }\n};\n\nconst getNextSingleWidthAndHeightFromPointer = (\n  latestElement: ExcalidrawElement,\n  origElement: ExcalidrawElement,\n  handleDirection: TransformHandleDirection,\n  pointerX: number,\n  pointerY: number,\n  {\n    shouldMaintainAspectRatio = false,\n    shouldResizeFromCenter = false,\n  }: {\n    shouldMaintainAspectRatio?: boolean;\n    shouldResizeFromCenter?: boolean;\n  } = {},\n) => {\n  // Gets bounds corners\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    origElement,\n    origElement.width,\n    origElement.height,\n    true,\n  );\n  const startTopLeft = pointFrom(x1, y1);\n  const startBottomRight = pointFrom(x2, y2);\n  const startCenter = pointCenter(startTopLeft, startBottomRight);\n\n  // Calculate new dimensions based on cursor position\n  const rotatedPointer = pointRotateRads(\n    pointFrom(pointerX, pointerY),\n    startCenter,\n    -origElement.angle as Radians,\n  );\n\n  // Get bounds corners rendered on screen\n  const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(\n    latestElement,\n    latestElement.width,\n    latestElement.height,\n    true,\n  );\n\n  const boundsCurrentWidth = esx2 - esx1;\n  const boundsCurrentHeight = esy2 - esy1;\n\n  // It's important we set the initial scale value based on the width and height at resize start,\n  // otherwise previous dimensions affected by modifiers will be taken into account.\n  const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];\n  const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];\n  let scaleX = atStartBoundsWidth / boundsCurrentWidth;\n  let scaleY = atStartBoundsHeight / boundsCurrentHeight;\n\n  if (handleDirection.includes(\"e\")) {\n    scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;\n  }\n  if (handleDirection.includes(\"s\")) {\n    scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;\n  }\n  if (handleDirection.includes(\"w\")) {\n    scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;\n  }\n  if (handleDirection.includes(\"n\")) {\n    scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;\n  }\n\n  // We have to use dimensions of element on screen, otherwise the scaling of the\n  // dimensions won't match the cursor for linear elements.\n  let nextWidth = latestElement.width * scaleX;\n  let nextHeight = latestElement.height * scaleY;\n\n  if (shouldResizeFromCenter) {\n    nextWidth = 2 * nextWidth - origElement.width;\n    nextHeight = 2 * nextHeight - origElement.height;\n  }\n\n  // adjust dimensions to keep sides ratio\n  if (shouldMaintainAspectRatio) {\n    const widthRatio = Math.abs(nextWidth) / origElement.width;\n    const heightRatio = Math.abs(nextHeight) / origElement.height;\n    if (handleDirection.length === 1) {\n      nextHeight *= widthRatio;\n      nextWidth *= heightRatio;\n    }\n    if (handleDirection.length === 2) {\n      const ratio = Math.max(widthRatio, heightRatio);\n      nextWidth = origElement.width * ratio * Math.sign(nextWidth);\n      nextHeight = origElement.height * ratio * Math.sign(nextHeight);\n    }\n  }\n\n  return {\n    nextWidth,\n    nextHeight,\n  };\n};\n\nconst getNextMultipleWidthAndHeightFromPointer = (\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  originalElementsMap: ElementsMap,\n  elementsMap: ElementsMap,\n  handleDirection: TransformHandleDirection,\n  pointerX: number,\n  pointerY: number,\n  {\n    shouldMaintainAspectRatio = false,\n    shouldResizeFromCenter = false,\n  }: {\n    shouldResizeFromCenter?: boolean;\n    shouldMaintainAspectRatio?: boolean;\n  } = {},\n) => {\n  const originalElementsArray = selectedElements.map(\n    (el) => originalElementsMap.get(el.id)!,\n  );\n\n  // getCommonBoundingBox() uses getBoundTextElement() which returns null for\n  // original elements from pointerDownState, so we have to find and add these\n  // bound text elements manually. Additionally, the coordinates of bound text\n  // elements aren't always up to date.\n  const boundTextElements = originalElementsArray.reduce((acc, orig) => {\n    if (!isLinearElement(orig)) {\n      return acc;\n    }\n    const textId = getBoundTextElementId(orig);\n    if (!textId) {\n      return acc;\n    }\n    const text = originalElementsMap.get(textId) ?? null;\n    if (!isBoundToContainer(text)) {\n      return acc;\n    }\n    return [\n      ...acc,\n      {\n        ...text,\n        ...LinearElementEditor.getBoundTextElementPosition(\n          orig,\n          text,\n          elementsMap,\n        ),\n      },\n    ];\n  }, [] as ExcalidrawTextElementWithContainer[]);\n\n  const originalBoundingBox = getCommonBoundingBox(\n    originalElementsArray.map((orig) => orig).concat(boundTextElements),\n  );\n\n  const { minX, minY, maxX, maxY, midX, midY } = originalBoundingBox;\n  const width = maxX - minX;\n  const height = maxY - minY;\n\n  const anchorsMap = {\n    ne: [minX, maxY],\n    se: [minX, minY],\n    sw: [maxX, minY],\n    nw: [maxX, maxY],\n    e: [minX, minY + height / 2],\n    w: [maxX, minY + height / 2],\n    n: [minX + width / 2, maxY],\n    s: [minX + width / 2, minY],\n  } as Record<TransformHandleDirection, GlobalPoint>;\n\n  // anchor point must be on the opposite side of the dragged selection handle\n  // or be the center of the selection if shouldResizeFromCenter\n  const [anchorX, anchorY] = shouldResizeFromCenter\n    ? [midX, midY]\n    : anchorsMap[handleDirection];\n\n  const resizeFromCenterScale = shouldResizeFromCenter ? 2 : 1;\n\n  const scale =\n    Math.max(\n      Math.abs(pointerX - anchorX) / width || 0,\n      Math.abs(pointerY - anchorY) / height || 0,\n    ) * resizeFromCenterScale;\n\n  let nextWidth =\n    handleDirection.includes(\"e\") || handleDirection.includes(\"w\")\n      ? Math.abs(pointerX - anchorX) * resizeFromCenterScale\n      : width;\n  let nextHeight =\n    handleDirection.includes(\"n\") || handleDirection.includes(\"s\")\n      ? Math.abs(pointerY - anchorY) * resizeFromCenterScale\n      : height;\n\n  if (shouldMaintainAspectRatio) {\n    nextWidth = width * scale * Math.sign(pointerX - anchorX);\n    nextHeight = height * scale * Math.sign(pointerY - anchorY);\n  }\n\n  const flipConditionsMap: Record<\n    TransformHandleDirection,\n    // Condition for which we should flip or not flip the selected elements\n    // - when evaluated to `true`, we flip\n    // - therefore, setting it to always `false` means we do not flip (in that direction) at all\n    [x: boolean, y: boolean]\n  > = {\n    ne: [pointerX < anchorX, pointerY > anchorY],\n    se: [pointerX < anchorX, pointerY < anchorY],\n    sw: [pointerX > anchorX, pointerY < anchorY],\n    nw: [pointerX > anchorX, pointerY > anchorY],\n    // e.g. when resizing from the \"e\" side, we do not need to consider changes in the `y` direction\n    //      and therefore, we do not need to flip in the `y` direction at all\n    e: [pointerX < anchorX, false],\n    w: [pointerX > anchorX, false],\n    n: [false, pointerY > anchorY],\n    s: [false, pointerY < anchorY],\n  };\n\n  const [flipByX, flipByY] = flipConditionsMap[handleDirection].map(\n    (condition) => condition,\n  );\n\n  return {\n    originalBoundingBox,\n    nextWidth,\n    nextHeight,\n    flipByX,\n    flipByY,\n  };\n};\n\nexport const resizeMultipleElements = (\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  elementsMap: ElementsMap,\n  handleDirection: TransformHandleDirection,\n  scene: Scene,\n  originalElementsMap: ElementsMap,\n  {\n    shouldMaintainAspectRatio = false,\n    shouldResizeFromCenter = false,\n    flipByX = false,\n    flipByY = false,\n    nextHeight,\n    nextWidth,\n    originalBoundingBox,\n  }: {\n    nextWidth?: number;\n    nextHeight?: number;\n    shouldMaintainAspectRatio?: boolean;\n    shouldResizeFromCenter?: boolean;\n    flipByX?: boolean;\n    flipByY?: boolean;\n    // added to improve performance\n    originalBoundingBox?: BoundingBox;\n  } = {},\n) => {\n  // in the case of just flipping, there is no need to specify the next width and height\n  if (\n    nextWidth === undefined &&\n    nextHeight === undefined &&\n    flipByX === undefined &&\n    flipByY === undefined\n  ) {\n    return;\n  }\n\n  // do not allow next width or height to be 0\n  if (nextHeight === 0 || nextWidth === 0) {\n    return;\n  }\n\n  if (!originalElementsMap) {\n    originalElementsMap = elementsMap;\n  }\n\n  const targetElements = selectedElements.reduce(\n    (\n      acc: {\n        /** element at resize start */\n        orig: NonDeletedExcalidrawElement;\n        /** latest element */\n        latest: NonDeletedExcalidrawElement;\n      }[],\n      element,\n    ) => {\n      const origElement = originalElementsMap!.get(element.id);\n      if (origElement) {\n        acc.push({ orig: origElement, latest: element });\n      }\n      return acc;\n    },\n    [],\n  );\n\n  let boundingBox: BoundingBox;\n\n  if (originalBoundingBox) {\n    boundingBox = originalBoundingBox;\n  } else {\n    const boundTextElements = targetElements.reduce((acc, { orig }) => {\n      if (!isLinearElement(orig)) {\n        return acc;\n      }\n      const textId = getBoundTextElementId(orig);\n      if (!textId) {\n        return acc;\n      }\n      const text = originalElementsMap!.get(textId) ?? null;\n      if (!isBoundToContainer(text)) {\n        return acc;\n      }\n      return [\n        ...acc,\n        {\n          ...text,\n          ...LinearElementEditor.getBoundTextElementPosition(\n            orig,\n            text,\n            elementsMap,\n          ),\n        },\n      ];\n    }, [] as ExcalidrawTextElementWithContainer[]);\n\n    boundingBox = getCommonBoundingBox(\n      targetElements.map(({ orig }) => orig).concat(boundTextElements),\n    );\n  }\n  const { minX, minY, maxX, maxY, midX, midY } = boundingBox;\n  const width = maxX - minX;\n  const height = maxY - minY;\n\n  if (nextWidth === undefined && nextHeight === undefined) {\n    nextWidth = width;\n    nextHeight = height;\n  }\n\n  if (shouldMaintainAspectRatio) {\n    if (nextWidth === undefined) {\n      nextWidth = nextHeight! * (width / height);\n    } else if (nextHeight === undefined) {\n      nextHeight = nextWidth! * (height / width);\n    } else if (Math.abs(nextWidth / nextHeight - width / height) > 0.001) {\n      nextWidth = nextHeight * (width / height);\n    }\n  }\n\n  if (nextWidth && nextHeight) {\n    let scaleX =\n      handleDirection.includes(\"e\") || handleDirection.includes(\"w\")\n        ? Math.abs(nextWidth) / width\n        : 1;\n    let scaleY =\n      handleDirection.includes(\"n\") || handleDirection.includes(\"s\")\n        ? Math.abs(nextHeight) / height\n        : 1;\n\n    let scale: number;\n\n    if (handleDirection.length === 1) {\n      scale =\n        handleDirection.includes(\"e\") || handleDirection.includes(\"w\")\n          ? scaleX\n          : scaleY;\n    } else {\n      scale = Math.max(\n        Math.abs(nextWidth) / width || 0,\n        Math.abs(nextHeight) / height || 0,\n      );\n    }\n\n    const anchorsMap = {\n      ne: [minX, maxY],\n      se: [minX, minY],\n      sw: [maxX, minY],\n      nw: [maxX, maxY],\n      e: [minX, minY + height / 2],\n      w: [maxX, minY + height / 2],\n      n: [minX + width / 2, maxY],\n      s: [minX + width / 2, minY],\n    } as Record<TransformHandleDirection, GlobalPoint>;\n\n    // anchor point must be on the opposite side of the dragged selection handle\n    // or be the center of the selection if shouldResizeFromCenter\n    const [anchorX, anchorY] = shouldResizeFromCenter\n      ? [midX, midY]\n      : anchorsMap[handleDirection];\n\n    const keepAspectRatio =\n      shouldMaintainAspectRatio ||\n      targetElements.some(\n        (item) =>\n          item.latest.angle !== 0 ||\n          isTextElement(item.latest) ||\n          isInGroup(item.latest),\n      );\n\n    if (keepAspectRatio) {\n      scaleX = scale;\n      scaleY = scale;\n    }\n\n    /**\n     * to flip an element:\n     * 1. determine over which axis is the element being flipped\n     *    (could be x, y, or both) indicated by `flipFactorX` & `flipFactorY`\n     * 2. shift element's position by the amount of width or height (or both) or\n     *    mirror points in the case of linear & freedraw elemenets\n     * 3. adjust element angle\n     */\n    const [flipFactorX, flipFactorY] = [flipByX ? -1 : 1, flipByY ? -1 : 1];\n\n    const elementsAndUpdates: {\n      element: NonDeletedExcalidrawElement;\n      update: Mutable<\n        Pick<ExcalidrawElement, \"x\" | \"y\" | \"width\" | \"height\" | \"angle\">\n      > & {\n        points?: ExcalidrawLinearElement[\"points\"];\n        fontSize?: ExcalidrawTextElement[\"fontSize\"];\n        scale?: ExcalidrawImageElement[\"scale\"];\n        boundTextFontSize?: ExcalidrawTextElement[\"fontSize\"];\n        startBinding?: ExcalidrawElbowArrowElement[\"startBinding\"];\n        endBinding?: ExcalidrawElbowArrowElement[\"endBinding\"];\n        fixedSegments?: ExcalidrawElbowArrowElement[\"fixedSegments\"];\n      };\n    }[] = [];\n\n    for (const { orig, latest } of targetElements) {\n      // bounded text elements are updated along with their container elements\n      if (isTextElement(orig) && isBoundToContainer(orig)) {\n        continue;\n      }\n\n      const width = orig.width * scaleX;\n      const height = orig.height * scaleY;\n      const angle = normalizeRadians(\n        (orig.angle * flipFactorX * flipFactorY) as Radians,\n      );\n\n      const isLinearOrFreeDraw =\n        isLinearElement(orig) || isFreeDrawElement(orig);\n      const offsetX = orig.x - anchorX;\n      const offsetY = orig.y - anchorY;\n      const shiftX = flipByX && !isLinearOrFreeDraw ? width : 0;\n      const shiftY = flipByY && !isLinearOrFreeDraw ? height : 0;\n      const x = anchorX + flipFactorX * (offsetX * scaleX + shiftX);\n      const y = anchorY + flipFactorY * (offsetY * scaleY + shiftY);\n\n      const rescaledPoints = rescalePointsInElement(\n        orig,\n        width * flipFactorX,\n        height * flipFactorY,\n        false,\n      );\n\n      const update: typeof elementsAndUpdates[0][\"update\"] = {\n        x,\n        y,\n        width,\n        height,\n        angle,\n        ...rescaledPoints,\n      };\n\n      if (isElbowArrow(orig)) {\n        // Mirror fixed point binding for elbow arrows\n        // when resize goes into the negative direction\n        if (orig.startBinding) {\n          update.startBinding = {\n            ...orig.startBinding,\n            fixedPoint: [\n              flipByX\n                ? -orig.startBinding.fixedPoint[0] + 1\n                : orig.startBinding.fixedPoint[0],\n              flipByY\n                ? -orig.startBinding.fixedPoint[1] + 1\n                : orig.startBinding.fixedPoint[1],\n            ],\n          };\n        }\n        if (orig.endBinding) {\n          update.endBinding = {\n            ...orig.endBinding,\n            fixedPoint: [\n              flipByX\n                ? -orig.endBinding.fixedPoint[0] + 1\n                : orig.endBinding.fixedPoint[0],\n              flipByY\n                ? -orig.endBinding.fixedPoint[1] + 1\n                : orig.endBinding.fixedPoint[1],\n            ],\n          };\n        }\n        if (orig.fixedSegments && rescaledPoints.points) {\n          update.fixedSegments = orig.fixedSegments.map((segment) => ({\n            ...segment,\n            start: rescaledPoints.points[segment.index - 1],\n            end: rescaledPoints.points[segment.index],\n          }));\n        }\n      }\n\n      if (isImageElement(orig)) {\n        update.scale = [\n          orig.scale[0] * flipFactorX,\n          orig.scale[1] * flipFactorY,\n        ];\n      }\n\n      if (isTextElement(orig)) {\n        const metrics = measureFontSizeFromWidth(orig, elementsMap, width);\n        if (!metrics) {\n          return;\n        }\n        update.fontSize = metrics.size;\n      }\n\n      const boundTextElement = originalElementsMap.get(\n        getBoundTextElementId(orig) ?? \"\",\n      ) as ExcalidrawTextElementWithContainer | undefined;\n\n      if (boundTextElement) {\n        if (keepAspectRatio) {\n          const newFontSize = boundTextElement.fontSize * scale;\n          if (newFontSize < MIN_FONT_SIZE) {\n            return;\n          }\n          update.boundTextFontSize = newFontSize;\n        } else {\n          update.boundTextFontSize = boundTextElement.fontSize;\n        }\n      }\n\n      elementsAndUpdates.push({\n        element: latest,\n        update,\n      });\n    }\n\n    const elementsToUpdate = elementsAndUpdates.map(({ element }) => element);\n\n    for (const {\n      element,\n      update: { boundTextFontSize, ...update },\n    } of elementsAndUpdates) {\n      const { width, height, angle } = update;\n\n      scene.mutateElement(element, update);\n\n      updateBoundElements(element, scene, {\n        simultaneouslyUpdated: elementsToUpdate,\n        newSize: { width, height },\n      });\n\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n      if (boundTextElement && boundTextFontSize) {\n        scene.mutateElement(boundTextElement, {\n          fontSize: boundTextFontSize,\n          angle: isLinearElement(element) ? undefined : angle,\n        });\n        handleBindTextResize(element, scene, handleDirection, true);\n      }\n    }\n\n    scene.triggerUpdate();\n  }\n};\n",
    "import {\n  pointFrom,\n  pointOnLineSegment,\n  pointRotateRads,\n  type Radians,\n} from \"@excalidraw/math\";\n\nimport { SIDE_RESIZING_THRESHOLD } from \"@excalidraw/common\";\n\nimport type { GlobalPoint, LineSegment, LocalPoint } from \"@excalidraw/math\";\n\nimport type { AppState, Device, Zoom } from \"excalidraw-custom/types\";\n\nimport { getElementAbsoluteCoords } from \"./bounds\";\nimport {\n  getTransformHandlesFromCoords,\n  getTransformHandles,\n  getOmitSidesForDevice,\n  canResizeFromSides,\n} from \"./transformHandles\";\nimport { isImageElement, isLinearElement } from \"./typeChecks\";\n\nimport type { Bounds } from \"./bounds\";\nimport type {\n  TransformHandleType,\n  TransformHandle,\n  MaybeTransformHandleType,\n} from \"./transformHandles\";\nimport type {\n  ExcalidrawElement,\n  PointerType,\n  NonDeletedExcalidrawElement,\n  ElementsMap,\n} from \"./types\";\n\nconst isInsideTransformHandle = (\n  transformHandle: TransformHandle,\n  x: number,\n  y: number,\n) =>\n  x >= transformHandle[0] &&\n  x <= transformHandle[0] + transformHandle[2] &&\n  y >= transformHandle[1] &&\n  y <= transformHandle[1] + transformHandle[3];\n\nexport const resizeTest = <Point extends GlobalPoint | LocalPoint>(\n  element: NonDeletedExcalidrawElement,\n  elementsMap: ElementsMap,\n  appState: AppState,\n  x: number,\n  y: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  device: Device,\n): MaybeTransformHandleType => {\n  if (!appState.selectedElementIds[element.id]) {\n    return false;\n  }\n\n  const { rotation: rotationTransformHandle, ...transformHandles } =\n    getTransformHandles(\n      element,\n      zoom,\n      elementsMap,\n      pointerType,\n      getOmitSidesForDevice(device),\n    );\n\n  if (\n    rotationTransformHandle &&\n    isInsideTransformHandle(rotationTransformHandle, x, y)\n  ) {\n    return \"rotation\" as TransformHandleType;\n  }\n\n  const filter = Object.keys(transformHandles).filter((key) => {\n    const transformHandle =\n      transformHandles[key as Exclude<TransformHandleType, \"rotation\">]!;\n    if (!transformHandle) {\n      return false;\n    }\n    return isInsideTransformHandle(transformHandle, x, y);\n  });\n\n  if (filter.length > 0) {\n    return filter[0] as TransformHandleType;\n  }\n\n  if (canResizeFromSides(device)) {\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n      element,\n      elementsMap,\n    );\n\n    // do not resize from the sides for linear elements with only two points\n    if (!(isLinearElement(element) && element.points.length <= 2)) {\n      const SPACING = isImageElement(element)\n        ? 0\n        : SIDE_RESIZING_THRESHOLD / zoom.value;\n      const ZOOMED_SIDE_RESIZING_THRESHOLD =\n        SIDE_RESIZING_THRESHOLD / zoom.value;\n      const sides = getSelectionBorders(\n        pointFrom(x1 - SPACING, y1 - SPACING),\n        pointFrom(x2 + SPACING, y2 + SPACING),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n\n      for (const [dir, side] of Object.entries(sides)) {\n        // test to see if x, y are on the line segment\n        if (\n          pointOnLineSegment(\n            pointFrom(x, y),\n            side as LineSegment<Point>,\n            ZOOMED_SIDE_RESIZING_THRESHOLD,\n          )\n        ) {\n          return dir as TransformHandleType;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n\nexport const getElementWithTransformHandleType = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  scenePointerX: number,\n  scenePointerY: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  elementsMap: ElementsMap,\n  device: Device,\n) => {\n  return elements.reduce((result, element) => {\n    if (result) {\n      return result;\n    }\n    const transformHandleType = resizeTest(\n      element,\n      elementsMap,\n      appState,\n      scenePointerX,\n      scenePointerY,\n      zoom,\n      pointerType,\n      device,\n    );\n    return transformHandleType ? { element, transformHandleType } : null;\n  }, null as { element: NonDeletedExcalidrawElement; transformHandleType: MaybeTransformHandleType } | null);\n};\n\nexport const getTransformHandleTypeFromCoords = <\n  Point extends GlobalPoint | LocalPoint,\n>(\n  [x1, y1, x2, y2]: Bounds,\n  scenePointerX: number,\n  scenePointerY: number,\n  zoom: Zoom,\n  pointerType: PointerType,\n  device: Device,\n): MaybeTransformHandleType => {\n  const transformHandles = getTransformHandlesFromCoords(\n    [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2],\n    0 as Radians,\n    zoom,\n    pointerType,\n    getOmitSidesForDevice(device),\n  );\n\n  const found = Object.keys(transformHandles).find((key) => {\n    const transformHandle =\n      transformHandles[key as Exclude<TransformHandleType, \"rotation\">]!;\n    return (\n      transformHandle &&\n      isInsideTransformHandle(transformHandle, scenePointerX, scenePointerY)\n    );\n  });\n\n  if (found) {\n    return found as MaybeTransformHandleType;\n  }\n\n  if (canResizeFromSides(device)) {\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const SPACING = SIDE_RESIZING_THRESHOLD / zoom.value;\n\n    const sides = getSelectionBorders(\n      pointFrom(x1 - SPACING, y1 - SPACING),\n      pointFrom(x2 + SPACING, y2 + SPACING),\n      pointFrom(cx, cy),\n      0 as Radians,\n    );\n\n    for (const [dir, side] of Object.entries(sides)) {\n      // test to see if x, y are on the line segment\n      if (\n        pointOnLineSegment(\n          pointFrom(scenePointerX, scenePointerY),\n          side as LineSegment<Point>,\n          SPACING,\n        )\n      ) {\n        return dir as TransformHandleType;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst RESIZE_CURSORS = [\"ns\", \"nesw\", \"ew\", \"nwse\"];\nconst rotateResizeCursor = (cursor: string, angle: number) => {\n  const index = RESIZE_CURSORS.indexOf(cursor);\n  if (index >= 0) {\n    const a = Math.round(angle / (Math.PI / 4));\n    cursor = RESIZE_CURSORS[(index + a) % RESIZE_CURSORS.length];\n  }\n  return cursor;\n};\n\n/*\n * Returns bi-directional cursor for the element being resized\n */\nexport const getCursorForResizingElement = (resizingElement: {\n  element?: ExcalidrawElement;\n  transformHandleType: MaybeTransformHandleType;\n}): string => {\n  const { element, transformHandleType } = resizingElement;\n  const shouldSwapCursors =\n    element && Math.sign(element.height) * Math.sign(element.width) === -1;\n  let cursor = null;\n\n  switch (transformHandleType) {\n    case \"n\":\n    case \"s\":\n      cursor = \"ns\";\n      break;\n    case \"w\":\n    case \"e\":\n      cursor = \"ew\";\n      break;\n    case \"nw\":\n    case \"se\":\n      if (shouldSwapCursors) {\n        cursor = \"nesw\";\n      } else {\n        cursor = \"nwse\";\n      }\n      break;\n    case \"ne\":\n    case \"sw\":\n      if (shouldSwapCursors) {\n        cursor = \"nwse\";\n      } else {\n        cursor = \"nesw\";\n      }\n      break;\n    case \"rotation\":\n      return \"grab\";\n  }\n\n  if (cursor && element) {\n    cursor = rotateResizeCursor(cursor, element.angle);\n  }\n\n  return cursor ? `${cursor}-resize` : \"\";\n};\n\nconst getSelectionBorders = <Point extends LocalPoint | GlobalPoint>(\n  [x1, y1]: Point,\n  [x2, y2]: Point,\n  center: Point,\n  angle: Radians,\n) => {\n  const topLeft = pointRotateRads(pointFrom(x1, y1), center, angle);\n  const topRight = pointRotateRads(pointFrom(x2, y1), center, angle);\n  const bottomLeft = pointRotateRads(pointFrom(x1, y2), center, angle);\n  const bottomRight = pointRotateRads(pointFrom(x2, y2), center, angle);\n\n  return {\n    n: [topLeft, topRight],\n    e: [topRight, bottomRight],\n    s: [bottomRight, bottomLeft],\n    w: [bottomLeft, topLeft],\n  };\n};\n",
    "import {\n  DEFAULT_TRANSFORM_HANDLE_SPACING,\n  isAndroid,\n  isIOS,\n} from \"@excalidraw/common\";\n\nimport { pointFrom, pointRotateRads } from \"@excalidraw/math\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type {\n  Device,\n  InteractiveCanvasAppState,\n  Zoom,\n} from \"excalidraw-custom/types\";\n\nimport { getElementAbsoluteCoords } from \"./bounds\";\nimport {\n  isElbowArrow,\n  isFrameLikeElement,\n  isImageElement,\n  isLinearElement,\n} from \"./typeChecks\";\n\nimport type { Bounds } from \"./bounds\";\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  PointerType,\n} from \"./types\";\n\nexport type TransformHandleDirection =\n  | \"n\"\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"nw\"\n  | \"ne\"\n  | \"sw\"\n  | \"se\";\n\nexport type TransformHandleType = TransformHandleDirection | \"rotation\";\n\nexport type TransformHandle = Bounds;\nexport type TransformHandles = Partial<{\n  [T in TransformHandleType]: TransformHandle;\n}>;\nexport type MaybeTransformHandleType = TransformHandleType | false;\n\nconst transformHandleSizes: { [k in PointerType]: number } = {\n  mouse: 8,\n  pen: 16,\n  touch: 28,\n};\n\nconst ROTATION_RESIZE_HANDLE_GAP = 16;\n\nexport const DEFAULT_OMIT_SIDES = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nexport const OMIT_SIDES_FOR_FRAME = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  rotation: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_SLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  nw: true,\n  se: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_BACKSLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst generateTransformHandle = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: Radians,\n): TransformHandle => {\n  const [xx, yy] = pointRotateRads(\n    pointFrom(x + width / 2, y + height / 2),\n    pointFrom(cx, cy),\n    angle,\n  );\n  return [xx - width / 2, yy - height / 2, width, height];\n};\n\nexport const canResizeFromSides = (device: Device) => {\n  if (device.viewport.isMobile) {\n    return false;\n  }\n\n  if (device.isTouchScreen && (isAndroid || isIOS)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport const getOmitSidesForDevice = (device: Device) => {\n  if (canResizeFromSides(device)) {\n    return DEFAULT_OMIT_SIDES;\n  }\n\n  return {};\n};\n\nexport const getTransformHandlesFromCoords = (\n  [x1, y1, x2, y2, cx, cy]: [number, number, number, number, number, number],\n  angle: Radians,\n  zoom: Zoom,\n  pointerType: PointerType,\n  omitSides: { [T in TransformHandleType]?: boolean } = {},\n  margin = 4,\n  spacing = DEFAULT_TRANSFORM_HANDLE_SPACING,\n): TransformHandles => {\n  const size = transformHandleSizes[pointerType];\n  const handleWidth = size / zoom.value;\n  const handleHeight = size / zoom.value;\n\n  const handleMarginX = size / zoom.value;\n  const handleMarginY = size / zoom.value;\n\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const dashedLineMargin = margin / zoom.value;\n  const centeringOffset = (size - spacing * 2) / (2 * zoom.value);\n\n  const transformHandles: TransformHandles = {\n    nw: omitSides.nw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    ne: omitSides.ne\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y1 - dashedLineMargin - handleMarginY + centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    sw: omitSides.sw\n      ? undefined\n      : generateTransformHandle(\n          x1 - dashedLineMargin - handleMarginX + centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    se: omitSides.se\n      ? undefined\n      : generateTransformHandle(\n          x2 + dashedLineMargin - centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    rotation: omitSides.rotation\n      ? undefined\n      : generateTransformHandle(\n          x1 + width / 2 - handleWidth / 2,\n          y1 -\n            dashedLineMargin -\n            handleMarginY +\n            centeringOffset -\n            ROTATION_RESIZE_HANDLE_GAP / zoom.value,\n          handleWidth,\n          handleHeight,\n          cx,\n          cy,\n          angle,\n        ),\n  };\n\n  // We only want to show height handles (all cardinal directions)  above a certain size\n  // Note: we render using \"mouse\" size so we should also use \"mouse\" size for this check\n  const minimumSizeForEightHandles =\n    (5 * transformHandleSizes.mouse) / zoom.value;\n  if (Math.abs(width) > minimumSizeForEightHandles) {\n    if (!omitSides.n) {\n      transformHandles.n = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y1 - dashedLineMargin - handleMarginY + centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.s) {\n      transformHandles.s = generateTransformHandle(\n        x1 + width / 2 - handleWidth / 2,\n        y2 + dashedLineMargin - centeringOffset,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n  if (Math.abs(height) > minimumSizeForEightHandles) {\n    if (!omitSides.w) {\n      transformHandles.w = generateTransformHandle(\n        x1 - dashedLineMargin - handleMarginX + centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides.e) {\n      transformHandles.e = generateTransformHandle(\n        x2 + dashedLineMargin - centeringOffset,\n        y1 + height / 2 - handleHeight / 2,\n        handleWidth,\n        handleHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n\n  return transformHandles;\n};\n\nexport const getTransformHandles = (\n  element: ExcalidrawElement,\n  zoom: Zoom,\n  elementsMap: ElementsMap,\n  pointerType: PointerType = \"mouse\",\n  omitSides: { [T in TransformHandleType]?: boolean } = DEFAULT_OMIT_SIDES,\n): TransformHandles => {\n  // so that when locked element is selected (especially when you toggle lock\n  // via keyboard) the locked element is visually distinct, indicating\n  // you can't move/resize\n  if (\n    element.locked ||\n    // Elbow arrows cannot be rotated\n    isElbowArrow(element)\n  ) {\n    return {};\n  }\n\n  if (element.type === \"freedraw\" || isLinearElement(element)) {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n      if (p1[0] === 0 || p1[1] === 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] > 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] > 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] < 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] < 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      }\n    }\n  } else if (isFrameLikeElement(element)) {\n    omitSides = {\n      ...omitSides,\n      rotation: true,\n    };\n  }\n  const margin = isLinearElement(element)\n    ? DEFAULT_TRANSFORM_HANDLE_SPACING + 8\n    : isImageElement(element)\n    ? 0\n    : DEFAULT_TRANSFORM_HANDLE_SPACING;\n  return getTransformHandlesFromCoords(\n    getElementAbsoluteCoords(element, elementsMap, true),\n    element.angle,\n    zoom,\n    pointerType,\n    omitSides,\n    margin,\n    isImageElement(element) ? 0 : undefined,\n  );\n};\n\nexport const shouldShowBoundingBox = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: InteractiveCanvasAppState,\n) => {\n  if (appState.editingLinearElement) {\n    return false;\n  }\n  if (elements.length > 1) {\n    return true;\n  }\n  const element = elements[0];\n  if (isElbowArrow(element)) {\n    // Elbow arrows cannot be resized as single selected elements\n    return false;\n  }\n  if (!isLinearElement(element)) {\n    return true;\n  }\n\n  return element.points.length > 2;\n};\n",
    "import type { UIAppState } from \"excalidraw-custom/types\";\n\nimport { getSelectedElements } from \"./selection\";\n\nimport type { NonDeletedExcalidrawElement } from \"./types\";\n\nexport const showSelectedShapeActions = (\n  appState: UIAppState,\n  elements: readonly NonDeletedExcalidrawElement[],\n) =>\n  Boolean(\n    !appState.viewModeEnabled &&\n      appState.openDialog?.name !== \"elementLinkSelector\" &&\n      ((appState.activeTool.type !== \"custom\" &&\n        (appState.editingTextElement ||\n          (appState.activeTool.type !== \"selection\" &&\n            appState.activeTool.type !== \"lasso\" &&\n            appState.activeTool.type !== \"eraser\" &&\n            appState.activeTool.type !== \"hand\" &&\n            appState.activeTool.type !== \"laser\"))) ||\n        getSelectedElements(elements, appState).length),\n  );\n",
    "import { arrayToMap, findIndex, findLastIndex } from \"@excalidraw/common\";\n\nimport type { AppState } from \"excalidraw-custom/types\";\n\nimport { isFrameLikeElement } from \"./typeChecks\";\n\nimport { getElementsInGroup } from \"./groups\";\n\nimport { syncMovedIndices } from \"./fractionalIndex\";\n\nimport { getSelectedElements } from \"./selection\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { ExcalidrawElement, ExcalidrawFrameLikeElement } from \"./types\";\n\nconst isOfTargetFrame = (element: ExcalidrawElement, frameId: string) => {\n  return element.frameId === frameId || element.id === frameId;\n};\n\n/**\n * Returns indices of elements to move based on selected elements.\n * Includes contiguous deleted elements that are between two selected elements,\n *  e.g.: [0 (selected), 1 (deleted), 2 (deleted), 3 (selected)]\n *\n * Specified elements (elementsToBeMoved) take precedence over\n * appState.selectedElementsIds\n */\nconst getIndicesToMove = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  let selectedIndices: number[] = [];\n  let deletedIndices: number[] = [];\n  let includeDeletedIndex = null;\n  let index = -1;\n  const selectedElementIds = arrayToMap(\n    elementsToBeMoved\n      ? elementsToBeMoved\n      : getSelectedElements(elements, appState, {\n          includeBoundTextElement: true,\n          includeElementsInFrames: true,\n        }),\n  );\n  while (++index < elements.length) {\n    const element = elements[index];\n    if (selectedElementIds.get(element.id)) {\n      if (deletedIndices.length) {\n        selectedIndices = selectedIndices.concat(deletedIndices);\n        deletedIndices = [];\n      }\n      selectedIndices.push(index);\n      includeDeletedIndex = index + 1;\n    } else if (element.isDeleted && includeDeletedIndex === index) {\n      includeDeletedIndex = index + 1;\n      deletedIndices.push(index);\n    } else {\n      deletedIndices = [];\n    }\n  }\n  return selectedIndices;\n};\n\nconst toContiguousGroups = (array: number[]) => {\n  let cursor = 0;\n  return array.reduce((acc, value, index) => {\n    if (index > 0 && array[index - 1] !== value - 1) {\n      cursor = ++cursor;\n    }\n    (acc[cursor] || (acc[cursor] = [])).push(value);\n    return acc;\n  }, [] as number[][]);\n};\n\n/**\n * @returns index of target element, consindering tightly-bound elements\n * (currently non-linear elements bound to a container) as a one unit.\n * If no binding present, returns `undefined`.\n */\nconst getTargetIndexAccountingForBinding = (\n  nextElement: ExcalidrawElement,\n  elements: readonly ExcalidrawElement[],\n  direction: \"left\" | \"right\",\n  scene: Scene,\n) => {\n  if (\"containerId\" in nextElement && nextElement.containerId) {\n    // TODO: why not to get the container from the nextElements?\n    const containerElement = scene.getElement(nextElement.containerId);\n    if (containerElement) {\n      return direction === \"left\"\n        ? Math.min(\n            elements.indexOf(containerElement),\n            elements.indexOf(nextElement),\n          )\n        : Math.max(\n            elements.indexOf(containerElement),\n            elements.indexOf(nextElement),\n          );\n    }\n  } else {\n    const boundElementId = nextElement.boundElements?.find(\n      (binding) => binding.type !== \"arrow\",\n    )?.id;\n    if (boundElementId) {\n      const boundTextElement = scene.getElement(boundElementId);\n      if (boundTextElement) {\n        return direction === \"left\"\n          ? Math.min(\n              elements.indexOf(boundTextElement),\n              elements.indexOf(nextElement),\n            )\n          : Math.max(\n              elements.indexOf(boundTextElement),\n              elements.indexOf(nextElement),\n            );\n      }\n    }\n  }\n};\n\nconst getContiguousFrameRangeElements = (\n  allElements: readonly ExcalidrawElement[],\n  frameId: ExcalidrawFrameLikeElement[\"id\"],\n) => {\n  let rangeStart = -1;\n  let rangeEnd = -1;\n  allElements.forEach((element, index) => {\n    if (isOfTargetFrame(element, frameId)) {\n      if (rangeStart === -1) {\n        rangeStart = index;\n      }\n      rangeEnd = index;\n    }\n  });\n  if (rangeStart === -1) {\n    return [];\n  }\n  return allElements.slice(rangeStart, rangeEnd + 1);\n};\n\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\nconst getTargetIndex = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n  boundaryIndex: number,\n  direction: \"left\" | \"right\",\n  /**\n   * Frame id if moving frame children.\n   * If whole frame (including all children) is being moved, supply `null`.\n   */\n  containingFrame: ExcalidrawFrameLikeElement[\"id\"] | null,\n  scene: Scene,\n) => {\n  const sourceElement = elements[boundaryIndex];\n\n  const indexFilter = (element: ExcalidrawElement) => {\n    if (element.isDeleted) {\n      return false;\n    }\n    if (containingFrame) {\n      return element.frameId === containingFrame;\n    }\n    // if we're editing group, find closest sibling irrespective of whether\n    // there's a different-group element between them (for legacy reasons)\n    if (appState.editingGroupId) {\n      return element.groupIds.includes(appState.editingGroupId);\n    }\n    return true;\n  };\n\n  const candidateIndex =\n    direction === \"left\"\n      ? findLastIndex(\n          elements,\n          (el) => indexFilter(el),\n          Math.max(0, boundaryIndex - 1),\n        )\n      : findIndex(elements, (el) => indexFilter(el), boundaryIndex + 1);\n\n  const nextElement = elements[candidateIndex];\n\n  if (!nextElement) {\n    return -1;\n  }\n\n  if (appState.editingGroupId) {\n    if (\n      // candidate element is a sibling in current editing group → return\n      sourceElement?.groupIds.join(\"\") === nextElement?.groupIds.join(\"\")\n    ) {\n      return (\n        getTargetIndexAccountingForBinding(\n          nextElement,\n          elements,\n          direction,\n          scene,\n        ) ?? candidateIndex\n      );\n    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {\n      // candidate element is outside current editing group → prevent\n      return -1;\n    }\n  }\n\n  if (\n    !containingFrame &&\n    (nextElement.frameId || isFrameLikeElement(nextElement))\n  ) {\n    const frameElements = getContiguousFrameRangeElements(\n      elements,\n      nextElement.frameId || nextElement.id,\n    );\n    return direction === \"left\"\n      ? elements.indexOf(frameElements[0])\n      : elements.indexOf(frameElements[frameElements.length - 1]);\n  }\n\n  if (!nextElement.groupIds.length) {\n    return (\n      getTargetIndexAccountingForBinding(\n        nextElement,\n        elements,\n        direction,\n        scene,\n      ) ?? candidateIndex\n    );\n  }\n\n  const siblingGroupId = appState.editingGroupId\n    ? nextElement.groupIds[\n        nextElement.groupIds.indexOf(appState.editingGroupId) - 1\n      ]\n    : nextElement.groupIds[nextElement.groupIds.length - 1];\n\n  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);\n\n  if (elementsInSiblingGroup.length) {\n    // assumes getElementsInGroup() returned elements are sorted\n    // by zIndex (ascending)\n    return direction === \"left\"\n      ? elements.indexOf(elementsInSiblingGroup[0])\n      : elements.indexOf(\n          elementsInSiblingGroup[elementsInSiblingGroup.length - 1],\n        );\n  }\n\n  return candidateIndex;\n};\n\nconst getTargetElementsMap = <T extends ExcalidrawElement>(\n  elements: readonly T[],\n  indices: number[],\n) => {\n  return indices.reduce((acc, index) => {\n    const element = elements[index];\n    acc.set(element.id, element);\n    return acc;\n  }, new Map<string, ExcalidrawElement>());\n};\n\nconst shiftElementsByOne = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  scene: Scene,\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n\n  let groupedIndices = toContiguousGroups(indicesToMove);\n\n  if (direction === \"right\") {\n    groupedIndices = groupedIndices.reverse();\n  }\n\n  const selectedFrames = new Set<ExcalidrawFrameLikeElement[\"id\"]>(\n    indicesToMove\n      .filter((idx) => isFrameLikeElement(elements[idx]))\n      .map((idx) => elements[idx].id),\n  );\n\n  groupedIndices.forEach((indices, i) => {\n    const leadingIndex = indices[0];\n    const trailingIndex = indices[indices.length - 1];\n    const boundaryIndex = direction === \"left\" ? leadingIndex : trailingIndex;\n\n    const containingFrame = indices.some((idx) => {\n      const el = elements[idx];\n      return el.frameId && selectedFrames.has(el.frameId);\n    })\n      ? null\n      : elements[boundaryIndex]?.frameId;\n\n    const targetIndex = getTargetIndex(\n      appState,\n      elements,\n      boundaryIndex,\n      direction,\n      containingFrame,\n      scene,\n    );\n\n    if (targetIndex === -1 || boundaryIndex === targetIndex) {\n      return;\n    }\n\n    const leadingElements =\n      direction === \"left\"\n        ? elements.slice(0, targetIndex)\n        : elements.slice(0, leadingIndex);\n    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);\n    const displacedElements =\n      direction === \"left\"\n        ? elements.slice(targetIndex, leadingIndex)\n        : elements.slice(trailingIndex + 1, targetIndex + 1);\n    const trailingElements =\n      direction === \"left\"\n        ? elements.slice(trailingIndex + 1)\n        : elements.slice(targetIndex + 1);\n\n    elements =\n      direction === \"left\"\n        ? [\n            ...leadingElements,\n            ...targetElements,\n            ...displacedElements,\n            ...trailingElements,\n          ]\n        : [\n            ...leadingElements,\n            ...displacedElements,\n            ...targetElements,\n            ...trailingElements,\n          ];\n  });\n\n  syncMovedIndices(elements, targetElementsMap);\n\n  return elements;\n};\n\nconst shiftElementsToEnd = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  containingFrame: ExcalidrawFrameLikeElement[\"id\"] | null,\n  elementsToBeMoved?: readonly ExcalidrawElement[],\n) => {\n  const indicesToMove = getIndicesToMove(elements, appState, elementsToBeMoved);\n  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);\n  const displacedElements: ExcalidrawElement[] = [];\n\n  let leadingIndex: number;\n  let trailingIndex: number;\n  if (direction === \"left\") {\n    if (containingFrame) {\n      leadingIndex = findIndex(elements, (el) =>\n        isOfTargetFrame(el, containingFrame),\n      );\n    } else if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      leadingIndex = elements.indexOf(groupElements[0]);\n    } else {\n      leadingIndex = 0;\n    }\n\n    trailingIndex = indicesToMove[indicesToMove.length - 1];\n  } else {\n    if (containingFrame) {\n      trailingIndex = findLastIndex(elements, (el) =>\n        isOfTargetFrame(el, containingFrame),\n      );\n    } else if (appState.editingGroupId) {\n      const groupElements = getElementsInGroup(\n        elements,\n        appState.editingGroupId,\n      );\n      if (!groupElements.length) {\n        return elements;\n      }\n      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);\n    } else {\n      trailingIndex = elements.length - 1;\n    }\n\n    leadingIndex = indicesToMove[0];\n  }\n\n  if (leadingIndex === -1) {\n    leadingIndex = 0;\n  }\n\n  for (let index = leadingIndex; index < trailingIndex + 1; index++) {\n    if (!indicesToMove.includes(index)) {\n      displacedElements.push(elements[index]);\n    }\n  }\n\n  const targetElements = Array.from(targetElementsMap.values());\n  const leadingElements = elements.slice(0, leadingIndex);\n  const trailingElements = elements.slice(trailingIndex + 1);\n  const nextElements =\n    direction === \"left\"\n      ? [\n          ...leadingElements,\n          ...targetElements,\n          ...displacedElements,\n          ...trailingElements,\n        ]\n      : [\n          ...leadingElements,\n          ...displacedElements,\n          ...targetElements,\n          ...trailingElements,\n        ];\n\n  syncMovedIndices(nextElements, targetElementsMap);\n\n  return nextElements;\n};\n\nfunction shiftElementsAccountingForFrames(\n  allElements: readonly ExcalidrawElement[],\n  appState: AppState,\n  direction: \"left\" | \"right\",\n  shiftFunction: (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState,\n    direction: \"left\" | \"right\",\n    containingFrame: ExcalidrawFrameLikeElement[\"id\"] | null,\n    elementsToBeMoved?: readonly ExcalidrawElement[],\n  ) => ExcalidrawElement[] | readonly ExcalidrawElement[],\n) {\n  const elementsToMove = arrayToMap(\n    getSelectedElements(allElements, appState, {\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    }),\n  );\n\n  const frameAwareContiguousElementsToMove: {\n    regularElements: ExcalidrawElement[];\n    frameChildren: Map<ExcalidrawFrameLikeElement[\"id\"], ExcalidrawElement[]>;\n  } = { regularElements: [], frameChildren: new Map() };\n\n  const fullySelectedFrames = new Set<ExcalidrawFrameLikeElement[\"id\"]>();\n\n  for (const element of allElements) {\n    if (elementsToMove.has(element.id) && isFrameLikeElement(element)) {\n      fullySelectedFrames.add(element.id);\n    }\n  }\n\n  for (const element of allElements) {\n    if (elementsToMove.has(element.id)) {\n      if (\n        isFrameLikeElement(element) ||\n        (element.frameId && fullySelectedFrames.has(element.frameId))\n      ) {\n        frameAwareContiguousElementsToMove.regularElements.push(element);\n      } else if (!element.frameId) {\n        frameAwareContiguousElementsToMove.regularElements.push(element);\n      } else {\n        const frameChildren =\n          frameAwareContiguousElementsToMove.frameChildren.get(\n            element.frameId,\n          ) || [];\n        frameChildren.push(element);\n        frameAwareContiguousElementsToMove.frameChildren.set(\n          element.frameId,\n          frameChildren,\n        );\n      }\n    }\n  }\n\n  let nextElements = allElements;\n\n  const frameChildrenSets = Array.from(\n    frameAwareContiguousElementsToMove.frameChildren.entries(),\n  );\n\n  for (const [frameId, children] of frameChildrenSets) {\n    nextElements = shiftFunction(\n      allElements,\n      appState,\n      direction,\n      frameId,\n      children,\n    );\n  }\n\n  return shiftFunction(\n    nextElements,\n    appState,\n    direction,\n    null,\n    frameAwareContiguousElementsToMove.regularElements,\n  );\n}\n\n// public API\n// -----------------------------------------------------------------------------\n\nexport const moveOneLeft = (\n  allElements: readonly ExcalidrawElement[],\n  appState: AppState,\n  scene: Scene,\n) => {\n  return shiftElementsByOne(allElements, appState, \"left\", scene);\n};\n\nexport const moveOneRight = (\n  allElements: readonly ExcalidrawElement[],\n  appState: AppState,\n  scene: Scene,\n) => {\n  return shiftElementsByOne(allElements, appState, \"right\", scene);\n};\n\nexport const moveAllLeft = (\n  allElements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsAccountingForFrames(\n    allElements,\n    appState,\n    \"left\",\n    shiftElementsToEnd,\n  );\n};\n\nexport const moveAllRight = (\n  allElements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  return shiftElementsAccountingForFrames(\n    allElements,\n    appState,\n    \"right\",\n    shiftElementsToEnd,\n  );\n};\n"
  ],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,uCAAC,KAAM,KAAI;AAAA;AAAA;;;ACAX;AAAA;AAAA;AAUA,QAAI,kBAAkB;AAGtB,QAAI,MAAM,IAAI;AAGd,QAAI,YAAY;AAGhB,QAAI,SAAS;AAGb,QAAI,aAAa;AAGjB,QAAI,aAAa;AAGjB,QAAI,YAAY;AAGhB,QAAI,eAAe;AAGnB,QAAI,aAAa,OAAO,UAAU,YAAY,UAAU,OAAO,WAAW,UAAU;AAGpF,QAAI,WAAW,OAAO,QAAQ,YAAY,QAAQ,KAAK,WAAW,UAAU;AAG5E,QAAI,OAAO,cAAc,YAAY,SAAS,aAAa,EAAE;AAG7D,QAAI,cAAc,OAAO;AAOzB,QAAI,iBAAiB,YAAY;AAGjC,QAAI,YAAY,KAAK;AAArB,QACI,YAAY,KAAK;AAkBrB,QAAI,MAAM,WAAW;AACnB,aAAO,KAAK,KAAK,IAAI;AAAA,IACvB;AAwDA,aAAS,SAAS,MAAM,MAAM,SAAS;AACrC,UAAI,UACA,UACA,SACA,QACA,SACA,cACA,iBAAiB,GACjB,UAAU,OACV,SAAS,OACT,WAAW;AAEf,UAAI,OAAO,QAAQ,YAAY;AAC7B,cAAM,IAAI,UAAU,eAAe;AAAA,MACrC;AACA,aAAO,SAAS,IAAI,KAAK;AACzB,UAAI,SAAS,OAAO,GAAG;AACrB,kBAAU,CAAC,CAAC,QAAQ;AACpB,iBAAS,aAAa;AACtB,kBAAU,SAAS,UAAU,SAAS,QAAQ,OAAO,KAAK,GAAG,IAAI,IAAI;AACrE,mBAAW,cAAc,UAAU,CAAC,CAAC,QAAQ,WAAW;AAAA,MAC1D;AAEA,eAAS,WAAW,MAAM;AACxB,YAAI,OAAO,UACP,UAAU;AAEd,mBAAW,WAAW;AACtB,yBAAiB;AACjB,iBAAS,KAAK,MAAM,SAAS,IAAI;AACjC,eAAO;AAAA,MACT;AAEA,eAAS,YAAY,MAAM;AAEzB,yBAAiB;AAEjB,kBAAU,WAAW,cAAc,IAAI;AAEvC,eAAO,UAAU,WAAW,IAAI,IAAI;AAAA,MACtC;AAEA,eAAS,cAAc,MAAM;AAC3B,YAAI,oBAAoB,OAAO,cAC3B,sBAAsB,OAAO,gBAC7BA,UAAS,OAAO;AAEpB,eAAO,SAAS,UAAUA,SAAQ,UAAU,mBAAmB,IAAIA;AAAA,MACrE;AAEA,eAAS,aAAa,MAAM;AAC1B,YAAI,oBAAoB,OAAO,cAC3B,sBAAsB,OAAO;AAKjC,eAAQ,iBAAiB,UAAc,qBAAqB,QACzD,oBAAoB,KAAO,UAAU,uBAAuB;AAAA,MACjE;AAEA,eAAS,eAAe;AACtB,YAAI,OAAO,IAAI;AACf,YAAI,aAAa,IAAI,GAAG;AACtB,iBAAO,aAAa,IAAI;AAAA,QAC1B;AAEA,kBAAU,WAAW,cAAc,cAAc,IAAI,CAAC;AAAA,MACxD;AAEA,eAAS,aAAa,MAAM;AAC1B,kBAAU;AAIV,YAAI,YAAY,UAAU;AACxB,iBAAO,WAAW,IAAI;AAAA,QACxB;AACA,mBAAW,WAAW;AACtB,eAAO;AAAA,MACT;AAEA,eAAS,SAAS;AAChB,YAAI,YAAY,QAAW;AACzB,uBAAa,OAAO;AAAA,QACtB;AACA,yBAAiB;AACjB,mBAAW,eAAe,WAAW,UAAU;AAAA,MACjD;AAEA,eAAS,QAAQ;AACf,eAAO,YAAY,SAAY,SAAS,aAAa,IAAI,CAAC;AAAA,MAC5D;AAEA,eAAS,YAAY;AACnB,YAAI,OAAO,IAAI,GACX,aAAa,aAAa,IAAI;AAElC,mBAAW;AACX,mBAAW;AACX,uBAAe;AAEf,YAAI,YAAY;AACd,cAAI,YAAY,QAAW;AACzB,mBAAO,YAAY,YAAY;AAAA,UACjC;AACA,cAAI,QAAQ;AAEV,sBAAU,WAAW,cAAc,IAAI;AACvC,mBAAO,WAAW,YAAY;AAAA,UAChC;AAAA,QACF;AACA,YAAI,YAAY,QAAW;AACzB,oBAAU,WAAW,cAAc,IAAI;AAAA,QACzC;AACA,eAAO;AAAA,MACT;AACA,gBAAU,SAAS;AACnB,gBAAU,QAAQ;AAClB,aAAO;AAAA,IACT;AA8CA,aAASC,UAAS,MAAM,MAAM,SAAS;AACrC,UAAI,UAAU,MACV,WAAW;AAEf,UAAI,OAAO,QAAQ,YAAY;AAC7B,cAAM,IAAI,UAAU,eAAe;AAAA,MACrC;AACA,UAAI,SAAS,OAAO,GAAG;AACrB,kBAAU,aAAa,UAAU,CAAC,CAAC,QAAQ,UAAU;AACrD,mBAAW,cAAc,UAAU,CAAC,CAAC,QAAQ,WAAW;AAAA,MAC1D;AACA,aAAO,SAAS,MAAM,MAAM;AAAA,QAC1B,WAAW;AAAA,QACX,WAAW;AAAA,QACX,YAAY;AAAA,MACd,CAAC;AAAA,IACH;AA2BA,aAAS,SAAS,OAAO;AACvB,UAAI,OAAO,OAAO;AAClB,aAAO,CAAC,CAAC,UAAU,QAAQ,YAAY,QAAQ;AAAA,IACjD;AA0BA,aAAS,aAAa,OAAO;AAC3B,aAAO,CAAC,CAAC,SAAS,OAAO,SAAS;AAAA,IACpC;AAmBA,aAAS,SAAS,OAAO;AACvB,aAAO,OAAO,SAAS,YACpB,aAAa,KAAK,KAAK,eAAe,KAAK,KAAK,KAAK;AAAA,IAC1D;AAyBA,aAAS,SAAS,OAAO;AACvB,UAAI,OAAO,SAAS,UAAU;AAC5B,eAAO;AAAA,MACT;AACA,UAAI,SAAS,KAAK,GAAG;AACnB,eAAO;AAAA,MACT;AACA,UAAI,SAAS,KAAK,GAAG;AACnB,YAAI,QAAQ,OAAO,MAAM,WAAW,aAAa,MAAM,QAAQ,IAAI;AACnE,gBAAQ,SAAS,KAAK,IAAK,QAAQ,KAAM;AAAA,MAC3C;AACA,UAAI,OAAO,SAAS,UAAU;AAC5B,eAAO,UAAU,IAAI,QAAQ,CAAC;AAAA,MAChC;AACA,cAAQ,MAAM,QAAQ,QAAQ,EAAE;AAChC,UAAI,WAAW,WAAW,KAAK,KAAK;AACpC,aAAQ,YAAY,UAAU,KAAK,KAAK,IACpC,aAAa,MAAM,MAAM,CAAC,GAAG,WAAW,IAAI,CAAC,IAC5C,WAAW,KAAK,KAAK,IAAI,MAAM,CAAC;AAAA,IACvC;AAEA,WAAO,UAAUA;AAAA;AAAA;;;ACtbjB;AAAA,SAAS,cAAAC,mBAAkB;;;ACA3B;AAAA;AAAA,EACE;AAAA,EACA,+BAAAC;AAAA,OACK;AACP;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OAEK;AAEP,SAAS,eAAAC,oBAAmB;;;ACX5B;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;AAAA,SAAS,aAAa,QAAQ,QAAQ,SAAS;AAC3C,MAAI,UAAU,OAAO,QAAQ;AACzB,UAAM,CAAC,IAAI,EAAE,IAAI;AACjB,UAAM,QAAS,KAAK,KAAK,MAAO;AAChC,UAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,UAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,eAAW,KAAK,QAAQ;AACpB,YAAM,CAAC,GAAG,CAAC,IAAI;AACf,QAAE,CAAC,KAAM,IAAI,MAAM,OAAS,IAAI,MAAM,MAAO;AAC7C,QAAE,CAAC,KAAM,IAAI,MAAM,OAAS,IAAI,MAAM,MAAO;AAAA,IACjD;AAAA,EACJ;AACJ;AACA,SAAS,YAAY,OAAO,QAAQ,SAAS;AACzC,QAAM,SAAS,CAAC;AAChB,QAAM,QAAQ,CAACC,UAAS,OAAO,KAAK,GAAGA,KAAI,CAAC;AAC5C,eAAa,QAAQ,QAAQ,OAAO;AACxC;AACA,SAAS,cAAc,IAAI,IAAI;AAC3B,SAAO,GAAG,CAAC,MAAM,GAAG,CAAC,KAAK,GAAG,CAAC,MAAM,GAAG,CAAC;AAC5C;AACO,SAAS,aAAa,UAAU,YAAY,cAAc,oBAAoB,GAAG;AACpF,QAAM,QAAQ;AACd,QAAM,MAAM,KAAK,IAAI,YAAY,GAAG;AACpC,QAAM,cAAe,SAAS,CAAC,KAAK,SAAS,CAAC,EAAE,CAAC,KAAM,OAAO,SAAS,CAAC,EAAE,CAAC,MAAM,WAAa,CAAC,QAAQ,IAAI;AAC3G,QAAM,iBAAiB,CAAC,GAAG,CAAC;AAC5B,MAAI,OAAO;AACP,eAAWC,YAAW,aAAa;AAC/B,mBAAaA,UAAS,gBAAgB,KAAK;AAAA,IAC/C;AAAA,EACJ;AACA,QAAM,QAAQ,qBAAqB,aAAa,KAAK,iBAAiB;AACtE,MAAI,OAAO;AACP,eAAWA,YAAW,aAAa;AAC/B,mBAAaA,UAAS,gBAAgB,CAAC,KAAK;AAAA,IAChD;AACA,gBAAY,OAAO,gBAAgB,CAAC,KAAK;AAAA,EAC7C;AACA,SAAO;AACX;AACA,SAAS,qBAAqB,UAAU,KAAK,mBAAmB;AAC5D,QAAM,cAAc,CAAC;AACrB,aAAWA,YAAW,UAAU;AAC5B,UAAM,WAAW,CAAC,GAAGA,QAAO;AAC5B,QAAI,CAAC,cAAc,SAAS,CAAC,GAAG,SAAS,SAAS,SAAS,CAAC,CAAC,GAAG;AAC5D,eAAS,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC;AAAA,IAClD;AACA,QAAI,SAAS,SAAS,GAAG;AACrB,kBAAY,KAAK,QAAQ;AAAA,IAC7B;AAAA,EACJ;AACA,QAAM,QAAQ,CAAC;AACf,QAAM,KAAK,IAAI,KAAK,GAAG;AAEvB,QAAM,QAAQ,CAAC;AACf,aAAW,YAAY,aAAa;AAChC,aAAS,IAAI,GAAG,IAAI,SAAS,SAAS,GAAG,KAAK;AAC1C,YAAM,KAAK,SAAS,CAAC;AACrB,YAAM,KAAK,SAAS,IAAI,CAAC;AACzB,UAAI,GAAG,CAAC,MAAM,GAAG,CAAC,GAAG;AACjB,cAAM,OAAO,KAAK,IAAI,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAClC,cAAM,KAAK;AAAA,UACP;AAAA,UACA,MAAM,KAAK,IAAI,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAAA,UAC3B,GAAG,SAAS,GAAG,CAAC,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC;AAAA,UAChC,SAAS,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC;AAAA,QAC3C,CAAC;AAAA,MACL;AAAA,IACJ;AAAA,EACJ;AACA,QAAM,KAAK,CAAC,IAAI,OAAO;AACnB,QAAI,GAAG,OAAO,GAAG,MAAM;AACnB,aAAO;AAAA,IACX;AACA,QAAI,GAAG,OAAO,GAAG,MAAM;AACnB,aAAO;AAAA,IACX;AACA,QAAI,GAAG,IAAI,GAAG,GAAG;AACb,aAAO;AAAA,IACX;AACA,QAAI,GAAG,IAAI,GAAG,GAAG;AACb,aAAO;AAAA,IACX;AACA,QAAI,GAAG,SAAS,GAAG,MAAM;AACrB,aAAO;AAAA,IACX;AACA,YAAQ,GAAG,OAAO,GAAG,QAAQ,KAAK,IAAK,GAAG,OAAO,GAAG,IAAK;AAAA,EAC7D,CAAC;AACD,MAAI,CAAC,MAAM,QAAQ;AACf,WAAO;AAAA,EACX;AAEA,MAAI,cAAc,CAAC;AACnB,MAAI,IAAI,MAAM,CAAC,EAAE;AACjB,MAAI,YAAY;AAChB,SAAO,YAAY,UAAU,MAAM,QAAQ;AACvC,QAAI,MAAM,QAAQ;AACd,UAAI,KAAK;AACT,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,YAAI,MAAM,CAAC,EAAE,OAAO,GAAG;AACnB;AAAA,QACJ;AACA,aAAK;AAAA,MACT;AACA,YAAM,UAAU,MAAM,OAAO,GAAG,KAAK,CAAC;AACtC,cAAQ,QAAQ,CAAC,SAAS;AACtB,oBAAY,KAAK,EAAE,GAAG,GAAG,KAAK,CAAC;AAAA,MACnC,CAAC;AAAA,IACL;AACA,kBAAc,YAAY,OAAO,CAACC,QAAO;AACrC,UAAIA,IAAG,KAAK,QAAQ,GAAG;AACnB,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX,CAAC;AACD,gBAAY,KAAK,CAAC,KAAK,QAAQ;AAC3B,UAAI,IAAI,KAAK,MAAM,IAAI,KAAK,GAAG;AAC3B,eAAO;AAAA,MACX;AACA,cAAQ,IAAI,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAK,IAAI,KAAK,IAAI,IAAI,KAAK,CAAE;AAAA,IACzE,CAAC;AAED,QAAK,sBAAsB,KAAO,YAAY,QAAQ,GAAI;AACtD,UAAI,YAAY,SAAS,GAAG;AACxB,iBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,IAAI,IAAI,GAAG;AAC/C,gBAAM,QAAQ,IAAI;AAClB,cAAI,SAAS,YAAY,QAAQ;AAC7B;AAAA,UACJ;AACA,gBAAMC,MAAK,YAAY,CAAC,EAAE;AAC1B,gBAAM,KAAK,YAAY,KAAK,EAAE;AAC9B,gBAAM,KAAK;AAAA,YACP,CAAC,KAAK,MAAMA,IAAG,CAAC,GAAG,CAAC;AAAA,YACpB,CAAC,KAAK,MAAM,GAAG,CAAC,GAAG,CAAC;AAAA,UACxB,CAAC;AAAA,QACL;AAAA,MACJ;AAAA,IACJ;AACA,SAAK;AACL,gBAAY,QAAQ,CAACD,QAAO;AACxB,MAAAA,IAAG,KAAK,IAAIA,IAAG,KAAK,IAAK,oBAAoBA,IAAG,KAAK;AAAA,IACzD,CAAC;AACD;AAAA,EACJ;AACA,SAAO;AACX;;;ADhJO,SAAS,oBAAoB,aAAa,GAAG;AAChD,MAAI;AACJ,QAAM,QAAQ,EAAE,eAAe;AAC/B,MAAI,MAAM,EAAE;AACZ,MAAI,MAAM,GAAG;AACT,UAAM,EAAE,cAAc;AAAA,EAC1B;AACA,QAAM,KAAK,IAAI,KAAK,GAAG;AACvB,MAAI,aAAa;AACjB,MAAI,EAAE,aAAa,GAAG;AAClB,WAAO,KAAK,EAAE,gBAAgB,QAAQ,OAAO,SAAS,SAAS,GAAG,KAAK,MAAM,KAAK,OAAO,KAAK,KAAK;AAC/F,mBAAa;AAAA,IACjB;AAAA,EACJ;AACA,SAAO,aAAa,aAAa,KAAK,OAAO,cAAc,CAAC;AAChE;;;ADfO,IAAM,gBAAN,MAAoB;AAAA,EACvB,YAAYE,SAAQ;AAChB,SAAK,SAASA;AAAA,EAClB;AAAA,EACA,aAAa,aAAa,GAAG;AACzB,WAAO,KAAK,cAAc,aAAa,CAAC;AAAA,EAC5C;AAAA,EACA,cAAc,aAAa,GAAG;AAC1B,UAAM,QAAQ,oBAAoB,aAAa,CAAC;AAChD,UAAM,MAAM,KAAK,YAAY,OAAO,CAAC;AACrC,WAAO,EAAE,MAAM,cAAc,IAAI;AAAA,EACrC;AAAA,EACA,YAAY,OAAO,GAAG;AAClB,UAAM,MAAM,CAAC;AACb,eAAWC,SAAQ,OAAO;AACtB,UAAI,KAAK,GAAG,KAAK,OAAO,cAAcA,MAAK,CAAC,EAAE,CAAC,GAAGA,MAAK,CAAC,EAAE,CAAC,GAAGA,MAAK,CAAC,EAAE,CAAC,GAAGA,MAAK,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;AAAA,IAC5F;AACA,WAAO;AAAA,EACX;AACJ;;;AGpBA;;;ACAA;AAAO,SAAS,WAAWC,OAAM;AAC7B,QAAM,KAAKA,MAAK,CAAC;AACjB,QAAM,KAAKA,MAAK,CAAC;AACjB,SAAO,KAAK,KAAK,KAAK,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;AAC5E;;;ADDO,IAAM,eAAN,cAA2B,cAAc;AAAA,EAC5C,aAAa,aAAa,GAAG;AACzB,QAAI,MAAM,EAAE;AACZ,QAAI,MAAM,GAAG;AACT,YAAM,EAAE,cAAc;AAAA,IAC1B;AACA,UAAM,KAAK,IAAI,KAAK,GAAG;AACvB,UAAM,KAAK,OAAO,OAAO,CAAC,GAAG,GAAG,EAAE,YAAY,IAAI,CAAC;AACnD,UAAM,QAAQ,oBAAoB,aAAa,EAAE;AACjD,UAAM,cAAe,KAAK,KAAK,MAAO,EAAE;AACxC,UAAM,cAAc,CAAC;AACrB,UAAM,MAAM,MAAM,MAAM,KAAK,IAAI,WAAW;AAC5C,UAAM,MAAM,MAAM,MAAM,KAAK,IAAI,WAAW;AAC5C,eAAW,CAAC,IAAI,EAAE,KAAK,OAAO;AAC1B,UAAI,WAAW,CAAC,IAAI,EAAE,CAAC,GAAG;AACtB,oBAAY,KAAK;AAAA,UACb,CAAC,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,GAAG;AAAA,UACzB,CAAC,GAAG,EAAE;AAAA,QACV,GAAG;AAAA,UACC,CAAC,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,GAAG;AAAA,UACzB,CAAC,GAAG,EAAE;AAAA,QACV,CAAC;AAAA,MACL;AAAA,IACJ;AACA,UAAM,MAAM,KAAK,YAAY,aAAa,CAAC;AAC3C,WAAO,EAAE,MAAM,cAAc,IAAI;AAAA,EACrC;AACJ;;;AE9BA;AACO,IAAM,cAAN,cAA0B,cAAc;AAAA,EAC3C,aAAa,aAAa,GAAG;AACzB,UAAM,MAAM,KAAK,cAAc,aAAa,CAAC;AAC7C,UAAM,KAAK,OAAO,OAAO,CAAC,GAAG,GAAG,EAAE,cAAc,EAAE,eAAe,GAAG,CAAC;AACrE,UAAM,OAAO,KAAK,cAAc,aAAa,EAAE;AAC/C,QAAI,MAAM,IAAI,IAAI,OAAO,KAAK,GAAG;AACjC,WAAO;AAAA,EACX;AACJ;;;ACTA;AAEO,IAAM,YAAN,MAAgB;AAAA,EACnB,YAAYC,SAAQ;AAChB,SAAK,SAASA;AAAA,EAClB;AAAA,EACA,aAAa,aAAa,GAAG;AACzB,QAAI,OAAO,OAAO,CAAC,GAAG,GAAG,EAAE,cAAc,EAAE,CAAC;AAC5C,UAAM,QAAQ,oBAAoB,aAAa,CAAC;AAChD,WAAO,KAAK,YAAY,OAAO,CAAC;AAAA,EACpC;AAAA,EACA,YAAY,OAAO,GAAG;AAClB,UAAM,MAAM,CAAC;AACb,QAAI,MAAM,EAAE;AACZ,QAAI,MAAM,GAAG;AACT,YAAM,EAAE,cAAc;AAAA,IAC1B;AACA,UAAM,KAAK,IAAI,KAAK,GAAG;AACvB,QAAI,UAAU,EAAE;AAChB,QAAI,UAAU,GAAG;AACb,gBAAU,EAAE,cAAc;AAAA,IAC9B;AACA,UAAM,KAAK,MAAM;AACjB,eAAWC,SAAQ,OAAO;AACtB,YAAM,SAAS,WAAWA,KAAI;AAC9B,YAAM,KAAK,SAAS;AACpB,YAAM,QAAQ,KAAK,KAAK,EAAE,IAAI;AAC9B,YAAM,SAAS,SAAU,QAAQ;AACjC,YAAM,KAAMA,MAAK,CAAC,EAAE,CAAC,IAAIA,MAAK,CAAC,EAAE,CAAC,KAAK,IAAM,MAAM;AACnD,YAAM,OAAO,KAAK,IAAIA,MAAK,CAAC,EAAE,CAAC,GAAGA,MAAK,CAAC,EAAE,CAAC,CAAC;AAC5C,eAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC5B,cAAM,IAAI,OAAO,SAAU,IAAI;AAC/B,cAAM,KAAM,IAAI,KAAM,KAAK,OAAO,IAAI,IAAI;AAC1C,cAAM,KAAM,IAAI,KAAM,KAAK,OAAO,IAAI,IAAI;AAC1C,cAAM,KAAK,KAAK,OAAO,QAAQ,IAAI,IAAI,SAAS,SAAS,CAAC;AAC1D,YAAI,KAAK,GAAG,GAAG,GAAG;AAAA,MACtB;AAAA,IACJ;AACA,WAAO,EAAE,MAAM,cAAc,IAAI;AAAA,EACrC;AACJ;;;ACxCA;AAEO,IAAM,eAAN,MAAmB;AAAA,EACtB,YAAYC,SAAQ;AAChB,SAAK,SAASA;AAAA,EAClB;AAAA,EACA,aAAa,aAAa,GAAG;AACzB,UAAM,QAAQ,oBAAoB,aAAa,CAAC;AAChD,WAAO,EAAE,MAAM,cAAc,KAAK,KAAK,WAAW,OAAO,CAAC,EAAE;AAAA,EAChE;AAAA,EACA,WAAW,OAAO,GAAG;AACjB,UAAM,SAAS,EAAE,aAAa,IAAK,EAAE,aAAa,IAAK,EAAE,cAAc,IAAK,EAAE,aAAc,EAAE;AAC9F,UAAM,MAAM,EAAE,UAAU,IAAK,EAAE,aAAa,IAAK,EAAE,cAAc,IAAK,EAAE,aAAc,EAAE;AACxF,UAAM,MAAM,CAAC;AACb,UAAM,QAAQ,CAACC,UAAS;AACpB,YAAM,SAAS,WAAWA,KAAI;AAC9B,YAAM,QAAQ,KAAK,MAAM,UAAU,SAAS,IAAI;AAChD,YAAM,eAAe,SAAS,MAAO,SAAS,SAAS,QAAS;AAChE,UAAI,KAAKA,MAAK,CAAC;AACf,UAAI,KAAKA,MAAK,CAAC;AACf,UAAI,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG;AACf,aAAKA,MAAK,CAAC;AACX,aAAKA,MAAK,CAAC;AAAA,MACf;AACA,YAAM,QAAQ,KAAK,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,EAAE;AACzD,eAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC5B,cAAM,SAAS,KAAK,SAAS;AAC7B,cAAM,OAAO,SAAS;AACtB,cAAM,QAAQ,CAAC,GAAG,CAAC,IAAK,SAAS,KAAK,IAAI,KAAK,IAAM,cAAc,KAAK,IAAI,KAAK,GAAI,GAAG,CAAC,IAAI,SAAS,KAAK,IAAI,KAAK,IAAK,cAAc,KAAK,IAAI,KAAK,CAAE;AACvJ,cAAM,MAAM,CAAC,GAAG,CAAC,IAAK,OAAO,KAAK,IAAI,KAAK,IAAM,cAAc,KAAK,IAAI,KAAK,GAAI,GAAG,CAAC,IAAK,OAAO,KAAK,IAAI,KAAK,IAAM,cAAc,KAAK,IAAI,KAAK,CAAE;AACnJ,YAAI,KAAK,GAAG,KAAK,OAAO,cAAc,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;AAAA,MAChF;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AACJ;;;ACnCA;AAEO,IAAM,mBAAN,MAAuB;AAAA,EAC1B,YAAYC,SAAQ;AAChB,SAAK,SAASA;AAAA,EAClB;AAAA,EACA,aAAa,aAAa,GAAG;AACzB,UAAM,MAAM,EAAE,aAAa,IAAK,EAAE,cAAc,IAAK,EAAE;AACvD,UAAM,KAAK,EAAE,eAAe,IAAI,MAAM,EAAE;AACxC,QAAI,OAAO,OAAO,CAAC,GAAG,GAAG,EAAE,YAAY,MAAM,GAAG,CAAC;AACjD,UAAM,QAAQ,oBAAoB,aAAa,CAAC;AAChD,WAAO,EAAE,MAAM,cAAc,KAAK,KAAK,YAAY,OAAO,IAAI,CAAC,EAAE;AAAA,EACrE;AAAA,EACA,YAAY,OAAO,IAAI,GAAG;AACtB,UAAM,MAAM,CAAC;AACb,UAAM,QAAQ,CAACC,UAAS;AACpB,YAAM,SAAS,WAAWA,KAAI;AAC9B,YAAM,QAAQ,KAAK,MAAM,UAAU,IAAI,GAAG;AAC1C,UAAI,KAAKA,MAAK,CAAC;AACf,UAAI,KAAKA,MAAK,CAAC;AACf,UAAI,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG;AACf,aAAKA,MAAK,CAAC;AACX,aAAKA,MAAK,CAAC;AAAA,MACf;AACA,YAAM,QAAQ,KAAK,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,EAAE;AACzD,eAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC5B,cAAM,SAAS,IAAI,IAAI;AACvB,cAAM,QAAQ,IAAI,KAAK,IAAI;AAC3B,cAAM,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,CAAC;AACxC,cAAM,QAAQ,CAAC,GAAG,CAAC,IAAK,SAAS,KAAK,IAAI,KAAK,GAAI,GAAG,CAAC,IAAI,SAAS,KAAK,IAAI,KAAK,CAAC;AACnF,cAAM,MAAM,CAAC,GAAG,CAAC,IAAK,OAAO,KAAK,IAAI,KAAK,GAAI,GAAG,CAAC,IAAK,OAAO,KAAK,IAAI,KAAK,CAAE;AAC/E,cAAM,SAAS,CAAC,MAAM,CAAC,IAAI,KAAK,KAAK,IAAI,QAAQ,KAAK,KAAK,CAAC,GAAG,MAAM,CAAC,IAAI,KAAK,KAAK,IAAI,QAAQ,KAAK,KAAK,CAAC,CAAC;AAC5G,YAAI,KAAK,GAAG,KAAK,OAAO,cAAc,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,GAAG,GAAG,KAAK,OAAO,cAAc,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;AAAA,MAC7J;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AACJ;;;AT/BA,IAAM,UAAU,CAAC;AACV,SAAS,UAAU,GAAGC,SAAQ;AACjC,MAAI,aAAa,EAAE,aAAa;AAChC,MAAI,CAAC,QAAQ,UAAU,GAAG;AACtB,YAAQ,YAAY;AAAA,MAChB,KAAK;AACD,YAAI,CAAC,QAAQ,UAAU,GAAG;AACtB,kBAAQ,UAAU,IAAI,IAAI,aAAaA,OAAM;AAAA,QACjD;AACA;AAAA,MACJ,KAAK;AACD,YAAI,CAAC,QAAQ,UAAU,GAAG;AACtB,kBAAQ,UAAU,IAAI,IAAI,YAAYA,OAAM;AAAA,QAChD;AACA;AAAA,MACJ,KAAK;AACD,YAAI,CAAC,QAAQ,UAAU,GAAG;AACtB,kBAAQ,UAAU,IAAI,IAAI,UAAUA,OAAM;AAAA,QAC9C;AACA;AAAA,MACJ,KAAK;AACD,YAAI,CAAC,QAAQ,UAAU,GAAG;AACtB,kBAAQ,UAAU,IAAI,IAAI,aAAaA,OAAM;AAAA,QACjD;AACA;AAAA,MACJ,KAAK;AACD,YAAI,CAAC,QAAQ,UAAU,GAAG;AACtB,kBAAQ,UAAU,IAAI,IAAI,iBAAiBA,OAAM;AAAA,QACrD;AACA;AAAA,MACJ,KAAK;AAAA,MACL;AACI,qBAAa;AACb,YAAI,CAAC,QAAQ,UAAU,GAAG;AACtB,kBAAQ,UAAU,IAAI,IAAI,cAAcA,OAAM;AAAA,QAClD;AACA;AAAA,IACR;AAAA,EACJ;AACA,SAAO,QAAQ,UAAU;AAC7B;;;AU9CA;AAAO,SAAS,aAAa;AACzB,SAAO,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK,EAAE;AAC7C;AACO,IAAM,SAAN,MAAa;AAAA,EAChB,YAAY,MAAM;AACd,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,OAAO;AACH,QAAI,KAAK,MAAM;AACX,cAAS,KAAK,KAAK,KAAM,KAAK,OAAO,KAAK,KAAK,OAAO,KAAK,IAAI,MAAM,KAAK;AAAA,IAC9E,OACK;AACD,aAAO,KAAK,OAAO;AAAA,IACvB;AAAA,EACJ;AACJ;;;ACfA;;;ACAA;AAAA,IAAM,UAAU;AAChB,IAAM,SAAS;AACf,IAAM,MAAM;AACZ,IAAM,SAAS,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE;AACxI,SAAS,SAAS,GAAG;AACjB,QAAM,SAAS,IAAI,MAAM;AACzB,SAAO,MAAM,IAAI;AACb,QAAI,EAAE,MAAM,gBAAgB,GAAG;AAC3B,UAAI,EAAE,OAAO,OAAO,GAAG,MAAM;AAAA,IACjC,WACS,EAAE,MAAM,2BAA2B,GAAG;AAC3C,aAAO,OAAO,MAAM,IAAI,EAAE,MAAM,SAAS,MAAM,OAAO,GAAG;AACzD,UAAI,EAAE,OAAO,OAAO,GAAG,MAAM;AAAA,IACjC,WACS,EAAE,MAAM,6DAA6D,GAAG;AAC7E,aAAO,OAAO,MAAM,IAAI,EAAE,MAAM,QAAQ,MAAM,GAAG,WAAW,OAAO,EAAE,CAAC,GAAG;AACzE,UAAI,EAAE,OAAO,OAAO,GAAG,MAAM;AAAA,IACjC,OACK;AACD,aAAO,CAAC;AAAA,IACZ;AAAA,EACJ;AACA,SAAO,OAAO,MAAM,IAAI,EAAE,MAAM,KAAK,MAAM,GAAG;AAC9C,SAAO;AACX;AACA,SAAS,OAAO,OAAO,MAAM;AACzB,SAAO,MAAM,SAAS;AAC1B;AACO,SAAS,UAAU,GAAG;AACzB,QAAM,WAAW,CAAC;AAClB,QAAM,SAAS,SAAS,CAAC;AACzB,MAAI,OAAO;AACX,MAAI,QAAQ;AACZ,MAAI,QAAQ,OAAO,KAAK;AACxB,SAAO,CAAC,OAAO,OAAO,GAAG,GAAG;AACxB,QAAI,cAAc;AAClB,UAAM,SAAS,CAAC;AAChB,QAAI,SAAS,OAAO;AAChB,UAAI,MAAM,SAAS,OAAO,MAAM,SAAS,KAAK;AAC1C;AACA,sBAAc,OAAO,MAAM,IAAI;AAC/B,eAAO,MAAM;AAAA,MACjB,OACK;AACD,eAAO,UAAU,SAAS,CAAC;AAAA,MAC/B;AAAA,IACJ,WACS,OAAO,OAAO,MAAM,GAAG;AAC5B,oBAAc,OAAO,IAAI;AAAA,IAC7B,OACK;AACD;AACA,oBAAc,OAAO,MAAM,IAAI;AAC/B,aAAO,MAAM;AAAA,IACjB;AACA,QAAK,QAAQ,cAAe,OAAO,QAAQ;AACvC,eAAS,IAAI,OAAO,IAAI,QAAQ,aAAa,KAAK;AAC9C,cAAM,aAAa,OAAO,CAAC;AAC3B,YAAI,OAAO,YAAY,MAAM,GAAG;AAC5B,iBAAO,OAAO,MAAM,IAAI,CAAC,WAAW;AAAA,QACxC,OACK;AACD,gBAAM,IAAI,MAAM,yBAAyB,OAAO,MAAM,WAAW,IAAI;AAAA,QACzE;AAAA,MACJ;AACA,UAAI,OAAO,OAAO,IAAI,MAAM,UAAU;AAClC,cAAM,UAAU,EAAE,KAAK,MAAM,MAAM,OAAO;AAC1C,iBAAS,KAAK,OAAO;AACrB,iBAAS;AACT,gBAAQ,OAAO,KAAK;AACpB,YAAI,SAAS;AACT,iBAAO;AACX,YAAI,SAAS;AACT,iBAAO;AAAA,MACf,OACK;AACD,cAAM,IAAI,MAAM,kBAAkB,IAAI;AAAA,MAC1C;AAAA,IACJ,OACK;AACD,YAAM,IAAI,MAAM,uBAAuB;AAAA,IAC3C;AAAA,EACJ;AACA,SAAO;AACX;;;ACpFA;AACO,SAAS,WAAW,UAAU;AACjC,MAAI,KAAK,GAAG,KAAK;AACjB,MAAI,OAAO,GAAG,OAAO;AACrB,QAAM,MAAM,CAAC;AACb,aAAW,EAAE,KAAK,KAAK,KAAK,UAAU;AAClC,YAAQ,KAAK;AAAA,MACT,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,SAAC,IAAI,EAAE,IAAI;AACX,SAAC,MAAM,IAAI,IAAI;AACf;AAAA,MACJ,KAAK;AACD,cAAM,KAAK,CAAC;AACZ,cAAM,KAAK,CAAC;AACZ,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC;AACrC,eAAO;AACP,eAAO;AACP;AAAA,MACJ,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,SAAC,IAAI,EAAE,IAAI;AACX;AAAA,MACJ,KAAK;AACD,cAAM,KAAK,CAAC;AACZ,cAAM,KAAK,CAAC;AACZ,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC;AACrC;AAAA,MACJ,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,aAAK,KAAK,CAAC;AACX,aAAK,KAAK,CAAC;AACX;AAAA,MACJ,KAAK,KAAK;AACN,cAAM,UAAU,KAAK,IAAI,CAAC,GAAG,MAAO,IAAI,IAAM,IAAI,KAAO,IAAI,EAAG;AAChE,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,QAAQ,CAAC;AACpC,aAAK,QAAQ,CAAC;AACd,aAAK,QAAQ,CAAC;AACd;AAAA,MACJ;AAAA,MACA,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,aAAK,KAAK,CAAC;AACX,aAAK,KAAK,CAAC;AACX;AAAA,MACJ,KAAK,KAAK;AACN,cAAM,UAAU,KAAK,IAAI,CAAC,GAAG,MAAO,IAAI,IAAM,IAAI,KAAO,IAAI,EAAG;AAChE,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,QAAQ,CAAC;AACpC,aAAK,QAAQ,CAAC;AACd,aAAK,QAAQ,CAAC;AACd;AAAA,MACJ;AAAA,MACA,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,aAAK,KAAK,CAAC;AACX,aAAK,KAAK,CAAC;AACX;AAAA,MACJ,KAAK;AACD,cAAM,KAAK,CAAC;AACZ,cAAM,KAAK,CAAC;AACZ,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC;AAClF;AAAA,MACJ,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,aAAK,KAAK,CAAC;AACX;AAAA,MACJ,KAAK;AACD,cAAM,KAAK,CAAC;AACZ,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,EAAE,EAAE,CAAC;AACjC;AAAA,MACJ,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,aAAK,KAAK,CAAC;AACX;AAAA,MACJ,KAAK;AACD,cAAM,KAAK,CAAC;AACZ,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,EAAE,EAAE,CAAC;AACjC;AAAA,MACJ,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,aAAK,KAAK,CAAC;AACX,aAAK,KAAK,CAAC;AACX;AAAA,MACJ,KAAK,KAAK;AACN,cAAM,UAAU,KAAK,IAAI,CAAC,GAAG,MAAO,IAAI,IAAM,IAAI,KAAO,IAAI,EAAG;AAChE,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,QAAQ,CAAC;AACpC,aAAK,QAAQ,CAAC;AACd,aAAK,QAAQ,CAAC;AACd;AAAA,MACJ;AAAA,MACA,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,aAAK,KAAK,CAAC;AACX,aAAK,KAAK,CAAC;AACX;AAAA,MACJ,KAAK;AACD,cAAM,KAAK,CAAC;AACZ,cAAM,KAAK,CAAC;AACZ,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC;AACrC;AAAA,MACJ,KAAK;AAAA,MACL,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,EAAE,CAAC;AAC/B,aAAK;AACL,aAAK;AACL;AAAA,IACR;AAAA,EACJ;AACA,SAAO;AACX;;;AC7GA;AACO,SAAS,UAAU,UAAU;AAChC,QAAM,MAAM,CAAC;AACb,MAAI,WAAW;AACf,MAAI,KAAK,GAAG,KAAK;AACjB,MAAI,OAAO,GAAG,OAAO;AACrB,MAAI,MAAM,GAAG,MAAM;AACnB,aAAW,EAAE,KAAK,KAAK,KAAK,UAAU;AAClC,YAAQ,KAAK;AAAA,MACT,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,SAAC,IAAI,EAAE,IAAI;AACX,SAAC,MAAM,IAAI,IAAI;AACf;AAAA,MACJ,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,aAAK,KAAK,CAAC;AACX,aAAK,KAAK,CAAC;AACX,cAAM,KAAK,CAAC;AACZ,cAAM,KAAK,CAAC;AACZ;AAAA,MACJ,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,IAAI,EAAE,CAAC;AACtC,SAAC,IAAI,EAAE,IAAI;AACX;AAAA,MACJ,KAAK;AACD,aAAK,KAAK,CAAC;AACX,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC;AACrC;AAAA,MACJ,KAAK;AACD,aAAK,KAAK,CAAC;AACX,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC;AACrC;AAAA,MACJ,KAAK,KAAK;AACN,YAAI,MAAM,GAAG,MAAM;AACnB,YAAI,aAAa,OAAO,aAAa,KAAK;AACtC,gBAAM,MAAM,KAAK;AACjB,gBAAM,MAAM,KAAK;AAAA,QACrB,OACK;AACD,gBAAM;AACN,gBAAM;AAAA,QACV;AACA,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,GAAG,IAAI,EAAE,CAAC;AAChD,cAAM,KAAK,CAAC;AACZ,cAAM,KAAK,CAAC;AACZ,aAAK,KAAK,CAAC;AACX,aAAK,KAAK,CAAC;AACX;AAAA,MACJ;AAAA,MACA,KAAK,KAAK;AACN,cAAM,CAAC,GAAG,CAAC,IAAI;AACf,YAAI,KAAK,GAAG,KAAK;AACjB,YAAI,aAAa,OAAO,aAAa,KAAK;AACtC,eAAK,MAAM,KAAK;AAChB,eAAK,MAAM,KAAK;AAAA,QACpB,OACK;AACD,eAAK;AACL,eAAK;AAAA,QACT;AACA,cAAM,MAAM,KAAK,KAAK,KAAK,MAAM;AACjC,cAAM,MAAM,KAAK,KAAK,KAAK,MAAM;AACjC,cAAM,MAAM,IAAI,KAAK,KAAK,KAAK;AAC/B,cAAM,MAAM,IAAI,KAAK,KAAK,KAAK;AAC/B,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,KAAK,KAAK,GAAG,CAAC,EAAE,CAAC;AACvD,cAAM;AACN,cAAM;AACN,aAAK;AACL,aAAK;AACL;AAAA,MACJ;AAAA,MACA,KAAK,KAAK;AACN,cAAM,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI;AACvB,cAAM,MAAM,KAAK,KAAK,KAAK,MAAM;AACjC,cAAM,MAAM,KAAK,KAAK,KAAK,MAAM;AACjC,cAAM,MAAM,IAAI,KAAK,KAAK,KAAK;AAC/B,cAAM,MAAM,IAAI,KAAK,KAAK,KAAK;AAC/B,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,KAAK,KAAK,KAAK,KAAK,GAAG,CAAC,EAAE,CAAC;AACvD,cAAM;AACN,cAAM;AACN,aAAK;AACL,aAAK;AACL;AAAA,MACJ;AAAA,MACA,KAAK,KAAK;AACN,cAAM,KAAK,KAAK,IAAI,KAAK,CAAC,CAAC;AAC3B,cAAM,KAAK,KAAK,IAAI,KAAK,CAAC,CAAC;AAC3B,cAAM,QAAQ,KAAK,CAAC;AACpB,cAAM,eAAe,KAAK,CAAC;AAC3B,cAAM,YAAY,KAAK,CAAC;AACxB,cAAM,IAAI,KAAK,CAAC;AAChB,cAAM,IAAI,KAAK,CAAC;AAChB,YAAI,OAAO,KAAK,OAAO,GAAG;AACtB,cAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,IAAI,IAAI,GAAG,GAAG,GAAG,CAAC,EAAE,CAAC;AACjD,eAAK;AACL,eAAK;AAAA,QACT,OACK;AACD,cAAI,OAAO,KAAK,OAAO,GAAG;AACtB,kBAAM,SAAS,iBAAiB,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,OAAO,cAAc,SAAS;AACpF,mBAAO,QAAQ,SAAUC,QAAO;AAC5B,kBAAI,KAAK,EAAE,KAAK,KAAK,MAAMA,OAAM,CAAC;AAAA,YACtC,CAAC;AACD,iBAAK;AACL,iBAAK;AAAA,UACT;AAAA,QACJ;AACA;AAAA,MACJ;AAAA,MACA,KAAK;AACD,YAAI,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,EAAE,CAAC;AAC/B,aAAK;AACL,aAAK;AACL;AAAA,IACR;AACA,eAAW;AAAA,EACf;AACA,SAAO;AACX;AACA,SAAS,SAAS,SAAS;AACvB,SAAQ,KAAK,KAAK,UAAW;AACjC;AACA,SAAS,OAAO,GAAG,GAAG,UAAU;AAC5B,QAAM,IAAI,IAAI,KAAK,IAAI,QAAQ,IAAI,IAAI,KAAK,IAAI,QAAQ;AACxD,QAAM,IAAI,IAAI,KAAK,IAAI,QAAQ,IAAI,IAAI,KAAK,IAAI,QAAQ;AACxD,SAAO,CAAC,GAAG,CAAC;AAChB;AACA,SAAS,iBAAiB,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,OAAO,cAAc,WAAW,WAAW;AACzF,QAAM,WAAW,SAAS,KAAK;AAC/B,MAAI,SAAS,CAAC;AACd,MAAI,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK;AACjC,MAAI,WAAW;AACX,KAAC,IAAI,IAAI,IAAI,EAAE,IAAI;AAAA,EACvB,OACK;AACD,KAAC,IAAI,EAAE,IAAI,OAAO,IAAI,IAAI,CAAC,QAAQ;AACnC,KAAC,IAAI,EAAE,IAAI,OAAO,IAAI,IAAI,CAAC,QAAQ;AACnC,UAAM,KAAK,KAAK,MAAM;AACtB,UAAM,KAAK,KAAK,MAAM;AACtB,QAAI,IAAK,IAAI,KAAM,KAAK,MAAO,IAAI,KAAM,KAAK;AAC9C,QAAI,IAAI,GAAG;AACP,UAAI,KAAK,KAAK,CAAC;AACf,WAAK,IAAI;AACT,WAAK,IAAI;AAAA,IACb;AACA,UAAM,OAAQ,iBAAiB,YAAa,KAAK;AACjD,UAAM,QAAQ,KAAK;AACnB,UAAM,QAAQ,KAAK;AACnB,UAAM,OAAO,QAAQ,QAAQ,QAAQ,IAAI,IAAI,QAAQ,IAAI;AACzD,UAAM,QAAQ,QAAQ,IAAI,IAAI,QAAQ,IAAI;AAC1C,UAAM,IAAI,OAAO,KAAK,KAAK,KAAK,IAAI,OAAO,KAAK,CAAC;AACjD,SAAK,IAAI,KAAK,IAAI,MAAM,KAAK,MAAM;AACnC,SAAK,IAAI,CAAC,KAAK,IAAI,MAAM,KAAK,MAAM;AACpC,SAAK,KAAK,KAAK,aAAa,KAAK,MAAM,IAAI,QAAQ,CAAC,CAAC,CAAC;AACtD,SAAK,KAAK,KAAK,aAAa,KAAK,MAAM,IAAI,QAAQ,CAAC,CAAC,CAAC;AACtD,QAAI,KAAK,IAAI;AACT,WAAK,KAAK,KAAK;AAAA,IACnB;AACA,QAAI,KAAK,IAAI;AACT,WAAK,KAAK,KAAK;AAAA,IACnB;AACA,QAAI,KAAK,GAAG;AACR,WAAK,KAAK,KAAK,IAAI;AAAA,IACvB;AACA,QAAI,KAAK,GAAG;AACR,WAAK,KAAK,KAAK,IAAI;AAAA,IACvB;AACA,QAAI,aAAa,KAAK,IAAI;AACtB,WAAK,KAAK,KAAK,KAAK;AAAA,IACxB;AACA,QAAI,CAAC,aAAa,KAAK,IAAI;AACvB,WAAK,KAAK,KAAK,KAAK;AAAA,IACxB;AAAA,EACJ;AACA,MAAI,KAAK,KAAK;AACd,MAAI,KAAK,IAAI,EAAE,IAAK,KAAK,KAAK,MAAM,KAAM;AACtC,UAAM,QAAQ;AACd,UAAM,QAAQ;AACd,UAAM,QAAQ;AACd,QAAI,aAAa,KAAK,IAAI;AACtB,WAAK,KAAM,KAAK,KAAK,MAAM,MAAQ;AAAA,IACvC,OACK;AACD,WAAK,KAAM,KAAK,KAAK,MAAM,MAAQ;AAAA,IACvC;AACA,SAAK,KAAK,KAAK,KAAK,IAAI,EAAE;AAC1B,SAAK,KAAK,KAAK,KAAK,IAAI,EAAE;AAC1B,aAAS,iBAAiB,IAAI,IAAI,OAAO,OAAO,IAAI,IAAI,OAAO,GAAG,WAAW,CAAC,IAAI,OAAO,IAAI,EAAE,CAAC;AAAA,EACpG;AACA,OAAK,KAAK;AACV,QAAM,KAAK,KAAK,IAAI,EAAE;AACtB,QAAM,KAAK,KAAK,IAAI,EAAE;AACtB,QAAM,KAAK,KAAK,IAAI,EAAE;AACtB,QAAM,KAAK,KAAK,IAAI,EAAE;AACtB,QAAM,IAAI,KAAK,IAAI,KAAK,CAAC;AACzB,QAAM,KAAK,IAAI,IAAI,KAAK;AACxB,QAAM,KAAK,IAAI,IAAI,KAAK;AACxB,QAAM,KAAK,CAAC,IAAI,EAAE;AAClB,QAAM,KAAK,CAAC,KAAK,KAAK,IAAI,KAAK,KAAK,EAAE;AACtC,QAAM,KAAK,CAAC,KAAK,KAAK,IAAI,KAAK,KAAK,EAAE;AACtC,QAAM,KAAK,CAAC,IAAI,EAAE;AAClB,KAAG,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC;AACxB,KAAG,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC;AACxB,MAAI,WAAW;AACX,WAAO,CAAC,IAAI,IAAI,EAAE,EAAE,OAAO,MAAM;AAAA,EACrC,OACK;AACD,aAAS,CAAC,IAAI,IAAI,EAAE,EAAE,OAAO,MAAM;AACnC,UAAM,SAAS,CAAC;AAChB,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACvC,YAAMC,MAAK,OAAO,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,QAAQ;AACtD,YAAMC,MAAK,OAAO,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,QAAQ;AAC9D,YAAM,KAAK,OAAO,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,QAAQ;AAC9D,aAAO,KAAK,CAACD,IAAG,CAAC,GAAGA,IAAG,CAAC,GAAGC,IAAG,CAAC,GAAGA,IAAG,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAAA,IAC1D;AACA,WAAO;AAAA,EACX;AACJ;;;AfvNA,IAAM,SAAS;AAAA,EACX;AAAA,EACA;AAAA,EACA;AAAA,EACA,eAAe;AACnB;AACO,SAAS,KAAK,IAAI,IAAI,IAAI,IAAI,GAAG;AACpC,SAAO,EAAE,MAAM,QAAQ,KAAK,YAAY,IAAI,IAAI,IAAI,IAAI,CAAC,EAAE;AAC/D;AACO,SAAS,WAAW,QAAQ,OAAO,GAAG;AACzC,QAAM,OAAO,UAAU,CAAC,GAAG;AAC3B,MAAI,MAAM,GAAG;AACT,UAAM,MAAM,CAAC;AACb,aAAS,IAAI,GAAG,IAAK,MAAM,GAAI,KAAK;AAChC,UAAI,KAAK,GAAG,YAAY,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;AAAA,IAC9F;AACA,QAAI,OAAO;AACP,UAAI,KAAK,GAAG,YAAY,OAAO,MAAM,CAAC,EAAE,CAAC,GAAG,OAAO,MAAM,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;AAAA,IAClG;AACA,WAAO,EAAE,MAAM,QAAQ,IAAI;AAAA,EAC/B,WACS,QAAQ,GAAG;AAChB,WAAO,KAAK,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC;AAAA,EACzE;AACA,SAAO,EAAE,MAAM,QAAQ,KAAK,CAAC,EAAE;AACnC;AACO,SAAS,QAAQ,QAAQ,GAAG;AAC/B,SAAO,WAAW,QAAQ,MAAM,CAAC;AACrC;AACO,SAAS,UAAU,GAAG,GAAG,OAAO,QAAQ,GAAG;AAC9C,QAAM,SAAS;AAAA,IACX,CAAC,GAAG,CAAC;AAAA,IACL,CAAC,IAAI,OAAO,CAAC;AAAA,IACb,CAAC,IAAI,OAAO,IAAI,MAAM;AAAA,IACtB,CAAC,GAAG,IAAI,MAAM;AAAA,EAClB;AACA,SAAO,QAAQ,QAAQ,CAAC;AAC5B;AACO,SAAS,MAAM,QAAQ,GAAG;AAC7B,MAAI,KAAK,iBAAiB,QAAQ,KAAK,IAAI,EAAE,YAAY,MAAM,CAAC;AAChE,MAAI,CAAC,EAAE,oBAAoB;AACvB,UAAM,KAAK,iBAAiB,QAAQ,OAAO,IAAI,EAAE,YAAY,OAAO,sBAAsB,CAAC,CAAC;AAC5F,SAAK,GAAG,OAAO,EAAE;AAAA,EACrB;AACA,SAAO,EAAE,MAAM,QAAQ,KAAK,GAAG;AACnC;AACO,SAAS,QAAQ,GAAG,GAAG,OAAO,QAAQ,GAAG;AAC5C,QAAM,SAAS,sBAAsB,OAAO,QAAQ,CAAC;AACrD,SAAO,kBAAkB,GAAG,GAAG,GAAG,MAAM,EAAE;AAC9C;AACO,SAAS,sBAAsB,OAAO,QAAQ,GAAG;AACpD,QAAM,MAAM,KAAK,KAAK,KAAK,KAAK,IAAI,KAAK,MAAM,KAAK,IAAI,QAAQ,GAAG,CAAC,IAAI,KAAK,IAAI,SAAS,GAAG,CAAC,KAAK,CAAC,CAAC;AACrG,QAAM,YAAY,KAAK,KAAK,KAAK,IAAI,EAAE,gBAAiB,EAAE,iBAAiB,KAAK,KAAK,GAAG,IAAK,GAAG,CAAC;AACjG,QAAM,YAAa,KAAK,KAAK,IAAK;AAClC,MAAI,KAAK,KAAK,IAAI,QAAQ,CAAC;AAC3B,MAAI,KAAK,KAAK,IAAI,SAAS,CAAC;AAC5B,QAAM,qBAAqB,IAAI,EAAE;AACjC,QAAM,WAAW,KAAK,oBAAoB,CAAC;AAC3C,QAAM,WAAW,KAAK,oBAAoB,CAAC;AAC3C,SAAO,EAAE,WAAW,IAAI,GAAG;AAC/B;AACO,SAAS,kBAAkB,GAAG,GAAG,GAAG,eAAe;AACtD,QAAM,CAAC,KAAK,GAAG,IAAI,sBAAsB,cAAc,WAAW,GAAG,GAAG,cAAc,IAAI,cAAc,IAAI,GAAG,cAAc,YAAY,QAAQ,KAAK,QAAQ,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;AAC/K,MAAI,KAAK,OAAO,KAAK,MAAM,CAAC;AAC5B,MAAK,CAAC,EAAE,sBAAwB,EAAE,cAAc,GAAI;AAChD,UAAM,CAAC,GAAG,IAAI,sBAAsB,cAAc,WAAW,GAAG,GAAG,cAAc,IAAI,cAAc,IAAI,KAAK,GAAG,CAAC;AAChH,UAAM,KAAK,OAAO,KAAK,MAAM,CAAC;AAC9B,SAAK,GAAG,OAAO,EAAE;AAAA,EACrB;AACA,SAAO;AAAA,IACH,iBAAiB;AAAA,IACjB,OAAO,EAAE,MAAM,QAAQ,KAAK,GAAG;AAAA,EACnC;AACJ;AACO,SAAS,IAAI,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,QAAQ,cAAc,GAAG;AAC3E,QAAM,KAAK;AACX,QAAM,KAAK;AACX,MAAI,KAAK,KAAK,IAAI,QAAQ,CAAC;AAC3B,MAAI,KAAK,KAAK,IAAI,SAAS,CAAC;AAC5B,QAAM,WAAW,KAAK,MAAM,CAAC;AAC7B,QAAM,WAAW,KAAK,MAAM,CAAC;AAC7B,MAAI,OAAO;AACX,MAAI,MAAM;AACV,SAAO,OAAO,GAAG;AACb,YAAQ,KAAK,KAAK;AAClB,WAAO,KAAK,KAAK;AAAA,EACrB;AACA,MAAK,MAAM,OAAS,KAAK,KAAK,GAAI;AAC9B,WAAO;AACP,UAAM,KAAK,KAAK;AAAA,EACpB;AACA,QAAM,aAAc,KAAK,KAAK,IAAK,EAAE;AACrC,QAAM,SAAS,KAAK,IAAI,aAAa,IAAI,MAAM,QAAQ,CAAC;AACxD,QAAM,MAAM,KAAK,QAAQ,IAAI,IAAI,IAAI,IAAI,MAAM,KAAK,GAAG,CAAC;AACxD,MAAI,CAAC,EAAE,oBAAoB;AACvB,UAAM,KAAK,KAAK,QAAQ,IAAI,IAAI,IAAI,IAAI,MAAM,KAAK,KAAK,CAAC;AACzD,QAAI,KAAK,GAAG,EAAE;AAAA,EAClB;AACA,MAAI,QAAQ;AACR,QAAI,cAAc;AACd,UAAI,KAAK,GAAG,YAAY,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,IAAI,GAAG,KAAK,KAAK,KAAK,IAAI,IAAI,GAAG,CAAC,GAAG,GAAG,YAAY,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,GAAG,GAAG,CAAC,CAAC;AAAA,IACvK,OACK;AACD,UAAI,KAAK,EAAE,IAAI,UAAU,MAAM,CAAC,IAAI,EAAE,EAAE,GAAG,EAAE,IAAI,UAAU,MAAM,CAAC,KAAK,KAAK,KAAK,IAAI,IAAI,GAAG,KAAK,KAAK,KAAK,IAAI,IAAI,CAAC,EAAE,CAAC;AAAA,IAC3H;AAAA,EACJ;AACA,SAAO,EAAE,MAAM,QAAQ,IAAI;AAC/B;AACO,SAAS,QAAQ,MAAM,GAAG;AAC7B,QAAM,WAAW,UAAU,WAAW,UAAU,IAAI,CAAC,CAAC;AACtD,QAAM,MAAM,CAAC;AACb,MAAI,QAAQ,CAAC,GAAG,CAAC;AACjB,MAAI,UAAU,CAAC,GAAG,CAAC;AACnB,aAAW,EAAE,KAAK,KAAK,KAAK,UAAU;AAClC,YAAQ,KAAK;AAAA,MACT,KAAK,KAAK;AACN,kBAAU,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAC3B,gBAAQ,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACzB;AAAA,MACJ;AAAA,MACA,KAAK;AACD,YAAI,KAAK,GAAG,YAAY,QAAQ,CAAC,GAAG,QAAQ,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;AACpE,kBAAU,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAC3B;AAAA,MACJ,KAAK,KAAK;AACN,cAAM,CAAC,IAAI,IAAI,IAAI,IAAI,GAAG,CAAC,IAAI;AAC/B,YAAI,KAAK,GAAG,UAAU,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,SAAS,CAAC,CAAC;AACvD,kBAAU,CAAC,GAAG,CAAC;AACf;AAAA,MACJ;AAAA,MACA,KAAK;AACD,YAAI,KAAK,GAAG,YAAY,QAAQ,CAAC,GAAG,QAAQ,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AACtE,kBAAU,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAC7B;AAAA,IACR;AAAA,EACJ;AACA,SAAO,EAAE,MAAM,QAAQ,IAAI;AAC/B;AAEO,SAAS,iBAAiB,aAAa,GAAG;AAC7C,QAAM,MAAM,CAAC;AACb,aAAW,UAAU,aAAa;AAC9B,QAAI,OAAO,QAAQ;AACf,YAAM,SAAS,EAAE,uBAAuB;AACxC,YAAM,MAAM,OAAO;AACnB,UAAI,MAAM,GAAG;AACT,YAAI,KAAK,EAAE,IAAI,QAAQ,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC,CAAC,EAAE,CAAC;AAC3G,iBAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,cAAI,KAAK,EAAE,IAAI,UAAU,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC,CAAC,EAAE,CAAC;AAAA,QACjH;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,EAAE,MAAM,YAAY,IAAI;AACnC;AACO,SAAS,oBAAoB,aAAa,GAAG;AAChD,SAAO,UAAU,GAAG,MAAM,EAAE,aAAa,aAAa,CAAC;AAC3D;AACO,SAAS,eAAe,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,GAAG;AAChE,QAAM,KAAK;AACX,QAAM,KAAK;AACX,MAAI,KAAK,KAAK,IAAI,QAAQ,CAAC;AAC3B,MAAI,KAAK,KAAK,IAAI,SAAS,CAAC;AAC5B,QAAM,WAAW,KAAK,MAAM,CAAC;AAC7B,QAAM,WAAW,KAAK,MAAM,CAAC;AAC7B,MAAI,OAAO;AACX,MAAI,MAAM;AACV,SAAO,OAAO,GAAG;AACb,YAAQ,KAAK,KAAK;AAClB,WAAO,KAAK,KAAK;AAAA,EACrB;AACA,MAAK,MAAM,OAAS,KAAK,KAAK,GAAI;AAC9B,WAAO;AACP,UAAM,KAAK,KAAK;AAAA,EACpB;AACA,QAAM,aAAa,MAAM,QAAQ,EAAE;AACnC,QAAM,SAAS,CAAC;AAChB,WAAS,QAAQ,MAAM,SAAS,KAAK,QAAQ,QAAQ,WAAW;AAC5D,WAAO,KAAK,CAAC,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG,KAAK,KAAK,KAAK,IAAI,KAAK,CAAC,CAAC;AAAA,EACtE;AACA,SAAO,KAAK,CAAC,KAAK,KAAK,KAAK,IAAI,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,GAAG,CAAC,CAAC;AAC9D,SAAO,KAAK,CAAC,IAAI,EAAE,CAAC;AACpB,SAAO,oBAAoB,CAAC,MAAM,GAAG,CAAC;AAC1C;AACO,SAAS,WAAW,GAAG,GAAG;AAC7B,SAAO,WAAW,GAAG,CAAC;AAC1B;AACO,SAAS,oBAAoB,KAAK,KAAK,GAAG;AAC7C,SAAO,QAAQ,KAAK,KAAK,CAAC;AAC9B;AACO,SAAS,kBAAkB,IAAI,IAAI,IAAI,IAAI,GAAG;AACjD,SAAO,YAAY,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI;AAC9C;AAEA,SAAS,sBAAsB,KAAK;AAChC,QAAM,SAAS,OAAO,OAAO,CAAC,GAAG,GAAG;AACpC,SAAO,aAAa;AACpB,MAAI,IAAI,MAAM;AACV,WAAO,OAAO,IAAI,OAAO;AAAA,EAC7B;AACA,SAAO;AACX;AACA,SAAS,OAAO,KAAK;AACjB,MAAI,CAAC,IAAI,YAAY;AACjB,QAAI,aAAa,IAAI,OAAO,IAAI,QAAQ,CAAC;AAAA,EAC7C;AACA,SAAO,IAAI,WAAW,KAAK;AAC/B;AACA,SAAS,QAAQ,KAAK,KAAK,KAAK,gBAAgB,GAAG;AAC/C,SAAO,IAAI,YAAY,iBAAkB,OAAO,GAAG,KAAK,MAAM,OAAQ;AAC1E;AACA,SAAS,WAAW,GAAG,KAAK,gBAAgB,GAAG;AAC3C,SAAO,QAAQ,CAAC,GAAG,GAAG,KAAK,aAAa;AAC5C;AACA,SAAS,YAAY,IAAI,IAAI,IAAI,IAAI,GAAG,UAAU,OAAO;AACrD,QAAM,eAAe,UAAU,EAAE,yBAAyB,EAAE;AAC5D,QAAM,KAAK,MAAM,IAAI,IAAI,IAAI,IAAI,GAAG,MAAM,KAAK;AAC/C,MAAI,cAAc;AACd,WAAO;AAAA,EACX;AACA,QAAM,KAAK,MAAM,IAAI,IAAI,IAAI,IAAI,GAAG,MAAM,IAAI;AAC9C,SAAO,GAAG,OAAO,EAAE;AACvB;AACA,SAAS,MAAM,IAAI,IAAI,IAAI,IAAI,GAAG,MAAM,SAAS;AAC7C,QAAM,WAAW,KAAK,IAAK,KAAK,IAAK,CAAC,IAAI,KAAK,IAAK,KAAK,IAAK,CAAC;AAC/D,QAAM,SAAS,KAAK,KAAK,QAAQ;AACjC,MAAI,gBAAgB;AACpB,MAAI,SAAS,KAAK;AACd,oBAAgB;AAAA,EACpB,WACS,SAAS,KAAK;AACnB,oBAAgB;AAAA,EACpB,OACK;AACD,oBAAiB,YAAc,SAAS;AAAA,EAC5C;AACA,MAAI,SAAS,EAAE,uBAAuB;AACtC,MAAK,SAAS,SAAS,MAAO,UAAU;AACpC,aAAS,SAAS;AAAA,EACtB;AACA,QAAM,aAAa,SAAS;AAC5B,QAAM,eAAe,MAAM,OAAO,CAAC,IAAI;AACvC,MAAI,WAAW,EAAE,SAAS,EAAE,uBAAuB,KAAK,MAAM;AAC9D,MAAI,WAAW,EAAE,SAAS,EAAE,uBAAuB,KAAK,MAAM;AAC9D,aAAW,WAAW,UAAU,GAAG,aAAa;AAChD,aAAW,WAAW,UAAU,GAAG,aAAa;AAChD,QAAM,MAAM,CAAC;AACb,QAAM,aAAa,MAAM,WAAW,YAAY,GAAG,aAAa;AAChE,QAAM,aAAa,MAAM,WAAW,QAAQ,GAAG,aAAa;AAC5D,QAAM,mBAAmB,EAAE;AAC3B,MAAI,MAAM;AACN,QAAI,SAAS;AACT,UAAI,KAAK;AAAA,QACL,IAAI;AAAA,QAAQ,MAAM;AAAA,UACd,MAAM,mBAAmB,IAAI,WAAW;AAAA,UACxC,MAAM,mBAAmB,IAAI,WAAW;AAAA,QAC5C;AAAA,MACJ,CAAC;AAAA,IACL,OACK;AACD,UAAI,KAAK;AAAA,QACL,IAAI;AAAA,QAAQ,MAAM;AAAA,UACd,MAAM,mBAAmB,IAAI,WAAW,QAAQ,GAAG,aAAa;AAAA,UAChE,MAAM,mBAAmB,IAAI,WAAW,QAAQ,GAAG,aAAa;AAAA,QACpE;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AACA,MAAI,SAAS;AACT,QAAI,KAAK;AAAA,MACL,IAAI;AAAA,MACJ,MAAM;AAAA,QACF,WAAW,MAAM,KAAK,MAAM,eAAe,WAAW;AAAA,QACtD,WAAW,MAAM,KAAK,MAAM,eAAe,WAAW;AAAA,QACtD,WAAW,KAAK,KAAK,KAAK,MAAM,eAAe,WAAW;AAAA,QAC1D,WAAW,KAAK,KAAK,KAAK,MAAM,eAAe,WAAW;AAAA,QAC1D,MAAM,mBAAmB,IAAI,WAAW;AAAA,QACxC,MAAM,mBAAmB,IAAI,WAAW;AAAA,MAC5C;AAAA,IACJ,CAAC;AAAA,EACL,OACK;AACD,QAAI,KAAK;AAAA,MACL,IAAI;AAAA,MACJ,MAAM;AAAA,QACF,WAAW,MAAM,KAAK,MAAM,eAAe,WAAW;AAAA,QACtD,WAAW,MAAM,KAAK,MAAM,eAAe,WAAW;AAAA,QACtD,WAAW,KAAK,KAAK,KAAK,MAAM,eAAe,WAAW;AAAA,QAC1D,WAAW,KAAK,KAAK,KAAK,MAAM,eAAe,WAAW;AAAA,QAC1D,MAAM,mBAAmB,IAAI,WAAW;AAAA,QACxC,MAAM,mBAAmB,IAAI,WAAW;AAAA,MAC5C;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO;AACX;AACA,SAAS,iBAAiB,QAAQ,QAAQ,GAAG;AACzC,QAAM,KAAK,CAAC;AACZ,KAAG,KAAK;AAAA,IACJ,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC;AAAA,IACnC,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC;AAAA,EACvC,CAAC;AACD,KAAG,KAAK;AAAA,IACJ,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC;AAAA,IACnC,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC;AAAA,EACvC,CAAC;AACD,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,OAAG,KAAK;AAAA,MACJ,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC;AAAA,MACnC,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC;AAAA,IACvC,CAAC;AACD,QAAI,MAAO,OAAO,SAAS,GAAI;AAC3B,SAAG,KAAK;AAAA,QACJ,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC;AAAA,QACnC,OAAO,CAAC,EAAE,CAAC,IAAI,WAAW,QAAQ,CAAC;AAAA,MACvC,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO,OAAO,IAAI,MAAM,CAAC;AAC7B;AACA,SAAS,OAAO,QAAQ,YAAY,GAAG;AACnC,QAAM,MAAM,OAAO;AACnB,QAAM,MAAM,CAAC;AACb,MAAI,MAAM,GAAG;AACT,UAAMC,KAAI,CAAC;AACX,UAAM,IAAI,IAAI,EAAE;AAChB,QAAI,KAAK,EAAE,IAAI,QAAQ,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;AAC3D,aAAS,IAAI,GAAI,IAAI,IAAK,KAAK,KAAK;AAChC,YAAM,kBAAkB,OAAO,CAAC;AAChC,MAAAA,GAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,GAAG,gBAAgB,CAAC,CAAC;AAC9C,MAAAA,GAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,gBAAgB,CAAC,KAAK,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC;AACtJ,MAAAA,GAAE,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,IAAI,OAAO,CAAC,EAAE,CAAC,IAAI,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,IAAI,OAAO,CAAC,EAAE,CAAC,IAAI,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC;AAC1I,MAAAA,GAAE,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC;AAC1C,UAAI,KAAK,EAAE,IAAI,YAAY,MAAM,CAACA,GAAE,CAAC,EAAE,CAAC,GAAGA,GAAE,CAAC,EAAE,CAAC,GAAGA,GAAE,CAAC,EAAE,CAAC,GAAGA,GAAE,CAAC,EAAE,CAAC,GAAGA,GAAE,CAAC,EAAE,CAAC,GAAGA,GAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;AAAA,IAC7F;AACA,QAAI,cAAc,WAAW,WAAW,GAAG;AACvC,YAAM,KAAK,EAAE;AACb,UAAI,KAAK,EAAE,IAAI,UAAU,MAAM,CAAC,WAAW,CAAC,IAAI,WAAW,IAAI,CAAC,GAAG,WAAW,CAAC,IAAI,WAAW,IAAI,CAAC,CAAC,EAAE,CAAC;AAAA,IAC3G;AAAA,EACJ,WACS,QAAQ,GAAG;AAChB,QAAI,KAAK,EAAE,IAAI,QAAQ,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;AAC3D,QAAI,KAAK;AAAA,MACL,IAAI;AAAA,MACJ,MAAM;AAAA,QACF,OAAO,CAAC,EAAE,CAAC;AAAA,QAAG,OAAO,CAAC,EAAE,CAAC;AAAA,QACzB,OAAO,CAAC,EAAE,CAAC;AAAA,QAAG,OAAO,CAAC,EAAE,CAAC;AAAA,QACzB,OAAO,CAAC,EAAE,CAAC;AAAA,QAAG,OAAO,CAAC,EAAE,CAAC;AAAA,MAC7B;AAAA,IACJ,CAAC;AAAA,EACL,WACS,QAAQ,GAAG;AAChB,QAAI,KAAK,GAAG,YAAY,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;AAAA,EACtF;AACA,SAAO;AACX;AACA,SAAS,sBAAsB,WAAW,IAAI,IAAI,IAAI,IAAI,QAAQ,SAAS,GAAG;AAC1E,QAAM,WAAW,EAAE,cAAc;AACjC,QAAM,aAAa,CAAC;AACpB,QAAM,YAAY,CAAC;AACnB,MAAI,UAAU;AACV,gBAAY,YAAY;AACxB,cAAU,KAAK;AAAA,MACX,KAAK,KAAK,KAAK,IAAI,CAAC,SAAS;AAAA,MAC7B,KAAK,KAAK,KAAK,IAAI,CAAC,SAAS;AAAA,IACjC,CAAC;AACD,aAAS,QAAQ,GAAG,SAAS,KAAK,KAAK,GAAG,QAAQ,QAAQ,WAAW;AACjE,YAAM,IAAI;AAAA,QACN,KAAK,KAAK,KAAK,IAAI,KAAK;AAAA,QACxB,KAAK,KAAK,KAAK,IAAI,KAAK;AAAA,MAC5B;AACA,iBAAW,KAAK,CAAC;AACjB,gBAAU,KAAK,CAAC;AAAA,IACpB;AACA,cAAU,KAAK;AAAA,MACX,KAAK,KAAK,KAAK,IAAI,CAAC;AAAA,MACpB,KAAK,KAAK,KAAK,IAAI,CAAC;AAAA,IACxB,CAAC;AACD,cAAU,KAAK;AAAA,MACX,KAAK,KAAK,KAAK,IAAI,SAAS;AAAA,MAC5B,KAAK,KAAK,KAAK,IAAI,SAAS;AAAA,IAChC,CAAC;AAAA,EACL,OACK;AACD,UAAM,YAAY,WAAW,KAAK,CAAC,IAAK,KAAK,KAAK;AAClD,cAAU,KAAK;AAAA,MACX,WAAW,QAAQ,CAAC,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI,YAAY,SAAS;AAAA,MACtE,WAAW,QAAQ,CAAC,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI,YAAY,SAAS;AAAA,IAC1E,CAAC;AACD,UAAM,WAAW,KAAK,KAAK,IAAI,YAAY;AAC3C,aAAS,QAAQ,WAAW,QAAQ,UAAU,QAAQ,QAAQ,WAAW;AACrE,YAAM,IAAI;AAAA,QACN,WAAW,QAAQ,CAAC,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK;AAAA,QAChD,WAAW,QAAQ,CAAC,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK;AAAA,MACpD;AACA,iBAAW,KAAK,CAAC;AACjB,gBAAU,KAAK,CAAC;AAAA,IACpB;AACA,cAAU,KAAK;AAAA,MACX,WAAW,QAAQ,CAAC,IAAI,KAAK,KAAK,KAAK,IAAI,YAAY,KAAK,KAAK,IAAI,UAAU,GAAG;AAAA,MAClF,WAAW,QAAQ,CAAC,IAAI,KAAK,KAAK,KAAK,IAAI,YAAY,KAAK,KAAK,IAAI,UAAU,GAAG;AAAA,IACtF,CAAC;AACD,cAAU,KAAK;AAAA,MACX,WAAW,QAAQ,CAAC,IAAI,KAAK,OAAO,KAAK,KAAK,IAAI,YAAY,OAAO;AAAA,MACrE,WAAW,QAAQ,CAAC,IAAI,KAAK,OAAO,KAAK,KAAK,IAAI,YAAY,OAAO;AAAA,IACzE,CAAC;AACD,cAAU,KAAK;AAAA,MACX,WAAW,QAAQ,CAAC,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI,YAAY,UAAU,GAAG;AAAA,MAC1E,WAAW,QAAQ,CAAC,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI,YAAY,UAAU,GAAG;AAAA,IAC9E,CAAC;AAAA,EACL;AACA,SAAO,CAAC,WAAW,UAAU;AACjC;AACA,SAAS,KAAK,WAAW,IAAI,IAAI,IAAI,IAAI,MAAM,KAAK,QAAQ,GAAG;AAC3D,QAAM,YAAY,OAAO,WAAW,KAAK,CAAC;AAC1C,QAAM,SAAS,CAAC;AAChB,SAAO,KAAK;AAAA,IACR,WAAW,QAAQ,CAAC,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI,YAAY,SAAS;AAAA,IACtE,WAAW,QAAQ,CAAC,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI,YAAY,SAAS;AAAA,EAC1E,CAAC;AACD,WAAS,QAAQ,WAAW,SAAS,KAAK,QAAQ,QAAQ,WAAW;AACjE,WAAO,KAAK;AAAA,MACR,WAAW,QAAQ,CAAC,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK;AAAA,MAChD,WAAW,QAAQ,CAAC,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK;AAAA,IACpD,CAAC;AAAA,EACL;AACA,SAAO,KAAK;AAAA,IACR,KAAK,KAAK,KAAK,IAAI,GAAG;AAAA,IACtB,KAAK,KAAK,KAAK,IAAI,GAAG;AAAA,EAC1B,CAAC;AACD,SAAO,KAAK;AAAA,IACR,KAAK,KAAK,KAAK,IAAI,GAAG;AAAA,IACtB,KAAK,KAAK,KAAK,IAAI,GAAG;AAAA,EAC1B,CAAC;AACD,SAAO,OAAO,QAAQ,MAAM,CAAC;AACjC;AACA,SAAS,UAAU,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,SAAS,GAAG;AACjD,QAAM,MAAM,CAAC;AACb,QAAM,MAAM,CAAC,EAAE,uBAAuB,IAAI,EAAE,uBAAuB,KAAK,GAAG;AAC3E,MAAI,IAAI,CAAC,GAAG,CAAC;AACb,QAAM,aAAa,EAAE,qBAAqB,IAAI;AAC9C,QAAM,mBAAmB,EAAE;AAC3B,WAAS,IAAI,GAAG,IAAI,YAAY,KAAK;AACjC,QAAI,MAAM,GAAG;AACT,UAAI,KAAK,EAAE,IAAI,QAAQ,MAAM,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC,CAAC,EAAE,CAAC;AAAA,IAC3D,OACK;AACD,UAAI,KAAK,EAAE,IAAI,QAAQ,MAAM,CAAC,QAAQ,CAAC,KAAK,mBAAmB,IAAI,WAAW,IAAI,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,KAAK,mBAAmB,IAAI,WAAW,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC;AAAA,IAC7J;AACA,QAAI,mBAAmB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,WAAW,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,WAAW,IAAI,CAAC,GAAG,CAAC,CAAC;AACrF,QAAI,KAAK;AAAA,MACL,IAAI;AAAA,MACJ,MAAM;AAAA,QACF,KAAK,WAAW,IAAI,CAAC,GAAG,CAAC;AAAA,QAAG,KAAK,WAAW,IAAI,CAAC,GAAG,CAAC;AAAA,QACrD,KAAK,WAAW,IAAI,CAAC,GAAG,CAAC;AAAA,QAAG,KAAK,WAAW,IAAI,CAAC,GAAG,CAAC;AAAA,QACrD,EAAE,CAAC;AAAA,QAAG,EAAE,CAAC;AAAA,MACb;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO;AACX;;;AgB/cA;AAAA,SAAS,MAAM,GAAG;AACd,SAAO,CAAC,GAAG,CAAC;AAChB;AACO,SAAS,cAAc,UAAU,iBAAiB,GAAG;AACxD,QAAM,MAAM,SAAS;AACrB,MAAI,MAAM,GAAG;AACT,UAAM,IAAI,MAAM,0CAA0C;AAAA,EAC9D;AACA,QAAM,MAAM,CAAC;AACb,MAAI,QAAQ,GAAG;AACX,QAAI,KAAK,MAAM,SAAS,CAAC,CAAC,GAAG,MAAM,SAAS,CAAC,CAAC,GAAG,MAAM,SAAS,CAAC,CAAC,GAAG,MAAM,SAAS,CAAC,CAAC,CAAC;AAAA,EAC3F,OACK;AACD,UAAM,SAAS,CAAC;AAChB,WAAO,KAAK,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;AACpC,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,aAAO,KAAK,SAAS,CAAC,CAAC;AACvB,UAAI,MAAO,SAAS,SAAS,GAAI;AAC7B,eAAO,KAAK,SAAS,CAAC,CAAC;AAAA,MAC3B;AAAA,IACJ;AACA,UAAMC,KAAI,CAAC;AACX,UAAM,IAAI,IAAI;AACd,QAAI,KAAK,MAAM,OAAO,CAAC,CAAC,CAAC;AACzB,aAAS,IAAI,GAAI,IAAI,IAAK,OAAO,QAAQ,KAAK;AAC1C,YAAM,kBAAkB,OAAO,CAAC;AAChC,MAAAA,GAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,GAAG,gBAAgB,CAAC,CAAC;AAC9C,MAAAA,GAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,gBAAgB,CAAC,KAAK,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC;AACtJ,MAAAA,GAAE,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,IAAI,OAAO,CAAC,EAAE,CAAC,IAAI,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,IAAI,OAAO,CAAC,EAAE,CAAC,IAAI,IAAI,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC;AAC1I,MAAAA,GAAE,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC;AAC1C,UAAI,KAAKA,GAAE,CAAC,GAAGA,GAAE,CAAC,GAAGA,GAAE,CAAC,CAAC;AAAA,IAC7B;AAAA,EACJ;AACA,SAAO;AACX;;;AClCA;AACA,SAAS,SAAS,IAAI,IAAI;AACtB,SAAO,KAAK,KAAK,WAAW,IAAI,EAAE,CAAC;AACvC;AAEA,SAAS,WAAW,IAAI,IAAI;AACxB,SAAO,KAAK,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC;AACjE;AAEA,SAAS,oBAAoB,GAAG,GAAG,GAAG;AAClC,QAAM,KAAK,WAAW,GAAG,CAAC;AAC1B,MAAI,OAAO,GAAG;AACV,WAAO,WAAW,GAAG,CAAC;AAAA,EAC1B;AACA,MAAI,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,MAAM;AAC1E,MAAI,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,CAAC,CAAC;AAC9B,SAAO,WAAW,GAAG,KAAK,GAAG,GAAG,CAAC,CAAC;AACtC;AACA,SAAS,KAAKC,IAAGC,IAAG,GAAG;AACnB,SAAO;AAAA,IACHD,GAAE,CAAC,KAAKC,GAAE,CAAC,IAAID,GAAE,CAAC,KAAK;AAAA,IACvBA,GAAE,CAAC,KAAKC,GAAE,CAAC,IAAID,GAAE,CAAC,KAAK;AAAA,EAC3B;AACJ;AAEA,SAAS,SAAS,QAAQ,QAAQ;AAC9B,QAAM,KAAK,OAAO,SAAS,CAAC;AAC5B,QAAM,KAAK,OAAO,SAAS,CAAC;AAC5B,QAAM,KAAK,OAAO,SAAS,CAAC;AAC5B,QAAM,KAAK,OAAO,SAAS,CAAC;AAC5B,MAAI,KAAK,IAAI,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC;AACrC,QAAM;AACN,MAAI,KAAK,IAAI,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC;AACrC,QAAM;AACN,MAAI,KAAK,IAAI,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC;AACrC,QAAM;AACN,MAAI,KAAK,IAAI,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC;AACrC,QAAM;AACN,MAAI,KAAK,IAAI;AACT,SAAK;AAAA,EACT;AACA,MAAI,KAAK,IAAI;AACT,SAAK;AAAA,EACT;AACA,SAAO,KAAK;AAChB;AACA,SAAS,oCAAoC,QAAQ,QAAQ,WAAW,WAAW;AAC/E,QAAM,YAAY,aAAa,CAAC;AAChC,MAAI,SAAS,QAAQ,MAAM,IAAI,WAAW;AACtC,UAAM,KAAK,OAAO,SAAS,CAAC;AAC5B,QAAI,UAAU,QAAQ;AAClB,YAAM,IAAI,SAAS,UAAU,UAAU,SAAS,CAAC,GAAG,EAAE;AACtD,UAAI,IAAI,GAAG;AACP,kBAAU,KAAK,EAAE;AAAA,MACrB;AAAA,IACJ,OACK;AACD,gBAAU,KAAK,EAAE;AAAA,IACrB;AACA,cAAU,KAAK,OAAO,SAAS,CAAC,CAAC;AAAA,EACrC,OACK;AAED,UAAM,IAAI;AACV,UAAM,KAAK,OAAO,SAAS,CAAC;AAC5B,UAAM,KAAK,OAAO,SAAS,CAAC;AAC5B,UAAM,KAAK,OAAO,SAAS,CAAC;AAC5B,UAAM,KAAK,OAAO,SAAS,CAAC;AAC5B,UAAM,KAAK,KAAK,IAAI,IAAI,CAAC;AACzB,UAAM,KAAK,KAAK,IAAI,IAAI,CAAC;AACzB,UAAM,KAAK,KAAK,IAAI,IAAI,CAAC;AACzB,UAAM,KAAK,KAAK,IAAI,IAAI,CAAC;AACzB,UAAM,KAAK,KAAK,IAAI,IAAI,CAAC;AACzB,UAAM,MAAM,KAAK,IAAI,IAAI,CAAC;AAC1B,wCAAoC,CAAC,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,WAAW,SAAS;AAC9E,wCAAoC,CAAC,KAAK,IAAI,IAAI,EAAE,GAAG,GAAG,WAAW,SAAS;AAAA,EAClF;AACA,SAAO;AACX;AACO,SAAS,SAAS,QAAQE,WAAU;AACvC,SAAO,eAAe,QAAQ,GAAG,OAAO,QAAQA,SAAQ;AAC5D;AAGA,SAAS,eAAe,QAAQ,OAAO,KAAK,SAAS,WAAW;AAC5D,QAAM,YAAY,aAAa,CAAC;AAEhC,QAAM,IAAI,OAAO,KAAK;AACtB,QAAM,IAAI,OAAO,MAAM,CAAC;AACxB,MAAI,YAAY;AAChB,MAAI,SAAS;AACb,WAAS,IAAI,QAAQ,GAAG,IAAI,MAAM,GAAG,EAAE,GAAG;AACtC,UAAM,SAAS,oBAAoB,OAAO,CAAC,GAAG,GAAG,CAAC;AAClD,QAAI,SAAS,WAAW;AACpB,kBAAY;AACZ,eAAS;AAAA,IACb;AAAA,EACJ;AAEA,MAAI,KAAK,KAAK,SAAS,IAAI,SAAS;AAChC,mBAAe,QAAQ,OAAO,SAAS,GAAG,SAAS,SAAS;AAC5D,mBAAe,QAAQ,QAAQ,KAAK,SAAS,SAAS;AAAA,EAC1D,OACK;AACD,QAAI,CAAC,UAAU,QAAQ;AACnB,gBAAU,KAAK,CAAC;AAAA,IACpB;AACA,cAAU,KAAK,CAAC;AAAA,EACpB;AACA,SAAO;AACX;AACO,SAAS,qBAAqB,QAAQ,YAAY,MAAMA,WAAU;AACrE,QAAM,YAAY,CAAC;AACnB,QAAM,eAAe,OAAO,SAAS,KAAK;AAC1C,WAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AAClC,UAAM,SAAS,IAAI;AACnB,wCAAoC,QAAQ,QAAQ,WAAW,SAAS;AAAA,EAC5E;AACA,MAAIA,aAAYA,YAAW,GAAG;AAC1B,WAAO,eAAe,WAAW,GAAG,UAAU,QAAQA,SAAQ;AAAA,EAClE;AACA,SAAO;AACX;;;AC1HA;AAEO,SAAS,aAAa,MAAM,WAAWC,WAAU;AACpD,QAAM,WAAW,UAAU,IAAI;AAC/B,QAAM,aAAa,UAAU,WAAW,QAAQ,CAAC;AACjD,QAAM,OAAO,CAAC;AACd,MAAI,gBAAgB,CAAC;AACrB,MAAI,QAAQ,CAAC,GAAG,CAAC;AACjB,MAAI,eAAe,CAAC;AACpB,QAAM,qBAAqB,MAAM;AAC7B,QAAI,aAAa,UAAU,GAAG;AAC1B,oBAAc,KAAK,GAAG,qBAAqB,cAAc,SAAS,CAAC;AAAA,IACvE;AACA,mBAAe,CAAC;AAAA,EACpB;AACA,QAAM,sBAAsB,MAAM;AAC9B,uBAAmB;AACnB,QAAI,cAAc,QAAQ;AACtB,WAAK,KAAK,aAAa;AACvB,sBAAgB,CAAC;AAAA,IACrB;AAAA,EACJ;AACA,aAAW,EAAE,KAAK,KAAK,KAAK,YAAY;AACpC,YAAQ,KAAK;AAAA,MACT,KAAK;AACD,4BAAoB;AACpB,gBAAQ,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACzB,sBAAc,KAAK,KAAK;AACxB;AAAA,MACJ,KAAK;AACD,2BAAmB;AACnB,sBAAc,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;AACrC;AAAA,MACJ,KAAK;AACD,YAAI,CAAC,aAAa,QAAQ;AACtB,gBAAM,YAAY,cAAc,SAAS,cAAc,cAAc,SAAS,CAAC,IAAI;AACnF,uBAAa,KAAK,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC;AAAA,QAClD;AACA,qBAAa,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;AACpC,qBAAa,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;AACpC,qBAAa,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;AACpC;AAAA,MACJ,KAAK;AACD,2BAAmB;AACnB,sBAAc,KAAK,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC;AACvC;AAAA,IACR;AAAA,EACJ;AACA,sBAAoB;AACpB,MAAI,CAACA,WAAU;AACX,WAAO;AAAA,EACX;AACA,QAAM,MAAM,CAAC;AACb,aAAW,OAAO,MAAM;AACpB,UAAM,gBAAgB,SAAS,KAAKA,SAAQ;AAC5C,QAAI,cAAc,QAAQ;AACtB,UAAI,KAAK,aAAa;AAAA,IAC1B;AAAA,EACJ;AACA,SAAO;AACX;;;AnBvDA,IAAM,MAAM;AACL,IAAM,iBAAN,MAAqB;AAAA,EACxB,YAAY,QAAQ;AAChB,SAAK,iBAAiB;AAAA,MAClB,qBAAqB;AAAA,MACrB,WAAW;AAAA,MACX,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,aAAa;AAAA,MACb,gBAAgB;AAAA,MAChB,cAAc;AAAA,MACd,gBAAgB;AAAA,MAChB,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,cAAc;AAAA,MACd,MAAM;AAAA,MACN,oBAAoB;AAAA,MACpB,wBAAwB;AAAA,MACxB,kBAAkB;AAAA,MAClB,wBAAwB;AAAA,IAC5B;AACA,SAAK,SAAS,UAAU,CAAC;AACzB,QAAI,KAAK,OAAO,SAAS;AACrB,WAAK,iBAAiB,KAAK,GAAG,KAAK,OAAO,OAAO;AAAA,IACrD;AAAA,EACJ;AAAA,EACA,OAAO,UAAU;AACb,WAAO,WAAW;AAAA,EACtB;AAAA,EACA,GAAG,SAAS;AACR,WAAO,UAAU,OAAO,OAAO,CAAC,GAAG,KAAK,gBAAgB,OAAO,IAAI,KAAK;AAAA,EAC5E;AAAA,EACA,GAAG,OAAO,MAAM,SAAS;AACrB,WAAO,EAAE,OAAO,MAAM,QAAQ,CAAC,GAAG,SAAS,WAAW,KAAK,eAAe;AAAA,EAC9E;AAAA,EACA,KAAK,IAAI,IAAI,IAAI,IAAI,SAAS;AAC1B,UAAM,IAAI,KAAK,GAAG,OAAO;AACzB,WAAO,KAAK,GAAG,QAAQ,CAAC,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC;AAAA,EACvD;AAAA,EACA,UAAU,GAAG,GAAG,OAAO,QAAQ,SAAS;AACpC,UAAM,IAAI,KAAK,GAAG,OAAO;AACzB,UAAM,QAAQ,CAAC;AACf,UAAM,UAAU,UAAU,GAAG,GAAG,OAAO,QAAQ,CAAC;AAChD,QAAI,EAAE,MAAM;AACR,YAAM,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,OAAO,IAAI,MAAM,GAAG,CAAC,GAAG,IAAI,MAAM,CAAC;AAChF,UAAI,EAAE,cAAc,SAAS;AACzB,cAAM,KAAK,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC;AAAA,MAC5C,OACK;AACD,cAAM,KAAK,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAC;AAAA,MAC/C;AAAA,IACJ;AACA,QAAI,EAAE,WAAW,KAAK;AAClB,YAAM,KAAK,OAAO;AAAA,IACtB;AACA,WAAO,KAAK,GAAG,aAAa,OAAO,CAAC;AAAA,EACxC;AAAA,EACA,QAAQ,GAAG,GAAG,OAAO,QAAQ,SAAS;AAClC,UAAM,IAAI,KAAK,GAAG,OAAO;AACzB,UAAM,QAAQ,CAAC;AACf,UAAM,gBAAgB,sBAAsB,OAAO,QAAQ,CAAC;AAC5D,UAAM,kBAAkB,kBAAkB,GAAG,GAAG,GAAG,aAAa;AAChE,QAAI,EAAE,MAAM;AACR,UAAI,EAAE,cAAc,SAAS;AACzB,cAAM,QAAQ,kBAAkB,GAAG,GAAG,GAAG,aAAa,EAAE;AACxD,cAAM,OAAO;AACb,cAAM,KAAK,KAAK;AAAA,MACpB,OACK;AACD,cAAM,KAAK,oBAAoB,CAAC,gBAAgB,eAAe,GAAG,CAAC,CAAC;AAAA,MACxE;AAAA,IACJ;AACA,QAAI,EAAE,WAAW,KAAK;AAClB,YAAM,KAAK,gBAAgB,KAAK;AAAA,IACpC;AACA,WAAO,KAAK,GAAG,WAAW,OAAO,CAAC;AAAA,EACtC;AAAA,EACA,OAAO,GAAG,GAAG,UAAU,SAAS;AAC5B,UAAM,MAAM,KAAK,QAAQ,GAAG,GAAG,UAAU,UAAU,OAAO;AAC1D,QAAI,QAAQ;AACZ,WAAO;AAAA,EACX;AAAA,EACA,WAAW,QAAQ,SAAS;AACxB,UAAM,IAAI,KAAK,GAAG,OAAO;AACzB,WAAO,KAAK,GAAG,cAAc,CAAC,WAAW,QAAQ,OAAO,CAAC,CAAC,GAAG,CAAC;AAAA,EAClE;AAAA,EACA,IAAI,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,SAAS,OAAO,SAAS;AAC3D,UAAM,IAAI,KAAK,GAAG,OAAO;AACzB,UAAM,QAAQ,CAAC;AACf,UAAM,UAAU,IAAI,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,QAAQ,MAAM,CAAC;AACrE,QAAI,UAAU,EAAE,MAAM;AAClB,UAAI,EAAE,cAAc,SAAS;AACzB,cAAM,cAAc,OAAO,OAAO,CAAC,GAAG,CAAC;AACvC,oBAAY,qBAAqB;AACjC,cAAM,QAAQ,IAAI,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,MAAM,OAAO,WAAW;AAC5E,cAAM,OAAO;AACb,cAAM,KAAK,KAAK;AAAA,MACpB,OACK;AACD,cAAM,KAAK,eAAe,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,CAAC,CAAC;AAAA,MAClE;AAAA,IACJ;AACA,QAAI,EAAE,WAAW,KAAK;AAClB,YAAM,KAAK,OAAO;AAAA,IACtB;AACA,WAAO,KAAK,GAAG,OAAO,OAAO,CAAC;AAAA,EAClC;AAAA,EACA,MAAM,QAAQ,SAAS;AACnB,UAAM,IAAI,KAAK,GAAG,OAAO;AACzB,UAAM,QAAQ,CAAC;AACf,UAAM,UAAU,MAAM,QAAQ,CAAC;AAC/B,QAAI,EAAE,QAAQ,EAAE,SAAS,OAAO,OAAO,UAAU,GAAG;AAChD,UAAI,EAAE,cAAc,SAAS;AACzB,cAAM,YAAY,MAAM,QAAQ,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,oBAAoB,MAAM,WAAW,EAAE,YAAa,EAAE,YAAY,EAAE,yBAA0B,EAAE,CAAC,CAAC;AACxK,cAAM,KAAK;AAAA,UACP,MAAM;AAAA,UACN,KAAK,KAAK,aAAa,UAAU,GAAG;AAAA,QACxC,CAAC;AAAA,MACL,OACK;AACD,cAAM,SAAS,cAAc,MAAM;AACnC,cAAM,aAAa,qBAAqB,QAAQ,KAAK,IAAI,EAAE,aAAa,CAAC;AACzE,cAAM,KAAK,oBAAoB,CAAC,UAAU,GAAG,CAAC,CAAC;AAAA,MACnD;AAAA,IACJ;AACA,QAAI,EAAE,WAAW,KAAK;AAClB,YAAM,KAAK,OAAO;AAAA,IACtB;AACA,WAAO,KAAK,GAAG,SAAS,OAAO,CAAC;AAAA,EACpC;AAAA,EACA,QAAQ,QAAQ,SAAS;AACrB,UAAM,IAAI,KAAK,GAAG,OAAO;AACzB,UAAM,QAAQ,CAAC;AACf,UAAM,UAAU,WAAW,QAAQ,MAAM,CAAC;AAC1C,QAAI,EAAE,MAAM;AACR,UAAI,EAAE,cAAc,SAAS;AACzB,cAAM,KAAK,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC;AAAA,MAC5C,OACK;AACD,cAAM,KAAK,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAC;AAAA,MAC/C;AAAA,IACJ;AACA,QAAI,EAAE,WAAW,KAAK;AAClB,YAAM,KAAK,OAAO;AAAA,IACtB;AACA,WAAO,KAAK,GAAG,WAAW,OAAO,CAAC;AAAA,EACtC;AAAA,EACA,KAAK,GAAG,SAAS;AACb,UAAM,IAAI,KAAK,GAAG,OAAO;AACzB,UAAM,QAAQ,CAAC;AACf,QAAI,CAAC,GAAG;AACJ,aAAO,KAAK,GAAG,QAAQ,OAAO,CAAC;AAAA,IACnC;AACA,SAAK,KAAK,IAAI,QAAQ,OAAO,GAAG,EAAE,QAAQ,UAAU,GAAG,EAAE,QAAQ,WAAa,GAAG;AACjF,UAAM,UAAU,EAAE,QAAQ,EAAE,SAAS,iBAAiB,EAAE,SAAS;AACjE,UAAM,YAAY,EAAE,WAAW;AAC/B,UAAM,aAAa,CAAC,EAAE,EAAE,kBAAmB,EAAE,iBAAiB;AAC9D,UAAMC,YAAW,aAAc,IAAI,KAAK,EAAE,kBAAkB,MAAQ,IAAI,EAAE,aAAa;AACvF,UAAM,OAAO,aAAa,GAAG,GAAGA,SAAQ;AACxC,UAAM,QAAQ,QAAQ,GAAG,CAAC;AAC1B,QAAI,SAAS;AACT,UAAI,EAAE,cAAc,SAAS;AACzB,YAAI,KAAK,WAAW,GAAG;AACnB,gBAAM,YAAY,QAAQ,GAAG,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,oBAAoB,MAAM,WAAW,EAAE,YAAa,EAAE,YAAY,EAAE,yBAA0B,EAAE,CAAC,CAAC;AACrK,gBAAM,KAAK;AAAA,YACP,MAAM;AAAA,YACN,KAAK,KAAK,aAAa,UAAU,GAAG;AAAA,UACxC,CAAC;AAAA,QACL,OACK;AACD,gBAAM,KAAK,iBAAiB,MAAM,CAAC,CAAC;AAAA,QACxC;AAAA,MACJ,OACK;AACD,cAAM,KAAK,oBAAoB,MAAM,CAAC,CAAC;AAAA,MAC3C;AAAA,IACJ;AACA,QAAI,WAAW;AACX,UAAI,YAAY;AACZ,aAAK,QAAQ,CAAC,QAAQ;AAClB,gBAAM,KAAK,WAAW,KAAK,OAAO,CAAC,CAAC;AAAA,QACxC,CAAC;AAAA,MACL,OACK;AACD,cAAM,KAAK,KAAK;AAAA,MACpB;AAAA,IACJ;AACA,WAAO,KAAK,GAAG,QAAQ,OAAO,CAAC;AAAA,EACnC;AAAA,EACA,UAAU,SAAS,eAAe;AAC9B,QAAI,OAAO;AACX,eAAW,QAAQ,QAAQ,KAAK;AAC5B,YAAM,OAAS,OAAO,kBAAkB,YAAa,iBAAiB,IAAM,KAAK,KAAK,IAAI,CAAC,MAAM,CAAC,EAAE,QAAQ,aAAa,CAAC,IAAK,KAAK;AACpI,cAAQ,KAAK,IAAI;AAAA,QACb,KAAK;AACD,kBAAQ,IAAI,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC;AAC9B;AAAA,QACJ,KAAK;AACD,kBAAQ,IAAI,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC;AAC5E;AAAA,QACJ,KAAK;AACD,kBAAQ,IAAI,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC;AAC9B;AAAA,MACR;AAAA,IACJ;AACA,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA,EACA,QAAQ,UAAU;AACd,UAAM,OAAO,SAAS,QAAQ,CAAC;AAC/B,UAAM,IAAI,SAAS,WAAW,KAAK;AACnC,UAAM,QAAQ,CAAC;AACf,eAAW,WAAW,MAAM;AACxB,UAAI,OAAO;AACX,cAAQ,QAAQ,MAAM;AAAA,QAClB,KAAK;AACD,iBAAO;AAAA,YACH,GAAG,KAAK,UAAU,OAAO;AAAA,YACzB,QAAQ,EAAE;AAAA,YACV,aAAa,EAAE;AAAA,YACf,MAAM;AAAA,UACV;AACA;AAAA,QACJ,KAAK;AACD,iBAAO;AAAA,YACH,GAAG,KAAK,UAAU,OAAO;AAAA,YACzB,QAAQ;AAAA,YACR,aAAa;AAAA,YACb,MAAM,EAAE,QAAQ;AAAA,UACpB;AACA;AAAA,QACJ,KAAK;AACD,iBAAO,KAAK,WAAW,SAAS,CAAC;AACjC;AAAA,MACR;AACA,UAAI,MAAM;AACN,cAAM,KAAK,IAAI;AAAA,MACnB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW,SAAS,GAAG;AACnB,QAAI,UAAU,EAAE;AAChB,QAAI,UAAU,GAAG;AACb,gBAAU,EAAE,cAAc;AAAA,IAC9B;AACA,WAAO;AAAA,MACH,GAAG,KAAK,UAAU,OAAO;AAAA,MACzB,QAAQ,EAAE,QAAQ;AAAA,MAClB,aAAa;AAAA,MACb,MAAM;AAAA,IACV;AAAA,EACJ;AAAA,EACA,aAAa,OAAO;AAChB,WAAO,MAAM,OAAO,CAAC,GAAG,MAAM;AAC1B,UAAI,MAAM,GAAG;AACT,eAAO;AAAA,MACX;AACA,UAAI,EAAE,OAAO,QAAQ;AACjB,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX,CAAC;AAAA,EACL;AACJ;;;AD/QO,IAAM,cAAN,MAAkB;AAAA,EACrB,YAAY,QAAQ,QAAQ;AACxB,SAAK,SAAS;AACd,SAAK,MAAM,KAAK,OAAO,WAAW,IAAI;AACtC,SAAK,MAAM,IAAI,eAAe,MAAM;AAAA,EACxC;AAAA,EACA,KAAK,UAAU;AACX,UAAM,OAAO,SAAS,QAAQ,CAAC;AAC/B,UAAM,IAAI,SAAS,WAAW,KAAK,kBAAkB;AACrD,UAAM,MAAM,KAAK;AACjB,UAAM,YAAY,SAAS,QAAQ;AACnC,eAAW,WAAW,MAAM;AACxB,cAAQ,QAAQ,MAAM;AAAA,QAClB,KAAK;AACD,cAAI,KAAK;AACT,cAAI,cAAc,EAAE,WAAW,SAAS,gBAAgB,EAAE;AAC1D,cAAI,YAAY,EAAE;AAClB,cAAI,EAAE,gBAAgB;AAClB,gBAAI,YAAY,EAAE,cAAc;AAAA,UACpC;AACA,cAAI,EAAE,sBAAsB;AACxB,gBAAI,iBAAiB,EAAE;AAAA,UAC3B;AACA,eAAK,eAAe,KAAK,SAAS,SAAS;AAC3C,cAAI,QAAQ;AACZ;AAAA,QACJ,KAAK,YAAY;AACb,cAAI,KAAK;AACT,cAAI,YAAY,EAAE,QAAQ;AAC1B,gBAAM,WAAY,SAAS,UAAU,WAAW,SAAS,UAAU,aAAa,SAAS,UAAU,SAAU,YAAY;AACzH,eAAK,eAAe,KAAK,SAAS,WAAW,QAAQ;AACrD,cAAI,QAAQ;AACZ;AAAA,QACJ;AAAA,QACA,KAAK;AACD,eAAK,WAAW,KAAK,SAAS,CAAC;AAC/B;AAAA,MACR;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,WAAW,KAAK,SAAS,GAAG;AACxB,QAAI,UAAU,EAAE;AAChB,QAAI,UAAU,GAAG;AACb,gBAAU,EAAE,cAAc;AAAA,IAC9B;AACA,QAAI,KAAK;AACT,QAAI,EAAE,cAAc;AAChB,UAAI,YAAY,EAAE,YAAY;AAAA,IAClC;AACA,QAAI,EAAE,oBAAoB;AACtB,UAAI,iBAAiB,EAAE;AAAA,IAC3B;AACA,QAAI,cAAc,EAAE,QAAQ;AAC5B,QAAI,YAAY;AAChB,SAAK,eAAe,KAAK,SAAS,EAAE,uBAAuB;AAC3D,QAAI,QAAQ;AAAA,EAChB;AAAA,EACA,eAAe,KAAK,SAAS,eAAe,OAAO,WAAW;AAC1D,QAAI,UAAU;AACd,eAAW,QAAQ,QAAQ,KAAK;AAC5B,YAAM,OAAS,OAAO,kBAAkB,YAAa,iBAAiB,IAAM,KAAK,KAAK,IAAI,CAAC,MAAM,CAAC,EAAE,QAAQ,aAAa,CAAC,IAAK,KAAK;AACpI,cAAQ,KAAK,IAAI;AAAA,QACb,KAAK;AACD,cAAI,OAAO,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAC3B;AAAA,QACJ,KAAK;AACD,cAAI,cAAc,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACtE;AAAA,QACJ,KAAK;AACD,cAAI,OAAO,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAC3B;AAAA,MACR;AAAA,IACJ;AACA,QAAI,QAAQ,SAAS,YAAY;AAC7B,UAAI,KAAK,IAAI;AAAA,IACjB,OACK;AACD,UAAI,OAAO;AAAA,IACf;AAAA,EACJ;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,oBAAoB;AAChB,WAAO,KAAK,IAAI;AAAA,EACpB;AAAA,EACA,KAAK,IAAI,IAAI,IAAI,IAAI,SAAS;AAC1B,UAAM,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI,IAAI,OAAO;AAC/C,SAAK,KAAK,CAAC;AACX,WAAO;AAAA,EACX;AAAA,EACA,UAAU,GAAG,GAAG,OAAO,QAAQ,SAAS;AACpC,UAAM,IAAI,KAAK,IAAI,UAAU,GAAG,GAAG,OAAO,QAAQ,OAAO;AACzD,SAAK,KAAK,CAAC;AACX,WAAO;AAAA,EACX;AAAA,EACA,QAAQ,GAAG,GAAG,OAAO,QAAQ,SAAS;AAClC,UAAM,IAAI,KAAK,IAAI,QAAQ,GAAG,GAAG,OAAO,QAAQ,OAAO;AACvD,SAAK,KAAK,CAAC;AACX,WAAO;AAAA,EACX;AAAA,EACA,OAAO,GAAG,GAAG,UAAU,SAAS;AAC5B,UAAM,IAAI,KAAK,IAAI,OAAO,GAAG,GAAG,UAAU,OAAO;AACjD,SAAK,KAAK,CAAC;AACX,WAAO;AAAA,EACX;AAAA,EACA,WAAW,QAAQ,SAAS;AACxB,UAAM,IAAI,KAAK,IAAI,WAAW,QAAQ,OAAO;AAC7C,SAAK,KAAK,CAAC;AACX,WAAO;AAAA,EACX;AAAA,EACA,QAAQ,QAAQ,SAAS;AACrB,UAAM,IAAI,KAAK,IAAI,QAAQ,QAAQ,OAAO;AAC1C,SAAK,KAAK,CAAC;AACX,WAAO;AAAA,EACX;AAAA,EACA,IAAI,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,SAAS,OAAO,SAAS;AAC3D,UAAM,IAAI,KAAK,IAAI,IAAI,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,QAAQ,OAAO;AACxE,SAAK,KAAK,CAAC;AACX,WAAO;AAAA,EACX;AAAA,EACA,MAAM,QAAQ,SAAS;AACnB,UAAM,IAAI,KAAK,IAAI,MAAM,QAAQ,OAAO;AACxC,SAAK,KAAK,CAAC;AACX,WAAO;AAAA,EACX;AAAA,EACA,KAAK,GAAG,SAAS;AACb,UAAM,UAAU,KAAK,IAAI,KAAK,GAAG,OAAO;AACxC,SAAK,KAAK,OAAO;AACjB,WAAO;AAAA,EACX;AACJ;;;AqBpIA;;;ACAA;AAAO,IAAM,QAAQ;;;ADEd,IAAM,WAAN,MAAe;AAAA,EAClB,YAAY,KAAK,QAAQ;AACrB,SAAK,MAAM;AACX,SAAK,MAAM,IAAI,eAAe,MAAM;AAAA,EACxC;AAAA,EACA,KAAK,UAAU;AACX,UAAM,OAAO,SAAS,QAAQ,CAAC;AAC/B,UAAM,IAAI,SAAS,WAAW,KAAK,kBAAkB;AACrD,UAAM,MAAM,KAAK,IAAI,iBAAiB,OAAO;AAC7C,UAAM,IAAI,IAAI,gBAAgB,OAAO,GAAG;AACxC,UAAM,YAAY,SAAS,QAAQ;AACnC,eAAW,WAAW,MAAM;AACxB,UAAI,OAAO;AACX,cAAQ,QAAQ,MAAM;AAAA,QAClB,KAAK,QAAQ;AACT,iBAAO,IAAI,gBAAgB,OAAO,MAAM;AACxC,eAAK,aAAa,KAAK,KAAK,UAAU,SAAS,SAAS,CAAC;AACzD,eAAK,aAAa,UAAU,EAAE,MAAM;AACpC,eAAK,aAAa,gBAAgB,EAAE,cAAc,EAAE;AACpD,eAAK,aAAa,QAAQ,MAAM;AAChC,cAAI,EAAE,gBAAgB;AAClB,iBAAK,aAAa,oBAAoB,EAAE,eAAe,KAAK,GAAG,EAAE,KAAK,CAAC;AAAA,UAC3E;AACA,cAAI,EAAE,sBAAsB;AACxB,iBAAK,aAAa,qBAAqB,GAAG,EAAE,oBAAoB,EAAE;AAAA,UACtE;AACA;AAAA,QACJ;AAAA,QACA,KAAK,YAAY;AACb,iBAAO,IAAI,gBAAgB,OAAO,MAAM;AACxC,eAAK,aAAa,KAAK,KAAK,UAAU,SAAS,SAAS,CAAC;AACzD,eAAK,aAAa,UAAU,MAAM;AAClC,eAAK,aAAa,gBAAgB,GAAG;AACrC,eAAK,aAAa,QAAQ,EAAE,QAAQ,EAAE;AACtC,cAAI,SAAS,UAAU,WAAW,SAAS,UAAU,WAAW;AAC5D,iBAAK,aAAa,aAAa,SAAS;AAAA,UAC5C;AACA;AAAA,QACJ;AAAA,QACA,KAAK,cAAc;AACf,iBAAO,KAAK,WAAW,KAAK,SAAS,CAAC;AACtC;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,MAAM;AACN,UAAE,YAAY,IAAI;AAAA,MACtB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW,KAAK,SAAS,GAAG;AACxB,QAAI,UAAU,EAAE;AAChB,QAAI,UAAU,GAAG;AACb,gBAAU,EAAE,cAAc;AAAA,IAC9B;AACA,UAAM,OAAO,IAAI,gBAAgB,OAAO,MAAM;AAC9C,SAAK,aAAa,KAAK,KAAK,UAAU,SAAS,EAAE,uBAAuB,CAAC;AACzE,SAAK,aAAa,UAAU,EAAE,QAAQ,EAAE;AACxC,SAAK,aAAa,gBAAgB,UAAU,EAAE;AAC9C,SAAK,aAAa,QAAQ,MAAM;AAChC,QAAI,EAAE,cAAc;AAChB,WAAK,aAAa,oBAAoB,EAAE,aAAa,KAAK,GAAG,EAAE,KAAK,CAAC;AAAA,IACzE;AACA,QAAI,EAAE,oBAAoB;AACtB,WAAK,aAAa,qBAAqB,GAAG,EAAE,kBAAkB,EAAE;AAAA,IACpE;AACA,WAAO;AAAA,EACX;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,oBAAoB;AAChB,WAAO,KAAK,IAAI;AAAA,EACpB;AAAA,EACA,UAAU,SAAS,yBAAyB;AACxC,WAAO,KAAK,IAAI,UAAU,SAAS,uBAAuB;AAAA,EAC9D;AAAA,EACA,KAAK,IAAI,IAAI,IAAI,IAAI,SAAS;AAC1B,UAAM,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI,IAAI,OAAO;AAC/C,WAAO,KAAK,KAAK,CAAC;AAAA,EACtB;AAAA,EACA,UAAU,GAAG,GAAG,OAAO,QAAQ,SAAS;AACpC,UAAM,IAAI,KAAK,IAAI,UAAU,GAAG,GAAG,OAAO,QAAQ,OAAO;AACzD,WAAO,KAAK,KAAK,CAAC;AAAA,EACtB;AAAA,EACA,QAAQ,GAAG,GAAG,OAAO,QAAQ,SAAS;AAClC,UAAM,IAAI,KAAK,IAAI,QAAQ,GAAG,GAAG,OAAO,QAAQ,OAAO;AACvD,WAAO,KAAK,KAAK,CAAC;AAAA,EACtB;AAAA,EACA,OAAO,GAAG,GAAG,UAAU,SAAS;AAC5B,UAAM,IAAI,KAAK,IAAI,OAAO,GAAG,GAAG,UAAU,OAAO;AACjD,WAAO,KAAK,KAAK,CAAC;AAAA,EACtB;AAAA,EACA,WAAW,QAAQ,SAAS;AACxB,UAAM,IAAI,KAAK,IAAI,WAAW,QAAQ,OAAO;AAC7C,WAAO,KAAK,KAAK,CAAC;AAAA,EACtB;AAAA,EACA,QAAQ,QAAQ,SAAS;AACrB,UAAM,IAAI,KAAK,IAAI,QAAQ,QAAQ,OAAO;AAC1C,WAAO,KAAK,KAAK,CAAC;AAAA,EACtB;AAAA,EACA,IAAI,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,SAAS,OAAO,SAAS;AAC3D,UAAM,IAAI,KAAK,IAAI,IAAI,GAAG,GAAG,OAAO,QAAQ,OAAO,MAAM,QAAQ,OAAO;AACxE,WAAO,KAAK,KAAK,CAAC;AAAA,EACtB;AAAA,EACA,MAAM,QAAQ,SAAS;AACnB,UAAM,IAAI,KAAK,IAAI,MAAM,QAAQ,OAAO;AACxC,WAAO,KAAK,KAAK,CAAC;AAAA,EACtB;AAAA,EACA,KAAK,GAAG,SAAS;AACb,UAAM,UAAU,KAAK,IAAI,KAAK,GAAG,OAAO;AACxC,WAAO,KAAK,KAAK,OAAO;AAAA,EAC5B;AACJ;;;AtBhHA,IAAO,gBAAQ;AAAA,EACX,OAAO,QAAQ,QAAQ;AACnB,WAAO,IAAI,YAAY,QAAQ,MAAM;AAAA,EACzC;AAAA,EACA,IAAI,KAAK,QAAQ;AACb,WAAO,IAAI,SAAS,KAAK,MAAM;AAAA,EACnC;AAAA,EACA,UAAU,QAAQ;AACd,WAAO,IAAI,eAAe,MAAM;AAAA,EACpC;AAAA,EACA,UAAU;AACN,WAAO,eAAe,QAAQ;AAAA,EAClC;AACJ;;;ADdA;AAAA,EACE,cAAAC;AAAA,EACA,aAAAC;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP;AAAA,EACE;AAAA,EACA,eAAAC;AAAA,EACA,iBAAAC;AAAA,EACA,aAAAC;AAAA,EACA,kBAAAC;AAAA,EACA,mBAAAC;AAAA,OACK;;;AyBhBP;AAeA,SAAS,iBAAiB;AAC1B;AAAA,EACE,SAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OAGK;AAEP,SAAS,gCAAgC;AA+ElC,IAAM,kBAAkB,CAC7B,YAC0B;AAC1B,QAAM,EAAE,OAAO,OAAO,QAAQ,GAAG,EAAE,IAAI;AAEvC,QAAM,KAAK,IAAI,QAAQ;AACvB,QAAM,KAAK,IAAI,SAAS;AAExB,QAAM,SAAgB,UAAU,IAAI,EAAE;AAEtC,MAAI;AAEJ,MAAI,QAAQ,SAAS,WAAW;AAC9B,WAAOA;AAAA,MACL,gBAAgB,UAAU,IAAI,CAAC,GAAG,QAAQ,KAAK;AAAA,MAC/C,gBAAgB,UAAU,IAAI,OAAO,EAAE,GAAG,QAAQ,KAAK;AAAA,MACvD,gBAAgB,UAAU,IAAI,IAAI,MAAM,GAAG,QAAQ,KAAK;AAAA,MACxD,gBAAgB,UAAU,GAAG,EAAE,GAAG,QAAQ,KAAK;AAAA,IACjD;AAAA,EACF,OAAO;AACL,WAAOA;AAAA,MACL,gBAAgB,UAAU,GAAG,CAAC,GAAG,QAAQ,KAAK;AAAA,MAC9C,gBAAgB,UAAU,IAAI,OAAO,CAAC,GAAG,QAAQ,KAAK;AAAA,MACtD,gBAAgB,UAAU,IAAI,OAAO,IAAI,MAAM,GAAG,QAAQ,KAAK;AAAA,MAC/D,gBAAgB,UAAU,GAAG,IAAI,MAAM,GAAG,QAAQ,KAAK;AAAA,IACzD;AAAA,EACF;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,EACF;AACF;AAiCO,IAAM,kBAAkB,CAC7B,YAC0B;AAC1B,QAAM,EAAE,OAAO,QAAQ,OAAO,GAAG,EAAE,IAAI;AAEvC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,MACJ,QAAQ,UAAU,IAAI,QAAQ,GAAG,IAAI,SAAS,CAAC;AAAA,MAC/C;AAAA,MACA,WAAW,QAAQ;AAAA,MACnB,YAAY,SAAS;AAAA,IACvB;AAAA,EACF;AACF;AAEO,IAAM,kBAAkB,CAAC,UAA0B;AAExD,MAAI,CAAC,OAAO;AACV,WAAO,CAAC;AAAA,EACV;AAEA,aAAW,OAAO,MAAM,MAAM;AAC5B,QAAI,IAAI,SAAS,QAAQ;AACvB,aAAO,IAAI;AAAA,IACb;AAAA,EACF;AACA,SAAO,MAAM,KAAK,CAAC,EAAE;AACvB;AAGO,IAAM,gBAAgB,CAC3B,YACA,gBAAuB,UAAU,GAAG,CAAC,GACrC,eACA,WAC0B;AAC1B,QAAM,YAAY,CAAC,MACjB;AAAA,IACE,UAAU,EAAE,CAAC,IAAI,cAAc,CAAC,GAAG,EAAE,CAAC,IAAI,cAAc,CAAC,CAAC;AAAA,IAC1D;AAAA,IACA;AAAA,EACF;AAEF,QAAM,MAAM,gBAAgB,UAAU;AACtC,QAAM,YAA8B,CAAC;AACrC,MAAI,KAAK,UAAiB,GAAG,CAAC;AAE9B,aAAW,MAAM,KAAK;AACpB,QAAI,GAAG,OAAO,QAAQ;AACpB,YAAM,IAAI,eAAsB,GAAG,IAAI;AACvC,gBAAU,KAAK,MAAM,yBAAyB;AAC9C,WAAK,UAAU,CAAC;AAAA,IAClB;AACA,QAAI,GAAG,OAAO,YAAY;AACxB,YAAM,KAAK,UAAU,UAAiB,GAAG,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC;AAC7D,YAAM,KAAK,UAAU,UAAiB,GAAG,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC;AAC7D,YAAM,KAAK,UAAU,UAAiB,GAAG,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC;AAC7D,gBAAU,KAAKC,OAAa,IAAI,IAAI,IAAI,EAAE,CAAC;AAC3C,WAAK;AAAA,IACP;AAAA,EACF;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,EACR;AACF;AAEA,IAAM,qBAAqB,CACzB,WACoB;AACpB,MAAI,gBAAuB,OAAO,CAAC;AACnC,QAAM,WAAiC,CAAC;AAExC,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,YAAY,OAAO,CAAC;AAC1B,aAAS,KAAK,YAAmB,eAAe,SAAS,CAAC;AAC1D,oBAAgB;AAAA,EAClB;AAEA,SAAO;AACT;AAEO,IAAM,mBAAmB,CAC9B,SACA,QACA,WAAoB,UACM;AAC1B,QAAM,YAAY,CAAC,MACjB;AAAA,IACE;AAAA,MACE,UAAU,gBAAgB,CAAC,GAAG,OAAO,QAAQ,GAAG,QAAQ,CAAC,CAAC;AAAA,IAC5D;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,EACV;AAEF,QAAM,WAAW;AAAA,IACf,QAAQ,OAAO,IAAI,CAAC,MAAM,UAAU,CAAU,CAAC;AAAA,EACjD;AAEA,SACE,WACI;AAAA,IACE,MAAM;AAAA,IACN,MAAM,kBAAkB,SAAS,KAAK,CAAC;AAAA,EACzC,IACA;AAAA,IACE,MAAM;AAAA,IACN,MAAM;AAAA,EACR;AAER;AAEO,IAAM,sBAAsB,CACjC,SACA,YACA,gBAAuB,UAAiB,GAAG,CAAC,GAC5C,eACA,WAC0B;AAC1B,QAAM,YAAY,CAAC,MACjB;AAAA,IACE,UAAU,EAAE,CAAC,IAAI,cAAc,CAAC,GAAG,EAAE,CAAC,IAAI,cAAc,CAAC,CAAC;AAAA,IAC1D;AAAA,IACA;AAAA,EACF;AAEF,MAAI,QAAQ,cAAc,MAAM;AAC9B,WAAO;AAAA,MACL,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,QAAQ,OAAO,IAAI,CAAC,MAAM,UAAU,CAAU,CAAC;AAAA,MACjD;AAAA,IACF;AAAA,EACF;AAEA,QAAM,MAAM,gBAAgB,UAAU;AAEtC,QAAM,SAAkB,CAAC;AACzB,MAAI,MAAM;AACV,aAAW,aAAa,KAAK;AAC3B,QAAI,UAAU,OAAO,QAAQ;AAC3B,YAAM,CAAC;AACP,UAAI,KAAK;AACP,eAAO,KAAK,UAAU,UAAU,KAAK,CAAC,GAAG,UAAU,KAAK,CAAC,CAAC,CAAC;AAAA,MAC7D;AAAA,IACF,WAAW,UAAU,OAAO,YAAY;AACtC,UAAI,KAAK;AACP,eAAO,KAAK,UAAU,UAAU,KAAK,CAAC,GAAG,UAAU,KAAK,CAAC,CAAC,CAAC;AAC3D,eAAO,KAAK,UAAU,UAAU,KAAK,CAAC,GAAG,UAAU,KAAK,CAAC,CAAC,CAAC;AAC3D,eAAO,KAAK,UAAU,UAAU,KAAK,CAAC,GAAG,UAAU,KAAK,CAAC,CAAC,CAAC;AAAA,MAC7D;AAAA,IACF,WAAW,UAAU,OAAO,UAAU;AACpC,UAAI,KAAK;AACP,eAAO,KAAK,UAAU,UAAU,KAAK,CAAC,GAAG,UAAU,KAAK,CAAC,CAAC,CAAC;AAAA,MAC7D;AAAA,IACF;AAAA,EACF;AAEA,QAAM,gBAAgB,qBAAqB,QAAQ,IAAI,CAAC,EAAE;AAAA,IAAI,CAAC,MAC7D,UAAU,CAAU;AAAA,EACtB;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM,kBAAyB,aAAa;AAAA,EAC9C;AACF;;;AC7VA;AAWA;AAAA,EACE,aAAAC;AAAA,EACA,iBAAAC;AAAA,EAEA,mBAAAC;AAAA,OACK;AACP;AAAA,EACE;AAAA,EACA,iBAAAC;AAAA,EACA,eAAAC;AAAA,EACA;AAAA,EACA;AAAA,OACK;;;ACvBP;;;ACAA;AAAA,SAAS,EAAE,GAAE,GAAE,GAAE,IAAE,OAAG,GAAE;AAAC,SAAO,IAAE,EAAE,MAAG,KAAG,MAAG,EAAE;AAAC;AAAC,SAAS,GAAG,GAAE;AAAC,SAAM,CAAC,CAAC,EAAE,CAAC,GAAE,CAAC,EAAE,CAAC,CAAC;AAAC;AAAC,SAAS,EAAE,GAAE,GAAE;AAAC,SAAM,CAAC,EAAE,CAAC,IAAE,EAAE,CAAC,GAAE,EAAE,CAAC,IAAE,EAAE,CAAC,CAAC;AAAC;AAAC,SAAS,EAAE,GAAE,GAAE;AAAC,SAAM,CAAC,EAAE,CAAC,IAAE,EAAE,CAAC,GAAE,EAAE,CAAC,IAAE,EAAE,CAAC,CAAC;AAAC;AAAC,SAAS,EAAE,GAAE,GAAE;AAAC,SAAM,CAAC,EAAE,CAAC,IAAE,GAAE,EAAE,CAAC,IAAE,CAAC;AAAC;AAAC,SAAS,GAAG,GAAE,GAAE;AAAC,SAAM,CAAC,EAAE,CAAC,IAAE,GAAE,EAAE,CAAC,IAAE,CAAC;AAAC;AAAC,SAAS,EAAE,GAAE;AAAC,SAAM,CAAC,EAAE,CAAC,GAAE,CAAC,EAAE,CAAC,CAAC;AAAC;AAAC,SAAS,EAAE,GAAE,GAAE;AAAC,SAAO,EAAE,CAAC,IAAE,EAAE,CAAC,IAAE,EAAE,CAAC,IAAE,EAAE,CAAC;AAAC;AAAC,SAAS,GAAG,GAAE,GAAE;AAAC,SAAO,EAAE,CAAC,MAAI,EAAE,CAAC,KAAG,EAAE,CAAC,MAAI,EAAE,CAAC;AAAC;AAAC,SAAS,GAAG,GAAE;AAAC,SAAO,KAAK,MAAM,EAAE,CAAC,GAAE,EAAE,CAAC,CAAC;AAAC;AAAC,SAAS,GAAG,GAAE;AAAC,SAAO,EAAE,CAAC,IAAE,EAAE,CAAC,IAAE,EAAE,CAAC,IAAE,EAAE,CAAC;AAAC;AAAC,SAAS,EAAE,GAAE,GAAE;AAAC,SAAO,GAAG,EAAE,GAAE,CAAC,CAAC;AAAC;AAAC,SAAS,EAAE,GAAE;AAAC,SAAO,GAAG,GAAE,GAAG,CAAC,CAAC;AAAC;AAAC,SAAS,GAAG,GAAE,GAAE;AAAC,SAAO,KAAK,MAAM,EAAE,CAAC,IAAE,EAAE,CAAC,GAAE,EAAE,CAAC,IAAE,EAAE,CAAC,CAAC;AAAC;AAAC,SAAS,EAAE,GAAE,GAAE,GAAE;AAAC,MAAI,IAAE,KAAK,IAAI,CAAC,GAAE,IAAE,KAAK,IAAI,CAAC,GAAE,IAAE,EAAE,CAAC,IAAE,EAAE,CAAC,GAAE,IAAE,EAAE,CAAC,IAAE,EAAE,CAAC,GAAE,IAAE,IAAE,IAAE,IAAE,GAAE,IAAE,IAAE,IAAE,IAAE;AAAE,SAAM,CAAC,IAAE,EAAE,CAAC,GAAE,IAAE,EAAE,CAAC,CAAC;AAAC;AAAC,SAAS,EAAE,GAAE,GAAE,GAAE;AAAC,SAAO,EAAE,GAAE,EAAE,EAAE,GAAE,CAAC,GAAE,CAAC,CAAC;AAAC;AAAC,SAAS,GAAG,GAAE,GAAE,GAAE;AAAC,SAAO,EAAE,GAAE,EAAE,GAAE,CAAC,CAAC;AAAC;AAAC,IAAG,EAAC,KAAI,GAAE,IAAG,GAAE,IAAE;AAAjB,IAAsB,KAAG;AAAzB,IAA8B,IAAE,KAAG;AAAK,SAAS,GAAG,GAAE,IAAE,CAAC,GAAE;AAAC,MAAG,EAAC,MAAK,IAAE,IAAG,WAAU,IAAE,KAAG,UAAS,IAAE,KAAG,kBAAiB,IAAE,MAAG,QAAO,IAAE,OAAG,GAAE,OAAM,IAAE,CAAC,GAAE,KAAI,IAAE,CAAC,GAAE,MAAK,IAAE,MAAE,IAAE,GAAE,EAAC,KAAI,IAAE,MAAG,QAAO,IAAE,OAAG,KAAG,IAAE,GAAE,IAAE,GAAE,EAAC,KAAI,IAAE,MAAG,QAAO,IAAE,OAAG,EAAE,IAAE,IAAE,IAAE,EAAC,IAAE;AAAE,MAAG,EAAE,WAAS,KAAG,KAAG;AAAE,WAAM,CAAC;AAAE,MAAI,IAAE,EAAE,EAAE,SAAO,CAAC,EAAE,eAAc,IAAE,EAAE,UAAQ,QAAG,IAAE,EAAE,UAAQ,OAAG,KAAK,IAAI,GAAE,CAAC,IAAE,EAAE,OAAM,IAAE,EAAE,UAAQ,QAAG,IAAE,EAAE,UAAQ,OAAG,KAAK,IAAI,GAAE,CAAC,IAAE,EAAE,OAAM,KAAG,KAAK,IAAI,IAAE,GAAE,CAAC,GAAE,IAAE,CAAC,GAAE,IAAE,CAAC,GAAE,IAAE,EAAE,MAAM,GAAE,EAAE,EAAE,OAAO,CAAC,GAAE,MAAI;AAAC,QAAI,IAAE,EAAE;AAAS,QAAG,GAAE;AAAC,UAAI,IAAE,EAAE,GAAE,EAAE,WAAS,CAAC,GAAE,IAAE,EAAE,GAAE,IAAE,CAAC;AAAE,UAAE,EAAE,GAAE,KAAG,IAAE,MAAI,IAAE,GAAG;AAAA,IAAC;AAAC,YAAO,IAAE,KAAG;AAAA,EAAC,GAAE,EAAE,CAAC,EAAE,QAAQ,GAAE,IAAE,EAAE,GAAE,GAAE,EAAE,EAAE,SAAO,CAAC,EAAE,UAAS,CAAC,GAAE,GAAE,IAAE,EAAE,CAAC,EAAE,QAAO,IAAE,EAAE,CAAC,EAAE,OAAM,IAAE,GAAE,IAAE,GAAE,IAAE,GAAE,IAAE;AAAG,WAAQ,IAAE,GAAE,IAAE,EAAE,QAAO,KAAI;AAAC,QAAG,EAAC,UAAS,EAAC,IAAE,EAAE,CAAC,GAAE,EAAC,OAAM,GAAE,QAAO,GAAE,UAAS,GAAE,eAAc,EAAC,IAAE,EAAE,CAAC;AAAE,QAAG,IAAE,EAAE,SAAO,KAAG,IAAE,IAAE;AAAE;AAAS,QAAG,GAAE;AAAC,UAAG,GAAE;AAAC,YAAI,IAAE,EAAE,GAAE,IAAE,CAAC,GAAE,IAAE,EAAE,GAAE,IAAE,CAAC;AAAE,YAAE,EAAE,GAAE,KAAG,IAAE,MAAI,IAAE,GAAG;AAAA,MAAC;AAAC,UAAE,EAAE,GAAE,GAAE,GAAE,CAAC;AAAA,IAAC;AAAM,UAAE,IAAE;AAAE,UAAI,WAAS,IAAE;AAAG,QAAI,KAAG,IAAE,IAAE,EAAE,IAAE,CAAC,IAAE,GAAE,KAAG,IAAE,IAAE,IAAE,GAAG,IAAE,KAAG,CAAC,IAAE;AAAE,QAAE,KAAK,IAAI,MAAI,IAAE,KAAK,IAAI,IAAG,EAAE,CAAC;AAAE,QAAI,MAAI,IAAE,EAAE,SAAO,IAAE,EAAE,IAAE,CAAC,IAAE,EAAE,CAAC,GAAG,QAAO,IAAE,IAAE,EAAE,SAAO,IAAE,EAAE,GAAE,EAAE,IAAE,GAAE,KAAG,EAAE,GAAE,CAAC,IAAE,KAAG,CAAC,GAAE,KAAG,MAAI,QAAM,IAAE;AAAE,QAAG,MAAI,IAAG;AAAC,UAAI,IAAE,EAAE,EAAE,CAAC,GAAE,CAAC;AAAE,eAAQ,IAAE,IAAE,IAAG,IAAE,GAAE,KAAG,GAAE,KAAG;AAAE,YAAE,EAAE,EAAE,GAAE,CAAC,GAAE,GAAE,IAAE,CAAC,GAAE,EAAE,KAAK,CAAC,GAAE,IAAE,EAAE,EAAE,GAAE,CAAC,GAAE,GAAE,IAAE,CAAC,CAAC,GAAE,EAAE,KAAK,CAAC;AAAE,UAAE,GAAE,IAAE,GAAE,OAAK,IAAE;AAAI;AAAA,IAAQ;AAAC,QAAG,IAAE,OAAG,MAAI,EAAE,SAAO,GAAE;AAAC,UAAI,IAAE,EAAE,EAAE,CAAC,GAAE,CAAC;AAAE,QAAE,KAAK,EAAE,GAAE,CAAC,CAAC,GAAE,EAAE,KAAK,EAAE,GAAE,CAAC,CAAC;AAAE;AAAA,IAAQ;AAAC,QAAI,KAAG,EAAE,EAAE,EAAE,IAAG,GAAE,CAAC,CAAC,GAAE,CAAC;AAAE,QAAE,EAAE,GAAE,EAAE,IAAG,KAAG,KAAG,EAAE,GAAE,CAAC,IAAE,QAAM,EAAE,KAAK,CAAC,GAAE,IAAE,IAAG,IAAE,EAAE,GAAE,EAAE,IAAG,KAAG,KAAG,EAAE,GAAE,CAAC,IAAE,QAAM,EAAE,KAAK,CAAC,GAAE,IAAE,IAAG,IAAE,GAAE,IAAE;AAAA,EAAC;AAAC,MAAI,IAAE,EAAE,CAAC,EAAE,MAAM,MAAM,GAAE,CAAC,GAAE,IAAE,EAAE,SAAO,IAAE,EAAE,EAAE,SAAO,CAAC,EAAE,MAAM,MAAM,GAAE,CAAC,IAAE,EAAE,EAAE,CAAC,EAAE,OAAM,CAAC,GAAE,CAAC,CAAC,GAAE,IAAE,CAAC,GAAE,IAAE,CAAC;AAAE,MAAG,EAAE,WAAS,GAAE;AAAC,QAAG,EAAE,KAAG,MAAI,GAAE;AAAC,UAAI,IAAE,GAAG,GAAE,EAAE,EAAE,EAAE,GAAE,CAAC,CAAC,CAAC,GAAE,EAAE,KAAG,EAAE,GAAE,IAAE,CAAC;AAAE,eAAQ,IAAE,IAAE,IAAG,IAAE,GAAE,KAAG,GAAE,KAAG;AAAE,UAAE,KAAK,EAAE,GAAE,GAAE,IAAE,IAAE,CAAC,CAAC;AAAE,aAAO;AAAA,IAAC;AAAA,EAAC,OAAK;AAAC,QAAG,EAAE,KAAG,KAAG,EAAE,WAAS;AAAG,UAAG;AAAE,iBAAQ,IAAE,IAAE,IAAG,IAAE,GAAE,KAAG,GAAE,KAAG,GAAE;AAAC,cAAI,IAAE,EAAE,EAAE,CAAC,GAAE,GAAE,IAAE,CAAC;AAAE,YAAE,KAAK,CAAC;AAAA,QAAC;AAAA,WAAK;AAAC,YAAI,IAAE,EAAE,EAAE,CAAC,GAAE,EAAE,CAAC,CAAC,GAAE,IAAE,EAAE,GAAE,GAAE,GAAE,IAAE,EAAE,GAAE,IAAG;AAAE,UAAE,KAAK,EAAE,GAAE,CAAC,GAAE,EAAE,GAAE,CAAC,GAAE,EAAE,GAAE,CAAC,GAAE,EAAE,GAAE,CAAC,CAAC;AAAA,MAAC;AAAC,QAAI,IAAE,EAAE,GAAG,EAAE,EAAE,SAAO,CAAC,EAAE,MAAM,CAAC;AAAE,QAAG,KAAG,KAAG,EAAE,WAAS;AAAE,QAAE,KAAK,CAAC;AAAA,aAAU,GAAE;AAAC,UAAI,IAAE,GAAG,GAAE,GAAE,CAAC;AAAE,eAAQ,IAAE,IAAE,IAAG,IAAE,GAAE,IAAE,GAAE,KAAG;AAAE,UAAE,KAAK,EAAE,GAAE,GAAE,IAAE,IAAE,CAAC,CAAC;AAAA,IAAC;AAAM,QAAE,KAAK,EAAE,GAAE,EAAE,GAAE,CAAC,CAAC,GAAE,EAAE,GAAE,EAAE,GAAE,IAAE,IAAG,CAAC,GAAE,EAAE,GAAE,EAAE,GAAE,IAAE,IAAG,CAAC,GAAE,EAAE,GAAE,EAAE,GAAE,CAAC,CAAC,CAAC;AAAA,EAAC;AAAC,SAAO,EAAE,OAAO,GAAE,EAAE,QAAQ,GAAE,CAAC;AAAC;AAAC,SAAS,GAAG,GAAE,IAAE,CAAC,GAAE;AAAC,MAAI;AAAE,MAAG,EAAC,YAAW,IAAE,KAAG,MAAK,IAAE,IAAG,MAAK,IAAE,MAAE,IAAE;AAAE,MAAG,EAAE,WAAS;AAAE,WAAM,CAAC;AAAE,MAAI,IAAE,QAAK,IAAE,KAAG,MAAI,IAAE,MAAM,QAAQ,EAAE,CAAC,CAAC,IAAE,IAAE,EAAE,IAAI,CAAC,EAAC,GAAE,GAAE,GAAE,GAAE,UAAS,IAAE,IAAE,MAAI,CAAC,GAAE,GAAE,CAAC,CAAC;AAAE,MAAG,EAAE,WAAS,GAAE;AAAC,QAAI,IAAE,EAAE,CAAC;AAAE,QAAE,EAAE,MAAM,GAAE,EAAE;AAAE,aAAQ,IAAE,GAAE,IAAE,GAAE;AAAI,QAAE,KAAK,EAAE,EAAE,CAAC,GAAE,GAAE,IAAE,CAAC,CAAC;AAAA,EAAC;AAAC,IAAE,WAAS,MAAI,IAAE,CAAC,GAAG,GAAE,CAAC,GAAG,EAAE,EAAE,CAAC,GAAE,CAAC,GAAE,CAAC,CAAC,GAAE,GAAG,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;AAAG,MAAI,IAAE,CAAC,EAAC,OAAM,CAAC,EAAE,CAAC,EAAE,CAAC,GAAE,EAAE,CAAC,EAAE,CAAC,CAAC,GAAE,UAAS,EAAE,CAAC,EAAE,CAAC,KAAG,IAAE,EAAE,CAAC,EAAE,CAAC,IAAE,MAAI,QAAO,CAAC,GAAE,CAAC,GAAE,UAAS,GAAE,eAAc,EAAC,CAAC,GAAE,IAAE,OAAG,IAAE,GAAE,IAAE,EAAE,CAAC,GAAE,IAAE,EAAE,SAAO;AAAE,WAAQ,IAAE,GAAE,IAAE,EAAE,QAAO,KAAI;AAAC,QAAI,IAAE,KAAG,MAAI,IAAE,EAAE,CAAC,EAAE,MAAM,GAAE,CAAC,IAAE,EAAE,EAAE,OAAM,EAAE,CAAC,GAAE,CAAC;AAAE,QAAG,GAAG,EAAE,OAAM,CAAC;AAAE;AAAS,QAAI,IAAE,GAAG,GAAE,EAAE,KAAK;AAAE,QAAG,KAAG,GAAE,IAAE,KAAG,CAAC,GAAE;AAAC,UAAG,IAAE;AAAE;AAAS,UAAE;AAAA,IAAE;AAAC,QAAE,EAAC,OAAM,GAAE,UAAS,EAAE,CAAC,EAAE,CAAC,KAAG,IAAE,EAAE,CAAC,EAAE,CAAC,IAAE,KAAG,QAAO,EAAE,EAAE,EAAE,OAAM,CAAC,CAAC,GAAE,UAAS,GAAE,eAAc,EAAC,GAAE,EAAE,KAAK,CAAC;AAAA,EAAC;AAAC,SAAO,EAAE,CAAC,EAAE,WAAS,IAAE,EAAE,CAAC,MAAI,OAAK,SAAO,EAAE,WAAS,CAAC,GAAE,CAAC,GAAE;AAAC;AAAC,SAAS,GAAG,GAAE,IAAE,CAAC,GAAE;AAAC,SAAO,GAAG,GAAG,GAAE,CAAC,GAAE,CAAC;AAAC;;;ADGrlH,SAAS,wBAAwB;AAEjC;AAAA,EACE,sBAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAAC;AAAA,EACA,iBAAAC;AAAA,EACA;AAAA,EACA;AAAA,OACK;;;AEhBP;AAAA;AAAA,EAEE,aAAAC;AAAA,EACA;AAAA,EACA,mBAAAC;AAAA,EACA,mBAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA,aAAAC;AAAA,EACA,eAAAC;AAAA,EACA,mBAAAC;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAkBA,IAAM,oBAAoB;AAE1B,IAAM,cAAc,CACzB,SACA,aACA,iBACA,cACA,eACA,UACA,UACA,qBACG;AACH,QAAM,EAAE,OAAO,gBAAgB,QAAQ,gBAAgB,IACrD,2BAA2B,OAAO;AAEpC,QAAM,0BAA0B,eAAe;AAC/C,QAAM,2BAA2B,gBAAgB;AAEjD,QAAM,eAAe,QAAQ,MAAM,KAAK,KAAK;AAC7C,QAAM,cAAc,QAAQ,MAAM,KAAK,KAAK;AAa5C,QAAM,iBAAiBC;AAAA,IACrBC,WAAU,UAAU,QAAQ;AAAA,IAC5B,mBAAmB,SAAS,WAAW;AAAA,IACvC,CAAC,QAAQ;AAAA,EACX;AAEA,aAAW,eAAe,CAAC;AAC3B,aAAW,eAAe,CAAC;AAE3B,MAAI,YAAY,QAAQ;AACxB,MAAI,aAAa,QAAQ;AAEzB,MAAI,OAAyB,QAAQ,QAAQ;AAAA,IAC3C,GAAG;AAAA,IACH,GAAG;AAAA,IACH,OAAO;AAAA,IACP,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,EACF;AAEA,QAAM,qBAAqB,KAAK;AAChC,QAAM,oBAAoB,KAAK;AAE/B,QAAM,eAAe,QAAQ,MAAM,CAAC,MAAM;AAC1C,QAAM,eAAe,QAAQ,MAAM,CAAC,MAAM;AAE1C,MAAI,iBAAiB,WAAW,QAAQ;AACxC,MAAI,gBAAgB,WAAW,QAAQ;AAEvC,MAAI,gBAAgB,SAAS,GAAG,GAAG;AACjC,iBAAa;AAAA,MACX,QAAQ,SAAS;AAAA,MACjB;AAAA,MACA,eAAe,kBAAkB,aAAa,QAAQ,SAAS;AAAA,IACjE;AAAA,EACF;AAEA,MAAI,gBAAgB,SAAS,GAAG,GAAG;AACjC,qBAAiB,WAAW,QAAQ,IAAI,QAAQ;AAChD,iBAAa;AAAA,MACX,QAAQ,SAAS;AAAA,MACjB;AAAA,MACA,eAAe,QAAQ,SAAS,aAAa,kBAAkB;AAAA,IACjE;AAAA,EACF;AAEA,MAAI,gBAAgB,SAAS,GAAG,GAAG;AACjC,oBAAgB,WAAW,QAAQ,IAAI,QAAQ;AAE/C,gBAAY;AAAA,MACV,QAAQ,QAAQ;AAAA,MAChB;AAAA,MACA,eAAe,QAAQ,QAAQ,cAAc,iBAAiB;AAAA,IAChE;AAAA,EACF;AAEA,MAAI,gBAAgB,SAAS,GAAG,GAAG;AACjC,gBAAY;AAAA,MACV,QAAQ,QAAQ;AAAA,MAChB;AAAA,MACA,eAAe,iBAAiB,cAAc,QAAQ,QAAQ;AAAA,IAChE;AAAA,EACF;AAEA,QAAM,2BAA2B,CAACC,UAAoB;AACpD,IAAAA,MAAK,SAAS,aAAa;AAC3B,IAAAA,MAAK,QAAQ,YAAY;AAAA,EAC3B;AAEA,2BAAyB,IAAI;AAE7B,QAAM,sBAAsB,CAC1B,QACAA,UACG;AACH,6BAAyBA,KAAI;AAC7B,QAAI,OAAO,SAAS,GAAG,GAAG;AACxB,UAAI,CAAC,cAAc;AACjB,QAAAA,MAAK,KAAK,qBAAqBA,MAAK;AAAA,MACtC;AAAA,IACF;AACA,QAAI,OAAO,SAAS,GAAG,GAAG;AACxB,UAAI,cAAc;AAChB,QAAAA,MAAK,KAAK,qBAAqBA,MAAK;AAAA,MACtC;AAAA,IACF;AACA,QAAI,OAAO,SAAS,GAAG,GAAG;AACxB,UAAI,cAAc;AAChB,QAAAA,MAAK,KAAK,oBAAoBA,MAAK;AAAA,MACrC;AAAA,IACF;AACA,QAAI,OAAO,SAAS,GAAG,GAAG;AACxB,UAAI,CAAC,cAAc;AACjB,QAAAA,MAAK,KAAK,oBAAoBA,MAAK;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AAEA,UAAQ,iBAAiB;AAAA,IACvB,KAAK,KAAK;AACR,UAAI,kBAAkB;AACpB,cAAM,iBAAiB,cAAc,QAAQ,QAAQ;AACrD,cAAM,kBACJ,iBAAiB,cAAc,QAAQ,QAAQ;AAEjD,cAAM,YAAY,KAAK,IAAI,gBAAgB,eAAe,IAAI;AAE9D,oBAAY;AAAA,UACV,aAAa;AAAA,UACb;AAAA,UACA;AAAA,QACF;AACA,qBAAa,YAAY;AAAA,MAC3B;AAEA,0BAAoB,iBAAiB,IAAI;AAEzC,UAAI,kBAAkB;AACpB,aAAK,MAAM,oBAAoB,KAAK,SAAS;AAAA,MAC/C;AAEA;AAAA,IACF;AAAA,IACA,KAAK,KAAK;AACR,UAAI,kBAAkB;AACpB,cAAM,iBAAiB,cAAc,QAAQ,QAAQ;AACrD,cAAM,kBACJ,iBAAiB,cAAc,QAAQ,QAAQ;AAEjD,cAAM,YAAY,KAAK,IAAI,gBAAgB,eAAe,IAAI;AAE9D,oBAAY;AAAA,UACV,aAAa;AAAA,UACb;AAAA,UACA;AAAA,QACF;AACA,qBAAa,YAAY;AAAA,MAC3B;AAEA,0BAAoB,iBAAiB,IAAI;AAEzC,UAAI,kBAAkB;AACpB,aAAK,MAAM,oBAAoB,KAAK,SAAS;AAAA,MAC/C;AAEA;AAAA,IACF;AAAA,IACA,KAAK,KAAK;AACR,UAAI,kBAAkB;AACpB,cAAM,gBAAgB,aAAa,QAAQ,SAAS;AACpD,cAAM,mBACJ,kBAAkB,aAAa,QAAQ,SAAS;AAElD,cAAM,aAAa,KAAK,IAAI,eAAe,gBAAgB,IAAI;AAE/D,qBAAa;AAAA,UACX,YAAY;AAAA,UACZ;AAAA,UACA;AAAA,QACF;AACA,oBAAY,aAAa;AAAA,MAC3B;AAEA,0BAAoB,iBAAiB,IAAI;AAEzC,UAAI,kBAAkB;AACpB,aAAK,MAAM,qBAAqB,KAAK,UAAU;AAAA,MACjD;AAEA;AAAA,IACF;AAAA,IACA,KAAK,KAAK;AACR,UAAI,kBAAkB;AACpB,cAAM,gBAAgB,aAAa,QAAQ,SAAS;AACpD,cAAM,mBACJ,kBAAkB,aAAa,QAAQ,SAAS;AAElD,cAAM,aAAa,KAAK,IAAI,eAAe,gBAAgB,IAAI;AAE/D,qBAAa;AAAA,UACX,YAAY;AAAA,UACZ;AAAA,UACA;AAAA,QACF;AACA,oBAAY,aAAa;AAAA,MAC3B;AAEA,0BAAoB,iBAAiB,IAAI;AAEzC,UAAI,kBAAkB;AACpB,aAAK,MAAM,qBAAqB,KAAK,UAAU;AAAA,MACjD;AAEA;AAAA,IACF;AAAA,IACA,KAAK,MAAM;AACT,UAAI,kBAAkB;AACpB,YAAI,gBAAgB,CAAC,gBAAgB;AACnC,gBAAM,aAAa,eACf,kBAAkB,aAClB,aAAa,QAAQ;AAEzB,uBAAa;AAAA,YACX,YAAY;AAAA,YACZ;AAAA,YACA;AAAA,UACF;AACA,sBAAY,aAAa;AAAA,QAC3B,OAAO;AACL,gBAAM,YAAY,eACd,cAAc,QAAQ,QACtB,iBAAiB;AAErB,sBAAY;AAAA,YACV,aAAa;AAAA,YACb;AAAA,YACA;AAAA,UACF;AACA,uBAAa,YAAY;AAAA,QAC3B;AAAA,MACF;AAEA,0BAAoB,iBAAiB,IAAI;AACzC;AAAA,IACF;AAAA,IACA,KAAK,MAAM;AACT,UAAI,kBAAkB;AACpB,YAAI,gBAAgB,gBAAgB;AAClC,gBAAM,aAAa,eACf,kBAAkB,aAClB,aAAa,QAAQ;AACzB,uBAAa;AAAA,YACX,YAAY;AAAA,YACZ;AAAA,YACA;AAAA,UACF;AACA,sBAAY,aAAa;AAAA,QAC3B,OAAO;AACL,gBAAM,YAAY,eACd,iBAAiB,cACjB,cAAc,QAAQ;AAE1B,sBAAY;AAAA,YACV,aAAa;AAAA,YACb;AAAA,YACA;AAAA,UACF;AACA,uBAAa,YAAY;AAAA,QAC3B;AAAA,MACF;AAEA,0BAAoB,iBAAiB,IAAI;AACzC;AAAA,IACF;AAAA,IACA,KAAK,MAAM;AACT,UAAI,kBAAkB;AACpB,YAAI,gBAAgB,gBAAgB;AAClC,gBAAM,aAAa,eACf,aAAa,QAAQ,SACrB,kBAAkB;AAEtB,uBAAa;AAAA,YACX,YAAY;AAAA,YACZ;AAAA,YACA;AAAA,UACF;AACA,sBAAY,aAAa;AAAA,QAC3B,OAAO;AACL,gBAAM,YAAY,eACd,cAAc,QAAQ,QACtB,iBAAiB;AAErB,sBAAY;AAAA,YACV,aAAa;AAAA,YACb;AAAA,YACA;AAAA,UACF;AACA,uBAAa,YAAY;AAAA,QAC3B;AAAA,MACF;AAEA,0BAAoB,iBAAiB,IAAI;AACzC;AAAA,IACF;AAAA,IACA,KAAK,MAAM;AACT,UAAI,kBAAkB;AACpB,YAAI,CAAC,gBAAgB,gBAAgB;AACnC,gBAAM,aAAa,eACf,aAAa,QAAQ,SACrB,kBAAkB;AAEtB,uBAAa;AAAA,YACX,YAAY;AAAA,YACZ;AAAA,YACA;AAAA,UACF;AACA,sBAAY,aAAa;AAAA,QAC3B,OAAO;AACL,gBAAM,YAAY,eACd,iBAAiB,cACjB,cAAc,QAAQ;AAE1B,sBAAY;AAAA,YACV,aAAa;AAAA,YACb;AAAA,YACA;AAAA,UACF;AACA,uBAAa,YAAY;AAAA,QAC3B;AAAA,MACF;AAEA,0BAAoB,iBAAiB,IAAI;AACzC;AAAA,IACF;AAAA,IACA;AACE;AAAA,EACJ;AAEA,QAAM,YAAY;AAAA,IAChB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,CAAC,CAAC;AAAA,EACJ;AAGA,MACE,UAAU,KAAK,OAAO,KAAK,YAAY,KACvC,UAAU,KAAK,QAAQ,KAAK,aAAa,GACzC;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,GAAG,UAAU,CAAC;AAAA,IACd,GAAG,UAAU,CAAC;AAAA,IACd,OAAO;AAAA,IACP,QAAQ;AAAA,IACR;AAAA,EACF;AACF;AAEA,IAAM,kBAAkB,CACtB,kBACA,iBACA,OACA,QACA,8BACG;AACH,QAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAI;AAAA,IACvB;AAAA,IACA,iBAAiB;AAAA,IACjB,iBAAiB;AAAA,IACjB;AAAA,EACF;AACA,QAAM,eAAeD,WAAU,IAAI,EAAE;AACrC,QAAM,mBAAmBA,WAAU,IAAI,EAAE;AACzC,QAAM,cAAmB,YAAY,cAAc,gBAAgB;AAEnE,QAAM,CAAC,aAAa,aAAa,aAAa,WAAW,IACvD,gCAAgC,kBAAkB,OAAO,QAAQ,IAAI;AACvE,QAAM,iBAAiB,cAAc;AACrC,QAAM,kBAAkB,cAAc;AAGtC,MAAI,aAAa,CAAC,GAAG,YAAY;AAEjC,MAAI,CAAC,KAAK,KAAK,IAAI,EAAE,SAAS,eAAe,GAAG;AAC9C,iBAAa;AAAA,MACX,iBAAiB,CAAC,IAAI,KAAK,IAAI,cAAc;AAAA,MAC7C,iBAAiB,CAAC,IAAI,KAAK,IAAI,eAAe;AAAA,IAChD;AAAA,EACF;AACA,MAAI,oBAAoB,MAAM;AAC5B,UAAM,aAAa,CAAC,aAAa,CAAC,GAAG,iBAAiB,CAAC,CAAC;AACxD,iBAAa,CAAC,WAAW,CAAC,GAAG,WAAW,CAAC,IAAI,KAAK,IAAI,eAAe,CAAC;AAAA,EACxE;AACA,MAAI,oBAAoB,MAAM;AAC5B,UAAM,WAAW,CAAC,iBAAiB,CAAC,GAAG,aAAa,CAAC,CAAC;AACtD,iBAAa,CAAC,SAAS,CAAC,IAAI,KAAK,IAAI,cAAc,GAAG,SAAS,CAAC,CAAC;AAAA,EACnE;AAEA,MAAI,2BAA2B;AAC7B,QAAI,CAAC,KAAK,GAAG,EAAE,SAAS,eAAe,GAAG;AACxC,iBAAW,CAAC,IAAI,YAAY,CAAC,IAAI,iBAAiB;AAAA,IACpD;AACA,QAAI,CAAC,KAAK,GAAG,EAAE,SAAS,eAAe,GAAG;AACxC,iBAAW,CAAC,IAAI,YAAY,CAAC,IAAI,kBAAkB;AAAA,IACrD;AAAA,EACF;AAGA,QAAM,QAAQ,iBAAiB;AAC/B,QAAM,iBAAiBD,iBAAgB,YAAY,aAAa,KAAK;AACrE,QAAM,YAAmB;AAAA,IACvB,WAAW,CAAC,IAAI,KAAK,IAAI,cAAc,IAAI;AAAA,IAC3C,WAAW,CAAC,IAAI,KAAK,IAAI,eAAe,IAAI;AAAA,EAC9C;AACA,QAAM,mBAAmBA,iBAAgB,WAAW,aAAa,KAAK;AACtE,eAAaA;AAAA,IACX;AAAA,IACA;AAAA,IACA,CAAC;AAAA,EACH;AAEA,QAAM,YAAY,CAAC,GAAG,UAAU;AAChC,YAAU,CAAC,KAAK,iBAAiB,IAAI;AACrC,YAAU,CAAC,KAAK,iBAAiB,IAAI;AAErC,SAAO;AACT;AAGO,IAAM,2BAA2B,CACtC,SACA,gBACG;AACH,MAAI,QAAQ,MAAM;AAChB,UAAM,EAAE,OAAO,OAAO,IAAI,2BAA2B,OAAO;AAE5D,UAAM,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,IAAIG;AAAA,MAC/B;AAAA,MACA;AAAA,IACF;AAEA,UAAM,gBAAgBC;AAAA,MACpBJ,iBAAgBC,WAAU,IAAI,EAAE,GAAGA,WAAU,IAAI,EAAE,GAAG,QAAQ,KAAK;AAAA,IACrE;AACA,UAAM,iBAAiBG;AAAA,MACrBJ,iBAAgBC,WAAU,IAAI,EAAE,GAAGA,WAAU,IAAI,EAAE,GAAG,QAAQ,KAAK;AAAA,IACrE;AACA,UAAM,oBAAoB;AAAA,MACxB,eAAe,gBAAgB,aAAa;AAAA,IAC9C;AACA,UAAM,mBAAmBG;AAAA,MACvBJ,iBAAgBC,WAAU,IAAI,EAAE,GAAGA,WAAU,IAAI,EAAE,GAAG,QAAQ,KAAK;AAAA,IACrE;AACA,UAAM,iBAAiB,eAAe,kBAAkB,aAAa;AACrE,UAAM,qBAAqB,gBAAgB,cAAc;AAEzD,UAAM,EAAE,OAAO,MAAM,IAAI,mBAAmB,QAAQ,MAAM,QAAQ,KAAK;AAEvE,UAAM,iBAAiBI;AAAA,MACrBA;AAAA,QACE;AAAA,QACAC;AAAA,UACE;AAAA,UACC,CAAC,QAAQ,QAAS,QAAQ,KAAK;AAAA,QAClC;AAAA,MACF;AAAA,MACAA;AAAA,QACE;AAAA,QACC,CAAC,QAAQ,SAAU,QAAQ,KAAK;AAAA,MACnC;AAAA,IACF;AAEA,UAAM,SAASC;AAAA,MACbF;AAAA,QACEA,WAAU,gBAAgBC,aAAY,mBAAmB,QAAQ,CAAC,CAAC;AAAA,QACnEA,aAAY,oBAAoB,SAAS,CAAC;AAAA,MAC5C;AAAA,IACF;AAEA,UAAM,mBAAmBN;AAAA,MACvBO,iBAAgB,cAAc;AAAA,MAC9B;AAAA,MACA,CAAC,QAAQ;AAAA,IACX;AAEA,UAAM,mBAA2C;AAAA,MAC/C,GAAG;AAAA,MACH,GAAG,iBAAiB,CAAC;AAAA,MACrB,GAAG,iBAAiB,CAAC;AAAA,MACrB;AAAA,MACA;AAAA,MACA,MAAM;AAAA,IACR;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,IAAM,6BAA6B,CAAC,YAAoC;AAC7E,MAAI,QAAQ,MAAM;AAChB,UAAM,QACJ,QAAQ,SAAS,QAAQ,KAAK,QAAQ,QAAQ,KAAK;AACrD,UAAM,SACJ,QAAQ,UAAU,QAAQ,KAAK,SAAS,QAAQ,KAAK;AAEvD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL,OAAO,QAAQ;AAAA,IACf,QAAQ,QAAQ;AAAA,EAClB;AACF;AAEA,IAAM,qBAAqB,CACzB,MACA,UACG;AACH,MAAI,QAAQ,KAAK;AACjB,MAAI,QAAQ,KAAK;AAEjB,QAAM,QAAQ,MAAM,CAAC,MAAM;AAC3B,QAAM,QAAQ,MAAM,CAAC,MAAM;AAE3B,MAAI,OAAO;AACT,YAAQ,KAAK,eAAe,KAAK,IAAI,KAAK,IAAI,KAAK;AAAA,EACrD;AAEA,MAAI,OAAO;AACT,YAAQ,KAAK,gBAAgB,KAAK,IAAI,KAAK,IAAI,KAAK;AAAA,EACtD;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,8BAA8B,CACzC,SACA,UAAU,UACP;AACH,QAAM,OAAO,QAAQ;AACrB,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AAEA,QAAM,eAAe,QAAQ,MAAM,CAAC,MAAM;AAC1C,QAAM,eAAe,QAAQ,MAAM,CAAC,MAAM;AAE1C,MAAI,QAAQ,KAAK;AACjB,MAAI,QAAQ,KAAK;AAEjB,MAAI,cAAc;AAChB,YAAQ,KAAK,eAAe,KAAK,QAAQ,KAAK;AAAA,EAChD;AAEA,MAAI,cAAc;AAChB,YAAQ,KAAK,gBAAgB,KAAK,SAAS,KAAK;AAAA,EAClD;AAEA,MAAI,SAAS;AACX,WAAO;AAAA,MACL,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAAA,EACF;AAEA,QAAM,EAAE,OAAO,OAAO,IAAI,2BAA2B,OAAO;AAE5D,SAAO;AAAA,IACL,GAAG,SAAS,KAAK,eAAe;AAAA,IAChC,GAAG,SAAS,KAAK,gBAAgB;AAAA,EACnC;AACF;;;ACpnBA;AAAA;AAAA,EACE,eAAAC;AAAA,EACA,aAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,eAAAC;AAAA,EAGA,iBAAAC;AAAA,EACA,mBAAAC;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAIP;AAAA,EACE;AAAA,EACA,QAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA,aAAAC;AAAA,EACA,gBAAAC;AAAA,EACA;AAAA,OACK;AAEP;AAAA,EACE,sCAAAC;AAAA,EACA,eAAAC;AAAA,OAEK;;;AC7BP;AAAA;AAAA,EACE;AAAA,EACA,cAAAC;AAAA,EACA;AAAA,EACA,gBAAAC;AAAA,EACA,aAAAC;AAAA,EACA,YAAAC;AAAA,EACA,aAAAC;AAAA,OACK;AAEP;AAAA,EACE,eAAAC;AAAA,EACA,aAAAC;AAAA,EACA,mBAAAC;AAAA,EAEA,mBAAAC;AAAA,EACA;AAAA,EACA,SAAAC;AAAA,EACA,iBAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,eAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,eAAAC;AAAA,EACA,eAAAC;AAAA,EACA,iCAAAC;AAAA,EACA,aAAAC;AAAA,OACK;;;AC1BP;AAAA,SAAS,qBAAqB;AAC9B;AAAA,EACE;AAAA,EACA;AAAA,EACA,eAAAC;AAAA,EACA;AAAA,EACA,aAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,eAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,eAAAC;AAAA,OACK;AAEP;AAAA,EACE,WAAAC;AAAA,EACA;AAAA,OACK;;;AClBP;AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP;AAAA,EACE,SAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA,eAAAC;AAAA,EACA,iBAAAC;AAAA,EACA,aAAAC;AAAA,EACA,kBAAAC;AAAA,EACA,aAAAC;AAAA,OAEK;AAoBP,IAAM,qBAAqB,oBAAI,QAG7B;AAEF,IAAM,6BAA6B,CACjC,SACA,WAC6B;AAC7B,QAAM,SAAS,mBAAmB,IAAI,OAAO;AAE7C,MAAI,CAAC,QAAQ;AACX,WAAO;AAAA,EACT;AAEA,QAAM,EAAE,SAAS,OAAO,IAAI;AAE5B,MAAI,YAAY,QAAQ,SAAS;AAC/B,uBAAmB,OAAO,OAAO;AACjC,WAAO;AAAA,EACT;AAEA,SAAO,OAAO,IAAI,MAAM;AAC1B;AAEA,IAAM,6BAA6B,CACjC,SACA,OACA,WACG;AACH,QAAM,SAAS,mBAAmB,IAAI,OAAO;AAE7C,MAAI,CAAC,QAAQ;AACX,uBAAmB,IAAI,SAAS;AAAA,MAC9B,SAAS,QAAQ;AAAA,MACjB,QAAQ,oBAAI,IAAI,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC;AAAA,IACnC,CAAC;AAED;AAAA,EACF;AAEA,QAAM,EAAE,SAAS,OAAO,IAAI;AAE5B,MAAI,YAAY,QAAQ,SAAS;AAC/B,uBAAmB,IAAI,SAAS;AAAA,MAC9B,SAAS,QAAQ;AAAA,MACjB,QAAQ,oBAAI,IAAI,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC;AAAA,IACnC,CAAC;AAED;AAAA,EACF;AAEA,SAAO,IAAI,QAAQ,KAAK;AAC1B;AAQO,SAAS,mCACd,SACoD;AACpD,QAAM,cAAc,2BAA2B,SAAS,CAAC;AAEzD,MAAI,aAAa;AACf,WAAO;AAAA,EACT;AAEA,QAAM,MAAM,6BAA6B,OAAO;AAIhD,QAAM,QAAQ,CAAC;AACf,QAAM,SAAS,CAAC;AAEhB,WAAS,MAAM,GAAG,MAAM,IAAI,QAAQ,OAAO,GAAG;AAC5C,UAAM,KAAK,IAAI,GAAG;AAClB,UAAM,YACJ,IAAI,MAAM,CAAC,KAAKC,gBAA2B,IAAI,MAAM,CAAC,EAAE,KAAK,MAAM,EAAE,CAAC;AACxE,YAAQ,GAAG,IAAI;AAAA,MACb,KAAK;AACH;AAAA,MACF,KAAK;AACH,YAAI,CAAC,WAAW;AACd,gBAAM,IAAI,MAAM,wBAAwB;AAAA,QAC1C;AAEA,cAAM;AAAA,UACJC;AAAA,YACEC;AAAA,cACE,QAAQ,IAAI,UAAU,CAAC;AAAA,cACvB,QAAQ,IAAI,UAAU,CAAC;AAAA,YACzB;AAAA,YACAA;AAAA,cACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,YACvB;AAAA,UACF;AAAA,QACF;AACA;AAAA,MACF,KAAK;AACH,YAAI,CAAC,WAAW;AACd,gBAAM,IAAI,MAAM,wBAAwB;AAAA,QAC1C;AAEA,eAAO;AAAA,UACLC;AAAA,YACED;AAAA,cACE,QAAQ,IAAI,UAAU,CAAC;AAAA,cACvB,QAAQ,IAAI,UAAU,CAAC;AAAA,YACzB;AAAA,YACAA;AAAA,cACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,YACvB;AAAA,YACAA;AAAA,cACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,YACvB;AAAA,YACAA;AAAA,cACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,YACvB;AAAA,UACF;AAAA,QACF;AACA;AAAA,MACF,SAAS;AACP,gBAAQ,MAAM,mBAAmB,GAAG,EAAE;AAAA,MACxC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,QAAQ,CAAC,OAAO,MAAM;AAC5B,6BAA2B,SAAS,OAAO,CAAC;AAE5C,SAAO;AACT;AAUO,SAAS,+BACd,SACA,SAAiB,GACmC;AACpD,QAAM,cAAc,2BAA2B,SAAS,MAAM;AAE9D,MAAI,aAAa;AACf,WAAO;AAAA,EACT;AAEA,MAAI,SAAS;AAAA,IACX,KAAK,IAAI,QAAQ,OAAO,QAAQ,MAAM;AAAA,IACtC;AAAA,EACF;AAEA,MAAI,WAAW,GAAG;AAChB,aAAS;AAAA,EACX;AAEA,QAAM,IAAIE;AAAA,IACRF,WAAU,QAAQ,GAAG,QAAQ,CAAC;AAAA,IAC9BA,WAAU,QAAQ,IAAI,QAAQ,OAAO,QAAQ,IAAI,QAAQ,MAAM;AAAA,EACjE;AAEA,QAAM,MAAMD;AAAA,IACVC,WAAuB,EAAE,CAAC,EAAE,CAAC,IAAI,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,IAChDA,WAAuB,EAAE,CAAC,EAAE,CAAC,IAAI,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,EAClD;AACA,QAAM,QAAQD;AAAA,IACZC,WAAuB,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,IAChDA,WAAuB,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,EAClD;AACA,QAAM,SAASD;AAAA,IACbC,WAAuB,EAAE,CAAC,EAAE,CAAC,IAAI,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,IAChDA,WAAuB,EAAE,CAAC,EAAE,CAAC,IAAI,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,EAClD;AACA,QAAM,OAAOD;AAAA,IACXC,WAAuB,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,IAChDA,WAAuB,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,EAClD;AAEA,QAAM,cAAc;AAAA,IAClBC;AAAA,MACE,KAAK,CAAC;AAAA,MACND;AAAA,QACE,KAAK,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;AAAA,QAC3C,KAAK,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;AAAA,MAC7C;AAAA,MACAA;AAAA,QACE,IAAI,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC;AAAA,QACzC,IAAI,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC;AAAA,MAC3C;AAAA,MACA,IAAI,CAAC;AAAA,IACP;AAAA;AAAA,IACAC;AAAA,MACE,IAAI,CAAC;AAAA,MACLD;AAAA,QACE,IAAI,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC;AAAA,QACzC,IAAI,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC;AAAA,MAC3C;AAAA,MACAA;AAAA,QACE,MAAM,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC;AAAA,QAC7C,MAAM,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC;AAAA,MAC/C;AAAA,MACA,MAAM,CAAC;AAAA,IACT;AAAA;AAAA,IACAC;AAAA,MACE,MAAM,CAAC;AAAA,MACPD;AAAA,QACE,MAAM,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC;AAAA,QAC7C,MAAM,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC;AAAA,MAC/C;AAAA,MACAA;AAAA,QACE,OAAO,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC;AAAA,QAC/C,OAAO,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC;AAAA,MACjD;AAAA,MACA,OAAO,CAAC;AAAA,IACV;AAAA;AAAA,IACAC;AAAA,MACE,OAAO,CAAC;AAAA,MACRD;AAAA,QACE,OAAO,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC;AAAA,QAC/C,OAAO,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC;AAAA,MACjD;AAAA,MACAA;AAAA,QACE,KAAK,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;AAAA,QAC3C,KAAK,CAAC,EAAE,CAAC,IAAK,IAAI,KAAM,EAAE,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;AAAA,MAC7C;AAAA,MACA,KAAK,CAAC;AAAA,IACR;AAAA;AAAA,EACF;AAEA,QAAM,UACJ,SAAS,IACL,YAAY;AAAA,IACV,CAAC,WACC;AAAA,MACE,kBAAkB,QAAQ,MAAM;AAAA,IAClC;AAAA,EACJ,IACA;AAAA,IACE,CAAC,YAAY,CAAC,CAAC;AAAA,IACf,CAAC,YAAY,CAAC,CAAC;AAAA,IACf,CAAC,YAAY,CAAC,CAAC;AAAA,IACf,CAAC,YAAY,CAAC,CAAC;AAAA,EACjB;AAEN,QAAM,QAAQ;AAAA,IACZD;AAAA,MACE,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,EAAE,CAAC;AAAA,MACnC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;AAAA,IACjB;AAAA,IACAA;AAAA,MACE,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,EAAE,CAAC;AAAA,MACnC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;AAAA,IACjB;AAAA,IACAA;AAAA,MACE,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,EAAE,CAAC;AAAA,MACnC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;AAAA,IACjB;AAAA,IACAA;AAAA,MACE,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,EAAE,CAAC;AAAA,MACnC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;AAAA,IACjB;AAAA,EACF;AACA,QAAM,QAAQ,CAAC,OAAO,QAAQ,KAAK,CAAC;AAEpC,6BAA2B,SAAS,OAAO,MAAM;AAEjD,SAAO;AACT;AAUO,SAAS,0BACd,SACA,SAAiB,GACmC;AACpD,QAAM,cAAc,2BAA2B,SAAS,MAAM;AAE9D,MAAI,aAAa;AACf,WAAO;AAAA,EACT;AAEA,QAAM,CAAC,MAAM,MAAM,QAAQ,QAAQ,SAAS,SAAS,OAAO,KAAK,IAC/D,iBAAiB,OAAO;AAC1B,QAAM,iBAAiB,QAAQ,YAC3B,gBAAgB,KAAK,IAAI,OAAO,KAAK,GAAG,OAAO,KAC9C,OAAO,SAAS;AACrB,QAAM,mBAAmB,QAAQ,YAC7B,gBAAgB,KAAK,IAAI,SAAS,IAAI,GAAG,OAAO,KAC/C,SAAS,QAAQ;AAEtB,QAAM,CAAC,KAAK,OAAO,QAAQ,IAAI,IAAmB;AAAA,IAChDC,WAAU,QAAQ,IAAI,MAAM,QAAQ,IAAI,IAAI;AAAA,IAC5CA,WAAU,QAAQ,IAAI,QAAQ,QAAQ,IAAI,MAAM;AAAA,IAChDA,WAAU,QAAQ,IAAI,SAAS,QAAQ,IAAI,OAAO;AAAA,IAClDA,WAAU,QAAQ,IAAI,OAAO,QAAQ,IAAI,KAAK;AAAA,EAChD;AAEA,QAAM,cAAc;AAAA,IAClBC;AAAA,MACED;AAAA,QACE,MAAM,CAAC,IAAI;AAAA,QACX,MAAM,CAAC,IAAI;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACAA;AAAA,QACE,MAAM,CAAC,IAAI;AAAA,QACX,MAAM,CAAC,IAAI;AAAA,MACb;AAAA,IACF;AAAA;AAAA,IACAC;AAAA,MACED;AAAA,QACE,OAAO,CAAC,IAAI;AAAA,QACZ,OAAO,CAAC,IAAI;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,MACAA;AAAA,QACE,OAAO,CAAC,IAAI;AAAA,QACZ,OAAO,CAAC,IAAI;AAAA,MACd;AAAA,IACF;AAAA;AAAA,IACAC;AAAA,MACED;AAAA,QACE,KAAK,CAAC,IAAI;AAAA,QACV,KAAK,CAAC,IAAI;AAAA,MACZ;AAAA,MACA;AAAA,MACA;AAAA,MACAA;AAAA,QACE,KAAK,CAAC,IAAI;AAAA,QACV,KAAK,CAAC,IAAI;AAAA,MACZ;AAAA,IACF;AAAA;AAAA,IACAC;AAAA,MACED;AAAA,QACE,IAAI,CAAC,IAAI;AAAA,QACT,IAAI,CAAC,IAAI;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,MACAA;AAAA,QACE,IAAI,CAAC,IAAI;AAAA,QACT,IAAI,CAAC,IAAI;AAAA,MACX;AAAA,IACF;AAAA;AAAA,EACF;AAEA,QAAM,UACJ,SAAS,IACL,YAAY;AAAA,IACV,CAAC,WACC;AAAA,MACE,kBAAkB,QAAQ,MAAM;AAAA,IAClC;AAAA,EACJ,IACA;AAAA,IACE,CAAC,YAAY,CAAC,CAAC;AAAA,IACf,CAAC,YAAY,CAAC,CAAC;AAAA,IACf,CAAC,YAAY,CAAC,CAAC;AAAA,IACf,CAAC,YAAY,CAAC,CAAC;AAAA,EACjB;AAEN,QAAM,QAAQ;AAAA,IACZD;AAAA,MACE,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,EAAE,CAAC;AAAA,MACnC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;AAAA,IACjB;AAAA,IACAA;AAAA,MACE,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,EAAE,CAAC;AAAA,MACnC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;AAAA,IACjB;AAAA,IACAA;AAAA,MACE,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,EAAE,CAAC;AAAA,MACnC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;AAAA,IACjB;AAAA,IACAA;AAAA,MACE,QAAQ,CAAC,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAC,EAAE,CAAC;AAAA,MACnC,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;AAAA,IACjB;AAAA,EACF;AAEA,QAAM,QAAQ,CAAC,OAAO,QAAQ,KAAK,CAAC;AAEpC,6BAA2B,SAAS,OAAO,MAAM;AAEjD,SAAO;AACT;AAIO,IAAM,cAAc,CACzB,QAEA,YAA2B,MACf;AACZ,MAAI,OAAO,UAAU,GAAG;AACtB,UAAM,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,CAAC;AAC3D,UAAMI,YAAWC,eAAc,OAAO,IAAI;AAI1C,WAAOD,aAAY,yBAAyB;AAAA,EAC9C;AACA,SAAO;AACT;AAEO,IAAM,kBAAkB,CAAC,GAAW,YAA+B;AACxE,MACE,QAAQ,WAAW,SAAS,UAAU,uBACtC,QAAQ,WAAW,SAAS,UAAU,QACtC;AACA,WAAO,IAAI;AAAA,EACb;AAEA,MAAI,QAAQ,WAAW,SAAS,UAAU,iBAAiB;AACzD,UAAM,kBAAkB,QAAQ,WAAW,SAAS;AAEpD,UAAM,cAAc,kBAAkB;AAEtC,QAAI,KAAK,aAAa;AACpB,aAAO,IAAI;AAAA,IACb;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;ACleA;AAAA,SAAS,aAAAE,YAAW,mBAAmB;AAEvC,SAAS,mBAAmB;AAkCrB,IAAM,4BAA4B,CACvC,YACiD;AACjD,SAAO,CAAC,CAAC,WAAW,QAAQ,SAAS,WAAW,CAAC,CAAC,QAAQ;AAC5D;AAEO,IAAM,iBAAiB,CAC5B,YACsC;AACtC,SAAO,CAAC,CAAC,WAAW,QAAQ,SAAS;AACvC;AAEO,IAAM,sBAAsB,CACjC,YAC2C;AAC3C,SAAO,CAAC,CAAC,WAAW,QAAQ,SAAS;AACvC;AAEO,IAAM,kBAAkB,CAC7B,YACuC;AACvC,SAAO,CAAC,CAAC,WAAW,QAAQ,SAAS;AACvC;AAEO,IAAM,sBAAsB,CACjC,YAC2C;AAC3C,SACE,CAAC,CAAC,YAAY,QAAQ,SAAS,YAAY,QAAQ,SAAS;AAEhE;AAEO,IAAM,gBAAgB,CAC3B,YACqC;AACrC,SAAO,WAAW,QAAQ,QAAQ,SAAS;AAC7C;AAEO,IAAM,iBAAiB,CAC5B,YACsC;AACtC,SAAO,WAAW,QAAQ,QAAQ,SAAS;AAC7C;AAEO,IAAM,sBAAsB,CACjC,YAC2C;AAC3C,SAAO,WAAW,QAAQ,QAAQ,SAAS;AAC7C;AAEO,IAAM,qBAAqB,CAChC,YAC0C;AAC1C,SACE,WAAW,SACV,QAAQ,SAAS,WAAW,QAAQ,SAAS;AAElD;AAEO,IAAM,oBAAoB,CAC/B,YACyC;AACzC,SAAO,WAAW,QAAQ,sBAAsB,QAAQ,IAAI;AAC9D;AAEO,IAAM,wBAAwB,CACnC,gBACY;AACZ,SAAO,gBAAgB;AACzB;AAEO,IAAM,kBAAkB,CAC7B,YACuC;AACvC,SAAO,WAAW,QAAQ,oBAAoB,QAAQ,IAAI;AAC5D;AAEO,IAAM,gBAAgB,CAC3B,YACqC;AACrC,SAAO,WAAW,QAAQ,QAAQ,SAAS;AAC7C;AAEO,IAAM,iBAAiB,CAC5B,YACsC;AACtC,SAAO,WAAW,QAAQ,QAAQ,SAAS;AAC7C;AAEO,IAAM,eAAe,CAC1B,YAC2C;AAC3C,SAAO,eAAe,OAAO,KAAK,QAAQ;AAC5C;AAKO,IAAM,gBAAgB,CAC3B,YACsC;AACtC,SAAO,eAAe,OAAO,KAAK,CAAC,QAAQ;AAC7C;AAEO,IAAM,eAAe,CAC1B,YACsC;AACtC,SAAO,eAAe,OAAO,KAAK,CAAC,QAAQ,WAAW,CAAC,QAAQ;AACjE;AAEO,IAAM,gBAAgB,CAC3B,YACsC;AACtC,SACE,eAAe,OAAO,KAAK,CAAC,QAAQ,WAAW,QAAQ,cAAc;AAEzE;AAEO,IAAM,sBAAsB,CACjC,gBACY;AACZ,SACE,gBAAgB,WAAW,gBAAgB;AAE/C;AAEO,IAAM,mBAAmB,CAC9B,SACA,gBAAgB,SACuB;AACvC,SACE,WAAW,SACV,CAAC,QAAQ,UAAU,kBAAkB,SACtC,qBAAqB,QAAQ,IAAI;AAErC;AAEO,IAAM,uBAAuB,CAClC,gBACY;AACZ,SAAO,gBAAgB;AACzB;AAEO,IAAM,oBAAoB,CAC/B,SACA,gBAAgB,SACyB;AACzC,SACE,WAAW,SACV,CAAC,QAAQ,UAAU,kBAAkB,UACrC,QAAQ,SAAS,eAChB,QAAQ,SAAS,aACjB,QAAQ,SAAS,aACjB,QAAQ,SAAS,WACjB,QAAQ,SAAS,YACjB,QAAQ,SAAS,gBACjB,QAAQ,SAAS,WACjB,QAAQ,SAAS,gBAChB,QAAQ,SAAS,UAAU,CAAC,QAAQ;AAE3C;AAEO,IAAM,wBAAwB,CACnC,YACyC;AACzC,SACE,WAAW,SACV,QAAQ,SAAS,eAChB,QAAQ,SAAS,aACjB,QAAQ,SAAS,WACjB,QAAQ,SAAS,YACjB,QAAQ,SAAS,gBACjB,QAAQ,SAAS,WACjB,QAAQ,SAAS,gBAChB,QAAQ,SAAS,UAAU,CAAC,QAAQ;AAE3C;AAIO,IAAM,uBAAuB,CAClC,YACyC;AACzC,SACE,WAAW,SACV,QAAQ,SAAS,eAChB,QAAQ,SAAS,WACjB,QAAQ,SAAS,UACjB,QAAQ,SAAS,YACjB,QAAQ,SAAS,gBACjB,QAAQ,SAAS,WACjB,QAAQ,SAAS,gBACjB,QAAQ,SAAS;AAEvB;AAEO,IAAM,0BAA0B,CACrC,SACA,gBAAgB,SACuB;AACvC,SACE,WAAW,SACV,CAAC,QAAQ,UAAU,kBAAkB,UACrC,QAAQ,SAAS,eAChB,QAAQ,SAAS,aACjB,QAAQ,SAAS,aACjB,eAAe,OAAO;AAE5B;AAEO,IAAM,sBAAsB,CACjC,YACiC;AACjC,QAAM,OAA0C,SAAS;AACzD,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AACA,UAAQ,MAAM;AAAA,IACZ,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK,aAAa;AAChB,aAAO;AAAA,IACT;AAAA,IACA,SAAS;AACP,kBAAY,MAAM,IAAI;AACtB,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAEO,IAAM,yBAAyB,CACpC,YAC8C;AAC9C,SACE,QAAQ,SAAS,eACjB,QAAQ,SAAS,aACjB,QAAQ,SAAS;AAErB;AAEO,IAAM,sBAAsB,CACjC,YAC2E;AAC3E,SACE,wBAAwB,OAAO,KAC/B,CAAC,CAAC,QAAQ,eAAe,KAAK,CAAC,EAAE,KAAK,MAAM,SAAS,MAAM;AAE/D;AAEO,IAAM,qBAAqB,CAChC,YACkD;AAClD,SACE,YAAY,QACZ,iBAAiB,WACjB,QAAQ,gBAAgB,QACxB,cAAc,OAAO;AAEzB;AAEO,IAAM,wBAAwB,CAAC,YAAoC;AACxE,SAAO,CAAC,CAAC,QAAQ,gBAAgB,CAAC,CAAC,QAAQ;AAC7C;AAEO,IAAM,wBAAwB,CAAC,SACpC,SAAS,eACT,SAAS,gBACT,SAAS,YACT,SAAS;AAEJ,IAAM,4BAA4B,CAAC,SACxC,SAAS,UAAU,SAAS,WAAW,SAAS;AAE3C,IAAM,iCAAiC,CAC5C,eACA,YACG;AACH,OACG,kBAAkBA,WAAU;AAAA;AAAA,EAG3B,kBAAkBA,WAAU,WAC9B,sBAAsB,QAAQ,IAAI,GAClC;AACA,WAAO;AAAA,EACT;AACA,MACE,kBAAkBA,WAAU,uBAC5B,0BAA0B,QAAQ,IAAI,GACtC;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,IAAM,oCAAoC,CAC/C,YACG;AACH,MAAI,0BAA0B,QAAQ,IAAI,GAAG;AAC3C,WAAO;AAAA,MACL,MAAMA,WAAU;AAAA,IAClB;AAAA,EACF;AAEA,MAAI,sBAAsB,QAAQ,IAAI,GAAG;AACvC,WAAO;AAAA,MACL,MAAMA,WAAU;AAAA,IAClB;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,sBAAsB,CACjC,YACiC;AACjC,SACE,OAAO,OAAO,SAAS,YAAY,KAClC,QAA8B,cAAc;AAEjD;AAGO,IAAM,WAAW,CAAC,QACvB,MAAM,QAAQ,GAAG,KACjB,IAAI,WAAW,KACf,OAAO,IAAI,CAAC,MAAM,YAClB,OAAO,IAAI,CAAC,MAAM,YAClB,OAAO,IAAI,CAAC,MAAM,YAClB,OAAO,IAAI,CAAC,MAAM;AAEb,IAAM,0BAA0B,CACrC,YACmC;AACnC,MAAI,aAAa,OAAO,GAAG;AACzB,WAAO;AAAA,EACT;AACA,MAAI,cAAc,OAAO,GAAG;AAC1B,WAAO;AAAA,EACT;AACA,MAAI,aAAa,OAAO,GAAG;AACzB,WAAO;AAAA,EACT;AACA,SAAO;AACT;AASO,IAAM,iBAAiB,CAC5B,WACY;AACZ,SAAO,OAAO,SAAS,KAAK,YAAY,OAAO,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,CAAC;AAC9E;AAEO,IAAM,mBAAmB,CAC9B,WACY;AACZ,SACE,OAAO,SAAS;AAAA,EAEf,OAAO,WAAW,KAAK,CAAC,YAAY,OAAO,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,CAAC;AAE7E;;;AC9ZA;AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA,sBAAAC;AAAA,EACA,qBAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA,iBAAAC;AAAA,EACA;AAAA,EACA,aAAAC;AAAA,OACK;;;ACVP;AAEO,IAAM,yBAMT,CAAC;AAEE,IAAM,+BAA+B,CAC1C,IACA,WACG;AACH,QAAM,OACJ,uBAAuB,EAAE,MAAM,uBAAuB,EAAE,IAAI,EAAE,OAAO;AACvE,OAAK,SAAS;AACd,SAAO;AACT;AAEO,IAAM,8BAA8B,CACzC,OACG;AACH,MAAI,uBAAuB,EAAE,GAAG;AAC9B,WAAO,uBAAuB,EAAE;AAAA,EAClC;AACF;AAEO,IAAM,sCAAsC,CACjD,OACG;AACH,SAAO,uBAAuB,EAAE,GAAG,UAAU;AAC/C;;;AChCA;AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAIA,IAAM,cAAc,CACzB,MACA,MACA,eACG;AACH,QAAM,QAAQ,KACX,MAAM,IAAI,EAGV,IAAI,CAAC,MAAM,KAAK,GAAG,EACnB,KAAK,IAAI;AACZ,QAAM,WAAW,WAAW,IAAI;AAChC,QAAM,SAAS,cAAc,OAAO,UAAU,UAAU;AACxD,QAAM,QAAQ,aAAa,OAAO,IAAI;AACtC,SAAO,EAAE,OAAO,OAAO;AACzB;AAEA,IAAM,aAAa,uCAAuC,kBAAkB;AAGrE,IAAM,wBAAwB,CACnC,MACA,eACG;AACH,QAAM,eAAe,gBAAgB,IAAI;AACzC,MAAI,iBAAiB,GAAG;AACtB,WACE,YAAY,WAAW,MAAM,EAAE,EAAE,KAAK,IAAI,GAAG,MAAM,UAAU,EAAE,QAC/D,qBAAqB;AAAA,EAEzB;AACA,SAAO,eAAe,qBAAqB;AAC7C;AAEO,IAAM,yBAAyB,CACpC,MACA,eACG;AACH,SAAO,YAAY,IAAI,MAAM,UAAU,EAAE,QAAQ,qBAAqB;AACxE;AAEO,IAAM,yBAAyB,MAAM;AAC1C,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA,cAAc;AAAA,MACZ,UAAU;AAAA,MACV,YAAY;AAAA,IACd,CAAC;AAAA,EACH;AACA,SAAO,QAAQ;AACjB;AAEO,IAAM,gBAAgB,CAAC,SAAiB;AAC7C,SACE,aAAa,IAAI,EAEd,QAAQ,OAAO,UAAU;AAEhC;AAEA,IAAM,iBAAiB,CAAC,SAAiB;AACvC,SAAO,cAAc,IAAI,EAAE,MAAM,IAAI;AACvC;AAMO,IAAM,mBAAmB,CAAC,gBAAuC;AACtE,QAAM,YAAY,eAAe,YAAY,IAAI,EAAE;AACnD,SAAQ,YAAY,SAClB,YACA,YAAY;AAChB;AAMO,IAAM,oBAAoB,CAC/B,UACA,eACG;AACH,SAAO,WAAW;AACpB;AAGO,IAAM,yBAAyB,CACpC,UACA,eACG;AACH,SAAO,kBAAkB,UAAU,UAAU,IAAI,qBAAqB;AACxE;AAEA,IAAI;AAOG,IAAM,+BAA+B,CAAC,aAAkC;AAC7E,wBAAsB;AACxB;AAMA,IAAM,4BAAN,MAA+D;AAAA,EACrD;AAAA,EAER,cAAc;AACZ,SAAK,SAAS,SAAS,cAAc,QAAQ;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,aAAa,MAAc,YAAgC;AAChE,UAAM,UAAU,KAAK,OAAO,WAAW,IAAI;AAC3C,YAAQ,OAAO;AACf,UAAM,UAAU,QAAQ,YAAY,IAAI;AACxC,UAAM,eAAe,QAAQ;AAK7B,QAAI,UAAU,GAAG;AACf,aAAO,eAAe;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AACF;AAEO,IAAM,eAAe,CAAC,MAAc,SAAqB;AAC9D,MAAI,CAAC,qBAAqB;AACxB,0BAAsB,IAAI,0BAA0B;AAAA,EACtD;AAEA,SAAO,oBAAoB,aAAa,MAAM,IAAI;AACpD;AAEO,IAAM,eAAe,CAAC,MAAc,SAAqB;AAC9D,QAAM,QAAQ,eAAe,IAAI;AACjC,MAAI,QAAQ;AACZ,QAAM,QAAQ,CAACC,UAAS;AACtB,YAAQ,KAAK,IAAI,OAAO,aAAaA,OAAM,IAAI,CAAC;AAAA,EAClD,CAAC;AAED,SAAO;AACT;AAEO,IAAM,gBAAgB,CAC3B,MACA,UACA,eACG;AACH,QAAM,YAAY,eAAe,IAAI,EAAE;AACvC,SAAO,kBAAkB,UAAU,UAAU,IAAI;AACnD;AAEO,IAAM,YAAa,uBAAM;AAC9B,QAAM,kBAAwD,CAAC;AAE/D,QAAM,YAAY,CAAC,MAAc,SAAqB;AACpD,UAAM,UAAU,KAAK,WAAW,CAAC;AACjC,QAAI,CAAC,gBAAgB,IAAI,GAAG;AAC1B,sBAAgB,IAAI,IAAI,CAAC;AAAA,IAC3B;AACA,QAAI,CAAC,gBAAgB,IAAI,EAAE,OAAO,GAAG;AACnC,YAAM,QAAQ,aAAa,MAAM,IAAI;AACrC,sBAAgB,IAAI,EAAE,OAAO,IAAI;AAAA,IACnC;AAEA,WAAO,gBAAgB,IAAI,EAAE,OAAO;AAAA,EACtC;AAEA,QAAM,WAAW,CAAC,SAAqB;AACrC,WAAO,gBAAgB,IAAI;AAAA,EAC7B;AAEA,QAAM,aAAa,CAAC,SAAqB;AACvC,oBAAgB,IAAI,IAAI,CAAC;AAAA,EAC3B;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF,GAAG;AAEI,IAAM,kBAAkB,CAAC,SAAqB;AACnD,QAAM,QAAQ,UAAU,SAAS,IAAI;AACrC,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AACA,QAAM,oBAAoB,MAAM,OAAO,CAAC,QAAQ,QAAQ,MAAS;AAEjE,SAAO,KAAK,IAAI,GAAG,iBAAiB;AACtC;AAEO,IAAM,kBAAkB,CAAC,SAAqB;AACnD,QAAM,QAAQ,UAAU,SAAS,IAAI;AACrC,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AACA,QAAM,oBAAoB,MAAM,OAAO,CAAC,QAAQ,QAAQ,MAAS;AACjE,SAAO,KAAK,IAAI,GAAG,iBAAiB;AACtC;;;AClOA;AAAA,SAAS,UAAU,aAAAC,kBAAiB;AAMpC,IAAI;AACJ,IAAI;AACJ,IAAI;AAKG,IAAM,cAAc,CAAC,SAAiB;AAC3C,MAAI,CAAC,gBAAgB;AACnB,qBAAiB,MAAM,MAAM,GAAG,OAAO,OAAO,GAAG,CAAC;AAAA,EACpD;AAEA,SAAO,eAAe,KAAK,IAAI;AACjC;AAEA,IAAM,oBAAoB,MAAM;AAC9B,MAAI,CAAC,sBAAsB;AACzB,QAAI;AACF,6BAAuB,0BAA0B;AAAA,IACnD,QAAQ;AACN,6BAAuB,wBAAwB;AAAA,IACjD;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,gBAAgB,MAAM;AAC1B,MAAI,CAAC,kBAAkB;AACrB,uBAAmB,qBAAqB;AAAA,EAC1C;AAEA,SAAO;AACT;AAKA,IAAM,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASb,YAAY;AAAA,EACZ,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWR,SAAS;AAAA,EACT,SAAS;AACX;AAKA,IAAM,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMV,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcN,SAAQ;AAAA,EACR,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOT,UAAU;AACZ;AAEA,IAAM,QAAQ;AAAA,EACZ,MAAM;AAAA,EACN,QACE;AAAA,EACF,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AACR;AAWA,IAAM,0BAA0B,MAC9B,MAAM;AAAA,EACJ,cAAc;AAAA,EACd,MAAM,GAAG,OAAO,QAAQ,OAAO,YAAY,IAAI,IAAI;AACrD;AASF,IAAM,4BAA4B,MAChC,MAAM;AAAA;AAAA,EAEJ,cAAc;AAAA;AAAA,EAEd,MAAM,OAAO,OAAO,UAAU,EAAE,MAAM;AAAA,EACtC,MAAM,MAAM,OAAO,YAAY,OAAO,MAAM,EAAE,MAAM;AAAA;AAAA,EAEpD,MAAM,OAAO,IAAI,MAAM,IAAI,QAAQ,EAChC,cAAc,OAAO,SAAS,IAAI,OAAO,EACzC,MAAM;AAAA,EACT,MAAM,MAAM,IAAI,IAAI,EACjB,cAAc,OAAO,QAAQ,OAAO,SAAS,IAAI,OAAO,EACxD,MAAM;AAAA;AAAA,EAET,MAAM,WAAW,IAAI,OAAO,EAAE,cAAc,OAAO,OAAO,EAAE,MAAM;AAAA,EAClE,MAAM,UAAU,IAAI,OAAO,EAAE,cAAc,OAAO,OAAO,EAAE,MAAM;AAAA,EACjE,MAAM,UAAU,OAAO,OAAO,EAAE,WAAW,OAAO,OAAO,EAAE,MAAM;AACnE;AAyBF,IAAM,uBAAuB,MAC3B,MAAM;AAAA,EACJ,MAAM;AAAA,IACJ,MAAM;AAAA,IACN,MAAM;AAAA,MACJ,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,MAAM,MAAM,IAAI,MAAM,MAAM,MAAM,KAAK,MAAM,IAAI,MAAM,IAAI,MAAM,GAAG,MAAM,OAAO,MAAM;AAAA,MACzF;AAAA,IACF;AAAA,EACF;AACF;AAKF,IAAM,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIZ,OAAO,CAAC,UAA0B,IAAI,OAAO,OAAO,GAAG;AAAA;AAAA;AAAA;AAAA,EAIvD,MAAM,IAAI,YAA8B,QAAQ,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE;AAAA;AAAA;AAAA;AAAA,EAI5E,KAAK,IAAI,YAA8B,MAAM,MAAM,MAAM,KAAK,GAAG,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAIzE,IAAI,IAAI,YACN,MAAM,MAAM,QAAQ,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,GAAG,CAAC;AAAA;AAAA;AAAA;AAAA,EAIpD,OAAO,IAAI,YACT,MAAM,MAAM,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG;AAAA;AAAA;AAAA;AAAA,EAI3C,OAAO,IAAI,YACT,MAAM,MAAM,IAAI,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG;AAC7C;AAMA,IAAM,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIZ,IAAI,IAAI,YAAsB;AAC5B,UAAM,SAAS,MAAM,KAAK,GAAG,OAAO;AACpC,WAAO,MAAM,MAAM,KAAK,MAAM,IAAI;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ,IAAI,YAAsB;AAChC,UAAM,SAAS,MAAM,KAAK,GAAG,OAAO;AACpC,UAAM,UAAU,MAAM,MAAM,MAAM,OAAO,MAAM,IAAI;AACnD,WAAO,MAAM,MAAM,OAAO;AAAA,EAI5B;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO,IAAI,YAAsB;AAC/B,UAAM,SAAS,MAAM,KAAK,GAAG,OAAO;AACpC,UAAM,UAAU,MAAM,MAAM,MAAM,QAAQ,MAAM,IAAI;AACpD,WAAO,MAAM,MAAM,OAAO;AAAA,EAI5B;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY,IAAI,YAAsB;AACpC,UAAM,SAAS,MAAM,KAAK,GAAG,OAAO;AACpC,UAAM,UAAU,MAAM,MAAM,MAAM,QAAQ,MAAM,SAAS,MAAM,IAAI;AACnE,WAAO,MAAM,MAAM,OAAO;AAAA,EAI5B;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW,IAAI,YAAsB;AACnC,UAAM,SAAS,MAAM,KAAK,GAAG,OAAO;AACpC,UAAM,UAAU,MAAM,MAAM,MAAM,QAAQ,MAAM,SAAS,MAAM,IAAI;AACnE,WAAO,MAAM,MAAM,OAAO;AAAA,EAI5B;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW,IAAI,YAAsB;AACnC,UAAM,SAAS,MAAM,KAAK,GAAG,OAAO;AACpC,UAAM,UAAU,MAAM,MAAM,MAAM,OAAO,MAAM,IAAI;AACnD,WAAO,MAAM,MAAM,OAAO;AAAA,EAI5B;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU,IAAI,YAAsB;AAClC,UAAM,SAAS,MAAM,KAAK,GAAG,OAAO;AACpC,UAAM,UAAU,MAAM,MAAM,MAAM,QAAQ,MAAM,IAAI;AACpD,WAAO,MAAM,MAAM,OAAO;AAAA,EAI5B;AAAA,EACA,OAAO,CAAC,iBAA+B;AAAA;AAAA;AAAA;AAAA,IAIrC,OAAO;AAAA;AAAA;AAAA;AAAA,IAIP,aAAa,IAAI,YAAsB;AACrC,YAAM,OAAO,YAAY;AACzB,YAAM,YAAY,MAAM,MAAM,GAAG,OAAO,EAAE,MAAM;AAChD,YAAM,UAAU,MAAM,MAAM,IAAI,WAAW,IAAI;AAC/C,aAAO,MAAM,MAAM,OAAO;AAAA,IAI5B;AAAA;AAAA;AAAA;AAAA,IAIA,YAAY,IAAI,YAAsB;AACpC,YAAM,OAAO,YAAY;AACzB,YAAM,WAAW,MAAM,OAAO,GAAG,OAAO,EAAE,MAAM;AAChD,YAAM,UAAU,MAAM,MAAM,IAAI,MAAM,QAAQ;AAC9C,aAAO,MAAM,MAAM,OAAO;AAAA,IAI5B;AAAA;AAAA;AAAA;AAAA,IAIA,eAAe,IAAI,YAAsB;AACvC,YAAM,OAAO,YAAY;AACzB,YAAM,eAAe,MAAM,SAAS,GAAG,OAAO,EAAE,MAAM;AACtD,YAAM,UAAU,MAAM,MAAM,IAAI,cAAc,IAAI;AAClD,aAAO,MAAM,MAAM,OAAO;AAAA,IAI5B;AAAA;AAAA;AAAA;AAAA,IAIA,eAAe,IAAI,YAAsB;AACvC,YAAM,OAAO,YAAY;AACzB,YAAM,cAAc,MAAM,UAAU,GAAG,OAAO,EAAE,MAAM;AACtD,YAAM,UAAU,MAAM,MAAM,IAAI,MAAM,WAAW;AACjD,aAAO,MAAM,MAAM,OAAO;AAAA,IAI5B;AAAA,EACF;AACF;AAKO,IAAM,cAAc,CAACC,UAAiB;AAC3C,QAAM,iBAAiB,kBAAkB;AAKzC,SAAOA,MAAK,UAAU,KAAK,EAAE,MAAM,cAAc,EAAE,OAAO,OAAO;AACnE;AAKO,IAAM,WAAW,CACtB,MACA,MACA,aACW;AAIX,MAAI,CAAC,OAAO,SAAS,QAAQ,KAAK,WAAW,GAAG;AAC9C,WAAO;AAAA,EACT;AAEA,QAAM,QAAuB,CAAC;AAC9B,QAAM,gBAAgB,KAAK,MAAM,IAAI;AAErC,aAAW,gBAAgB,eAAe;AACxC,UAAM,mBAAmB,aAAa,cAAc,IAAI;AAExD,QAAI,oBAAoB,UAAU;AAChC,YAAM,KAAK,YAAY;AACvB;AAAA,IACF;AAEA,UAAM,cAAc,SAAS,cAAc,MAAM,QAAQ;AACzD,UAAM,KAAK,GAAG,WAAW;AAAA,EAC3B;AAEA,SAAO,MAAM,KAAK,IAAI;AACxB;AAKA,IAAM,WAAW,CACfA,OACA,MACA,aACa;AACb,QAAM,QAAuB,CAAC;AAC9B,QAAM,SAAS,YAAYA,KAAI;AAC/B,QAAM,gBAAgB,OAAO,OAAO,QAAQ,EAAE;AAE9C,MAAI,cAAc;AAClB,MAAI,mBAAmB;AAEvB,MAAI,WAAW,cAAc,KAAK;AAElC,SAAO,CAAC,SAAS,MAAM;AACrB,UAAM,QAAQ,SAAS;AACvB,UAAM,WAAW,cAAc;AAG/B,UAAM,gBAAgB,kBAAkB,KAAK,IACzC,mBAAmB,UAAU,UAAU,OAAO,IAAI,IAClD,aAAa,UAAU,IAAI;AAG/B,QAAI,KAAK,KAAK,KAAK,KAAK,iBAAiB,UAAU;AACjD,oBAAc;AACd,yBAAmB;AACnB,iBAAW,cAAc,KAAK;AAC9B;AAAA,IACF;AAGA,QAAI,CAAC,aAAa;AAChB,YAAM,cAAc,SAAS,OAAO,MAAM,QAAQ;AAClD,YAAM,eAAe,YAAY,YAAY,SAAS,CAAC,KAAK;AAC5D,YAAM,iBAAiB,YAAY,MAAM,GAAG,EAAE;AAE9C,YAAM,KAAK,GAAG,cAAc;AAG5B,oBAAc;AACd,yBAAmB,aAAa,cAAc,IAAI;AAClD,iBAAW,cAAc,KAAK;AAAA,IAChC,OAAO;AAEL,YAAM,KAAK,YAAY,QAAQ,CAAC;AAGhC,oBAAc;AACd,yBAAmB;AAAA,IACrB;AAAA,EACF;AAGA,MAAI,aAAa;AACf,UAAM,eAAe,SAAS,aAAa,MAAM,QAAQ;AACzD,UAAM,KAAK,YAAY;AAAA,EACzB;AAEA,SAAO;AACT;AAKA,IAAM,WAAW,CACf,MACA,MACA,aACkB;AAElB,MAAI,cAAc,EAAE,KAAK,IAAI,GAAG;AAC9B,WAAO,CAAC,IAAI;AAAA,EACd;AAEA,yBAAuB,IAAI;AAE3B,QAAM,QAAuB,CAAC;AAC9B,QAAM,QAAQ,MAAM,KAAK,IAAI;AAE7B,MAAI,cAAc;AAClB,MAAI,mBAAmB;AAEvB,aAAW,QAAQ,OAAO;AACxB,UAAM,aAAa,UAAU,UAAU,MAAM,IAAI;AACjD,UAAM,gBAAgB,mBAAmB;AAEzC,QAAI,iBAAiB,UAAU;AAC7B,oBAAc,cAAc;AAC5B,yBAAmB;AACnB;AAAA,IACF;AAEA,QAAI,aAAa;AACf,YAAM,KAAK,WAAW;AAAA,IACxB;AAEA,kBAAc;AACd,uBAAmB;AAAA,EACrB;AAEA,MAAI,aAAa;AACf,UAAM,KAAK,WAAW;AAAA,EACxB;AAEA,SAAO;AACT;AAKA,IAAM,WAAW,CAACA,OAAc,MAAkB,aAAqB;AACrE,QAAM,wBAAwB,aAAaA,OAAM,IAAI,IAAI;AAEzD,MAAI,CAAC,uBAAuB;AAC1B,WAAOA;AAAA,EACT;AAGA,MAAI,CAAC,EAAE,aAAa,WAAW,IAAIA,MAAK,MAAM,cAAc,KAAK;AAAA,IAC/DA;AAAA,IACAA,MAAK,QAAQ;AAAA,IACb;AAAA,EACF;AAEA,MAAI,mBAAmB,aAAa,aAAa,IAAI;AAErD,aAAW,cAAc,MAAM,KAAK,WAAW,GAAG;AAChD,UAAM,aAAa,UAAU,UAAU,YAAY,IAAI;AACvD,UAAM,gBAAgB,mBAAmB;AAEzC,QAAI,gBAAgB,UAAU;AAC5B;AAAA,IACF;AAEA,kBAAc,cAAc;AAC5B,uBAAmB;AAAA,EACrB;AAEA,SAAO;AACT;AAOA,IAAM,oBAAoB,CAAC,yBAAiC;AAC1D,SACE,qBAAqB,YAAY,CAAC,MAAM,UACxC,qBAAqB,YAAY,CAAC,MAAM;AAE5C;AAKA,IAAM,yBAAyB,CAAC,SAAiB;AAC/C,MAAIC,WAAU,KAAK,SAAS,GAAG;AAC7B,QAAI,KAAK,KAAK,IAAI,GAAG;AACnB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC5D;AAAA,EACF;AACF;;;AH5gBO,IAAM,wBAAwB,CACnC,aACA,WACA,UACG;AACH,QAAM,cAAc,MAAM,yBAAyB;AAEnD,MAAI,WAAW;AAEf,MAAI,CAAC,UAAU,GAAG;AAChB,IAAAC;AAAA,MACE,CAAC,aAAa,CAAC,eAAe,SAAS,KAAK,YAAY,UAAU;AAAA,MAClE;AAAA,IACF;AAAA,EACF;AAEA,QAAM,mBAAmB;AAAA,IACvB,GAAG,YAAY;AAAA,IACf,GAAG,YAAY;AAAA,IACf,MAAM,YAAY;AAAA,IAClB,OAAO,YAAY;AAAA,IACnB,QAAQ,YAAY;AAAA,IACpB,OAAQ,YACJ,eAAe,SAAS,IACtB,IACA,UAAU,QACZ,YAAY;AAAA,EAClB;AAEA,mBAAiB,OAAO,YAAY;AAEpC,MAAI,aAAa,CAAC,YAAY,YAAY;AACxC,eAAW,YACP,qBAAqB,WAAW,WAAW,IAC3C,YAAY;AAChB,qBAAiB,OAAO;AAAA,MACtB,YAAY;AAAA,MACZC,eAAc,WAAW;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAEA,QAAM,UAAU;AAAA,IACd,iBAAiB;AAAA,IACjBA,eAAc,WAAW;AAAA,IACzB,YAAY;AAAA,EACd;AAGA,MAAI,YAAY,YAAY;AAC1B,qBAAiB,QAAQ,QAAQ;AAAA,EACnC;AACA,mBAAiB,SAAS,QAAQ;AAElC,MAAI,WAAW;AACb,UAAM,qBAAqB;AAAA,MACzB;AAAA,MACA;AAAA,IACF;AACA,UAAM,oBAAoB,qBAAqB,WAAW,WAAW;AAErE,QAAI,CAAC,eAAe,SAAS,KAAK,QAAQ,SAAS,oBAAoB;AACrE,YAAM,aAAa;AAAA,QACjB,QAAQ;AAAA,QACR,UAAU;AAAA,MACZ;AACA,YAAM,cAAc,WAAW,EAAE,QAAQ,WAAW,CAAC;AACrD,mCAA6B,UAAU,IAAI,UAAU;AAAA,IACvD;AAEA,QAAI,QAAQ,QAAQ,mBAAmB;AACrC,YAAM,YAAY;AAAA,QAChB,QAAQ;AAAA,QACR,UAAU;AAAA,MACZ;AACA,YAAM,cAAc,WAAW,EAAE,OAAO,UAAU,CAAC;AAAA,IACrD;AAEA,UAAM,qBAAqB;AAAA,MACzB,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAEA,UAAM,EAAE,GAAG,EAAE,IAAI;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,qBAAiB,IAAI;AACrB,qBAAiB,IAAI;AAAA,EACvB;AAEA,QAAM,cAAc,aAAa,gBAAgB;AACnD;AAEO,IAAM,uBAAuB,CAClC,WACA,OACA,qBACA,4BAA4B,UACzB;AACH,QAAM,cAAc,MAAM,yBAAyB;AACnD,QAAM,qBAAqB,sBAAsB,SAAS;AAC1D,MAAI,CAAC,oBAAoB;AACvB;AAAA,EACF;AACA,8BAA4B,UAAU,EAAE;AACxC,QAAM,cAAc,oBAAoB,WAAW,WAAW;AAC9D,MAAI,eAAe,YAAY,MAAM;AACnC,QAAI,CAAC,WAAW;AACd;AAAA,IACF;AAEA,QAAI,OAAO,YAAY;AACvB,QAAI,aAAa,YAAY;AAC7B,QAAI,YAAY,YAAY;AAC5B,UAAM,WAAW,qBAAqB,WAAW,WAAW;AAC5D,UAAM,YAAY,sBAAsB,WAAW,WAAW;AAC9D,QAAI,kBAAkB,UAAU;AAChC,QACE,6BACC,wBAAwB,OAAO,wBAAwB,KACxD;AACA,UAAI,MAAM;AACR,eAAO;AAAA,UACL,YAAY;AAAA,UACZA,eAAc,WAAW;AAAA,UACzB;AAAA,QACF;AAAA,MACF;AACA,YAAM,UAAU;AAAA,QACd;AAAA,QACAA,eAAc,WAAW;AAAA,QACzB,YAAY;AAAA,MACd;AACA,mBAAa,QAAQ;AACrB,kBAAY,QAAQ;AAAA,IACtB;AAEA,QAAI,aAAa,WAAW;AAC1B,wBAAkB;AAAA,QAChB;AAAA,QACA,UAAU;AAAA,MACZ;AAEA,YAAM,OAAO,kBAAkB,UAAU;AAEzC,YAAM,WACJ,CAAC,eAAe,SAAS,MACxB,wBAAwB,QACvB,wBAAwB,QACxB,wBAAwB,OACtB,UAAU,IAAI,OACd,UAAU;AAChB,YAAM,cAAc,WAAW;AAAA,QAC7B,QAAQ;AAAA,QACR,GAAG;AAAA,MACL,CAAC;AAAA,IACH;AAEA,UAAM,cAAc,aAAa;AAAA,MAC/B;AAAA,MACA,OAAO;AAAA,MACP,QAAQ;AAAA,IACV,CAAC;AAED,QAAI,CAAC,eAAe,SAAS,GAAG;AAC9B,YAAM;AAAA,QACJ;AAAA,QACA,yBAAyB,WAAW,aAAa,WAAW;AAAA,MAC9D;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,2BAA2B,CACtC,WACA,kBACA,gBACG;AACH,MAAI,eAAe,SAAS,GAAG;AAC7B,WAAO,oBAAoB;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,QAAM,kBAAkB,mBAAmB,SAAS;AACpD,QAAM,qBAAqB,sBAAsB,WAAW,gBAAgB;AAC5E,QAAM,oBAAoB,qBAAqB,WAAW,gBAAgB;AAE1E,MAAI;AACJ,MAAI;AACJ,MAAI,iBAAiB,kBAAkB,eAAe,KAAK;AACzD,QAAI,gBAAgB;AAAA,EACtB,WAAW,iBAAiB,kBAAkB,eAAe,QAAQ;AACnE,QAAI,gBAAgB,KAAK,qBAAqB,iBAAiB;AAAA,EACjE,OAAO;AACL,QACE,gBAAgB,KACf,qBAAqB,IAAI,iBAAiB,SAAS;AAAA,EACxD;AACA,MAAI,iBAAiB,cAAc,WAAW,MAAM;AAClD,QAAI,gBAAgB;AAAA,EACtB,WAAW,iBAAiB,cAAc,WAAW,OAAO;AAC1D,QAAI,gBAAgB,KAAK,oBAAoB,iBAAiB;AAAA,EAChE,OAAO;AACL,QACE,gBAAgB,KAAK,oBAAoB,IAAI,iBAAiB,QAAQ;AAAA,EAC1E;AACA,SAAO,EAAE,GAAG,EAAE;AAChB;AAEO,IAAM,wBAAwB,CAAC,cAAwC;AAC5E,SAAO,WAAW,eAAe,SAC7B,WAAW,eAAe,KAAK,CAAC,QAAQ,IAAI,SAAS,MAAM,GAAG,MAAM,OACpE;AACN;AAEO,IAAM,sBAAsB,CACjC,SACA,gBACG;AACH,MAAI,CAAC,SAAS;AACZ,WAAO;AAAA,EACT;AACA,QAAM,qBAAqB,sBAAsB,OAAO;AAExD,MAAI,oBAAoB;AACtB,WAAQ,YAAY,IAAI,kBAAkB,KACxC;AAAA,EACJ;AACA,SAAO;AACT;AAEO,IAAM,sBAAsB,CACjC,SACA,gBACmC;AACnC,MAAI,CAAC,SAAS;AACZ,WAAO;AAAA,EACT;AACA,MAAI,QAAQ,aAAa;AACvB,WAAQ,YAAY,IAAI,QAAQ,WAAW,KACzC;AAAA,EACJ;AACA,SAAO;AACT;AAEO,IAAM,qBAAqB,CAChC,WACA,UACA,gBACG;AACH,MAAI,CAAC,eAAe,SAAS,GAAG;AAC9B,WAAO;AAAA,MACL,GAAG,UAAU,IAAI,UAAU,QAAQ;AAAA,MACnC,GAAG,UAAU,IAAI,UAAU,SAAS;AAAA,IACtC;AAAA,EACF;AACA,QAAM,SAAS,oBAAoB;AAAA,IACjC;AAAA,IACA;AAAA,EACF;AACA,MAAI,OAAO,SAAS,MAAM,GAAG;AAC3B,UAAMC,SAAQ,KAAK,MAAM,UAAU,OAAO,SAAS,CAAC;AACpD,UAAM,WAAW,oBAAoB;AAAA,MACnC;AAAA,MACA,UAAU,OAAOA,MAAK;AAAA,MACtB;AAAA,IACF;AACA,WAAO,EAAE,GAAG,SAAS,CAAC,GAAG,GAAG,SAAS,CAAC,EAAE;AAAA,EAC1C;AACA,QAAM,QAAQ,UAAU,OAAO,SAAS,IAAI;AAC5C,MAAI,qBAAqB,oBAAoB;AAAA,IAC3C;AAAA,IACA;AAAA,IACA;AAAA,EACF,EAAE,KAAK;AACP,MAAI,CAAC,oBAAoB;AACvB,yBAAqB,oBAAoB;AAAA,MACvC;AAAA,MACA,QAAQ;AAAA,IACV;AAAA,EACF;AACA,SAAO,EAAE,GAAG,mBAAmB,CAAC,GAAG,GAAG,mBAAmB,CAAC,EAAE;AAC9D;AAEO,IAAM,qBAAqB,CAAC,cAA2C;AAC5E,MAAI,UAAUC;AACd,MAAI,UAAUA;AAEd,MAAI,UAAU,SAAS,WAAW;AAEhC,eAAY,UAAU,QAAQ,KAAM,IAAI,KAAK,KAAK,CAAC,IAAI;AACvD,eAAY,UAAU,SAAS,KAAM,IAAI,KAAK,KAAK,CAAC,IAAI;AAAA,EAC1D;AAEA,MAAI,UAAU,SAAS,WAAW;AAChC,eAAW,UAAU,QAAQ;AAC7B,eAAW,UAAU,SAAS;AAAA,EAChC;AACA,SAAO;AAAA,IACL,GAAG,UAAU,IAAI;AAAA,IACjB,GAAG,UAAU,IAAI;AAAA,EACnB;AACF;AAEO,IAAM,sBAAsB,CACjC,aACA,cACG;AACH,MAAI,eAAe,SAAS,GAAG;AAC7B,WAAO;AAAA,EACT;AACA,MAAI,CAAC,WAAW;AACd,WAAO,YAAY;AAAA,EACrB;AACA,SAAO,UAAU;AACnB;AAEO,IAAM,8BAA8B,CACzC,WACA,kBACA,gBACG;AACH,MAAI,eAAe,SAAS,GAAG;AAC7B,WAAO,oBAAoB;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,2BAA2B,CACtC,kBACA,gBACG;AACH,SAAO,iBAAiB,KAAK,CAAC,YAAY;AACxC,QAAI,mBAAmB,OAAO,GAAG;AAC/B,YAAM,YAAY,oBAAoB,SAAS,WAAW;AAC1D,UAAI,eAAe,SAAS,GAAG;AAC7B,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AACH;AAEO,IAAM,2BAA2B,CACtC,kBACA,gBACG;AACH,SAAO,iBAAiB,KAAK,CAAC,YAAY;AACxC,QAAI,mBAAmB,OAAO,GAAG;AAC/B,YAAM,YAAY,oBAAoB,SAAS,WAAW;AAC1D,UAAI,eAAe,SAAS,GAAG;AAC7B,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAEA,WAAO,cAAc,OAAO;AAAA,EAC9B,CAAC;AACH;AAEA,IAAM,wBAAwB,oBAAI,IAAI;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAEM,IAAM,uBAAuB,CAAC,YAE/B,sBAAsB,IAAI,QAAQ,IAAI;AAErC,IAAM,wCAAwC,CACnD,WACA,kBACG;AACH,cAAY,KAAK,KAAK,SAAS;AAC/B,QAAM,UAAUA,sBAAqB;AAErC,MAAI,kBAAkB,WAAW;AAC/B,WAAO,KAAK,OAAQ,YAAY,WAAW,KAAK,KAAK,CAAC,IAAK,CAAC;AAAA,EAC9D;AACA,MAAI,kBAAkB,SAAS;AAC7B,WAAO,YAAY,UAAU;AAAA,EAC/B;AACA,MAAI,kBAAkB,WAAW;AAC/B,WAAO,KAAK,YAAY;AAAA,EAC1B;AACA,SAAO,YAAY;AACrB;AAEO,IAAM,uBAAuB,CAClC,WACA,qBACG;AACH,QAAM,EAAE,MAAM,IAAI;AAClB,MAAI,eAAe,SAAS,GAAG;AAC7B,UAAM,YACH,kBAAkB,YAAYC,sBAC/B;AACF,WAAO,KAAK,IAAI,6BAA6B,OAAO,QAAQ;AAAA,EAC9D;AACA,MAAI,UAAU,SAAS,WAAW;AAIhC,WAAO,KAAK,MAAO,QAAQ,IAAK,KAAK,KAAK,CAAC,CAAC,IAAID,sBAAqB;AAAA,EACvE;AACA,MAAI,UAAU,SAAS,WAAW;AAGhC,WAAO,KAAK,MAAM,QAAQ,CAAC,IAAIA,sBAAqB;AAAA,EACtD;AACA,SAAO,QAAQA,sBAAqB;AACtC;AAEO,IAAM,wBAAwB,CACnC,WACA,qBACG;AACH,QAAM,EAAE,OAAO,IAAI;AACnB,MAAI,eAAe,SAAS,GAAG;AAC7B,UAAM,kBAAkB,SAASA,sBAAqB,IAAI;AAC1D,QAAI,mBAAmB,GAAG;AACxB,aAAO,iBAAiB;AAAA,IAC1B;AACA,WAAO;AAAA,EACT;AACA,MAAI,UAAU,SAAS,WAAW;AAIhC,WAAO,KAAK,MAAO,SAAS,IAAK,KAAK,KAAK,CAAC,CAAC,IAAIA,sBAAqB;AAAA,EACxE;AACA,MAAI,UAAU,SAAS,WAAW;AAGhC,WAAO,KAAK,MAAM,SAAS,CAAC,IAAIA,sBAAqB;AAAA,EACvD;AACA,SAAO,SAASA,sBAAqB;AACvC;AAGO,IAAM,sBAAsB,CACjC,UACA,YAAY,WACT;AACH,QAAM,OAAO,SACV,OAAO,CAAC,KAAe,YAAY;AAClC,QAAI,cAAc,OAAO,GAAG;AAC1B,UAAI,KAAK,QAAQ,IAAI;AAAA,IACvB;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC,EACJ,KAAK,SAAS;AACjB,SAAO;AACT;;;AI7fA;AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA,mBAAAE;AAAA,OACK;AAEP,SAAS,WAAAC,UAAS,gCAAgC;AAsB3C,IAAM,oBAAoB,CAC/B,SACA,aACA,MACW;AACX,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO,8BAA8B,SAAS,aAAa,CAAC;AAAA,IAC9D,KAAK;AACH,aAAO,yBAAyB,SAAS,aAAa,CAAC;AAAA,IACzD,KAAK;AACH,aAAO,yBAAyB,SAAS,aAAa,CAAC;AAAA,IACzD,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO,iCAAiC,SAAS,CAAC;AAAA,EACtD;AACF;AAUA,IAAM,gCAAgC,CACpC,SACA,aACA,MACG;AACH,QAAM,SAAS,mBAAmB,SAAS,WAAW;AAGtD,QAAM,eAAeC,iBAAgB,GAAG,QAAQ,CAAC,QAAQ,KAAgB;AAGzE,QAAM,CAAC,OAAO,OAAO,IAAI,+BAA+B,OAAO;AAE/D,SAAO,KAAK;AAAA,IACV,GAAG,MAAM,IAAI,CAAC,MAAM,sBAAsB,cAAc,CAAC,CAAC;AAAA,IAC1D,GAAG,QACA,IAAI,CAACC,OAAM,mBAAmBA,IAAG,YAAY,CAAC,EAC9C,OAAO,CAAC,MAAmB,MAAM,IAAI;AAAA,EAC1C;AACF;AAUA,IAAM,2BAA2B,CAC/B,SACA,aACA,MACW;AACX,QAAM,SAAS,mBAAmB,SAAS,WAAW;AAItD,QAAM,eAAeD,iBAAgB,GAAG,QAAQ,CAAC,QAAQ,KAAgB;AAEzE,QAAM,CAAC,OAAO,MAAM,IAAI,0BAA0B,OAAO;AAEzD,SAAO,KAAK;AAAA,IACV,GAAG,MAAM,IAAI,CAAC,MAAM,sBAAsB,cAAc,CAAC,CAAC;AAAA,IAC1D,GAAG,OACA,IAAI,CAACC,OAAM,mBAAmBA,IAAG,YAAY,CAAC,EAC9C,OAAO,CAAC,MAAmB,MAAM,IAAI;AAAA,EAC1C;AACF;AAUA,IAAM,2BAA2B,CAC/B,SACA,aACA,MACW;AACX,QAAM,SAAS,mBAAmB,SAAS,WAAW;AACtD,SAAO;AAAA;AAAA,IAELD,iBAAgB,GAAG,QAAQ,CAAC,QAAQ,KAAgB;AAAA,IACpDE,SAAQ,QAAQ,QAAQ,QAAQ,GAAG,QAAQ,SAAS,CAAC;AAAA,EACvD;AACF;AAEA,IAAM,mCAAmC,CACvC,SACA,MACG;AACH,QAAM,CAAC,OAAO,MAAM,IAAI,mCAAmC,OAAO;AAClE,SAAO,KAAK;AAAA,IACV,GAAG,MAAM,IAAI,CAAC,MAAM,sBAAsB,GAAG,CAAC,CAAC;AAAA,IAC/C,GAAG,OAAO,IAAI,CAACD,OAAM,mBAAmBA,IAAG,CAAC,CAAC;AAAA,EAC/C;AACF;;;AP1EO,IAAM,mBAAmB,CAAC,YAA+B;AAC9D,MAAI,QAAQ,SAAS,SAAS;AAC5B,WAAO;AAAA,EACT;AAEA,QAAM,wBACJ,CAAC,cAAc,QAAQ,eAAe,KACtC,oBAAoB,OAAO,KAC3B,oBAAoB,OAAO,KAC3B,cAAc,OAAO;AAEvB,MAAI,QAAQ,SAAS,QAAQ;AAC3B,WAAO,yBAAyB,YAAY,QAAQ,MAAM;AAAA,EAC5D;AAEA,MAAI,QAAQ,SAAS,YAAY;AAC/B,WAAO,yBAAyB,YAAY,QAAQ,MAAM;AAAA,EAC5D;AAEA,SAAO,yBAAyB,eAAe,OAAO;AACxD;AAUO,IAAM,mBAAmB,CAAC;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,iBAAiB;AACnB,MAAmB;AAEjB,QAAM,eAAe,iBACjB;AAAA,IACEE,WAAU,eAAe,IAAI,WAAW,eAAe,IAAI,SAAS;AAAA,IACpE;AAAA,IACAA;AAAA,MACE,eAAe,IAAI,eAAe,QAAQ;AAAA,MAC1C,eAAe,IAAI,eAAe,SAAS;AAAA,IAC7C;AAAA,EACF,IACA;AAGJ,QAAM,SAAS,iBAAiB,SAAS,aAAa,IAAI;AAC1D,QAAM,YAAY;AAAA,IAChBA,WAAU,OAAO,CAAC,IAAI,WAAW,OAAO,CAAC,IAAI,SAAS;AAAA,IACtDC;AAAA,MACE;AAAA,MACA,mBAAmB,MAAM;AAAA,MACzB,CAAC,QAAQ;AAAA,IACX;AAAA,IACAD,WAAU,OAAO,CAAC,IAAI,WAAW,OAAO,CAAC,IAAI,SAAS;AAAA,EACxD;AAIA,MAAI,CAAC,aAAa,CAAC,cAAc;AAC/B,WAAO;AAAA,EACT;AAGA,QAAM,aAAa,iBAAiB,OAAO;AAAA;AAAA;AAAA,IAGvC,iBAAiB,OAAO,SAAS,WAAW,KAC5C,wBAAwB,OAAO,SAAS,aAAa,SAAS;AAAA,MAC9D,wBAAwB,OAAO,SAAS,aAAa,SAAS;AAElE,SAAO,cAAc;AACvB;AAEO,IAAM,wBAAwB,CACnC,OACA,SACA,aACA,YAAY,MACT;AACH,MAAI,CAAC,IAAI,IAAI,IAAI,EAAE,IAAI,iBAAiB,SAAS,WAAW;AAC5D,QAAM;AACN,QAAM;AACN,QAAM;AACN,QAAM;AACN,SAAO,oBAAoBA,WAAU,IAAI,EAAE,GAAG,OAAOA,WAAU,IAAI,EAAE,CAAC;AACxE;AAEO,IAAM,4BAA4B,CACvC,SACA,gBAEA,CAAC,iBAAiB,OAAO;AAEzB,CAAC,oBAAoB,QAAQ,OAAO,QAAQ,SAAS,WAAW,KAChE,sBAAsB,QAAQ,OAAO,QAAQ,SAAS,WAAW;AAE5D,IAAM,sBAAsB,CACjC,OACA,SACA,gBACY;AACZ,QAAM,4BAA4B,oBAAoB,SAAS,WAAW;AAE1E,MAAI,CAAC,2BAA2B;AAC9B,WAAO;AAAA,EACT;AACA,QAAM,mBAAmB,gBAAgB,OAAO,IAC5C;AAAA,IACE,GAAG;AAAA;AAAA;AAAA,IAGH,GAAG,oBAAoB;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,IACA;AAEJ,SAAO,iBAAiB,OAAO,kBAAkB,WAAW;AAC9D;AAUO,IAAM,kCAAkC,CAC7C,SACA,aACAE,OACA,SAAiB,GACjB,YAAY,UACM;AAGlB,QAAM,oBAAoB;AAAA,IACxB,KAAK,IAAIA,MAAK,CAAC,EAAE,CAAC,IAAI,QAAQA,MAAK,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,IACjD,KAAK,IAAIA,MAAK,CAAC,EAAE,CAAC,IAAI,QAAQA,MAAK,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,IACjD,KAAK,IAAIA,MAAK,CAAC,EAAE,CAAC,IAAI,QAAQA,MAAK,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,IACjD,KAAK,IAAIA,MAAK,CAAC,EAAE,CAAC,IAAI,QAAQA,MAAK,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,EACnD;AACA,QAAM,gBAAgB,iBAAiB,SAAS,WAAW;AAE3D,MAAI,CAAC,kBAAkB,mBAAmB,aAAa,GAAG;AACxD,WAAO,CAAC;AAAA,EACV;AAGA,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACAA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,KAAK;AACH,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACAA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,KAAK;AACH,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACAA;AAAA,QACA;AAAA,MACF;AAAA,IACF,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO,yCAAyC,SAASA,OAAM,SAAS;AAAA,EAC5E;AACF;AAEA,IAAM,qBAAqB,CACzB,QACA,SACA,eACA,QACA,OACA,YAAY,UACT;AACH,aAAW,KAAK,QAAQ;AAEtB,UAAM,KAAK,yBAAyB,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;AAC1D,UAAM,KAAK;AAAA,MACT,KAAK,IAAI,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,MACrC,KAAK,IAAI,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,MACrC,KAAK,IAAI,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,MACrC,KAAK,IAAI,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,IACvC;AAEA,QAAI,CAAC,kBAAkB,IAAI,EAAE,GAAG;AAC9B;AAAA,IACF;AAEA,UAAM,OAAO,0BAA0B,GAAG,OAAO;AAEjD,QAAI,KAAK,SAAS,GAAG;AACnB,iBAAW,KAAK,MAAM;AACpB,sBAAc,KAAKD,iBAAgB,GAAG,QAAQ,KAAK,CAAC;AAAA,MACtD;AAEA,UAAI,WAAW;AACb,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,oBAAoB,CACxB,OACA,SACA,eACA,QACA,OACA,YAAY,UACT;AACH,aAAWE,MAAK,OAAO;AACrB,UAAM,eAAe,8BAA8BA,IAAG,OAAO;AAC7D,QAAI,cAAc;AAChB,oBAAc,KAAKF,iBAAgB,cAAc,QAAQ,KAAK,CAAC;AAE/D,UAAI,WAAW;AACb,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,2CAA2C,CAC/C,SACA,SACA,YAAY,UACM;AAGlB,QAAM,CAAC,OAAO,MAAM,IAAI,mCAAmC,OAAO;AAClE,QAAM,gBAA+B,CAAC;AAEtC,aAAWE,MAAK,OAAO;AACrB,UAAM,eAAe,8BAA8BA,IAAG,OAAO;AAC7D,QAAI,cAAc;AAChB,oBAAc,KAAK,YAAY;AAE/B,UAAI,WAAW;AACb,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,aAAW,KAAK,QAAQ;AAEtB,UAAM,KAAK,yBAAyB,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;AAC1D,UAAM,KAAK;AAAA,MACT,KAAK,IAAI,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,MACrC,KAAK,IAAI,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,MACrC,KAAK,IAAI,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,MACrC,KAAK,IAAI,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,IACvC;AAEA,QAAI,CAAC,kBAAkB,IAAI,EAAE,GAAG;AAC9B;AAAA,IACF;AAEA,UAAM,OAAO,0BAA0B,GAAG,OAAO;AAEjD,QAAI,KAAK,SAAS,GAAG;AACnB,oBAAc,KAAK,GAAG,IAAI;AAE1B,UAAI,WAAW;AACb,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,uCAAuC,CAC3C,SACA,aACA,SACA,SAAiB,GACjB,YAAY,UACM;AAClB,QAAM,SAAS,mBAAmB,SAAS,WAAW;AAGtD,QAAM,WAAWF;AAAA,IACf,QAAQ,CAAC;AAAA,IACT;AAAA,IACA,CAAC,QAAQ;AAAA,EACX;AACA,QAAM,WAAWA;AAAA,IACf,QAAQ,CAAC;AAAA,IACT;AAAA,IACA,CAAC,QAAQ;AAAA,EACX;AACA,QAAM,qBAAqBG,aAAY,UAAU,QAAQ;AAGzD,QAAM,CAAC,OAAO,OAAO,IAAI,+BAA+B,SAAS,MAAM;AAEvE,QAAM,gBAA+B,CAAC;AAEtC;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,EACF;AAEA,MAAI,aAAa,cAAc,SAAS,GAAG;AACzC,WAAO;AAAA,EACT;AAEA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AACT;AASA,IAAM,kCAAkC,CACtC,SACA,aACAD,IACA,SAAiB,GACjB,YAAY,UACM;AAClB,QAAM,SAAS,mBAAmB,SAAS,WAAW;AAItD,QAAM,WAAWF,iBAAgBE,GAAE,CAAC,GAAG,QAAQ,CAAC,QAAQ,KAAgB;AACxE,QAAM,WAAWF,iBAAgBE,GAAE,CAAC,GAAG,QAAQ,CAAC,QAAQ,KAAgB;AACxE,QAAM,qBAAqBC,aAAY,UAAU,QAAQ;AAEzD,QAAM,CAAC,OAAO,OAAO,IAAI,0BAA0B,SAAS,MAAM;AAClE,QAAM,gBAA+B,CAAC;AAEtC;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,EACF;AAEA,MAAI,aAAa,cAAc,SAAS,GAAG;AACzC,WAAO;AAAA,EACT;AAEA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AACT;AASA,IAAM,kCAAkC,CACtC,SACA,aACAD,IACA,SAAiB,MACC;AAClB,QAAM,SAAS,mBAAmB,SAAS,WAAW;AAEtD,QAAM,WAAWF,iBAAgBE,GAAE,CAAC,GAAG,QAAQ,CAAC,QAAQ,KAAgB;AACxE,QAAM,WAAWF,iBAAgBE,GAAE,CAAC,GAAG,QAAQ,CAAC,QAAQ,KAAgB;AAExE,SAAO;AAAA,IACLE,SAAQ,QAAQ,QAAQ,QAAQ,IAAI,QAAQ,QAAQ,SAAS,IAAI,MAAM;AAAA,IACvED,aAAY,UAAU,QAAQ;AAAA,EAChC,EAAE,IAAI,CAAC,MAAMH,iBAAgB,GAAG,QAAQ,QAAQ,KAAK,CAAC;AACxD;AAUA,IAAM,0BAA0B,CAC9B,OACA,SACA,aACA,YAAY,MACT,kBAAkB,SAAS,aAAa,KAAK,KAAK;AAShD,IAAM,mBAAmB,CAC9B,OACA,SACA,gBACG;AACH,OACG,gBAAgB,OAAO,KAAK,kBAAkB,OAAO,MACtD,CAAC,YAAY,QAAQ,MAAM,GAC3B;AAEA,WAAO;AAAA,EACT;AAEA,QAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAI,iBAAiB,SAAS,WAAW;AAE9D,MAAI,CAAC,oBAAoBD,WAAU,IAAI,EAAE,GAAG,OAAOA,WAAU,IAAI,EAAE,CAAC,GAAG;AACrE,WAAO;AAAA,EACT;AAEA,QAAM,SAASA,YAAwB,KAAK,MAAM,IAAI,KAAK,MAAM,CAAC;AAClE,QAAM,aAAaM;AAAA,IACjBC;AAAA,MACEC,iBAAgBC,iBAAgB,OAAO,QAAQ,GAAG,CAAC;AAAA,MACnD,KAAK,IAAI,QAAQ,OAAO,QAAQ,MAAM,IAAI;AAAA,IAC5C;AAAA,IACA;AAAA,EACF;AACA,QAAM,cAAcL,aAAY,OAAO,UAAU;AACjD,QAAM,gBAAgB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,EACF,EAAE,OAAO,CAAC,GAAG,KAAK,QAAQ,IAAI,UAAU,CAAC,MAAMM,aAAY,GAAG,CAAC,CAAC,MAAM,GAAG;AAEzE,SAAO,cAAc,SAAS,MAAM;AACtC;;;AQ3iBA;AAAA,SAAS,aAAAC,YAAW,YAAAC,WAAU,aAAAC,kBAAiB;AAE/C;AAAA,EACE,aAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,mBAAAC;AAAA,EACA;AAAA,EACA,eAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA,mBAAAC;AAAA,EACA,eAAAC;AAAA,OACK;AAaA,IAAM,gBAAgB,CAAC,GAAG,CAAC;AAC3B,IAAM,eAAe,CAAC,GAAG,CAAC;AAC1B,IAAM,eAAe,CAAC,IAAI,CAAC;AAC3B,IAAM,aAAa,CAAC,GAAG,EAAE;AAGzB,IAAM,kBAAkB,CAAC,QAAyB;AACvD,QAAM,CAAC,GAAG,CAAC,IAAI;AACf,QAAM,OAAO,KAAK,IAAI,CAAC;AACvB,QAAM,OAAO,KAAK,IAAI,CAAC;AACvB,MAAI,IAAI,MAAM;AACZ,WAAO;AAAA,EACT,WAAW,KAAK,CAAC,MAAM;AACrB,WAAO;AAAA,EACT,WAAW,IAAI,MAAM;AACnB,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,IAAM,kBAAkB,CAC7B,GACA,MACG,gBAAgBC,iBAAmB,GAAG,CAAC,CAAC;AAEtC,IAAM,8BAA8B,CACzC,GACA,MACG,oBAAoB,gBAAmB,GAAG,CAAC,CAAC;AAE1C,IAAM,iBAAiB,CAACC,IAAYC,OACzCD,GAAE,CAAC,MAAMC,GAAE,CAAC,KAAKD,GAAE,CAAC,MAAMC,GAAE,CAAC;AAExB,IAAM,sBAAsB,CAACD,OAClC,eAAeA,IAAG,aAAa,KAAK,eAAeA,IAAG,YAAY;AAE7D,IAAM,oBAAoB,CAACA,OAAe,CAAC,oBAAoBA,EAAC;AAEvE,IAAM,oCAAoC,CACxC,SACA,MACA,UACY;AACZ,QAAM,WAAW,mBAAmB,IAAI;AAExC,MAAIE,UAAS,KAAKC,WAAU,GAAG;AAC7B,IAAAC;AAAA,MACE,QAAQ,QAAQ,KAAK,QAAQ,SAAS;AAAA,MACtC;AAAA,IACF;AACA,IAAAA;AAAA,MACE,CAACC,aAAY,UAAU,KAAK;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS;AACf,QAAM,MAAMC;AAAA,IACVC;AAAA,MACER;AAAA,QACES;AAAA,UACEC,WAAuB,QAAQ,IAAI,QAAQ,QAAQ,GAAG,QAAQ,CAAC;AAAA,UAC/D;AAAA,UACA,QAAQ;AAAA,QACV;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACA,QAAM,QAAQH;AAAA,IACZC;AAAA,MACER;AAAA,QACES;AAAA,UACEC;AAAA,YACE,QAAQ,IAAI,QAAQ;AAAA,YACpB,QAAQ,IAAI,QAAQ,SAAS;AAAA,UAC/B;AAAA,UACA;AAAA,UACA,QAAQ;AAAA,QACV;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACA,QAAM,SAASH;AAAA,IACbC;AAAA,MACER;AAAA,QACES;AAAA,UACEC;AAAA,YACE,QAAQ,IAAI,QAAQ,QAAQ;AAAA,YAC5B,QAAQ,IAAI,QAAQ;AAAA,UACtB;AAAA,UACA;AAAA,UACA,QAAQ;AAAA,QACV;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACA,QAAM,OAAOH;AAAA,IACXC;AAAA,MACER;AAAA,QACES;AAAA,UACEC,WAAuB,QAAQ,GAAG,QAAQ,IAAI,QAAQ,SAAS,CAAC;AAAA,UAChE;AAAA,UACA,QAAQ;AAAA,QACV;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,IACF;AAAA,IACA;AAAA,EACF;AAGA,MACE,YAAYV,iBAAgB,OAAO,GAAG,GAAGA,iBAAgB,KAAK,KAAK,CAAC,KAClE,KACF,YAAYA,iBAAgB,OAAO,GAAG,GAAGA,iBAAgB,KAAK,IAAI,CAAC,IAAI,GACvE;AACA,WAAO,gBAAgB,KAAK,QAAQ;AAAA,EACtC,WACE;AAAA,IACEA,iBAAgB,OAAO,KAAK;AAAA,IAC5BA,iBAAgB,OAAO,MAAM;AAAA,EAC/B,KAAK,KACL,YAAYA,iBAAgB,OAAO,KAAK,GAAGA,iBAAgB,OAAO,GAAG,CAAC,IAAI,GAC1E;AACA,WAAO,gBAAgB,OAAO,QAAQ;AAAA,EACxC,WACE;AAAA,IACEA,iBAAgB,OAAO,MAAM;AAAA,IAC7BA,iBAAgB,QAAQ,IAAI;AAAA,EAC9B,KAAK,KACL;AAAA,IACEA,iBAAgB,OAAO,MAAM;AAAA,IAC7BA,iBAAgB,QAAQ,KAAK;AAAA,EAC/B,IAAI,GACJ;AACA,WAAO,gBAAgB,QAAQ,QAAQ;AAAA,EACzC,WACE,YAAYA,iBAAgB,OAAO,IAAI,GAAGA,iBAAgB,MAAM,GAAG,CAAC,KAClE,KACF,YAAYA,iBAAgB,OAAO,IAAI,GAAGA,iBAAgB,MAAM,MAAM,CAAC,IAAI,GAC3E;AACA,WAAO,gBAAgB,MAAM,QAAQ;AAAA,EACvC;AAGA,MACE;AAAA,IACEA,iBAAgB,OAAO,QAAQ;AAAA,IAC/BA,iBAAgB,KAAK,QAAQ;AAAA,EAC/B,KAAK,KACL;AAAA,IACEA,iBAAgB,OAAO,QAAQ;AAAA,IAC/BA,iBAAgB,OAAO,QAAQ;AAAA,EACjC,IAAI,GACJ;AACA,UAAMW,KAAI,QAAQ,QAAQ,QAAQ,SAAS,MAAM;AACjD,WAAO,gBAAgBA,IAAG,QAAQ;AAAA,EACpC,WACE;AAAA,IACEX,iBAAgB,OAAO,QAAQ;AAAA,IAC/BA,iBAAgB,OAAO,QAAQ;AAAA,EACjC,KAAK,KACL;AAAA,IACEA,iBAAgB,OAAO,QAAQ;AAAA,IAC/BA,iBAAgB,QAAQ,QAAQ;AAAA,EAClC,IAAI,GACJ;AACA,UAAMW,KAAI,QAAQ,QAAQ,QAAQ,SAAS,SAAS;AACpD,WAAO,gBAAgBA,IAAG,QAAQ;AAAA,EACpC,WACE;AAAA,IACEX,iBAAgB,OAAO,QAAQ;AAAA,IAC/BA,iBAAgB,QAAQ,QAAQ;AAAA,EAClC,KAAK,KACL;AAAA,IACEA,iBAAgB,OAAO,QAAQ;AAAA,IAC/BA,iBAAgB,MAAM,QAAQ;AAAA,EAChC,IAAI,GACJ;AACA,UAAMW,KAAI,QAAQ,QAAQ,QAAQ,SAAS,SAAS;AACpD,WAAO,gBAAgBA,IAAG,QAAQ;AAAA,EACpC;AAEA,QAAM,IAAI,QAAQ,QAAQ,QAAQ,SAAS,MAAM;AACjD,SAAO,gBAAgB,GAAG,QAAQ;AACpC;AAKO,IAAM,6BAA6B,CACxC,SACA,MACA,MACY;AACZ,QAAM,yBAAyB;AAE/B,QAAM,WAAW,mBAAmB,IAAI;AAExC,MAAI,QAAQ,SAAS,WAAW;AAC9B,WAAO,kCAAkC,SAAS,MAAM,CAAC;AAAA,EAC3D;AAEA,QAAM,UAAU;AAAA,IACdD,WAAU,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAAA,IAC1B;AAAA,IACA;AAAA,EACF;AACA,QAAM,WAAW;AAAA,IACfA,WAAU,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAAA,IAC1B;AAAA,IACA;AAAA,EACF;AACA,QAAM,aAAa;AAAA,IACjBA,WAAU,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAAA,IAC1B;AAAA,IACA;AAAA,EACF;AACA,QAAM,cAAc;AAAA,IAClBA,WAAU,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAAA,IAC1B;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AAAA,IACL,CAAC,SAAS,UAAU,QAAQ;AAAA,IAC5B;AAAA,EACF,IACI,aACA;AAAA,IACE,CAAC,UAAU,aAAa,QAAQ;AAAA,IAChC;AAAA,EACF,IACA,gBACA;AAAA,IACE,CAAC,aAAa,YAAY,QAAQ;AAAA,IAClC;AAAA,EACF,IACA,eACA;AACN;AAEO,IAAM,cAAc,CAAC,MAC1B;AAAA,EACE,EAAE,CAAC,MAAM,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,KAAK;AAAA,EACjC,EAAE,CAAC,MAAM,IAAI,IAAI,EAAE,CAAC,IAAI,IAAI,KAAK;AACnC;;;ACzRF;AAAA;AAAA,EACE,qBAAAE;AAAA,EACA;AAAA,EACA;AAAA,OACK;;;ACJP;AAAA;AAAA,EACE,SAAAC;AAAA,EACA,iBAAAC;AAAA,EACA,aAAAC;AAAA,EACA,wBAAAC;AAAA,EACA,eAAAC;AAAA,EACA;AAAA,EACA,UAAAC;AAAA,EACA,eAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,eAAAC;AAAA,OAGK;AAEP;AAAA,EACE;AAAA,EACA,aAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAAC;AAAA,EACA;AAAA,OACK;AAqFP,IAAM,iBAAiB;AAChB,IAAM,eAAe;AAE5B,IAAM,+BAA+B,CACnC,OACA,gBACG;AACH,QAAM,oBAA2C,MAAM,gBACnD,MAAM,cAAc,MAAM,IAC1B;AAEJ,MAAI,mBAAmB;AACrB,UAAM,cAA6B,CAAC;AAEpC,UAAM,OACH,IAAI,CAAC,MAAMC,WAAuB,MAAM,IAAI,EAAE,CAAC,GAAG,MAAM,IAAI,EAAE,CAAC,CAAC,CAAC,EACjE,QAAQ,CAAC,GAAG,GAAG,WAAW;AACzB,UAAI,IAAI,GAAG;AACT,eAAO,YAAY,KAAK,CAAC;AAAA,MAC3B;AAEA,YAAM,6BAA6B,gBAAgB,GAAG,OAAO,IAAI,CAAC,CAAC;AACnE,YAAM,0BAA0B;AAAA,QAC9B,OAAO,IAAI,CAAC;AAAA,QACZ,OAAO,IAAI,CAAC;AAAA,MACd;AAEA;AAAA;AAAA,QAEE,eAAe,4BAA4B,uBAAuB;AAAA,QAClE;AACA,cAAM,iBACJ,mBAAmB;AAAA,UACjB,CAAC,YAAY,QAAQ,UAAU,IAAI;AAAA,QACrC,KAAK;AACP,cAAM,aACJ,mBAAmB,UAAU,CAAC,YAAY,QAAQ,UAAU,CAAC,KAC7D;AAGF,YAAI,eAAe,IAAI;AACrB,4BAAkB,UAAU,EAAE,QAAQA;AAAA,YACpC,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,YACzB,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,MAAM;AAAA,UAC3B;AAAA,QACF;AAKA,YAAI,mBAAmB,IAAI;AACzB,4BAAkB,OAAO,gBAAgB,CAAC;AAAA,QAC5C;AAGA,oBAAY,OAAO,IAAI,CAAC;AAGxB,0BAAkB,QAAQ,CAAC,YAAY;AACrC,cAAI,QAAQ,QAAQ,IAAI,GAAG;AACzB,oBAAQ,SAAS;AAAA,UACnB;AAAA,QACF,CAAC;AAAA,MACH;AAEA,aAAO,YAAY,KAAK,CAAC;AAAA,IAC3B,CAAC;AAEH,UAAM,aAA4B,CAAC;AAEnC,gBAAY,QAAQ,CAAC,GAAG,GAAG,WAAW;AACpC,UAAI,IAAI,GAAG;AACT,eAAO,WAAW,KAAK,CAAC;AAAA,MAC1B;AAEA;AAAA;AAAA,QAEEC,eAAc,OAAO,IAAI,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC,IAAI;AAAA,QAC9C;AACA,cAAM,qBACJ,mBAAmB,UAAU,CAAC,YAAY,QAAQ,UAAU,IAAI,CAAC,KACjE;AACF,cAAM,iBACJ,mBAAmB,UAAU,CAAC,YAAY,QAAQ,UAAU,IAAI,CAAC,KACjE;AAIF,YAAI,mBAAmB,IAAI;AACzB,4BAAkB,OAAO,gBAAgB,CAAC;AAAA,QAC5C;AAKA,YAAI,uBAAuB,IAAI;AAC7B,4BAAkB,OAAO,oBAAoB,CAAC;AAAA,QAChD;AAEA,mBAAW,OAAO,IAAI,CAAC;AAGvB,0BAAkB,QAAQ,CAAC,YAAY;AACrC,cAAI,QAAQ,QAAQ,IAAI,GAAG;AACzB,oBAAQ,SAAS;AAAA,UACnB;AAAA,QACF,CAAC;AAGD,cAAM,eAAe,4BAA4B,GAAG,OAAO,IAAI,CAAC,CAAC;AAEjE,eAAO,WAAW;AAAA,UAChBD;AAAA,YACE,CAAC,eAAe,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;AAAA,YACtC,eAAe,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC;AAAA,UACvC;AAAA,QACF;AAAA,MACF;AAEA,iBAAW,KAAK,CAAC;AAAA,IACnB,CAAC;AAED,UAAM,4BAA4B,kBAAkB;AAAA,MAClD,CAAC,YACC,QAAQ,UAAU,KAAK,QAAQ,UAAU,WAAW,SAAS;AAAA,IACjE;AACA,QAAI,0BAA0B,WAAW,GAAG;AAC1C,aAAO;AAAA,QACL;AAAA,UACE;AAAA,YACE;AAAA,cACE;AAAA,cACA;AAAA,gBACE;AAAA,gBACA;AAAA,gBACA,WAAW;AAAA,kBAAI,CAAC,MACdA,WAAsB,EAAE,CAAC,IAAI,MAAM,GAAG,EAAE,CAAC,IAAI,MAAM,CAAC;AAAA,gBACtD;AAAA,cACF;AAAA,YACF,KAAK,CAAC;AAAA,UACR;AAAA,QACF;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,IAAAE,UAAS,KACPC;AAAA,MACE,oBAAoB,UAAU;AAAA,MAC9B;AAAA,IACF;AAEF,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,MAAM;AAAA,MACN,MAAM;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AAAA,IACL,GAAG,MAAM;AAAA,IACT,GAAG,MAAM;AAAA,IACT,QAAQ,MAAM;AAAA,IACd,eAAe,MAAM;AAAA,IACrB,gBAAgB,MAAM;AAAA,IACtB,cAAc,MAAM;AAAA,EACtB;AACF;AAEA,IAAM,uBAAuB,CAC3B,OACA,eACA,gBACG;AACH,QAAM,yBAAyB,cAAc,IAAI,CAAC,YAAY,QAAQ,KAAK;AAC3E,QAAM,yBACJ,MAAM,eAAe,IAAI,CAAC,YAAY,QAAQ,KAAK,KAAK,CAAC;AAC3D,QAAM,oBAAoB,uBAAuB;AAAA,IAC/C,CAAC,QAAQ,CAAC,uBAAuB,SAAS,GAAG;AAAA,EAC/C;AAEA,MAAI,sBAAsB,MAAM,CAAC,MAAM,gBAAgB,iBAAiB,GAAG;AACzE,WAAO;AAAA,MACL,QAAQ,MAAM;AAAA,IAChB;AAAA,EACF;AAEA,QAAM,aAAa,MAAM,cAAc,iBAAiB,EAAE;AAG1D,QAAM,cAAc,MAAM,cAAc,oBAAoB,CAAC;AAC7D,QAAM,cAAc,MAAM,cAAc,oBAAoB,CAAC;AAG7D,QAAM,IAAI,MAAM,KAAK,cAAc,YAAY,IAAI,CAAC,IAAI;AACxD,QAAM,IAAI,MAAM,KAAK,cAAc,YAAY,IAAI,CAAC,IAAI;AACxD,QAAM,eAAe,cAAc,OAAO,MAAM;AAChD,QAAM,aAAa,cAAc,OAAO,MAAM;AAC9C,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG;AAAA,EACL,IAAI;AAAA,IACF;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,gBAAgB;AAAA,MAChB,cAAc;AAAA,MACd,QAAQ,MAAM;AAAA,IAChB;AAAA,IACA;AAAA,IACA;AAAA,MACEH,WAAsB,GAAG,CAAC;AAAA,MAC1BA;AAAA,QACE,MAAM,KACH,aAAa,MAAM,CAAC,KAAK,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,EAAE,CAAC,KACjE;AAAA,QACF,MAAM,KACH,aAAa,MAAM,CAAC,KAAK,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,EAAE,CAAC,KACjE;AAAA,MACJ;AAAA,IACF;AAAA,IACA,EAAE,YAAY,MAAM;AAAA,EACtB;AAEA,QAAM,EAAE,QAAQ,eAAe,IAAI;AAAA,IACjC;AAAA,MACE;AAAA,QACE,gBAAgB,OAAO;AAAA,UACrB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,GAAG;AAAA,QACL,CAAC,KAAK,CAAC;AAAA,MACT;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,aAA4B,CAAC;AAGnC,MAAI,aAAa;AACf,aAAS,IAAI,GAAG,IAAI,YAAY,OAAO,KAAK;AAC1C,iBAAW;AAAA,QACTA;AAAA,UACE,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,UAC3B,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,iBAAe,QAAQ,CAAC,MAAM;AAC5B,eAAW;AAAA,MACTA;AAAA,QACE,MAAM,KAAK,cAAc,YAAY,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC;AAAA,QACtD,MAAM,KAAK,cAAc,YAAY,IAAI,CAAC,IAAI,KAAK,EAAE,CAAC;AAAA,MACxD;AAAA,IACF;AAAA,EACF,CAAC;AAGD,MAAI,aAAa;AACf,aAAS,IAAI,YAAY,OAAO,IAAI,MAAM,OAAO,QAAQ,KAAK;AAC5D,iBAAW;AAAA,QACTA;AAAA,UACE,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,UAC3B,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,QAAM,4BACH,aAAa,SAAS,MAAM,OAAO,WAAW,aAAa,SAAS,KAAK;AAE5E,QAAM,oBAAoB,cAAc,IAAI,CAAC,YAAY;AACvD,QAAI,QAAQ,QAAQ,YAAY;AAC9B,aAAO;AAAA,QACL,GAAG;AAAA,QACH,OACE,QAAQ,QACR,4BACC,eAAe,SAAS;AAAA,MAC7B;AAAA,IACF;AAEA,WAAO;AAAA,EACT,CAAC;AAED,QAAM,mBAAmB,WAAW,QAAQ,CAAC,GAAG,MAAM;AACpD,UAAM,OAAO,WAAW,IAAI,CAAC;AAC7B,UAAM,OAAO,WAAW,IAAI,CAAC;AAE7B,QAAI,QAAQ,MAAM;AAChB,YAAM,cAAc,gBAAgB,GAAG,IAAI;AAC3C,YAAM,cAAc,gBAAgB,MAAM,CAAC;AAE3C,UAAI,eAAe,aAAa,WAAW,GAAG;AAE5C,0BAAkB,QAAQ,CAAC,YAAY;AACrC,cAAI,QAAQ,QAAQ,GAAG;AACrB,oBAAQ,SAAS;AAAA,UACnB;AAAA,QACF,CAAC;AAED,eAAO,CAAC;AAAA,MACV,WAAW,eAAe,aAAa,YAAY,WAAW,CAAC,GAAG;AAEhE,0BAAkB,QAAQ,CAAC,YAAY;AACrC,cAAI,QAAQ,QAAQ,GAAG;AACrB,oBAAQ,SAAS;AAAA,UACnB;AAAA,QACF,CAAC;AAED,eAAO,CAAC,GAAG,CAAC;AAAA,MACd;AAAA,IACF;AAEA,WAAO,CAAC,CAAC;AAAA,EACX,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAKA,IAAM,oBAAoB,CACxB,OACA,eACA,cACA,YACA,qBACA,sBAC+C;AAC/C,QAAM,6BAA6B,cAChC,IAAI,CAAC,SAAS,MAAM;AACnB,QACE,MAAM,iBAAiB,QACvB,MAAM,cAAc,CAAC,MAAM,UAC3B,MAAM,cAAc,CAAC,EAAE,UAAU,QAAQ,OACzC;AACA,aAAO;AAAA,IACT;AAEA,YAAQ,QAAQ,MAAM,CAAC,MAAM,MAAM,cAAe,CAAC,EAAE,MAAM,CAAC,KAC1D,QAAQ,IAAI,CAAC,MAAM,MAAM,cAAe,CAAC,EAAE,IAAI,CAAC,QAC/C,QAAQ,MAAM,CAAC,MAAM,MAAM,cAAe,CAAC,EAAE,MAAM,CAAC,KACnD,QAAQ,IAAI,CAAC,MAAM,MAAM,cAAe,CAAC,EAAE,IAAI,CAAC,KAChD,IACA;AAAA,EACN,CAAC,EACA,OAAO,CAAC,QAAQ,QAAQ,IAAI,EAC5B,MAAM;AAET,MAAI,8BAA8B,MAAM;AACtC,WAAO,EAAE,QAAQ,MAAM,OAAO;AAAA,EAChC;AAEA,QAAM,kBACJ,MAAM,eAAe,UAAU,CAAC,YAAY,QAAQ,UAAU,CAAC,KAAK;AACtE,QAAM,iBACJ,MAAM,eAAe;AAAA,IACnB,CAAC,YAAY,QAAQ,UAAU,MAAM,OAAO,SAAS;AAAA,EACvD,KAAK;AAGP,QAAM,gBAAgBC;AAAA,IACpB,cAAc,0BAA0B,EAAE;AAAA,IAC1C,cAAc,0BAA0B,EAAE;AAAA,EAC5C;AACA,QAAM,oBAAoB,gBAAgB,eAAe;AACzD,MACE,oBAAoB,MACpB,cAAc,0BAA0B,EAAE,UAAU,KACpD,qBACA;AACA,UAAM,oBAAoB,oBAAoB,YAAY;AAC1D,UAAM,kBAAkB,oBACpB,eAAe,cAAc,aAAa,IAC1C,eAAe,cAAc,YAAY;AAC7C,UAAM,UAAU,kBACZ,oBACE,gBAAgB,IAChB,eACF,oBACA,CAAC,gBAAgB,IACjB,CAAC;AACL,kBAAc,0BAA0B,EAAE,QAAQD;AAAA,MAChD,cAAc,0BAA0B,EAAE,MAAM,CAAC,KAC9C,oBAAoB,UAAU;AAAA,MACjC,cAAc,0BAA0B,EAAE,MAAM,CAAC,KAC9C,CAAC,oBAAoB,UAAU;AAAA,IACpC;AAAA,EACF;AAGA,MACE,mBAAmB,MACnB,cAAc,0BAA0B,EAAE,UACxC,MAAM,OAAO,SAAS,KACxB,mBACA;AACA,UAAM,kBAAkB,oBAAoB,UAAU;AACtD,UAAM,gBAAgB,kBAClB,eAAe,YAAY,aAAa,IACxC,eAAe,YAAY,YAAY;AAC3C,UAAM,UAAU,gBACZ,oBACE,gBAAgB,IAChB,eACF,oBACA,CAAC,gBAAgB,IACjB,CAAC;AACL,kBAAc,0BAA0B,EAAE,MAAMA;AAAA,MAC9C,cAAc,0BAA0B,EAAE,IAAI,CAAC,KAC5C,kBAAkB,UAAU;AAAA,MAC/B,cAAc,0BAA0B,EAAE,IAAI,CAAC,KAC5C,CAAC,kBAAkB,UAAU;AAAA,IAClC;AAAA,EACF;AAGA,QAAM,oBAAoB,cAAc,IAAI,CAAC,aAAa;AAAA,IACxD,GAAG;AAAA,IACH,OAAOA;AAAA,MACL,MAAM,IAAI,QAAQ,MAAM,CAAC;AAAA,MACzB,MAAM,IAAI,QAAQ,MAAM,CAAC;AAAA,IAC3B;AAAA,IACA,KAAKA;AAAA,MACH,MAAM,IAAI,QAAQ,IAAI,CAAC;AAAA,MACvB,MAAM,IAAI,QAAQ,IAAI,CAAC;AAAA,IACzB;AAAA,EACF,EAAE;AAGF,QAAM,YAA2B,MAAM,OAAO;AAAA,IAAI,CAAC,GAAG,MACpDA,WAAuB,MAAM,IAAI,EAAE,CAAC,GAAG,MAAM,IAAI,EAAE,CAAC,CAAC;AAAA,EACvD;AAEA,QAAM,WAAW,kBAAkB,0BAA0B,EAAE,QAAQ;AACvE,QAAM,SAAS,kBAAkB,0BAA0B,EAAE;AAC7D,QAAM,QAAQ,kBAAkB,0BAA0B,EAAE;AAC5D,QAAM,MAAM,kBAAkB,0BAA0B,EAAE;AAC1D,QAAM,0BACJ,UAAU,WAAW,CAAC,KACtB,CAACI,aAAY,UAAU,QAAQ,GAAG,UAAU,WAAW,CAAC,CAAC,IACrD;AAAA,IACE,UAAU,WAAW,CAAC;AAAA,IACtB,UAAU,QAAQ;AAAA,EACpB,IACA;AACN,QAAM,0BACJ,UAAU,SAAS,CAAC,KACpB,CAACA,aAAY,UAAU,MAAM,GAAG,UAAU,SAAS,CAAC,CAAC,IACjD,4BAA4B,UAAU,SAAS,CAAC,GAAG,UAAU,MAAM,CAAC,IACpE;AAGN,MAAI,4BAA4B,QAAW;AACzC,UAAM,MAAM,0BAA0B,IAAI;AAC1C,cAAU,WAAW,CAAC,EAAE,GAAG,IAAI,MAAM,GAAG;AAAA,EAC1C;AACA,YAAU,QAAQ,IAAI;AACtB,YAAU,MAAM,IAAI;AACpB,MAAI,4BAA4B,QAAW;AACzC,UAAM,MAAM,0BAA0B,IAAI;AAC1C,cAAU,SAAS,CAAC,EAAE,GAAG,IAAI,IAAI,GAAG;AAAA,EACtC;AAGA,QAAM,iBAAiB,kBAAkB;AAAA,IACvC,CAAC,YAAY,QAAQ,UAAU;AAAA,EACjC;AACA,MAAI,mBAAmB,IAAI;AAEzB,UAAM,MAAM;AAAA,MACV,kBAAkB,cAAc,EAAE;AAAA,MAClC,kBAAkB,cAAc,EAAE;AAAA,IACpC,IACI,IACA;AACJ,sBAAkB,cAAc,EAAE,MAAM,GAAG,IAAI,MAAM,GAAG;AACxD,sBAAkB,cAAc,EAAE,MAAM;AAAA,EAC1C;AAEA,QAAM,iBAAiB,kBAAkB;AAAA,IACvC,CAAC,YAAY,QAAQ,UAAU,SAAS;AAAA,EAC1C;AACA,MAAI,mBAAmB,IAAI;AAEzB,UAAM,MAAM;AAAA,MACV,kBAAkB,cAAc,EAAE;AAAA,MAClC,kBAAkB,cAAc,EAAE;AAAA,IACpC,IACI,IACA;AACJ,sBAAkB,cAAc,EAAE,IAAI,GAAG,IAAI,IAAI,GAAG;AACpD,sBAAkB,cAAc,EAAE,QAAQ;AAAA,EAC5C;AAGA,MAAI,oBAAoB,MAAM,aAAa,GAAG;AAC5C,UAAM,oBAAoB,sBACtB,oBAAoB,YAAY,IAChC,4BAA4B,UAAU,CAAC,GAAG,UAAU,CAAC,CAAC;AAC1D,cAAU;AAAA,MACRJ;AAAA,QACE,oBAAoB,MAAM,CAAC,IAAI,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,QAC1D,CAAC,oBAAoB,MAAM,CAAC,IAAI,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,MAC7D;AAAA,IACF;AAEA,QAAI,qBAAqB;AACvB,gBAAU;AAAA,QACRA;AAAA,UACE,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,UAC3B,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAEA,eAAW,WAAW,mBAAmB;AACvC,cAAQ,SAAS,sBAAsB,IAAI;AAAA,IAC7C;AAAA,EACF;AAGA,MAAI,mBAAmB,MAAM,WAAW,MAAM,OAAO,SAAS,GAAG;AAC/D,UAAM,kBAAkB,oBAAoB,UAAU;AACtD,cAAU;AAAA,MACRA;AAAA,QACE,kBACI,IAAI,CAAC,IACL,MAAM,IAAI,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,EAAE,CAAC;AAAA,QACrD,CAAC,kBACG,IAAI,CAAC,IACL,MAAM,IAAI,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,EAAE,CAAC;AAAA,MACvD;AAAA,IACF;AACA,QAAI,mBAAmB;AACrB,gBAAU;AAAA,QACRA;AAAA,UACE,MAAM,IAAI,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,EAAE,CAAC;AAAA,UACjD,MAAM,IAAI,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,EAAE,CAAC;AAAA,QACnD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA,kBAAkB,IAAI,CAAC,aAAa;AAAA,MAClC,GAAG;AAAA,MACH,OAAOA;AAAA,QACL,QAAQ,MAAM,CAAC,IAAI,MAAM;AAAA,QACzB,QAAQ,MAAM,CAAC,IAAI,MAAM;AAAA,MAC3B;AAAA,MACA,KAAKA;AAAA,QACH,QAAQ,IAAI,CAAC,IAAI,MAAM;AAAA,QACvB,QAAQ,IAAI,CAAC,IAAI,MAAM;AAAA,MACzB;AAAA,IACF,EAAE;AAAA,IACF;AAAA;AAAA,IACA;AAAA;AAAA,EACF;AACF;AAEA,IAAM,qBAAqB,CACzB,OACA,eACA,eACA,cACA,YACA,kBACA,gBACA,qBACA,sBACG;AACH,MAAI,iBAAiB,MAAM,kBAAkB;AAC7C,MAAI,eAAe,MAAM,gBAAgB;AACzC,QAAM,sBAAsB,cAAc;AAAA,IAAI,CAAC,GAAG,MAChD,MAAM,IACFA,WAAuB,MAAM,IAAI,EAAE,CAAC,GAAG,MAAM,IAAI,EAAE,CAAC,CAAC,IACrD,MAAM,cAAc,SAAS,IAC7BA,WAAuB,MAAM,IAAI,EAAE,CAAC,GAAG,MAAM,IAAI,EAAE,CAAC,CAAC,IACrDA;AAAA,MACE,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,MAC3B,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,IAC7B;AAAA,EACN;AACA,QAAM,oBAAoB,cAAc,IAAI,CAAC,aAAa;AAAA,IACxD,GAAG;AAAA,IACH,OAAOA;AAAA,MACL,MAAM,KAAK,QAAQ,MAAM,CAAC,IAAI,cAAc,CAAC,EAAE,CAAC;AAAA,MAChD,MAAM,KAAK,QAAQ,MAAM,CAAC,IAAI,cAAc,CAAC,EAAE,CAAC;AAAA,IAClD;AAAA,IACA,KAAKA;AAAA,MACH,MAAM,KAAK,QAAQ,IAAI,CAAC,IAAI,cAAc,CAAC,EAAE,CAAC;AAAA,MAC9C,MAAM,KAAK,QAAQ,IAAI,CAAC,IAAI,cAAc,CAAC,EAAE,CAAC;AAAA,IAChD;AAAA,EACF,EAAE;AACF,QAAM,YAA2B,CAAC;AAGlC,QAAM,SAAS,KAAK,iBAAiB,IAAI;AACzC,QAAM,YAAY,KAAK,eAAe,IAAI;AAC1C,SAAO,UAAU,SAAS,SAAS,oBAAoB,SAAS,WAAW;AACzE,cAAU,KAAK,oBAAoB,UAAU,SAAS,MAAM,CAAC;AAAA,EAC/D;AAGA;AACE,UAAM,cAAc,oBAAoB,iBAAiB,IAAI,CAAC;AAC9D,UAAM,aAAa,oBAAoB,iBAAiB,IAAI,CAAC;AAC7D,UAAM,oBAAoB,oBAAoB,YAAY;AAC1D,UAAM,qBAAqB;AAAA,MACzB,gBAAgBK,iBAAgB,aAAa,UAAU,CAAC;AAAA,IAC1D;AAEA,QAAI,uBAAuB,sBAAsB,oBAAoB;AACnE,YAAM,WAAW,oBACb,eAAe,cAAc,aAAa,IAC1C,eAAe,cAAc,YAAY;AAC7C,gBAAU;AAAA,QACRL;AAAA,UACE,CAAC,qBACG,WAAW,CAAC,IACZ,iBAAiB,CAAC,KAAK,WAAW,eAAe,CAAC;AAAA,UACtD,qBACI,WAAW,CAAC,IACZ,iBAAiB,CAAC,KAAK,WAAW,eAAe,CAAC;AAAA,QACxD;AAAA,MACF;AACA,gBAAU;AAAA,QACRA;AAAA,UACE,oBACI,iBAAiB,CAAC,KAAK,WAAW,eAAe,CAAC,gBAClD,iBAAiB,CAAC;AAAA,UACtB,CAAC,oBACG,iBAAiB,CAAC,KAAK,WAAW,eAAe,CAAC,gBAClD,iBAAiB,CAAC;AAAA,QACxB;AAAA,MACF;AACA,UAAI,CAAC,gBAAgB;AACnB,yBAAiB;AACjB,mBAAW,WAAW,mBAAmB;AACvC,cAAI,QAAQ,QAAQ,GAAG;AACrB,oBAAQ,SAAS;AAAA,UACnB;AAAA,QACF;AAAA,MACF;AAAA,IACF,OAAO;AACL,gBAAU;AAAA,QACRA;AAAA,UACE,CAAC,qBAAqB,YAAY,CAAC,IAAI,iBAAiB,CAAC;AAAA,UACzD,qBAAqB,YAAY,CAAC,IAAI,iBAAiB,CAAC;AAAA,QAC1D;AAAA,MACF;AACA,UAAI,gBAAgB;AAClB,yBAAiB;AACjB,mBAAW,WAAW,mBAAmB;AACvC,cAAI,QAAQ,QAAQ,GAAG;AACrB,oBAAQ,SAAS;AAAA,UACnB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,cAAU,QAAQ,gBAAgB;AAAA,EACpC;AAGA;AACE,UAAM,oBACJ,oBAAoB,oBAAoB,UAAU,eAAe,IAAI,EAAE;AACzE,UAAM,mBACJ,oBAAoB,oBAAoB,UAAU,eAAe,IAAI,EAAE;AACzE,UAAM,kBAAkB,oBAAoB,UAAU;AACtD,UAAM,qBAAqB;AAAA,MACzB;AAAA,MACA;AAAA,IACF;AACA,QAAI,qBAAqB,oBAAoB,oBAAoB;AAC/D,YAAM,WAAW,kBACb,eAAe,YAAY,aAAa,IACxC,eAAe,YAAY,YAAY;AAC3C,gBAAU;AAAA,QACRA;AAAA,UACE,CAAC,qBACG,iBAAiB,CAAC,IAClB,eAAe,CAAC,KAAK,WAAW,eAAe,CAAC;AAAA,UACpD,qBACI,iBAAiB,CAAC,IAClB,eAAe,CAAC,KAAK,WAAW,eAAe,CAAC;AAAA,QACtD;AAAA,MACF;AACA,gBAAU;AAAA,QACRA;AAAA,UACE,kBACI,eAAe,CAAC,KAAK,WAAW,eAAe,CAAC,gBAChD,eAAe,CAAC;AAAA,UACpB,CAAC,kBACG,eAAe,CAAC,KAAK,WAAW,eAAe,CAAC,gBAChD,eAAe,CAAC;AAAA,QACtB;AAAA,MACF;AACA,UAAI,CAAC,cAAc;AACjB,uBAAe;AAAA,MACjB;AAAA,IACF,OAAO;AACL,gBAAU;AAAA,QACRA;AAAA,UACE,CAAC,qBAAqB,kBAAkB,CAAC,IAAI,eAAe,CAAC;AAAA,UAC7D,qBAAqB,kBAAkB,CAAC,IAAI,eAAe,CAAC;AAAA,QAC9D;AAAA,MACF;AACA,UAAI,cAAc;AAChB,uBAAe;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AAEA,YAAU,KAAK,cAAc;AAE7B,SAAO;AAAA,IACL;AAAA,IACA,kBACG,IAAI,CAAC,EAAE,MAAM,OAAO;AAAA,MACnB;AAAA,MACA,OAAO,UAAU,QAAQ,CAAC;AAAA,MAC1B,KAAK,UAAU,KAAK;AAAA,IACtB,EAAE,EACD,IAAI,CAAC,aAAa;AAAA,MACjB,GAAG;AAAA,MACH,OAAOA;AAAA,QACL,QAAQ,MAAM,CAAC,IAAI,iBAAiB,CAAC;AAAA,QACrC,QAAQ,MAAM,CAAC,IAAI,iBAAiB,CAAC;AAAA,MACvC;AAAA,MACA,KAAKA;AAAA,QACH,QAAQ,IAAI,CAAC,IAAI,iBAAiB,CAAC;AAAA,QACnC,QAAQ,IAAI,CAAC,IAAI,iBAAiB,CAAC;AAAA,MACrC;AAAA,IACF,EAAE;AAAA,IACJ;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,UAAU;AAKT,IAAM,yBAAyB,CACpC,OACA,aACA,SAMA,YAG+C;AAC/C,MAAI,MAAM,OAAO,SAAS,GAAG;AAC3B,WAAO,EAAE,QAAQ,QAAQ,UAAU,MAAM,OAAO;AAAA,EAClD;AAEA,MAAI,CAAC,+BAAgB,MAAM;AACzB,IAAAG;AAAA,MACE,CAAC,QAAQ,UAAU,QAAQ,OAAO,UAAU;AAAA,MAC5C;AAAA,IAGF;AAEA,IAAAA;AAAA,MACE,CAAC,MAAM,iBACL,MAAM,cACH,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,EAC7D,MAAM,OAAO;AAAA,MAClB;AAAA,IACF;AAEA,IAAAA;AAAA,MACE,CAAC,QAAQ,iBACP,QAAQ,cACL,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,EAC7D,MAAM,OAAO;AAAA,MAClB;AAAA,IACF;AAEA,IAAAA;AAAA,MACE,MAAM,OACH,MAAM,CAAC,EACP;AAAA,QACC,CAAC,GAAG,MAAM,EAAE,CAAC,MAAM,MAAM,OAAO,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,MAAM,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,MACrE;AAAA,MACF;AAAA,IACF;AAEA,IAAAA;AAAA,MACE,QAAQ,eAAe;AAAA,QACrB,CAAC,YACC,QAAQ,UAAU,KAClBC,aAAY,QAAQ,QAAQ,QAAQ,UAAU,MAAM,QAAQ,CAAC,CAAC;AAAA,MAClE,KAAK,QACH,QAAQ,eAAe;AAAA,QACrB,CAAC,YACC,QAAQ,WAAW,QAAQ,UAAU,MAAM,QAAQ,SAAS,KAC5DA;AAAA,UACE,QAAQ;AAAA,WACP,QAAQ,UAAU,MAAM,SACtB,QAAQ,UAAU,MAAM,QAAQ,SAAS,CAC5C;AAAA,QACF;AAAA,MACJ,KAAK;AAAA,MACP;AAAA,IACF;AAAA,EACF;AAEA,QAAM,gBAAgB,QAAQ,iBAAiB,MAAM,iBAAiB,CAAC;AAEvE,QAAM,gBAAuC,QAAQ,SACjD,QAAQ,UAAU,QAAQ,OAAO,WAAW,IAC1C,MAAM,OAAO;AAAA,IAAI,CAAC,GAAG,QACnB,QAAQ,IACJ,QAAQ,OAAQ,CAAC,IACjB,QAAQ,MAAM,OAAO,SAAS,IAC9B,QAAQ,OAAQ,CAAC,IACjB;AAAA,EACN,IACA,QAAQ,OAAO,MAAM,IACvB,MAAM,OAAO,MAAM;AAKvB,QAAM;AAAA,IACJ,cAAc;AAAA,IACd,YAAY;AAAA,IACZ,GAAG;AAAA,EACL,IAAI;AACJ,QAAM,eACJ,OAAO,wBAAwB,cAC3B,sBACA,MAAM;AACZ,QAAM,aACJ,OAAO,sBAAsB,cACzB,oBACA,MAAM;AACZ,QAAM,eACJ,gBACA,wBAAwB,aAAa,WAAW,WAAW;AAC7D,QAAM,aACJ,cAAc,wBAAwB,WAAW,WAAW,WAAW;AACzE,QAAM,wBAAwB,oBAAoB,aAAa;AAE/D,MACG,gBAAgB,CAAC,gBAAgB,yBACjC,cAAc,CAAC,cAAc,yBAC7B,YAAY,SAAS,KAAK,yBAC1B,OAAO,KAAK,gBAAgB,EAAE,WAAW,MACvC,cAAc,OAAO,cAAc,aAClC,YAAY,OAAO,YAAY,YACnC;AACA,WAAO;AAAA,MACL,cAAc;AAAA,QAAI,CAAC,MACjBJ,WAAuB,MAAM,IAAI,EAAE,CAAC,GAAG,MAAM,IAAI,EAAE,CAAC,CAAC;AAAA,MACvD;AAAA,MACA,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,IACR;AAAA,EACF;AAEA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG;AAAA,EACL,IAAI;AAAA,IACF;AAAA,MACE,GAAG,MAAM;AAAA,MACT,GAAG,MAAM;AAAA,MACT;AAAA,MACA;AAAA,MACA,gBAAgB,MAAM;AAAA,MACtB,cAAc,MAAM;AAAA,MACpB,QAAQ,MAAM;AAAA,IAChB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAKA,MAAI,YAAY,SAAS,KAAK,uBAAuB;AACnD,WAAO;AAAA,MACL,cAAc;AAAA,QAAI,CAAC,MACjBA,WAAuB,MAAM,IAAI,EAAE,CAAC,GAAG,MAAM,IAAI,EAAE,CAAC,CAAC;AAAA,MACvD;AAAA,MACA,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,IACR;AAAA,EACF;AAKA,MACE,CAAC,QAAQ,UACT,CAAC,QAAQ,iBACT,CAAC,QAAQ,gBACT,CAAC,QAAQ,YACT;AACA,WAAO,6BAA6B,OAAO,WAAW;AAAA,EACxD;AAGA,MACE,QAAQ,iBAAiB,MAAM,gBAC/B,QAAQ,eAAe,MAAM,eAC5B,QAAQ,UAAU,CAAC,GAAG;AAAA,IAAM,CAAC,GAAG,MAC/BI;AAAA,MACE;AAAA,MACA,MAAM,OAAO,CAAC,KAAKJ,WAAsB,UAAU,QAAQ;AAAA,IAC7D;AAAA,EACF,KACA,uBACA;AACA,WAAO,CAAC;AAAA,EACV;AAKA,MAAI,cAAc,WAAW,GAAG;AAC9B,WAAO;AAAA,MACL;AAAA,QACE;AAAA,UACE,gBAAgB,OAAO;AAAA,YACrB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,GAAG;AAAA,UACL,CAAC,KAAK,CAAC;AAAA,QACT;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAIA,OAAK,MAAM,eAAe,UAAU,KAAK,cAAc,QAAQ;AAC7D,WAAO,qBAAqB,OAAO,eAAe,WAAW;AAAA,EAC/D;AAKA,MAAI,CAAC,QAAQ,QAAQ;AACnB,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAKA,MAAI,QAAQ,UAAU,QAAQ,eAAe;AAC3C,WAAO;AAAA,EACT;AASA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAyBA,IAAM,oBAAoB,CACxB,OASA,aACA,YACA,YAIG;AACH,QAAM,uBAAoC,eAGxC,WAAW,CAAC,GAAGM,QAAO,MAAM,GAAG,MAAM,CAAC,CAAC;AACzC,QAAM,qBAAkC,eAGtC,WAAW,WAAW,SAAS,CAAC,GAAGA,QAAO,MAAM,GAAG,MAAM,CAAC,CAAC;AAE7D,MAAI,sBAAsB;AAC1B,MAAI,oBAAoB;AACxB,MAAI,SAAS,YAAY;AACvB,UAAM,WAAW,MAAM,KAAK,YAAY,OAAO,CAAC;AAChD,0BACE;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS;AAAA,IACX,KAAK;AACP,wBACE;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS;AAAA,IACX,KAAK;AAAA,EACT,OAAO;AACL,0BAAsB,MAAM,eACxB,wBAAwB,MAAM,aAAa,WAAW,WAAW,KACjE,OACA;AACJ,wBAAoB,MAAM,aACtB,wBAAwB,MAAM,WAAW,WAAW,WAAW,KAAK,OACpE;AAAA,EACN;AAEA,QAAM,mBAAmB;AAAA,IACvB;AAAA,MACE,GAAG;AAAA,MACH,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,IACV;AAAA,IACA;AAAA,IACA,MAAM,cAAc;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,EACX;AACA,QAAM,iBAAiB;AAAA,IACrB;AAAA,MACE,GAAG;AAAA,MACH,MAAM;AAAA,MACN,SAAS;AAAA,MACT,QAAQ;AAAA,IACV;AAAA,IACA;AAAA,IACA,MAAM,YAAY;AAAA,IAClB;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,EACX;AACA,QAAM,eAAe;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,aAAa;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,mBAAmB;AAAA,IACvB,iBAAiB,CAAC,IAAI;AAAA,IACtB,iBAAiB,CAAC,IAAI;AAAA,IACtB,iBAAiB,CAAC,IAAI;AAAA,IACtB,iBAAiB,CAAC,IAAI;AAAA,EACxB;AACA,QAAM,iBAAiB;AAAA,IACrB,eAAe,CAAC,IAAI;AAAA,IACpB,eAAe,CAAC,IAAI;AAAA,IACpB,eAAe,CAAC,IAAI;AAAA,IACpB,eAAe,CAAC,IAAI;AAAA,EACtB;AACA,QAAM,qBAAqB,sBACvB;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,MACE;AAAA,MACA,MAAM,iBACF,yBAAyB,IACzB,yBAAyB;AAAA,MAC7B;AAAA,IACF;AAAA,EACF,IACA;AACJ,QAAM,mBAAmB,oBACrB;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,MACE;AAAA,MACA,MAAM,eACF,yBAAyB,IACzB,yBAAyB;AAAA,MAC7B;AAAA,IACF;AAAA,EACF,IACA;AACJ,QAAM,gBACJ;AAAA,IACE;AAAA,IACA,oBACI;AAAA,MACE;AAAA,MACA;AAAA,MACA,kBAAkB,YAAY,cAAc,YAAY;AAAA,IAC1D,IACA;AAAA,EACN,KACA;AAAA,IACE;AAAA,IACA,sBACI;AAAA,MACE;AAAA,MACA;AAAA,MACA,kBAAkB,cAAc,cAAc,YAAY;AAAA,IAC5D,IACA;AAAA,EACN;AACF,QAAM,eAAe;AAAA,IACnB,gBACI,CAAC,kBAAkB,cAAc,IACjC,CAAC,oBAAoB,gBAAgB;AAAA,EAC3C;AACA,QAAM,eAAe;AAAA,IACnB,gBAAgB,mBAAmB;AAAA,IACnC,gBAAgB,iBAAiB;AAAA,IACjC;AAAA,IACA,gBACI;AAAA,MACE;AAAA,MACA,CAAC,uBAAuB,CAAC,oBAAoB,IAAI;AAAA,MACjD;AAAA,IACF,IACA;AAAA,MACE;AAAA,MACA,CAAC,uBAAuB,CAAC,oBACrB,IACA,gBACG,MAAM,iBACH,yBAAyB,IACzB,yBAAyB;AAAA,MACnC;AAAA,IACF;AAAA,IACJ,gBACI;AAAA,MACE;AAAA,MACA,CAAC,uBAAuB,CAAC,oBAAoB,IAAI;AAAA,MACjD;AAAA,IACF,IACA;AAAA,MACE;AAAA,MACA,CAAC,uBAAuB,CAAC,oBACrB,IACA,gBACG,MAAM,eACH,yBAAyB,IACzB,yBAAyB;AAAA,MACnC;AAAA,IACF;AAAA,IACJ;AAAA,IACA,uBAAuB,eAAe,qBAAqB,WAAW;AAAA,IACtE,qBAAqB,eAAe,mBAAmB,WAAW;AAAA,EACpE;AACA,QAAM,sBAAsB;AAAA,IAC1B,aAAa,CAAC;AAAA,IACd;AAAA,IACA;AAAA,EACF;AACA,QAAM,oBAAoB;AAAA,IACxB,aAAa,CAAC;AAAA,IACd;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAWA,IAAM,kBAAkB,CACtB,OACA,mBACyB;AACzB,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AAGJ,QAAM,OAAO;AAAA,IACX;AAAA,IACA,sBAAsB,sBAAsB;AAAA,IAC5C;AAAA,IACA,oBAAoB,oBAAoB;AAAA,IACxC;AAAA,IACA;AAAA,EACF;AAEA,QAAM,cACJ,uBAAuB,gBAAgB,qBAAqB,IAAI;AAClE,QAAM,YACJ,qBAAqB,gBAAgB,mBAAmB,IAAI;AAG9D,QAAM,UAAU,gBAAgB,gBAAgB,IAAI;AACpD,MAAI,WAAW,mBAAmB;AAChC,YAAQ,SAAS;AAAA,EACnB;AACA,QAAM,YAAY,gBAAgB,kBAAkB,IAAI;AACxD,MAAI,aAAa,MAAM,cAAc;AACnC,cAAU,SAAS;AAAA,EACrB;AACA,QAAM,gBACJ,eACA,cACC,kBAAkB,YAAY,KAAK,aAAa,CAAC,CAAC,KACjD,kBAAkB,UAAU,KAAK,aAAa,CAAC,CAAC;AAGpD,QAAM,OAAO;AAAA,IACX,cAAc,cAAc;AAAA,IAC5B,YAAY,YAAY;AAAA,IACxB;AAAA,IACA,eAAe,eAAe;AAAA,IAC9B,aAAa,aAAa;AAAA,IAC1B,gBAAgB,CAAC,IAAI;AAAA,EACvB;AAEA,MAAI,MAAM;AACR,UAAM,SAAS,KAAK,IAAI,CAAC,SAAS;AAAA,MAChC,KAAK,IAAI,CAAC;AAAA,MACV,KAAK,IAAI,CAAC;AAAA,IACZ,CAAC;AACD,mBAAe,OAAO,QAAQ,gBAAgB;AAC9C,iBAAa,OAAO,KAAK,cAAc;AAEvC,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEA,IAAM,oBAAoB,CACxB,SACA,MACA,SACqC;AACrC,UAAQ,SAAS;AAAA,IACf,KAAK;AACH,aAAO,CAAC,MAAM,MAAM,MAAM,IAAI;AAAA,IAChC,KAAK;AACH,aAAO,CAAC,MAAM,MAAM,MAAM,IAAI;AAAA,IAChC,KAAK;AACH,aAAO,CAAC,MAAM,MAAM,MAAM,IAAI;AAAA,EAClC;AAEA,SAAO,CAAC,MAAM,MAAM,MAAM,IAAI;AAChC;AAaA,IAAM,QAAQ,CACZ,OACA,KACA,MACA,cACA,YACA,UACG;AACH,QAAM,iBAAiB,OAAO,MAAM,KAAK,IAAI,GAAG;AAChD,QAAM,OAAO,IAAI,WAAiB,CAAC,SAAS,KAAK,CAAC;AAElD,OAAK,KAAK,KAAK;AAEf,SAAO,KAAK,KAAK,IAAI,GAAG;AAEtB,UAAM,UAAU,KAAK,IAAI;AAEzB,QAAI,CAAC,WAAW,QAAQ,QAAQ;AAE9B;AAAA,IACF;AAGA,QAAI,YAAY,KAAK;AACnB,aAAO,OAAO,OAAO,OAAO;AAAA,IAC9B;AAGA,YAAQ,SAAS;AAGjB,UAAM,YAAY,aAAa,QAAQ,MAAM,IAAI;AAEjD,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,YAAM,WAAW,UAAU,CAAC;AAE5B,UAAI,CAAC,YAAY,SAAS,QAAQ;AAEhC;AAAA,MACF;AAGA,YAAM,oBAAoBC;AAAA,QACxB,SAAS;AAAA,QACT,QAAQ;AAAA,QACR;AAAA,MACF;AACA,UACE;AAAA,QACE,GAAG,MAAM,IAAI,CAAC,SAAS,kBAAkB,mBAAmB,IAAI,CAAC;AAAA,MACnE,GACA;AACA;AAAA,MACF;AAIA,YAAM,kBAAkB,uBAAuB,CAAkB;AACjE,YAAM,oBAAoB,QAAQ,SAC9B,gBAAgBF,iBAAgB,QAAQ,KAAK,QAAQ,OAAO,GAAG,CAAC,IAChE;AAGJ,YAAM,iBAAiB,YAAY,iBAAiB;AACpD,YAAM,yBACJ,eAAe,gBAAgB,eAAe,KAC7C,mBAAmB,MAAM,MAAM,SAAS,IAAI,KAC3C,eAAe,iBAAiB,YAAY,KAC7C,mBAAmB,IAAI,MAAM,SAAS,IAAI,KACzC,eAAe,iBAAiB,UAAU;AAC9C,UAAI,wBAAwB;AAC1B;AAAA,MACF;AAEA,YAAM,kBAAkB,sBAAsB;AAC9C,YAAM,SACJ,QAAQ,IACR,OAAO,SAAS,KAAK,QAAQ,GAAG,KAC/B,kBAAkB,KAAK,IAAI,gBAAgB,CAAC,IAAI;AAEnD,YAAM,cAAc,SAAS;AAE7B,UAAI,CAAC,eAAe,SAAS,SAAS,GAAG;AACvC,cAAM,eAAe;AAAA,UACnB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAEA,iBAAS,UAAU;AACnB,iBAAS,SAAS;AAClB,iBAAS,IACP,OAAO,IAAI,KAAK,SAAS,GAAG,IAC5B,eAAe,KAAK,IAAI,gBAAgB,CAAC;AAC3C,iBAAS,IAAI;AACb,iBAAS,IAAI,SAAS,IAAI,SAAS;AACnC,YAAI,CAAC,aAAa;AAEhB,eAAK,KAAK,QAAQ;AAAA,QACpB,OAAO;AAEL,eAAK,eAAe,QAAQ;AAAA,QAC9B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,SAAS,CAAC,OAAa,SAAe;AAC1C,MAAI,OAAO;AACX,QAAM,OAAO,CAAC;AACd,SAAO,KAAK,QAAQ;AAClB,SAAK,QAAQ,IAAI;AACjB,WAAO,KAAK;AAAA,EACd;AACA,OAAK,QAAQ,KAAK;AAElB,SAAO;AACT;AAEA,IAAM,SAAS,CAACG,IAA6BC,OAC3C,KAAK,IAAID,GAAE,CAAC,IAAIC,GAAE,CAAC,CAAC,IAAI,KAAK,IAAID,GAAE,CAAC,IAAIC,GAAE,CAAC,CAAC;AAO9C,IAAM,uBAAuB,CAC3BD,IACAC,IACA,QACA,iBACA,eACA,iBACA,oBACA,qBACa;AACb,QAAM,UAAU,sBAAsBD;AACtC,QAAM,QAAQ,oBAAoBC;AAClC,QAAM,CAAC,SAAS,YAAY,WAAW,SAAS,IAAI,mBAAmB;AAAA,IACrE;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,EACX;AACA,QAAM,CAAC,OAAO,UAAU,SAAS,OAAO,IAAI,iBAAiB,CAAC,GAAG,GAAG,GAAG,CAAC;AAExE,QAAM,QAAQ;AAAA,IACZD,GAAE,CAAC,IAAIC,GAAE,CAAC,IACND,GAAE,CAAC,IAAIC,GAAE,CAAC,KAAKD,GAAE,CAAC,IAAIC,GAAE,CAAC,IACvB,KAAK,KAAK,QAAQ,CAAC,IAAI,MAAM,CAAC,KAAK,GAAGD,GAAE,CAAC,IAAI,SAAS,KACrD,QAAQ,CAAC,IAAI,MAAM,CAAC,KAAK,IAC5BA,GAAE,CAAC,IAAIC,GAAE,CAAC,IACVD,GAAE,CAAC,IAAI,YACP,OAAO,CAAC,IAAI;AAAA,IAChBA,GAAE,CAAC,IAAIC,GAAE,CAAC,IACND,GAAE,CAAC,IAAIC,GAAE,CAAC,KAAKD,GAAE,CAAC,IAAIC,GAAE,CAAC,IACvB,KAAK,KAAK,QAAQ,CAAC,IAAI,MAAM,CAAC,KAAK,GAAGD,GAAE,CAAC,IAAI,OAAO,KACnD,QAAQ,CAAC,IAAI,MAAM,CAAC,KAAK,IAC5BA,GAAE,CAAC,IAAIC,GAAE,CAAC,IACVD,GAAE,CAAC,IAAI,UACP,OAAO,CAAC,IAAI;AAAA,IAChBA,GAAE,CAAC,IAAIC,GAAE,CAAC,IACND,GAAE,CAAC,IAAIC,GAAE,CAAC,KAAKD,GAAE,CAAC,IAAIC,GAAE,CAAC,IACvB,KAAK,KAAK,QAAQ,CAAC,IAAI,MAAM,CAAC,KAAK,GAAGD,GAAE,CAAC,IAAI,UAAU,KACtD,QAAQ,CAAC,IAAI,MAAM,CAAC,KAAK,IAC5BA,GAAE,CAAC,IAAIC,GAAE,CAAC,IACVD,GAAE,CAAC,IAAI,aACP,OAAO,CAAC,IAAI;AAAA,IAChBA,GAAE,CAAC,IAAIC,GAAE,CAAC,IACND,GAAE,CAAC,IAAIC,GAAE,CAAC,KAAKD,GAAE,CAAC,IAAIC,GAAE,CAAC,IACvB,KAAK,KAAK,QAAQ,CAAC,IAAI,MAAM,CAAC,KAAK,GAAGD,GAAE,CAAC,IAAI,SAAS,KACrD,QAAQ,CAAC,IAAI,MAAM,CAAC,KAAK,IAC5BA,GAAE,CAAC,IAAIC,GAAE,CAAC,IACVD,GAAE,CAAC,IAAI,YACP,OAAO,CAAC,IAAI;AAAA,EAClB;AACA,QAAM,SAAS;AAAA,IACbC,GAAE,CAAC,IAAID,GAAE,CAAC,IACNC,GAAE,CAAC,IAAID,GAAE,CAAC,KAAKC,GAAE,CAAC,IAAID,GAAE,CAAC,IACvB,KAAK,KAAK,MAAM,CAAC,IAAI,QAAQ,CAAC,KAAK,GAAGC,GAAE,CAAC,IAAI,OAAO,KACnD,MAAM,CAAC,IAAI,QAAQ,CAAC,KAAK,IAC5BA,GAAE,CAAC,IAAID,GAAE,CAAC,IACVC,GAAE,CAAC,IAAI,UACP,OAAO,CAAC,IAAI;AAAA,IAChBA,GAAE,CAAC,IAAID,GAAE,CAAC,IACNC,GAAE,CAAC,IAAID,GAAE,CAAC,KAAKC,GAAE,CAAC,IAAID,GAAE,CAAC,IACvB,KAAK,KAAK,MAAM,CAAC,IAAI,QAAQ,CAAC,KAAK,GAAGC,GAAE,CAAC,IAAI,KAAK,KACjD,MAAM,CAAC,IAAI,QAAQ,CAAC,KAAK,IAC5BA,GAAE,CAAC,IAAID,GAAE,CAAC,IACVC,GAAE,CAAC,IAAI,QACP,OAAO,CAAC,IAAI;AAAA,IAChBA,GAAE,CAAC,IAAID,GAAE,CAAC,IACNC,GAAE,CAAC,IAAID,GAAE,CAAC,KAAKC,GAAE,CAAC,IAAID,GAAE,CAAC,IACvB,KAAK,KAAK,MAAM,CAAC,IAAI,QAAQ,CAAC,KAAK,GAAGC,GAAE,CAAC,IAAI,QAAQ,KACpD,MAAM,CAAC,IAAI,QAAQ,CAAC,KAAK,IAC5BA,GAAE,CAAC,IAAID,GAAE,CAAC,IACVC,GAAE,CAAC,IAAI,WACP,OAAO,CAAC,IAAI;AAAA,IAChBA,GAAE,CAAC,IAAID,GAAE,CAAC,IACNC,GAAE,CAAC,IAAID,GAAE,CAAC,KAAKC,GAAE,CAAC,IAAID,GAAE,CAAC,IACvB,KAAK,KAAK,MAAM,CAAC,IAAI,QAAQ,CAAC,KAAK,GAAGC,GAAE,CAAC,IAAI,OAAO,KACnD,MAAM,CAAC,IAAI,QAAQ,CAAC,KAAK,IAC5BA,GAAE,CAAC,IAAID,GAAE,CAAC,IACVC,GAAE,CAAC,IAAI,UACP,OAAO,CAAC,IAAI;AAAA,EAClB;AAEA,QAAM,IAAI,WAAW,CAAC,OAAO,MAAM,CAAC;AACpC,MACE,CAAC,mBACD,MAAM,CAAC,IAAI,MAAM,CAAC,IAAI,OAAO,CAAC,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,SAC5D,MAAM,CAAC,IAAI,MAAM,CAAC,IAAI,OAAO,CAAC,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,OAC5D;AACA,UAAM,CAAC,YAAY,UAAU,IAAI;AAAA,OAC9B,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK;AAAA,OACzB,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK;AAAA,IAC5B;AACA,QAAIA,GAAE,CAAC,IAAID,GAAE,CAAC,KAAKA,GAAE,CAAC,IAAIC,GAAE,CAAC,GAAG;AAE9B,YAAM,KAAK,MAAM,CAAC,KAAK,OAAO,CAAC,IAAI,MAAM,CAAC,KAAK;AAC/C,YAAM,KAAK,OAAO,CAAC,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,KAAK;AAEhD,UACEC;AAAA,QACEJ,QAAOE,GAAE,CAAC,IAAI,YAAYA,GAAE,CAAC,IAAI,UAAU;AAAA,QAC3CF,QAAOE,GAAE,CAAC,IAAI,YAAYA,GAAE,CAAC,IAAI,UAAU;AAAA,MAC7C,IAAI,GACJ;AACA,eAAO;AAAA,UACL,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC;AAAA,UACjC,CAAC,IAAI,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,QACtC;AAAA,MACF;AAEA,aAAO;AAAA,QACL,CAAC,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAAA,QACjC,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,EAAE;AAAA,MACtC;AAAA,IACF,WAAWA,GAAE,CAAC,IAAIC,GAAE,CAAC,KAAKD,GAAE,CAAC,IAAIC,GAAE,CAAC,GAAG;AAErC,YAAM,KAAK,MAAM,CAAC,KAAK,OAAO,CAAC,IAAI,MAAM,CAAC,KAAK;AAC/C,YAAM,KAAK,MAAM,CAAC,KAAK,OAAO,CAAC,IAAI,MAAM,CAAC,KAAK;AAE/C,UACEC;AAAA,QACEJ,QAAOE,GAAE,CAAC,IAAI,YAAYA,GAAE,CAAC,IAAI,UAAU;AAAA,QAC3CF,QAAOE,GAAE,CAAC,IAAI,YAAYA,GAAE,CAAC,IAAI,UAAU;AAAA,MAC7C,IAAI,GACJ;AACA,eAAO;AAAA,UACL,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,EAAE;AAAA,UACjC,CAAC,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,QACtC;AAAA,MACF;AAEA,aAAO;AAAA,QACL,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC;AAAA,QACjC,CAAC,IAAI,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,MACtC;AAAA,IACF,WAAWA,GAAE,CAAC,IAAIC,GAAE,CAAC,KAAKD,GAAE,CAAC,IAAIC,GAAE,CAAC,GAAG;AAErC,YAAM,KAAK,OAAO,CAAC,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,KAAK;AAChD,YAAM,KAAK,MAAM,CAAC,KAAK,OAAO,CAAC,IAAI,MAAM,CAAC,KAAK;AAE/C,UACEC;AAAA,QACEJ,QAAOE,GAAE,CAAC,IAAI,YAAYA,GAAE,CAAC,IAAI,UAAU;AAAA,QAC3CF,QAAOE,GAAE,CAAC,IAAI,YAAYA,GAAE,CAAC,IAAI,UAAU;AAAA,MAC7C,IAAI,GACJ;AACA,eAAO;AAAA,UACL,CAAC,IAAI,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAAA,UACjC,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,CAAC;AAAA,QACtC;AAAA,MACF;AAEA,aAAO;AAAA,QACL,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,EAAE;AAAA,QACjC,CAAC,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,MACtC;AAAA,IACF,WAAWA,GAAE,CAAC,IAAIC,GAAE,CAAC,KAAKD,GAAE,CAAC,IAAIC,GAAE,CAAC,GAAG;AAErC,YAAM,KAAK,OAAO,CAAC,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,KAAK;AAChD,YAAM,KAAK,OAAO,CAAC,KAAK,MAAM,CAAC,IAAI,OAAO,CAAC,KAAK;AAEhD,UACEC;AAAA,QACEJ,QAAOE,GAAE,CAAC,IAAI,YAAYA,GAAE,CAAC,IAAI,UAAU;AAAA,QAC3CF,QAAOE,GAAE,CAAC,IAAI,YAAYA,GAAE,CAAC,IAAI,UAAU;AAAA,MAC7C,IAAI,GACJ;AACA,eAAO;AAAA,UACL,CAAC,IAAI,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAAA,UACjC,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,CAAC;AAAA,QACtC;AAAA,MACF;AAEA,aAAO;AAAA,QACL,CAAC,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAAA,QACjC,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,EAAE;AAAA,MACtC;AAAA,IACF;AAAA,EACF;AAEA,SAAO,CAAC,OAAO,MAAM;AACvB;AASA,IAAM,gBAAgB,CACpB,OACA,OACA,cACA,KACA,YACA,WACS;AACT,QAAM,aAAa,oBAAI,IAAY;AACnC,QAAM,WAAW,oBAAI,IAAY;AAEjC,MAAI,iBAAiB,gBAAgB,iBAAiB,eAAe;AACnE,aAAS,IAAI,MAAM,CAAC,CAAC;AAAA,EACvB,OAAO;AACL,eAAW,IAAI,MAAM,CAAC,CAAC;AAAA,EACzB;AACA,MAAI,eAAe,gBAAgB,eAAe,eAAe;AAC/D,aAAS,IAAI,IAAI,CAAC,CAAC;AAAA,EACrB,OAAO;AACL,eAAW,IAAI,IAAI,CAAC,CAAC;AAAA,EACvB;AAEA,QAAM,QAAQ,CAAC,SAAS;AACtB,eAAW,IAAI,KAAK,CAAC,CAAC;AACtB,eAAW,IAAI,KAAK,CAAC,CAAC;AACtB,aAAS,IAAI,KAAK,CAAC,CAAC;AACpB,aAAS,IAAI,KAAK,CAAC,CAAC;AAAA,EACtB,CAAC;AAED,aAAW,IAAI,OAAO,CAAC,CAAC;AACxB,aAAW,IAAI,OAAO,CAAC,CAAC;AACxB,WAAS,IAAI,OAAO,CAAC,CAAC;AACtB,WAAS,IAAI,OAAO,CAAC,CAAC;AAEtB,QAAM,YAAY,MAAM,KAAK,QAAQ,EAAE,KAAK,CAACA,IAAGC,OAAMD,KAAIC,EAAC;AAC3D,QAAM,cAAc,MAAM,KAAK,UAAU,EAAE,KAAK,CAACD,IAAGC,OAAMD,KAAIC,EAAC;AAE/D,SAAO;AAAA,IACL,KAAK,UAAU;AAAA,IACf,KAAK,YAAY;AAAA,IACjB,MAAM,UAAU;AAAA,MAAQ,CAAC,GAAG,QAC1B,YAAY;AAAA,QACV,CAAC,GAAG,SAAe;AAAA,UACjB,GAAG;AAAA,UACH,GAAG;AAAA,UACH,GAAG;AAAA,UACH,QAAQ;AAAA,UACR,SAAS;AAAA,UACT,QAAQ;AAAA,UACR,MAAM,CAAC,KAAK,GAAG;AAAA,UACf,KAAK,CAAC,GAAG,CAAC;AAAA,QACZ;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,oBAAoB,CACxB,QACA,SACA,MACgB;AAChB,UAAQ,SAAS;AAAA,IACf,KAAK;AACH,aAAOT,WAAU,EAAE,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,IAClC,KAAK;AACH,aAAOA,WAAU,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;AAAA,IAClC,KAAK;AACH,aAAOA,WAAU,EAAE,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,EACpC;AACA,SAAOA,WAAU,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;AAClC;AAEA,IAAM,uBAAuB,CAC3B,OACA,KACA,cACA,eACG;AACH,MAAI,eAAe,eAAe;AAChC,YAAQ,cAAc;AAAA,MACpB,KAAK,eAAe;AAClB,YAAI,MAAM,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,GAAG;AAC9B,iBAAO;AAAA,QACT;AACA,YAAI,MAAM,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG;AAC/B,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT;AAAA,MACA,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG;AAC1D,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG;AAC1D,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG;AAC/B,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,IACX;AAAA,EACF,WAAW,eAAe,cAAc;AACtC,YAAQ,cAAc;AAAA,MACpB,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG;AAC/B,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG;AAC1D,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG;AAC1D,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,GAAG;AAC9B,iBAAO;AAAA,QACT;AACA,YAAI,MAAM,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG;AAC/B,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,IACX;AAAA,EACF,WAAW,eAAe,YAAY;AACpC,YAAQ,cAAc;AAAA,MACpB,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG;AAC1D,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,GAAG;AAC9B,iBAAO;AAAA,QACT;AACA,YAAI,MAAM,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG;AAC/B,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG;AAC/B,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG;AAC1D,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,IACX;AAAA,EACF,WAAW,eAAe,cAAc;AACtC,YAAQ,cAAc;AAAA,MACpB,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG;AAC1D,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG;AAC/B,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,GAAG;AAC9B,iBAAO;AAAA,QACT;AACA,YAAI,MAAM,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG;AAC/B,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,MACT,KAAK;AACH,YAAI,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG;AAC1D,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,IACX;AAAA,EACF;AACA,SAAO;AACT;AAKA,IAAM,eAAe,CAAC,CAAC,KAAK,GAAG,GAAqB,SAClD;AAAA,EACE,iBAAiB,CAAC,KAAK,MAAM,CAAC,GAAG,IAAI;AAAA,EACrC,iBAAiB,CAAC,MAAM,GAAG,GAAG,GAAG,IAAI;AAAA,EACrC,iBAAiB,CAAC,KAAK,MAAM,CAAC,GAAG,IAAI;AAAA,EACrC,iBAAiB,CAAC,MAAM,GAAG,GAAG,GAAG,IAAI;AACvC;AAEF,IAAM,mBAAmB,CACvB,CAAC,KAAK,GAAG,GACT,SACgB;AAChB,MAAI,MAAM,KAAK,OAAO,KAAK,OAAO,MAAM,KAAK,OAAO,KAAK,KAAK;AAC5D,WAAO;AAAA,EACT;AAEA,SAAO,KAAK,KAAK,MAAM,KAAK,MAAM,GAAG,KAAK;AAC5C;AAKA,IAAM,kBAAkB,CAAC,OAAoB,SAA4B;AACvE,WAAS,MAAM,GAAG,MAAM,KAAK,KAAK,OAAO;AACvC,aAAS,MAAM,GAAG,MAAM,KAAK,KAAK,OAAO;AACvC,YAAM,YAAY,iBAAiB,CAAC,KAAK,GAAG,GAAG,IAAI;AACnD,UACE,aACA,MAAM,CAAC,MAAM,UAAU,IAAI,CAAC,KAC5B,MAAM,CAAC,MAAM,UAAU,IAAI,CAAC,GAC5B;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,aAAa,CAAC,UAA4B;AAAA,EAC9C,KAAK,IAAI,GAAG,MAAM,IAAI,CAAC,SAAS,KAAK,CAAC,CAAC,CAAC;AAAA,EACxC,KAAK,IAAI,GAAG,MAAM,IAAI,CAAC,SAAS,KAAK,CAAC,CAAC,CAAC;AAAA,EACxC,KAAK,IAAI,GAAG,MAAM,IAAI,CAAC,SAAS,KAAK,CAAC,CAAC,CAAC;AAAA,EACxC,KAAK,IAAI,GAAG,MAAM,IAAI,CAAC,SAAS,KAAK,CAAC,CAAC,CAAC;AAC1C;AAIA,IAAM,0BAA0B,CAC9B,IACA,gBACqC;AACrC,QAAM,UAAU,YAAY,IAAI,EAAE;AAClC,MAAI,WAAW,kBAAkB,OAAO,GAAG;AACzC,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEA,IAAM,8BAA8B,CAClCW,SACA,mBACA,gBACA,iBAUG;AACH,QAAM,UAAUA,QAAO,CAAC,EAAE,CAAC;AAC3B,QAAM,UAAUA,QAAO,CAAC,EAAE,CAAC;AAC3B,MAAI,SAASA,QAAO;AAAA,IAAI,CAAC,MACvB;AAAA,MACE;AAAA,MACAC,aAAYP,iBAAgBM,QAAO,CAAC,CAAC,GAAG,EAAE;AAAA,IAC5C;AAAA,EACF;AAIA,MACE,UAAU,CAAC,WACX,UAAU,WACV,UAAU,CAAC,WACX,UAAU,WACV,UAAU,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,IAAI,CAAC,WAC1C,UAAU,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,IAAI,WACzC,UAAU,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,IAAI,CAAC,WAC1C,UAAU,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,IAAI,SACzC;AACA,YAAQ;AAAA,MACN;AAAA,MACA;AAAA,QACE,GAAG;AAAA,QACH,GAAG;AAAA,QACH;AAAA,QACA,GAAG,kBAAkB,MAAM;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAEA,WAAS,OAAO;AAAA,IAAI,CAAC,CAAC,GAAG,CAAC,MACxBX,WAAsBa,OAAM,GAAG,MAAM,GAAG,GAAGA,OAAM,GAAG,MAAM,GAAG,CAAC;AAAA,EAChE;AAEA,SAAO;AAAA,IACL;AAAA,IACA,GAAGA,OAAM,SAAS,MAAM,GAAG;AAAA,IAC3B,GAAGA,OAAM,SAAS,MAAM,GAAG;AAAA,IAC3B,gBACG,mBAAmB,UAAU,KAAK,IAAI,oBAAoB;AAAA,IAC7D,GAAG,kBAAkB,MAAM;AAAA,IAC3B;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,4BAA4B,CAAC,WAAyC;AAC1E,MAAI,OAAO,SAAS,GAAG;AACrB,QAAI,qBACF,KAAK,IAAI,OAAO,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC,IACpC,KAAK,IAAI,OAAO,CAAC,EAAE,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC;AAEtC,WAAO,OAAO,OAAO,CAAC,GAAG,QAAQ;AAE/B,UAAI,QAAQ,KAAK,QAAQ,OAAO,SAAS,GAAG;AAC1C,eAAO;AAAA,MACT;AAEA,YAAM,OAAO,OAAO,MAAM,CAAC;AAC3B,YAAM,iBACJ,KAAK,IAAI,EAAE,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC,IAAI,KAAK,CAAC,CAAC;AACpD,UAAI,uBAAuB,gBAAgB;AACzC,6BAAqB;AACrB,eAAO;AAAA,MACT;AAEA,2BAAqB;AACrB,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEA,IAAM,gCAAgC,CACpC,WACkB;AAClB,MAAI,OAAO,UAAU,GAAG;AACtB,WAAO,OAAO,OAAO,CAAC,GAAG,QAAQ;AAC/B,UAAI,QAAQ,KAAK,QAAQ,OAAO,SAAS,GAAG;AAC1C,eAAO;AAAA,MACT;AAEA,YAAM,OAAO,OAAO,MAAM,CAAC;AAC3B,YAAM,WAAWZ,eAAc,MAAM,CAAC;AACtC,aAAO,WAAW;AAAA,IACpB,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEA,IAAM,yBAAyB,CAAC,QAAyB;AACvD,UAAQ,KAAK;AAAA,IACX,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,EACX;AACA,SAAO;AACT;AAEA,IAAM,iBAAiB,CACrB,OACA,YACA,iBACA,cACA,SACA,aACA,eACgB;AAChB,MAAI,YAAY;AACd,QAAI,WAAW,aAAa;AAC1B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,MAAI,SAAS;AACX,WAAO;AAAA,MACL,mBAAmB,CAAC,GAAG,CAAC;AAAA,MACxB;AAAA,MACA,eAAe,WAAW,CAAC,OAAO,CAAC;AAAA,IACrC;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,sBAAsB,CAC1B,GACA,YACA,gBACA,WACA,gBAEA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA,kBACE;AAAA,IACE;AAAA,IACA;AAAA,IACA,MAAM,CAAC,EAAE,KAAK,kBAAkB,gBAAgB,aAAa,CAAC,CAAC;AAAA,EAMjE;AAAA,EACF;AAAA,EACA;AACF;AAEF,IAAM,oBAAoB,CACxB,WACA,aACA,UACA,SACG;AACH,SAAO;AAAA,IACL,aAAa,SAAS;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,qBAAqB,CAACO,IAAgBC,OAC1CD,GAAE,CAAC,MAAMC,GAAE,CAAC,KAAKD,GAAE,CAAC,MAAMC,GAAE,CAAC;AAExB,IAAM,sBAAsB,CACjC,QACA,YAAoB,mBAEpB,OACG,MAAM,CAAC,EACP;AAAA,EACC,CAAC,GAAG,MACF,KAAK,IAAI,EAAE,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC,IAAI,aAChC,KAAK,IAAI,EAAE,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC,IAAI;AACpC,EACC,MAAM,OAAO;;;ADlsEX,IAAM,gBAAgB,CAC3B,SACA,aACA,SACA,YAGG;AACH,MAAI,YAAY;AAIhB,QAAM,EAAE,QAAQ,eAAe,cAAc,YAAY,OAAO,IAC9D;AAEF,MACE,aAAa,OAAO,MACnB,OAAO,KAAK,OAAO,EAAE,WAAW;AAAA,EAC/B,OAAO,WAAW;AAAA,EAClB,OAAO,kBAAkB;AAAA,EACzB,OAAO,iBAAiB,eACxB,OAAO,eAAe,cACxB;AACA,cAAU;AAAA,MACR,GAAG;AAAA,MACH,OAAO;AAAA,MACP,GAAG;AAAA,QACD;AAAA,UACE,GAAG;AAAA,UACH,GAAG,QAAQ,KAAK,QAAQ;AAAA,UACxB,GAAG,QAAQ,KAAK,QAAQ;AAAA,QAC1B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF,WAAW,OAAO,WAAW,aAAa;AACxC,cAAU,EAAE,GAAGK,mBAAkB,MAAM,GAAG,GAAG,QAAQ;AAAA,EACvD;AAEA,aAAW,OAAO,SAAS;AACzB,UAAM,QAAS,QAAgB,GAAG;AAClC,QAAI,OAAO,UAAU,aAAa;AAChC,UACG,QAAgB,GAAG,MAAM;AAAA;AAAA,OAGzB,OAAO,UAAU,YAChB,UAAU,QACV,QAAQ,cACR,QAAQ,UACV;AACA;AAAA,MACF;AAEA,UAAI,QAAQ,SAAS;AACnB,cAAM,YAAa,QAAgB,GAAG;AACtC,cAAM,YAAY;AAClB,YAAI,UAAU,CAAC,MAAM,UAAU,CAAC,KAAK,UAAU,CAAC,MAAM,UAAU,CAAC,GAAG;AAClE;AAAA,QACF;AAAA,MACF,WAAW,QAAQ,UAAU;AAC3B,cAAM,aAAc,QAAgB,GAAG;AACvC,cAAM,aAAa;AACnB,YAAI,WAAW,WAAW,WAAW,QAAQ;AAC3C,cAAI,kBAAkB;AACtB,cAAI,QAAQ,WAAW;AACvB,iBAAO,EAAE,OAAO;AACd,kBAAM,YAAY,WAAW,KAAK;AAClC,kBAAM,YAAY,WAAW,KAAK;AAClC,gBACE,UAAU,CAAC,MAAM,UAAU,CAAC,KAC5B,UAAU,CAAC,MAAM,UAAU,CAAC,GAC5B;AACA,gCAAkB;AAClB;AAAA,YACF;AAAA,UACF;AACA,cAAI,CAAC,iBAAiB;AACpB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,MAAC,QAAgB,GAAG,IAAI;AACxB,kBAAY;AAAA,IACd;AAAA,EACF;AAEA,MAAI,CAAC,WAAW;AACd,WAAO;AAAA,EACT;AAEA,MACE,OAAO,QAAQ,WAAW,eAC1B,OAAO,QAAQ,UAAU,eACzB,OAAO,UAAU,eACjB,OAAO,WAAW,aAClB;AACA,eAAW,OAAO,OAAO;AAAA,EAC3B;AAEA,UAAQ,UAAU,QAAQ,WAAW,QAAQ,UAAU;AACvD,UAAQ,eAAe,QAAQ,gBAAgB,cAAc;AAC7D,UAAQ,UAAU,oBAAoB;AAEtC,SAAO;AACT;AAEO,IAAM,iBAAiB,CAC5B,SACA,SAEA,QAAQ,UACK;AACb,MAAI,YAAY;AAChB,aAAW,OAAO,SAAS;AACzB,UAAM,QAAS,QAAgB,GAAG;AAClC,QAAI,OAAO,UAAU,aAAa;AAChC,UACG,QAAgB,GAAG,MAAM;AAAA,OAEzB,OAAO,UAAU,YAAY,UAAU,OACxC;AACA;AAAA,MACF;AACA,kBAAY;AAAA,IACd;AAAA,EACF;AAEA,MAAI,CAAC,aAAa,CAAC,OAAO;AACxB,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,IACH,SAAS,QAAQ,WAAW,QAAQ,UAAU;AAAA,IAC9C,cAAc,QAAQ,gBAAgB,cAAc;AAAA,IACpD,SAAS,oBAAoB;AAAA,EAC/B;AACF;AAOO,IAAM,cAAc,CACzB,SACA,YACG;AACH,UAAQ,WAAW,WAAW,QAAQ,WAAW;AACjD,UAAQ,eAAe,cAAc;AACrC,UAAQ,UAAU,oBAAoB;AACtC,SAAO;AACT;;;AVjGO,IAAM,qCAAqC,CAChD,UACG;AACH,SAAO,CAAC,MAAM,KAAK,WAAW;AAChC;AAEO,IAAM,mBAAmB,CAAC,aAAgC;AAC/D,SAAO,SAAS;AAClB;AAEO,IAAM,yBAAyB;AAC/B,IAAM,8BAA8B;AAE3C,IAAM,wBAAwB,CAC5B,OACA,QACoC;AACpC,QAAM,SAA0C,CAAC;AACjD,MAAI,QAAQ,CAAC,OAAO;AAClB,UAAM,UAAU,MAAM,qBAAqB,EAAE;AAC7C,QAAI,WAAW,MAAM;AACnB,aAAO,KAAK,OAAO;AAAA,IACrB;AAAA,EACF,CAAC;AACD,SAAO;AACT;AAEO,IAAM,4BAA4B,CACvC,eACA,qBACA,mBACA,UACS;AACT,QAAM,cAAc,MAAM,yBAAyB;AACnD,QAAM,oBAA0D,oBAAI,IAAI;AACxE,QAAM,wBAA8D,oBAAI,IAAI;AAC5E;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,cAAc,MAAM,KAAK,qBAAqB,EAAE;AAAA,IACpD,CAAC,OAAO,CAAC,kBAAkB,IAAI,EAAE;AAAA,EACnC;AAEA,wBAAsB,OAAO,WAAW,EAAE,QAAQ,CAAC,YAAY;AAC7D,UAAM,cAAc,SAAS;AAAA,MAC3B,eAAe,QAAQ,eAAe;AAAA,QACpC,CAACC,aACCA,SAAQ,SAAS,WAAWA,SAAQ,OAAO,cAAc;AAAA,MAC7D;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;AAEA,IAAM,gCAAgC,CACpC,eACA,iBACA,0BACA,YAEA,mBAEA,uBACA,OACA,gBACS;AAET,MAAI,oBAAoB,QAAQ;AAC9B;AAAA,EACF;AAGA,MAAI,oBAAoB,MAAM;AAC5B,UAAM,UAAU,oBAAoB,eAAe,YAAY,KAAK;AACpE,QAAI,WAAW,MAAM;AACnB,4BAAsB,IAAI,OAAO;AAAA,IACnC;AACA;AAAA,EACF;AAKA,MAAI,sBAAsB,aAAa,GAAG;AACxC,QACE,4BAA4B,SAC3B,6BAA6B;AAAA;AAAA,MAE1B,CAAC;AAAA,QACC;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,QACA,eAAe,WACf,yBAAyB,OAAO,gBAAgB,KACpD;AACA,wBAAkB,eAAe,iBAAiB,YAAY,KAAK;AACnE,wBAAkB,IAAI,gBAAgB,EAAE;AAAA,IAC1C;AAAA,EACF,OAAO;AACL,sBAAkB,eAAe,iBAAiB,YAAY,KAAK;AACnE,sBAAkB,IAAI,gBAAgB,EAAE;AAAA,EAC1C;AACF;AAEA,IAAM,6CAA6C,CACjD,eACA,aACA,SAEC,CAAC,SAAS,KAAK,EAAY,IAAI,CAAC,SAAS;AACxC,QAAM,QAAQ,0BAA0B,eAAe,MAAM,WAAW;AACxE,QAAM,YACJ,SAAS,UACL,cAAc,cAAc,YAC5B,cAAc,YAAY;AAChC,MAAI,WAAW;AACb,UAAM,UAAU,YAAY,IAAI,SAAS;AACzC,QACE,kBAAkB,OAAO,KACzB,kBAAkB,SAAS,OAAO,aAAa,IAAI,GACnD;AACA,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT,CAAC;AAEH,IAAM,8CAA8C,CAClD,iBACAC,mBACA,gBACA,aACA,UACA,SAC8D;AAC9D,QAAM,WAAW;AACjB,QAAM,SAAS,gBAAgB,OAAO,SAAS;AAC/C,QAAM,eAAe,eAAe,UAAU,CAAC,MAAM,MAAM,QAAQ,IAAI;AACvE,QAAM,aAAa,eAAe,UAAU,CAAC,MAAM,MAAM,MAAM,IAAI;AACnE,QAAM,QAAQ,eACVA,oBACE;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IACA,OACF;AACJ,QAAM,MAAM,aACRA,oBACE;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IACA,OACF;AAEJ,SAAO,CAAC,OAAO,GAAG;AACpB;AAEA,IAAM,6CAA6C,CACjD,iBACA,aACA,UACAA,mBACA,SAC8D;AAE9D,MAAI,aAAa,eAAe,GAAG;AACjC,WAAO,CAAC,QAAQ,MAAM;AAAA,EACxB;AAEA,QAAM,CAAC,cAAc,UAAU,IAAI;AAAA,IACjC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,QAAQ,eACVA,oBACE;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IACA,OACF;AACJ,QAAM,MAAM,aACRA,oBACE;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IACA,OACF;AAEJ,SAAO,CAAC,OAAO,GAAG;AACpB;AAEO,IAAM,6BAA6B,CACxC,kBACAA,mBACA,gBACA,OACA,SACS;AACT,mBAAiB,QAAQ,CAAC,oBAAoB;AAC5C,UAAM,CAAC,OAAO,GAAG,IAAI,gBAAgB;AAAA;AAAA,MAEjC;AAAA,QACE;AAAA,QACAA;AAAA,QACA,kBAAkB,CAAC;AAAA,QACnB,MAAM,yBAAyB;AAAA,QAC/B,MAAM,sBAAsB;AAAA,QAC5B;AAAA,MACF;AAAA;AAAA;AAAA,MAEA;AAAA,QACE;AAAA,QACA,MAAM,yBAAyB;AAAA,QAC/B,MAAM,sBAAsB;AAAA,QAC5BA;AAAA,QACA;AAAA,MACF;AAAA;AAEJ,8BAA0B,iBAAiB,OAAO,KAAK,KAAK;AAAA,EAC9D,CAAC;AACH;AAEO,IAAM,gCAAgC,CAC3C,kBACA,aACA,SACuB;AAEvB,MAAI,iBAAiB,SAAS,IAAI;AAChC,WAAO,CAAC;AAAA,EACV;AAEA,SACE,iBACG,OAAO,eAAe,EACtB;AAAA,IAAQ,CAAC,YACR,2CAA2C,SAAS,aAAa,IAAI;AAAA,EACvE,EACC;AAAA,IACC,CAAC,YACC,YAAY;AAAA,EAChB,EAKC;AAAA,IACC,CAAC,YACC,iBAAiB,OAAO,CAAC,aAAa,SAAS,OAAO,SAAS,EAAE,EAC9D,WAAW;AAAA,EAClB;AAEN;AAEO,IAAM,+CAA+C,CAC1D,eAEA,eAIA,OACA,MAGA,gCAEA,MAAM;AAAA,EACJ,cAAc;AAAA,IACZ,CAAC,KAAiD,WAAW;AAC3D,YAAM,yBAAyB;AAAA,QAC7B;AAAA,QACA,MAAM,sBAAsB;AAAA,QAC5B,MAAM,yBAAyB;AAAA,QAC/B;AAAA,QACA,aAAa,aAAa;AAAA,QAC1B,aAAa,aAAa;AAAA,MAC5B;AAEA,UACE,0BAA0B,QAC1B,CAAC;AAAA,QACC;AAAA,QACA,6BAA6B;AAAA,QAC7B;AAAA,MACF,GACA;AACA,YAAI,IAAI,sBAAsB;AAAA,MAChC;AAEA,aAAO;AAAA,IACT;AAAA,IACA,oBAAI,IAAI;AAAA,EACV;AACF;AAEK,IAAM,yBAAyB,CACpC,eACA,UACA,eACA,UACS;AACT,QAAM,WAAW,MAAM,sBAAsB;AAC7C,QAAM,cAAc,MAAM,yBAAyB;AAEnD,MAAI,SAAS,qBAAqB,MAAM;AACtC;AAAA,MACE;AAAA,MACA,SAAS;AAAA,MACT;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS;AAAA,IACT,aAAa,aAAa;AAAA,IAC1B,aAAa,aAAa;AAAA,EAC5B;AAEA,MAAI,mBAAmB,MAAM;AAC3B,QACE,CAAC;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,IACF,GACA;AACA,wBAAkB,eAAe,gBAAgB,OAAO,KAAK;AAAA,IAC/D;AAAA,EACF;AACF;AAEA,IAAM,wBAAwB,CAC5B,SACA,oBACI;AAAA,EACJ,GAAG;AAAA,EACH,KAAK,KAAK;AAAA,IACR,QAAQ;AAAA,IACR,cAAc,gBAAgB,eAAe,OAAO,eAAe,MAAM;AAAA,EAC3E;AACF;AAEO,IAAM,oBAAoB,CAC/B,eACA,gBACA,YACA,UACS;AACT,MAAI,CAAC,eAAe,aAAa,GAAG;AAClC;AAAA,EACF;AAEA,MAAI,UAA4C;AAAA,IAC9C,WAAW,eAAe;AAAA,IAC1B,GAAG;AAAA,MACD;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM,yBAAyB;AAAA,MACjC;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,MAAI,aAAa,aAAa,GAAG;AAC/B,cAAU;AAAA,MACR,GAAG;AAAA,MACH,GAAG;AAAA,QACD;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM,yBAAyB;AAAA,MACjC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,cAAc,eAAe;AAAA,IACjC,CAAC,eAAe,UAAU,iBAAiB,YAAY,GAAG;AAAA,EAC5D,CAAC;AAED,QAAM,mBAAmBC,YAAW,eAAe,iBAAiB,CAAC,CAAC;AACtE,MAAI,CAAC,iBAAiB,IAAI,cAAc,EAAE,GAAG;AAC3C,UAAM,cAAc,gBAAgB;AAAA,MAClC,gBAAgB,eAAe,iBAAiB,CAAC,GAAG,OAAO;AAAA,QACzD,IAAI,cAAc;AAAA,QAClB,MAAM;AAAA,MACR,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF;AAGA,IAAM,qDAAqD,CACzD,eACA,iBACA,eACY;AACZ,QAAM,eACJ,cAAc,eAAe,UAAU,eAAe,cAAc;AACtE,SAAO;AAAA,IACL;AAAA,IACA,cAAc;AAAA,IACd;AAAA,EACF;AACF;AAEO,IAAM,uCAAuC,CAClD,eACA,kBACA,oBACY;AACZ,SACE,qBAAqB,gBAAgB,MACrC,sBAAsB,aAAa;AAEvC;AAEA,IAAM,wBAAwB,CAC5B,kBACY,cAAc,OAAO,SAAS,KAAK,CAAC,aAAa,aAAa;AAE5E,IAAM,sBAAsB,CAC1B,eACA,YACA,UAC2C;AAC3C,QAAM,QAAQ,eAAe,UAAU,iBAAiB;AACxD,QAAM,UAAU,cAAc,KAAK;AACnC,MAAI,WAAW,MAAM;AACnB,WAAO;AAAA,EACT;AACA,QAAM,cAAc,eAAe,EAAE,CAAC,KAAK,GAAG,KAAK,CAAC;AACpD,SAAO,QAAQ;AACjB;AAEO,IAAM,8BAA8B,CACzC,eAIA,UACA,aACA,MACA,WACA,wBACiD;AACjD,MAAI,qBAAqB;AACvB,QAAI,WAAW;AACf,UAAM,oBAAoB;AAAA,MACxB;AAAA,MACA,CAAC,YACC,kBAAkB,SAAS,KAAK,KAChC;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,SACC,aACC,CAAC;AAAA,UACC;AAAA,QACF;AAAA;AAAA,QAGA,CAAC,mBAAmB,OAAO;AAAA,MAC/B;AAAA,IACJ,EAAE,OAAO,CAAC,YAAY;AACpB,UAAI,UAAU;AACZ,eAAO;AAAA,MACT;AAEA,UAAI,CAAC,4BAA4B,OAAoC,GAAG;AACtE,mBAAW;AAAA,MACb;AAEA,aAAO;AAAA,IACT,CAAC;AAGD,QAAI,CAAC,qBAAqB,kBAAkB,WAAW,GAAG;AACxD,aAAO;AAAA,IACT;AAEA,QAAI,kBAAkB,WAAW,GAAG;AAClC,aAAO,kBAAkB,CAAC;AAAA,IAC5B;AAGA,UAAM,qBAAqB,kBAAkB;AAAA,MAAO,CAAC,YACnD,kBAAkB,SAAS,eAAe,aAAa,MAAM,KAAK;AAAA,IACpE;AACA,QAAI,mBAAmB,WAAW,GAAG;AACnC,aAAO,mBAAmB,CAAC;AAAA,IAC7B;AAGA,WAAO,kBACJ;AAAA,MACC,CAACC,IAAGC,OAAMA,GAAE,SAAS,IAAIA,GAAE,UAAU,KAAKD,GAAE,SAAS,IAAIA,GAAE,UAAU;AAAA,IACvE,EACC,IAAI;AAAA,EACT;AAEA,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA,CAAC,YACC,kBAAkB,SAAS,KAAK,KAChC;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAAA,OAGC,aAAa,CAAC,4BAA4B,OAAO,MAChD,CAAC,mBAAmB,OAAO;AAAA,IAC/B;AAAA,EACJ;AAEA,SAAO;AACT;AAEA,IAAM,iCAAiC,CACrC,UACA,mBACG;AACH,MAAI,aAAa;AAIjB,WAAS,QAAQ,SAAS,SAAS,GAAG,SAAS,GAAG,EAAE,OAAO;AACzD,UAAM,UAAU,SAAS,KAAK;AAC9B,QAAI,QAAQ,WAAW;AACrB;AAAA,IACF;AACA,QAAI,eAAe,OAAO,GAAG;AAC3B,mBAAa;AACb;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,qCAAqC,CACzC,UACA,mBACG;AACH,QAAM,qBAAoD,CAAC;AAI3D,WAAS,QAAQ,SAAS,SAAS,GAAG,SAAS,GAAG,EAAE,OAAO;AACzD,UAAM,UAAU,SAAS,KAAK;AAC9B,QAAI,QAAQ,WAAW;AACrB;AAAA,IACF;AAEA,QAAI,eAAe,OAAO,GAAG;AAC3B,yBAAmB,KAAK,OAAO;AAAA,IACjC;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,uBAAuB,CAC3B,eACA,gBACA,YACA,gBACmC;AACnC,QAAM,YAAY,eAAe,UAAU,KAAK;AAChD,QAAM,iBAAiB,cAAc,KAAK,IAAI,cAAc,OAAO,SAAS;AAC5E,QAAM,qBAAqB,iBAAiB;AAE5C,QAAM,YAAY,oBAAoB;AAAA,IACpC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,gBAAgB,oBAAoB;AAAA,IACxC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AAAA,IACL,OAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACA,KAAK,KAAK,IAAI,GAAG,kBAAkB,gBAAgB,aAAa,SAAS,CAAC;AAAA,EAC5E;AACF;AAIO,IAAM,sBAAsB,CACjC,gBACA,OACA,YAKG;AACH,MAAI,CAAC,kBAAkB,cAAc,GAAG;AACtC;AAAA,EACF;AAEA,QAAM,EAAE,SAAS,sBAAsB,IAAI,WAAW,CAAC;AACvD,QAAM,kCAAkC;AAAA,IACtC;AAAA,EACF;AAEA,MAAI,cAA2B,MAAM,yBAAyB;AAC9D,MAAI,SAAS,iBAAiB;AAC5B,kBAAc,IAAI,IAAI,WAAW;AACjC,YAAQ,gBAAgB,QAAQ,CAAC,YAAY;AAC3C,kBAAY,IAAI,QAAQ,IAAI,OAAO;AAAA,IACrC,CAAC;AAAA,EACH;AAEA,uBAAqB,aAAa,gBAAgB,CAAC,YAAY;AAC7D,QAAI,CAAC,gBAAgB,OAAO,KAAK,QAAQ,WAAW;AAClD;AAAA,IACF;AAGA,QAAI,CAAC,eAAe,SAAS,cAAc,GAAG;AAC5C;AAAA,IACF;AAGA,UAAM,sBAAsB,QAAQ,eAChC,YAAY,IAAI,QAAQ,aAAa,SAAS,IAC9C;AACJ,UAAM,oBAAoB,QAAQ,aAC9B,YAAY,IAAI,QAAQ,WAAW,SAAS,IAC5C;AAEJ,QAAI,cAA6B;AACjC,QAAI,YAA2B;AAC/B,QAAI,uBAAuB,mBAAmB;AAC5C,oBAAc,iBAAiB,qBAAqB,WAAW;AAC/D,kBAAY,iBAAiB,mBAAmB,WAAW;AAAA,IAC7D;AAEA,UAAM,WAAW;AAAA,MACf,cAAc;AAAA,QACZ;AAAA,QACA,QAAQ;AAAA,QACR;AAAA,MACF;AAAA,MACA,YAAY;AAAA,QACV;AAAA,QACA,QAAQ;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAGA,QAAI,gCAAgC,IAAI,QAAQ,EAAE,GAAG;AACnD,YAAM,cAAc,SAAS,QAAQ;AACrC;AAAA,IACF;AAEA,UAAM,UAAU;AAAA,MACd;AAAA,MACA;AAAA,MACA,CAAC,iBAAiB,gBAAgB;AAChC,YACE,mBACA,kBAAkB,eAAe,MAChC,gBAAgB,kBAAkB,gBAAgB,kBAClD,eAAe,OAAO,QAAQ,WAAW,GAAG,aAC1C,eAAe,OACd,QACE,gBAAgB,iBAAiB,eAAe,cAClD,GAAG,aACH,CAAC,kBAAkB,aAAa,SAAS,IAC7C;AACA,gBAAM,QAAQ;AAAA,YACZ;AAAA,YACA;AAAA,YACA,SAAS,WAAW;AAAA,YACpB;AAAA,YACA;AAAA,UACF;AAEA,cAAI,OAAO;AACT,mBAAO;AAAA,cACL,gBAAgB,iBAAiB,IAAI,QAAQ,OAAO,SAAS;AAAA,cAC7D,EAAE,MAAM;AAAA,YACV;AAAA,UACF;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA,IACF,EAAE;AAAA,MACA,CAAC,WAAsD,WAAW;AAAA,IACpE;AAEA,wBAAoB,WAAW,SAAS,OAAO,IAAI,IAAI,OAAO,GAAG;AAAA,MAC/D,GAAI,eAAe,OAAO,QAAQ,cAAc,YAC5C,EAAE,cAAc,SAAS,aAAa,IACtC,CAAC;AAAA,MACL,GAAI,eAAe,OAAO,QAAQ,YAAY,YAC1C,EAAE,YAAY,SAAS,WAAW,IAClC,CAAC;AAAA,IACP,CAAC;AAED,UAAM,YAAY,oBAAoB,SAAS,WAAW;AAC1D,QAAI,aAAa,CAAC,UAAU,WAAW;AACrC,2BAAqB,SAAS,OAAO,KAAK;AAAA,IAC5C;AAAA,EACF,CAAC;AACH;AAEO,IAAM,iBAAiB,CAC5B,eACA,OACA,YAKG;AACH,MAAI,gBAAgB,aAAa,GAAG;AAClC,+BAA2B,CAAC,aAAa,GAAG,MAAM,CAAC,GAAG,OAAO,SAAS,IAAI;AAAA,EAC5E,OAAO;AACL,wBAAoB,eAAe,OAAO;AAAA,MACxC,GAAG;AAAA,MACH,iBAAiB,oBAAI,IAAI,CAAC,CAAC,cAAc,IAAI,aAAa,CAAC,CAAC;AAAA,IAC9D,CAAC;AAAA,EACH;AACF;AAEA,IAAM,iBAAiB,CACrB,cACA,mBACG;AACH,SACE,aAAa,cAAc,cAAc,eAAe,MACxD,aAAa,YAAY,cAAc,eAAe;AAE1D;AAEA,IAAM,qCAAqC,CACzC,0BACiC;AACjC,SAAO,IAAI,KAAK,yBAAyB,CAAC,GAAG,IAAI,CAAC,YAAY,QAAQ,EAAE,CAAC;AAC3E;AAEO,IAAM,8BAA8B,CACzC,GACA,YACA,iBACA,MACA,WACA,aACA,SACY;AACZ,QAAM,oBAAoB,gBAAgBE,iBAAgB,YAAY,CAAC,CAAC;AAExE,MAAI,CAAC,mBAAmB,CAAC,MAAM;AAC7B,WAAO;AAAA,EACT;AAEA,QAAMC,YAAW;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,CAACA,WAAU;AACb,WAAO;AAAA,MACLD,iBAAgB,GAAG,mBAAmB,iBAAiB,WAAW,CAAC;AAAA,IACrE;AAAA,EACF;AAEA,SAAO,2BAA2B,iBAAiB,MAAM,CAAC;AAC5D;AAEA,IAAM,wBAAwB,CAC5B,OACA,iBACA,aACA,SACG;AACH,QAAMC,YAAW,kBAAkB,iBAAiB,aAAa,KAAK;AACtE,QAAM,eAAe;AAAA,IACnB;AAAA,IACA,gBAAgB;AAAA,IAChB,gBAAgB;AAAA,IAChB;AAAA,EACF;AAEA,SAAOA,YAAW,eAAe,OAAOA;AAC1C;AAEO,IAAM,kCAAkC,CAC7C,OACA,iBACA,YACA,gBACgB;AAChB,MAAIC,UAAS,KAAKC,WAAU,GAAG;AAC7B,IAAAC,WAAU,MAAM,OAAO,SAAS,GAAG,qCAAqC;AAAA,EAC1E;AAEA,QAAM,OAAO,eAAe,iBAAiB,WAAW;AACxD,QAAM,SACJ,MAAM,OAAO,eAAe,UAAU,IAAI,MAAM,OAAO,SAAS,CAAC;AACnE,QAAM,UAAUC;AAAA,IACd,MAAM,IAAI,OAAO,CAAC;AAAA,IAClB,MAAM,IAAI,OAAO,CAAC;AAAA,EACpB;AACA,QAAM,YAAY,sBAAsB,eAAe,IACnD,uBAAuB,iBAAiB,aAAa,OAAO,IAC5D;AACJ,QAAM,UAAU,aAAa,KAAK;AAClC,QAAM,SAAS,mBAAmB,IAAI;AACtC,QAAM,mBAAmB,eAAe,UAAU,IAAI,MAAM,OAAO,SAAS;AAC5E,QAAM,gBAAgBC;AAAA,IACpBD;AAAA,MACE,MAAM,IAAI,MAAM,OAAO,gBAAgB,EAAE,CAAC;AAAA,MAC1C,MAAM,IAAI,MAAM,OAAO,gBAAgB,EAAE,CAAC;AAAA,IAC5C;AAAA,IACA;AAAA,IACA,MAAM,SAAS;AAAA,EACjB;AAEA,MAAI,eAAmC;AACvC,MAAI,SAAS;AACX,UAAM,eAAe;AAAA,MACnB,2BAA2B,iBAAiB,MAAM,OAAO;AAAA,IAC3D;AACA,UAAM,YAAY,UAAU,iBAAiB,aAAa,SAAS;AACnE,UAAM,aAAaA;AAAA,MACjB,eAAe,OAAO,CAAC,IAAI,UAAU,CAAC;AAAA,MACtC,CAAC,eAAe,OAAO,CAAC,IAAI,UAAU,CAAC;AAAA,IACzC;AACA,UAAM,cAAcE;AAAA,MAClB;AAAA,MACAC;AAAA,QACEC;AAAA,UACEC,iBAAgBV,iBAAgB,WAAW,UAAU,CAAC;AAAA,UACtD,KAAK,IAAI,gBAAgB,OAAO,gBAAgB,MAAM,IAAI;AAAA,QAC5D;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,mBAAe;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAE,KAAK,eAAe,EAAE,CAAC;AAAA,EAC3B,OAAO;AACL,mBAAe;AAAA,MACb;AAAA,MACA;AAAA,MACAO;AAAA,QACE;AAAA,QACAC;AAAA,UACEC;AAAA,YACEC,iBAAgBV,iBAAgB,WAAW,aAAa,CAAC;AAAA,YACzDW,eAAc,WAAW,aAAa,IACpC,KAAK,IAAI,gBAAgB,OAAO,gBAAgB,MAAM,IAAI;AAAA,UAC9D;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,MACA;AAAA,IACF,EAAE;AAAA,MACA,CAAC,GAAG,MACF,gBAAgB,GAAG,aAAa,IAAI,gBAAgB,GAAG,aAAa;AAAA,IACxE,EAAE,CAAC;AAAA,EACL;AAEA,MACE,CAAC;AAAA,EAED,gBAAgB,WAAW,YAAY,IAAIC,YAC3C;AACA,WAAO;AAAA,EACT;AAEA,SAAO,UAAU,eAAe;AAClC;AAEO,IAAM,yBAAyB,CACpC,SACA,aACA,MACgB;AAChB,QAAM,SAAS,mBAAmB,SAAS,WAAW;AACtD,QAAM,kBAAkBN,iBAAgB,GAAG,QAAQ,CAAC,QAAQ,KAAgB;AAE5E,MAAI,gBAAgB,CAAC,IAAI,QAAQ,KAAK,gBAAgB,CAAC,IAAI,QAAQ,GAAG;AAEpE,QAAI,gBAAgB,CAAC,IAAI,QAAQ,IAAI,CAAC,wBAAwB;AAC5D,aAAOA;AAAA,QACLD,WAAU,QAAQ,IAAI,wBAAwB,QAAQ,CAAC;AAAA,QACvD;AAAA,QACA,QAAQ;AAAA,MACV;AAAA,IACF;AACA,WAAOC;AAAA,MACLD,WAAU,QAAQ,GAAG,QAAQ,IAAI,sBAAsB;AAAA,MACvD;AAAA,MACA,QAAQ;AAAA,IACV;AAAA,EACF,WACE,gBAAgB,CAAC,IAAI,QAAQ,KAC7B,gBAAgB,CAAC,IAAI,QAAQ,IAAI,QAAQ,QACzC;AAEA,QAAI,gBAAgB,CAAC,IAAI,QAAQ,IAAI,CAAC,wBAAwB;AAC5D,aAAOC;AAAA,QACLD;AAAA,UACE,QAAQ;AAAA,UACR,QAAQ,IAAI,QAAQ,SAAS;AAAA,QAC/B;AAAA,QACA;AAAA,QACA,QAAQ;AAAA,MACV;AAAA,IACF;AACA,WAAOC;AAAA,MACLD,WAAU,QAAQ,IAAI,wBAAwB,QAAQ,IAAI,QAAQ,MAAM;AAAA,MACxE;AAAA,MACA,QAAQ;AAAA,IACV;AAAA,EACF,WACE,gBAAgB,CAAC,IAAI,QAAQ,IAAI,QAAQ,SACzC,gBAAgB,CAAC,IAAI,QAAQ,IAAI,QAAQ,QACzC;AAEA,QACE,gBAAgB,CAAC,IAAI,QAAQ,IAC7B,QAAQ,QAAQ,wBAChB;AACA,aAAOC;AAAA,QACLD;AAAA,UACE,QAAQ,IAAI,QAAQ;AAAA,UACpB,QAAQ,IAAI,QAAQ,SAAS;AAAA,QAC/B;AAAA,QACA;AAAA,QACA,QAAQ;AAAA,MACV;AAAA,IACF;AACA,WAAOC;AAAA,MACLD;AAAA,QACE,QAAQ,IAAI,QAAQ,QAAQ;AAAA,QAC5B,QAAQ,IAAI,QAAQ;AAAA,MACtB;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,IACV;AAAA,EACF,WACE,gBAAgB,CAAC,IAAI,QAAQ,IAAI,QAAQ,SACzC,gBAAgB,CAAC,IAAI,QAAQ,GAC7B;AAEA,QACE,gBAAgB,CAAC,IAAI,QAAQ,IAC7B,QAAQ,QAAQ,wBAChB;AACA,aAAOC;AAAA,QACLD;AAAA,UACE,QAAQ,IAAI,QAAQ;AAAA,UACpB,QAAQ,IAAI;AAAA,QACd;AAAA,QACA;AAAA,QACA,QAAQ;AAAA,MACV;AAAA,IACF;AACA,WAAOC;AAAA,MACLD,WAAU,QAAQ,IAAI,QAAQ,QAAQ,wBAAwB,QAAQ,CAAC;AAAA,MACvE;AAAA,MACA,QAAQ;AAAA,IACV;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,YAAY,CACvB,SACA,aACA,GACA,YAAoB,SACJ;AAChB,QAAM,EAAE,GAAG,GAAG,OAAO,QAAQ,MAAM,IAAI;AACvC,QAAM,SAAS,mBAAmB,SAAS,aAAa,MAAM,IAAI;AAClE,QAAM,aAAaC,iBAAgB,GAAG,QAAQ,CAAC,KAAgB;AAI/D,QAAM,oBAAoBO,OAAM,YAAY,QAAQ,GAAG,EAAE;AACzD,QAAM,sBAAsBA,OAAM,YAAY,OAAO,GAAG,EAAE;AAE1D,MACE,WAAW,CAAC,KAAK,IAAI,QAAQ,KAC7B,WAAW,CAAC,IAAI,OAAO,CAAC,IAAI,qBAC5B,WAAW,CAAC,IAAI,OAAO,CAAC,IAAI,mBAC5B;AAEA,WAAOP;AAAA,MACLD,WAAU,IAAI,wBAAwB,OAAO,CAAC,CAAC;AAAA,MAC/C;AAAA,MACA;AAAA,IACF;AAAA,EACF,WACE,WAAW,CAAC,KAAK,IAAI,SAAS,KAC9B,WAAW,CAAC,IAAI,OAAO,CAAC,IAAI,uBAC5B,WAAW,CAAC,IAAI,OAAO,CAAC,IAAI,qBAC5B;AAEA,WAAOC;AAAA,MACLD,WAAU,OAAO,CAAC,GAAG,IAAI,sBAAsB;AAAA,MAC/C;AAAA,MACA;AAAA,IACF;AAAA,EACF,WACE,WAAW,CAAC,KAAK,IAAI,QAAQ,KAC7B,WAAW,CAAC,IAAI,OAAO,CAAC,IAAI,qBAC5B,WAAW,CAAC,IAAI,OAAO,CAAC,IAAI,mBAC5B;AAEA,WAAOC;AAAA,MACLD,WAAU,IAAI,QAAQ,wBAAwB,OAAO,CAAC,CAAC;AAAA,MACvD;AAAA,MACA;AAAA,IACF;AAAA,EACF,WACE,WAAW,CAAC,KAAK,IAAI,SAAS,KAC9B,WAAW,CAAC,IAAI,OAAO,CAAC,IAAI,uBAC5B,WAAW,CAAC,IAAI,OAAO,CAAC,IAAI,qBAC5B;AAEA,WAAOC;AAAA,MACLD,WAAU,OAAO,CAAC,GAAG,IAAI,SAAS,sBAAsB;AAAA,MACxD;AAAA,MACA;AAAA,IACF;AAAA,EACF,WAAW,QAAQ,SAAS,WAAW;AACrC,UAAMJ,YAAW;AACjB,UAAM,UAAUI;AAAA,MACd,IAAI,QAAQ,IAAIJ;AAAA,MAChB,IAAI,SAAS,IAAIA;AAAA,IACnB;AACA,UAAM,WAAWI;AAAA,MACf,IAAK,IAAI,QAAS,IAAIJ;AAAA,MACtB,IAAI,SAAS,IAAIA;AAAA,IACnB;AACA,UAAM,aAAaI;AAAA,MACjB,IAAI,QAAQ,IAAIJ;AAAA,MAChB,IAAK,IAAI,SAAU,IAAIA;AAAA,IACzB;AACA,UAAM,cAAcI;AAAA,MAClB,IAAK,IAAI,QAAS,IAAIJ;AAAA,MACtB,IAAK,IAAI,SAAU,IAAIA;AAAA,IACzB;AAEA,QACEU,eAAc,SAAS,UAAU,IACjC,KAAK,IAAI,qBAAqB,iBAAiB,GAC/C;AACA,aAAOL,iBAAgB,SAAS,QAAQ,KAAK;AAAA,IAC/C;AACA,QACEK,eAAc,UAAU,UAAU,IAClC,KAAK,IAAI,qBAAqB,iBAAiB,GAC/C;AACA,aAAOL,iBAAgB,UAAU,QAAQ,KAAK;AAAA,IAChD;AACA,QACEK,eAAc,YAAY,UAAU,IACpC,KAAK,IAAI,qBAAqB,iBAAiB,GAC/C;AACA,aAAOL,iBAAgB,YAAY,QAAQ,KAAK;AAAA,IAClD;AACA,QACEK,eAAc,aAAa,UAAU,IACrC,KAAK,IAAI,qBAAqB,iBAAiB,GAC/C;AACA,aAAOL,iBAAgB,aAAa,QAAQ,KAAK;AAAA,IACnD;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,mBAAmB,CACvB,eACA,YACA,SACA,iBACA,gBACsB;AACtB,MACE,WAAW;AAAA,EAEV,QAAQ,cAAc,gBAAgB,MACrC,cAAc,OAAO,SAAS,GAChC;AACA,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,eAAe,iBAAiB,KAAK;AACvD,QAAM,iBAAiB,cAAc,KAAK,IAAI,cAAc,OAAO,SAAS;AAE5E,MAAI,aAAa,aAAa,KAAK,oBAAoB,OAAO,GAAG;AAC/D,UAAM,aACJ,oBAAoB,QAAQ,UAAU,KACtC;AAAA,MACE;AAAA,MACA;AAAA,MACA,eAAe,iBAAiB,UAAU;AAAA,MAC1C;AAAA,IACF,EAAE;AACJ,UAAM,iBAAiB,mBAAmB,iBAAiB,WAAW;AACtE,UAAMQ,UAAST;AAAA,MACb,gBAAgB,IAAI,WAAW,CAAC,IAAI,gBAAgB;AAAA,MACpD,gBAAgB,IAAI,WAAW,CAAC,IAAI,gBAAgB;AAAA,IACtD;AACA,UAAM,gBAAgBC;AAAA,MACpBQ;AAAA,MACA;AAAA,MACA,gBAAgB;AAAA,IAClB;AAEA,WAAO,oBAAoB;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,qBAAqB,iBAAiB;AAC5C,QAAM,gBAAgB,oBAAoB;AAAA,IACxC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,qBAAqB;AAAA,IACzB;AAAA,IACA;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,EACF;AAEA,MAAI;AAIJ,MAAI,QAAQ,QAAQ,GAAG;AACrB,mBAAe;AAAA,EACjB,OAAO;AACL,UAAM,oBACJ,oBAAoB;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEF,UAAM,SAAS,mBAAmB,iBAAiB,WAAW;AAC9D,UAAM,oBACJH,eAAc,eAAe,iBAAiB,IAC9CA,eAAc,eAAe,MAAM,IACnC,KAAK,IAAI,gBAAgB,OAAO,gBAAgB,MAAM,IAAI;AAC5D,UAAM,gBAAgB;AAAA,MACpB,GAAG;AAAA,QACD;AAAA,QACA;AAAA,QACAJ;AAAA,UACE;AAAA,UACAC;AAAA,YACEC;AAAA,cACEC;AAAA,gBACEV,iBAAgB,oBAAoB,aAAa;AAAA,cACnD;AAAA,cACA;AAAA,YACF;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,QACA,QAAQ;AAAA,MACV,EAAE;AAAA,QACA,CAAC,GAAG,MACF,gBAAgB,GAAG,aAAa,IAAI,gBAAgB,GAAG,aAAa;AAAA,MACxE;AAAA;AAAA,MAEAQ;AAAA,QACEC;AAAA,UACEC,iBAAgBV,iBAAgB,oBAAoB,aAAa,CAAC;AAAA,UAClEW,eAAc,eAAe,iBAAiB;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,QAAI,cAAc,SAAS,GAAG;AAE5B,qBAAe,cAAc,CAAC;AAAA,IAChC,WAAW,cAAc,WAAW,GAAG;AAErC,qBAAe;AAAA,IACjB,OAAO;AAEL,qBAAe;AAAA,IACjB;AAAA,EACF;AAEA,SAAO,oBAAoB;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,0CAA0C,CACrD,eACA,gBACA,YACA,gBAC+B;AAC/B,QAAM,SAAS;AAAA,IACb,eAAe;AAAA,IACf,eAAe;AAAA,IACf,eAAe,IAAI,eAAe;AAAA,IAClC,eAAe,IAAI,eAAe;AAAA,EACpC;AACA,QAAM,eAAe;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,iBAAiBN;AAAA,IACrB,OAAO,CAAC,KAAK,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK;AAAA,IACtC,OAAO,CAAC,KAAK,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK;AAAA,EACxC;AACA,QAAM,+BAA+BC;AAAA,IACnC;AAAA,IACA;AAAA,IACA,CAAC,eAAe;AAAA,EAClB;AAEA,SAAO;AAAA,IACL,YAAY,oBAAoB;AAAA,OAC7B,6BAA6B,CAAC,IAAI,eAAe,KAChD,eAAe;AAAA,OAChB,6BAA6B,CAAC,IAAI,eAAe,KAChD,eAAe;AAAA,IACnB,CAAC;AAAA,EACH;AACF;AAEA,IAAM,kCAAkC,CACtC,gBACA,gBACA,YACoC;AACpC,MAAI,kBAAkB,QAAQ,WAAW,MAAM;AAC7C,WAAO;AAAA,EACT;AACA,QAAM,EAAE,OAAO,UAAU,QAAQ,UAAU,IAAI;AAC/C,QAAM,EAAE,OAAO,OAAO,IAAI;AAC1B,QAAM,SAAS,KAAK;AAAA,IAClB;AAAA,IACA,KAAK;AAAA,MACH,cAAc,gBAAgB,UAAU,SAAS;AAAA,MACjD,eAAe,OACZ,WAAW,YAAY,WAAW,QAAQ,YAAY;AAAA,IAC3D;AAAA,EACF;AAEA,SAAO,EAAE,GAAG,gBAAgB,KAAK,OAAO;AAC1C;AAEA,IAAM,sCAAsC,CAC1C,eACA,YACA,aACA,UACA,SACiD;AACjD,SAAO;AAAA,IACL,0BAA0B,eAAe,YAAY,WAAW;AAAA,IAChE;AAAA,IACA;AAAA,IACA;AAAA,IACA,aAAa,aAAa;AAAA,IAC1B,aAAa,aAAa;AAAA,EAC5B;AACF;AAEA,IAAM,4BAA4B,CAChC,eACA,YACA,gBAC6B;AAC7B,QAAM,QAAQ,eAAe,UAAU,IAAI;AAC3C,SAAOS;AAAA,IACL,oBAAoB;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,wCAAwC,CACnD,oBACA,qBACA,yBACG;AACH,aAAWC,qBAAoB,oBAAoB;AACjD,QAAI,mBAAmBA,qBAAoBA,kBAAiB,eAAe;AACzE,aAAO,OAAOA,mBAAkB;AAAA,QAC9B,eAAeA,kBAAiB,cAAc;AAAA,UAC5C,CACE,KACA,YACG;AACH,kBAAM,eAAe,oBAAoB,IAAI,QAAQ,EAAE;AACvD,gBAAI,cAAc;AAChB,kBAAI,KAAK,EAAE,GAAG,SAAS,IAAI,aAAa,CAAC;AAAA,YAC3C;AACA,mBAAO;AAAA,UACT;AAAA,UACA,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH;AAEA,QAAI,iBAAiBA,qBAAoBA,kBAAiB,aAAa;AACrE,aAAO,OAAOA,mBAAkB;AAAA,QAC9B,aACE,oBAAoB,IAAIA,kBAAiB,WAAW,KAAK;AAAA,MAC7D,CAAC;AAAA,IACH;AAEA,QAAI,gBAAgBA,qBAAoBA,kBAAiB,YAAY;AACnE,YAAM,kBAAkB,oBAAoB;AAAA,QAC1CA,kBAAiB,WAAW;AAAA,MAC9B;AACA,aAAO,OAAOA,mBAAkB;AAAA,QAC9B,YAAY,kBACR;AAAA,UACE,GAAGA,kBAAiB;AAAA,UACpB,WAAW;AAAA,QACb,IACA;AAAA,MACN,CAAC;AAAA,IACH;AACA,QAAI,kBAAkBA,qBAAoBA,kBAAiB,cAAc;AACvE,YAAM,kBAAkB,oBAAoB;AAAA,QAC1CA,kBAAiB,aAAa;AAAA,MAChC;AACA,aAAO,OAAOA,mBAAkB;AAAA,QAC9B,cAAc,kBACV;AAAA,UACE,GAAGA,kBAAiB;AAAA,UACpB,WAAW;AAAA,QACb,IACA;AAAA,MACN,CAAC;AAAA,IACH;AAEA,QAAI,aAAaA,iBAAgB,GAAG;AAClC,aAAO;AAAA,QACLA;AAAA,QACA,uBAAuBA,mBAAkB,sBAAsB;AAAA,UAC7D,QAAQ;AAAA,YACNA,kBAAiB,OAAO,CAAC;AAAA,YACzBA,kBAAiB,OAAOA,kBAAiB,OAAO,SAAS,CAAC;AAAA,UAC5D;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,2BAA2B,CACtC,eACA,oBACS;AACT,QAAM,WAAWnB,YAAW,aAAa;AAEzC,aAAW,WAAW,iBAAiB;AACrC,iBAAa;AAAA,MAAe;AAAA,MAAU;AAAA,MAAS,CAACF,UAAS,YACvD,cAAcA,UAAS,UAAU,OAAO;AAAA,IAC1C;AACA,oBAAgB;AAAA,MAAe;AAAA,MAAU;AAAA,MAAS,CAACA,UAAS,YAC1D,cAAcA,UAAS,UAAU,OAAO;AAAA,IAC1C;AAAA,EACF;AACF;AAEA,IAAM,mBAAmB,CACvB,eACA,aACA,gBAA0C,CAAC,MACxC;AACH,MAAI,CAAC,eAAe;AAClB,WAAO;AAAA,EACT;AAEA,QAAM,oBAAoB,cAAc;AAAA,IACtC,CAAC,iBAAiB,CAAC,YAAY,IAAI,aAAa,EAAE;AAAA,EACpD;AAEA,oBAAkB;AAAA,IAChB,GAAG,cAAc;AAAA,MACf,CAAC,OACE,EAAE,IAAI,EAAE,IAAI,MAAM,EAAE,KAAK;AAAA,IAG9B;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,oBAAoB,CAC/B,SACA,EAAE,GAAG,EAAE,GACP,aACA,MACA,cACY;AACZ,QAAM,IAAIU,WAAuB,GAAG,CAAC;AACrC,QAAM,YAAY,cAAc,SAAS,QAAQ,OAAO,QAAQ,QAAQ,IAAI;AAC5E,QAAMY;AAAA;AAAA;AAAA,KAGH,aAAa,CAAC,4BAA4B,OAAO,MAClD,CAAC,mBAAmB,OAAO;AAAA;AAI7B,QAAM,SAAS;AAAA,IACb,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA,EACN;AACA,QAAM,gBAAgB,iBAAiB,SAAS,WAAW;AAC3D,MAAI,CAAC,kBAAkB,QAAQ,aAAa,GAAG;AAC7C,WAAO;AAAA,EACT;AAGA,QAAM,gBAAgB;AAAA,IACpB;AAAA,IACA;AAAA,IACAV,aAAY,mBAAmB,SAAS,WAAW,GAAG,CAAC;AAAA,EACzD;AACA,QAAMN,YAAW,kBAAkB,SAAS,aAAa,CAAC;AAE1D,SAAOgB,oBACH,cAAc,WAAW,KAAKhB,aAAY,YAC1C,cAAc,SAAS,KAAKA,aAAY;AAC9C;AAEO,IAAM,gBAAgB,CAC3B,SACA,cACA,eACA,SACW;AACX,QAAM,YAAY,MAAM,SAAS,KAAK,QAAQ,IAAI,KAAK,QAAQ;AAG/D,QAAM,aAAa,QAAQ,SAAS,YAAY,IAAI,KAAK,KAAK,CAAC,IAAI;AACnE,QAAM,mBAAmB,aAAa,KAAK,IAAI,cAAc,aAAa;AAE1E,SAAO,KAAK;AAAA,IACV;AAAA;AAAA,IAEA,KAAK,IAAI,OAAO,kBAAkB,EAAE;AAAA;AAAA,IAEpC,8BAA8B,YAAY;AAAA,EAC5C;AACF;AAOA,IAAM,yBAAyB,CAC7B,SACA,aAEAH,IAEAC,OACW;AACX,QAAM,SAAS,mBAAmB,SAAS,WAAW;AAEtD,MAAImB,aAAYpB,IAAGC,EAAC,GAAG;AACrB,WAAO;AAAA,EACT;AAEA,QAAM,WAAWO,iBAAgBR,IAAG,QAAQ,CAAC,QAAQ,KAAgB;AACrE,QAAM,WAAWQ,iBAAgBP,IAAG,QAAQ,CAAC,QAAQ,KAAgB;AACrE,QAAM,OACJ,KAAK;AAAA,IACHoB;AAAA,MACEnB,iBAAgB,UAAUF,EAAC;AAAA,MAC3BE,iBAAgB,UAAU,MAAM;AAAA,IAClC;AAAA,EACF,IAAI;AACN,QAAM,qBAAqBO;AAAA,IACzB;AAAA,IACAC;AAAA,MACEC;AAAA,QACEC,iBAAgBV,iBAAgB,UAAU,QAAQ,CAAC;AAAA,QACnD,KAAK,IAAI,QAAQ,QAAQ,GAAG,QAAQ,SAAS,CAAC;AAAA,MAChD;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,QAAM,OACJ,QAAQ,SAAS,YACb;AAAA,IACEO;AAAA,MACEF,WAAuB,QAAQ,IAAI,QAAQ,QAAQ,GAAG,QAAQ,CAAC;AAAA,MAC/DA;AAAA,QACE,QAAQ,IAAI,QAAQ,QAAQ;AAAA,QAC5B,QAAQ,IAAI,QAAQ;AAAA,MACtB;AAAA,IACF;AAAA,IACAE;AAAA,MACEF,WAAuB,QAAQ,GAAG,QAAQ,IAAI,QAAQ,SAAS,CAAC;AAAA,MAChEA;AAAA,QACE,QAAQ,IAAI,QAAQ;AAAA,QACpB,QAAQ,IAAI,QAAQ,SAAS;AAAA,MAC/B;AAAA,IACF;AAAA,EACF,IACA;AAAA,IACEE;AAAA,MACEF,WAAuB,QAAQ,GAAG,QAAQ,CAAC;AAAA,MAC3CA;AAAA,QACE,QAAQ,IAAI,QAAQ;AAAA,QACpB,QAAQ,IAAI,QAAQ;AAAA,MACtB;AAAA,IACF;AAAA,IACAE;AAAA,MACEF,WAAuB,QAAQ,IAAI,QAAQ,OAAO,QAAQ,CAAC;AAAA,MAC3DA,WAAuB,QAAQ,GAAG,QAAQ,IAAI,QAAQ,MAAM;AAAA,IAC9D;AAAA,EACF;AACN,QAAM,eACJ,QAAQ,SAAS,YACb;AAAA,IACEE;AAAA,MACEF;AAAA,QACE,QAAQ,IAAI,QAAQ,QAAQ;AAAA,QAC5B,QAAQ,IAAI,QAAQ;AAAA,MACtB;AAAA,MACAA;AAAA,QACE,QAAQ,IAAI,QAAQ,QAAQ;AAAA,QAC5B,QAAQ,IAAI,QAAQ,SAAS;AAAA,MAC/B;AAAA,IACF;AAAA,IACAE;AAAA,MACEF;AAAA,QACE,QAAQ,IAAI,QAAQ;AAAA,QACpB,QAAQ,IAAI,QAAQ,SAAS;AAAA,MAC/B;AAAA,MACAA;AAAA,QACE,QAAQ,IAAI,QAAQ,QAAQ;AAAA,QAC5B,QAAQ,IAAI,QAAQ,SAAS;AAAA,MAC/B;AAAA,IACF;AAAA,EACF,IACA;AAAA,IACEE;AAAA,MACEF;AAAA,QACE,QAAQ,IAAI,QAAQ;AAAA,QACpB,QAAQ,IAAI,QAAQ;AAAA,MACtB;AAAA,MACAA;AAAA,QACE,QAAQ,IAAI,QAAQ,QAAQ;AAAA,QAC5B,QAAQ,IAAI,QAAQ,SAAS;AAAA,MAC/B;AAAA,IACF;AAAA,IACAE;AAAA,MACEF;AAAA,QACE,QAAQ,IAAI,QAAQ,QAAQ;AAAA,QAC5B,QAAQ,IAAI,QAAQ;AAAA,MACtB;AAAA,MACAA;AAAA,QACE,QAAQ,IAAI,QAAQ;AAAA,QACpB,QAAQ,IAAI,QAAQ,SAAS;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAEN,QAAM,UAAU;AAAA,IACde,+BAA8B,oBAAoB,aAAa,CAAC,CAAC;AAAA,IACjEA,+BAA8B,oBAAoB,aAAa,CAAC,CAAC;AAAA,EACnE,EACG,OAAO,CAAC,MAAwB,MAAM,IAAI,EAC1C,KAAK,CAAC,GAAG,MAAM,gBAAgB,GAAGrB,EAAC,IAAI,gBAAgB,GAAGA,EAAC,CAAC,EAC5D;AAAA,IACC,CAAC,GAAG,QACD,OAAOY,eAAc,QAAQ,CAAC,KAC9B,QAAQ,SAAS,YACdA,eAAc,KAAK,GAAG,EAAE,CAAC,GAAG,KAAK,GAAG,EAAE,CAAC,CAAC,IAAI,IAC5C,KAAK,KAAK,QAAQ,SAAS,IAAI,QAAQ,UAAU,CAAC,IAAI;AAAA,EAC9D,EACC,KAAK,CAAC,GAAG,MAAM,KAAK,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;AAE3C,QAAM,sBAAsB,QAAQ,CAAC,KAAK;AAE1C,SAAO;AACT;AAEA,IAAM,sBAAsB,CAC1B,SACA,aAGA,OACA,kBACgB;AAChB,QAAM,SAAS,mBAAmB,SAAS,WAAW;AAEtD,MAAI,UAAU,GAAG;AACf,WAAO;AAAA,EACT;AAEA,QAAM,cACJ,QAAQ,SAAS,YACb;AAAA,IACEN,WAAuB,QAAQ,GAAG,QAAQ,IAAI,QAAQ,SAAS,CAAC;AAAA,IAChEA,WAAuB,QAAQ,IAAI,QAAQ,QAAQ,GAAG,QAAQ,CAAC;AAAA,IAC/DA;AAAA,MACE,QAAQ,IAAI,QAAQ;AAAA,MACpB,QAAQ,IAAI,QAAQ,SAAS;AAAA,IAC/B;AAAA,IACAA;AAAA,MACE,QAAQ,IAAI,QAAQ,QAAQ;AAAA,MAC5B,QAAQ,IAAI,QAAQ;AAAA,IACtB;AAAA,EACF,IACA;AAAA,IACEA,WAAuB,QAAQ,GAAG,QAAQ,CAAC;AAAA,IAC3CA,WAAuB,QAAQ,IAAI,QAAQ,OAAO,QAAQ,CAAC;AAAA,IAC3DA;AAAA,MACE,QAAQ,IAAI,QAAQ;AAAA,MACpB,QAAQ,IAAI,QAAQ;AAAA,IACtB;AAAA,IACAA,WAAuB,QAAQ,GAAG,QAAQ,IAAI,QAAQ,MAAM;AAAA,EAC9D,GAEH;AAAA,IAAI,CAAC,MACJG;AAAA,MACEC,aAAYT,iBAAgB,GAAG,MAAM,GAAG,KAAK,IAAI,KAAK,CAAC;AAAA,MACvD;AAAA,IACF;AAAA,EACF,EACC,IAAI,CAAC,MAAMM,iBAAgB,GAAG,QAAQ,QAAQ,KAAgB,CAAC;AAElE,QAAM,WAAW;AAAA,IACfa;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI;AAAA,KACD,QAAQ,IACLmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI,IACJmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI;AAAA,IACVmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI;AAAA,KACD,QAAQ,IACLmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI,IACJmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI;AAAA,IACVmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI;AAAA,KACD,QAAQ,IACLmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI,IACJmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI;AAAA,IACVmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI;AAAA,KACD,QAAQ,IACLmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI,IACJmB;AAAA,MACEnB,iBAAgB,eAAe,WAAW,CAAC,CAAC;AAAA,MAC5CA,iBAAgB,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC9C,IAAI;AAAA,EACZ;AAEA,QAAM,aAAa,SAAS,CAAC,IACzB,QAAQ,IACN,WAAW,CAAC,IACZ,WAAW,CAAC,IACd,SAAS,CAAC,IACV,QAAQ,IACN,WAAW,CAAC,IACZ,WAAW,CAAC,IACd,SAAS,CAAC,IACV,QAAQ,IACN,WAAW,CAAC,IACZ,WAAW,CAAC,IACd,QAAQ,IACR,WAAW,CAAC,IACZ,WAAW,CAAC;AAEhB,SAAO;AACT;AAEO,IAAM,oBAAqD,oBAAI,IAAI;AAAA,EACxE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAyBD,IAAM,uBAAuB,CAC3B,UACA,SACA,UACG;AACH,MAAI,kBAAkB,OAAO,GAAG;AAE9B,UAAM,gBAAgB,QAAQ,eAAe,MAAM,KAAK,CAAC;AAGzD,kBAAc,QAAQ,CAAC,EAAE,GAAG,MAAM;AAChC,YAAM,SAAS,IAAI,EAAE,GAAG,iBAAiB,EAAE;AAAA,IAC7C,CAAC;AAAA,EACH;AACF;AAKA,IAAM,0BAA0B,CAC9B,UACA,SACA,UACQ;AACR,QAAM,SAAc,CAAC;AAErB,MAAI,QAAQ,SAAS;AACnB,UAAM,KAAK,QAAQ;AACnB,WAAO,KAAK,MAAM,SAAS,IAAI,EAAE,GAAG,WAAW,EAAE,CAAC;AAAA,EACpD;AAEA,MAAI,mBAAmB,OAAO,GAAG;AAC/B,UAAM,KAAK,QAAQ;AACnB,WAAO,KAAK,MAAM,SAAS,IAAI,EAAE,GAAG,eAAe,EAAE,CAAC;AAAA,EACxD;AAEA,MAAI,eAAe,OAAO,GAAG;AAC3B,QAAI,QAAQ,cAAc;AACxB,YAAM,KAAK,QAAQ,aAAa;AAChC,aAAO,KAAK,MAAM,SAAS,IAAI,EAAE,GAAG,gBAAgB,EAAE,CAAC;AAAA,IACzD;AAEA,QAAI,QAAQ,YAAY;AACtB,YAAM,KAAK,QAAQ,WAAW;AAC9B,aAAO,KAAK,MAAM,SAAS,IAAI,EAAE,GAAG,cAAc,EAAE,CAAC;AAAA,IACvD;AAAA,EACF;AAEA,SAAO;AACT;AAKO,IAAM,eAAN,MAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMxB,OAAc,eACZ,UACA,cACA,mBAIA;AACA,QAAI,CAAC,cAAc;AACjB;AAAA,IACF;AAEA,4BAAwB,UAAU,cAAc,CAAC,oBAAoB;AAEnE,UAAI,CAAC,mBAAmB,gBAAgB,WAAW;AACjD;AAAA,MACF;AAEA;AAAA,QACE;AAAA,QACA;AAAA,QACA,CAAC,GAAG,IAAI,mBAAmB;AACzB,cAAI,mBAAmB,aAAa,IAAI;AACtC,8BAAkB,iBAAiB;AAAA,cACjC,eAAe;AAAA,gBACb,gBAAgB;AAAA,gBAChB,oBAAI,IAAI,CAAC,cAAc,CAAC;AAAA,cAC1B;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAc,iBAAiB,CAC7B,UACA,cACA,sBAIG;AAEH,QAAI,CAAC,gBAAgB,aAAa,WAAW;AAC3C;AAAA,IACF;AAEA;AAAA,MACE;AAAA,MACA;AAAA,MACA,CAAC,iBAAiB,gBAAgB;AAEhC,YAAI,CAAC,mBAAmB,gBAAgB,WAAW;AACjD,4BAAkB,cAAc,EAAE,CAAC,WAAW,GAAG,KAAK,CAAC;AACvD;AAAA,QACF;AAGA,YAAI,gBAAgB,WAAW;AAC7B;AAAA,QACF;AAEA,YACE,gBAAgB,eAAe,KAAK,CAAC,MAAM,EAAE,OAAO,aAAa,EAAE,GACnE;AACA;AAAA,QACF;AAEA,YAAI,eAAe,YAAY,GAAG;AAEhC,4BAAkB,iBAAiB;AAAA,YACjC,eAAe;AAAA,cACb,gBAAgB;AAAA,cAChB,oBAAI,IAAI;AAAA,cACR,IAAI,MAAM,YAAY;AAAA,YACxB;AAAA,UACF,CAAC;AAAA,QACH;AAEA,YAAI,cAAc,YAAY,GAAG;AAC/B,cAAI,CAAC,gBAAgB,eAAe,KAAK,CAAC,MAAM,EAAE,SAAS,MAAM,GAAG;AAElE,8BAAkB,iBAAiB;AAAA,cACjC,eAAe;AAAA,gBACb,gBAAgB;AAAA,gBAChB,oBAAI,IAAI;AAAA,gBACR,IAAI,MAAM,YAAY;AAAA,cACxB;AAAA,YACF,CAAC;AAAA,UACH,OAAO;AAEL,8BAAkB,cAAc,EAAE,CAAC,WAAW,GAAG,KAAK,CAAC;AAAA,UACzD;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAKO,IAAM,kBAAN,MAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM3B,OAAc,eACZ,UACA,iBACA,mBAIA;AACA,QAAI,CAAC,iBAAiB;AACpB;AAAA,IACF;AAEA,yBAAqB,UAAU,iBAAiB,CAAC,iBAAiB;AAEhE,UAAI,CAAC,gBAAgB,aAAa,WAAW;AAC3C;AAAA,MACF;AAEA;AAAA,QACE;AAAA,QACA;AAAA,QACA,CAAC,GAAG,aAAa,sBAAsB;AAErC,cAAI,sBAAsB,gBAAgB,IAAI;AAC5C,8BAAkB,cAAc,EAAE,CAAC,WAAW,GAAG,KAAK,CAAC;AAAA,UACzD;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAc,iBAAiB,CAC7B,UACA,iBACA,sBAIG;AAEH,QAAI,CAAC,mBAAmB,gBAAgB,WAAW;AACjD;AAAA,IACF;AAEA;AAAA,MACE;AAAA,MACA;AAAA,MACA,CAAC,cAAc,GAAG,mBAAmB;AAEnC,YAAI,CAAC,gBAAgB,aAAa,WAAW;AAC3C,4BAAkB,iBAAiB;AAAA,YACjC,eAAe;AAAA,cACb,gBAAgB;AAAA,cAChB,oBAAI,IAAI,CAAC,cAAc,CAAC;AAAA,YAC1B;AAAA,UACF,CAAC;AACD;AAAA,QACF;AAEA,YAAI,cAAc,YAAY,GAAG;AAC/B,gBAAM,gBAAgB,gBAAgB,eAAe,MAAM,KAAK,CAAC;AAEjE,cACE,cAAc,QAAQ,EAAE,KAAK,CAAC,MAAM,EAAE,SAAS,MAAM,GAAG,OACxD,aAAa,IACb;AACA,gBAAI,aAAa,gBAAgB,gBAAgB,IAAI;AAEnD,gCAAkB,cAAc;AAAA,gBAC9B,aAAa,gBAAgB;AAAA,cAC/B,CAAyC;AAAA,YAC3C;AAAA,UACF,OAAO;AACL,gBAAI,aAAa,gBAAgB,MAAM;AAErC,gCAAkB,cAAc;AAAA,gBAC9B,aAAa;AAAA,cACf,CAAyC;AAAA,YAC3C;AAGA,8BAAkB,iBAAiB;AAAA,cACjC,eAAe;AAAA,gBACb,gBAAgB;AAAA,gBAChB,oBAAI,IAAI,CAAC,aAAa,EAAE,CAAC;AAAA,cAC3B;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,wCAAwC,CACnD,iBACA,SACA,gBACgB;AAChB,QAAM,CAAC,QAAQ,MAAM,IAAI,oBAAoB,eAAe;AAE5D,SAAOM;AAAA,IACLD;AAAA,MACE,QAAQ,IAAI,QAAQ,QAAQ;AAAA,MAC5B,QAAQ,IAAI,QAAQ,SAAS;AAAA,IAC/B;AAAA,IACA,mBAAmB,SAAS,WAAW;AAAA,IACvC,QAAQ;AAAA,EACV;AACF;AAEO,IAAM,uBAAuB,CAClC,OACA,gBAC+B;AAC/B,QAAM,eACJ,MAAM,gBACL,YAAY,IAAI,MAAM,aAAa,SAAS;AAG/C,QAAM,aACJ,MAAM,cACL,YAAY,IAAI,MAAM,WAAW,SAAS;AAG7C,QAAM,aACJ,gBAAgB,MAAM,eAClB;AAAA,IACE,MAAM,aAAa;AAAA,IACnB;AAAA,IACA;AAAA,EACF,IACAA;AAAA,IACE,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,IAC3B,MAAM,IAAI,MAAM,OAAO,CAAC,EAAE,CAAC;AAAA,EAC7B;AACN,QAAM,WACJ,cAAc,MAAM,aAChB;AAAA,IACE,MAAM,WAAW;AAAA,IACjB;AAAA,IACA;AAAA,EACF,IACAA;AAAA,IACE,MAAM,IAAI,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,EAAE,CAAC;AAAA,IACjD,MAAM,IAAI,MAAM,OAAO,MAAM,OAAO,SAAS,CAAC,EAAE,CAAC;AAAA,EACnD;AAEN,SAAO,CAAC,YAAY,QAAQ;AAC9B;AAEO,IAAM,2BAA2B,CACtC,OACA,gBACG;AACH,QAAM,CAAC,YAAY,QAAQ,IAAI,qBAAqB,OAAO,WAAW;AAEtE,SAAO;AAAA,IACL,oBAAoB,wBAAwB,OAAO,YAAY,WAAW;AAAA,IAC1E,oBAAoB,wBAAwB,OAAO,UAAU,WAAW;AAAA,EAC1E;AACF;AAEO,IAAM,sBAAsB,CACjC,eACuC;AAGvC,MACE,eACC,KAAK,IAAI,WAAW,CAAC,IAAI,GAAG,IAAI,QAC/B,KAAK,IAAI,WAAW,CAAC,IAAI,GAAG,IAAI,OAClC;AACA,WAAO,WAAW;AAAA,MAAI,CAAC,UACrB,KAAK,IAAI,QAAQ,GAAG,IAAI,OAAS,SAAS;AAAA,IAC5C;AAAA,EACF;AACA,SAAO;AACT;;;ADvoEA,IAAM,sBAAsB,CAAC;AAAA,EAC3B;AACF,MAMK;AACH,QAAM,UAAU,OAAO,CAAC,EAAE,CAAC;AAC3B,QAAM,UAAU,OAAO,CAAC,EAAE,CAAC;AAE3B,SAAO;AAAA,IACL,QAAQ,OAAO,IAAI,CAAC,MAAM;AACxB,aAAOgB,WAAU,EAAE,CAAC,IAAI,SAAS,EAAE,CAAC,IAAI,OAAO;AAAA,IACjD,CAAC;AAAA,IACD;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,sBAAN,MAAM,qBAAoB;AAAA,EACf;AAAA;AAAA,EAIA;AAAA,EAEA;AAAA;AAAA,EAcA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAIA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEhB,YACE,SACA,aACA;AACA,SAAK,YAAY,QAAQ;AAGzB,QAAI,CAACC,aAAY,QAAQ,OAAO,CAAC,GAAGD,WAAU,GAAG,CAAC,CAAC,GAAG;AACpD,cAAQ,MAAM,oCAAoC,MAAM,EAAE,KAAK;AAC/D;AAAA,QACE;AAAA,QACA;AAAA,QACA,qBAAoB,mCAAmC,OAAO;AAAA,MAChE;AAAA,IACF;AACA,SAAK,wBAAwB;AAC7B,SAAK,uBAAuB;AAC5B,SAAK,aAAa;AAClB,SAAK,gBAAgB,EAAE,GAAG,GAAG,GAAG,EAAE;AAClC,SAAK,sBAAsB;AAC3B,SAAK,oBAAoB;AACzB,SAAK,mBAAmB;AAAA,MACtB,2BAA2B;AAAA,MAC3B,kBAAkB;AAAA,MAClB,uBAAuB;AAAA,MACvB,QAAQ;AAAA,MAER,iBAAiB;AAAA,QACf,OAAO;AAAA,QACP,OAAO;AAAA,QACP,OAAO;AAAA,MACT;AAAA,IACF;AACA,SAAK,kBAAkB;AACvB,SAAK,+BAA+B;AACpC,SAAK,UAAU,aAAa,OAAO,KAAK,QAAQ;AAChD,SAAK,kBAAkB;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,oBAAoB;AAAA;AAAA;AAAA;AAAA;AAAA,EAK3B,OAAO,WACL,IACA,aACU;AACV,UAAM,UAAU,YAAY,IAAI,EAAE;AAClC,QAAI,SAAS;AACX,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,mBACL,OACA,UACA,UACA,aACA;AACA,QAAI,CAAC,SAAS,wBAAwB,CAAC,SAAS,kBAAkB;AAChE,aAAO;AAAA,IACT;AACA,UAAM,EAAE,qBAAqB,IAAI;AACjC,UAAM,EAAE,uBAAuB,UAAU,IAAI;AAE7C,UAAM,UAAU,qBAAoB,WAAW,WAAW,WAAW;AACrE,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AAEA,UAAM,CAAC,aAAa,aAAa,aAAa,WAAW,IACvDE,0BAAyB,SAAS,kBAAkB,WAAW;AAEjE,UAAM,oBAAoB,qBAAoB;AAAA,MAC5C;AAAA,MACA;AAAA,IACF;AAEA,UAAM,qBAAqB,kBACxB,OAAO,CAAC,KAAe,OAAO,UAAU;AACvC,UACG,MAAM,CAAC,KAAK,eACX,MAAM,CAAC,KAAK,eACZ,MAAM,CAAC,KAAK,eACZ,MAAM,CAAC,KAAK,eACb,MAAM,YAAY,uBAAuB,SAAS,KAAK,GACxD;AACA,YAAI,KAAK,KAAK;AAAA,MAChB;AAEA,aAAO;AAAA,IACT,GAAG,CAAC,CAAC,EACJ,OAAO,CAAC,UAAU;AACjB,UACE,aAAa,OAAO,KACpB,UAAU,KACV,UAAU,QAAQ,OAAO,SAAS,GAClC;AACA,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,CAAC;AAEH,aAAS;AAAA,MACP,sBAAsB;AAAA,QACpB,GAAG;AAAA,QACH,uBAAuB,mBAAmB,SACtC,qBACA;AAAA,MACN;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,oBACL,OACA,KACA,eACA,eACA,qBACuC;AACvC,QAAI,CAAC,qBAAqB;AACxB,aAAO;AAAA,IACT;AACA,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,cAAc,IAAI,MAAM,yBAAyB;AACvD,UAAM,UAAU,qBAAoB,WAAW,WAAW,WAAW;AACrE,QAAI,kBAAkB,oBAAoB;AAC1C,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AAEA,QACE,aAAa,OAAO,KACpB,CAAC,oBAAoB,iBAAiB,yBACtC,oBAAoB,iBAAiB,qBAAqB,GAC1D;AACA,aAAO;AAAA,IACT;AAEA,UAAM,wBAAwB,aAAa,OAAO,IAC9C;AAAA,MACE,CAAC,CAAC,oBAAoB,uBAAuB,SAAS,CAAC,IACnD,IACA;AAAA,MACJ,CAAC,CAAC,oBAAoB,uBAAuB,KAAK,CAAC,QAAQ,MAAM,CAAC,IAC9D,QAAQ,OAAO,SAAS,IACxB;AAAA,IACN,EAAE,OAAO,CAAC,QAAuB,QAAQ,MAAS,IAClD,oBAAoB;AACxB,UAAM,mBAAmB,aAAa,OAAO,IACzC,oBAAoB,iBAAiB,mBAAmB,IACtD,QAAQ,OAAO,SAAS,IACxB,IACF,oBAAoB,iBAAiB;AAGzC,UAAM,gBAAgB,QAAQ,OAAO,gBAAgB;AAErD,QAAI,yBAAyB,eAAe;AAC1C,UACE,8BAA8B,KAAK,KACnC,sBAAsB,WAAW,KACjC,QAAQ,OAAO,SAAS,GACxB;AACA,cAAM,gBAAgB,sBAAsB,CAAC;AAC7C,cAAM,iBACJ,QAAQ,OAAO,kBAAkB,IAAI,IAAI,gBAAgB,CAAC;AAC5D,0BACE,oBAAoB,mBACpB,KAAK;AAAA,UACH,QAAQ,OAAO,aAAa,EAAE,CAAC,IAAI,eAAe,CAAC;AAAA,UACnD,QAAQ,OAAO,aAAa,EAAE,CAAC,IAAI,eAAe,CAAC;AAAA,QACrD;AAEF,cAAM,CAAC,OAAO,MAAM,IAAI,qBAAoB;AAAA,UAC1C;AAAA,UACA;AAAA,UACA;AAAA,UACAF,WAAU,eAAe,aAAa;AAAA,UACtC,MAAMG,MAAK,WAAW,IAAI,OAAO,IAAI,qBAAqB;AAAA,UAC1D;AAAA,QACF;AAEA,6BAAoB;AAAA,UAClB;AAAA,UACA,IAAI;AAAA,UACJ,oBAAI,IAAI;AAAA,YACN;AAAA,cACE;AAAA,cACA;AAAA,gBACE,OAAOH;AAAA,kBACL,QAAQ,eAAe,CAAC;AAAA,kBACxB,SAAS,eAAe,CAAC;AAAA,gBAC3B;AAAA,gBACA,YAAY,kBAAkB;AAAA,cAChC;AAAA,YACF;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF,OAAO;AACL,cAAM,2BAA2B,qBAAoB;AAAA,UACnD;AAAA,UACA;AAAA,UACA,gBAAgB,oBAAoB,cAAc;AAAA,UAClD,gBAAgB,oBAAoB,cAAc;AAAA,UAClD,MAAMG,MAAK,WAAW,IAAI,OAAO,IAAI,qBAAqB;AAAA,QAC5D;AAEA,cAAM,SAAS,yBAAyB,CAAC,IAAI,cAAc,CAAC;AAC5D,cAAM,SAAS,yBAAyB,CAAC,IAAI,cAAc,CAAC;AAE5D,6BAAoB;AAAA,UAClB;AAAA,UACA,IAAI;AAAA,UACJ,IAAI;AAAA,YACF,sBAAsB,IAAI,CAAC,eAAe;AACxC,oBAAM,mBACJ,eAAe,mBACX,qBAAoB;AAAA,gBAClB;AAAA,gBACA;AAAA,gBACA,gBAAgB,oBAAoB,cAAc;AAAA,gBAClD,gBAAgB,oBAAoB,cAAc;AAAA,gBAClD,MAAMA,MAAK,WAAW,IAClB,OACA,IAAI,qBAAqB;AAAA,cAC/B,IACAH;AAAA,gBACE,QAAQ,OAAO,UAAU,EAAE,CAAC,IAAI;AAAA,gBAChC,QAAQ,OAAO,UAAU,EAAE,CAAC,IAAI;AAAA,cAClC;AACN,qBAAO;AAAA,gBACL;AAAA,gBACA;AAAA,kBACE,OAAO;AAAA,kBACP,YAAY,eAAe;AAAA,gBAC7B;AAAA,cACF;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAEA,YAAM,mBAAmB,oBAAoB,SAAS,WAAW;AACjE,UAAI,kBAAkB;AACpB,6BAAqB,SAAS,IAAI,OAAO,KAAK;AAAA,MAChD;AAGA,UAAI,oBAAiD,CAAC;AACtD,UAAI,iBAAiB,SAAS,KAAK,GAAG;AACpC,cAAM,qBAAqB,sBAAsB,CAAC,MAAM;AACxD,cAAM,oBACJ,sBAAsB,sBAAsB,SAAS,CAAC,MACtD,QAAQ,OAAO,SAAS;AAC1B,cAAM,SAAqC,CAAC;AAE5C,YAAI,CAAC,uBAAuB,CAAC,mBAAmB;AAC9C,iBAAO,KAAK,EAAE,GAAG,eAAe,GAAG,cAAc,CAAC;AAAA,QACpD,OAAO;AACL,cAAI,oBAAoB;AACtB,mBAAO;AAAA,cACLI;AAAA,gBACE,qBAAoB;AAAA,kBAClB;AAAA,kBACA,QAAQ,OAAO,CAAC;AAAA,kBAChB;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAEA,cAAI,mBAAmB;AACrB,mBAAO;AAAA,cACLA;AAAA,gBACE,qBAAoB;AAAA,kBAClB;AAAA,kBACA,QAAQ,OACN,sBAAsB,sBAAsB,SAAS,CAAC,CACxD;AAAA,kBACA;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,YAAI,OAAO,QAAQ;AACjB,8BAAoB;AAAA,YAClB;AAAA,YACA;AAAA,YACA,IAAI;AAAA,YACJ,IAAI,MAAM;AAAA,UACZ;AAAA,QACF;AAAA,MACF;AAEA,YAAM,yBAAyB;AAAA,QAC7B,GAAG;AAAA,QACH;AAAA,QACA,8BACE,qBAAqB,KACrB,qBAAqB,QAAQ,OAAO,SAAS,IACzC,KAAK;AAAA,UACH;AAAA,UACA;AAAA,UACA;AAAA,QACF,IACA;AAAA,QACN,iBACE,qBAAqB,KACrB,qBAAqB,QAAQ,OAAO,SAAS,IACzC,mBACA;AAAA,QACN,YAAY;AAAA,QACZ;AAAA,MACF;AAEA,aAAO;AAAA,QACL,GAAG,IAAI;AAAA,QACP,sBAAsB,IAAI,MAAM,uBAC5B,yBACA;AAAA,QACJ,uBAAuB;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,gBACL,OACA,sBACA,UACA,OACqB;AACrB,UAAM,cAAc,MAAM,yBAAyB;AACnD,UAAM,WAAW,MAAM,sBAAsB;AAC7C,UAAM,gBAAgB,4BAA4B,OAAO,QAAQ;AAEjE,UAAM,EAAE,WAAW,uBAAuB,YAAY,iBAAiB,IACrE;AACF,UAAM,UAAU,qBAAoB,WAAW,WAAW,WAAW;AACrE,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AAEA,UAAM,WAOF,CAAC;AAEL,QAAI,cAAc,uBAAuB;AACvC,iBAAW,iBAAiB,uBAAuB;AACjD,YACE,kBAAkB,KAClB,kBAAkB,QAAQ,OAAO,SAAS,GAC1C;AACA,cAAIC,aAAY,QAAQ,QAAQ,SAAS,KAAK,KAAK,GAAG;AACpD,gBAAI,cAAc,OAAO,GAAG;AAC1B,oBAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,kBACE,GAAG,uBAAuB,SAAS,IAAI;AAAA,gBACzC;AAAA,gBACA;AAAA,kBACE,gBAAgB;AAAA,kBAChB,YAAY;AAAA,gBACd;AAAA,cACF;AAAA,YACF;AACA,iCAAoB;AAAA,cAClB;AAAA,cACA;AAAA,cACA,oBAAI,IAAI;AAAA,gBACN;AAAA,kBACE;AAAA,kBACA;AAAA,oBACE,OACE,kBAAkB,IACd,QAAQ,OAAO,QAAQ,OAAO,SAAS,CAAC,IACxC,QAAQ,OAAO,CAAC;AAAA,kBACxB;AAAA,gBACF;AAAA,cACF,CAAC;AAAA,YACH;AAAA,UACF;AAEA,gBAAM,iBAAiB,iBAAiB,QAAQ,IAC5C;AAAA,aACG,uBAAuB,UAAU,KAAK,IACnCD;AAAA,cACE,qBAAoB;AAAA,gBAClB;AAAA,gBACA;AAAA,gBACA;AAAA,cACF;AAAA,YACF,IACA;AAAA,YACJ;AAAA,YACA;AAAA,YACA,SAAS;AAAA,YACT,aAAa,OAAO;AAAA,YACpB,aAAa,OAAO;AAAA,UACtB,IACA;AAEJ,mBACE,kBAAkB,IAAI,wBAAwB,mBAChD,IAAI;AAAA,QACN;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,GAAG;AAAA,MACH,8BAA8B;AAAA,MAC9B,iBAAiB;AAAA;AAAA;AAAA;AAAA,MAIjB,uBACE,cAAc,MAAM,WAChB,CAAC,cACD,MAAM,YACN,iBAAiB,2BAA2B;AAAA,QAC1C,iBAAiB;AAAA,MACnB,IACE,yBACA,sBAAsB;AAAA,QACpB,CAAC,eACC,eAAe,iBAAiB;AAAA,MACpC,IACA,wBACF,uBAAuB,SAAS,iBAAiB,gBAAgB,IACjE,CAAC,iBAAiB,gBAAgB,IAClC;AAAA,MACN,YAAY;AAAA,MACZ,eAAe,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,MAC5B,iBAAiB;AAAA,IACnB;AAAA,EACF;AAAA,EAEA,OAAO,qBAAqB,CAC1B,SACA,aACA,aAC2B;AAC3B,UAAM,YAAY,oBAAoB,SAAS,WAAW;AAG1D,QACE,CAAC,aAAa,OAAO,KACrB,CAAC,SAAS,wBACV,QAAQ,OAAO,SAAS,KACxB,CAAC,WACD;AACA,aAAO,CAAC;AAAA,IACV;AAEA,UAAM,SAAS,qBAAoB;AAAA,MACjC;AAAA,MACA;AAAA,IACF;AAEA,QAAI,QAAQ;AACZ,UAAM,YAAoC,CAAC;AAC3C,WAAO,QAAQ,OAAO,SAAS,GAAG;AAChC,UACE,qBAAoB;AAAA,QAClB;AAAA,QACA,QAAQ,OAAO,KAAK;AAAA,QACpB,QAAQ,OAAO,QAAQ,CAAC;AAAA,QACxB;AAAA,QACA,SAAS;AAAA,MACX,GACA;AACA,kBAAU,KAAK,IAAI;AACnB;AACA;AAAA,MACF;AACA,YAAM,kBAAkB,qBAAoB;AAAA,QAC1C;AAAA,QACA,QAAQ;AAAA,MACV;AACA,gBAAU,KAAK,eAAe;AAC9B;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,8BAA8B,CACnC,qBACA,cACA,UACA,gBACuB;AACvB,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,UAAU,qBAAoB,WAAW,WAAW,WAAW;AACrE,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AACA,UAAM,oBAAoB,qBAAoB;AAAA,MAC5C;AAAA,MACA;AAAA,MACA,SAAS;AAAA,MACT,aAAa;AAAA,MACb,aAAa;AAAA,IACf;AACA,QAAI,CAAC,aAAa,OAAO,KAAK,qBAAqB,GAAG;AACpD,aAAO;AAAA,IACT;AACA,UAAM,SAAS,qBAAoB;AAAA,MACjC;AAAA,MACA;AAAA,IACF;AACA,QACE,OAAO,UAAU,KACjB,CAAC,SAAS,wBACV,CAAC,aAAa,OAAO,GACrB;AACA,aAAO;AAAA,IACT;AAEA,UAAM,aACH,qBAAoB,oBAAoB,KAAK,SAAS,KAAK;AAE9D,UAAM,mCACJ,oBAAoB;AACtB,QAAI,kCAAkC;AACpC,YAAME,YAAWC;AAAA,QACfP;AAAA,UACE,iCAAiC,CAAC;AAAA,UAClC,iCAAiC,CAAC;AAAA,QACpC;AAAA,QACAA,WAAU,aAAa,GAAG,aAAa,CAAC;AAAA,MAC1C;AACA,UAAIM,aAAY,WAAW;AACzB,eAAO;AAAA,MACT;AAAA,IACF;AACA,QAAI,QAAQ;AACZ,UAAM,YAAY,qBAAoB;AAAA,MACpC;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,WAAO,QAAQ,UAAU,QAAQ;AAC/B,UAAI,UAAU,KAAK,MAAM,MAAM;AAC7B,cAAMA,YAAWC;AAAA,UACf,UAAU,KAAK;AAAA,UACfP,WAAU,aAAa,GAAG,aAAa,CAAC;AAAA,QAC1C;AACA,YAAIM,aAAY,WAAW;AACzB,iBAAO,UAAU,KAAK;AAAA,QACxB;AAAA,MACF;AAEA;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,kBACL,SACA,YACA,UACA,OACA,MACA;AACA,QAAI,aAAa,OAAO,GAAG;AACzB,UAAI,SAAS,KAAK,QAAQ,QAAQ,OAAO,QAAQ;AAC/C,eACEC,eAAc,YAAY,QAAQ,IAAI,KAAK,QAC3C,qBAAoB,oBAAoB;AAAA,MAE5C;AAEA,aAAO;AAAA,IACT;AAEA,QAAID,YAAWC,eAAc,YAAY,QAAQ;AACjD,QAAI,QAAQ,OAAO,SAAS,KAAK,QAAQ,WAAW;AAClD,YAAM,CAAC,OAAO,MAAM,IAAIC,oCAAmC,OAAO;AAElE,MAAAC;AAAA,QACE,MAAM,WAAW,KAAK,OAAO,SAAS;AAAA,QACtC;AAAA,MACF;AACA,MAAAA;AAAA,QACE,MAAM,SAAS,OAAO,UAAU;AAAA,QAChC;AAAA,MACF;AAEA,MAAAH,YAAW,YAAyB,OAAO,KAAK,CAAC;AAAA,IACnD;AAEA,WAAOA,YAAW,KAAK,QAAQ,qBAAoB,oBAAoB;AAAA,EACzE;AAAA,EAEA,OAAO,mBACL,SACA,OACa;AACb,QAAI,aAAa,OAAO,GAAG;AACzB,MAAAG;AAAA,QACE,QAAQ,OAAO,UAAU;AAAA,QACzB;AAAA,MACF;AAEA,YAAM,IAAIC,aAAY,QAAQ,OAAO,QAAQ,CAAC,GAAG,QAAQ,OAAO,KAAK,CAAC;AAEtE,aAAOV,WAAuB,QAAQ,IAAI,EAAE,CAAC,GAAG,QAAQ,IAAI,EAAE,CAAC,CAAC;AAAA,IAClE;AAEA,UAAM,CAAC,OAAO,MAAM,IAAIQ,oCAAmC,OAAO;AAElE,IAAAC;AAAA,MACG,MAAM,WAAW,KAAK,OAAO,SAAS,KACpC,MAAM,SAAS,KAAK,OAAO,WAAW;AAAA,MACzC;AAAA,IACF;AACA,IAAAA;AAAA,MACE,MAAM,SAAS,OAAO,UAAU;AAAA,MAChC;AAAA,IACF;AAEA,QAAI,MAAM,QAAQ;AAChB,YAAM,UAAU,MAAM,QAAQ,CAAC;AAC/B,aAAOC,aAAY,QAAQ,CAAC,GAAG,QAAQ,CAAC,CAAC;AAAA,IAC3C;AAEA,QAAI,OAAO,QAAQ;AACjB,YAAM,UAAU,OAAO,QAAQ,CAAC;AAChC,aAAO,mBAAmB,SAAS,GAAG;AAAA,IACxC;AAEA,IAAAD,WAAU,OAAO,kDAAkD;AAAA,EACrE;AAAA,EAEA,OAAO,wBACL,qBACA,UACA,UACA,aACA;AACA,UAAM,UAAU,qBAAoB;AAAA,MAClC,oBAAoB;AAAA,MACpB;AAAA,IACF;AACA,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AACA,UAAM,YAAY,qBAAoB;AAAA,MACpC;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,QAAI,QAAQ;AACZ,WAAO,QAAQ,UAAU,QAAQ;AAC/B,UAAI,qBAAoB,eAAe,UAAU,UAAU,KAAK,CAAC,GAAG;AAClE,eAAO,QAAQ;AAAA,MACjB;AACA;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,kBACL,OACA,KACA,OACA,cACA,qBACA,OAKA;AACA,UAAM,WAAW,IAAI;AACrB,UAAM,cAAc,MAAM,yBAAyB;AACnD,UAAM,WAAW,MAAM,sBAAsB;AAE7C,UAAM,MAAmE;AAAA,MACvE,aAAa;AAAA,MACb,YAAY;AAAA,MACZ,qBAAqB;AAAA,IACvB;AAEA,QAAI,CAAC,qBAAqB;AACxB,aAAO;AAAA,IACT;AAEA,UAAM,EAAE,UAAU,IAAI;AACtB,UAAM,UAAU,qBAAoB,WAAW,WAAW,WAAW;AAErE,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AACA,UAAM,kBAAkB,qBAAoB;AAAA,MAC1C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,QAAI,uBAAuB;AAC3B,QAAI,iBAAiB;AACnB,6BAAuB,qBAAoB;AAAA,QACzC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,WAAW,MAAM,UAAU,SAAS,sBAAsB;AACxD,UAAI,oBAAoB,wBAAwB,MAAM;AACpD,cAAM,cAAc,SAAS;AAAA,UAC3B,QAAQ;AAAA,YACN,GAAG,QAAQ;AAAA,YACX,qBAAoB;AAAA,cAClB;AAAA,cACA;AAAA,cACA,aAAa;AAAA,cACb,aAAa;AAAA,cACb,MAAMN,MAAK,WAAW,IAAI,OAAO,IAAI,qBAAqB;AAAA,YAC5D;AAAA,UACF;AAAA,QACF,CAAC;AACD,YAAI,cAAc;AAAA,MACpB;AACA,YAAM,gBAAgB;AACtB,UAAI,sBAAsB;AAAA,QACxB,GAAG;AAAA,QACH,kBAAkB;AAAA,UAChB,2BAA2B,oBAAoB;AAAA,UAC/C,kBAAkB;AAAA,UAClB,uBAAuB;AAAA,UACvB,QAAQ,EAAE,GAAG,aAAa,GAAG,GAAG,aAAa,EAAE;AAAA,UAC/C,iBAAiB;AAAA,YACf,OAAO;AAAA,YACP,OAAO;AAAA,YACP,OAAO;AAAA,UACT;AAAA,QACF;AAAA,QACA,uBAAuB,CAAC,QAAQ,OAAO,SAAS,CAAC;AAAA,QACjD,sBAAsB;AAAA,QACtB,mBAAmB;AAAA,UACjB;AAAA,UACA;AAAA,UACA;AAAA,UACA,IAAI,MAAM;AAAA,UACV,oBAAoB;AAAA,QACtB;AAAA,MACF;AAEA,UAAI,cAAc;AAClB,aAAO;AAAA,IACT;AAEA,UAAM,oBAAoB,qBAAoB;AAAA,MAC5C;AAAA,MACA;AAAA,MACA,SAAS;AAAA,MACT,aAAa;AAAA,MACb,aAAa;AAAA,IACf;AAGA,QAAI,qBAAqB,KAAK,iBAAiB;AAC7C,UAAI,aAAa;AAAA,IACnB,OAAO;AAML,YAAM,EAAE,qBAAqB,kBAAkB,IAAI;AACnD,UAAI,iBAAiB,QAAQ,KAAK,iBAAiB,OAAO,GAAG;AAC3D;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAID,0BAAyB,SAAS,WAAW;AACtE,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,cACJ,oBAAoB,MACpBS;AAAA,MACEX;AAAA,QACE,QAAQ,IAAI,QAAQ,OAAO,iBAAiB,EAAE,CAAC;AAAA,QAC/C,QAAQ,IAAI,QAAQ,OAAO,iBAAiB,EAAE,CAAC;AAAA,MACjD;AAAA,MACAA,WAAU,IAAI,EAAE;AAAA,MAChB,QAAQ;AAAA,IACV;AAEF,UAAM,4BACJ,oBAAoB,MAAM,MAAM,WAC5B,MAAM,YACN,oBAAoB,uBAAuB,SAAS,iBAAiB,IACnE,wBAAwB;AAAA,MACtB,GAAI,oBAAoB,yBAAyB,CAAC;AAAA,MAClD;AAAA,IACF,CAAC,IACD,CAAC,iBAAiB,IACpB;AACN,QAAI,sBAAsB;AAAA,MACxB,GAAG;AAAA,MACH,kBAAkB;AAAA,QAChB,2BAA2B,oBAAoB;AAAA,QAC/C,kBAAkB;AAAA,QAClB,uBAAuB,sBAAsB,QAAQ,OAAO,SAAS;AAAA,QACrE,QAAQ,EAAE,GAAG,aAAa,GAAG,GAAG,aAAa,EAAE;AAAA,QAC/C,iBAAiB;AAAA,UACf,OAAO;AAAA,UACP,OAAO;AAAA,UACP,OAAO;AAAA,QACT;AAAA,MACF;AAAA,MACA,uBAAuB;AAAA,MACvB,eAAe,cACX;AAAA,QACE,GAAG,aAAa,IAAI,YAAY,CAAC;AAAA,QACjC,GAAG,aAAa,IAAI,YAAY,CAAC;AAAA,MACnC,IACA,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,IACnB;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,eACL,QACA,QACA;AACA,QAAI,CAAC,UAAU,CAAC,QAAQ;AACtB,aAAO;AAAA,IACT;AACA,QAAI,CAAC,UAAU,CAAC,QAAQ;AACtB,aAAO;AAAA,IACT;AACA,WAAOC,aAAY,QAAQ,MAAM;AAAA,EACnC;AAAA,EAEA,OAAO,kBACL,OACA,eACA,eACA,KAC4B;AAC5B,UAAM,WAAW,IAAI;AACrB,QAAI,CAAC,SAAS,sBAAsB;AAClC,aAAO;AAAA,IACT;AACA,UAAM,EAAE,WAAW,qBAAqB,IAAI,SAAS;AACrD,UAAM,cAAc,IAAI,MAAM,yBAAyB;AACvD,UAAM,UAAU,qBAAoB,WAAW,WAAW,WAAW;AACrE,QAAI,CAAC,SAAS;AACZ,aAAO,SAAS;AAAA,IAClB;AAEA,UAAM,EAAE,OAAO,IAAI;AACnB,UAAM,YAAY,OAAO,OAAO,SAAS,CAAC;AAE1C,QAAI,CAAC,MAAM,QAAQ;AACjB,UAAI,cAAc,sBAAsB;AACtC,6BAAoB,aAAa,SAAS,KAAK,CAAC,OAAO,SAAS,CAAC,CAAC;AAAA,MACpE;AACA,aAAO;AAAA,QACL,GAAG,SAAS;AAAA,QACZ,sBAAsB;AAAA,MACxB;AAAA,IACF;AAEA,QAAI;AAEJ,QAAI,8BAA8B,KAAK,KAAK,OAAO,UAAU,GAAG;AAC9D,YAAM,qBAAqB,OAAO,OAAO,SAAS,CAAC;AAEnD,YAAM,CAAC,OAAO,MAAM,IAAI,qBAAoB;AAAA,QAC1C;AAAA,QACA;AAAA,QACA;AAAA,QACAD,WAAU,eAAe,aAAa;AAAA,QACtC,MAAMG,MAAK,WAAW,IAAI,OAAO,IAAI,qBAAqB;AAAA,MAC5D;AAEA,iBAAWH;AAAA,QACT,QAAQ,mBAAmB,CAAC;AAAA,QAC5B,SAAS,mBAAmB,CAAC;AAAA,MAC/B;AAAA,IACF,OAAO;AACL,iBAAW,qBAAoB;AAAA,QAC7B;AAAA,QACA;AAAA,QACA,gBAAgB,SAAS,qBAAqB,cAAc;AAAA,QAC5D,gBAAgB,SAAS,qBAAqB,cAAc;AAAA,QAC5D,MAAMG,MAAK,WAAW,KAAK,aAAa,OAAO,IAC3C,OACA,IAAI,qBAAqB;AAAA,MAC/B;AAAA,IACF;AAEA,QAAI,cAAc,sBAAsB;AACtC,2BAAoB;AAAA,QAClB;AAAA,QACA,IAAI;AAAA,QACJ,oBAAI,IAAI;AAAA,UACN;AAAA,YACE,QAAQ,OAAO,SAAS;AAAA,YACxB;AAAA,cACE,OAAO;AAAA,YACT;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,OAAO;AACL,2BAAoB,UAAU,SAAS,IAAI,OAAO,CAAC,QAAQ,CAAC;AAAA,IAC9D;AACA,WAAO;AAAA,MACL,GAAG,SAAS;AAAA,MACZ,sBAAsB,QAAQ,OAAO,QAAQ,OAAO,SAAS,CAAC;AAAA,IAChE;AAAA,EACF;AAAA;AAAA,EAGA,OAAO,0BACL,SACA,GACA,aACa;AACb,UAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAID,0BAAyB,SAAS,WAAW;AACtE,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,MAAM,KAAK,MAAM;AAEvB,UAAM,EAAE,GAAG,EAAE,IAAI;AACjB,WAAOS;AAAA,MACLX,WAAU,IAAI,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC;AAAA,MAC5BA,WAAU,IAAI,EAAE;AAAA,MAChB,QAAQ;AAAA,IACV;AAAA,EACF;AAAA;AAAA,EAGA,OAAO,2BACL,SACA,aACe;AACf,UAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAIE,0BAAyB,SAAS,WAAW;AACtE,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,MAAM,KAAK,MAAM;AACvB,WAAO,QAAQ,OAAO,IAAI,CAAC,MAAM;AAC/B,YAAM,EAAE,GAAG,EAAE,IAAI;AACjB,aAAOS;AAAA,QACLX,WAAU,IAAI,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC;AAAA,QAC5BA,WAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,OAAO,iCACL,SAEA,mBACA,aACa;AACb,UAAM,QACJ,oBAAoB,IAChB,QAAQ,OAAO,SAAS,oBACxB;AACN,UAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAIE,0BAAyB,SAAS,WAAW;AACtE,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,IAAI,QAAQ,OAAO,KAAK;AAC9B,UAAM,EAAE,GAAG,EAAE,IAAI;AAEjB,WAAO,IACHS;AAAA,MACEX,WAAU,IAAI,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC;AAAA,MAC5BA,WAAU,IAAI,EAAE;AAAA,MAChB,QAAQ;AAAA,IACV,IACAW,iBAAgBX,WAAU,GAAG,CAAC,GAAGA,WAAU,IAAI,EAAE,GAAG,QAAQ,KAAK;AAAA,EACvE;AAAA,EAEA,OAAO,wBACL,SACA,gBACA,aACY;AACZ,QAAI,aAAa,OAAO,GAAG;AAEzB,aAAOA;AAAA,QACL,eAAe,CAAC,IAAI,QAAQ;AAAA,QAC5B,eAAe,CAAC,IAAI,QAAQ;AAAA,MAC9B;AAAA,IACF;AAEA,UAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAIE,0BAAyB,SAAS,WAAW;AACtE,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,CAAC,GAAG,CAAC,IAAIS;AAAA,MACbX,WAAU,eAAe,CAAC,GAAG,eAAe,CAAC,CAAC;AAAA,MAC9CA,WAAU,IAAI,EAAE;AAAA,MAChB,CAAC,QAAQ;AAAA,IACX;AACA,WAAOA,WAAU,IAAI,QAAQ,GAAG,IAAI,QAAQ,CAAC;AAAA,EAC/C;AAAA,EAEA,OAAO,yBACL,SACA,aACA,MACA,GACA,GACA;AACA,UAAM,eAAe,qBAAoB;AAAA,MACvC;AAAA,MACA;AAAA,IACF;AACA,QAAI,MAAM,aAAa;AAIvB,WAAO,EAAE,MAAM,IAAI;AACjB,YAAM,IAAI,aAAa,GAAG;AAC1B,UACEO,eAAcP,WAAU,GAAG,CAAC,GAAGA,WAAU,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK;AAAA,MAE7D,qBAAoB,oBAAoB,GACxC;AACA,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,cACL,SACA,aACA,eACA,eACA,UACY;AACZ,UAAM,gBAAgB,aAAa,eAAe,eAAe,QAAQ;AACzE,UAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAIE,0BAAyB,SAAS,WAAW;AACtE,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,CAAC,UAAU,QAAQ,IAAIS;AAAA,MAC3BX,WAAU,cAAc,CAAC,GAAG,cAAc,CAAC,CAAC;AAAA,MAC5CA,WAAU,IAAI,EAAE;AAAA,MAChB,CAAC,QAAQ;AAAA,IACX;AAEA,WAAOA,WAAU,WAAW,QAAQ,GAAG,WAAW,QAAQ,CAAC;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,mCAAmC,SAAkC;AAC1E,UAAM,EAAE,QAAQ,SAAS,QAAQ,IAAI,oBAAoB,OAAO;AAEhE,WAAO;AAAA,MACL;AAAA,MACA,GAAG,QAAQ,IAAI;AAAA,MACf,GAAG,QAAQ,IAAI;AAAA,IACjB;AAAA,EACF;AAAA;AAAA;AAAA,EAIA,OAAO,wBAAwB,UAAoB,OAAwB;AACzE,IAAAS;AAAA,MACE,SAAS;AAAA,MACT;AAAA,IACF;AAEA,UAAM,cAAc,MAAM,yBAAyB;AACnD,UAAM,EAAE,uBAAuB,UAAU,IAAI,SAAS;AACtD,UAAM,UAAU,qBAAoB,WAAW,WAAW,WAAW;AAErE,IAAAA;AAAA,MACE;AAAA,MACA;AAAA,IACF;AACA,IAAAA;AAAA,MACE,yBAAyB;AAAA,MACzB;AAAA,IACF;AAEA,UAAM,EAAE,OAAO,IAAI;AAEnB,UAAM,sBAAgC,CAAC;AAEvC,QAAI,kBAAkB;AACtB,QAAI,cAAc;AAClB,UAAM,aAAa,OAAO,OAAO,CAAC,KAAmB,GAAG,UAAU;AAChE,QAAE;AACF,UAAI,KAAK,CAAC;AAEV,YAAM,aAAa,sBAAsB,SAAS,KAAK;AACvD,UAAI,YAAY;AACd,cAAM,YAAY,OAAO,QAAQ,CAAC;AAElC,YAAI,CAAC,WAAW;AACd,4BAAkB;AAAA,QACpB;AACA,YAAI;AAAA,UACF,YACIT,YAAW,EAAE,CAAC,IAAI,UAAU,CAAC,KAAK,IAAI,EAAE,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,IAC9DA,WAAU,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;AAAA,QAC1B;AAEA,4BAAoB,KAAK,cAAc,CAAC;AACxC,UAAE;AAAA,MACJ;AAEA,aAAO;AAAA,IACT,GAAG,CAAC,CAAC;AAEL,UAAM,cAAc,SAAS,EAAE,QAAQ,WAAW,CAAC;AAInD,QAAI,iBAAiB;AACnB,YAAM,YAAY,QAAQ,OAAO,QAAQ,OAAO,SAAS,CAAC;AAC1D,2BAAoB;AAAA,QAClB;AAAA,QACA;AAAA,QACA,oBAAI,IAAI;AAAA,UACN;AAAA,YACE,QAAQ,OAAO,SAAS;AAAA,YACxB,EAAE,OAAOA,WAAU,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,EAAE,EAAE;AAAA,UAC3D;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,sBAAsB;AAAA,QACpB,GAAG,SAAS;AAAA,QACZ,uBAAuB;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,aACL,SACA,KACA,cACA;AACA,UAAM,qBACJ,IAAI,MAAM,sBAAsB,yBAChC,QAAQ,OAAO,QAAQ,OAAO,SAAS,CAAC;AAE1C,UAAM,aAAa,QAAQ,OAAO,OAAO,CAAC,GAAG,QAAQ;AACnD,aAAO,CAAC,aAAa,SAAS,GAAG;AAAA,IACnC,CAAC;AAED,UAAM,YAAY,cAAc,OAAO,KAAK,QAAQ;AAGpD,QACE,cACC,sBACC,aAAa,SAAS,CAAC,KACvB,aAAa,SAAS,QAAQ,OAAO,SAAS,CAAC,IACjD;AACA,iBAAW,CAAC,IAAIA;AAAA,QACd,WAAW,WAAW,SAAS,CAAC,EAAE,CAAC;AAAA,QACnC,WAAW,WAAW,SAAS,CAAC,EAAE,CAAC;AAAA,MACrC;AAAA,IACF;AAEA,UAAM;AAAA,MACJ,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,IACF,IAAI,oBAAoB,EAAE,QAAQ,WAAW,CAAC;AAE9C,yBAAoB;AAAA,MAClB;AAAA,MACA,IAAI;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,UACL,SACA,OACA,aACA;AACA,UAAM,aAAa,CAAC,GAAG,QAAQ,QAAQ,GAAG,WAAW;AAErD,QAAI,cAAc,OAAO,KAAK,QAAQ,SAAS;AAC7C,iBAAW,CAAC,IAAIA;AAAA,QACd,WAAW,WAAW,SAAS,CAAC,EAAE,CAAC;AAAA,QACnC,WAAW,WAAW,SAAS,CAAC,EAAE,CAAC;AAAA,MACrC;AAAA,IACF;AAEA,UAAM;AAAA,MACJ,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,IACF,IAAI,oBAAoB,EAAE,QAAQ,WAAW,CAAC;AAE9C,yBAAoB;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,WACL,SACA,OACA,cACA,cAIA;AACA,UAAM,EAAE,OAAO,IAAI;AAGnB,QAAI,cAAc,OAAO,KAAK,QAAQ,SAAS;AAC7C,YAAM,mBAAmB,aAAa,IAAI,CAAC;AAC3C,YAAM,kBAAkB,aAAa,IAAI,OAAO,SAAS,CAAC;AAE1D,UAAI,kBAAkB;AACpB,qBAAa,IAAI,OAAO,SAAS,GAAG;AAAA,UAClC,OAAOA;AAAA,YACL,iBAAiB,MAAM,CAAC;AAAA,YACxB,iBAAiB,MAAM,CAAC;AAAA,UAC1B;AAAA,UACA,YAAY,iBAAiB;AAAA,QAC/B,CAAC;AAAA,MACH,WAAW,iBAAiB;AAC1B,qBAAa,IAAI,GAAG;AAAA,UAClB,OAAOA,WAAU,gBAAgB,MAAM,CAAC,GAAG,gBAAgB,MAAM,CAAC,CAAC;AAAA,UACnE,YAAY,gBAAgB;AAAA,QAC9B,CAAC;AAAA,MACH;AAAA,IACF;AAQA,UAAM,qBACJ,aAAa,IAAI,CAAC,GAAG,SAASA,WAAsB,GAAG,CAAC;AAE1D,UAAM,CAAC,SAAS,OAAO,IAAI;AAE3B,UAAM,aAAa,aAAa,OAAO,IACnC;AAAA,MACE,aAAa,IAAI,CAAC,GAAG,SAAS,OAAO,CAAC;AAAA,MACtC,aAAa,IAAI,OAAO,SAAS,CAAC,GAAG,SACnC,OAAO,OAAO,SAAS,CAAC;AAAA,IAC5B,IACA,OAAO,IAAI,CAAC,GAAG,QAAQ;AACrB,YAAM,UAAU,aAAa,IAAI,GAAG,GAAG,SAAS;AAEhD,aAAOA;AAAA,QACL,QAAQ,CAAC,IAAI;AAAA,QACb,QAAQ,CAAC,IAAI;AAAA,MACf;AAAA,IACF,CAAC;AAEL,yBAAoB;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACE,YAAY,MAAM,KAAK,aAAa,OAAO,CAAC,EAAE,KAAK,CAAC,MAAM,EAAE,UAAU;AAAA,MACxE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAO,kBACL,qBACA,eACA,UACA,aACA;AACA,UAAM,UAAU,qBAAoB;AAAA,MAClC,oBAAoB;AAAA,MACpB;AAAA,IACF;AAGA,QAAI,WAAW,aAAa,OAAO,GAAG;AACpC,aAAO;AAAA,IACT;AAEA,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AAEA,UAAM,EAAE,gBAAgB,IAAI,oBAAoB;AAEhD,QACE,gBAAgB,SAChB,gBAAgB,UAAU,QAC1B,gBAAgB,UAAU,QAC1B,oBAAoB,iBAAiB,WAAW,MAChD;AACA,aAAO;AAAA,IACT;AAEA,UAAM,SAAS,oBAAoB,iBAAiB;AACpD,UAAM,OAAOO;AAAA,MACXP,WAAU,OAAO,GAAG,OAAO,CAAC;AAAA,MAC5BA,WAAU,cAAc,GAAG,cAAc,CAAC;AAAA,IAC5C;AACA,QACE,CAAC,SAAS,wBACV,OAAO,qBAAqB,SAAS,KAAK,OAC1C;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,YACL,qBACA,eACA,KACA,YACA,OACA;AACA,UAAM,cAAc,MAAM,yBAAyB;AACnD,UAAM,UAAU,qBAAoB;AAAA,MAClC,oBAAoB;AAAA,MACpB;AAAA,IACF;AACA,QAAI,CAAC,SAAS;AACZ;AAAA,IACF;AACA,UAAM,EAAE,gBAAgB,IAAI,oBAAoB;AAChD,UAAM,MAGF;AAAA,MACF,kBAAkB,oBAAoB;AAAA,MACtC,uBAAuB,oBAAoB;AAAA,IAC7C;AAEA,UAAMY,YAAW,qBAAoB;AAAA,MACnC;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd,cAAc;AAAA,MACd,cAAc,CAAC,aAAa,OAAO,IAAI,IAAI,qBAAqB,IAAI;AAAA,IACtE;AACA,UAAM,SAAS;AAAA,MACb,GAAG,QAAQ,OAAO,MAAM,GAAG,gBAAgB,KAAM;AAAA,MACjDA;AAAA,MACA,GAAG,QAAQ,OAAO,MAAM,gBAAgB,KAAM;AAAA,IAChD;AAEA,UAAM,cAAc,SAAS,EAAE,OAAO,CAAC;AAEvC,QAAI,mBAAmB;AAAA,MACrB,GAAG,oBAAoB;AAAA,MACvB,iBAAiB;AAAA,QACf,GAAG,oBAAoB,iBAAiB;AAAA,QACxC,OAAO;AAAA,MACT;AAAA,MACA,kBAAkB,gBAAgB;AAAA,IACpC;AACA,QAAI,wBAAwB,CAAC,gBAAgB,KAAM;AACnD,WAAO;AAAA,EACT;AAAA,EAEA,OAAe,cACb,SACA,OACA,YACA,SACA,SACA,cAIA,SAKA;AACA,QAAI,aAAa,OAAO,GAAG;AACzB,YAAM,UAIF,CAAC;AACL,UAAI,cAAc,iBAAiB,QAAW;AAC5C,gBAAQ,eACN,aAAa,iBAAiB,QAC9B,oBAAoB,aAAa,YAAY,IACzC,aAAa,eACb;AAAA,MACR;AACA,UAAI,cAAc,eAAe,QAAW;AAC1C,gBAAQ,aACN,aAAa,eAAe,QAC5B,oBAAoB,aAAa,UAAU,IACvC,aAAa,aACb;AAAA,MACR;AAEA,cAAQ,SAAS,MAAM,KAAK,UAAU;AAEtC,YAAM,cAAc,SAAS,SAAS;AAAA,QACpC,gBAAgB;AAAA,QAChB,YAAY,SAAS,cAAc;AAAA,MACrC,CAAC;AAAA,IACH,OAAO;AAEL,YAAM,aAAa,uBAAuB,SAAS,UAAU;AAC7D,YAAM,aAAa,uBAAuB,SAAS,QAAQ,MAAM;AACjE,YAAM,eAAe,WAAW,CAAC,IAAI,WAAW,CAAC,KAAK;AACtD,YAAM,eAAe,WAAW,CAAC,IAAI,WAAW,CAAC,KAAK;AACtD,YAAM,eAAe,WAAW,CAAC,IAAI,WAAW,CAAC,KAAK;AACtD,YAAM,eAAe,WAAW,CAAC,IAAI,WAAW,CAAC,KAAK;AACtD,YAAM,KAAK,cAAc;AACzB,YAAM,KAAK,cAAc;AACzB,YAAM,gBAAgBD;AAAA,QACpBX,WAAU,SAAS,OAAO;AAAA,QAC1BA,WAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AACA,YAAM,cAAc,SAAS;AAAA,QAC3B,GAAG;AAAA,QACH,QAAQ;AAAA,QACR,GAAG,QAAQ,IAAI,cAAc,CAAC;AAAA,QAC9B,GAAG,QAAQ,IAAI,cAAc,CAAC;AAAA,MAChC,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,OAAe,qBACb,SACA,aACA,gBACA,cACA,UACA,iBACA;AACA,UAAM,uBAAuB,qBAAoB;AAAA,MAC/C;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,QAAI,aAAa,OAAO,GAAG;AACzB,aAAO;AAAA,QACL,aAAa,CAAC,IAAI,qBAAqB,CAAC;AAAA,QACxC,aAAa,CAAC,IAAI,qBAAqB,CAAC;AAAA,MAC1C;AAAA,IACF;AAEA,UAAM,CAAC,OAAO,KAAK,IAAI;AAAA,MACrB,aAAa,CAAC;AAAA,MACd,aAAa,CAAC;AAAA,MACd;AAAA,IACF;AAEA,UAAM,EAAE,OAAO,OAAO,IAAI;AAAA,MACxB,qBAAqB,CAAC;AAAA,MACtB,qBAAqB,CAAC;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,WAAOW;AAAA,MACLX,WAAU,OAAO,MAAM;AAAA,MACvBA,WAAU,GAAG,CAAC;AAAA,MACd,CAAC,QAAQ;AAAA,IACX;AAAA,EACF;AAAA,EAEA,OAAO,8BAA8B,CACnC,SACA,kBACA,gBAC6B;AAC7B,UAAM,SAAS,qBAAoB;AAAA,MACjC;AAAA,MACA;AAAA,IACF;AACA,QAAI,OAAO,SAAS,GAAG;AACrB,oBAAc,kBAAkB,aAAa,EAAE,WAAW,KAAK,CAAC;AAAA,IAClE;AACA,QAAI,IAAI;AACR,QAAI,IAAI;AACR,QAAI,QAAQ,OAAO,SAAS,MAAM,GAAG;AACnC,YAAM,QAAQ,KAAK,MAAM,QAAQ,OAAO,SAAS,CAAC;AAClD,YAAM,WAAW,qBAAoB;AAAA,QACnC;AAAA,QACA,QAAQ,OAAO,KAAK;AAAA,QACpB;AAAA,MACF;AACA,UAAI,SAAS,CAAC,IAAI,iBAAiB,QAAQ;AAC3C,UAAI,SAAS,CAAC,IAAI,iBAAiB,SAAS;AAAA,IAC9C,OAAO;AACL,YAAM,QAAQ,QAAQ,OAAO,SAAS,IAAI;AAC1C,YAAM,qBAAqB,qBAAoB;AAAA,QAC7C;AAAA,QACA,QAAQ;AAAA,MACV;AAEA,UAAI,mBAAmB,CAAC,IAAI,iBAAiB,QAAQ;AACrD,UAAI,mBAAmB,CAAC,IAAI,iBAAiB,SAAS;AAAA,IACxD;AACA,WAAO,EAAE,GAAG,EAAE;AAAA,EAChB;AAAA,EAEA,OAAO,2BAA2B,CAChC,SACA,aACA,eACA,qBACqD;AACrD,QAAI,CAAC,IAAI,IAAI,IAAI,EAAE,IAAI;AACvB,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,EAAE,GAAG,aAAa,GAAG,YAAY,IACrC,qBAAoB;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACF,UAAM,cAAc,cAAc,iBAAiB;AACnD,UAAM,cAAc,cAAc,iBAAiB;AACnD,UAAM,cAAcA,WAAU,IAAI,EAAE;AAEpC,UAAM,sBAAsBW;AAAA,MAC1BX,WAAU,IAAI,EAAE;AAAA,MAChB;AAAA,MACA,QAAQ;AAAA,IACV;AACA,UAAM,uBAAuBW;AAAA,MAC3BX,WAAU,IAAI,EAAE;AAAA,MAChB;AAAA,MACA,QAAQ;AAAA,IACV;AAEA,UAAM,gCAAgCW;AAAA,MACpCX,WAAU,aAAa,WAAW;AAAA,MAClC;AAAA,MACA,CAAC,QAAQ;AAAA,IACX;AACA,UAAM,iCAAiCW;AAAA,MACrCX,WAAU,aAAa,WAAW;AAAA,MAClC;AAAA,MACA,CAAC,QAAQ;AAAA,IACX;AACA,UAAM,mCAAmCW;AAAA,MACvCX,WAAU,aAAa,WAAW;AAAA,MAClC;AAAA,MACA,CAAC,QAAQ;AAAA,IACX;AACA,UAAM,oCAAoCW;AAAA,MACxCX,WAAU,aAAa,WAAW;AAAA,MAClC;AAAA,MACA,CAAC,QAAQ;AAAA,IACX;AAEA,QACE,oBAAoB,CAAC,IAAI,qBAAqB,CAAC,KAC/C,oBAAoB,CAAC,KAAK,qBAAqB,CAAC,GAChD;AACA,WAAK,KAAK,IAAI,IAAI,iCAAiC,CAAC,CAAC;AACrD,WAAK,KAAK;AAAA,QACR;AAAA,QACA,KAAK;AAAA,UACH,+BAA+B,CAAC;AAAA,UAChC,kCAAkC,CAAC;AAAA,QACrC;AAAA,MACF;AACA,WAAK,KAAK,IAAI,IAAI,8BAA8B,CAAC,CAAC;AAElD,WAAK,KAAK,IAAI,IAAI,kCAAkC,CAAC,CAAC;AAAA,IACxD,WACE,oBAAoB,CAAC,KAAK,qBAAqB,CAAC,KAChD,oBAAoB,CAAC,IAAI,qBAAqB,CAAC,GAC/C;AACA,WAAK,KAAK,IAAI,IAAI,kCAAkC,CAAC,CAAC;AACtD,WAAK,KAAK;AAAA,QACR;AAAA,QACA,KAAK;AAAA,UACH,8BAA8B,CAAC;AAAA,UAC/B,+BAA+B,CAAC;AAAA,QAClC;AAAA,MACF;AACA,WAAK,KAAK,IAAI,IAAI,iCAAiC,CAAC,CAAC;AAErD,WAAK,KAAK,IAAI,IAAI,+BAA+B,CAAC,CAAC;AAAA,IACrD,WAAW,oBAAoB,CAAC,KAAK,qBAAqB,CAAC,GAAG;AAC5D,WAAK,KAAK,IAAI,IAAI,+BAA+B,CAAC,CAAC;AACnD,WAAK,KAAK,IAAI,IAAI,iCAAiC,CAAC,CAAC;AACrD,WAAK,KAAK,IAAI,IAAI,kCAAkC,CAAC,CAAC;AAEtD,WAAK,KAAK,IAAI,IAAI,8BAA8B,CAAC,CAAC;AAAA,IACpD,WAAW,oBAAoB,CAAC,KAAK,qBAAqB,CAAC,GAAG;AAC5D,WAAK,KAAK;AAAA,QACR;AAAA,QACA,KAAK;AAAA,UACH,+BAA+B,CAAC;AAAA,UAChC,8BAA8B,CAAC;AAAA,QACjC;AAAA,MACF;AAEA,WAAK,KAAK,IAAI,IAAI,kCAAkC,CAAC,CAAC;AACtD,WAAK,KAAK,IAAI,IAAI,+BAA+B,CAAC,CAAC;AACnD,WAAK,KAAK,IAAI,IAAI,iCAAiC,CAAC,CAAC;AAAA,IACvD;AAEA,WAAO,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;AAAA,EAChC;AAAA,EAEA,OAAO,2BAA2B,CAChC,SACA,aACA,mBAA4B,UACyB;AACrD,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI,QAAQ,OAAO,SAAS,KAAK,CAAC,WAAW,IAAI,OAAO,GAAG;AAEzD,YAAM,EAAE,MAAM,MAAM,MAAM,KAAK,IAAI,QAAQ,OAAO;AAAA,QAChD,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM;AAClB,iBAAO,OAAO,KAAK,IAAI,OAAO,MAAM,CAAC;AACrC,iBAAO,OAAO,KAAK,IAAI,OAAO,MAAM,CAAC;AAErC,iBAAO,OAAO,KAAK,IAAI,OAAO,MAAM,CAAC;AACrC,iBAAO,OAAO,KAAK,IAAI,OAAO,MAAM,CAAC;AAErC,iBAAO;AAAA,QACT;AAAA,QACA,EAAE,MAAM,UAAU,MAAM,UAAU,MAAM,WAAW,MAAM,UAAU;AAAA,MACrE;AACA,WAAK,OAAO,QAAQ;AACpB,WAAK,OAAO,QAAQ;AACpB,WAAK,OAAO,QAAQ;AACpB,WAAK,OAAO,QAAQ;AAAA,IACtB,OAAO;AACL,YAAM,QAAQ,WAAW,qBAAqB,SAAS,IAAI;AAG3D,YAAM,MAAM,gBAAgB,MAAM,CAAC,CAAC;AAEpC,YAAM,CAAC,MAAM,MAAM,MAAM,IAAI,IAAI,4BAA4B,GAAG;AAChE,WAAK,OAAO,QAAQ;AACpB,WAAK,OAAO,QAAQ;AACpB,WAAK,OAAO,QAAQ;AACpB,WAAK,OAAO,QAAQ;AAAA,IACtB;AACA,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,MAAM,KAAK,MAAM;AACvB,aAAS,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;AAEhC,QAAI,CAAC,kBAAkB;AACrB,aAAO;AAAA,IACT;AACA,UAAM,mBAAmB,oBAAoB,SAAS,WAAW;AACjE,QAAI,kBAAkB;AACpB,eAAS,qBAAoB;AAAA,QAC3B;AAAA,QACA;AAAA,QACA,CAAC,IAAI,IAAI,IAAI,EAAE;AAAA,QACf;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,iBACL,eACA,OACA,GACA,GACA,OACqB;AACrB,UAAM,cAAc,MAAM,yBAAyB;AACnD,UAAM,UAAU,qBAAoB;AAAA,MAClC,cAAc;AAAA,MACd;AAAA,IACF;AAEA,QAAI,CAAC,WAAW,CAAC,aAAa,OAAO,GAAG;AACtC,aAAO;AAAA,IACT;AAEA,QAAI,SAAS,QAAQ,KAAK,QAAQ,QAAQ,OAAO,QAAQ;AACvD,YAAM,eAAe;AAAA,QACnB;AAAA,UACEa,iBAAgB,QAAQ,OAAO,KAAK,GAAG,QAAQ,OAAO,QAAQ,CAAC,CAAC;AAAA,QAClE;AAAA,MACF;AAEA,YAAM,iBAAiB,QAAQ,iBAAiB,CAAC,GAAG;AAAA,QAClD,CAAC,UAAU,MAAM;AACf,mBAAS,EAAE,KAAK,IAAI;AACpB,iBAAO;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MACH;AACA,oBAAc,KAAK,IAAI;AAAA,QACrB;AAAA,QACA,OAAOb;AAAA,UACL,CAAC,eAAe,IAAI,QAAQ,IAAI,QAAQ,OAAO,QAAQ,CAAC,EAAE,CAAC;AAAA,UAC3D,eAAe,IAAI,QAAQ,IAAI,QAAQ,OAAO,QAAQ,CAAC,EAAE,CAAC;AAAA,QAC5D;AAAA,QACA,KAAKA;AAAA,UACH,CAAC,eAAe,IAAI,QAAQ,IAAI,QAAQ,OAAO,KAAK,EAAE,CAAC;AAAA,UACvD,eAAe,IAAI,QAAQ,IAAI,QAAQ,OAAO,KAAK,EAAE,CAAC;AAAA,QACxD;AAAA,MACF;AACA,YAAM,oBAAoB,OAAO,OAAO,aAAa,EAAE;AAAA,QACrD,CAACc,IAAGC,OAAMD,GAAE,QAAQC,GAAE;AAAA,MACxB;AAEA,YAAM,SAAS,kBACZ,IAAI,CAAC,YAAY,QAAQ,KAAK,EAC9B,OAAO,CAAC,OAAO,QAAS,MAAM,QAAQ,QAAQ,IAAI,OAAQ,CAAC;AAE9D,YAAM,cAAc,SAAS;AAAA,QAC3B,eAAe;AAAA,MACjB,CAAC;AAED,YAAM,QAAQf;AAAA,QACZ,QAAQ,KACL,QAAQ,cAAe,MAAM,EAAE,MAAM,CAAC,IACrC,QAAQ,cAAe,MAAM,EAAE,IAAI,CAAC,KACpC;AAAA,QACJ,QAAQ,KACL,QAAQ,cAAe,MAAM,EAAE,MAAM,CAAC,IACrC,QAAQ,cAAe,MAAM,EAAE,IAAI,CAAC,KACpC;AAAA,MACN;AAEA,aAAO;AAAA,QACL,GAAG;AAAA,QACH,8BAA8B;AAAA,QAC9B,kBAAkB;AAAA,UAChB,GAAG,cAAc;AAAA,UACjB,iBAAiB;AAAA,YACf,OAAO;AAAA,YACP,OAAO,QAAQ,cAAe,MAAM,EAAE;AAAA,YACtC,OAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,mBACL,SACA,OACA,OACM;AACN,UAAM,cAAc,SAAS;AAAA,MAC3B,eAAe,QAAQ,eAAe;AAAA,QACpC,CAAC,YAAY,QAAQ,UAAU;AAAA,MACjC;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEA,IAAM,0BAA0B,CAC9B,WACoB;AACpB,MAAI,aAAa;AAAA,IACf,GAAG,IAAI,IAAI,OAAO,OAAO,CAAC,MAAM,MAAM,QAAQ,MAAM,EAAE,CAAC;AAAA,EACzD;AACA,eAAa,WAAW,KAAK,CAACc,IAAGC,OAAMD,KAAIC,EAAC;AAC5C,SAAO,WAAW,SAAS,aAAa;AAC1C;;;Aa17DA;AAAA,SAAS,cAAAC,mBAAkB;AAC3B,SAAS,uBAAAC,sBAAqB,aAAAC,mBAAiB;;;ACD/C;AAAA;AAAA,EACE,eAAAC;AAAA,EACA,mBAAAC;AAAA,OAGK;AAMA,SAAS,QACdC,OACQ;AACR,SAAO;AAAA,IACL,KAAK,IAAIA,MAAK,CAAC,EAAE,CAAC,GAAGA,MAAK,CAAC,EAAE,CAAC,CAAC;AAAA,IAC/B,KAAK,IAAIA,MAAK,CAAC,EAAE,CAAC,GAAGA,MAAK,CAAC,EAAE,CAAC,CAAC;AAAA,IAC/B,KAAK,IAAIA,MAAK,CAAC,EAAE,CAAC,GAAGA,MAAK,CAAC,EAAE,CAAC,CAAC;AAAA,IAC/B,KAAK,IAAIA,MAAK,CAAC,EAAE,CAAC,GAAGA,MAAK,CAAC,EAAE,CAAC,CAAC;AAAA,EACjC;AACF;AAEO,SAAS,kBAAkBC,IAAWC,IAAW;AACtD,SAAOD,GAAE,CAAC,KAAKC,GAAE,CAAC,KAAKD,GAAE,CAAC,KAAKC,GAAE,CAAC,KAAKD,GAAE,CAAC,KAAKC,GAAE,CAAC,KAAKD,GAAE,CAAC,KAAKC,GAAE,CAAC;AACpE;AAEA,IAAM,UAAU;AAET,SAAS,cACdC,IACA,GACA;AACA,QAAM,KAAKJ,iBAAgBI,GAAE,CAAC,GAAGA,GAAE,CAAC,CAAC;AACrC,QAAM,KAAKJ,iBAAgB,GAAGI,GAAE,CAAC,CAAC;AAElC,QAAM,IAAIL,aAAY,IAAI,EAAE;AAE5B,SAAO,KAAK,IAAI,CAAC,IAAI;AACvB;AAEO,SAAS,mBACdK,IACA,GACA;AACA,QAAM,KAAKJ,iBAAgBI,GAAE,CAAC,GAAGA,GAAE,CAAC,CAAC;AACrC,QAAM,KAAKJ,iBAAgB,GAAGI,GAAE,CAAC,CAAC;AAElC,SAAOL,aAAY,IAAI,EAAE,IAAI;AAC/B;AAEO,SAAS,oCAEdG,IAAmBC,IAAmB;AACtC,SACE,cAAcD,IAAGC,GAAE,CAAC,CAAC,KACrB,cAAcD,IAAGC,GAAE,CAAC,CAAC,MACpB,mBAAmBD,IAAGC,GAAE,CAAC,CAAC,IACvB,CAAC,mBAAmBD,IAAGC,GAAE,CAAC,CAAC,IAC3B,mBAAmBD,IAAGC,GAAE,CAAC,CAAC;AAElC;AAGO,SAAS,wBACdD,IACAC,IACA;AACA,SACE,kBAAkB,QAAQD,EAAC,GAAG,QAAQC,EAAC,CAAC,KACxC,oCAAoCD,IAAGC,EAAC,KACxC,oCAAoCA,IAAGD,EAAC;AAE5C;;;ACxEA;AAAA,SAAS,cAAAG,mBAAkB;AAC3B,SAAS,oBAAAC,yBAAwB;AACjC;AAAA,EACE,kBAAAC;AAAA,EACA,uBAAAC;AAAA,EACA,qBAAAC;AAAA,EACA,mBAAAC;AAAA,EACA,iBAAAC;AAAA,OACK;AACP;AAAA,EACE;AAAA,EACA,aAAAC;AAAA,EACA,mBAAAC;AAAA,EACA;AAAA,OACK;AAiBP,IAAM,oCAAoC,CACxC,YASG;AACH,MAAI,QAAQ,SAAS,WAAW;AAC9B,WAAO;AAAA,MACLD,WAAU,QAAQ,QAAQ,GAAG,CAAC;AAAA,MAC9BA,WAAU,QAAQ,OAAO,QAAQ,SAAS,CAAC;AAAA,MAC3CA,WAAU,QAAQ,QAAQ,GAAG,QAAQ,MAAM;AAAA,MAC3CA,WAAU,GAAG,QAAQ,SAAS,CAAC;AAAA,IACjC;AAAA,EACF;AACA,SAAO;AAAA,IACLA,WAAU,GAAG,CAAC;AAAA,IACdA,WAAU,IAAI,QAAQ,OAAO,CAAC;AAAA,IAC9BA,WAAU,IAAI,QAAQ,OAAO,QAAQ,MAAM;AAAA,IAC3CA,WAAU,GAAG,QAAQ,MAAM;AAAA,EAC7B;AACF;AAGA,IAAM,2BAA2B,CAAC,YAAuC;AACvE,MAAIF,iBAAgB,OAAO,KAAKD,mBAAkB,OAAO,GAAG;AAC1D,WAAO,QAAQ;AAAA,EACjB;AACA,SAAO,kCAAkC,OAAO;AAClD;AAEA,IAAM,kBAAkB,CAAC,WAAmB;AAC1C,QAAM,MAAM,OAAO;AAAA,IACjB,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM;AAClB,aAAO,OAAO,KAAK,IAAI,OAAO,MAAM,CAAC;AACrC,aAAO,OAAO,KAAK,IAAI,OAAO,MAAM,CAAC;AAErC,aAAO,OAAO,KAAK,IAAI,OAAO,MAAM,CAAC;AACrC,aAAO,OAAO,KAAK,IAAI,OAAO,MAAM,CAAC;AAErC,aAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,IAAI;AAAA,MACJ,IAAI;AAAA,IACN;AAAA,EACF;AAEA,MAAI,MAAM,IAAI,OAAO,IAAI,QAAQ;AACjC,MAAI,MAAM,IAAI,OAAO,IAAI,QAAQ;AAEjC,SAAO;AACT;AAEA,IAAM,iBAAiB,CAAC,YAA6B;AACnD,QAAM,SAAS,yBAAyB,OAAO;AAE/C,QAAM,EAAE,IAAI,GAAG,IAAI,gBAAgB,MAAM;AACzC,QAAM,cAAcG,WAAsB,IAAI,EAAE;AAEhD,QAAM,gBAAgB,OAAO;AAAA,IAAI,CAAC,MAChCC,iBAAgB,GAAG,aAAa,QAAQ,KAAK;AAAA,EAC/C;AACA,QAAM,EAAE,MAAM,MAAM,MAAM,KAAK,IAAI,gBAAgB,aAAa;AAEhE,SAAO;AAAA,IACL,OAAO,QAAQ;AAAA,IACf,OAAO,QAAQ;AAAA,IACf,OAAO,QAAQ;AAAA,IACf,OAAO,QAAQ;AAAA,EACjB;AACF;AAEO,IAAM,sBAAsB,CACjC,SACA,MACA,kBAAkB,UACN;AACZ,QAAM,cAAc,eAAe,OAAO;AAE1C,QAAM,oBACJ,KAAK,CAAC,KAAK,YAAY,CAAC,KACxB,KAAK,CAAC,KAAK,YAAY,CAAC,KACxB,KAAK,CAAC,KAAK,YAAY,CAAC,KACxB,KAAK,CAAC,KAAK,YAAY,CAAC;AAE1B,MAAI,CAAC,iBAAiB;AACpB,WAAO;AAAA,EACT;AAEA,MAAI,mBAAmB;AACrB,WAAO;AAAA,EACT;AAEA,SACE,YAAY,CAAC,KAAK,KAAK,CAAC,KACxB,YAAY,CAAC,KAAK,KAAK,CAAC,KACxB,YAAY,CAAC,KAAK,KAAK,CAAC,KACxB,YAAY,CAAC,KAAK,KAAK,CAAC;AAE5B;AAEO,IAAM,6CAA6C,CACxD,SACA,SACY;AACZ,QAAM,cAAc,eAAe,OAAO;AAE1C,UACG,mBAAmB,YAAY,CAAC,GAAG,eAAe,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,KAClE;AAAA,IACE,KAAK,CAAC;AAAA,IACN,eAAe,YAAY,CAAC,GAAG,YAAY,CAAC,CAAC;AAAA,EAC/C,OACD,mBAAmB,YAAY,CAAC,GAAG,eAAe,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,KAClE;AAAA,IACE,KAAK,CAAC;AAAA,IACN,eAAe,YAAY,CAAC,GAAG,YAAY,CAAC,CAAC;AAAA,EAC/C;AAEN;AAEO,IAAM,0BAA0B,CAAC;AAAA,EACtC;AAAA,EACA;AAAA,EACA;AAAA,EACA,cAAc;AAChB,MAWM;AACJ,MAAIL,qBAAoB,MAAM,GAAG;AAC/B,aAASF,kBAAiB,QAAQD,YAAW,QAAQ,CAAC;AAAA,EACxD;AACA,QAAM,eAAuB;AAAA,IAC3B,OAAO,CAAC,IAAI;AAAA,IACZ,OAAO,CAAC,IAAI;AAAA,IACZ,OAAO,CAAC,IAAI;AAAA,IACZ,OAAO,CAAC,IAAI;AAAA,EACd;AAEA,QAAM,qBAAqB,oBAAI,IAAY;AAE3C,aAAW,WAAW,UAAU;AAC9B,QAAI,mBAAmB,IAAI,QAAQ,EAAE,GAAG;AACtC;AAAA,IACF;AAEA,UAAM,eACJ,SAAS,YACL,2CAA2C,SAAS,YAAY,IAChE,SAAS,WACT,oBAAoB,SAAS,YAAY,IACzC,oBAAoB,SAAS,cAAc,IAAI;AAErD,QAAI,cAAc;AAChB,yBAAmB,IAAI,QAAQ,EAAE;AAEjC,UAAI,QAAQ,eAAe;AACzB,mBAAW,gBAAgB,QAAQ,eAAe;AAChD,6BAAmB,IAAI,aAAa,EAAE;AAAA,QACxC;AAAA,MACF;AAEA,UAAIM,eAAc,OAAO,KAAK,QAAQ,aAAa;AACjD,2BAAmB,IAAI,QAAQ,WAAW;AAAA,MAC5C;AAEA,UAAIJ,gBAAe,OAAO,GAAG;AAC3B,YAAI,QAAQ,cAAc;AACxB,6BAAmB,IAAI,QAAQ,aAAa,SAAS;AAAA,QACvD;AAEA,YAAI,QAAQ,YAAY;AACtB,6BAAmB,IAAI,QAAQ,YAAY,SAAS;AAAA,QACtD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO,SAAS,OAAO,CAAC,YAAY,mBAAmB,IAAI,QAAQ,EAAE,CAAC;AACxE;;;ACpOA;AAAA,SAAS,cAAAO,aAAY,sBAAsB;;;ACA3C;AAoBO,IAAM,cAAc,CACzB,SACA,UACA,aAIG;AACH,QAAM,kBAAkB,SAAS;AAAA,IAC/B,CAAC,KAA2B,YAAY;AACtC,UAAI,QAAQ,SAAS,SAAS,OAAO,GAAG;AACtC,YAAI,QAAQ,EAAE,IAAI;AAAA,MACpB;AACA,aAAO;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EACH;AAEA,MAAI,OAAO,KAAK,eAAe,EAAE,SAAS,GAAG;AAC3C,QACE,SAAS,iBAAiB,OAAO,KACjC,SAAS,mBAAmB,SAC5B;AACA,aAAO;AAAA,QACL,oBAAoB,SAAS;AAAA,QAC7B,kBAAkB,EAAE,GAAG,SAAS,kBAAkB,CAAC,OAAO,GAAG,MAAM;AAAA,QACnE,gBAAgB;AAAA,MAClB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,gBAAgB,SAAS;AAAA,IACzB,kBAAkB,EAAE,GAAG,SAAS,kBAAkB,CAAC,OAAO,GAAG,KAAK;AAAA,IAClE,oBAAoB;AAAA,MAClB,GAAG,SAAS;AAAA,MACZ,GAAG;AAAA,IACL;AAAA,EACF;AACF;AAEO,IAAM,kCAAmC,WAAY;AAM1D,MAAI,uBACF;AACF,MAAI,eAAgE;AACpE,MAAI,kBAAiD;AAErD,QAAM,gBAAgB,CACpB,kBACA,UACA,UACA,iBAC2B;AAC3B,QACE,oBAAoB,UACpB,aAAa,gBACb,qBAAqB,wBACrB,SAAS,mBAAmB,iBAAiB,gBAC7C;AACA,aAAO;AAAA,IACT;AAEA,UAAM,mBAA6C,CAAC;AAEpD,eAAW,mBAAmB,kBAAkB;AAC9C,UAAI,WAAW,gBAAgB;AAC/B,UAAI,SAAS,gBAAgB;AAE3B,cAAM,sBAAsB,SAAS,QAAQ,SAAS,cAAc;AACpE,YAAI,sBAAsB,IAAI;AAC5B,qBAAW,SAAS,MAAM,GAAG,mBAAmB;AAAA,QAClD;AAAA,MACF;AACA,UAAI,SAAS,SAAS,GAAG;AACvB,cAAM,oBAAoB,SAAS,SAAS,SAAS,CAAC;AACtD,yBAAiB,iBAAiB,IAAI;AAAA,MACxC;AAAA,IACF;AAGA,UAAM,qBAAgD,CAAC;AACvD,UAAM,6BAA6B,SAAS;AAAA,MAC1C,CAAC,KAA2B,YAAY;AACtC,YAAI,QAAQ,WAAW;AACrB,iBAAO;AAAA,QACT;AAEA,cAAM,UAAU,QAAQ,SAAS,KAAK,CAAC,OAAO,iBAAiB,EAAE,CAAC;AAElE,YAAI,SAAS;AACX,cAAI,QAAQ,EAAE,IAAI;AAGlB,cAAI,CAAC,MAAM,QAAQ,mBAAmB,OAAO,CAAC,GAAG;AAC/C,+BAAmB,OAAO,IAAI,CAAC,QAAQ,EAAE;AAAA,UAC3C,OAAO;AACL,+BAAmB,OAAO,EAAE,KAAK,QAAQ,EAAE;AAAA,UAC7C;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IACH;AAEA,eAAW,WAAW,OAAO,KAAK,kBAAkB,GAAG;AAErD,UAAI,mBAAmB,OAAO,EAAE,SAAS,GAAG;AAC1C,YAAI,iBAAiB,OAAO,GAAG;AAC7B,2BAAiB,OAAO,IAAI;AAAA,QAC9B;AAAA,MACF;AAAA,IACF;AAEA,mBAAe;AACf,2BAAuB;AAEvB,sBAAkB;AAAA,MAChB,gBAAgB,SAAS;AAAA,MACzB;AAAA,MACA,oBAAoB;AAAA,QAClB;AAAA,UACE,GAAG,SAAS;AAAA,UACZ,GAAG;AAAA,QACL;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAMA,QAAMC,mCAAkC,CACtC,UACA,UACA,cAKA,QAMG;AACH,UAAM,mBAAmB,MACrB,IAAI,MAAM,oBAAoB;AAAA,MAC5B,oBAAoB,SAAS;AAAA;AAAA,MAE7B;AAAA,IACF,CAAC,IACD,oBAAoB,UAAU,QAAQ;AAE1C,QAAI,CAAC,iBAAiB,QAAQ;AAC5B,aAAO;AAAA,QACL,kBAAkB,CAAC;AAAA,QACnB,gBAAgB;AAAA,QAChB,oBAAoB;AAAA,UAClB,SAAS;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,cAAc,kBAAkB,UAAU,UAAU,YAAY;AAAA,EACzE;AAEA,EAAAA,iCAAgC,aAAa,MAAM;AACjD,mBAAe;AACf,2BAAuB;AACvB,sBAAkB;AAAA,EACpB;AAEA,SAAOA;AACT,EAAG;AAMI,IAAM,qBAAqB,CAChC,UACA,YACG,2BAA2B,UAAU,OAAO,KAAK;AAE/C,IAAM,6BAA6B,CACxC,UAIA,YAEA,QAAQ,SACL,OAAO,CAAC,YAAY,YAAY,SAAS,cAAc,EACvD,KAAK,CAAC,YAAY,SAAS,iBAAiB,OAAO,CAAC;AAElD,IAAM,sBAAsB,CACjC,aAEA,OAAO,QAAQ,SAAS,gBAAgB,EACrC,OAAO,CAAC,CAAC,SAAS,UAAU,MAAM,UAAU,EAC5C,IAAI,CAAC,CAAC,SAAS,UAAU,MAAM,OAAO;AAIpC,IAAM,gCAAgC,CAC3C,UACA,aACG;AACH,MAAI,eAA0C;AAAA,IAC5C,GAAG;AAAA,IACH,kBAAkB,CAAC;AAAA,EACrB;AAEA,aAAW,WAAW,UAAU;AAC9B,QAAI,WAAW,QAAQ;AACvB,QAAI,SAAS,gBAAgB;AAC3B,YAAM,sBAAsB,SAAS,QAAQ,SAAS,cAAc;AACpE,UAAI,sBAAsB,IAAI;AAC5B,mBAAW,SAAS,MAAM,GAAG,mBAAmB;AAAA,MAClD;AAAA,IACF;AACA,QAAI,SAAS,SAAS,GAAG;AACvB,YAAM,UAAU,SAAS,SAAS,SAAS,CAAC;AAC5C,qBAAe;AAAA,QACb,GAAG;AAAA,QACH,GAAG,YAAY,SAAS,cAAc,QAAQ;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AAEA,SAAO,aAAa;AACtB;AAEO,IAAM,8BAA8B,CACzC,UACA,YACa;AACb,SAAO;AAAA,IACL,GAAG;AAAA,IACH,gBAAgB,QAAQ,SAAS,SAAS,QAAQ,SAAS,CAAC,IAAI;AAAA,IAChE,kBAAkB,CAAC;AAAA,IACnB,oBAAoB;AAAA,MAClB,CAAC,QAAQ,EAAE,GAAG;AAAA,IAChB;AAAA,EACF;AACF;AAEO,IAAM,mBAAmB,CAAC,SAA4B,YAC3D,QAAQ,SAAS,SAAS,OAAO;AAE5B,IAAM,qBAAqB,CAChC,UACA,YACG;AACH,QAAM,kBAAuC,CAAC;AAC9C,aAAW,WAAW,SAAS,OAAO,GAAG;AACvC,QAAI,iBAAiB,SAAS,OAAO,GAAG;AACtC,sBAAgB,KAAK,OAAO;AAAA,IAC9B;AAAA,EACF;AACA,SAAO;AACT;AAEO,IAAM,+BAA+B,CAC1C,SACA,qBACG,QAAQ,SAAS,KAAK,CAAC,YAAY,iBAAiB,OAAO,CAAC;AAE1D,IAAM,aAAa,CACxB,cACA,YACA,mBACG;AAEH,QAAM,WAAW,CAAC,GAAG,YAAY;AACjC,QAAM,2BAA2B,iBAC7B,SAAS,QAAQ,cAAc,IAC/B;AACJ,QAAM,mBACJ,2BAA2B,KAAK,2BAA2B,SAAS;AACtE,WAAS,OAAO,kBAAkB,GAAG,UAAU;AAC/C,SAAO;AACT;AAEO,IAAM,2BAA2B,CACtC,UACA,qBACG,SAAS,OAAO,CAAC,YAAY,CAAC,iBAAiB,OAAO,CAAC;AAErD,IAAM,mBAAmB,CAC9B,UACA,gBAC0B;AAC1B,QAAM,SAA2C,oBAAI,IAGnD;AACF,WAAS,QAAQ,CAAC,YAA+B;AAC/C,UAAM,UACJ,QAAQ,SAAS,WAAW,IACxB,QAAQ,KACR,QAAQ,SAAS,QAAQ,SAAS,SAAS,CAAC;AAElD,UAAM,sBAAsB,OAAO,IAAI,OAAO,KAAK,CAAC;AAGpD,UAAM,mBAAmB,oBAAoB,SAAS,WAAW;AACjE,QAAI,kBAAkB;AACpB,0BAAoB,KAAK,gBAAgB;AAAA,IAC3C;AACA,WAAO,IAAI,SAAS,CAAC,GAAG,qBAAqB,OAAO,CAAC;AAAA,EACvD,CAAC;AAED,SAAO,MAAM,KAAK,OAAO,OAAO,CAAC;AACnC;AAEO,IAAM,wBAAwB,CAAC,aAA0B;AAC9D,QAAM,qBAAqB,oBAAI,IAAY;AAE3C,aAAW,CAAC,EAAE,OAAO,KAAK,UAAU;AAElC,QAAI,QAAQ,WAAW;AACrB;AAAA,IACF;AAGA,eAAW,WAAW,QAAQ,YAAY,CAAC,GAAG;AAC5C,yBAAmB,IAAI,OAAO;AAAA,IAChC;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,yBAAyB,CACpC,aACG;AACH,QAAM,YAAY,SAAS,QAAQ,CAAC,YAAY,QAAQ,QAAQ;AAChE,QAAM,aAAa,oBAAI,IAAoB;AAC3C,MAAI,WAAW;AAEf,aAAW,SAAS,WAAW;AAC7B,eAAW,IAAI,QAAQ,WAAW,IAAI,KAAK,KAAK,KAAK,CAAC;AACtD,QAAI,WAAW,IAAI,KAAK,IAAK,UAAU;AACrC,iBAAW,WAAW,IAAI,KAAK;AAAA,IACjC;AAAA,EACF;AAEA,SAAO,aAAa,SAAS;AAC/B;AAEO,IAAM,YAAY,CAAC,YAAyC;AACjE,SAAO,QAAQ,SAAS,SAAS;AACnC;AAEO,IAAM,+BAA+B,CAC1C,UACA,gBACA,WACG;AACH,QAAM,OAAO,CAAC,GAAG,QAAQ;AACzB,QAAM,2BAA2B,iBAC7B,SAAS,QAAQ,cAAc,IAC/B;AACJ,QAAM,WACJ,2BAA2B,KAAK,2BAA2B,SAAS;AACtE,WAAS,QAAQ,GAAG,QAAQ,UAAU,SAAS;AAC7C,SAAK,KAAK,IAAI,OAAO,KAAK,KAAK,CAAC;AAAA,EAClC;AAEA,SAAO;AACT;;;AD/WO,IAAM,uCAAuC,CAGlD,qBACG;AACH,QAAM,oBAAoB,oBAAI,IAAa;AAE3C,mBAAiB,QAAQ,CAAC,YAAY;AACpC,QAAI,mBAAmB,OAAO,GAAG;AAC/B,wBAAkB,IAAI,QAAQ,EAAE;AAAA,IAClC;AAAA,EACF,CAAC;AAED,SAAO,iBAAiB,OAAO,CAAC,YAAY;AAC1C,QAAI,QAAQ,WAAW,kBAAkB,IAAI,QAAQ,OAAO,GAAG;AAC7D,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AACH;AAEO,IAAM,6BAA6B,CACxC,UACA,WACA,aACA,0BAAmC,SAChC;AACH,QAAM,CAAC,aAAa,aAAa,aAAa,WAAW,IACvDC,0BAAyB,WAAW,WAAW;AAEjD,MAAI,sBAAsB,SAAS,OAAO,CAAC,YAAY;AACrD,QAAI,CAAC,WAAW,WAAW,WAAW,SAAS,IAAI;AAAA,MACjD;AAAA,MACA;AAAA,IACF;AAEA,UAAM,kBAAkB,mBAAmB,SAAS,WAAW;AAC/D,QAAI,iBAAiB;AACnB,YAAM,CAAC,KAAK,KAAK,KAAK,GAAG,IAAI;AAAA,QAC3B;AAAA,QACA;AAAA,MACF;AAEA,kBAAY,KAAK,IAAI,KAAK,SAAS;AACnC,kBAAY,KAAK,IAAI,KAAK,SAAS;AACnC,kBAAY,KAAK,IAAI,KAAK,SAAS;AACnC,kBAAY,KAAK,IAAI,KAAK,SAAS;AAAA,IACrC;AAEA,WACE,QAAQ,WAAW,SACnB,QAAQ,SAAS,eACjB,CAAC,mBAAmB,OAAO,KAC3B,eAAe,aACf,eAAe,aACf,eAAe,aACf,eAAe;AAAA,EAEnB,CAAC;AAED,wBAAsB,0BAClB,qCAAqC,mBAAmB,IACxD;AAEJ,wBAAsB,oBAAoB,OAAO,CAAC,YAAY;AAC5D,UAAM,kBAAkB,mBAAmB,SAAS,WAAW;AAE/D,QAAI,iBAAiB;AACnB,aAAO,yBAAyB,SAAS,iBAAiB,WAAW;AAAA,IACvE;AAEA,WAAO;AAAA,EACT,CAAC;AAED,SAAO;AACT;AAEO,IAAM,mCAAmC,CAC9C,UACA,kBACA,UACA,gBACG;AACH,QAAM,sBAAsB,IAAI;AAAA,IAC9B,iBAAiB,IAAI,CAAC,YAAY,QAAQ,EAAE;AAAA,EAC9C;AACA,SAAO,SAAS,OAAO,CAAC,YAAY;AAClC,UAAM,YAAY;AAAA,MAChB;AAAA,MACA,SAAS;AAAA,MACT,SAAS;AAAA,MACT;AAAA,MACA;AAAA,IACF;AAEA,WAAO,CAAC,oBAAoB,IAAI,QAAQ,EAAE,KAAK;AAAA,EACjD,CAAC;AACH;AAGO,IAAM,wBAAyB,WAAY;AAChD,MAAI,eAA8D;AAClE,MAAI,yBAAgE;AACpE,MAAI,aAA6B;AAEjC,QAAM,MAAM,CACV,UACA,aACY;AACZ,QACE,cAAc,QACd,aAAa,gBACb,SAAS,uBAAuB,wBAChC;AACA,aAAO;AAAA,IACT;AAEA,iBAAa,SAAS;AAAA,MACpB,CAAC,YAAY,SAAS,mBAAmB,QAAQ,EAAE;AAAA,IACrD;AACA,mBAAe;AACf,6BAAyB,SAAS;AAElC,WAAO;AAAA,EACT;AAEA,MAAI,aAAa,MAAM;AACrB,mBAAe;AACf,6BAAyB;AACzB,iBAAa;AAAA,EACf;AAEA,SAAO;AACT,EAAG;AAEI,IAAM,sBAAsB,CACjC,UACA,UACA,SAIG;AACH,QAAM,gBAAgB,oBAAI,IAA6B;AACvD,QAAM,mBAAwC,CAAC;AAC/C,aAAW,WAAW,SAAS,OAAO,GAAG;AACvC,QAAI,SAAS,mBAAmB,QAAQ,EAAE,GAAG;AAC3C,uBAAiB,KAAK,OAAO;AAC7B,oBAAc,IAAI,QAAQ,EAAE;AAC5B;AAAA,IACF;AACA,QACE,MAAM,2BACN,mBAAmB,OAAO,KAC1B,SAAS,mBAAmB,SAAS,WAAW,GAChD;AACA,uBAAiB,KAAK,OAAO;AAC7B,oBAAc,IAAI,QAAQ,EAAE;AAC5B;AAAA,IACF;AAAA,EACF;AAEA,MAAI,MAAM,yBAAyB;AACjC,UAAM,oBAAyC,CAAC;AAChD,qBAAiB,QAAQ,CAAC,YAAY;AACpC,UAAI,mBAAmB,OAAO,GAAG;AAC/B,yBAAiB,UAAU,QAAQ,EAAE,EAAE;AAAA,UACrC,CAAC,MAAM,CAAC,cAAc,IAAI,EAAE,EAAE,KAAK,kBAAkB,KAAK,CAAC;AAAA,QAC7D;AAAA,MACF;AACA,wBAAkB,KAAK,OAAO;AAAA,IAChC,CAAC;AAED,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,IAAM,oBAAoB,CAC/B,UACA,aAKA,SAAS,qBACL,CAAC,SAAS,kBAAkB,IAC5B,SAAS,aACT,CAAC,SAAS,UAAU,IACpB,oBAAoB,UAAU,UAAU;AAAA,EACtC,yBAAyB;AAC3B,CAAC;AAMA,IAAM,6BAA6B,CACxC,wBACA,cACG;AACH,MAAI,eAAe,UAAU,oBAAoB,sBAAsB,GAAG;AACxE,WAAO,UAAU;AAAA,EACnB;AAEA,SAAO;AACT;AAEA,IAAM,0BAA0B,CAC9B,gBACA,gBACG;AACH,QAAM,UAAU,eAAe,OAAO,eAAe;AACrD,MAAI,QAAQ,WAAW,GAAG;AACxB,UAAM,SAAS,QAAQ,CAAC;AACxB,UAAM,gBAAgB,OAAO,eAAe,IAAI,CAAC,QAAQ,IAAI,EAAE,KAAK,CAAC;AACrE,UAAM,2BAA2B,eAAe;AAAA,MAC9C,CAAC,OAAO,GAAG,OAAO,OAAO,MAAM,cAAc,SAAS,GAAG,EAAE;AAAA,IAC7D;AAEA,QAAI,0BAA0B;AAC5B,aAAO,IAAI,oBAAoB,QAAQC,YAAW,WAAW,CAAC;AAAA,IAChE;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,+BAA+B,CAC1C,gBACA,aACA,aACG;AACH,SAAO;AAAA,IACL,uBAAuB,wBAAwB,gBAAgB,WAAW;AAAA,IAC1E,GAAG;AAAA,MACD;AAAA,QACE,gBAAgB,SAAS;AAAA,QACzB,oBAAoB;AAAA,UAClB;AAAA,QACF,EAAE,OAAO,CAAC,KAA4C,YAAY;AAChE,cAAI,CAAC,mBAAmB,OAAO,GAAG;AAChC,gBAAI,QAAQ,EAAE,IAAI;AAAA,UACpB;AACA,iBAAO;AAAA,QACT,GAAG,CAAC,CAAC;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;AHxPO,IAAM,uCAAuC,CAClD,cACA,cACA,wBACG;AACH,QAAM,iBAAiBC,YAAW,YAAY;AAK9C,aAAW,WAAW,cAAc;AAClC,QAAI,QAAQ,SAAS;AAEnB,YAAM,gBAAgB,oBAAoB,IAAI,QAAQ,EAAE;AACxD,YAAM,cAAc,oBAAoB,IAAI,QAAQ,OAAO;AAC3D,YAAM,cAAc,iBAAiB,eAAe,IAAI,aAAa;AACrE,UAAI,aAAa;AACf,sBAAc,aAAa,gBAAgB;AAAA,UACzC,SAAS,eAAe;AAAA,QAC1B,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;AAEO,SAAS,2BACd,SACA,OACA,aACA;AACA,QAAM,oBAAoB,uBAAuB,OAAO,WAAW;AAEnE,QAAM,sBAAsB,uBAAuB,SAAS,WAAW;AAEvE,QAAM,eAAe,kBAAkB;AAAA,IAAK,CAAC,qBAC3C,oBAAoB;AAAA,MAAK,CAAC,uBACxB,wBAAwB,kBAAkB,kBAAkB;AAAA,IAC9D;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,+BAA+B,CAC1C,UACA,OACA,gBAEA;AAAA,EACE,2BAA2B,UAAU,OAAO,aAAa,KAAK;AAChE,EAAE;AAAA,EACA,CAAC,YACE,CAAC,mBAAmB,OAAO,KAAK,CAAC,QAAQ,WAC1C,QAAQ,YAAY,MAAM;AAC9B;AAEK,IAAM,2BAA2B,CACtC,SACA,OACA,gBACG;AACH,SAAO,2BAA2B,CAAC,KAAK,GAAG,SAAS,WAAW,EAAE;AAAA,IAC/D,CAAC,MAAM,EAAE,OAAO,MAAM;AAAA,EACxB;AACF;AAEO,IAAM,+BAA+B,CAC1C,UACA,UACG;AACH,QAAM,cAAcA,YAAW,QAAQ;AACvC,SAAO,SAAS;AAAA,IAAO,CAAC,YACtB,2BAA2B,SAAS,OAAO,WAAW;AAAA,EACxD;AACF;AAEO,IAAM,2BAA2B,CACtC,UACA,OACA,gBACG;AACH,QAAM,CAAC,SAAS,SAAS,SAAS,OAAO,IAAIC;AAAA,IAC3C;AAAA,IACA;AAAA,EACF;AAEA,QAAM,CAAC,WAAW,WAAW,WAAW,SAAS,IAC/C,gBAAgB,QAAQ;AAE1B,SACE,WAAW,aACX,WAAW,aACX,WAAW,aACX,WAAW;AAEf;AAEO,IAAM,2BAA2B,CACtC,SACA,OACA,gBACG;AACH,SACE,yBAAyB,CAAC,OAAO,GAAG,OAAO,WAAW,KACtD,2BAA2B,SAAS,OAAO,WAAW,KACtD,yBAAyB,SAAS,OAAO,WAAW;AAExD;AAEO,IAAM,kBAAkB,CAC7B,cAIA,OACA,gBACG;AACH,QAAM,CAAC,KAAK,KAAK,KAAK,GAAG,IAAIA,0BAAyB,OAAO,WAAW;AAExE,SAAOC;AAAA,IACLC,YAAU,KAAK,GAAG;AAAA,IAClBA,YAAU,aAAa,GAAG,aAAa,CAAC;AAAA,IACxCA,YAAU,KAAK,GAAG;AAAA,EACpB;AACF;AAEO,IAAM,uCAAuC,CAClD,UACA,UACA,UACG;AACH,QAAM,cAAcH,YAAW,QAAQ;AACvC,QAAM,kBAAkB,SAAS;AAAA,IAAQ,CAAC,YACxC,mBAAmB,UAAU,OAAO;AAAA,EACtC;AAEA,MAAI,gBAAgB,WAAW,GAAG;AAChC,WAAO;AAAA,EACT;AAEA,SAAO,CAAC,CAAC,gBAAgB;AAAA,IACvB,CAAC,YACC,yBAAyB,CAAC,OAAO,GAAG,OAAO,WAAW,KACtD,2BAA2B,SAAS,OAAO,WAAW;AAAA,EAC1D;AACF;AAEO,IAAM,gCAAgC,CAC3C,UACA,UACA,UACG;AACH,QAAM,cAAcA,YAAW,QAAQ;AACvC,QAAM,kBAAkB,SAAS;AAAA,IAAQ,CAAC,YACxC,mBAAmB,UAAU,OAAO;AAAA,EACtC;AAEA,MAAI,gBAAgB,WAAW,GAAG;AAChC,WAAO;AAAA,EACT;AAEA,SACE,gBAAgB;AAAA,IACd,CAAC,YACC,yBAAyB,CAAC,OAAO,GAAG,OAAO,WAAW,KACtD,2BAA2B,SAAS,OAAO,WAAW;AAAA,EAC1D,MAAM;AAEV;AAOO,IAAM,oBAAoB,CAAC,aAA2C;AAC3E,QAAM,mBAAmB,oBAAI,IAG3B;AAEF,aAAW,WAAW,UAAU;AAC9B,UAAM,UAAU,mBAAmB,OAAO,IAAI,QAAQ,KAAK,QAAQ;AACnE,QAAI,WAAW,CAAC,iBAAiB,IAAI,OAAO,GAAG;AAC7C,uBAAiB,IAAI,SAAS,iBAAiB,UAAU,OAAO,CAAC;AAAA,IACnE;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,mBAAmB,CAC9B,aACA,YACG;AACH,QAAM,gBAAqC,CAAC;AAC5C,aAAW,WAAW,YAAY,OAAO,GAAG;AAC1C,QAAI,QAAQ,YAAY,SAAS;AAC/B,oBAAc,KAAK,OAAO;AAAA,IAC5B;AAAA,EACF;AACA,SAAO;AACT;AAEO,IAAM,uBAAuB,CAClC,gBACiC;AACjC,SAAO,YAAY;AAAA,IAAO,CAAC,YACzB,mBAAmB,OAAO;AAAA,EAC5B;AACF;AAUO,IAAM,kBAAkB,CAC7B,gBACG;AACH,QAAM,gBAAgBA,YAAW,qBAAqB,WAAW,CAAC;AAClE,SAAO,YAAY;AAAA,IACjB,CAAC,YACC,cAAc,IAAI,QAAQ,EAAE,KAC5B,CAAC,QAAQ,WACT,CAAC,cAAc,IAAI,QAAQ,OAAO;AAAA,EACtC;AACF;AAEO,IAAM,6BAA6B,CACxC,aACA,OACA,UACA,gBACwB;AACxB,QAAM,sBAAsB,iBAAiB,aAAa,MAAM,EAAE;AAClE,QAAM,sBAAsB,IAAI,IAAuB,mBAAmB;AAE1E,QAAM,4BAA4B,oBAAI,IAAI;AAAA,IACxC,GAAG,6BAA6B,aAAa,OAAO,WAAW;AAAA,IAC/D,GAAG,oBAAoB;AAAA,MAAO,CAAC,YAC7B,yBAAyB,SAAS,OAAO,WAAW;AAAA,IACtD;AAAA,EACF,CAAC;AAED,QAAM,+BAA+B,oBAAoB;AAAA,IACvD,CAAC,YAAY,CAAC,0BAA0B,IAAI,OAAO;AAAA,EACrD;AAKA,QAAM,eAAe,IAAI;AAAA,IACvB,MAAM,KAAK,yBAAyB,EAAE;AAAA,MACpC,CAAC,YAAY,QAAQ;AAAA,IACvB;AAAA,EACF;AAEA,aAAW,WAAW,8BAA8B;AAClD,QAAI,CAAC,2BAA2B,SAAS,OAAO,WAAW,GAAG;AAC5D,UAAI,QAAQ,SAAS,WAAW,GAAG;AACjC,4BAAoB,OAAO,OAAO;AAAA,MACpC;AAAA,IACF,WAAW,QAAQ,SAAS,SAAS,GAAG;AAGtC,iBAAW,MAAM,QAAQ,UAAU;AACjC,qBAAa,IAAI,EAAE;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAEA,aAAW,WAAW,8BAA8B;AAClD,QAAI,QAAQ,SAAS,SAAS,GAAG;AAC/B,UAAI,sBAAsB;AAE1B,iBAAW,MAAM,QAAQ,UAAU;AACjC,YAAI,aAAa,IAAI,EAAE,GAAG;AACxB,gCAAsB;AAAA,QACxB;AAAA,MACF;AAEA,UAAI,qBAAqB;AACvB,4BAAoB,OAAO,OAAO;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,sCAAsC,MAAM;AAAA,IAChD;AAAA,EACF,EAAE,OAAO,CAAC,YAAY,QAAQ,SAAS,WAAW,CAAC;AAEnD,aAAW,WAAW,qCAAqC;AACzD,wBAAoB,IAAI,OAAO;AAAA,EACjC;AAEA,QAAM,oCAAoC,MAAM;AAAA,IAC9C;AAAA,EACF,EAAE,OAAO,CAAC,YAAY,QAAQ,SAAS,SAAS,CAAC;AAEjD,QAAM,WAAW;AAAA,IACf;AAAA,IACA;AAAA,EACF;AAGA,aAAW,CAAC,IAAI,UAAU,KAAK,OAAO,QAAQ,QAAQ,GAAG;AACvD,QAAI,YAAY;AACd,YAAM,kBAAkB,mBAAmB,aAAa,EAAE;AAE1D,UAAI,yBAAyB,iBAAiB,OAAO,WAAW,GAAG;AACjE,mBAAW,WAAW,iBAAiB;AACrC,8BAAoB,IAAI,OAAO;AAAA,QACjC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO,CAAC,GAAG,mBAAmB,EAAE,OAAO,CAAC,YAAY;AAClD,WAAO,EAAE,cAAc,OAAO,KAAK,QAAQ;AAAA,EAC7C,CAAC;AACH;AAEO,IAAM,wBAAwB,CACnC,UACA,OACA,gBACG;AACH,SAAO;AAAA,IACL;AAAA,MACE;AAAA,MACA,6BAA6B,UAAU,OAAO,WAAW;AAAA,IAC3D;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,oBAAoB,CAC/B,UACA,OACA,mBACG;AACH,QAAM,mBAAmB,CAAC;AAC1B,QAAM,gBAAgB,oBAAI,IAAqB;AAE/C,aAAW,WAAW,UAAU;AAC9B,QAAI,aAAa;AACjB,QAAI,QAAQ,SAAS,SAAS,GAAG;AAE/B,UAAI,QAAQ,SAAS,KAAK,CAAC,QAAQ,cAAc,IAAI,GAAG,CAAC,GAAG;AAC1D,qBAAa;AAAA,MACf,OAAO;AACL,cAAM,qBAAqB,IAAI;AAAA,UAC7B,QAAQ,SAAS;AAAA,YAAQ,CAAC,QACxB,mBAAmB,gBAAgB,GAAG;AAAA,UACxC;AAAA,QACF;AAEA,qBAAa,CAAC;AAAA,UACZ,MAAM,KAAK,kBAAkB;AAAA,UAC7B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,cAAQ,SAAS,QAAQ,CAAC,QAAQ;AAChC,sBAAc,IAAI,KAAK,UAAU;AAAA,MACnC,CAAC;AAAA,IACH;AAEA,QAAI,CAAC,YAAY;AACf,uBAAiB,KAAK,OAAO;AAAA,IAC/B;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,qBAAqB,CAChC,SACA,gBACG;AACH,MAAI,CAAC,QAAQ,SAAS;AACpB,WAAO;AAAA,EACT;AACA,SAAQ,YAAY,IAAI,QAAQ,OAAO,KACrC;AACJ;AAKO,IAAM,wCAAwC,CACnD,UACA,UACG;AACH,QAAM,cAAc,oBAAI,IAAsC;AAC9D,QAAM,cAAcA,YAAW,QAAQ;AACvC,aAAW,+BAA+B,QAAQ;AAElD,aAAW,WAAW,UAAU;AAC9B,QAAI,mBAAmB,OAAO,KAAK,QAAQ,OAAO,MAAM,IAAI;AAC1D,kBAAY,IAAI,QAAQ,EAAE;AAAA,IAC5B;AAAA,EACF;AAEA,QAAM,kBAAkB,oBAAI,IAA6B;AAEzD,QAAM,mBAAwC,CAAC;AAE/C,aAAW,WAAW,UAAU;AAE9B,QACE,mBAAmB,OAAO,KACzB,QAAQ,WAAW,YAAY,IAAI,QAAQ,OAAO,GACnD;AACA;AAAA,IACF;AAEA,QAAI,QAAQ,SAAS,QAAQ;AAC3B,YAAM,oBAAoB,QAAQ,SAAS,GAAG,EAAE;AAChD,UAAI,CAAC,gBAAgB,IAAI,iBAAiB,GAAG;AAC3C,wBAAgB,IAAI,iBAAiB;AACrC,cAAM,gBAAgB,mBAAmB,UAAU,iBAAiB;AACpE,YACE,cAAc;AAAA,UAAK,CAAC,OAClB,yBAAyB,IAAI,OAAO,WAAW;AAAA,QACjD,GACA;AACA,qBAAW,SAAS,eAAe;AACjC,6BAAiB,KAAK,KAAK;AAAA,UAC7B;AAAA,QACF;AAAA,MACF;AAAA,IACF,OAAO;AACL,YAAM,WAAW,yBAAyB,SAAS,OAAO,WAAW;AACrE,UAAI,UAAU;AACZ,yBAAiB,KAAK,OAAO;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AASO,IAAM,qBAAqB,CAChC,aACA,eACA,OACA,aACM;AACN,QAAM,cAAcA,YAAW,WAAW;AAC1C,QAAM,6BAA6B,oBAAI,IAAmC;AAC1E,aAAW,WAAW,YAAY,OAAO,GAAG;AAC1C,QAAI,QAAQ,YAAY,MAAM,IAAI;AAChC,iCAA2B,IAAI,QAAQ,IAAI,IAAI;AAAA,IACjD;AAAA,EACF;AAEA,QAAM,2BAA2B,IAAI,IAAI,cAAc,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;AAEzE,QAAM,qBAA0C,CAAC;AAEjD,QAAM,cAAc,oBAAI,IAAsC;AAE9D,aAAW,WAAW,eAAe;AACnC,QAAI,mBAAmB,OAAO,KAAK,QAAQ,OAAO,MAAM,IAAI;AAC1D,kBAAY,IAAI,QAAQ,EAAE;AAAA,IAC5B;AAAA,EACF;AAIA,aAAW,WAAW;AAAA,IACpB;AAAA,IACA;AAAA,EACF,GAAG;AAED,QACE,mBAAmB,OAAO,KACzB,QAAQ,WAAW,YAAY,IAAI,QAAQ,OAAO,GACnD;AACA;AAAA,IACF;AAKA,QACE,QAAQ,WACR,SAAS,mBAAmB,QAAQ,EAAE,KACtC,SAAS,mBAAmB,QAAQ,OAAO,GAC3C;AACA;AAAA,IACF;AAEA,QAAI,CAAC,2BAA2B,IAAI,QAAQ,EAAE,GAAG;AAC/C,yBAAmB,KAAK,OAAO;AAAA,IACjC;AAEA,UAAM,mBAAmB,oBAAoB,SAAS,WAAW;AACjE,QACE,oBACA,CAAC,yBAAyB,IAAI,iBAAiB,EAAE,KACjD,CAAC,2BAA2B,IAAI,iBAAiB,EAAE,GACnD;AACA,yBAAmB,KAAK,gBAAgB;AAAA,IAC1C;AAAA,EACF;AAEA,aAAW,WAAW,oBAAoB;AACxC,kBAAc,SAAS,aAAa;AAAA,MAClC,SAAS,MAAM;AAAA,IACjB,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEO,IAAM,0BAA0B,CACrC,kBACA,gBACG;AACH,QAAM,oBAAoB,oBAAI,IAG5B;AAEF,QAAM,0BAA0B,oBAAI,IAGlC;AAEF,aAAW,WAAW,kBAAkB;AACtC,QAAI,QAAQ,SAAS;AACnB,wBAAkB,IAAI,QAAQ,IAAI,OAAO;AAEzC,YAAM,MAAM,wBAAwB,IAAI,QAAQ,OAAO,KAAK,CAAC;AAC7D,UAAI,KAAK,OAAO;AAEhB,YAAM,mBAAmB,oBAAoB,SAAS,WAAW;AACjE,UAAI,kBAAkB;AACpB,0BAAkB,IAAI,iBAAiB,IAAI,gBAAgB;AAC3D,YAAI,KAAK,gBAAgB;AAAA,MAC3B;AAEA,8BAAwB,IAAI,QAAQ,SAAS,GAAG;AAAA,IAClD;AAAA,EACF;AAEA,aAAW,CAAC,EAAE,OAAO,KAAK,mBAAmB;AAC3C,kBAAc,SAAS,aAAa;AAAA,MAClC,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AACF;AAEO,IAAM,6BAA6B,CACxC,aACA,UACG;AACH,QAAM,kBAAkB,iBAAiB,aAAa,MAAM,EAAE;AAC9D,0BAAwB,iBAAiBA,YAAW,WAAW,CAAC;AAChE,SAAO;AACT;AAEO,IAAM,4BAA4B,CACvC,aACA,qBACA,OACA,QACQ;AACR,SAAO;AAAA,IACL,2BAA2B,aAAa,KAAK;AAAA,IAC7C;AAAA,IACA;AAAA,IACA,IAAI;AAAA,EACN,EAAE,MAAM;AACV;AAGO,IAAM,0CAA0C,CAGrD,aACA,UACA,QACG;AACH,QAAM,mBAAmB,IAAI,MAAM,oBAAoB;AAAA,IACrD,oBAAoB,SAAS;AAAA;AAAA,IAE7B,UAAU;AAAA,EACZ,CAAC;AACD,QAAM,mBAAmB,IAAI,IAAuB,gBAAgB;AAEpE,MAAI,SAAS,gBAAgB;AAC3B,eAAW,WAAW,kBAAkB;AACtC,UAAI,QAAQ,SAAS,WAAW,GAAG;AACjC,yBAAiB,IAAI,OAAO;AAAA,MAC9B,OAAO;AACL,gBAAQ,SACL,QAAQ,CAAC,QAAQ,mBAAmB,aAAa,GAAG,CAAC,EACrD,QAAQ,CAACI,aAAY,iBAAiB,IAAIA,QAAO,CAAC;AAAA,MACvD;AAAA,IACF;AAAA,EACF;AAEA,QAAM,mBAAmB,oBAAI,IAAuB;AAEpD,QAAM,cAAcJ,YAAW,WAAW;AAE1C,mBAAiB,QAAQ,CAAC,YAAY;AACpC,QACE,QAAQ,WACR,CAAC,mBAAmB,OAAO,KAC3B,CAAC,iBAAiB,SAAS,aAAa,QAAQ,GAChD;AACA,uBAAiB,IAAI,OAAO;AAAA,IAC9B;AAAA,EACF,CAAC;AAED,MAAI,iBAAiB,OAAO,GAAG;AAC7B,4BAAwB,kBAAkB,WAAW;AAAA,EACvD;AACA,SAAO;AACT;AAMO,IAAM,iCAAiC,CAC5C,aAIA,qBACG;AACH,QAAM,iBAAiB,oBAAI,IAAY;AACvC,QAAM,WAAW,oBAAoB;AAErC,aAAW,MAAM,SAAS,OAAO,GAAG;AAClC,UAAM,iBAAiB,GAAG,SAAS,GAAG,SAAS,SAAS,CAAC;AACzD,QAAI,gBAAgB;AAClB,qBAAe,IAAI,cAAc;AAAA,IACnC;AAAA,EACF;AAEA,QAAM,mBAAmB,oBAAI,IAAY;AACzC,aAAW,WAAW,gBAAgB;AACpC,QACE,mBAAmB,aAAa,OAAO,EAAE;AAAA,MAAK,CAAC,OAC7C,mBAAmB,EAAE;AAAA,IACvB,GACA;AACA,uBAAiB,IAAI,OAAO;AAAA,IAC9B;AAAA,EACF;AAEA,QAAM,MAA2B,CAAC;AAElC,aAAW,WAAW,SAAS,OAAO,GAAG;AACvC,QAAI,CAAC,iBAAiB,IAAI,QAAQ,SAAS,QAAQ,SAAS,SAAS,CAAC,CAAC,GAAG;AACxE,UAAI,KAAK,OAAO;AAAA,IAClB;AAAA,EACF;AAEA,SAAO;AACT;AAMO,IAAM,iBAAiB,CAC5B,SACA,aACA,aACG;AACH,QAAM,WAAW,cAAc,OAAO,IAClC,oBAAoB,SAAS,WAAW,KAAK,UAC7C;AAIJ,MACE,SAAS,WACT,SAAS,mBAAmB,SAAS,EAAE,KACvC,SAAS,mBAAmB,SAAS,OAAO,GAC5C;AACA,WAAO,mBAAmB,UAAU,WAAW;AAAA,EACjD;AAEA,SAAO,SAAS,mBAAmB,SAAS,EAAE,KAC5C,SAAS,kCACP,SAAS,mBACT,mBAAmB,UAAU,WAAW;AAC9C;AAIO,IAAM,mBAAmB,CAC9B,SACA,gBACA,UACA,SAIG;AACH,QAAM,QACJ,MAAM,eAAe,eAAe,SAAS,gBAAgB,QAAQ;AAEvE,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AAEA,QAAM,WAAW,cAAc,OAAO,IAClC,oBAAoB,SAAS,cAAc,KAAK,UAChD;AAEJ,QAAM,mBAAmB,CAAC,cAAuB;AAC/C,QAAI,MAAM,eAAe;AACvB,eAAS,SAAS,QAAQ,CAAC,YAAY;AACrC,aAAK,eAAe,IAAI,SAAS,SAAS;AAAA,MAC5C,CAAC;AAAA,IACH;AAAA,EACF;AAEA;AAAA;AAAA;AAAA,IAGE,CAAC,SAAS,mBAAmB,SAAS,EAAE,KACxC,CAAC,SAAS;AAAA,IAET,SAAS,mBAAmB,SAAS,EAAE,KACtC,SAAS,mBAAmB,MAAM,EAAE;AAAA,IACtC;AACA,WAAO;AAAA,EACT;AAEA,MAAI,SAAS,SAAS,WAAW,GAAG;AAClC,WAAO,yBAAyB,UAAU,OAAO,cAAc;AAAA,EACjE;AAEA,aAAW,OAAO,SAAS,UAAU;AACnC,QAAI,MAAM,eAAe,IAAI,GAAG,GAAG;AACjC,aAAO,KAAK,cAAc,IAAI,GAAG;AAAA,IACnC;AAAA,EACF;AAEA,QAAM,qBAAqB,IAAI;AAAA,IAC7B,SAAS,SACN,OAAO,CAAC,QAAQ;AACf,UAAI,MAAM,eAAe;AACvB,eAAO,CAAC,KAAK,cAAc,IAAI,GAAG;AAAA,MACpC;AACA,aAAO;AAAA,IACT,CAAC,EACA,QAAQ,CAAC,QAAQ,mBAAmB,gBAAgB,GAAG,CAAC;AAAA,EAC7D;AAEA,MAAI,SAAS,kBAAkB,SAAS,iCAAiC;AACvE,UAAM,mBAAmB,IAAI;AAAA,MAC3B,oBAAoB,gBAAgB,QAAQ;AAAA,IAC9C;AAEA,UAAM,4BAA4B,SAAS,qBAAqB;AAEhE,QAAI,2BAA2B;AAC7B,aAAO;AAAA,IACT;AAEA,qBAAiB,QAAQ,CAAC,oBAAoB;AAC5C,yBAAmB,OAAO,eAAe;AAAA,IAC3C,CAAC;AAAA,EACH;AAEA,aAAW,kBAAkB,oBAAoB;AAC/C,QAAI,mBAAmB,cAAc,GAAG;AACtC,uBAAiB,KAAK;AACtB,aAAO;AAAA,IACT;AAAA,EACF;AAEA,aAAW,kBAAkB,oBAAoB;AAC/C,QAAI,yBAAyB,gBAAgB,OAAO,cAAc,GAAG;AACnE,uBAAiB,IAAI;AACrB,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,uBAAuB,CAClC,SACA,OACA,UACA,aACA,kBACG;AACH,MAAI,CAAC,SAAS,kBAAkB,CAAC,SAAS,eAAe,MAAM;AAC7D,WAAO;AAAA,EACT;AAMA,QAAM,0BACJ,2BAA2B,SAAS,OAAO,WAAW,KACtD,yBAAyB,SAAS,OAAO,WAAW;AAEtD,MAAI,yBAAyB;AAC3B,eAAW,WAAW,QAAQ,UAAU;AACtC,qBAAe,IAAI,SAAS,IAAI;AAAA,IAClC;AAEA,WAAO;AAAA,EACT;AAIA,MACE,CAAC,2BACD,QAAQ,SAAS,SAAS,KAC1B,CAAC,yBAAyB,CAAC,OAAO,GAAG,OAAO,WAAW,GACvD;AACA,QAAI,aAAa;AAIjB,QAAI,CAAC,SAAS,iCAAiC;AAC7C,mBAAa,QAAQ,YAAY,MAAM;AACvC,iBAAW,WAAW,QAAQ,UAAU;AACtC,uBAAe,IAAI,SAAS,UAAU;AAAA,MACxC;AAAA,IACF,OAAO;AACL,mBAAa,iBAAiB,SAAS,aAAa,UAAU;AAAA,QAC5D,aAAa;AAAA,QACb;AAAA,MACF,CAAC;AAAA,IACH;AAEA,eAAW,WAAW,QAAQ,UAAU;AACtC,qBAAe,IAAI,SAAS,UAAU;AAAA,IACxC;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEA,IAAM,qBAAqB;AAC3B,IAAM,wBAAwB;AAEvB,IAAM,sBAAsB,CAAC,YAAwC;AAE1E,SAAO,eAAe,OAAO,IAAI,qBAAqB;AACxD;AAEO,IAAM,oBAAoB,CAAC,YAAwC;AACxE,SAAO,QAAQ,SAAS,OAAO,oBAAoB,OAAO,IAAI,QAAQ;AACxE;AAEO,IAAM,8BAA8B,CACzC,UACA,UACG;AACH,SACE,wBAAwB;AAAA,IACtB;AAAA,IACA,QAAQ;AAAA,IACR,MAAM;AAAA,EACR,CAAC,EAGE,OAAO,CAAC,OAAO,CAAC,GAAG,WAAW,GAAG,YAAY,MAAM,EAAE;AAE5D;AAEO,IAAM,mCAAmC,CAC9C,qBACG;AACH,QAAM,sBAAsBA,YAAW,gBAAgB;AAEvD,SACE,iBAAiB,SAAS,KAC1B,iBAAiB;AAAA,IACf,CAAC,YAAY,QAAQ,WAAW,oBAAoB,IAAI,QAAQ,OAAO;AAAA,EACzE;AAEJ;;;AhBn2BO,IAAM,sBACX;AAEF,IAAM,wBAAwB,CAC5B,SACA,iBAEA,0BAA0B,OAAO,KACjC,CAAC,aAAa,WAAW,IAAI,QAAQ,MAAM;AAE7C,IAAM,yBAAyB,CAC7B,SACA,cACA,aACG;AACH,SACE,SAAS,UAAU,MAAM,QACzB,0BAA0B,OAAO,KACjC,CAAC,sBAAsB,SAAS,YAAY,KAC5C,aAAa,WAAW,IAAI,QAAQ,MAAM,GAAG,aAAa,WAAW;AAEzE;AAEA,IAAM,mBAAmB,CAAC,YAA+B;AACvD,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK;AACH,aAAO,QAAQ,cAAc;AAAA,IAC/B,KAAK;AACH,aAAO,QAAQ,WAAW;AAAA,IAC5B;AACE,aAAO;AAAA,EACX;AACF;AAEO,IAAM,mBAAmB,CAC9B,SACA,iBACA,wBACA,cACA,cAAsB,MACnB;AAGH,MAAI,WACC,iBAAiB,WAAW,OAAO,QAAQ,UAAW,MACzD;AAIF,MACE,uBAAuB,IAAI,QAAQ,EAAE,KACpC,gBAAgB,aAAa,KAAK,CAAC,SAAS,KAAK,OAAO,QAAQ,EAAE,KAClE,mBAAmB,uBAAuB,IAAI,gBAAgB,EAAE,GACjE;AACA,eAAW,iCAAiC;AAAA,EAC9C;AAEA,SAAO;AACT;AAiBA,IAAM,0BAA0B,CAC9B,SACA,aACA,SAKG;AAOH,QAAM,aAAa;AAEnB,QAAM,qBAAqB;AAE3B,QAAM,UAAU,iBAAiB,OAAO;AAExC,QAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAIK,0BAAyB,SAAS,WAAW;AACtE,QAAM,eACJ,gBAAgB,OAAO,KAAK,kBAAkB,OAAO,IACjDC,UAAS,IAAI,EAAE,IACf,QAAQ;AACd,QAAM,gBACJ,gBAAgB,OAAO,KAAK,kBAAkB,OAAO,IACjDA,UAAS,IAAI,EAAE,IACf,QAAQ;AAEd,MAAI,QAAQ,eAAe,OAAO,mBAAmB,UAAU;AAC/D,MAAI,SAAS,gBAAgB,OAAO,mBAAmB,UAAU;AAEjE,MAAI,QAAgB,KAAK;AAGzB,MACE,QAAQ,QAAQ,sBAChB,SAAS,QAAQ,oBACjB;AACA,YAAQ,KAAK,IAAI,qBAAqB,OAAO,qBAAqB,MAAM;AAAA,EAC1E;AAGA,MAAI,QAAQ,SAAS,QAAQ,QAAQ,YAAY;AAC/C,YAAQ,KAAK,KAAK,cAAc,QAAQ,OAAO;AAAA,EACjD;AAEA,UAAQ,KAAK,MAAM,QAAQ,KAAK;AAChC,WAAS,KAAK,MAAM,SAAS,KAAK;AAElC,SAAO,EAAE,OAAO,QAAQ,MAAM;AAChC;AAEA,IAAM,wBAAwB,CAC5B,SACA,aACA,MACA,cACA,aACuC;AACvC,QAAM,SAAS,SAAS,cAAc,QAAQ;AAC9C,QAAM,UAAU,OAAO,WAAW,IAAI;AACtC,QAAM,UAAU,iBAAiB,OAAO;AAExC,QAAM,EAAE,OAAO,QAAQ,MAAM,IAAI;AAAA,IAC/B;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,CAAC,SAAS,CAAC,QAAQ;AACrB,WAAO;AAAA,EACT;AAEA,SAAO,QAAQ;AACf,SAAO,SAAS;AAEhB,MAAI,gBAAgB;AACpB,MAAI,gBAAgB;AAEpB,MAAI,gBAAgB,OAAO,KAAK,kBAAkB,OAAO,GAAG;AAC1D,UAAM,CAAC,IAAI,EAAE,IAAID,0BAAyB,SAAS,WAAW;AAE9D,oBACE,QAAQ,IAAI,KACRC,UAAS,QAAQ,GAAG,EAAE,IAAI,OAAO,mBAAmB,QACpD;AAEN,oBACE,QAAQ,IAAI,KACRA,UAAS,QAAQ,GAAG,EAAE,IAAI,OAAO,mBAAmB,QACpD;AAEN,YAAQ,UAAU,eAAe,aAAa;AAAA,EAChD;AAEA,UAAQ,KAAK;AACb,UAAQ,UAAU,UAAU,OAAO,UAAU,KAAK;AAClD,UAAQ;AAAA,IACN,OAAO,mBAAmB;AAAA,IAC1B,OAAO,mBAAmB;AAAA,EAC5B;AAEA,QAAM,KAAK,cAAM,OAAO,MAAM;AAG9B,MAAI,uBAAuB,SAAS,cAAc,QAAQ,GAAG;AAC3D,YAAQ,SAAS;AAAA,EACnB;AAEA,sBAAoB,SAAS,IAAI,SAAS,cAAc,QAAQ;AAEhE,UAAQ,QAAQ;AAEhB,QAAM,mBAAmB,oBAAoB,SAAS,WAAW;AACjE,QAAM,kBAAkB,SAAS,cAAc,QAAQ;AACvD,QAAM,yBAAyB,gBAAgB,WAAW,IAAI;AAE9D,MAAI,eAAe,OAAO,KAAK,kBAAkB;AAC/C,UAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAID,0BAAyB,SAAS,WAAW;AAGtE,UAAM,SAAS,KAAK,IAAIC,UAAS,IAAI,EAAE,GAAGA,UAAS,IAAI,EAAE,CAAC;AAC1D,oBAAgB,QACd,SAAS,OAAO,mBAAmB,QAAQ,UAAU,QAAQ;AAC/D,oBAAgB,SACd,SAAS,OAAO,mBAAmB,QAAQ,UAAU,QAAQ;AAC/D,2BAAuB;AAAA,MACrB,gBAAgB,QAAQ;AAAA,MACxB,gBAAgB,SAAS;AAAA,IAC3B;AACA,2BAAuB,OAAO,QAAQ,KAAK;AAC3C,2BAAuB;AAAA,MACrB;AAAA,MACA,CAAC,OAAO,QAAQ;AAAA,MAChB,CAAC,OAAO,SAAS;AAAA,MACjB,OAAO;AAAA,MACP,OAAO;AAAA,IACT;AAEA,UAAM,CAAC,EAAE,EAAE,EAAE,EAAE,aAAa,WAAW,IAAID;AAAA,MACzC;AAAA,MACA;AAAA,IACF;AAEA,2BAAuB,OAAO,CAAC,QAAQ,KAAK;AAC5C,UAAM,WAAW,gBAAgB,QAAQ,OAAQ,SAAS;AAC1D,UAAM,WAAW,gBAAgB,SAAS,OAAQ,UAAU;AAC5D,UAAM,SACJ,gBAAgB,QAAQ,KACvB,cAAc,MAAM,OAAO,mBAAmB,QAC/C,UACA,UAAU;AAEZ,UAAM,SACJ,gBAAgB,SAAS,KACxB,cAAc,MAAM,OAAO,mBAAmB,QAC/C,UACA,UAAU;AACZ,2BAAuB,UAAU,CAAC,QAAQ,CAAC,MAAM;AAEjD,2BAAuB;AAAA,MACrB,EAAE,iBAAiB,QAAQ,IAAIE,uBAC7B,OAAO,mBACP;AAAA,MACF,EAAE,iBAAiB,SAAS,IAAIA,uBAC9B,OAAO,mBACP;AAAA,OACD,iBAAiB,QAAQA,sBAAqB,KAC7C,OAAO,mBACP;AAAA,OACD,iBAAiB,SAASA,sBAAqB,KAC9C,OAAO,mBACP;AAAA,IACJ;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OAAO,SAAS;AAAA,IAChB;AAAA,IACA,WAAW,KAAK;AAAA,IAChB;AAAA,IACA;AAAA,IACA,yBACE,oBAAoB,SAAS,WAAW,GAAG,WAAW;AAAA,IACxD,wBACE,mBAAmB,SAAS,WAAW,GAAG,WAAW;AAAA,IACvD;AAAA,IACA,OAAO,QAAQ;AAAA,IACf,WAAW,eAAe,OAAO,IAAI,QAAQ,OAAO;AAAA,EACtD;AACF;AAEO,IAAM,oBAAoB;AAEjC,IAAM,wBACJ,OAAO,aAAa,cAChB,SAAS,cAAc,KAAK,IAC3B,EAAE,KAAK,GAAG;AAEjB,sBAAsB,MAAM,QAAQ,WAAW,GAAG,IAAI;AAAA,EACpD;AACF,CAAC;AAED,IAAM,8BACJ,OAAO,aAAa,cAChB,SAAS,cAAc,KAAK,IAC3B,EAAE,KAAK,GAAG;AAEjB,4BAA4B,MAAM,QAAQ,WAAW,GAAG,IAAI;AAAA,EAC1D;AACF,CAAC;AAED,IAAM,uBAAuB,CAC3B,SACA,YACG;AACH,UAAQ,YAAY;AACpB,UAAQ,SAAS,GAAG,GAAG,QAAQ,OAAO,QAAQ,MAAM;AAEpD,QAAM,wBAAwB,KAAK,IAAI,QAAQ,OAAO,QAAQ,MAAM;AAEpE,QAAM,OAAO,KAAK;AAAA,IAChB;AAAA,IACA,KAAK,IAAI,wBAAwB,KAAK,GAAG;AAAA,EAC3C;AAEA,UAAQ;AAAA,IACN,QAAQ,WAAW,UACf,8BACA;AAAA,IACJ,QAAQ,QAAQ,IAAI,OAAO;AAAA,IAC3B,QAAQ,SAAS,IAAI,OAAO;AAAA,IAC5B;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,sBAAsB,CAC1B,SACA,IACA,SACA,cACA,aACG;AACH,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK,WAAW;AACd,cAAQ,WAAW;AACnB,cAAQ,UAAU;AAClB,SAAG,KAAK,WAAW,IAAI,OAAO,CAAE;AAChC;AAAA,IACF;AAAA,IACA,KAAK;AAAA,IACL,KAAK,QAAQ;AACX,cAAQ,WAAW;AACnB,cAAQ,UAAU;AAElB,iBAAW,IAAI,OAAO,EAAG,QAAQ,CAAC,UAAU;AAC1C,WAAG,KAAK,KAAK;AAAA,MACf,CAAC;AACD;AAAA,IACF;AAAA,IACA,KAAK,YAAY;AAEf,cAAQ,KAAK;AACb,cAAQ,YAAY,QAAQ;AAE5B,YAAM,OAAO,kBAAkB,OAAO;AACtC,YAAM,YAAY,WAAW,IAAI,OAAO;AAExC,UAAI,WAAW;AACb,WAAG,KAAK,SAAS;AAAA,MACnB;AAEA,cAAQ,YAAY,QAAQ;AAC5B,cAAQ,KAAK,IAAI;AAEjB,cAAQ,QAAQ;AAChB;AAAA,IACF;AAAA,IACA,KAAK,SAAS;AACZ,YAAM,MAAM,0BAA0B,OAAO,IACzC,aAAa,WAAW,IAAI,QAAQ,MAAM,GAAG,QAC7C;AACJ,UAAI,OAAO,QAAQ,EAAE,eAAe,UAAU;AAC5C,YAAI,QAAQ,aAAa,QAAQ,WAAW;AAC1C,kBAAQ,UAAU;AAClB,kBAAQ;AAAA,YACN;AAAA,YACA;AAAA,YACA,QAAQ;AAAA,YACR,QAAQ;AAAA,YACR,gBAAgB,KAAK,IAAI,QAAQ,OAAO,QAAQ,MAAM,GAAG,OAAO;AAAA,UAClE;AACA,kBAAQ,KAAK;AAAA,QACf;AAEA,cAAM,EAAE,GAAG,GAAG,OAAO,OAAO,IAAI,QAAQ,OACpC,QAAQ,OACR;AAAA,UACE,GAAG;AAAA,UACH,GAAG;AAAA,UACH,OAAO,IAAI;AAAA,UACX,QAAQ,IAAI;AAAA,QACd;AAEJ,gBAAQ;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV;AAAA,MACF,OAAO;AACL,6BAAqB,SAAS,OAAO;AAAA,MACvC;AACA;AAAA,IACF;AAAA,IACA,SAAS;AACP,UAAI,cAAc,OAAO,GAAG;AAC1B,cAAM,MAAM,MAAM,QAAQ,IAAI;AAC9B,cAAM,0BAA0B,OAAO,CAAC,QAAQ,OAAO;AACvD,YAAI,yBAAyB;AAG3B,mBAAS,KAAK,YAAY,QAAQ,MAAM;AAAA,QAC1C;AACA,gBAAQ,OAAO,aAAa,OAAO,MAAM,QAAQ,KAAK;AACtD,gBAAQ,KAAK;AACb,gBAAQ,OAAOC,eAAc,OAAO;AACpC,gBAAQ,YAAY,QAAQ;AAC5B,gBAAQ,YAAY,QAAQ;AAG5B,cAAM,QAAQ,QAAQ,KAAK,QAAQ,UAAU,IAAI,EAAE,MAAM,IAAI;AAE7D,cAAM,mBACJ,QAAQ,cAAc,WAClB,QAAQ,QAAQ,IAChB,QAAQ,cAAc,UACtB,QAAQ,QACR;AAEN,cAAM,eAAe;AAAA,UACnB,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV;AAEA,cAAM,iBAAiB;AAAA,UACrB,QAAQ;AAAA,UACR,QAAQ;AAAA,UACR;AAAA,QACF;AAEA,iBAAS,QAAQ,GAAG,QAAQ,MAAM,QAAQ,SAAS;AACjD,kBAAQ;AAAA,YACN,MAAM,KAAK;AAAA,YACX;AAAA,YACA,QAAQ,eAAe;AAAA,UACzB;AAAA,QACF;AACA,gBAAQ,QAAQ;AAChB,YAAI,yBAAyB;AAC3B,kBAAQ,OAAO,OAAO;AAAA,QACxB;AAAA,MACF,OAAO;AACL,cAAM,IAAI,MAAM,sBAAsB,QAAQ,IAAI,EAAE;AAAA,MACtD;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,yBAAyB,oBAAI,QAGxC;AAEF,IAAM,4BAA4B,CAChC,SACA,aACA,cACA,aACG;AACH,QAAM,OAAa,eACf,SAAS,OACT;AAAA,IACE,OAAO;AAAA,EACT;AACJ,QAAM,wBAAwB,uBAAuB,IAAI,OAAO;AAChE,QAAM,8BACJ,yBACA,sBAAsB,cAAc,KAAK,SACzC,CAAC,UAAU;AACb,QAAM,mBAAmB,oBAAoB,SAAS,WAAW;AACjE,QAAM,0BAA0B,kBAAkB,WAAW;AAC7D,QAAM,YAAY,eAAe,OAAO,IAAI,QAAQ,OAAO;AAE3D,QAAM,yBACJ,mBAAmB,SAAS,WAAW,GAAG,WAAW;AAEvD,MACE,CAAC,yBACD,+BACA,sBAAsB,UAAU,SAAS,SACzC,sBAAsB,4BAA4B,2BAClD,sBAAsB,cAAc,aACpC,sBAAsB,2BAA2B;AAAA;AAAA;AAAA;AAAA,EAKhD,eAAe,OAAO,KACrB,oBACA,QAAQ,UAAU,sBAAsB,OAC1C;AACA,UAAM,oBAAoB;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,QAAI,CAAC,mBAAmB;AACtB,aAAO;AAAA,IACT;AAEA,2BAAuB,IAAI,SAAS,iBAAiB;AAErD,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEA,IAAM,wBAAwB,CAC5B,mBACA,SACA,cACA,UACA,mBACG;AACH,QAAM,UAAU,kBAAkB;AAClC,QAAM,UAAU,iBAAiB,OAAO;AACxC,QAAM,OAAO,kBAAkB;AAC/B,QAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAIH,0BAAyB,SAAS,cAAc;AACzE,QAAM,OAAO,KAAK,MAAM,IAAI,SAAS,WAAW,OAAO;AACvD,QAAM,OAAO,KAAK,MAAM,IAAI,SAAS,WAAW,OAAO;AAEvD,UAAQ,KAAK;AACb,UAAQ,MAAM,IAAI,OAAO,kBAAkB,IAAI,OAAO,gBAAgB;AAEtE,QAAM,mBAAmB,oBAAoB,SAAS,cAAc;AAEpE,MAAI,eAAe,OAAO,KAAK,kBAAkB;AAC/C,UAAM,WACH,kBAAkB,gBAAgB,QACjC,kBAAkB,OAAQ,SAC5B;AACF,UAAM,WACH,kBAAkB,gBAAgB,SACjC,kBAAkB,OAAQ,UAC5B;AACF,YAAQ,UAAU,IAAI,EAAE;AACxB,YAAQ;AAAA,MACN,kBAAkB;AAAA,MACjB,EAAE,KAAK,MAAM,IAAK,OAAO,mBAAmB,UAAU,OAAO;AAAA,MAC7D,EAAE,KAAK,MAAM,IAAK,OAAO,mBAAmB,UAAU,OAAO;AAAA,MAC9D,kBAAkB,gBAAgB,QAAQ;AAAA,MAC1C,kBAAkB,gBAAgB,SAAS;AAAA,IAC7C;AAAA,EACF,OAAO;AAGL,YAAQ,UAAU,IAAI,EAAE;AAExB,YAAQ,OAAO,QAAQ,KAAK;AAE5B,QACE,WAAW,kBAAkB,WAC7B,CAAC,sBAAsB,SAAS,YAAY,GAC5C;AACA,cAAQ;AAAA,QACN,kBAAkB,QAAQ,MAAM,CAAC;AAAA,QACjC,kBAAkB,QAAQ,MAAM,CAAC;AAAA,MACnC;AAAA,IACF;AAGA,YAAQ,UAAU,CAAC,IAAI,CAAC,EAAE;AAE1B,YAAQ;AAAA,MACN,kBAAkB;AAAA,OACjB,KAAK,SAAS,WAAW,OAAO,mBAC9B,UAAU,kBAAkB,QAAS,kBAAkB;AAAA,OACzD,KAAK,SAAS,WAAW,OAAO,mBAC9B,UAAU,kBAAkB,QAAS,kBAAkB;AAAA,MAC1D,kBAAkB,OAAQ,QAAQ,kBAAkB;AAAA,MACpD,kBAAkB,OAAQ,SAAS,kBAAkB;AAAA,IACvD;AAEA,QACE,+BAAgB,sDACd,UACF,oBAAoB,OAAO,GAC3B;AACA,YAAM,cAAc;AAAA,QAClB;AAAA,QACA;AAAA,MACF;AACA,YAAM,SAAS,mBAAmB,OAAO;AACzC,cAAQ,cAAc;AACtB,cAAQ,YAAY;AACpB,cAAQ;AAAA,SACL,OAAO,IAAI,SAAS,WAAW,OAAO;AAAA,SACtC,OAAO,IAAI,SAAS,WAAW,OAAO;AAAA,QACvC,qBAAqB,SAAS,WAAW,IAAI,OAAO;AAAA,QACpD,sBAAsB,SAAS,WAAW,IAAI,OAAO;AAAA,MACvD;AAAA,IACF;AAAA,EACF;AACA,UAAQ,QAAQ;AAGlB;AAEO,IAAM,yBAAyB,CACpC,SACA,SACA,UACA,mBACG;AACH,UAAQ,KAAK;AACb,UAAQ,UAAU,QAAQ,IAAI,SAAS,SAAS,QAAQ,IAAI,SAAS,OAAO;AAC5E,UAAQ,YAAY;AAMpB,QAAM,SAAS,MAAM,SAAS,KAAK;AAEnC,UAAQ,SAAS,QAAQ,QAAQ,QAAQ,OAAO,QAAQ,MAAM;AAC9D,UAAQ,YAAY,IAAI,SAAS,KAAK;AACtC,UAAQ,cAAc;AACtB,UAAQ,WAAW,QAAQ,QAAQ,QAAQ,OAAO,QAAQ,MAAM;AAEhE,UAAQ,QAAQ;AAClB;AAEO,IAAM,gBAAgB,CAC3B,SACA,aACA,gBACA,IACA,SACA,cACA,aACG;AACH,QAAM,0BACJ,SAAS,YAAY,SAAS,yBAC9B,CAAC,SAAS,mBAAmB,QAAQ,EAAE,KACvC,CAAC,SAAS,kBAAkB,QAAQ,EAAE;AAExC,UAAQ,cAAc;AAAA,IACpB;AAAA,IACA,mBAAmB,SAAS,WAAW;AAAA,IACvC,aAAa;AAAA,IACb,aAAa;AAAA,IACb,0BAA0B,+BAA+B;AAAA,EAC3D;AAEA,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK;AAAA,IACL,KAAK,SAAS;AACZ,UAAI,SAAS,eAAe,WAAW,SAAS,eAAe,SAAS;AACtE,gBAAQ,KAAK;AACb,gBAAQ;AAAA,UACN,QAAQ,IAAI,SAAS;AAAA,UACrB,QAAQ,IAAI,SAAS;AAAA,QACvB;AACA,gBAAQ,YAAY;AAEpB,gBAAQ,YAAY,YAAY,cAAc,SAAS,KAAK;AAC5D,gBAAQ,cAAc,YAAY;AAGlC,YAAI,oBAAoB,OAAO,GAAG;AAChC,kBAAQ,cACN,SAAS,UAAU,MAAM,QAAQ,YAAY;AAAA,QACjD;AAEA,YAAI,YAAY,UAAU,QAAQ,WAAW;AAC3C,kBAAQ,UAAU;AAClB,kBAAQ;AAAA,YACN;AAAA,YACA;AAAA,YACA,QAAQ;AAAA,YACR,QAAQ;AAAA,YACR,YAAY,SAAS,SAAS,KAAK;AAAA,UACrC;AACA,kBAAQ,OAAO;AACf,kBAAQ,UAAU;AAAA,QACpB,OAAO;AACL,kBAAQ,WAAW,GAAG,GAAG,QAAQ,OAAO,QAAQ,MAAM;AAAA,QACxD;AAEA,gBAAQ,QAAQ;AAAA,MAClB;AACA;AAAA,IACF;AAAA,IACA,KAAK,YAAY;AAIf,iBAAW,qBAAqB,SAAS,IAAI;AAE7C,UAAI,aAAa,aAAa;AAC5B,cAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAIA,0BAAyB,SAAS,WAAW;AACtE,cAAM,MAAM,KAAK,MAAM,IAAI,SAAS;AACpC,cAAM,MAAM,KAAK,MAAM,IAAI,SAAS;AACpC,cAAM,UAAU,KAAK,MAAM,KAAK,QAAQ,IAAI;AAC5C,cAAM,UAAU,KAAK,MAAM,KAAK,QAAQ,IAAI;AAC5C,gBAAQ,KAAK;AACb,gBAAQ,UAAU,IAAI,EAAE;AACxB,gBAAQ,OAAO,QAAQ,KAAK;AAC5B,gBAAQ,UAAU,CAAC,QAAQ,CAAC,MAAM;AAClC,4BAAoB,SAAS,IAAI,SAAS,cAAc,QAAQ;AAChE,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,cAAM,oBAAoB;AAAA,UACxB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AACA,YAAI,CAAC,mBAAmB;AACtB;AAAA,QACF;AAEA;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA;AAAA,IACF;AAAA,IACA,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK,cAAc;AAIjB,iBAAW,qBAAqB,SAAS,YAAY;AACrD,UAAI,aAAa,aAAa;AAC5B,cAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAIA,0BAAyB,SAAS,WAAW;AACtE,cAAM,MAAM,KAAK,MAAM,IAAI,SAAS;AACpC,cAAM,MAAM,KAAK,MAAM,IAAI,SAAS;AACpC,YAAI,UAAU,KAAK,MAAM,KAAK,QAAQ,IAAI;AAC1C,YAAI,UAAU,KAAK,MAAM,KAAK,QAAQ,IAAI;AAC1C,YAAI,cAAc,OAAO,GAAG;AAC1B,gBAAM,YAAY,oBAAoB,SAAS,WAAW;AAC1D,cAAI,eAAe,SAAS,GAAG;AAC7B,kBAAM,kBACJ,oBAAoB;AAAA,cAClB;AAAA,cACA;AAAA,cACA;AAAA,YACF;AACF,sBAAU,KAAK,MAAM,KAAK,gBAAgB,IAAI;AAC9C,sBAAU,KAAK,MAAM,KAAK,gBAAgB,IAAI;AAAA,UAChD;AAAA,QACF;AACA,gBAAQ,KAAK;AACb,gBAAQ,UAAU,IAAI,EAAE;AAExB,YAAI,uBAAuB,SAAS,cAAc,QAAQ,GAAG;AAC3D,kBAAQ,SAAS;AAAA,QACnB;AACA,cAAM,mBAAmB,oBAAoB,SAAS,WAAW;AAEjE,YAAI,eAAe,OAAO,KAAK,kBAAkB;AAC/C,gBAAM,aAAa,SAAS,cAAc,QAAQ;AAElD,gBAAM,oBAAoB,WAAW,WAAW,IAAI;AAIpD,gBAAM,SAAS,KAAK,IAAIC,UAAS,IAAI,EAAE,GAAGA,UAAS,IAAI,EAAE,CAAC;AAC1D,gBAAM,UAAU,iBAAiB,OAAO;AACxC,qBAAW,QACT,SAAS,SAAS,cAAc,UAAU,KAAK,SAAS;AAC1D,qBAAW,SACT,SAAS,SAAS,cAAc,UAAU,KAAK,SAAS;AAE1D,4BAAkB;AAAA,YAChB,WAAW,QAAQ;AAAA,YACnB,WAAW,SAAS;AAAA,UACtB;AACA,4BAAkB,MAAM,SAAS,aAAa,SAAS,WAAW;AAGlE,mBAAS,QAAQ,QAAQ,KAAK,QAAQ,IAAI;AAC1C,mBAAS,QAAQ,SAAS,KAAK,QAAQ,IAAI;AAE3C,4BAAkB,OAAO,QAAQ,KAAK;AACtC,gBAAM,SAAS,cAAM,OAAO,UAAU;AAEtC,4BAAkB,UAAU,CAAC,QAAQ,CAAC,MAAM;AAE5C;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAEA,4BAAkB,UAAU,QAAQ,MAAM;AAE1C,4BAAkB,OAAO,CAAC,QAAQ,KAAK;AAGvC,gBAAM,CAAC,EAAE,EAAE,EAAE,EAAE,aAAa,WAAW,IAAID;AAAA,YACzC;AAAA,YACA;AAAA,UACF;AACA,gBAAM,mBAAmB,KAAK,MAAM,IAAI;AACxC,gBAAM,mBAAmB,KAAK,MAAM,IAAI;AACxC,4BAAkB,UAAU,CAAC,iBAAiB,CAAC,eAAe;AAG9D,4BAAkB;AAAA,YAChB,CAAC,iBAAiB,QAAQ;AAAA,YAC1B,CAAC,iBAAiB,SAAS;AAAA,YAC3B,iBAAiB;AAAA,YACjB,iBAAiB;AAAA,UACnB;AACA,kBAAQ,MAAM,IAAI,SAAS,aAAa,IAAI,SAAS,WAAW;AAChE,kBAAQ;AAAA,YACN;AAAA,YACA,CAAC,WAAW,QAAQ;AAAA,YACpB,CAAC,WAAW,SAAS;AAAA,YACrB,WAAW;AAAA,YACX,WAAW;AAAA,UACb;AAAA,QACF,OAAO;AACL,kBAAQ,OAAO,QAAQ,KAAK;AAE5B,cAAI,QAAQ,SAAS,SAAS;AAE5B,oBAAQ,MAAM,QAAQ,MAAM,CAAC,GAAG,QAAQ,MAAM,CAAC,CAAC;AAAA,UAClD;AAEA,kBAAQ,UAAU,CAAC,QAAQ,CAAC,MAAM;AAClC,8BAAoB,SAAS,IAAI,SAAS,cAAc,QAAQ;AAAA,QAClE;AAEA,gBAAQ,QAAQ;AAAA,MAGlB,OAAO;AACL,cAAM,oBAAoB;AAAA,UACxB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAEA,YAAI,CAAC,mBAAmB;AACtB;AAAA,QACF;AAEA,cAAM,8BAA8B,QAAQ;AAE5C;AAAA;AAAA;AAAA,UAGE,CAAC,UAAU;AAAA,WAEV,CAAC,QAAQ;AAAA;AAAA;AAAA,UAIR,iBAAiB,QAAQ,KAAK;AAAA,UAChC;AAQA,kBAAQ,wBAAwB;AAAA,QAClC;AAEA,YACE,QAAQ,OAAO,SAAS,qBACxB,eAAe,kBAAkB,OAAO,KACxC,kBAAkB,QAAQ,SAAS,MACnC;AACA,kBAAQ,KAAK;AACb,kBAAQ,cAAc;AAEtB,gBAAM,yBAAyB;AAAA,YAC7B,yBAAyB,kBAAkB,SAAS,WAAW;AAAA,YAC/D;AAAA,YACA,SAAS;AAAA,YACT;AAAA,YACA;AAAA,UACF;AAEA,cAAI,wBAAwB;AAC1B;AAAA,cACE;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAAA,UACF;AAEA,kBAAQ,QAAQ;AAAA,QAClB;AAEA;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAGA,gBAAQ,wBAAwB;AAAA,MAClC;AACA;AAAA,IACF;AAAA,IACA,SAAS;AAEP,YAAM,IAAI,MAAM,sBAAsB,QAAQ,IAAI,EAAE;AAAA,IACtD;AAAA,EACF;AAEA,UAAQ,cAAc;AACxB;AAEO,IAAM,aAAa,oBAAI,QAA2C,CAAC,CAAC;AAEpE,SAAS,sBAAsB,SAAoC;AACxE,QAAM,cAAc,mBAAmB,OAAO;AAC9C,QAAM,OAAO,IAAI,OAAO,WAAW;AACnC,aAAW,IAAI,SAAS,IAAI;AAC5B,SAAO;AACT;AAEO,SAAS,kBAAkB,SAAoC;AACpE,SAAO,WAAW,IAAI,OAAO;AAC/B;AAEO,SAAS,mBAAmB,SAAoC;AAErE,QAAM,cAAc,QAAQ,mBACxB,QAAQ,SACR,QAAQ,OAAO,SACf,QAAQ,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,GAAG,QAAQ,UAAU,CAAC,CAAC,CAAC,IAC9D,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC;AAGhB,QAAM,UAAyB;AAAA,IAC7B,kBAAkB,QAAQ;AAAA,IAC1B,MAAM,QAAQ,cAAc;AAAA,IAC5B,UAAU;AAAA,IACV,WAAW;AAAA,IACX,YAAY;AAAA,IACZ,QAAQ,CAAC,MAAM,KAAK,IAAK,IAAI,KAAK,KAAM,CAAC;AAAA;AAAA,IACzC,MAAM,CAAC,CAAC,QAAQ;AAAA;AAAA,EAClB;AAEA,SAAO,qBAAqB,GAAU,aAA2B,OAAO,CAAC;AAC3E;AAEA,SAAS,IAAII,IAAaC,IAAa;AACrC,SAAO,EAAED,GAAE,CAAC,IAAIC,GAAE,CAAC,KAAK,IAAID,GAAE,CAAC,IAAIC,GAAE,CAAC,KAAK,CAAC;AAC9C;AAKA,IAAM,qBAAqB;AAE3B,SAAS,qBAAqB,QAA4B;AACxD,MAAI,CAAC,OAAO,QAAQ;AAClB,WAAO;AAAA,EACT;AAEA,QAAM,MAAM,OAAO,SAAS;AAE5B,SAAO,OACJ;AAAA,IACC,CAAC,KAAK,OAAO,GAAG,QAAQ;AACtB,UAAI,MAAM,KAAK;AACb,YAAI,KAAK,OAAO,IAAI,OAAO,IAAI,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,GAAG,GAAG;AAAA,MACtD,OAAO;AACL,YAAI,KAAK,OAAO,IAAI,OAAO,IAAI,IAAI,CAAC,CAAC,CAAC;AAAA,MACxC;AACA,aAAO;AAAA,IACT;AAAA,IACA,CAAC,KAAK,OAAO,CAAC,GAAG,GAAG;AAAA,EACtB,EACC,KAAK,GAAG,EACR,QAAQ,oBAAoB,IAAI;AACrC;;;AqB/jCA;AAEO,IAAM,gBAAgB,CAAC,SAC5B,SAAS,eACT,SAAS,YACT,SAAS,gBACT,SAAS,aACT,SAAS,aACT,SAAS,UACT,SAAS;AAEJ,IAAM,iBAAiB,CAAC,SAC7B,SAAS,WAAW,SAAS,WAAW,SAAS;AAE5C,IAAM,iBAAiB,CAAC,SAC7B,SAAS,eACT,SAAS,YACT,SAAS,gBACT,SAAS,aACT,SAAS,aACT,SAAS,cACT,SAAS,WACT,SAAS;AAEJ,IAAM,iBAAiB,CAAC,SAC7B,SAAS,eACT,SAAS,YACT,SAAS,gBACT,SAAS,aACT,SAAS,aACT,SAAS,WACT,SAAS;AAEJ,IAAM,qBAAqB,CAAC,SACjC,SAAS,eACT,SAAS,YACT,SAAS,gBACT,SAAS,UACT,SAAS,aACT,SAAS;AAEJ,IAAM,cAAc,CAAC,SAA4B,SAAS;AAE1D,IAAM,oBAAoB,CAAC,SAA4B,SAAS;;;AtBkChE,IAAM,aAAN,MAAM,YAAW;AAAA,EACtB,OAAe,KAAK,IAAI,eAAe;AAAA,EACvC,OAAe,QAAQ,oBAAI,QAAyC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMpE,OAAc,MAAM,CAA8B,YAAe;AAC/D,WAAO,YAAW,MAAM;AAAA,MACtB;AAAA,IACF;AAAA,EAGF;AAAA,EAEA,OAAc,MAAM,CAClB,SACA,UAGG,YAAW,MAAM,IAAI,SAAS,KAAK;AAAA,EAExC,OAAc,SAAS,CAAC,YACtB,YAAW,MAAM,OAAO,OAAO;AAAA,EAEjC,OAAc,UAAU,MAAM;AAC5B,gBAAW,QAAQ,oBAAI,QAAQ;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAc,uBAAuB,CAGnC,SACA,iBAKG;AAEH,UAAM,cAAc,cAAc,cAC9B,SACA,YAAW,IAAI,OAAO;AAI1B,QAAI,gBAAgB,QAAW;AAC7B,aAAO;AAAA,IACT;AAEA,2BAAuB,OAAO,OAAO;AAErC,UAAM,QAAQ;AAAA,MACZ;AAAA,MACA,YAAW;AAAA,MACX,gBAAgB;AAAA,QACd,aAAa;AAAA,QACb,uBAAuB,cAAc;AAAA,QACrC,wBAAwB;AAAA,MAC1B;AAAA,IACF;AAIA,gBAAW,MAAM,IAAI,SAAS,KAAK;AAEnC,WAAO;AAAA,EACT;AACF;AAEA,IAAM,qBAAqB,CAAC,gBAAwB,CAAC,GAAG,IAAI,WAAW;AAEvE,IAAM,qBAAqB,CAAC,gBAAwB,CAAC,KAAK,IAAI,WAAW;AAEzE,SAAS,gBAAgB,SAAoC;AAC3D,QAAM,YAAY,QAAQ;AAE1B,QAAM,UAAU,KAAK,IAAI,QAAQ,OAAO,QAAQ,MAAM;AACtD,QAAM,UAAU,KAAK,IAAI,QAAQ,OAAO,QAAQ,MAAM;AAGtD;AAAA;AAAA,IAEG,WAAW,MAAM,WAAW;AAAA,IAE5B,WAAW,MACV,CAAC,CAAC,QAAQ,aACV,mBAAmB,QAAQ,IAAI;AAAA,IAEhC,gBAAgB,OAAO,KAAK,WAAW;AAAA,IACxC;AACA,WAAO;AAAA,EACT;AAEA,SAAO,KAAK,IAAI,aAAa,UAAU,KAAK,IAAI,IAAI,GAAG;AACzD;AAEO,IAAM,uBAAuB,CAClC,SACA,iBAAiB,UACL;AACZ,QAAM,UAAmB;AAAA,IACvB,MAAM,QAAQ;AAAA,IACd,gBACE,QAAQ,gBAAgB,WACpB,mBAAmB,QAAQ,WAAW,IACtC,QAAQ,gBAAgB,WACxB,mBAAmB,QAAQ,WAAW,IACtC;AAAA;AAAA;AAAA,IAGN,oBAAoB,QAAQ,gBAAgB;AAAA;AAAA;AAAA,IAG5C,aACE,QAAQ,gBAAgB,UACpB,QAAQ,cAAc,MACtB,QAAQ;AAAA;AAAA;AAAA;AAAA,IAId,YAAY,QAAQ,cAAc;AAAA,IAClC,YAAY,QAAQ,cAAc;AAAA,IAClC,WAAW,gBAAgB,OAAO;AAAA,IAClC,QAAQ,QAAQ;AAAA,IAChB,kBACE,kBAAkB,QAAQ,YAAY,UAAU;AAAA,EACpD;AAEA,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK,WAAW;AACd,cAAQ,YAAY,QAAQ;AAC5B,cAAQ,OAAOC,eAAc,QAAQ,eAAe,IAChD,SACA,QAAQ;AACZ,UAAI,QAAQ,SAAS,WAAW;AAC9B,gBAAQ,eAAe;AAAA,MACzB;AACA,aAAO;AAAA,IACT;AAAA,IACA,KAAK;AAAA,IACL,KAAK,YAAY;AACf,UAAI,YAAY,QAAQ,MAAM,GAAG;AAC/B,gBAAQ,YAAY,QAAQ;AAC5B,gBAAQ,OACN,QAAQ,oBAAoB,gBACxB,SACA,QAAQ;AAAA,MAChB;AACA,aAAO;AAAA,IACT;AAAA,IACA,KAAK;AACH,aAAO;AAAA,IACT,SAAS;AACP,YAAM,IAAI,MAAM,sBAAsB,QAAQ,IAAI,EAAE;AAAA,IACtD;AAAA,EACF;AACF;AAEA,IAAM,kCAAkC,CACtC,SACA,aACA,2BACG;AACH,MACE,oBAAoB,OAAO,MAC1B,eACE,oBAAoB,OAAO,KAC1B,wBAAwB,IAAI,QAAQ,EAAE,MAAM,SAChDA,eAAc,QAAQ,eAAe,KACrCA,eAAc,QAAQ,WAAW,GACjC;AACA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,WAAW;AAAA,MACX,iBAAiB;AAAA,MACjB,WAAW;AAAA,IACb;AAAA,EACF,WAAW,gBAAgB,OAAO,GAAG;AACnC,WAAO;AAAA,MACL,GAAG;AAAA,MACH,aAAaA,eAAc,QAAQ,WAAW,IAC1C,YACA,QAAQ;AAAA,MACZ,iBAAiBA,eAAc,QAAQ,eAAe,IAClD,YACA,QAAQ;AAAA,IACd;AAAA,EACF;AACA,SAAO;AACT;AAEA,IAAM,qBAAqB,CACzB,SACA,OACA,UACA,WACA,WACA,SACA,0BACG;AACH,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,oBAAoB,MAAM;AAC5B,WAAO,CAAC;AAAA,EACV;AAEA,QAAM,sBAAsB,CAC1BC,kBACAC,aACG;AACH,QAAID,qBAAoB,MAAM;AAC5B,aAAO,CAAC;AAAA,IACV;AAEA,UAAM,CAAC,EAAE,EAAE,IAAI,IAAI,IAAI,EAAE,IAAIA;AAE7B,WAAO,CAAC,UAAU,KAAK,IAAI,IAAI,IAAI,IAAIC,QAAO,CAAC;AAAA,EACjD;AAEA,UAAQ,WAAW;AAAA,IACjB,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK,kBAAkB;AACrB,YAAM,CAAC,GAAG,GAAG,QAAQ,IAAI;AAGzB,aAAO,QAAQ;AAEf,aAAO;AAAA,QACL,UAAU,OAAO,GAAG,GAAG,UAAU;AAAA,UAC/B,GAAG;AAAA,UACH,MACE,cAAc,mBACV,wBACA,QAAQ;AAAA,UAEd,WAAW;AAAA,UACX,QAAQ,QAAQ;AAAA,UAChB,WAAW,KAAK,IAAI,KAAK,QAAQ,aAAa,CAAC;AAAA,QACjD,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IACA,KAAK;AAAA,IACL,KAAK,oBAAoB;AACvB,YAAM,CAAC,GAAG,GAAG,IAAI,IAAI,IAAI,EAAE,IAAI;AAG/B,aAAO,QAAQ;AAEf,aAAO;AAAA,QACL,UAAU;AAAA,UACR;AAAA,YACE,CAAC,GAAG,CAAC;AAAA,YACL,CAAC,IAAI,EAAE;AAAA,YACP,CAAC,IAAI,EAAE;AAAA,YACP,CAAC,GAAG,CAAC;AAAA,UACP;AAAA,UACA;AAAA,YACE,GAAG;AAAA,YACH,MACE,cAAc,qBACV,wBACA,QAAQ;AAAA,YACd,WAAW;AAAA,YACX,WAAW,KAAK,IAAI,GAAG,QAAQ,aAAa,CAAC;AAAA,UAC/C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA,KAAK;AAAA,IACL,KAAK,mBAAmB;AACtB,YAAM,CAAC,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,IAAI;AAGvC,aAAO,QAAQ;AAEf,aAAO;AAAA,QACL,UAAU;AAAA,UACR;AAAA,YACE,CAAC,GAAG,CAAC;AAAA,YACL,CAAC,IAAI,EAAE;AAAA,YACP,CAAC,IAAI,EAAE;AAAA,YACP,CAAC,IAAI,EAAE;AAAA,YACP,CAAC,GAAG,CAAC;AAAA,UACP;AAAA,UACA;AAAA,YACE,GAAG;AAAA,YACH,MACE,cAAc,oBACV,wBACA,QAAQ;AAAA,YACd,WAAW;AAAA,YACX,WAAW,KAAK,IAAI,GAAG,QAAQ,aAAa,CAAC;AAAA,UAC/C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA,KAAK;AACH,aAAO,oBAAoB,iBAAiB,OAAO;AAAA,IACrD,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,SAAS;AACP,YAAM,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,IAAI;AAEjC,UAAI,QAAQ,gBAAgB,UAAU;AAEpC,cAAM,OAAO,mBAAmB,QAAQ,cAAc,CAAC;AACvD,gBAAQ,iBAAiB,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC;AAAA,MAChD,OAAO;AAEL,eAAO,QAAQ;AAAA,MACjB;AACA,cAAQ,YAAY,KAAK,IAAI,GAAG,QAAQ,aAAa,CAAC;AACtD,aAAO;AAAA,QACL,UAAU,KAAK,IAAI,IAAI,IAAI,IAAI,OAAO;AAAA,QACtC,UAAU,KAAK,IAAI,IAAI,IAAI,IAAI,OAAO;AAAA,QACtC,GAAI,cAAc,yBACd;AAAA,UACE,mBAAmB,SAAS,OAAO,UAAU,cAAc;AAAA,UAC3D;AAAA,QACF,IACA,CAAC;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,+BAA+B,CAC1C,YACG;AACH,QAAM,YAAY,IAAI,eAAe;AACrC,QAAM,UAAmB;AAAA,IACvB,MAAM,QAAQ;AAAA,IACd,oBAAoB;AAAA,IACpB,wBAAwB;AAAA,IACxB,WAAW;AAAA,IACX,kBAAkB;AAAA,EACpB;AACA,QAAM,SAAS;AAAA;AAAA,IAEb,QAAQ,OAAO;AAAA,MACb,CAAC,KAAK,UAAU;AACd,eAAO;AAAA,UACL,KAAK,IAAI,QAAQ,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC;AAAA,UACrC,KAAK,IAAI,QAAQ,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC;AAAA,UACrC,KAAK,IAAI,QAAQ,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC;AAAA,UACrC,KAAK,IAAI,QAAQ,IAAI,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC;AAAA,QACvC;AAAA,MACF;AAAA,MACA,CAAC,UAAU,UAAU,WAAW,SAAS;AAAA,IAC3C;AAAA,EACF;AAEA,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK;AAAA,IACL,KAAK,SAAS;AAGZ,YAAM,SAAS,QAAQ,OAAO,SAC1B,QAAQ,SACR,CAACC,YAAsB,GAAG,CAAC,CAAC;AAEhC,UAAI,aAAa,OAAO,GAAG;AACzB,eAAO,UAAU,KAAK,wBAAwB,QAAQ,EAAE,GAAG,OAAO,EAC/D,KAAK,CAAC,EAAE;AAAA,MACb,WAAW,CAAC,QAAQ,WAAW;AAC7B,eAAO,OAAO,IAAI,CAAC,OAAO,QAAQ;AAChC,gBAAM,IAAIC;AAAA,YACRD,YAAuB,QAAQ,IAAI,MAAM,CAAC,GAAG,QAAQ,IAAI,MAAM,CAAC,CAAC;AAAA,YACjE;AAAA,YACA,QAAQ;AAAA,UACV;AAEA,iBAAO;AAAA,YACL,IAAI,QAAQ,IAAI,SAAS;AAAA,YACzB,MAAMA,YAAsB,EAAE,CAAC,IAAI,QAAQ,GAAG,EAAE,CAAC,IAAI,QAAQ,CAAC;AAAA,UAChE;AAAA,QACF,CAAC;AAAA,MACH;AAEA,aAAO,UACJ,MAAM,QAAmC,OAAO,EAChD,KAAK,CAAC,EAAE,IAAI,MAAM,GAAG,QAAQ,OAAO,MAAM,EAC1C,IAAI,CAAC,IAAI,MAAM;AACd,YAAI,MAAM,GAAG;AACX,gBAAM,IAAIC;AAAA,YACRD;AAAA,cACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,YACvB;AAAA,YACA;AAAA,YACA,QAAQ;AAAA,UACV;AAEA,iBAAO;AAAA,YACL,IAAI;AAAA,YACJ,MAAMA,YAAsB,EAAE,CAAC,IAAI,QAAQ,GAAG,EAAE,CAAC,IAAI,QAAQ,CAAC;AAAA,UAChE;AAAA,QACF;AAEA,eAAO;AAAA,UACL,IAAI;AAAA,UACJ,MAAM;AAAA,YACJC;AAAA,cACED;AAAA,gBACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,gBACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACvB;AAAA,cACA;AAAA,cACA,QAAQ;AAAA,YACV;AAAA,YACAC;AAAA,cACED;AAAA,gBACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,gBACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACvB;AAAA,cACA;AAAA,cACA,QAAQ;AAAA,YACV;AAAA,YACAC;AAAA,cACED;AAAA,gBACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,gBACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACvB;AAAA,cACA;AAAA,cACA,QAAQ;AAAA,YACV;AAAA,UACF,EACG;AAAA,YAAI,CAAC,MACJA,YAAsB,EAAE,CAAC,IAAI,QAAQ,GAAG,EAAE,CAAC,IAAI,QAAQ,CAAC;AAAA,UAC1D,EACC,KAAK;AAAA,QACV;AAAA,MACF,CAAC;AAAA,IACL;AAAA,IACA,KAAK,YAAY;AACf,UAAI,QAAQ,OAAO,SAAS,GAAG;AAC7B,eAAO,CAAC;AAAA,MACV;AAEA,YAAM,mBAAmB;AAAA,QACvB,QAAQ;AAAA,QACR;AAAA,MACF;AAEA,aAAO,UACJ,MAAM,kBAAwC,OAAO,EACrD,KAAK,CAAC,EAAE,IAAI,MAAM,GAAG,QAAQ,OAAO,MAAM,EAC1C,IAAI,CAAC,IAAI,MAAM;AACd,YAAI,MAAM,GAAG;AACX,gBAAM,IAAIC;AAAA,YACRD;AAAA,cACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,YACvB;AAAA,YACA;AAAA,YACA,QAAQ;AAAA,UACV;AAEA,iBAAO;AAAA,YACL,IAAI;AAAA,YACJ,MAAMA,YAAsB,EAAE,CAAC,IAAI,QAAQ,GAAG,EAAE,CAAC,IAAI,QAAQ,CAAC;AAAA,UAChE;AAAA,QACF;AAEA,eAAO;AAAA,UACL,IAAI;AAAA,UACJ,MAAM;AAAA,YACJC;AAAA,cACED;AAAA,gBACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,gBACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACvB;AAAA,cACA;AAAA,cACA,QAAQ;AAAA,YACV;AAAA,YACAC;AAAA,cACED;AAAA,gBACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,gBACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACvB;AAAA,cACA;AAAA,cACA,QAAQ;AAAA,YACV;AAAA,YACAC;AAAA,cACED;AAAA,gBACE,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,gBACrB,QAAQ,IAAI,GAAG,KAAK,CAAC;AAAA,cACvB;AAAA,cACA;AAAA,cACA,QAAQ;AAAA,YACV;AAAA,UACF,EACG;AAAA,YAAI,CAAC,MACJA,YAAsB,EAAE,CAAC,IAAI,QAAQ,GAAG,EAAE,CAAC,IAAI,QAAQ,CAAC;AAAA,UAC1D,EACC,KAAK;AAAA,QACV;AAAA,MACF,CAAC;AAAA,IACL;AAAA,EACF;AACF;AASA,IAAM,uBAAuB,CAC3B,SACA,WACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AACF,MAKiC;AACjC,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK,cAAc;AACjB,UAAI;AAIJ,UAAI,QAAQ,WAAW;AACrB,cAAM,IAAI,QAAQ;AAClB,cAAM,IAAI,QAAQ;AAClB,cAAM,IAAI,gBAAgB,KAAK,IAAI,GAAG,CAAC,GAAG,OAAO;AACjD,gBAAQ,UAAU;AAAA,UAChB,KAAK,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,IAC9C,IAAI,CACN,MAAM,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,OAC9C,IAAI,CACN,QAAQ,CAAC,WAAW,CAAC;AAAA,UACrB;AAAA,YACE;AAAA,cACE;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF,OAAO;AACL,gBAAQ,UAAU;AAAA,UAChB;AAAA,UACA;AAAA,UACA,QAAQ;AAAA,UACR,QAAQ;AAAA,UACR;AAAA,YACE;AAAA,cACE;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,IACA,KAAK,WAAW;AACd,UAAI;AAEJ,YAAM,CAAC,MAAM,MAAM,QAAQ,QAAQ,SAAS,SAAS,OAAO,KAAK,IAC/D,iBAAiB,OAAO;AAC1B,UAAI,QAAQ,WAAW;AACrB,cAAM,iBAAiB,gBAAgB,KAAK,IAAI,OAAO,KAAK,GAAG,OAAO;AAEtE,cAAM,mBAAmB;AAAA,UACvB,KAAK,IAAI,SAAS,IAAI;AAAA,UACtB;AAAA,QACF;AAEA,gBAAQ,UAAU;AAAA,UAChB,KAAK,OAAO,cAAc,IAAI,OAAO,gBAAgB,MACnD,SAAS,cACX,IAAI,SAAS,gBAAgB;AAAA,gBACvB,MAAM,IAAI,MAAM,KAAK,MAAM,IAAI,MAAM,KACzC,SAAS,cACX,IAAI,SAAS,gBAAgB;AAAA,gBACvB,UAAU,cAAc,IAAI,UAAU,gBAAgB;AAAA,gBACtD,OAAO,IAAI,OAAO,KAAK,OAAO,IAAI,OAAO,KAC7C,UAAU,cACZ,IAAI,UAAU,gBAAgB;AAAA,gBACxB,QAAQ,cAAc,IAAI,QAAQ,gBAAgB;AAAA,gBAClD,KAAK,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK,QAAQ,cAAc,IAChE,QAAQ,gBACV;AAAA,gBACM,OAAO,cAAc,IAAI,OAAO,gBAAgB;AAAA,gBAChD,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,OAAO,cAAc,IAC3D,OAAO,gBACT;AAAA,UACA,qBAAqB,SAAS,IAAI;AAAA,QACpC;AAAA,MACF,OAAO;AACL,gBAAQ,UAAU;AAAA,UAChB;AAAA,YACE,CAAC,MAAM,IAAI;AAAA,YACX,CAAC,QAAQ,MAAM;AAAA,YACf,CAAC,SAAS,OAAO;AAAA,YACjB,CAAC,OAAO,KAAK;AAAA,UACf;AAAA,UACA,qBAAqB,OAAO;AAAA,QAC9B;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,IACA,KAAK,WAAW;AACd,YAAM,QAA4C,UAAU;AAAA,QAC1D,QAAQ,QAAQ;AAAA,QAChB,QAAQ,SAAS;AAAA,QACjB,QAAQ;AAAA,QACR,QAAQ;AAAA,QACR,qBAAqB,OAAO;AAAA,MAC9B;AACA,aAAO;AAAA,IACT;AAAA,IACA,KAAK;AAAA,IACL,KAAK,SAAS;AACZ,UAAI;AACJ,YAAM,UAAU,qBAAqB,OAAO;AAI5C,YAAM,SAAS,QAAQ,OAAO,SAC1B,QAAQ,SACR,CAACA,YAAsB,GAAG,CAAC,CAAC;AAEhC,UAAI,aAAa,OAAO,GAAG;AAEzB,YACE,CAAC,OAAO;AAAA,UACN,CAAC,UAAU,KAAK,IAAI,MAAM,CAAC,CAAC,KAAK,OAAO,KAAK,IAAI,MAAM,CAAC,CAAC,KAAK;AAAA,QAChE,GACA;AACA,kBAAQ;AAAA,YACN;AAAA,YACA,QAAQ;AAAA,YACR,KAAK,UAAU,MAAM;AAAA,UACvB;AACA,kBAAQ,CAAC;AAAA,QACX,OAAO;AACL,kBAAQ;AAAA,YACN,UAAU;AAAA,cACR,wBAAwB,QAAQ,EAAE;AAAA,cAClC,qBAAqB,SAAS,IAAI;AAAA,YACpC;AAAA,UACF;AAAA,QACF;AAAA,MACF,WAAW,CAAC,QAAQ,WAAW;AAG7B,YAAI,QAAQ,MAAM;AAChB,kBAAQ;AAAA,YACN,UAAU,QAAQ,QAAmC,OAAO;AAAA,UAC9D;AAAA,QACF,OAAO;AACL,kBAAQ;AAAA,YACN,UAAU,WAAW,QAAmC,OAAO;AAAA,UACjE;AAAA,QACF;AAAA,MACF,OAAO;AACL,gBAAQ,CAAC,UAAU,MAAM,QAAmC,OAAO,CAAC;AAAA,MACtE;AAGA,UAAI,QAAQ,SAAS,SAAS;AAC5B,cAAM,EAAE,iBAAiB,MAAM,eAAe,QAAQ,IAAI;AAE1D,YAAI,mBAAmB,MAAM;AAC3B,gBAAM,SAAS;AAAA,YACb;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,gBAAM,KAAK,GAAG,MAAM;AAAA,QACtB;AAEA,YAAI,iBAAiB,MAAM;AACzB,cAAI,iBAAiB,QAAW;AAAA,UAEhC;AAEA,gBAAM,SAAS;AAAA,YACb;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,gBAAM,KAAK,GAAG,MAAM;AAAA,QACtB;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,IACA,KAAK,YAAY;AACf,UAAI;AACJ,4BAAsB,OAAO;AAE7B,UAAI,YAAY,QAAQ,MAAM,GAAG;AAE/B,cAAM,mBAAmB;AAAA,UACvB,QAAQ;AAAA,UACR;AAAA,QACF;AACA,gBAAQ,UAAU,MAAM,kBAAwC;AAAA,UAC9D,GAAG,qBAAqB,OAAO;AAAA,UAC/B,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,OAAO;AACL,gBAAQ;AAAA,MACV;AACA,aAAO;AAAA,IACT;AAAA,IACA,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK,SAAS;AACZ,YAAM,QAA4C;AAGlD,aAAO;AAAA,IACT;AAAA,IACA,SAAS;AACP,MAAAE;AAAA,QACE;AAAA,QACA,8CAA+C,SAAiB,IAAI;AAAA,MACtE;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAEA,IAAM,0BAA0B,CAC9B,QACA,WACG;AACH,QAAM,YAAY,CAAC;AACnB,WAAS,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK,GAAG;AAC7C,UAAM,OAAO,OAAO,IAAI,CAAC;AACzB,UAAM,OAAO,OAAO,IAAI,CAAC;AACzB,UAAM,QAAQ,OAAO,CAAC;AACtB,UAAM,mBAAmB,4BAA4B,OAAO,IAAI;AAChE,UAAM,mBAAmB,4BAA4B,MAAM,KAAK;AAChE,UAAM,SAAS,KAAK;AAAA,MAClB;AAAA,MACAC,eAAc,OAAO,CAAC,GAAG,IAAI,IAAI;AAAA,MACjCA,eAAc,OAAO,CAAC,GAAG,IAAI,IAAI;AAAA,IACnC;AAEA,QAAI,kBAAkB;AACpB,UAAI,KAAK,CAAC,IAAI,MAAM,CAAC,GAAG;AAEtB,kBAAU,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,QAAQ,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;AAAA,MACtD,OAAO;AAEL,kBAAU,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,QAAQ,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;AAAA,MACtD;AAAA,IACF,WAAW,KAAK,CAAC,IAAI,MAAM,CAAC,GAAG;AAE7B,gBAAU,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC;AAAA,IACtD,OAAO;AACL,gBAAU,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC;AAAA,IACtD;AAEA,cAAU,KAAK,OAAO,CAAC,CAAqB;AAE5C,QAAI,kBAAkB;AACpB,UAAI,KAAK,CAAC,IAAI,MAAM,CAAC,GAAG;AAEtB,kBAAU,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,QAAQ,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;AAAA,MACtD,OAAO;AAEL,kBAAU,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,QAAQ,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;AAAA,MACtD;AAAA,IACF,WAAW,KAAK,CAAC,IAAI,MAAM,CAAC,GAAG;AAE7B,gBAAU,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC;AAAA,IACtD,OAAO;AAEL,gBAAU,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC;AAAA,IACtD;AAAA,EACF;AAEA,QAAM,IAAI,CAAC,KAAK,OAAO,CAAC,EAAE,CAAC,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE;AAC9C,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK,GAAG;AAC5C,MAAE,KAAK,KAAK,UAAU,CAAC,EAAE,CAAC,CAAC,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC,EAAE;AAChD,MAAE;AAAA,MACA,KAAK,UAAU,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,UAAU,IAAI,CAAC,EAAE,CAAC,CAAC,KAC7C,UAAU,IAAI,CAAC,EAAE,CAAC,CACpB,IAAI,UAAU,IAAI,CAAC,EAAE,CAAC,CAAC;AAAA,IACzB;AAAA,EACF;AACA,IAAE,KAAK,KAAK,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,CAAC,IAAI,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE;AAE1E,SAAO,EAAE,KAAK,GAAG;AACnB;AAMO,IAAM,kBAAkB,CAC7B,SACA,gBAC0B;AAC1B,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO,gBAAgB,OAAO;AAAA,IAChC,KAAK;AAAA,IACL,KAAK,QAAQ;AACX,YAAM,aACJ,WAAW,IAAI,OAAO,IAAI,CAAC,KAC3B,WAAW,qBAAqB,SAAS,IAAI,EAAE,CAAC;AAClD,YAAM,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,IAAIC,0BAAyB,SAAS,WAAW;AAEtE,aAAO,iBAAiB,OAAO,IAC3B;AAAA,QACE;AAAA,QACA;AAAA,QACAJ,YAAiB,QAAQ,GAAG,QAAQ,CAAC;AAAA,QACrC,QAAQ;AAAA,QACRA,YAAU,IAAI,EAAE;AAAA,MAClB,IACA;AAAA,QACE;AAAA,QACAA,YAAiB,QAAQ,GAAG,QAAQ,CAAC;AAAA,QACrC,QAAQ;AAAA,QACRA,YAAU,IAAI,EAAE;AAAA,MAClB;AAAA,IACN;AAAA,IAEA,KAAK;AACH,aAAO,gBAAgB,OAAO;AAAA,IAEhC,KAAK,YAAY;AACf,YAAM,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,IAAII,0BAAyB,SAAS,WAAW;AACtE,aAAO;AAAA,QACL;AAAA,QACAJ,YAAU,IAAI,EAAE;AAAA,QAChB,iBAAiB,OAAO;AAAA,MAC1B;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,yBAAyB,CACpC,SACA,qBAIU;AACV,QAAM,gBAAgB,CAAC,GAAG,QAAQ,MAAM;AAExC,MAAI,kBAAkB;AACpB,QAAI,CAAC,iBAAiB,QAAQ,MAAM,GAAG;AACrC,aAAO;AAAA,IACT;AAEA,UAAM,aAAa,cAAc,CAAC;AAClC,UAAM,YAAY,cAAc,cAAc,SAAS,CAAC;AAExD,UAAMK,YAAW,KAAK;AAAA,MACpB,WAAW,CAAC,IAAI,UAAU,CAAC;AAAA,MAC3B,WAAW,CAAC,IAAI,UAAU,CAAC;AAAA,IAC7B;AAEA,QACEA,YAAW,qCACX,cAAc,SAAS,GACvB;AACA,oBAAc,KAAKL,YAAU,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC;AAAA,IAC5D,OAAO;AACL,oBAAc,cAAc,SAAS,CAAC,IAAIA;AAAA,QACxC,WAAW,CAAC;AAAA,QACZ,WAAW,CAAC;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAGA,QAAM,MAAM;AAAA,IACV,SAAS;AAAA,IACT,QAAQ;AAAA,EACV;AAEA,SAAO;AACT;;;A1B54BO,IAAM,gBAAN,MAAM,eAAc;AAAA,EACzB,OAAe,cAAc,oBAAI,QAM/B;AAAA,EACF,OAAe,wBAAwB,oBAAI,QAMzC;AAAA,EAEF,OAAO,UACL,SACA,aACA,aAAsB,OACtB;AACA,UAAM,eACJ,cAAc,QAAQ,UAAU,IAC5B,eAAc,sBAAsB,IAAI,OAAO,IAC/C,eAAc,YAAY,IAAI,OAAO;AAE3C,QACE,cAAc,WACd,aAAa,YAAY,QAAQ;AAAA;AAAA,IAGjC,CAAC,mBAAmB,OAAO,GAC3B;AACA,aAAO,aAAa;AAAA,IACtB;AAEA,QAAI,cAAc,QAAQ,UAAU,GAAG;AACrC,YAAM,mBAAmB,eAAc;AAAA,QACrC;AAAA,UACE,GAAG;AAAA,UACH,OAAO;AAAA,QACT;AAAA,QACA;AAAA,MACF;AACA,qBAAc,sBAAsB,IAAI,SAAS;AAAA,QAC/C,SAAS,QAAQ;AAAA,QACjB,QAAQ;AAAA,MACV,CAAC;AAED,aAAO;AAAA,IACT;AAEA,UAAM,SAAS,eAAc,gBAAgB,SAAS,WAAW;AAEjE,mBAAc,YAAY,IAAI,SAAS;AAAA,MACrC,SAAS,QAAQ;AAAA,MACjB;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAEA,OAAe,gBACb,SACA,aACQ;AACR,QAAI;AAEJ,UAAM,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,IAAIM;AAAA,MAC/B;AAAA,MACA;AAAA,IACF;AACA,QAAI,kBAAkB,OAAO,GAAG;AAC9B,YAAM,CAAC,MAAM,MAAM,MAAM,IAAI,IAAI;AAAA,QAC/B,QAAQ,OAAO;AAAA,UAAI,CAAC,CAAC,GAAG,CAAC,MACvBC;AAAA,YACEC,YAAU,GAAG,CAAC;AAAA,YACdA,YAAU,KAAK,QAAQ,GAAG,KAAK,QAAQ,CAAC;AAAA,YACxC,QAAQ;AAAA,UACV;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,QACL,OAAO,QAAQ;AAAA,QACf,OAAO,QAAQ;AAAA,QACf,OAAO,QAAQ;AAAA,QACf,OAAO,QAAQ;AAAA,MACjB;AAAA,IACF,WAAW,gBAAgB,OAAO,GAAG;AACnC,eAAS,8BAA8B,SAAS,IAAI,IAAI,WAAW;AAAA,IACrE,WAAW,QAAQ,SAAS,WAAW;AACrC,YAAM,CAAC,KAAK,GAAG,IAAID;AAAA,QACjBC,YAAU,IAAI,EAAE;AAAA,QAChBA,YAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AACA,YAAM,CAAC,KAAK,GAAG,IAAID;AAAA,QACjBC,YAAU,IAAI,EAAE;AAAA,QAChBA,YAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AACA,YAAM,CAAC,KAAK,GAAG,IAAID;AAAA,QACjBC,YAAU,IAAI,EAAE;AAAA,QAChBA,YAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AACA,YAAM,CAAC,KAAK,GAAG,IAAID;AAAA,QACjBC,YAAU,IAAI,EAAE;AAAA,QAChBA,YAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AACA,YAAM,OAAO,KAAK,IAAI,KAAK,KAAK,KAAK,GAAG;AACxC,YAAM,OAAO,KAAK,IAAI,KAAK,KAAK,KAAK,GAAG;AACxC,YAAM,OAAO,KAAK,IAAI,KAAK,KAAK,KAAK,GAAG;AACxC,YAAM,OAAO,KAAK,IAAI,KAAK,KAAK,KAAK,GAAG;AACxC,eAAS,CAAC,MAAM,MAAM,MAAM,IAAI;AAAA,IAClC,WAAW,QAAQ,SAAS,WAAW;AACrC,YAAM,KAAK,KAAK,MAAM;AACtB,YAAM,KAAK,KAAK,MAAM;AACtB,YAAM,MAAM,KAAK,IAAI,QAAQ,KAAK;AAClC,YAAM,MAAM,KAAK,IAAI,QAAQ,KAAK;AAClC,YAAM,KAAK,KAAK,MAAM,IAAI,KAAK,IAAI,GAAG;AACtC,YAAM,KAAK,KAAK,MAAM,IAAI,KAAK,IAAI,GAAG;AACtC,eAAS,CAAC,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,EAAE;AAAA,IAC9C,OAAO;AACL,YAAM,CAAC,KAAK,GAAG,IAAID;AAAA,QACjBC,YAAU,IAAI,EAAE;AAAA,QAChBA,YAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AACA,YAAM,CAAC,KAAK,GAAG,IAAID;AAAA,QACjBC,YAAU,IAAI,EAAE;AAAA,QAChBA,YAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AACA,YAAM,CAAC,KAAK,GAAG,IAAID;AAAA,QACjBC,YAAU,IAAI,EAAE;AAAA,QAChBA,YAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AACA,YAAM,CAAC,KAAK,GAAG,IAAID;AAAA,QACjBC,YAAU,IAAI,EAAE;AAAA,QAChBA,YAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AACA,YAAM,OAAO,KAAK,IAAI,KAAK,KAAK,KAAK,GAAG;AACxC,YAAM,OAAO,KAAK,IAAI,KAAK,KAAK,KAAK,GAAG;AACxC,YAAM,OAAO,KAAK,IAAI,KAAK,KAAK,KAAK,GAAG;AACxC,YAAM,OAAO,KAAK,IAAI,KAAK,KAAK,KAAK,GAAG;AACxC,eAAS,CAAC,MAAM,MAAM,MAAM,IAAI;AAAA,IAClC;AAEA,WAAO;AAAA,EACT;AACF;AAMO,IAAMF,4BAA2B,CACtC,SACA,aACA,mBAA4B,UACyB;AACrD,MAAI,kBAAkB,OAAO,GAAG;AAC9B,WAAO,iCAAiC,OAAO;AAAA,EACjD,WAAW,gBAAgB,OAAO,GAAG;AACnC,WAAO,oBAAoB;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,WAAW,cAAc,OAAO,GAAG;AACjC,UAAM,YAAY,cACd,oBAAoB,SAAS,WAAW,IACxC;AACJ,QAAI,eAAe,SAAS,GAAG;AAC7B,YAAM,EAAE,GAAG,EAAE,IAAI,oBAAoB;AAAA,QACnC;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,IAAI,QAAQ;AAAA,QACZ,IAAI,QAAQ;AAAA,QACZ,IAAI,QAAQ,QAAQ;AAAA,QACpB,IAAI,QAAQ,SAAS;AAAA,MACvB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ,IAAI,QAAQ;AAAA,IACpB,QAAQ,IAAI,QAAQ;AAAA,IACpB,QAAQ,IAAI,QAAQ,QAAQ;AAAA,IAC5B,QAAQ,IAAI,QAAQ,SAAS;AAAA,EAC/B;AACF;AAYO,IAAM,yBAAyB,CACpC,SACA,gBAC+B;AAC/B,QAAM,QAAQ,gBAAgB,SAAS,WAAW;AAClD,QAAM,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,IAAIA;AAAA,IAC/B;AAAA,IACA;AAAA,EACF;AACA,QAAM,SAASE,YAAuB,IAAI,EAAE;AAE5C,MAAI,MAAM,SAAS,aAAa;AAC9B,UAAM,SAAS,MAAM;AACrB,UAAM,SAAS,OACZ,IAAI,CAACC,WAAU,qBAAqBA,QAAO,EAAE,CAAC,EAC9C,KAAK;AACR,QAAI,IAAI;AACR,UAAM,WAAuC,CAAC;AAC9C,WAAO,IAAI,OAAO,SAAS,GAAG;AAC5B,eAAS;AAAA,QACPC;AAAA,UACEF,YAAU,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC;AAAA,UACpCA,YAAU,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC;AAAA,QAC9C;AAAA,MACF;AACA;AAAA,IACF;AAEA,WAAO;AAAA,EACT,WAAW,MAAM,SAAS,YAAY;AACpC,WAAO,MAAM;AAAA,EACf,WAAW,uBAAuB,OAAO,GAAG;AAC1C,UAAM,CAAC,OAAO,OAAO,IAAI,+BAA+B,OAAO;AAC/D,UAAM,iBAA6C,QAChD,IAAI,CAAC,WAAW,mBAAmB,QAAQ,QAAQ,QAAQ,KAAK,CAAC,EACjE,KAAK;AACR,UAAM,eAAe,gBAAgB,OAAO,QAAQ,QAAQ,KAAK;AACjE,WAAO,CAAC,GAAG,cAAc,GAAG,cAAc;AAAA,EAC5C,WAAW,QAAQ,SAAS,WAAW;AACrC,UAAM,CAAC,OAAO,OAAO,IAAI,0BAA0B,OAAO;AAC1D,UAAM,iBAAiB,QACpB,IAAI,CAAC,WAAW,mBAAmB,QAAQ,QAAQ,QAAQ,KAAK,CAAC,EACjE,KAAK;AACR,UAAM,eAAe,gBAAgB,OAAO,QAAQ,QAAQ,KAAK;AAEjE,WAAO,CAAC,GAAG,cAAc,GAAG,cAAc;AAAA,EAC5C,WAAW,MAAM,SAAS,WAAW;AACnC,QAAI,cAAc,OAAO,GAAG;AAC1B,YAAM,YAAY,oBAAoB,SAAS,WAAW;AAC1D,UAAI,aAAa,gBAAgB,SAAS,GAAG;AAC3C,cAAMG,YAAuC;AAAA,UAC3CD,aAAYF,YAAU,IAAI,EAAE,GAAGA,YAAU,IAAI,EAAE,CAAC;AAAA,UAChDE,aAAYF,YAAU,IAAI,EAAE,GAAGA,YAAU,IAAI,EAAE,CAAC;AAAA,UAChDE,aAAYF,YAAU,IAAI,EAAE,GAAGA,YAAU,IAAI,EAAE,CAAC;AAAA,UAChDE,aAAYF,YAAU,IAAI,EAAE,GAAGA,YAAU,IAAI,EAAE,CAAC;AAAA,QAClD;AACA,eAAOG;AAAA,MACT;AAAA,IACF;AAEA,UAAM,SAAS,MAAM;AACrB,UAAM,WAAuC,CAAC;AAC9C,aAAS,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK;AAC1C,eAAS,KAAKD,aAAY,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC,CAAC;AAAA,IACrD;AACA,WAAO;AAAA,EACT,WAAW,MAAM,SAAS,WAAW;AACnC,WAAO,qBAAqB,OAAmC;AAAA,EACjE;AAEA,QAAM,CAAC,IAAI,IAAI,IAAIE,KAAI,EAAE,EAAE,GAAG,CAAC,IAC7B;AAAA,IACE,CAAC,IAAI,EAAE;AAAA,IACP,CAAC,IAAI,EAAE;AAAA,IACP,CAAC,IAAI,EAAE;AAAA,IACP,CAAC,IAAI,EAAE;AAAA,IACP,CAAC,IAAI,EAAE;AAAA,IACP,CAAC,IAAI,EAAE;AAAA,IACP,CAAC,IAAI,EAAE;AAAA,IACP,CAAC,IAAI,EAAE;AAAA,EACT,EACA,IAAI,CAAC,UAAUL,kBAAgB,OAAO,QAAQ,QAAQ,KAAK,CAAC;AAE9D,SAAO;AAAA,IACLG,aAAY,IAAI,EAAE;AAAA,IAClBA,aAAY,IAAIE,GAAE;AAAA,IAClBF,aAAY,IAAI,EAAE;AAAA,IAClBA,aAAY,IAAIE,GAAE;AAAA,IAClBF,aAAY,IAAI,CAAC;AAAA,IACjBA,aAAY,IAAI,CAAC;AAAA,IACjBA,aAAY,IAAI,CAAC;AAAA,IACjBA,aAAYE,KAAI,CAAC;AAAA,EACnB;AACF;AAEA,IAAM,yBAAyB,CAC7B,YAC6C;AAC7C,SACE,WAAW,SACV,QAAQ,SAAS,eAChB,QAAQ,SAAS,WACjB,QAAQ,SAAS,YACjB,QAAQ,SAAS,gBACjB,QAAQ,SAAS,WACjB,QAAQ,SAAS,gBAChB,QAAQ,SAAS,UAAU,CAAC,QAAQ;AAE3C;AAEA,IAAM,kBAAkB,CACtB,OACA,QACA,UACG;AACH,SAAO,MAAM,IAAI,CAAC,SAAS;AACzB,WAAOF;AAAA,MACLH,kBAA6B,KAAK,CAAC,GAAG,QAAQ,KAAK;AAAA,MACnDA,kBAA6B,KAAK,CAAC,GAAG,QAAQ,KAAK;AAAA,IACrD;AAAA,EACF,CAAC;AACH;AAEA,IAAM,qBAAqB,CACzBE,QACA,QACA,UAC+B;AAC/B,QAAM,SAAS,qBAAqBA,QAAO,EAAE;AAC7C,MAAI,IAAI;AACR,QAAM,WAAuC,CAAC;AAC9C,SAAO,IAAI,OAAO,SAAS,GAAG;AAC5B,aAAS;AAAA,MACPC;AAAA,QACEH;AAAA,UACEC,YAAU,OAAO,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC;AAAA,UACpC;AAAA,UACA;AAAA,QACF;AAAA,QACAD;AAAA,UACEC,YAAU,OAAO,IAAI,CAAC,EAAE,CAAC,GAAG,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC;AAAA,UAC5C;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,uBAAuB,CAC3BK,aAC+B;AAC/B,QAAM,SAASL;AAAA,IACbK,SAAQ,IAAIA,SAAQ,QAAQ;AAAA,IAC5BA,SAAQ,IAAIA,SAAQ,SAAS;AAAA,EAC/B;AAEA,QAAMC,KAAID,SAAQ,QAAQ;AAC1B,QAAME,KAAIF,SAAQ,SAAS;AAE3B,QAAM,WAAuC,CAAC;AAC9C,QAAM,SAAwB,CAAC;AAC/B,QAAM,IAAI;AACV,QAAM,SAAU,KAAK,KAAK,IAAK;AAE/B,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,UAAM,IAAI,IAAI;AACd,UAAM,IAAI,OAAO,CAAC,IAAIC,KAAI,KAAK,IAAI,CAAC;AACpC,UAAM,IAAI,OAAO,CAAC,IAAIC,KAAI,KAAK,IAAI,CAAC;AACpC,WAAO,KAAKR,kBAAgBC,YAAU,GAAG,CAAC,GAAG,QAAQK,SAAQ,KAAK,CAAC;AAAA,EACrE;AAEA,WAAS,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK;AAC1C,aAAS,KAAKH,aAAY,OAAO,CAAC,GAAG,OAAO,IAAI,CAAC,CAAC,CAAC;AAAA,EACrD;AAEA,WAAS,KAAKA,aAAY,OAAO,OAAO,SAAS,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;AAC/D,SAAO;AACT;AAOO,IAAM,gCAAgC,CAAC,mBAAiC;AAC7E,SAAO;AAAA,IACL,eAAe;AAAA,IACf,eAAe;AAAA,IACf,eAAe,IAAI,eAAe;AAAA,IAClC,eAAe,IAAI,eAAe;AAAA,IAClC,eAAe,IAAI,eAAe,QAAQ;AAAA,IAC1C,eAAe,IAAI,eAAe,SAAS;AAAA,EAC7C;AACF;AAEO,IAAM,mBAAmB,CAAC,YAA+B;AAG9D,QAAM,OAAO,KAAK,MAAM,QAAQ,QAAQ,CAAC,IAAI;AAC7C,QAAM,OAAO;AACb,QAAM,SAAS,QAAQ;AACvB,QAAM,SAAS,KAAK,MAAM,QAAQ,SAAS,CAAC,IAAI;AAChD,QAAM,UAAU;AAChB,QAAM,UAAU,QAAQ;AACxB,QAAM,QAAQ;AACd,QAAM,QAAQ;AAEd,SAAO,CAAC,MAAM,MAAM,QAAQ,QAAQ,SAAS,SAAS,OAAO,KAAK;AACpE;AAGA,IAAM,qBAAqB,CACzB,GACA,IACA,IACA,IACA,OACG;AACH,QAAM,YAAY,IAAI;AACtB,SACE,KAAK,IAAI,WAAW,CAAC,IAAI,KACzB,IAAI,KAAK,IAAI,WAAW,CAAC,IAAI,IAAI,KACjC,IAAI,YAAY,KAAK,IAAI,GAAG,CAAC,IAAI,KACjC,KAAK,IAAI,GAAG,CAAC,IAAI;AAErB;AAEA,IAAM,iBAAiB,CACrB,IACA,IACA,IACA,OAC2B;AAC3B,QAAM,IAAI,KAAK;AACf,QAAM,IAAI,KAAK;AACf,QAAM,IAAI,KAAK;AAEf,QAAMI,KAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAC9B,QAAMC,KAAI,IAAI,IAAI,IAAI;AACtB,QAAM,IAAI,IAAI;AAEd,QAAM,WAAWA,KAAIA,KAAI,IAAID,KAAI;AACjC,QAAM,cAAc,YAAY;AAEhC,MAAI,CAAC,aAAa;AAChB,WAAO;AAAA,EACT;AAEA,MAAI,KAAK;AACT,MAAI,KAAK;AAET,MAAI,KAAK;AACT,MAAI,KAAK;AAET,MAAIA,OAAM,GAAG;AACX,SAAK,KAAK,CAAC,IAAIC;AAAA,EACjB,OAAO;AACL,UAAM,CAACA,KAAI,KAAK,KAAK,QAAQ,MAAM,IAAID;AACvC,UAAM,CAACC,KAAI,KAAK,KAAK,QAAQ,MAAM,IAAID;AAAA,EACzC;AAEA,MAAI,MAAM,KAAK,MAAM,GAAG;AACtB,SAAK,mBAAmB,IAAI,IAAI,IAAI,IAAI,EAAE;AAAA,EAC5C;AAEA,MAAI,MAAM,KAAK,MAAM,GAAG;AACtB,SAAK,mBAAmB,IAAI,IAAI,IAAI,IAAI,EAAE;AAAA,EAC5C;AAEA,SAAO,CAAC,IAAI,EAAE;AAChB;AAEO,IAAM,2BAA2B,CACtC,IACA,IACA,IACA,OACW;AACX,QAAM,OAAO,eAAe,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AACtD,QAAM,OAAO,eAAe,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAEtD,MAAI,OAAO,KAAK,IAAI,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAChC,MAAI,OAAO,KAAK,IAAI,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAEhC,MAAI,MAAM;AACR,UAAM,KAAK,KAAK,OAAO,CAAC,MAAM,MAAM,IAAI;AACxC,WAAO,KAAK,IAAI,MAAM,GAAG,EAAE;AAC3B,WAAO,KAAK,IAAI,MAAM,GAAG,EAAE;AAAA,EAC7B;AAEA,MAAI,OAAO,KAAK,IAAI,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAChC,MAAI,OAAO,KAAK,IAAI,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAChC,MAAI,MAAM;AACR,UAAM,KAAK,KAAK,OAAO,CAAC,MAAM,MAAM,IAAI;AACxC,WAAO,KAAK,IAAI,MAAM,GAAG,EAAE;AAC3B,WAAO,KAAK,IAAI,MAAM,GAAG,EAAE;AAAA,EAC7B;AACA,SAAO,CAAC,MAAM,MAAM,MAAM,IAAI;AAChC;AAEO,IAAM,8BAA8B,CACzC,KACA,gBACW;AACX,MAAI,WAAwBN,YAAU,GAAG,CAAC;AAE1C,QAAM,EAAE,MAAM,MAAM,MAAM,KAAK,IAAI,IAAI;AAAA,IACrC,CAAC,QAAQ,EAAE,IAAI,KAAK,MAAM;AAGxB,UAAI,OAAO,QAAQ;AAEjB,cAAM,IAA6BQ,gBAAe,IAAI;AACtD,QAAAC,WAAU,KAAK,MAAM,wBAAwB;AAC7C,mBAAW;AAAA,MAGb,WAAW,OAAO,YAAY;AAC5B,cAAM,MAAMT,YAAuB,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACnD,cAAM,MAAMA,YAAuB,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACnD,cAAM,MAAMA,YAAuB,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAEnD,cAAM,KAAK,cAAc,YAAY,GAAG,IAAI;AAC5C,cAAM,KAAK,cAAc,YAAY,GAAG,IAAI;AAC5C,cAAM,KAAK,cAAc,YAAY,GAAG,IAAI;AAE5C,cAAM,KAAK,cAAc,YAAY,QAAQ,IAAI;AACjD,mBAAW;AAEX,cAAM,CAACU,OAAMC,OAAMC,OAAMC,KAAI,IAAI;AAAA,UAC/B;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAEA,eAAO,OAAO,KAAK,IAAI,OAAO,MAAMH,KAAI;AACxC,eAAO,OAAO,KAAK,IAAI,OAAO,MAAMC,KAAI;AAExC,eAAO,OAAO,KAAK,IAAI,OAAO,MAAMC,KAAI;AACxC,eAAO,OAAO,KAAK,IAAI,OAAO,MAAMC,KAAI;AAAA,MAC1C,WAAW,OAAO,UAAU;AAAA,MAE5B,WAAW,OAAO,YAAY;AAAA,MAE9B;AACA,aAAO;AAAA,IACT;AAAA,IACA,EAAE,MAAM,UAAU,MAAM,UAAU,MAAM,WAAW,MAAM,UAAU;AAAA,EACrE;AACA,SAAO,CAAC,MAAM,MAAM,MAAM,IAAI;AAChC;AAEO,IAAM,sBAAsB,CACjC,WACW;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AAEX,aAAW,CAAC,GAAG,CAAC,KAAK,QAAQ;AAC3B,WAAO,KAAK,IAAI,MAAM,CAAC;AACvB,WAAO,KAAK,IAAI,MAAM,CAAC;AACvB,WAAO,KAAK,IAAI,MAAM,CAAC;AACvB,WAAO,KAAK,IAAI,MAAM,CAAC;AAAA,EACzB;AAEA,SAAO,CAAC,MAAM,MAAM,MAAM,IAAI;AAChC;AAEA,IAAM,mCAAmC,CACvC,YACqD;AACrD,QAAM,CAAC,MAAM,MAAM,MAAM,IAAI,IAAI,oBAAoB,QAAQ,MAAM;AACnE,QAAM,KAAK,OAAO,QAAQ;AAC1B,QAAM,KAAK,OAAO,QAAQ;AAC1B,QAAM,KAAK,OAAO,QAAQ;AAC1B,QAAM,KAAK,OAAO,QAAQ;AAC1B,SAAO,CAAC,IAAI,IAAI,IAAI,KAAK,KAAK,MAAM,IAAI,KAAK,MAAM,CAAC;AACtD;AAGO,IAAM,mBAAmB,CAAC,cAAiC;AAChE,UAAQ,WAAW;AAAA,IACjB,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AAGO,IAAM,oBAAoB,CAAC,cAAkC;AAClE,UAAQ,WAAW;AAAA,IACjB,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AAEO,IAAM,qBAAqB,CAChC,SACA,OACA,UACA,cACG;AACH,MAAI,MAAM,SAAS,GAAG;AACpB,WAAO;AAAA,EACT;AAEA,QAAM,MAAM,gBAAgB,MAAM,CAAC,CAAC;AACpC,MAAI,IAAI,SAAS,GAAG;AAClB,WAAO;AAAA,EACT;AAGA,QAAM,QAAQ,aAAa,UAAU,IAAI,IAAI,SAAS;AAEtD,QAAM,OAAO,IAAI,KAAK,EAAE;AAExB,EAAAJ,WAAU,KAAK,WAAW,GAAG,yBAAyB;AAEtD,QAAM,KAAKT,YAAU,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACrC,QAAM,KAAKA,YAAU,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACrC,QAAM,KAAKA,YAAU,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAKrC,QAAM,SAAS,IAAI,QAAQ,CAAC;AAC5B,MAAI,KAAKA,YAAU,GAAG,CAAC;AACvB,MAAI,OAAO,OAAO,QAAQ;AACxB,UAAM,IAAIQ,gBAAe,OAAO,IAAI;AACpC,IAAAC,WAAU,KAAK,MAAM,wBAAwB;AAC7C,SAAK;AAAA,EACP,WAAW,OAAO,OAAO,YAAY;AACnC,SAAKT,YAAU,OAAO,KAAK,CAAC,GAAG,OAAO,KAAK,CAAC,CAAC;AAAA,EAC/C;AAGA,QAAM,WAAW,CAAC,GAAW,QAC3B,KAAK,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,GAAG,IAC3B,IAAI,IAAI,KAAK,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,GAAG,IACnC,IAAI,KAAK,IAAI,GAAG,CAAC,KAAK,IAAI,KAAK,GAAG,GAAG,IACrC,GAAG,GAAG,IAAI,KAAK,IAAI,GAAG,CAAC;AAGzB,QAAM,CAAC,IAAI,EAAE,IAAI,aAAa,UAAU,KAAK;AAM7C,QAAM,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,KAAK,CAAC,GAAG,SAAS,KAAK,CAAC,CAAC;AAIpD,QAAMc,YAAW,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAC5C,QAAM,MAAM,KAAK,MAAMA;AACvB,QAAM,MAAM,KAAK,MAAMA;AAEvB,QAAM,OAAO,iBAAiB,SAAS;AAEvC,MAAI,SAAS;AAEb;AAEE,UAAM,CAAC,IAAI,EAAE,IACX,aAAa,QACT,QAAQ,OAAO,QAAQ,OAAO,SAAS,CAAC,IACxC,QAAQ,OAAO,CAAC;AACtB,UAAM,CAAC,IAAI,EAAE,IACX,QAAQ,OAAO,SAAS,IACpB,aAAa,QACX,QAAQ,OAAO,QAAQ,OAAO,SAAS,CAAC,IACxC,QAAQ,OAAO,CAAC,IAClB,CAAC,GAAG,CAAC;AAEX,aAAS,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAAA,EACtC;AAIA,QAAM,mBACJ,cAAc,aAAa,cAAc,oBAAoB,OAAO;AACtE,QAAM,UAAU,KAAK,IAAI,MAAM,SAAS,gBAAgB;AACxD,QAAM,KAAK,KAAK,KAAK;AACrB,QAAM,KAAK,KAAK,KAAK;AAErB,MACE,cAAc,SACd,cAAc,YACd,cAAc,kBACd;AACA,UAAM,WAAW,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE,IAAI,QAAQ,cAAc;AACtE,WAAO,CAAC,IAAI,IAAI,QAAQ;AAAA,EAC1B;AAEA,QAAM,QAAQ,kBAAkB,SAAS;AAEzC,MAAI,cAAc,mBAAmB,cAAc,wBAAwB;AAEzE,UAAM,CAACC,KAAIC,GAAE,IAAIjB;AAAA,MACfC,YAAU,IAAI,EAAE;AAAA,MAChBA,YAAU,IAAI,EAAE;AAAA,MAChB,iBAAiB,CAAC,KAAgB;AAAA,IACpC;AACA,UAAM,CAACiB,KAAIC,GAAE,IAAInB;AAAA,MACfC,YAAU,IAAI,EAAE;AAAA,MAChBA,YAAU,IAAI,EAAE;AAAA,MAChB,iBAAiB,KAAK;AAAA,IACxB;AACA,WAAO,CAAC,IAAI,IAAIe,KAAIC,KAAIC,KAAIC,GAAE;AAAA,EAChC;AAGA,QAAM,CAAC,IAAI,EAAE,IAAInB;AAAA,IACfC,YAAU,IAAI,EAAE;AAAA,IAChBA,YAAU,IAAI,EAAE;AAAA,IACd,CAAC,QAAQ,KAAK,KAAM;AAAA,EACxB;AACA,QAAM,CAAC,IAAI,EAAE,IAAID;AAAA,IACfC,YAAU,IAAI,EAAE;AAAA,IAChBA,YAAU,IAAI,EAAE;AAAA,IAChB,iBAAiB,KAAK;AAAA,EACxB;AAEA,MAAI,cAAc,aAAa,cAAc,mBAAmB;AAE9D,QAAI;AACJ,QAAI;AAEJ,QAAI,aAAa,SAAS;AACxB,YAAM,CAAC,IAAI,EAAE,IAAI,QAAQ,OAAO,SAAS,IAAI,QAAQ,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC;AAEtE,OAAC,IAAI,EAAE,IAAID;AAAA,QACTC,YAAU,KAAK,UAAU,GAAG,EAAE;AAAA,QAC9BA,YAAU,IAAI,EAAE;AAAA,QAChB,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAAA,MAC7B;AAAA,IACF,OAAO;AACL,YAAM,CAAC,IAAI,EAAE,IACX,QAAQ,OAAO,SAAS,IACpB,QAAQ,OAAO,QAAQ,OAAO,SAAS,CAAC,IACxC,CAAC,GAAG,CAAC;AAEX,OAAC,IAAI,EAAE,IAAID;AAAA,QACTC,YAAU,KAAK,UAAU,GAAG,EAAE;AAAA,QAC9BA,YAAU,IAAI,EAAE;AAAA,QAChB,KAAK,MAAM,KAAK,IAAI,KAAK,EAAE;AAAA,MAC7B;AAAA,IACF;AAEA,WAAO,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;AAAA,EACxC;AAEA,SAAO,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;AAChC;AAEA,IAAM,6BAA6B,CACjC,YACa;AACb,QAAM,YAAY,cAAM,UAAU;AAClC,QAAM,UAAU,qBAAqB,OAAO;AAE5C,QAAM,UAAU,MAAM;AACpB,QAAI,QAAQ,WAAW;AACrB,aAAO;AAAA,IACT;AACA,QAAI,QAAQ,MAAM;AAChB,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,GAAG;AAEH,SAAO,UAAU,MAAM;AAAA,IACrB,QAAQ;AAAA,IACR;AAAA,EACF;AACF;AAEA,IAAM,gCAAgC,CACpC,SACA,IACA,IACA,gBACW;AACX,QAAM,mBAAmB,oBAAoB,SAAS,WAAW;AAEjE,MAAI,QAAQ,OAAO,SAAS,GAAG;AAC7B,UAAM,CAAC,QAAQ,MAAM,IAAI,QAAQ,OAAO,CAAC;AACzC,UAAM,CAAC,GAAG,CAAC,IAAID;AAAA,MACbC,YAAU,QAAQ,IAAI,QAAQ,QAAQ,IAAI,MAAM;AAAA,MAChDA,YAAU,IAAI,EAAE;AAAA,MAChB,QAAQ;AAAA,IACV;AAEA,QAAImB,UAAiB,CAAC,GAAG,GAAG,GAAG,CAAC;AAChC,QAAI,kBAAkB;AACpB,YAAM,sBAAsB,oBAAoB;AAAA,QAC9C;AAAA,QACA;AAAA,QACA,CAAC,GAAG,GAAG,GAAG,CAAC;AAAA,QACX;AAAA,MACF;AACA,MAAAA,UAAS;AAAA,QACP,oBAAoB,CAAC;AAAA,QACrB,oBAAoB,CAAC;AAAA,QACrB,oBAAoB,CAAC;AAAA,QACrB,oBAAoB,CAAC;AAAA,MACvB;AAAA,IACF;AACA,WAAOA;AAAA,EACT;AAGA,QAAM,cAAc,WAAW,IAAI,OAAO,IAAI,CAAC;AAC/C,QAAM,QAAQ,eAAe,2BAA2B,OAAO;AAC/D,QAAM,MAAM,gBAAgB,KAAK;AACjC,QAAM,cAAc,CAAC,CAAC,GAAG,CAAC,MACxBpB;AAAA,IACEC,YAAU,QAAQ,IAAI,GAAG,QAAQ,IAAI,CAAC;AAAA,IACtCA,YAAU,IAAI,EAAE;AAAA,IAChB,QAAQ;AAAA,EACV;AACF,QAAM,MAAM,4BAA4B,KAAK,WAAW;AACxD,MAAI,SAAiB,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;AACpD,MAAI,kBAAkB;AACpB,UAAM,sBAAsB,oBAAoB;AAAA,MAC9C;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,aAAS;AAAA,MACP,oBAAoB,CAAC;AAAA,MACrB,oBAAoB,CAAC;AAAA,MACrB,oBAAoB,CAAC;AAAA,MACrB,oBAAoB,CAAC;AAAA,IACvB;AAAA,EACF;AACA,SAAO;AACT;AAEO,IAAM,mBAAmB,CAC9B,SACA,aACA,aAAsB,UACX;AACX,SAAO,cAAc,UAAU,SAAS,aAAa,UAAU;AACjE;AAEO,IAAM,kBAAkB,CAC7B,UACA,gBACW;AACX,MAAI,CAAC,OAAO,QAAQ,GAAG;AACrB,WAAO,CAAC,GAAG,GAAG,GAAG,CAAC;AAAA,EACpB;AAEA,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AACX,MAAI,OAAO;AAEX,QAAM,eAAe,eAAeoB,YAAW,QAAQ;AAEvD,WAAS,QAAQ,CAAC,YAAY;AAC5B,UAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAI,iBAAiB,SAAS,YAAY;AAC/D,WAAO,KAAK,IAAI,MAAM,EAAE;AACxB,WAAO,KAAK,IAAI,MAAM,EAAE;AACxB,WAAO,KAAK,IAAI,MAAM,EAAE;AACxB,WAAO,KAAK,IAAI,MAAM,EAAE;AAAA,EAC1B,CAAC;AAED,SAAO,CAAC,MAAM,MAAM,MAAM,IAAI;AAChC;AAEO,IAAM,2BAA2B,CACtC,UACA,eACG;AACH,QAAM,CAAC,MAAM,MAAM,MAAM,IAAI,IAAI,gBAAgB,QAAQ;AACzD,SAAO;AAAA,IACL,OAAO,WAAW;AAAA,IAClB,OAAO,WAAW;AAAA,IAClB,OAAO,WAAW;AAAA,IAClB,OAAO,WAAW;AAAA,EACpB;AACF;AAEO,IAAM,kCAAkC,CAC7C,SACA,WACA,YACA,oBACW;AACX,MAAI,EAAE,gBAAgB,OAAO,KAAK,kBAAkB,OAAO,IAAI;AAC7D,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ,IAAI;AAAA,MACZ,QAAQ,IAAI;AAAA,IACd;AAAA,EACF;AAEA,QAAM,SAAS;AAAA,IACb;AAAA,IACA;AAAA,IACA,cAAc,GAAG,YAAY,QAAQ,QAAQ,eAAe;AAAA,IAC5D;AAAA,EACF;AAEA,MAAI;AAEJ,MAAI,kBAAkB,OAAO,GAAG;AAE9B,aAAS,oBAAoB,MAAM;AAAA,EACrC,OAAO;AAEL,UAAM,MAAM,cAAM,UAAU;AAC5B,UAAMnB,SAAQ,CAAC,QAAQ,YACnB,IAAI;AAAA,MACF;AAAA,MACA,qBAAqB,OAAO;AAAA,IAC9B,IACA,IAAI,MAAM,QAA8B,qBAAqB,OAAO,CAAC;AAEzE,UAAM,MAAM,gBAAgBA,MAAK;AACjC,aAAS,4BAA4B,GAAG;AAAA,EAC1C;AAEA,QAAM,CAAC,MAAM,MAAM,MAAM,IAAI,IAAI;AACjC,SAAO;AAAA,IACL,OAAO,QAAQ;AAAA,IACf,OAAO,QAAQ;AAAA,IACf,OAAO,QAAQ;AAAA,IACf,OAAO,QAAQ;AAAA,EACjB;AACF;AAEO,IAAM,yBAAyB,CACpC,SACA,WACW;AAEX,QAAM,MAAM,cAAM,UAAU;AAC5B,QAAMA,SACJ,QAAQ,aAAa,OACjB,IAAI;AAAA,IACF;AAAA,IACA,qBAAqB,OAAO;AAAA,EAC9B,IACA,IAAI,MAAM,QAA8B,qBAAqB,OAAO,CAAC;AAC3E,QAAM,MAAM,gBAAgBA,MAAK;AACjC,QAAM,CAAC,MAAM,MAAM,MAAM,IAAI,IAAI,4BAA4B,GAAG;AAChE,SAAO;AAAA,IACL,OAAO,QAAQ;AAAA,IACf,OAAO,QAAQ;AAAA,IACf,OAAO,QAAQ;AAAA,IACf,OAAO,QAAQ;AAAA,EACjB;AACF;AAEO,IAAM,0BAA0B,CACrC,UACA,SACW;AACX,MAAI,CAAC,SAAS,QAAQ;AACpB,WAAO,CAAC,GAAG,GAAG,GAAG,CAAC;AAAA,EACpB;AAEA,MAAI,cAAc;AAClB,MAAI,iBAAiB,SAAS,CAAC;AAC/B,QAAM,cAAcmB,YAAW,QAAQ;AACvC,WAAS,QAAQ,CAAC,YAAY;AAC5B,UAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAI,iBAAiB,SAAS,WAAW;AAC9D,UAAMN,YAAWO;AAAA,MACfrB,aAAW,KAAK,MAAM,IAAI,KAAK,MAAM,CAAC;AAAA,MACtCA,YAAU,KAAK,GAAG,KAAK,CAAC;AAAA,IAC1B;AAEA,QAAIc,YAAW,aAAa;AAC1B,oBAAcA;AACd,uBAAiB;AAAA,IACnB;AAAA,EACF,CAAC;AAED,SAAO,iBAAiB,gBAAgB,WAAW;AACrD;AAaO,IAAM,uBAAuB,CAClC,aACgB;AAChB,QAAM,CAAC,MAAM,MAAM,MAAM,IAAI,IAAI,gBAAgB,QAAQ;AACzD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,OAAO;AAAA,IACd,QAAQ,OAAO;AAAA,IACf,OAAO,OAAO,QAAQ;AAAA,IACtB,OAAO,OAAO,QAAQ;AAAA,EACxB;AACF;AAKO,IAAM,wBAAwB,CAAC;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAA6B;AAC3B,SAAO;AAAA,IACL,CAAC;AAAA,IACD,CAAC;AAAA,IACD,CAAC,UAAU,QAAQ,KAAK;AAAA,IACxB,CAAC,UAAU,SAAS,KAAK;AAAA,EAC3B;AACF;AAEO,IAAM,qBAAqB,CAAC,WACjCd;AAAA,EACE,OAAO,CAAC,KAAK,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK;AAAA,EACtC,OAAO,CAAC,KAAK,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK;AACxC;AAKK,IAAM,iBAAiB,CAC5B,SACA,aACA,WACG;AACH,QAAM,OAAO;AAAA,IACX,MAAM,QAAQ;AAAA,IACd,MAAM,QAAQ;AAAA,IACd,MAAM,QAAQ,IAAI,QAAQ;AAAA,IAC1B,MAAM,QAAQ,IAAI,QAAQ;AAAA,IAC1B,MAAM,QAAQ,IAAI,QAAQ,QAAQ;AAAA,IAClC,MAAM,QAAQ,IAAI,QAAQ,SAAS;AAAA,EACrC;AAEA,QAAM,SAAS,mBAAmB,SAAS,WAAW;AACtD,QAAM,CAAC,UAAU,QAAQ,IAAID;AAAA,IAC3BC,YAAU,KAAK,MAAM,KAAK,IAAI;AAAA,IAC9B;AAAA,IACA,QAAQ;AAAA,EACV;AACA,QAAM,CAAC,WAAW,SAAS,IAAID;AAAA,IAC7BC,YAAU,KAAK,MAAM,KAAK,IAAI;AAAA,IAC9B;AAAA,IACA,QAAQ;AAAA,EACV;AACA,QAAM,CAAC,cAAc,YAAY,IAAID;AAAA,IACnCC,YAAU,KAAK,MAAM,KAAK,IAAI;AAAA,IAC9B;AAAA,IACA,QAAQ;AAAA,EACV;AACA,QAAM,CAAC,aAAa,WAAW,IAAID;AAAA,IACjCC,YAAU,KAAK,MAAM,KAAK,IAAI;AAAA,IAC9B;AAAA,IACA,QAAQ;AAAA,EACV;AAEA,QAAM,SAAS;AAAA,IACb,KAAK,IAAI,UAAU,WAAW,cAAc,WAAW;AAAA,IACvD,KAAK,IAAI,UAAU,WAAW,cAAc,WAAW;AAAA,IACvD,KAAK,IAAI,UAAU,WAAW,cAAc,WAAW;AAAA,IACvD,KAAK,IAAI,UAAU,WAAW,cAAc,WAAW;AAAA,EACzD;AAEA,MAAI,QAAQ;AACV,UAAM,CAAC,WAAW,aAAa,YAAY,UAAU,IAAI;AACzD,WAAO;AAAA,MACL,OAAO,CAAC,IAAI;AAAA,MACZ,OAAO,CAAC,IAAI;AAAA,MACZ,OAAO,CAAC,IAAI;AAAA,MACZ,OAAO,CAAC,IAAI;AAAA,IACd;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,oBAAoB,CAC/B,GACA,WAEA,EAAE,CAAC,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC,IAAI,OAAO,CAAC;AAEtE,IAAM,oBAAoB,CAC/B,SACA,YACY;AACZ,MAAI,WAAW,QAAQ,WAAW,MAAM;AACtC,WAAO;AAAA,EACT;AAEA,QAAM,CAAC,OAAO,OAAO,OAAO,KAAK,IAAI;AACrC,QAAM,CAAC,OAAO,OAAO,OAAO,KAAK,IAAI;AAErC,SAAO,QAAQ,SAAS,QAAQ,SAAS,QAAQ,SAAS,QAAQ;AACpE;AAEO,IAAM,qBAAqB,CAChC,SACA,aACA,UAAkB,GAClB,UAAkB,MACf;AACH,QAAM,CAAC,GAAG,CAAC,IAAI,mBAAmB,iBAAiB,SAAS,WAAW,CAAC;AAExE,SAAOA,YAAuB,IAAI,SAAS,IAAI,OAAO;AACxD;;;AD/sCO,IAAM,+BAA+B;AAKrC,IAAM,0BAA0B,CACrC,YACY;AACZ,MAAI,gBAAgB,OAAO,KAAK,kBAAkB,OAAO,GAAG;AAC1D,WACE,QAAQ,OAAO,SAAS,KACvB,QAAQ,OAAO,WAAW,KACzB,eAAe,OAAO,KACtBsB;AAAA,MACE,QAAQ,OAAO,CAAC;AAAA,MAChB,QAAQ,OAAO,QAAQ,OAAO,SAAS,CAAC;AAAA,MACxC;AAAA,IACF;AAAA,EAEN;AAEA,SAAO,QAAQ,UAAU,KAAK,QAAQ,WAAW;AACnD;AAEO,IAAM,sBAAsB,CACjC,SACA,OACA,QACA,qBAOA,gBACG;AACH,QAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAI,iBAAiB,SAAS,WAAW;AAC9D,QAAM,qBAAqBC;AAAA,IACzB;AAAA,MACE,SAAS,oBAAoB;AAAA,MAC7B,SAAS,oBAAoB;AAAA,IAC/B;AAAA,IACA;AAAA,EACF;AACA,QAAM,yBAAyBA;AAAA,IAC7B;AAAA,MACE,SAAS,oBAAoB,aAAa;AAAA,MAC1C,SAAS,oBAAoB,YAAY;AAAA,IAC3C;AAAA,IACA;AAAA,EACF;AAEA,SACE,mBAAmB,KAAK,MACxB,mBAAmB,KAAK,MACxB,uBAAuB,KAAK,MAC5B,uBAAuB,KAAK;AAEhC;AAEO,IAAM,gCAAgC,CAC3C,UACA,OACA,QACA,qBAOA,aACA,YACG;AACH,QAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAI,gBAAgB,UAAU,WAAW;AAC9D,QAAM,qBAAqBA;AAAA,IACzB;AAAA,MACE,SAAS,oBAAoB,cAAc,SAAS,QAAQ;AAAA,MAC5D,SAAS,oBAAoB,aAAa,SAAS,OAAO;AAAA,IAC5D;AAAA,IACA;AAAA,EACF;AACA,QAAM,yBAAyBA;AAAA,IAC7B;AAAA,MACE,SAAS,oBAAoB,aAAa,SAAS,SAAS,SAAS;AAAA,MACrE,SAAS,oBAAoB,YAAY,UAAU,SAAS,UAAU;AAAA,IACxE;AAAA,IACA;AAAA,EACF;AAEA,SACE,MAAM,mBAAmB,KACzB,MAAM,mBAAmB,KACzB,MAAM,uBAAuB,KAC7B,MAAM,uBAAuB;AAEjC;AAKO,IAAM,wBAAwB,CACnC,aACA,OACA,WACsC;AACtC,QAAM,WAAW,KAAK,IAAI,KAAK;AAC/B,QAAM,YAAY,KAAK,IAAI,MAAM;AAEjC,MACE,gBAAgB,UAChB,gBAAgB,WAChB,gBAAgB,YAChB;AACA,UAAM,cACJ,KAAK,MAAM,KAAK,KAAK,YAAY,QAAQ,IAAI,mBAAmB,IAChE;AACF,QAAI,gBAAgB,GAAG;AACrB,eAAS;AAAA,IACX,WAAW,gBAAgB,KAAK,KAAK,GAAG;AACtC,cAAQ;AAAA,IACV,OAAO;AACL,eAAS,WAAW,KAAK,IAAI,WAAW,IAAI,KAAK,KAAK,MAAM,KAAK;AAAA,IACnE;AAAA,EACF,WAAW,gBAAgB,aAAa;AACtC,aAAS,WAAW,KAAK,KAAK,MAAM;AAAA,EACtC;AACA,SAAO,EAAE,OAAO,OAAO;AACzB;AAEO,IAAM,iCAAiC,CAC5C,SACA,SACA,GACA,GACA,gBACG;AACH,MAAI,QAAQ,IAAI;AAChB,MAAI,SAAS,IAAI;AAEjB,QAAM,QAAQ,KAAK,MAAM,QAAQ,KAAK;AACtC,MAAI,cAAe,KAAK,MAAM,QAAQ,mBAAmB,IACvD;AAEF,MAAI,aAAa;AAIf,UAAM,QAAS,KAAK,MAAM,cAAc,mBAAmB,IACzD;AACF,QACE;AAAA,MACE;AAAA,MACA;AAAA,MACC,QAAQ;AAAA,IACX,GACA;AACA,UACE,kBAAkB,OAAO,WAAsB,IAC/C,sBAAsB,GACtB;AACA,sBAAc;AAAA,MAChB,WACE,iBAAiB,KAAK,IAAI,iBAAiB,WAAsB,GACjE;AACA,sBAAe,QAAQ;AAAA,MACzB,OAAO;AACL,sBAAc;AAAA,MAChB;AAAA,IACF;AAAA,EACF;AAEA,MAAI,gBAAgB,GAAG;AACrB,aAAS;AAAA,EACX,WAAW,gBAAgB,KAAK,KAAK,GAAG;AACtC,YAAQ;AAAA,EACV,OAAO;AAEL,UAAM,KAAK,KAAK,IAAI,WAAW;AAC/B,UAAM,KAAK;AACX,UAAM,KAAK,UAAU,KAAK;AAG1B,UAAM,KAAK,KAAK;AAChB,UAAM,KAAK;AACX,UAAM,KAAK,IAAI,KAAK;AAGpB,UAAM,cAAc,KAAK,KAAK,KAAK,OAAO,KAAK,KAAK,KAAK;AACzD,UAAM,cAAc,KAAK,KAAK,KAAK,OAAO,KAAK,KAAK,KAAK;AAGzD,YAAQ,aAAa;AACrB,aAAS,aAAa;AAAA,EACxB;AAEA,SAAO,EAAE,OAAO,OAAO;AACzB;AAEO,IAAM,0BAA0B,CACrC,YAMG;AACH,QAAM,MAAM;AAAA,IACV,OAAO,QAAQ;AAAA,IACf,QAAQ,QAAQ;AAAA,IAChB,GAAG,QAAQ;AAAA,IACX,GAAG,QAAQ;AAAA,EACb;AAEA,MAAI,QAAQ,QAAQ,GAAG;AACrB,UAAM,YAAY,KAAK,IAAI,QAAQ,KAAK;AACxC,QAAI,QAAQ;AACZ,QAAI,IAAI,QAAQ,IAAI;AAAA,EACtB;AAEA,MAAI,QAAQ,SAAS,GAAG;AACtB,UAAM,aAAa,KAAK,IAAI,QAAQ,MAAM;AAC1C,QAAI,SAAS;AACb,QAAI,IAAI,QAAQ,IAAI;AAAA,EACtB;AAEA,SAAO;AACT;;;AkD5PA;AAcO,IAAM,gBAAgB,CAC3B,kBACA,WACA,UACwB;AACxB,QAAM,cAAc,MAAM,yBAAyB;AACnD,QAAM,SAAgC;AAAA,IACpC;AAAA,IACA;AAAA,EACF;AACA,QAAM,uBAAuB,qBAAqB,gBAAgB;AAElE,SAAO,OAAO,QAAQ,CAAC,UAAU;AAC/B,UAAM,cAAc;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,MAAM,IAAI,CAAC,YAAY;AAE5B,YAAM,aAAa,MAAM,cAAc,SAAS;AAAA,QAC9C,GAAG,QAAQ,IAAI,YAAY;AAAA,QAC3B,GAAG,QAAQ,IAAI,YAAY;AAAA,MAC7B,CAAC;AAGD,0BAAoB,SAAS,OAAO;AAAA,QAClC,uBAAuB;AAAA,MACzB,CAAC;AACD,aAAO;AAAA,IACT,CAAC;AAAA,EACH,CAAC;AACH;AAEA,IAAM,uBAAuB,CAC3B,OACA,sBACA,EAAE,MAAM,SAAS,MACY;AAC7B,QAAM,mBAAmB,qBAAqB,KAAK;AAEnD,QAAM,CAAC,KAAK,GAAG,IACb,SAAS,MAAM,CAAC,QAAQ,MAAM,IAAI,CAAC,QAAQ,MAAM;AAEnD,QAAM,gBAAgB,EAAE,GAAG,GAAG,GAAG,EAAE;AACnC,MAAI,aAAa,SAAS;AACxB,WAAO;AAAA,MACL,GAAG;AAAA,MACH,CAAC,IAAI,GAAG,qBAAqB,GAAG,IAAI,iBAAiB,GAAG;AAAA,IAC1D;AAAA,EACF,WAAW,aAAa,OAAO;AAC7B,WAAO;AAAA,MACL,GAAG;AAAA,MACH,CAAC,IAAI,GAAG,qBAAqB,GAAG,IAAI,iBAAiB,GAAG;AAAA,IAC1D;AAAA,EACF;AACA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,CAAC,IAAI,IACF,qBAAqB,GAAG,IAAI,qBAAqB,GAAG,KAAK,KACzD,iBAAiB,GAAG,IAAI,iBAAiB,GAAG,KAAK;AAAA,EACtD;AACF;;;AC5EA;AAAA;AAAA,EACE,cAAAC;AAAA,EACA;AAAA,EACA,eAAAC;AAAA,EACA,YAAAC;AAAA,EACA,kBAAAC;AAAA,EACA,aAAAC;AAAA,EACA,iBAAAC;AAAA,OACK;;;ACRP;AAAA;AAAA,EACE,eAAAC;AAAA,EACA,iBAAAC;AAAA,EACA,YAAAC;AAAA,EACA,aAAAC;AAAA,EACA,YAAAC;AAAA,EACA;AAAA,EACA;AAAA,OACK;;;ACRP;AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA,iBAAAC;AAAA,EACA,cAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA,uBAAAC;AAAA,EACA,aAAAC;AAAA,OACK;;;ACTP;AAAA,SAAS,2BAA2B;AAIpC,IAAM,6BAA6B,CAAC,aAA2C;AAC7E,QAAM,eAAoC,SAAS,MAAM;AACzD,QAAM,iBAAiB,oBAAI,IAAuB;AAElD,QAAM,mBAAmB,CACvBC,cACwB;AACxB,UAAM,gBAAgBA,UAAS,CAAC,GAAG,UAAU,KAAK,EAAE;AACpD,UAAM,SAA8B,CAACA,UAAS,CAAC,CAAC;AAChD,UAAM,SAA8B,CAAC;AACrC,eAAW,WAAWA,UAAS,MAAM,CAAC,GAAG;AACvC,UAAI,QAAQ,UAAU,KAAK,EAAE,MAAM,eAAe;AAChD,eAAO,KAAK,OAAO;AAAA,MACrB,OAAO;AACL,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA,IACF;AACA,WAAO,OAAO,SAAS,CAAC,GAAG,QAAQ,GAAG,iBAAiB,MAAM,CAAC,IAAI;AAAA,EACpE;AAEA,QAAM,uBAAuB,oBAAI,IAAkB;AAEnD,eAAa,QAAQ,CAAC,SAAS,QAAQ;AACrC,QAAI,qBAAqB,IAAI,QAAQ,EAAE,GAAG;AACxC;AAAA,IACF;AACA,QAAI,QAAQ,UAAU,QAAQ;AAC5B,YAAM,WAAW,QAAQ,SAAS,QAAQ,SAAS,SAAS,CAAC;AAC7D,YAAM,gBAAgB,aAAa,MAAM,GAAG,EAAE,OAAO,CAACC,aAAY;AAChE,cAAM,MAAMA,UAAS,UAAU,KAAK,CAAC,OAAO,OAAO,QAAQ;AAC3D,YAAI,KAAK;AACP,+BAAqB,IAAIA,SAAS,IAAI,IAAI;AAAA,QAC5C;AACA,eAAO;AAAA,MACT,CAAC;AAED,iBAAW,QAAQ,iBAAiB,aAAa,GAAG;AAClD,uBAAe,IAAI,IAAI;AAAA,MACzB;AAAA,IACF,OAAO;AACL,qBAAe,IAAI,OAAO;AAAA,IAC5B;AAAA,EACF,CAAC;AAID,MAAI,eAAe,SAAS,SAAS,QAAQ;AAC3C,YAAQ,MAAM,4DAA4D;AAC1E,WAAO;AAAA,EACT;AAEA,SAAO,CAAC,GAAG,cAAc;AAC3B;AAWA,IAAM,8BAA8B,CAClC,aACG;AACH,QAAM,cAAc,oBAAoB,QAAQ;AAEhD,QAAM,eAA6C,SAAS,MAAM;AAClE,QAAM,iBAAiB,oBAAI,IAAuB;AAElD,eAAa,QAAQ,CAAC,SAAS,QAAQ;AACrC,QAAI,CAAC,SAAS;AACZ;AAAA,IACF;AACA,QAAI,QAAQ,eAAe,QAAQ;AACjC,qBAAe,IAAI,OAAO;AAC1B,mBAAa,GAAG,IAAI;AACpB,cAAQ,cAAc,QAAQ,CAAC,iBAAiB;AAC9C,cAAM,QAAQ,YAAY,IAAI,aAAa,EAAE;AAC7C,YAAI,SAAS,aAAa,SAAS,QAAQ;AACzC,yBAAe,IAAI,MAAM,CAAC,CAAC;AAC3B,uBAAa,MAAM,CAAC,CAAC,IAAI;AAAA,QAC3B;AAAA,MACF,CAAC;AAAA,IACH,WAAW,QAAQ,SAAS,UAAU,QAAQ,aAAa;AACzD,YAAM,SAAS,YAAY,IAAI,QAAQ,WAAW;AAClD,UAAI,CAAC,SAAS,CAAC,EAAE,eAAe,KAAK,CAAC,MAAM,EAAE,OAAO,QAAQ,EAAE,GAAG;AAChE,uBAAe,IAAI,OAAO;AAC1B,qBAAa,GAAG,IAAI;AAAA,MAItB;AAAA,IACF,OAAO;AACL,qBAAe,IAAI,OAAO;AAC1B,mBAAa,GAAG,IAAI;AAAA,IACtB;AAAA,EACF,CAAC;AAID,MAAI,eAAe,SAAS,SAAS,QAAQ;AAC3C,YAAQ;AAAA,MACN;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,SAAO,CAAC,GAAG,cAAc;AAC3B;AAEO,IAAM,wBAAwB,CACnC,aACG;AACH,SAAO,4BAA4B,2BAA2B,QAAQ,CAAC;AACzE;;;AD5DO,IAAM,mBAAmB,CAC9B,gBACA,wBACA,SACA,kBACuB;AACvB,QAAM,OAAO,gBAAgB,OAAO;AAEpC,MAAIC,WAAU,GAAG;AACf,yBAAqB,MAAM,QAAQ,EAAE;AAAA,EACvC;AAEA,OAAK,KAAK,SAAS;AACnB,OAAK,UAAUC,qBAAoB;AACnC,MAAI,eAAe;AACjB,SAAK,OAAOC,eAAc;AAC1B,gBAAY,IAAI;AAAA,EAClB;AAEA,OAAK,WAAW;AAAA,IACd,KAAK;AAAA,IACL;AAAA,IACA,CAAC,YAAY;AACX,UAAI,CAAC,uBAAuB,IAAI,OAAO,GAAG;AACxC,+BAAuB,IAAI,SAAS,SAAS,CAAC;AAAA,MAChD;AACA,aAAO,uBAAuB,IAAI,OAAO;AAAA,IAC3C;AAAA,EACF;AACA,SAAO;AACT;AAEO,IAAM,oBAAoB,CAC/B,SAwCG;AACH,MAAI,EAAE,SAAS,IAAI;AAEnB,QAAM,WACJ,cAAc,OACV,KAAK,WACJ;AAAA,IACC,gBAAgB;AAAA,IAChB,kBAAkB,CAAC;AAAA,EACrB;AAYN,QAAM,eAAe,oBAAI,IAAmC;AAC5D,QAAM,aAAa,oBAAI,IAAI;AAC3B,QAAM,qBAA0C,CAAC;AACjD,QAAM,eAAoC,CAAC;AAC3C,QAAM,sBAAsB,oBAAI,IAG9B;AACF,QAAM,2BAA2B,oBAAI,IAGnC;AACF,QAAM,uBAAuB,oBAAI,IAA+B;AAChE,QAAM,cAAcC,YAAW,QAAQ;AACvC,QAAM,4BACJ,KAAK,SAAS,aACV,KAAK,2BACL,IAAI,IAAI,SAAS,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC;AAG/C,MAAI,KAAK,SAAS,YAAY;AAC5B,eAAW,WAAW,OAAO,KAAK,KAAK,SAAS,gBAAgB,GAAG;AACjE,eACG,OAAO,CAAC,OAAO,GAAG,UAAU,SAAS,OAAO,CAAC,EAC7C,QAAQ,CAAC,OAAO,0BAA0B,IAAI,GAAG,IAAI,EAAE,CAAC;AAAA,IAC7D;AAAA,EACF;AAEA,aAAW,sBAAsB,QAAQ;AAEzC,QAAM,yBAA8C,SAAS,MAAM;AAOnE,QAAM,eAAe,CACnB,YAG8B;AAC9B,UAAMC,YAAW,UAAU,OAAO;AAElC,UAAM,eAAeA,UAAS;AAAA,MAC5B,CAAC,KAA0BC,aAAY;AACrC,YAAI,aAAa,IAAIA,SAAQ,EAAE,GAAG;AAChC,iBAAO;AAAA,QACT;AAEA,qBAAa,IAAIA,SAAQ,IAAI,IAAI;AAEjC,cAAMC,cAAa;AAAA,UACjB,SAAS;AAAA,UACT;AAAA,UACAD;AAAA,UACA,KAAK;AAAA,QACP;AAEA,qBAAa,IAAIC,YAAW,IAAI,IAAI;AAEpC,6BAAqB,IAAIA,YAAW,IAAIA,WAAU;AAClD,4BAAoB,IAAID,SAAQ,IAAIC,YAAW,EAAE;AACjD,iCAAyB,IAAIA,YAAW,IAAID,QAAO;AAEnD,qBAAa,KAAKA,QAAO;AACzB,2BAAmB,KAAKC,WAAU;AAElC,YAAI,KAAKA,WAAU;AACnB,eAAO;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IACH;AAEA,WACE,MAAM,QAAQ,OAAO,IAAI,eAAe,aAAa,CAAC,KAAK;AAAA,EAI/D;AAGA,QAAM,2BAA2B,CAC/B,OACAF,cACG;AACH,QAAI,CAACA,WAAU;AACb;AAAA,IACF;AAEA,QAAI,QAAQ,uBAAuB,SAAS,GAAG;AAC7C,6BAAuB,KAAK,GAAG,UAAUA,SAAQ,CAAC;AAClD;AAAA,IACF;AAEA,2BAAuB,OAAO,QAAQ,GAAG,GAAG,GAAG,UAAUA,SAAQ,CAAC;AAAA,EACpE;AAEA,QAAM,sBAAsB,IAAI;AAAA,IAC9B,SACG;AAAA,MACC,CAAC,OAAO,0BAA0B,IAAI,GAAG,EAAE,KAAK,mBAAmB,EAAE;AAAA,IACvE,EACC,IAAI,CAAC,OAAO,GAAG,EAAE;AAAA,EACtB;AAEA,aAAW,WAAW,UAAU;AAC9B,QAAI,aAAa,IAAI,QAAQ,EAAE,GAAG;AAChC;AAAA,IACF;AAEA,QAAI,CAAC,0BAA0B,IAAI,QAAQ,EAAE,GAAG;AAC9C;AAAA,IACF;AAKA,UAAM,UAAU,2BAA2B,UAAU,OAAO;AAC5D,QAAI,SAAS;AACX,YAAM,gBAAgB,mBAAmB,UAAU,OAAO,EAAE;AAAA,QAC1D,CAACC,aACC,mBAAmBA,QAAO,IACtB,CAAC,GAAG,iBAAiB,UAAUA,SAAQ,EAAE,GAAGA,QAAO,IACnD,CAACA,QAAO;AAAA,MAChB;AAEA,YAAM,cAAc,cAAc,wBAAwB,CAAC,OAAO;AAChE,eAAO,GAAG,UAAU,SAAS,OAAO;AAAA,MACtC,CAAC;AAED,+BAAyB,aAAa,aAAa,aAAa,CAAC;AACjE;AAAA,IACF;AAKA,QAAI,QAAQ,WAAW,oBAAoB,IAAI,QAAQ,OAAO,GAAG;AAC/D;AAAA,IACF;AAEA,QAAI,mBAAmB,OAAO,GAAG;AAC/B,YAAM,UAAU,QAAQ;AAExB,YAAM,gBAAgB,iBAAiB,UAAU,OAAO;AAExD,YAAM,cAAc,cAAc,wBAAwB,CAAC,OAAO;AAChE,eAAO,GAAG,YAAY,WAAW,GAAG,OAAO;AAAA,MAC7C,CAAC;AAED;AAAA,QACE;AAAA,QACA,aAAa,CAAC,GAAG,eAAe,OAAO,CAAC;AAAA,MAC1C;AACA;AAAA,IACF;AAKA,QAAI,oBAAoB,OAAO,GAAG;AAChC,YAAM,mBAAmB,oBAAoB,SAAS,WAAW;AAEjE,YAAM,cAAc,cAAc,wBAAwB,CAAC,OAAO;AAChE,eACE,GAAG,OAAO,QAAQ,MACjB,iBAAiB,MAAM,GAAG,gBAAgB,QAAQ;AAAA,MAEvD,CAAC;AAED,UAAI,kBAAkB;AACpB;AAAA,UACE;AAAA,UACA,aAAa,CAAC,SAAS,gBAAgB,CAAC;AAAA,QAC1C;AAAA,MACF,OAAO;AACL,iCAAyB,aAAa,aAAa,OAAO,CAAC;AAAA,MAC7D;AAEA;AAAA,IACF;AAEA,QAAI,mBAAmB,OAAO,GAAG;AAC/B,YAAM,YAAY,oBAAoB,SAAS,WAAW;AAE1D,YAAM,cAAc,cAAc,wBAAwB,CAAC,OAAO;AAChE,eAAO,GAAG,OAAO,QAAQ,MAAM,GAAG,OAAO,WAAW;AAAA,MACtD,CAAC;AAED,UAAI,WAAW;AACb;AAAA,UACE;AAAA,UACA,aAAa,CAAC,WAAW,OAAO,CAAC;AAAA,QACnC;AAAA,MACF,OAAO;AACL,iCAAyB,aAAa,aAAa,OAAO,CAAC;AAAA,MAC7D;AAEA;AAAA,IACF;AAKA;AAAA,MACE,cAAc,wBAAwB,CAAC,OAAO,GAAG,OAAO,QAAQ,EAAE;AAAA,MAClE,aAAa,OAAO;AAAA,IACtB;AAAA,EACF;AAIA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,KAAK,WAAW;AAClB,eAAWE,qBAAoB,oBAAoB;AACjD,YAAM,cAAc,yBAAyB,IAAIA,kBAAiB,EAAE;AACpE,UAAI,aAAa;AACf,eAAO;AAAA,UACLA;AAAA,UACA,KAAK,UAAU;AAAA,YACb,kBAAAA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAWA,IAAM,mBAAmB,CAAC,KAAU,QAAgB,MAAM;AAExD,MAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;AAC1C,WAAO;AAAA,EACT;AAEA,QAAM,aAAa,OAAO,UAAU,SAAS,KAAK,GAAG;AAErD,MAAI,eAAe,mBAAmB;AACpC,UAAM,MACJ,OAAO,IAAI,gBAAgB,aACvB,OAAO,OAAO,OAAO,eAAe,GAAG,CAAC,IACxC,CAAC;AACP,eAAW,OAAO,KAAK;AACrB,UAAI,IAAI,eAAe,GAAG,GAAG;AAG3B,YAAI,UAAU,MAAM,QAAQ,WAAW,QAAQ,WAAW;AACxD;AAAA,QACF;AACA,YAAI,GAAG,IAAI,iBAAiB,IAAI,GAAG,GAAG,QAAQ,CAAC;AAAA,MACjD;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,QAAI,IAAI,IAAI;AACZ,UAAM,MAAM,IAAI,MAAM,CAAC;AACvB,WAAO,KAAK;AACV,UAAI,CAAC,IAAI,iBAAiB,IAAI,CAAC,GAAG,QAAQ,CAAC;AAAA,IAC7C;AACA,WAAO;AAAA,EACT;AAKA,MAAI,+BAAgB,KAAK;AACvB,QACE,eAAe,qBACf,eAAe,oBACf,WAAW,WAAW,UAAU,GAChC;AACA,cAAQ;AAAA,QACN,6CAA6C,UAAU;AAAA,MACzD;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAWO,IAAM,kBAAkB,CAC7B,QACe;AACf,SAAO,iBAAiB,GAAG;AAC7B;AAEA,IAAM,uBAAuB,CAAC,WAAmB,WAAmB;AAClE,SAAO,eAAe,WAAW,SAAS;AAAA,IACxC,OAAO;AAAA,IACP,UAAU;AAAA,IACV,YAAY;AAAA,EACd,CAAC;AACH;;;ADncO,IAAM,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASjC,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASb,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYP,YAAY;AACd;AASO,IAAM,QAAN,MAAY;AAAA,EAoBjB,YAA6B,KAAU;AAAV;AAAA,EAAW;AAAA;AAAA,EAlBxB,4BAA4B,IAAI,QAA4B;AAAA,EAC5D,0BAA0B,IAAI,QAE5C;AAAA,EAEM,wBAAsD,oBAAI,IAAI;AAAA,EAC9D,wBAA2C,CAAC;AAAA,EAE5C,YAAY,cAAc,MAAM;AAAA,EAExC,IAAW,WAAW;AACpB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAW,SAAS,UAAyB;AAC3C,SAAK,YAAY;AAAA,EACnB;AAAA,EAIO,eAAe,QAAiC;AACrD,SAAK,sBAAsB,IAAI,MAAM;AACrC,SAAK,mCAAmC;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,kBAAkB;AACvB,SAAK,eAAe,oBAAoB,WAAW;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKO,oBACL,QAiBA;AACA,UAAM,EAAE,OAAO,IAAI;AAEnB,QAAI;AAEJ,QAAI,YAAY,QAAQ;AACtB,eAAS,OAAO;AAAA,IAClB,OAAO;AAKL,YAAM,kBAAkB,cAAc;AAAA,QACpC,KAAK,IAAI,MAAM,+BAA+B;AAAA,QAC9C,KAAK,IAAI;AAAA,MACX;AAEA,YAAM,oBAAoB,gBAAgB;AAAA,QACxC;AAAA;AAAA;AAAA;AAAA,QAIA,OAAO,WACH,4BAA4B,OAAO,QAAQ,IAC3C;AAAA,QACJ,OAAO;AAAA,MACT;AAEA,eAAS,YAAY,OAAO,iBAAiB,iBAAiB;AAAA,IAChE;AAEA,UAAM,QAAQ,WAAW,SAAS,OAAO,QAAQ;AAEjD,SAAK,sBAAsB;AAAA,MAAK,MAC9B,KAAK,cAAc;AAAA,QACjB;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,OACL,UACA,UACM;AAGN,SAAK,kBAAkB;AAEvB,QAAI;AAGF,YAAM,SAAS,KAAK,wBAAwB;AAC5C,WAAK,cAAc,EAAE,QAAQ,UAAU,SAAS,CAAC;AAAA,IACnD,UAAE;AACA,WAAK,mCAAmC;AAExC,WAAK,wBAAwB,oBAAI,IAAI;AAAA,IACvC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,QAAc;AACnB,SAAK,WAAW,cAAc,MAAM;AACpC,SAAK,wBAAwB,oBAAI,IAAI;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,qBACN,UACA,SAAkC,QAClC,QAAgC,QAChC;AACA,UAAM,eAAe,KAAK;AAE1B,QAAI;AACJ,QAAI;AAEJ,QAAI,QAAQ;AACV,oBAAc;AAAA,IAChB,OAAO;AACL,oBAAc,YAAY,OAAO,cAAc,QAAQ;AAAA,IACzD;AAEA,QAAI,OAAO;AAGT,mBAAa;AAAA,IACf,OAAO;AACL,mBAAa,WAAW,UAAU,cAAc,QAAQ;AAAA,IAC1D;AAEA,QAAI,CAAC,WAAW,QAAQ,GAAG;AACzB,YAAM,YAAY,IAAI,iBAAiB,aAAa,UAAU;AAG9D,WAAK,0BAA0B,QAAQ,SAAS;AAChD,WAAK,wBAAwB,QAAQ,SAAS;AAAA,IAChD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,uBACN,UACA,SAAkC,QAClC;AACA,QAAI;AAEJ,QAAI,QAAQ;AACV,oBAAc;AAAA,IAChB,OAAO;AACL,YAAM,eAAe,KAAK;AAC1B,oBAAc,YAAY,OAAO,cAAc,QAAQ;AAAA,IACzD;AAEA,UAAM,YAAY,IAAI,mBAAmB,WAAW;AAGpD,SAAK,wBAAwB,QAAQ,SAAS;AAAA,EAChD;AAAA,EAEQ,sBAAsB,QAAqB;AACjD,UAAM,eAAe,KAAK;AAC1B,UAAM,eAAe,KAAK,SAAS,YAAY,MAAM;AAErD,QAAI,iBAAiB,cAAc;AACjC,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,mBACN,QACA,UACA,UACA;AACA,QAAI,CAAC,YAAY,CAAC,UAAU;AAC1B,aAAO;AAAA,IACT;AAEA,UAAM,eAAe,KAAK;AAC1B,UAAM,eAAe,KAAK,SAAS,WAAW,QAAQ,UAAU,QAAQ;AAExE,QAAI,iBAAiB,cAAc;AACjC,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,oBAAoB;AAC1B,eAAW,eAAe,KAAK,uBAAuB;AACpD,UAAI;AACF,oBAAY;AAAA,MACd,SAAS,OAAO;AACd,gBAAQ,MAAM,4CAA4C,KAAK;AAAA,MACjE;AAAA,IACF;AAEA,SAAK,wBAAwB,CAAC;AAAA,EAChC;AAAA,EAEQ,cACN,QAWA;AACA,UAAM,EAAE,OAAO,IAAI;AAKnB,QACE,WAAW,oBAAoB,cAC/B,CAAC,KAAK,wBAAwB,YAAY,QAC1C;AACA;AAAA,IACF;AAEA,QAAI;AAEJ,QAAI,YAAY,QAAQ;AACtB,qBAAe,KAAK,sBAAsB,OAAO,MAAM;AAAA,IACzD,OAAO;AACL,qBAAe,KAAK;AAAA,QAClB;AAAA,QACA,OAAO;AAAA,QACP,OAAO;AAAA,MACT;AAAA,IACF;AAEA,QAAI,CAAC,cAAc;AAEjB;AAAA,IACF;AAEA,UAAM,SAAS,YAAY,SAAS,OAAO,SAAS;AACpD,UAAM,QAAQ,WAAW,SAAS,OAAO,QAAQ;AAEjD,QAAI;AACF,cAAQ,QAAQ;AAAA,QAEd,KAAK,oBAAoB;AACvB,eAAK,qBAAqB,cAAc,QAAQ,KAAK;AACrD;AAAA,QAEF,KAAK,oBAAoB;AAAA,QACzB,KAAK,oBAAoB;AACvB,eAAK,uBAAuB,cAAc,MAAM;AAChD;AAAA,QACF;AACE,UAAAC,aAAY,QAAQ,sBAAsB;AAAA,MAC9C;AAAA,IACF,UAAE;AAEA,cAAQ,QAAQ;AAAA,QAEd,KAAK,oBAAoB;AAAA,QACzB,KAAK,oBAAoB;AACvB,eAAK,WAAW;AAChB;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,0BAA0B;AAChC,QAAI;AAEJ,QAAI,KAAK,sBAAsB,IAAI,oBAAoB,WAAW,GAAG;AAEnE,wBAAkB,oBAAoB;AAAA,IACxC,WAAW,KAAK,sBAAsB,IAAI,oBAAoB,KAAK,GAAG;AAEpE,wBAAkB,oBAAoB;AAAA,IACxC,OAAO;AAEL,wBAAkB,oBAAoB;AAAA,IACxC;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,qCAAqC;AAC3C,QACE,EACE,KAAK,sBAAsB,QAAQ,KACnC,KAAK,sBAAsB,QACzB,OAAO,KAAK,mBAAmB,EAAE,SAErC;AACA,YAAM,UAAU,uFAAuF,KAAK,sBAAsB,IAAI;AACtI,cAAQ,MAAM,SAAS,KAAK,sBAAsB,OAAO,CAAC;AAE1D,UAAIC,WAAU,KAAKC,UAAS,GAAG;AAC7B,cAAM,IAAI,MAAM,OAAO;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AACF;AAKO,IAAM,cAAN,MAAM,aAAY;AAAA;AAAA;AAAA,EAGf,YACU,UACA,UAChB;AAFgB;AACA;AAAA,EACf;AAAA,EAEH,OAAc,OACZ,cACA,cACA;AACA,UAAM,kBAAkB,aAAa,mBAAmB,YAAY;AACpE,UAAM,kBAAkB,aAAa,mBAAmB,YAAY;AAEpE,WAAO,IAAI,aAAY,iBAAiB,eAAe;AAAA,EACzD;AACF;AAKO,IAAe,iBAAf,MAA8B;AAAA,EACzB,YACQ,MACA,QAChB;AAFgB;AACA;AAAA,EACf;AAAA,EAEH,OAAc,UACZ,WAC+B;AAC/B,WAAO,UAAU,SAAS;AAAA,EAC5B;AAAA,EAEA,OAAc,YACZ,WACiC;AACjC,WAAO,UAAU,SAAS;AAAA,EAC5B;AACF;AAKO,IAAM,mBAAN,cAA+B,eAAe;AAAA,EACnD,YACkB,QACA,OAChB;AACA,UAAM,WAAW,MAAM;AAHP;AACA;AAAA,EAGlB;AACF;AAKO,IAAM,qBAAN,cAAiC,eAAe;AAAA,EACrD,YAA4B,QAAqB;AAC/C,UAAM,aAAa,MAAM;AADC;AAAA,EAE5B;AACF;AAKO,IAAM,aAAN,MAAiB;AAAA,EACZ,YACQ,IACA,UACA,UAChB;AAHgB;AACA;AACA;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAKH,OAAc,OACZ,UACA,UACA,OAEI;AAAA,IACF,IAAIC,UAAS;AAAA,EACf,GACA;AACA,WAAO,IAAI,KAAK,KAAK,IAAI,UAAU,QAAQ;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,UACZ,cACA,cACA;AACA,UAAM,gBAAgB,aAAa,SAAS,oBACxC,cAAc,UAAU,aAAa,UAAU,aAAa,QAAQ,IACpE,cAAc,MAAM;AAExB,UAAM,gBAAgB,aAAa,SAAS,oBACxC,cAAc,UAAU,aAAa,UAAU,aAAa,QAAQ,IACpE,cAAc,MAAM;AAExB,WAAO,KAAK,OAAO,eAAe,aAAa;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,QAAQ,eAAgC;AACpD,UAAM,EAAE,IAAI,UAAU,SAAS,IAAI;AACnC,WAAO,IAAI;AAAA,MACT;AAAA,MACA,cAAc,QAAQ,QAAQ;AAAA,MAC9B,cAAc,QAAQ,QAAQ;AAAA,IAChC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,KAAK;AAAA,IACjB;AAAA,IACA,UAAU,EAAE,OAAO,SAAS,QAAQ;AAAA,EACtC,GAAoB;AAClB,UAAM,WAAW,cAAc,OAAO,OAAO,SAAS,OAAO;AAE7D,WAAO,IAAI,KAAK,IAAI,UAAU,cAAc,MAAM,CAAC;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,QAAQ,OAAmB;AACvC,WAAO,KAAK,OAAO,MAAM,SAAS,QAAQ,GAAG,MAAM,SAAS,QAAQ,CAAC;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,QACZ,OACA,UACA,UACuC;AACvC,UAAM,CAAC,cAAc,4BAA4B,IAC/C,MAAM,SAAS,QAAQ,QAAQ;AAEjC,UAAM,CAAC,cAAc,6BAA6B,IAChD,MAAM,SAAS,QAAQ,UAAU,YAAY;AAE/C,UAAM,wBACJ,gCAAgC;AAElC,WAAO,CAAC,cAAc,cAAc,qBAAqB;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,mBACZ,OACA,cACA,cACA,iBACY;AACZ,WAAO,KAAK;AAAA,MACV,MAAM,SAAS;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA,MAAM;AAAA,MACN;AAAA,QACE,IAAI,MAAM;AAAA,MACZ;AAAA,IACF;AAAA,EACF;AAAA,EAEO,UAAU;AACf,WAAO,KAAK,SAAS,QAAQ,KAAK,KAAK,SAAS,QAAQ;AAAA,EAC1D;AACF;AAMO,IAAM,gBAAN,MAAM,eAAc;AAAA,EAIjB,YACU,UACA,UACA,WAIZ;AAAA,IACF,mBAAmB;AAAA,IACnB,mBAAmB;AAAA,IACnB,SAAS;AAAA,EACX,GACA;AAXgB;AACA;AACA;AAAA,EASf;AAAA,EAfK,2BAAmC;AAAA,EACnC,2BAAmC;AAAA,EAgB3C,OAAc,OACZ,UACA,UACA,WAGI;AAAA,IACF,mBAAmB;AAAA,IACnB,mBAAmB;AAAA,EACrB,GACA;AACA,WAAO,IAAI;AAAA,MACT;AAAA,MACA,mBAAmB,QAAQ,IAAI,WAAW,oBAAoB,QAAQ;AAAA,MACtE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAc,QAAQ;AACpB,WAAO,IAAI;AAAA,MACT,oBAAI,IAAI;AAAA,MACR,2BAA2B;AAAA,MAC3B;AAAA,QACE,mBAAmB;AAAA,QACnB,mBAAmB;AAAA,QACnB,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AAAA,EAEO,mBAAmB,cAA6B;AACrD,UAAM,kBAA4D,CAAC;AAEnE,eAAW,eAAe,WAAW,aAAa,QAAQ,GAAG;AAC3D,YAAM,cAAc,KAAK,SAAS,IAAI,YAAY,EAAE;AAEpD,UAAI,CAAC,aAAa;AAChB,wBAAgB,YAAY,EAAE,IAAI,eAAe,aAAa;AAAA,UAC5D,WAAW;AAAA,QACb,CAAC;AAAA,MACH;AAAA,IACF;AAEA,eAAW,eAAe,WAAW,KAAK,QAAQ,GAAG;AAEnD,UAAI,aAAa,SAAS,IAAI,YAAY,EAAE,MAAM,aAAa;AAC7D,wBAAgB,YAAY,EAAE,IAAI;AAAA,MACpC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEO,mBACL,cAC2B;AAC3B,WAAO,MAAM;AAAA,MACX,aAAa;AAAA,MACb,KAAK;AAAA,IACP,EAAE;AAAA,MACA,CAAC,KAAK,QACJ,OAAO,OAAO,KAAK;AAAA,QACjB,CAAC,GAAG,GAAG,KAAK,SAAS,GAA6B;AAAA,MACpD,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEO,UAAU;AACf,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKO,YAAY,QAAoC;AACrD,UAAM,eAAe,IAAI,IAAI,KAAK,QAAQ;AAE1C,eAAW,CAAC,IAAI,cAAc,KAAK,OAAO,QAAQ,OAAO,QAAQ,GAAG;AAClE,mBAAa,IAAI,IAAI,cAAc;AAAA,IACrC;AAEA,UAAM,eAAe,oBAAoB;AAAA,MACvC,GAAG,KAAK;AAAA,MACR,GAAG,OAAO;AAAA,IACZ,CAAC;AAED,WAAO,eAAc,OAAO,cAAc,cAAc;AAAA;AAAA;AAAA,MAGtD,mBAAmB,OAAO,KAAK,OAAO,QAAQ,EAAE,SAAS;AAAA,MACzD,mBAAmB,OAAO,KAAK,OAAO,QAAQ,EAAE,SAAS;AAAA,IAC3D,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,WACL,QACA,UACA,UACA;AACA,UAAM,UAAU;AAAA,MACd,qBAAqB;AAAA,IACvB;AAEA,QAAI,WAAW,oBAAoB,YAAY;AAI7C,cAAQ,sBAAsB;AAAA,IAChC;AAEA,UAAM,uBAAuB,KAAK;AAAA,MAChC;AAAA,MACA;AAAA,IACF;AACA,UAAM,uBAAuB,KAAK;AAAA,MAChC;AAAA,MACA;AAAA,IACF;AAEA,QAAI,oBAAoB;AACxB,QAAI,oBAAoB;AAExB,QAAI,KAAK,aAAa,sBAAsB;AAC1C,0BAAoB;AAAA,IACtB;AAEA,QAAI,KAAK,aAAa,sBAAsB;AAC1C,0BAAoB;AAAA,IACtB;AAEA,QAAI,CAAC,qBAAqB,CAAC,mBAAmB;AAC5C,aAAO;AAAA,IACT;AAEA,UAAM,WAAW,IAAI;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,QACE;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,4BACN,UACA,UAEI;AAAA,IACF,qBAAqB;AAAA,EACvB,GACkB;AAClB,QAAI,CAAC,UAAU;AACb,aAAO,KAAK;AAAA,IACd;AAGA,UAAM,uBAAuB,CAAC,mBAAmB,QAAQ,IACrD,oBAAoB,QAAQ,IAC5B;AAEJ,UAAM,oBAAoB,KAAK;AAAA,MAC7B;AAAA,MACA;AAAA,IACF;AAEA,QAAI,CAAC,mBAAmB;AACtB,aAAO,KAAK;AAAA,IACd;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,4BACN,UACA,UAEI;AAAA,IACF,qBAAqB;AAAA,EACvB,GACkB;AAClB,QAAI,CAAC,UAAU;AACb,aAAO,KAAK;AAAA,IACd;AAEA,UAAM,kBAAkB,KAAK,sBAAsB,UAAU,OAAO;AAEpE,QAAI,CAAC,iBAAiB,MAAM;AAC1B,aAAO,KAAK;AAAA,IACd;AAEA,UAAM,mBAAmB,KAAK,uBAAuB,eAAe;AACpE,WAAO;AAAA,EACT;AAAA,EAEQ,sBACN,sBACA,UAEI;AAAA,IACF,qBAAqB;AAAA,EACvB,GACqB;AACrB,QAAI,KAAK,aAAa,sBAAsB;AAC1C;AAAA,IACF;AAEA,UAAM,oBAAoB,MAAM;AAAA,MAC9B,KAAK;AAAA,MACL;AAAA,IACF;AAEA,QAAI,CAAC,mBAAmB;AACtB;AAAA,IACF;AAEA,UAAM,sBAAsB;AAAA,MAC1B,KAAK,UAAU,oBAAoB;AAAA,IACrC;AAEA,QACE,QAAQ,uBACR,KAAK,6BAA6B,qBAClC;AACA;AAAA,IACF;AAEA,SAAK,2BAA2B;AAEhC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,sBACN,cACA,UAEI;AAAA,IACF,qBAAqB;AAAA,EACvB,GAC8B;AAC9B,QAAI,KAAK,aAAa,cAAc;AAClC;AAAA,IACF;AAEA,UAAM,kBAAoC,oBAAI,IAAI;AAElD,eAAW,eAAe,WAAW,KAAK,QAAQ,GAAG;AACnD,YAAM,cAAc,aAAa,IAAI,YAAY,EAAE;AAEnD,UAAI,CAAC,aAAa;AAEhB,wBAAgB;AAAA,UACd,YAAY;AAAA,UACZ,eAAe,aAAa,EAAE,WAAW,KAAK,CAAC;AAAA,QACjD;AAAA,MACF;AAAA,IACF;AAEA,eAAW,eAAe,WAAW,YAAY,GAAG;AAClD,YAAM,cAAc,KAAK,SAAS,IAAI,YAAY,EAAE;AAEpD,UACE,CAAC;AAAA,MACD,YAAY,UAAU,YAAY,SAClC;AACA,YACE,eAAe,WAAW,KAC1B,CAAC,0BAA0B,WAAW,GACtC;AAEA;AAAA,QACF;AAEA,wBAAgB,IAAI,YAAY,IAAI,WAAW;AAAA,MACjD;AAAA,IACF;AAEA,QAAI,CAAC,gBAAgB,MAAM;AACzB;AAAA,IACF;AAEA,UAAM,sBAAsB,oBAAoB,eAAe;AAE/D,QACE,QAAQ,uBACR,KAAK,6BAA6B,qBAClC;AACA;AAAA,IACF;AAEA,SAAK,2BAA2B;AAEhC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,uBAAuB,iBAAmC;AAChE,UAAM,iBAAiB,oBAAI,IAAI;AAE/B,eAAW,eAAe,WAAW,KAAK,QAAQ,GAAG;AAGnD,qBAAe,IAAI,YAAY,IAAI,WAAW;AAAA,IAChD;AAEA,eAAW,kBAAkB,WAAW,eAAe,GAAG;AAGxD,qBAAe,IAAI,eAAe,IAAI,gBAAgB,cAAc,CAAC;AAAA,IACvE;AAEA,WAAO;AAAA,EACT;AACF;AAGA,IAAM,6BAA6B;AAEnC,IAAM,6BAA6B,MAAwB;AACzD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,gBAAgB;AAAA,IAChB,qBAAqBC,eAAc;AAAA,IACnC,oBAAoB,CAAC;AAAA,IACrB,kBAAkB,CAAC;AAAA,IACnB,wBAAwB;AAAA,IACxB,yBAAyB;AAAA,IACzB,mBAAmB;AAAA,IACnB,gBAAgB;AAAA,IAChB,uBAAuB,CAAC;AAAA,EAC1B;AACF;AAEO,IAAM,sBAAsB,CACjC,aACqB;AACrB,QAAM,mBAAmB;AAAA,IACvB,MAAM,SAAS;AAAA,IACf,gBAAgB,SAAS;AAAA,IACzB,qBAAqB,SAAS;AAAA,IAC9B,oBAAoB,SAAS;AAAA,IAC7B,kBAAkB,SAAS;AAAA,IAC3B,mBAAmB,SAAS;AAAA,IAC5B,gBAAgB,SAAS;AAAA,IACzB,uBAAuB,SAAS;AAAA,IAChC,wBACG,SAAsB,sBAAsB;AAAA,IAC5C,SAA8B;AAAA,IAC/B;AAAA,IACF,yBACG,SAAsB,uBAAuB,aAC7C,SAA8B,2BAC/B;AAAA,EACJ;AAEA,UAAQ,eAAe,kBAAkB,4BAA4B;AAAA,IACnE,OAAO;AAAA,IACP,YAAY;AAAA,EACd,CAAC;AAED,SAAO;AACT;AAEA,IAAM,qBAAqB,CACzB,aAEA,CAAC,CAAC,QAAQ,IAAI,UAAU,0BAA0B;;;AGr/BpD;;;ACAA;AAIO,IAAM,iBACX;AAaF,SAAS,SAASC,IAAGC,IAAG,QAAQ;AAC9B,QAAM,OAAO,OAAO,CAAC;AACrB,MAAIA,MAAK,QAAQD,MAAKC,IAAG;AACvB,UAAM,IAAI,MAAMD,KAAI,SAASC,EAAC;AAAA,EAChC;AACA,MAAID,GAAE,MAAM,EAAE,MAAM,QAASC,MAAKA,GAAE,MAAM,EAAE,MAAM,MAAO;AACvD,UAAM,IAAI,MAAM,eAAe;AAAA,EACjC;AACA,MAAIA,IAAG;AAIL,QAAI,IAAI;AACR,YAAQD,GAAE,CAAC,KAAK,UAAUC,GAAE,CAAC,GAAG;AAC9B;AAAA,IACF;AACA,QAAI,IAAI,GAAG;AACT,aAAOA,GAAE,MAAM,GAAG,CAAC,IAAI,SAASD,GAAE,MAAM,CAAC,GAAGC,GAAE,MAAM,CAAC,GAAG,MAAM;AAAA,IAChE;AAAA,EACF;AAEA,QAAM,SAASD,KAAI,OAAO,QAAQA,GAAE,CAAC,CAAC,IAAI;AAC1C,QAAM,SAASC,MAAK,OAAO,OAAO,QAAQA,GAAE,CAAC,CAAC,IAAI,OAAO;AACzD,MAAI,SAAS,SAAS,GAAG;AACvB,UAAM,WAAW,KAAK,MAAM,OAAO,SAAS,OAAO;AACnD,WAAO,OAAO,QAAQ;AAAA,EACxB,OAAO;AAEL,QAAIA,MAAKA,GAAE,SAAS,GAAG;AACrB,aAAOA,GAAE,MAAM,GAAG,CAAC;AAAA,IACrB,OAAO;AAOL,aAAO,OAAO,MAAM,IAAI,SAASD,GAAE,MAAM,CAAC,GAAG,MAAM,MAAM;AAAA,IAC3D;AAAA,EACF;AACF;AAOA,SAAS,gBAAgB,KAAK;AAC5B,MAAI,IAAI,WAAW,iBAAiB,IAAI,CAAC,CAAC,GAAG;AAC3C,UAAM,IAAI,MAAM,wCAAwC,GAAG;AAAA,EAC7D;AACF;AAOA,SAAS,iBAAiB,MAAM;AAC9B,MAAI,QAAQ,OAAO,QAAQ,KAAK;AAC9B,WAAO,KAAK,WAAW,CAAC,IAAI,IAAI,WAAW,CAAC,IAAI;AAAA,EAClD,WAAW,QAAQ,OAAO,QAAQ,KAAK;AACrC,WAAO,IAAI,WAAW,CAAC,IAAI,KAAK,WAAW,CAAC,IAAI;AAAA,EAClD,OAAO;AACL,UAAM,IAAI,MAAM,6BAA6B,IAAI;AAAA,EACnD;AACF;AAOA,SAAS,eAAe,KAAK;AAC3B,QAAM,oBAAoB,iBAAiB,IAAI,CAAC,CAAC;AACjD,MAAI,oBAAoB,IAAI,QAAQ;AAClC,UAAM,IAAI,MAAM,wBAAwB,GAAG;AAAA,EAC7C;AACA,SAAO,IAAI,MAAM,GAAG,iBAAiB;AACvC;AAQA,SAAS,iBAAiB,KAAK,QAAQ;AACrC,MAAI,QAAQ,MAAM,OAAO,CAAC,EAAE,OAAO,EAAE,GAAG;AACtC,UAAM,IAAI,MAAM,wBAAwB,GAAG;AAAA,EAC7C;AAIA,QAAM,IAAI,eAAe,GAAG;AAC5B,QAAM,IAAI,IAAI,MAAM,EAAE,MAAM;AAC5B,MAAI,EAAE,MAAM,EAAE,MAAM,OAAO,CAAC,GAAG;AAC7B,UAAM,IAAI,MAAM,wBAAwB,GAAG;AAAA,EAC7C;AACF;AAQA,SAAS,iBAAiB,GAAG,QAAQ;AACnC,kBAAgB,CAAC;AACjB,QAAM,CAAC,MAAM,GAAG,IAAI,IAAI,EAAE,MAAM,EAAE;AAClC,MAAI,QAAQ;AACZ,WAAS,IAAI,KAAK,SAAS,GAAG,SAAS,KAAK,GAAG,KAAK;AAClD,UAAM,IAAI,OAAO,QAAQ,KAAK,CAAC,CAAC,IAAI;AACpC,QAAI,MAAM,OAAO,QAAQ;AACvB,WAAK,CAAC,IAAI,OAAO,CAAC;AAAA,IACpB,OAAO;AACL,WAAK,CAAC,IAAI,OAAO,CAAC;AAClB,cAAQ;AAAA,IACV;AAAA,EACF;AACA,MAAI,OAAO;AACT,QAAI,SAAS,KAAK;AAChB,aAAO,MAAM,OAAO,CAAC;AAAA,IACvB;AACA,QAAI,SAAS,KAAK;AAChB,aAAO;AAAA,IACT;AACA,UAAM,IAAI,OAAO,aAAa,KAAK,WAAW,CAAC,IAAI,CAAC;AACpD,QAAI,IAAI,KAAK;AACX,WAAK,KAAK,OAAO,CAAC,CAAC;AAAA,IACrB,OAAO;AACL,WAAK,IAAI;AAAA,IACX;AACA,WAAO,IAAI,KAAK,KAAK,EAAE;AAAA,EACzB,OAAO;AACL,WAAO,OAAO,KAAK,KAAK,EAAE;AAAA,EAC5B;AACF;AASA,SAAS,iBAAiB,GAAG,QAAQ;AACnC,kBAAgB,CAAC;AACjB,QAAM,CAAC,MAAM,GAAG,IAAI,IAAI,EAAE,MAAM,EAAE;AAClC,MAAI,SAAS;AACb,WAAS,IAAI,KAAK,SAAS,GAAG,UAAU,KAAK,GAAG,KAAK;AACnD,UAAM,IAAI,OAAO,QAAQ,KAAK,CAAC,CAAC,IAAI;AACpC,QAAI,MAAM,IAAI;AACZ,WAAK,CAAC,IAAI,OAAO,MAAM,EAAE;AAAA,IAC3B,OAAO;AACL,WAAK,CAAC,IAAI,OAAO,CAAC;AAClB,eAAS;AAAA,IACX;AAAA,EACF;AACA,MAAI,QAAQ;AACV,QAAI,SAAS,KAAK;AAChB,aAAO,MAAM,OAAO,MAAM,EAAE;AAAA,IAC9B;AACA,QAAI,SAAS,KAAK;AAChB,aAAO;AAAA,IACT;AACA,UAAM,IAAI,OAAO,aAAa,KAAK,WAAW,CAAC,IAAI,CAAC;AACpD,QAAI,IAAI,KAAK;AACX,WAAK,KAAK,OAAO,MAAM,EAAE,CAAC;AAAA,IAC5B,OAAO;AACL,WAAK,IAAI;AAAA,IACX;AACA,WAAO,IAAI,KAAK,KAAK,EAAE;AAAA,EACzB,OAAO;AACL,WAAO,OAAO,KAAK,KAAK,EAAE;AAAA,EAC5B;AACF;AAaO,SAAS,mBAAmBA,IAAGC,IAAG,SAAS,gBAAgB;AAChE,MAAID,MAAK,MAAM;AACb,qBAAiBA,IAAG,MAAM;AAAA,EAC5B;AACA,MAAIC,MAAK,MAAM;AACb,qBAAiBA,IAAG,MAAM;AAAA,EAC5B;AACA,MAAID,MAAK,QAAQC,MAAK,QAAQD,MAAKC,IAAG;AACpC,UAAM,IAAI,MAAMD,KAAI,SAASC,EAAC;AAAA,EAChC;AACA,MAAID,MAAK,MAAM;AACb,QAAIC,MAAK,MAAM;AACb,aAAO,MAAM,OAAO,CAAC;AAAA,IACvB;AAEA,UAAMC,MAAK,eAAeD,EAAC;AAC3B,UAAME,MAAKF,GAAE,MAAMC,IAAG,MAAM;AAC5B,QAAIA,QAAO,MAAM,OAAO,CAAC,EAAE,OAAO,EAAE,GAAG;AACrC,aAAOA,MAAK,SAAS,IAAIC,KAAI,MAAM;AAAA,IACrC;AACA,QAAID,MAAKD,IAAG;AACV,aAAOC;AAAA,IACT;AACA,UAAM,MAAM,iBAAiBA,KAAI,MAAM;AACvC,QAAI,OAAO,MAAM;AACf,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AACA,WAAO;AAAA,EACT;AAEA,MAAID,MAAK,MAAM;AACb,UAAMG,MAAK,eAAeJ,EAAC;AAC3B,UAAMK,MAAKL,GAAE,MAAMI,IAAG,MAAM;AAC5B,UAAME,KAAI,iBAAiBF,KAAI,MAAM;AACrC,WAAOE,MAAK,OAAOF,MAAK,SAASC,KAAI,MAAM,MAAM,IAAIC;AAAA,EACvD;AAEA,QAAM,KAAK,eAAeN,EAAC;AAC3B,QAAM,KAAKA,GAAE,MAAM,GAAG,MAAM;AAC5B,QAAM,KAAK,eAAeC,EAAC;AAC3B,QAAM,KAAKA,GAAE,MAAM,GAAG,MAAM;AAC5B,MAAI,OAAO,IAAI;AACb,WAAO,KAAK,SAAS,IAAI,IAAI,MAAM;AAAA,EACrC;AACA,QAAM,IAAI,iBAAiB,IAAI,MAAM;AACrC,MAAI,KAAK,MAAM;AACb,UAAM,IAAI,MAAM,2BAA2B;AAAA,EAC7C;AACA,MAAI,IAAIA,IAAG;AACT,WAAO;AAAA,EACT;AACA,SAAO,KAAK,SAAS,IAAI,MAAM,MAAM;AACvC;AAgBO,SAAS,qBAAqBD,IAAGC,IAAG,GAAG,SAAS,gBAAgB;AACrE,MAAI,MAAM,GAAG;AACX,WAAO,CAAC;AAAA,EACV;AACA,MAAI,MAAM,GAAG;AACX,WAAO,CAAC,mBAAmBD,IAAGC,IAAG,MAAM,CAAC;AAAA,EAC1C;AACA,MAAIA,MAAK,MAAM;AACb,QAAIM,KAAI,mBAAmBP,IAAGC,IAAG,MAAM;AACvC,UAAM,SAAS,CAACM,EAAC;AACjB,aAAS,IAAI,GAAG,IAAI,IAAI,GAAG,KAAK;AAC9B,MAAAA,KAAI,mBAAmBA,IAAGN,IAAG,MAAM;AACnC,aAAO,KAAKM,EAAC;AAAA,IACf;AACA,WAAO;AAAA,EACT;AACA,MAAIP,MAAK,MAAM;AACb,QAAIO,KAAI,mBAAmBP,IAAGC,IAAG,MAAM;AACvC,UAAM,SAAS,CAACM,EAAC;AACjB,aAAS,IAAI,GAAG,IAAI,IAAI,GAAG,KAAK;AAC9B,MAAAA,KAAI,mBAAmBP,IAAGO,IAAG,MAAM;AACnC,aAAO,KAAKA,EAAC;AAAA,IACf;AACA,WAAO,QAAQ;AACf,WAAO;AAAA,EACT;AACA,QAAM,MAAM,KAAK,MAAM,IAAI,CAAC;AAC5B,QAAM,IAAI,mBAAmBP,IAAGC,IAAG,MAAM;AACzC,SAAO;AAAA,IACL,GAAG,qBAAqBD,IAAG,GAAG,KAAK,MAAM;AAAA,IACzC;AAAA,IACA,GAAG,qBAAqB,GAAGC,IAAG,IAAI,MAAM,GAAG,MAAM;AAAA,EACnD;AACF;;;ADlTA,SAAS,cAAAO,mBAAkB;AAcpB,IAAM,8BAAN,cAA0C,MAAM;AAAA,EAC9C,OAAO;AAChB;AAwBO,IAAM,4BAA4B,CACvC,UACA;AAAA,EACE,cAAc;AAAA,EACd,6BAA6B;AAAA,EAC7B;AAAA,EACA;AACF,MASG;AACH,QAAM,gBAAgB,CAAC;AACvB,QAAM,mBAAmB,CAAC,YACxB,GAAG,SAAS,KAAK,IAAI,SAAS,EAAE,IAAI,SAAS,IAAI,IAAI,SAAS,SAAS,IAAI,SAAS,OAAO,IAAI,SAAS,YAAY;AAEtH,QAAM,UAAU,SAAS,IAAI,CAAC,MAAM,EAAE,KAAK;AAC3C,aAAW,CAAC,GAAG,KAAK,KAAK,QAAQ,QAAQ,GAAG;AAC1C,UAAM,mBAAmB,QAAQ,IAAI,CAAC;AACtC,UAAM,iBAAiB,QAAQ,IAAI,CAAC;AAEpC,QAAI,CAAC,uBAAuB,OAAO,kBAAkB,cAAc,GAAG;AACpE,oBAAc;AAAA,QACZ,uDAAuD;AAAA,UACrD,SAAS,IAAI,CAAC;AAAA,QAChB,CAAC,OAAO,iBAAiB,SAAS,CAAC,CAAC,CAAC,OAAO;AAAA,UAC1C,SAAS,IAAI,CAAC;AAAA,QAChB,CAAC;AAAA,MACH;AAAA,IACF;AAGA,QAAI,8BAA8B,oBAAoB,SAAS,CAAC,CAAC,GAAG;AAClE,YAAM,YAAY,SAAS,CAAC;AAC5B,YAAM,OAAO,oBAAoB,WAAWC,YAAW,QAAQ,CAAC;AAEhE,UAAI,QAAQ,KAAK,SAAU,UAAU,OAAQ;AAC3C,sBAAc;AAAA,UACZ,0EAA0E;AAAA,YACxE;AAAA,UACF,CAAC,OAAO,iBAAiB,SAAS,CAAC;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAI,cAAc,QAAQ;AACxB,UAAM,QAAQ,IAAI,4BAA4B;AAC9C,UAAM,oBAAoB,CAAC;AAE3B,QAAI,uBAAuB;AACzB,wBAAkB,KAAK,oCAAoC;AAC3D,wBAAkB;AAAA,QAChB,sBAAsB,cAAc,IAAI,CAAC,MAAM,iBAAiB,CAAC,CAAC;AAAA,MACpE;AACA,wBAAkB;AAAA,QAChB,sBAAsB,eAAe,IAAI,CAAC,MAAM,iBAAiB,CAAC,CAAC;AAAA,MACrE;AAAA,IACF;AAEA,QAAI,CAAC,YAAY;AAEf,cAAQ;AAAA,QACN,cAAc,KAAK,MAAM;AAAA,QACzB,MAAM;AAAA,QACN,SAAS,IAAI,CAAC,MAAM,iBAAiB,CAAC,CAAC;AAAA,QACvC,GAAG;AAAA,MACL;AAAA,IACF;AAEA,QAAI,aAAa;AAEf,YAAM;AAAA,IACR;AAAA,EACF;AACF;AAOO,IAAM,yBAAyB,CACpC,aACG;AACH,SAAO,SAAS,KAAK,CAACC,IAAGC,OAAM;AAE7B,QAAI,iBAAiBD,EAAC,KAAK,iBAAiBC,EAAC,GAAG;AAC9C,UAAID,GAAE,QAAQC,GAAE,OAAO;AACrB,eAAO;AAAA,MACT,WAAWD,GAAE,QAAQC,GAAE,OAAO;AAC5B,eAAO;AAAA,MACT;AAGA,aAAOD,GAAE,KAAKC,GAAE,KAAK,KAAK;AAAA,IAC5B;AAGA,WAAO;AAAA,EACT,CAAC;AACH;AAMO,IAAM,mBAAmB,CAC9B,UACA,kBAC+B;AAC/B,MAAI;AACF,UAAM,cAAcF,YAAW,QAAQ;AACvC,UAAM,gBAAgB,sBAAsB,UAAU,aAAa;AAGnE,UAAM,kBAAkB,gBAAgB,UAAU,aAAa;AAC/D,UAAM,qBAAqB,SAAS,IAAI,CAAC,MAAM;AAC7C,YAAM,iBAAiB,gBAAgB,IAAI,CAAC;AAE5C,UAAI,gBAAgB;AAClB,eAAO,EAAE,GAAG,GAAG,OAAO,eAAe,MAAM;AAAA,MAC7C;AAEA,aAAO;AAAA,IACT,CAAC;AAGD;AAAA,MACE;AAAA;AAAA,MAEA;AAAA,QACE,4BAA4B;AAAA,QAC5B,aAAa;AAAA,QACb,YAAY;AAAA,MACd;AAAA,IACF;AAGA,eAAW,CAAC,SAAS,EAAE,MAAM,CAAC,KAAK,iBAAiB;AAClD,oBAAc,SAAS,aAAa,EAAE,MAAM,CAAC;AAAA,IAC/C;AAAA,EACF,SAAS,GAAG;AAEV,uBAAmB,QAAQ;AAAA,EAC7B;AAEA,SAAO;AACT;AAOO,IAAM,qBAAqB,CAChC,aAC+B;AAC/B,QAAM,cAAcA,YAAW,QAAQ;AACvC,QAAM,gBAAgB,wBAAwB,QAAQ;AACtD,QAAM,kBAAkB,gBAAgB,UAAU,aAAa;AAE/D,aAAW,CAAC,SAAS,EAAE,MAAM,CAAC,KAAK,iBAAiB;AAClD,kBAAc,SAAS,aAAa,EAAE,MAAM,CAAC;AAAA,EAC/C;AAEA,SAAO;AACT;AAOO,IAAM,8BAA8B,CACzC,aACiC;AACjC,QAAM,iBAAiBA,YAAW,QAAQ;AAC1C,QAAM,gBAAgB,wBAAwB,QAAQ;AACtD,QAAM,kBAAkB,gBAAgB,UAAU,aAAa;AAE/D,aAAW,CAAC,SAAS,EAAE,MAAM,CAAC,KAAK,iBAAiB;AAClD,mBAAe,IAAI,QAAQ,IAAI,eAAe,SAAS,EAAE,MAAM,CAAC,CAAC;AAAA,EACnE;AAEA,SAAO;AACT;AAOA,IAAM,wBAAwB,CAC5B,UACA,kBACG;AACH,QAAM,gBAA4B,CAAC;AAEnC,MAAI,IAAI;AAER,SAAO,IAAI,SAAS,QAAQ;AAC1B,QAAI,cAAc,IAAI,SAAS,CAAC,EAAE,EAAE,GAAG;AACrC,YAAM,eAAe,CAAC,IAAI,GAAG,CAAC;AAE9B,aAAO,EAAE,IAAI,SAAS,QAAQ;AAC5B,YAAI,CAAC,cAAc,IAAI,SAAS,CAAC,EAAE,EAAE,GAAG;AACtC;AAAA,QACF;AAEA,qBAAa,KAAK,CAAC;AAAA,MACrB;AAEA,mBAAa,KAAK,CAAC;AACnB,oBAAc,KAAK,YAAY;AAAA,IACjC,OAAO;AACL;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAOA,IAAM,0BAA0B,CAAC,aAA2C;AAC1E,QAAM,gBAA4B,CAAC;AAGnC,MAAI,aAAqD;AACzD,MAAI,aAAqD;AACzD,MAAI,kBAA0B;AAC9B,MAAI,kBAA0B;AAG9B,QAAM,gBAAgB,CACpB,UACqD;AACrD,UAAMG,cAAa,SAAS,eAAe,IACvC,SAAS,eAAe,EAAE,QAC1B;AAGJ,UAAM,YAAY,SAAS,QAAQ,CAAC,GAAG;AAEvC,QACG,CAACA,eAAc;AAAA,IACfA,eAAc,aAAa,YAAYA,aACxC;AAEA,aAAO,CAAC,WAAW,QAAQ,CAAC;AAAA,IAC9B;AAGA,WAAO,CAACA,aAAY,eAAe;AAAA,EACrC;AAGA,QAAM,gBAAgB,CACpB,UACqD;AACrD,UAAMC,cAAa,SAAS,eAAe,IACvC,SAAS,eAAe,EAAE,QAC1B;AAGJ,QAAIA,eAAc,QAAQ,iBAAiB;AACzC,aAAO,CAACA,aAAY,eAAe;AAAA,IACrC;AAGA,QAAIC,KAAI;AACR,WAAO,EAAEA,KAAI,SAAS,QAAQ;AAC5B,YAAM,YAAY,SAASA,EAAC,GAAG;AAE/B,UACG,CAACD,eAAc;AAAA,MACfA,eAAc,aAAa,YAAYA,aACxC;AACA,eAAO,CAAC,WAAWC,EAAC;AAAA,MACtB;AAAA,IACF;AAGA,WAAO,CAAC,QAAWA,EAAC;AAAA,EACtB;AAEA,MAAI,IAAI;AAER,SAAO,IAAI,SAAS,QAAQ;AAC1B,UAAM,UAAU,SAAS,CAAC,EAAE;AAC5B,KAAC,YAAY,eAAe,IAAI,cAAc,CAAC;AAC/C,KAAC,YAAY,eAAe,IAAI,cAAc,CAAC;AAE/C,QAAI,CAAC,uBAAuB,SAAS,YAAY,UAAU,GAAG;AAE5D,YAAM,eAAe,CAAC,iBAAiB,CAAC;AAExC,aAAO,EAAE,IAAI,SAAS,QAAQ;AAC5B,cAAMC,WAAU,SAAS,CAAC,EAAE;AAC5B,cAAM,CAAC,gBAAgB,mBAAmB,IAAI,cAAc,CAAC;AAC7D,cAAM,CAAC,gBAAgB,mBAAmB,IAAI,cAAc,CAAC;AAE7D,YAAI,uBAAuBA,UAAS,gBAAgB,cAAc,GAAG;AACnE;AAAA,QACF;AAGA,SAAC,YAAY,eAAe,IAAI,CAAC,gBAAgB,mBAAmB;AACpE,SAAC,YAAY,eAAe,IAAI,CAAC,gBAAgB,mBAAmB;AAEpE,qBAAa,KAAK,CAAC;AAAA,MACrB;AAGA,mBAAa,KAAK,eAAe;AACjC,oBAAc,KAAK,YAAY;AAAA,IACjC,OAAO;AACL;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,yBAAyB,CAC7B,OACA,aACA,cACG;AACH,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AAEA,MAAI,eAAe,WAAW;AAC5B,WAAO,cAAc,SAAS,QAAQ;AAAA,EACxC;AAEA,MAAI,CAAC,eAAe,WAAW;AAE7B,WAAO,QAAQ;AAAA,EACjB;AAEA,MAAI,eAAe,CAAC,WAAW;AAE7B,WAAO,cAAc;AAAA,EACvB;AAGA,SAAO,CAAC,CAAC;AACX;AAEA,IAAM,kBAAkB,CACtB,UACA,kBACG;AACH,QAAM,kBAAkB,oBAAI,IAG1B;AAEF,aAAW,WAAW,eAAe;AACnC,UAAM,kBAAkB,QAAQ,MAAM;AACtC,UAAM,kBAAkB,QAAQ,IAAI;AAEpC,UAAM,oBAAoB;AAAA,MACxB,SAAS,eAAe,GAAG;AAAA,MAC3B,SAAS,eAAe,GAAG;AAAA,MAC3B,QAAQ;AAAA,IACV;AAEA,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,YAAM,UAAU,SAAS,QAAQ,CAAC,CAAC;AAEnC,sBAAgB,IAAI,SAAS;AAAA,QAC3B,OAAO,kBAAkB,CAAC;AAAA,MAC5B,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,mBAAmB,CACvB,YACwC;AAKxC,MAAI,QAAQ,OAAO;AACjB,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;AE7bA;AAAA,oBAAqB;AAErB;AAAA,EACE,iBAAAC;AAAA,EACA,cAAAC;AAAA,EACA;AAAA,EACA,YAAAC;AAAA,EACA,aAAAC;AAAA,EACA;AAAA,OACK;AACP,SAAS,2BAA2B;AACpC,SAAS,sBAAAC,2BAA0B;AACnC,SAAS,sBAAAC,2BAA0B;AAEnC;AAAA,EACE,sBAAAC;AAAA,EACA,oBAAAC;AAAA,EACA,6BAAAC;AAAA,OACK;AAEP,SAAS,uBAAAC,4BAA2B;AAEpC,SAAS,iBAAAC,sBAAyC;AA2BlD,IAAMC,yBAAwB,CAC5B,gBACG;AACH,QAAM,cAAc,oBAAI,IAAI;AAC5B,QAAM,WAAgB,CAAC;AACvB,aAAW,WAAW,aAAa;AACjC,QAAI,CAAC,QAAQ,WAAW;AACtB,eAAS,KAAK,OAAwB;AACtC,kBAAY;AAAA,QACV,QAAQ;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO,EAAE,aAAa,SAAS;AACjC;AAEA,IAAM,+BAA2B,cAAAC;AAAA,EAC/B,CAAC,aAA2C;AAC1C,QAAIV,UAAS,KAAKC,WAAU,KAAK,QAAQ,0BAA0B;AACjE,MAAAK,2BAA0B,UAAU;AAAA;AAAA,QAElC,aAAaN,UAAS,KAAKC,WAAU;AAAA,QACrC,4BAA4B;AAAA,MAC9B,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,MAAO;AAAA,EACP,EAAE,SAAS,MAAM,UAAU,MAAM;AACnC;AAEA,IAAM,oBAAoB,CACxB,SACG;AACH,QAAM,OAAO,CAAC,2BAA2B,yBAAyB;AAalE,MAAI,OAAO;AACX,aAAW,OAAO,MAAM;AACtB,YAAQ,GAAG,GAAG,IAAI,KAAK,GAAG,IAAI,MAAM,GAAG;AAAA,EACzC;AACA,SAAO;AACT;AAMO,IAAM,QAAN,MAAY;AAAA;AAAA;AAAA;AAAA,EAKT,YAAqC,oBAAI,IAAI;AAAA,EAE7C,qBACN,CAAC;AAAA,EACK,wBAAwB;AAAA,IAC9B,oBAAI,IAAI;AAAA,EACV;AAAA;AAAA,EAEQ,WAAgD,CAAC;AAAA,EACjD,wBACN,CAAC;AAAA,EACK,SAAgD,CAAC;AAAA,EACjD,cAAc,cAAgC,oBAAI,IAAI,CAAC;AAAA,EACvD,wBAIJ;AAAA,IACF,oBAAoB;AAAA,IACpB,UAAU;AAAA,IACV,OAAO,oBAAI,IAAI;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ;AAAA,EAER,gBAAgB;AACd,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,2BAA2B;AACzB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,8BAA8B;AAC5B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,iCAAiC;AAC/B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,wBAAwB;AACtB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,4BAA4B;AAC1B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,YAAY,WAAsC,MAAM;AACtD,QAAI,UAAU;AACZ,WAAK,mBAAmB,QAAQ;AAAA,IAClC;AAAA,EACF;AAAA,EAEA,oBAAoB,MAYgB;AAClC,UAAM,OAAO,kBAAkB,IAAI;AAEnC,UAAM,WAAW,MAAM,YAAY,KAAK;AACxC,QACE,KAAK,sBAAsB,aAAa,YACxC,KAAK,sBAAsB,uBAAuB,KAAK,oBACvD;AACA,YAAM,SAAS,KAAK,sBAAsB,MAAM,IAAI,IAAI;AACxD,UAAI,QAAQ;AACV,eAAO;AAAA,MACT;AAAA,IACF,WAAW,MAAM,YAAY,MAAM;AAGjC,WAAK,sBAAsB,MAAM,MAAM;AAAA,IACzC;AAEA,UAAM,mBAAmBM;AAAA,MACvB;AAAA,MACA,EAAE,oBAAoB,KAAK,mBAAmB;AAAA,MAC9C;AAAA,IACF;AAGA,QAAI,MAAM,YAAY,MAAM;AAC1B,WAAK,sBAAsB,qBAAqB,KAAK;AACrD,WAAK,sBAAsB,WAAW,KAAK;AAC3C,WAAK,sBAAsB,MAAM,IAAI,MAAM,gBAAgB;AAAA,IAC7D;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,2BAA8E;AAC5E,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,WAAwC,IAAuB;AAC7D,WAAQ,KAAK,YAAY,IAAI,EAAE,KAAuB;AAAA,EACxD;AAAA,EAEA,qBACE,IACsC;AACtC,UAAM,UAAU,KAAK,WAAW,EAAE;AAClC,QAAI,WAAW,oBAAoB,OAAO,GAAG;AAC3C,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,YACE,UACS;AACT,QAAI,YAAY;AAChB,UAAM,cAAc,KAAK,SAAS,IAAI,CAAC,YAAY;AACjD,YAAM,cAAc,SAAS,OAAO;AACpC,UAAI,gBAAgB,SAAS;AAC3B,oBAAY;AAAA,MACd;AACA,aAAO;AAAA,IACT,CAAC;AACD,QAAI,WAAW;AACb,WAAK,mBAAmB,WAAW;AAAA,IACrC;AACA,WAAO;AAAA,EACT;AAAA,EAEA,mBAAmB,cAAkC;AAEnD,UAAM,gBAAgB,QAAQ,YAAY;AAC1C,UAAM,iBAA+C,CAAC;AAEtD,6BAAyB,aAAa;AAEtC,SAAK,WAAWH,oBAAmB,aAAa;AAChD,SAAK,YAAY,MAAM;AACvB,SAAK,SAAS,QAAQ,CAAC,YAAY;AACjC,UAAIF,oBAAmB,OAAO,GAAG;AAC/B,uBAAe,KAAK,OAAO;AAAA,MAC7B;AACA,WAAK,YAAY,IAAI,QAAQ,IAAI,OAAO;AAAA,IAC1C,CAAC;AACD,UAAM,qBAAqBO,uBAAsB,KAAK,QAAQ;AAC9D,SAAK,qBAAqB,mBAAmB;AAC7C,SAAK,wBAAwB,mBAAmB;AAEhD,SAAK,SAAS;AACd,SAAK,wBAAwBA,uBAAsB,KAAK,MAAM,EAAE;AAEhE,SAAK,cAAc;AAAA,EACrB;AAAA,EAEA,gBAAgB;AACd,SAAK,aAAaX,eAAc;AAEhC,eAAW,YAAY,MAAM,KAAK,KAAK,SAAS,GAAG;AACjD,eAAS;AAAA,IACX;AAAA,EACF;AAAA,EAEA,SAAS,IAAmD;AAC1D,QAAI,KAAK,UAAU,IAAI,EAAE,GAAG;AAC1B,YAAM,IAAI,MAAM;AAAA,IAClB;AAEA,SAAK,UAAU,IAAI,EAAE;AAErB,WAAO,MAAM;AACX,UAAI,CAAC,KAAK,UAAU,IAAI,EAAE,GAAG;AAC3B,cAAM,IAAI,MAAM;AAAA,MAClB;AACA,WAAK,UAAU,OAAO,EAAE;AAAA,IAC1B;AAAA,EACF;AAAA,EAEA,UAAU;AACR,SAAK,WAAW,CAAC;AACjB,SAAK,qBAAqB,CAAC;AAC3B,SAAK,wBAAwB,CAAC;AAC9B,SAAK,SAAS,CAAC;AACf,SAAK,YAAY,MAAM;AACvB,SAAK,sBAAsB,qBAAqB;AAChD,SAAK,sBAAsB,WAAW;AACtC,SAAK,sBAAsB,MAAM,MAAM;AAIvC,SAAK,UAAU,MAAM;AAAA,EACvB;AAAA,EAEA,qBAAqB,SAA4B,OAAe;AAC9D,QAAI,CAAC,OAAO,SAAS,KAAK,KAAK,QAAQ,GAAG;AACxC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,eAAe;AAAA,MACnB,GAAG,KAAK,SAAS,MAAM,GAAG,KAAK;AAAA,MAC/B;AAAA,MACA,GAAG,KAAK,SAAS,MAAM,KAAK;AAAA,IAC9B;AAEA,IAAAO,kBAAiB,cAAcN,YAAW,CAAC,OAAO,CAAC,CAAC;AAEpD,SAAK,mBAAmB,YAAY;AAAA,EACtC;AAAA,EAEA,sBAAsB,UAA+B,OAAe;AAClE,QAAI,CAAC,SAAS,QAAQ;AACpB;AAAA,IACF;AAEA,QAAI,CAAC,OAAO,SAAS,KAAK,KAAK,QAAQ,GAAG;AACxC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,eAAe;AAAA,MACnB,GAAG,KAAK,SAAS,MAAM,GAAG,KAAK;AAAA,MAC/B,GAAG;AAAA,MACH,GAAG,KAAK,SAAS,MAAM,KAAK;AAAA,IAC9B;AAEA,IAAAM,kBAAiB,cAAcN,YAAW,QAAQ,CAAC;AAEnD,SAAK,mBAAmB,YAAY;AAAA,EACtC;AAAA,EAEA,gBAAgB,CAAC,YAA+B;AAC9C,UAAM,QAAQ,QAAQ,UAClB,KAAK,gBAAgB,QAAQ,OAAO,IACpC,KAAK,SAAS;AAElB,SAAK,qBAAqB,SAAS,KAAK;AAAA,EAC1C;AAAA,EAEA,iBAAiB,CAAC,aAAkC;AAClD,QAAI,CAAC,SAAS,QAAQ;AACpB;AAAA,IACF;AAEA,UAAM,QAAQ,SAAS,CAAC,GAAG,UACvB,KAAK,gBAAgB,SAAS,CAAC,EAAE,OAAO,IACxC,KAAK,SAAS;AAElB,SAAK,sBAAsB,UAAU,KAAK;AAAA,EAC5C;AAAA,EAEA,gBAAgB,WAAmB;AACjC,WAAO,KAAK,SAAS,UAAU,CAAC,YAAY,QAAQ,OAAO,SAAS;AAAA,EACtE;AAAA,EAEA,sBAAsB,CACpB,YAKG;AACH,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AACA,QAAI,QAAQ,aAAa;AACvB,aAAO,KAAK,WAAW,QAAQ,WAAW,KAAK;AAAA,IACjD;AACA,WAAO;AAAA,EACT;AAAA,EAEA,oBAAoB,CAAC,OAAoC;AACvD,UAAM,cAAc,KAAK,yBAAyB;AAElD,UAAM,KAAK,YAAY,IAAI,EAAE;AAC7B,QAAI,IAAI;AACN,aAAO,CAAC,EAAE;AAAA,IACZ;AAGA,WAAOI,oBAAmB,aAAa,EAAE;AAAA,EAC3C;AAAA;AAAA;AAAA,EAIA,cACE,SACA,SACA,UAGI;AAAA,IACF,gBAAgB;AAAA,IAChB,YAAY;AAAA,EACd,GACA;AACA,UAAM,cAAc,KAAK,yBAAyB;AAElD,UAAM,EAAE,SAAS,YAAY,IAAI;AACjC,UAAM,EAAE,SAAS,YAAY,IAAIK;AAAA,MAC/B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA;AAAA;AAAA,MAEE,KAAK,YAAY,IAAI,QAAQ,EAAE;AAAA,MAE/B,gBAAgB,eAChB,QAAQ;AAAA,MACR;AACA,WAAK,cAAc;AAAA,IACrB;AAEA,WAAO;AAAA,EACT;AACF;;;AN7XO,IAAM,QAAN,MAAM,OAAS;AAAA,EACZ,YACU,SACA,UAChB;AAFgB;AACA;AAAA,EACf;AAAA,EAEH,OAAc,OACZ,SACA,UACA,UAIA,iBACA;AACA,UAAM,kBACJ,YAAY,oBAAoB,aAC5B,SAAS,SAAS,SAAS,IAC3B;AACN,UAAM,mBACJ,YAAY,oBAAoB,YAC5B,SAAS,UAAU,UAAU,IAC7B;AAEN,WAAO,IAAI,OAAM,iBAAiB,gBAAgB;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,OAAc,UACZ,YACA,YACA,UACA,aAIU;AACV,QAAI,eAAe,YAAY;AAC7B,aAAO,OAAM,MAAM;AAAA,IACrB;AAEA,UAAM,UAAU,CAAC;AACjB,UAAM,WAAW,CAAC;AAOlB,eAAW,OAAO,KAAK,eAAe,YAAY,UAAU,GAAG;AAC7D,cAAQ,GAAc,IAAI,WAAW,GAAG;AACxC,eAAS,GAAc,IAAI,WAAW,GAAG;AAAA,IAC3C;AAEA,UAAM,CAAC,kBAAkB,iBAAiB,IAAI,cAC1C,YAAY,SAAS,QAAQ,IAC7B,CAAC,SAAS,QAAQ;AAEtB,WAAO,OAAM,OAAO,kBAAkB,mBAAmB,QAAQ;AAAA,EACnE;AAAA,EAEA,OAAc,QAAQ;AACpB,WAAO,IAAI,OAAM,CAAC,GAAG,CAAC,CAAC;AAAA,EACzB;AAAA,EAEA,OAAc,QAAW,OAA0B;AACjD,WACE,CAAC,OAAO,KAAK,MAAM,OAAO,EAAE,UAAU,CAAC,OAAO,KAAK,MAAM,QAAQ,EAAE;AAAA,EAEvE;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,aACZ,MACA,OACA,SACA;AACA,UAAM,SAAS,EAAE,GAAG,KAAK;AAEzB,eAAW,OAAO,OAAO,KAAK,OAAO,GAAG;AACtC,aAAO,OAAO,GAAG;AAAA,IACnB;AAEA,WAAO,EAAE,GAAG,QAAQ,GAAG,MAAM;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,YACZ,MACA,OACA,SACA,WACA;AACA,WAAO,OAAO;AAAA,MACZ,OAAM;AAAA,QACJ,cAAc,QAAQ,CAAC,GAAG,SAAS;AAAA,QACnC,cAAc,SAAS,CAAC,GAAG,SAAS;AAAA,QACpC,cAAc,WAAW,CAAC,GAAG,SAAS;AAAA,MACxC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,YACZ,SACA,UACA,UACA,UACA;AACA,QAAI,CAAC,QAAQ,QAAQ,KAAK,CAAC,SAAS,QAAQ,GAAG;AAC7C;AAAA,IACF;AAEA,UAAM,kBACJ,QAAQ,QAAQ,MAAM,QAAQ,OAAO,QAAQ,QAAQ,MAAM;AAC7D,UAAM,mBACJ,SAAS,QAAQ,MAAM,QAAQ,OAAO,SAAS,QAAQ,MAAM;AAE/D,QAAI,mBAAmB,kBAAkB;AAGvC,YAAM,gBAA4B,QAAQ,QAAQ,KAAK,CAAC;AACxD,YAAM,iBAA6B,SAAS,QAAQ,KAAK,CAAC;AAE1D,YAAM,qBAAqB,OAAM;AAAA,QAC/B;AAAA,QACA;AAAA,MACF,EAAE,OAAO,CAAC,KAAK,SAAS;AACtB,YAAI,IAAI,IAAI,SAAS,cAAc,IAAI,CAAC;AACxC,eAAO;AAAA,MACT,GAAG,CAAC,CAAe;AAEnB,YAAM,sBAAsB,OAAM;AAAA,QAChC;AAAA,QACA;AAAA,MACF,EAAE,OAAO,CAAC,KAAK,SAAS;AACtB,YAAI,IAAI,IAAI,SAAS,eAAe,IAAI,CAAC;AACzC,eAAO;AAAA,MACT,GAAG,CAAC,CAAe;AAEnB,UACE,OAAO,KAAK,kBAAkB,EAAE,UAChC,OAAO,KAAK,mBAAmB,EAAE,QACjC;AACA,gBAAQ,IAAI,SAAS,UAAU,kBAAkB;AACjD,gBAAQ,IAAI,UAAU,UAAU,mBAAmB;AAAA,MACrD,OAAO;AACL,gBAAQ,eAAe,SAAS,QAAQ;AACxC,gBAAQ,eAAe,UAAU,QAAQ;AAAA,MAC3C;AAAA,IACF,WAAW,QAAQ,QAAQ,MAAM,SAAS,QAAQ,GAAG;AACnD,cAAQ,eAAe,SAAS,QAAQ;AACxC,cAAQ,eAAe,UAAU,QAAQ;AAAA,IAC3C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,WACZ,SACA,UACA,UACA,SACA;AACA,QAAI,CAAC,QAAQ,QAAQ,KAAK,CAAC,SAAS,QAAQ,GAAG;AAC7C;AAAA,IACF;AAEA,QAAI,MAAM,QAAQ,QAAQ,QAAQ,CAAC,KAAK,MAAM,QAAQ,SAAS,QAAQ,CAAC,GAAG;AACzE,YAAM,eACJ,MAAM,QAAQ,QAAQ,QAAQ,CAAC,IAAI,QAAQ,QAAQ,IAAI,CAAC;AAE1D,YAAM,gBACJ,MAAM,QAAQ,SAAS,QAAQ,CAAC,IAAI,SAAS,QAAQ,IAAI,CAAC;AAG5D,YAAM,qBAAqB;AAAA,QACzB,OAAM;AAAA,UACJ,cAAc,cAAc,OAAO;AAAA,UACnC,cAAc,eAAe,OAAO;AAAA,QACtC;AAAA,QACA,CAAC,MAAM;AAAA,MACT;AACA,YAAM,sBAAsB;AAAA,QAC1B,OAAM;AAAA,UACJ,cAAc,cAAc,OAAO;AAAA,UACnC,cAAc,eAAe,OAAO;AAAA,QACtC;AAAA,QACA,CAAC,MAAM;AAAA,MACT;AAEA,UACE,OAAO,KAAK,kBAAkB,EAAE,UAChC,OAAO,KAAK,mBAAmB,EAAE,QACjC;AACA,cAAM,eAAe,aAAa;AAAA,UAChC,CAAC,MAAM,mBAAmB,UAAU,QAAQ,CAAC,IAAI,OAAO,CAAC,CAAC;AAAA,QAC5D;AACA,cAAM,gBAAgB,cAAc;AAAA,UAClC,CAAC,MAAM,oBAAoB,UAAU,QAAQ,CAAC,IAAI,OAAO,CAAC,CAAC;AAAA,QAC7D;AAEA,gBAAQ,IAAI,SAAS,UAAU,YAAY;AAC3C,gBAAQ,IAAI,UAAU,UAAU,aAAa;AAAA,MAC/C,OAAO;AACL,gBAAQ,eAAe,SAAS,QAAQ;AACxC,gBAAQ,eAAe,UAAU,QAAQ;AAAA,MAC3C;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,gBACZ,SACA,SACA,qBAAqB,OACZ;AACT,UAAM,iBAAiB,KAAK;AAAA,MAC1B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAE,KAAK,EAAE;AAET,WAAO,CAAC,CAAC;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,iBACZ,SACA,SACA,qBAAqB,OACZ;AACT,UAAM,iBAAiB,KAAK;AAAA,MAC1B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAE,KAAK,EAAE;AAET,WAAO,CAAC,CAAC;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,iBACZ,SACA,SACA,qBAAqB,OACZ;AACT,UAAM,iBAAiB,CAAC,CAAC,KAAK;AAAA,MAC5B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAE,KAAK,EAAE;AAET,WAAO,CAAC,CAAC;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,YACZ,SACA,SACA,qBAAqB,OACZ;AACT,UAAM,iBAAiB,CAAC,CAAC,KAAK;AAAA,MAC5B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAE,KAAK,EAAE;AAET,WAAO,CAAC,CAAC;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,mBACZ,SACA,SACA,qBAAqB,OACrB;AACA,WAAO,MAAM;AAAA,MACX,KAAK,qBAAqB,QAAQ,SAAS,SAAS,kBAAkB;AAAA,IACxE,EAAE,KAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,oBACZ,SACA,SACA,qBAAqB,OACrB;AACA,WAAO,MAAM;AAAA,MACX,KAAK,qBAAqB,SAAS,SAAS,SAAS,kBAAkB;AAAA,IACzE,EAAE,KAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,oBACZ,SACA,SACA,qBAAqB,OACrB;AACA,WAAO,MAAM;AAAA,MACX,KAAK,qBAAqB,SAAS,SAAS,SAAS,kBAAkB;AAAA,IACzE,EAAE,KAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,eACZ,SACA,SACA,qBAAqB,OACrB;AACA,WAAO,MAAM;AAAA,MACX,KAAK,qBAAqB,QAAQ,SAAS,SAAS,kBAAkB;AAAA,IACxE,EAAE,KAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,QAAgB,qBACd,MACA,SACA,SACA,qBAAqB,OACrB;AACA,QAAI,YAAY,SAAS;AACvB;AAAA,IACF;AAEA,QAAI,OAAiB,CAAC;AAEtB,QAAI,SAAS,QAAQ;AACnB,aAAO,OAAO,KAAK,OAAO;AAAA,IAC5B,WAAW,SAAS,SAAS;AAC3B,aAAO,OAAO,KAAK,OAAO;AAAA,IAC5B,WAAW,SAAS,SAAS;AAC3B,aAAO,OAAO,KAAK,OAAO,EAAE,OAAO,CAAC,QAAQ,OAAO,OAAO;AAAA,IAC5D,WAAW,SAAS,QAAQ;AAC1B,aAAO,MAAM;AAAA,QACX,oBAAI,IAAI,CAAC,GAAG,OAAO,KAAK,OAAO,GAAG,GAAG,OAAO,KAAK,OAAO,CAAC,CAAC;AAAA,MAC5D;AAAA,IACF,OAAO;AACL,MAAAG;AAAA,QACE;AAAA,QACA,8CAA8C,IAAI;AAAA,QAClD;AAAA,MACF;AAAA,IACF;AAEA,eAAW,OAAO,MAAM;AACtB,YAAM,SAAS,QAAQ,GAAc;AACrC,YAAM,SAAS,QAAQ,GAAc;AAErC,UAAI,WAAW,QAAQ;AACrB,YACE,CAAC,sBACD,OAAO,WAAW,YAClB,OAAO,WAAW,YAClB,WAAW,QACX,WAAW,QACXC,gBAAe,QAAQ,MAAM,GAC7B;AACA;AAAA,QACF;AAEA,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;AAwBO,IAAM,gBAAN,MAAM,eAAkD;AAAA,EACrD,YAA4B,OAAgC;AAAhC;AAAA,EAAiC;AAAA,EAErE,OAAc,UACZ,cACA,cACe;AACf,UAAM,QAAQ,MAAM;AAAA,MAClB;AAAA,MACA;AAAA;AAAA,MAEA,eAAc;AAAA,MACd,eAAc;AAAA,IAChB;AAEA,WAAO,IAAI,eAAc,KAAK;AAAA,EAChC;AAAA,EAEA,OAAc,QAAQ,kBAAqD;AACzE,UAAM,EAAE,MAAM,IAAI;AAClB,WAAO,IAAI,eAAc,KAAK;AAAA,EAChC;AAAA,EAEA,OAAc,QAAQ;AACpB,WAAO,IAAI,eAAc,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;AAAA,EAC/C;AAAA,EAEO,UAAyB;AAC9B,UAAM,gBAAgB,MAAM,OAAO,KAAK,MAAM,UAAU,KAAK,MAAM,OAAO;AAC1E,WAAO,IAAI,eAAc,aAAa;AAAA,EACxC;AAAA,EAEO,QACL,UACA,cACqB;AACrB,QAAI;AACF,YAAM;AAAA,QACJ,oBAAoB,4BAA4B,CAAC;AAAA,QACjD,kBAAkB,0BAA0B,CAAC;AAAA,MAC/C,IAAI,KAAK,MAAM;AAEf,YAAM;AAAA,QACJ,oBAAoB,0BAA0B,CAAC;AAAA,QAC/C,kBAAkB,wBAAwB,CAAC;AAAA,QAC3C;AAAA,QACA;AAAA,QACA,GAAG;AAAA,MACL,IAAI,KAAK,MAAM;AAEf,YAAM,2BAA2B,MAAM;AAAA,QACrC,SAAS;AAAA,QACT;AAAA,QACA;AAAA,MACF;AAEA,YAAM,yBAAyB,MAAM;AAAA,QACnC,SAAS;AAAA,QACT;AAAA,QACA;AAAA,MACF;AAEA,YAAM,wBACJ,2BAA2B,aAAa,IAAI,uBAAuB,IAC/D,IAAI;AAAA,QACF,aAAa;AAAA,UACX;AAAA,QACF;AAAA,QACA;AAAA,MACF,IACA;AAEN,YAAM,uBACJ,0BAA0B,aAAa,IAAI,sBAAsB,IAC7D,IAAI;AAAA,QACF,aAAa;AAAA,UACX;AAAA,QACF;AAAA,QACA;AAAA,MACF,IACA;AAEN,YAAM,eAAe;AAAA,QACnB,GAAG;AAAA,QACH,GAAG;AAAA,QACH,oBAAoB;AAAA,QACpB,kBAAkB;AAAA,QAClB,uBACE,OAAO,4BAA4B,cAC/B,wBACA,SAAS;AAAA;AAAA,QACf,sBACE,OAAO,2BAA2B,cAC9B,uBACA,SAAS;AAAA;AAAA,MACjB;AAEA,YAAM,0BAA0B,KAAK;AAAA,QACnC;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,aAAO,CAAC,cAAc,uBAAuB;AAAA,IAC/C,SAAS,GAAG;AAEV,cAAQ,MAAM,kCAAkC,CAAC;AAEjD,UAAIC,WAAU,KAAKC,UAAS,GAAG;AAC7B,cAAM;AAAA,MACR;AAEA,aAAO,CAAC,UAAU,KAAK;AAAA,IACzB;AAAA,EACF;AAAA,EAEO,UAAmB;AACxB,WAAO,MAAM,QAAQ,KAAK,KAAK;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,uBACN,cACA,cACA,cACS;AAGT,UAAM,uBAAuB,oBAAoB,YAAY;AAC7D,UAAM,uBAAuB,oBAAoB,YAAY;AAE7D,UAAM,+BAA+B,MAAM;AAAA,MACzC,eAAc,mBAAmB,oBAAoB;AAAA,MACrD,eAAc,mBAAmB,oBAAoB;AAAA,IACvD;AAEA,UAAM,6BAA6B,MAAM;AAAA,MACvC,eAAc,qBAAqB,oBAAoB;AAAA,MACvD,eAAc,qBAAqB,oBAAoB;AAAA,IACzD;AAEA,QAAI,CAAC,gCAAgC,CAAC,4BAA4B;AAEhE,aAAO;AAAA,IACT;AAEA,UAAM,wBAAwB;AAAA,MAC5B,OAAO;AAAA,IACT;AAEA,QAAI,4BAA4B;AAE9B,YAAM,uBAAuB,MAAM;AAAA,QACjC,eAAc,qBAAqB,oBAAoB;AAAA,QACvD,eAAc,qBAAqB,oBAAoB;AAAA,MACzD;AAEA,UAAI,qBAAqB,oBAAI,IAAY;AAEzC,UACE,qBAAqB,SAAS,gBAAgB,KAC9C,qBAAqB,SAAS,kBAAkB,GAChD;AAEA,6BAAqB,sBAAsB,YAAY;AAAA,MACzD;AAGA,iBAAW,OAAO,sBAAsB;AACtC,gBAAQ,KAAK;AAAA,UACX,KAAK;AACH,yBAAa,GAAG,IAAI,eAAc;AAAA,cAChC,aAAa,GAAG;AAAA,cAChB;AAAA,cACA;AAAA,YACF;AAEA;AAAA,UACF,KAAK;AACH,yBAAa,GAAG,IAAI,eAAc;AAAA,cAChC,aAAa,GAAG;AAAA,cAChB;AAAA,cACA;AAAA,YACF;AAEA;AAAA,UACF,KAAK,qBAAqB;AACxB,kBAAM,oBAAoB,aAAa,GAAG;AAE1C,gBAAI,CAAC,mBAAmB;AAEtB,oCAAsB,QAAQ;AAAA,YAChC,OAAO;AACL,oBAAM,UAAU,aAAa,IAAI,iBAAiB;AAElD,kBAAI,WAAW,CAAC,QAAQ,WAAW;AACjC,sCAAsB,QAAQ;AAAA,cAChC,OAAO;AACL,6BAAa,GAAG,IAAI;AAAA,cACtB;AAAA,YACF;AAEA;AAAA,UACF;AAAA,UACA,KAAK;AACH,kBAAM,iBAAiB,aAAa,GAAG;AAEvC,gBAAI,CAAC,gBAAgB;AAEnB,oCAAsB,QAAQ;AAAA,YAChC,WAAW,mBAAmB,IAAI,cAAc,GAAG;AAEjD,oCAAsB,QAAQ;AAAA,YAChC,OAAO;AAEL,2BAAa,GAAG,IAAI;AAAA,YACtB;AAEA;AAAA,UACF,KAAK;AAAA,UACL,KAAK;AACH,kBAAM,cAAc,eAAc,qBAAqB,GAAG;AAC1D,kBAAM,gBAAgB,aAAa,WAAW;AAE9C,gBAAI,CAAC,eAAe;AAElB,oCAAsB,QAAQ;AAAA,YAChC,OAAO;AACL,oBAAM,UAAU,aAAa,IAAI,cAAc,SAAS;AAExD,kBAAI,WAAW,CAAC,QAAQ,WAAW;AAEjC,sCAAsB,QAAQ;AAAA,cAChC,OAAO;AAEL,6BAAa,WAAW,IAAI;AAAA,cAC9B;AAAA,YACF;AAEA;AAAA,UACF,KAAK,yBAAyB;AAC5B,kBAAM,kBAAkB,aAAa,GAAG,KAAK,CAAC;AAC9C,kBAAM,kBAAkB,aAAa,GAAG,KAAK,CAAC;AAE9C,gBAAI,CAACF,gBAAe,iBAAiB,eAAe,GAAG;AACrD,oCAAsB,QAAQ;AAAA,YAChC;AACA;AAAA,UACF;AAAA,UACA,KAAK,kBAAkB;AACrB,kBAAM,kBAAkB,aAAa,GAAG,KAAK;AAC7C,kBAAM,kBAAkB,aAAa,GAAG,KAAK;AAE7C,gBAAI,oBAAoB,iBAAiB;AACvC,oCAAsB,QAAQ;AAAA,YAChC;AACA;AAAA,UACF;AAAA,UACA,SAAS;AACP,YAAAD;AAAA,cACE;AAAA,cACA,2CAA2C,GAAG;AAAA,cAC9C;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,sBAAsB;AAAA,EAC/B;AAAA,EAEA,OAAe,qBACb,KAIwE;AACxE,YAAQ,KAAK;AAAA,MACX,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,IACX;AAAA,EACF;AAAA,EAEA,OAAe,uBACb,oBACA,UACA,uBACA;AACA,UAAM,MAAM,OAAO,KAAK,kBAAkB;AAE1C,QAAI,CAAC,IAAI,QAAQ;AAEf,4BAAsB,QAAQ;AAC9B,aAAO;AAAA,IACT;AAEA,UAAM,yBAAyB,EAAE,GAAG,mBAAmB;AAEvD,eAAW,MAAM,KAAK;AACpB,YAAM,UAAU,SAAS,IAAI,EAAE;AAE/B,UAAI,WAAW,CAAC,QAAQ,WAAW;AAEjC,8BAAsB,QAAQ;AAAA,MAChC,OAAO;AACL,eAAO,uBAAuB,EAAE;AAAA,MAClC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAe,qBACb,kBACA,oBACA,uBACA;AACA,UAAM,MAAM,OAAO,KAAK,gBAAgB;AAExC,QAAI,CAAC,IAAI,QAAQ;AAEf,4BAAsB,QAAQ;AAC9B,aAAO;AAAA,IACT;AAEA,UAAM,uBAAuB,EAAE,GAAG,iBAAiB;AAEnD,eAAW,MAAM,OAAO,KAAK,oBAAoB,GAAG;AAClD,UAAI,mBAAmB,IAAI,EAAE,GAAG;AAE9B,8BAAsB,QAAQ;AAAA,MAChC,OAAO;AACL,eAAO,qBAAqB,EAAE;AAAA,MAChC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAe,mBACb,OACqC;AAErC,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IACL,IAAI;AAEJ,WAAO;AAAA,EAIT;AAAA,EAEA,OAAe,qBACb,OACmC;AAEnC,UAAM,EAAE,MAAM,qBAAqB,GAAG,cAAc,IAClD;AAEF,WAAO;AAAA,EAIT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAe,YACb,SACA,UAC0B;AAC1B,QAAI;AACF,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA;AAAA,QAEA,CAAC,MAAM;AAAA,MACT;AACA,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA,CAAC,cAAe,aAAa;AAAA,MAC/B;AACA,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA,CAAC,cAAe,aAAa,CAAC;AAAA,MAChC;AACA,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA,CAAC,cAAe,aAAa;AAAA,MAC/B;AAAA,IACF,SAAS,GAAG;AAEV,cAAQ,MAAM,8CAA8C;AAE5D,UAAIE,WAAU,KAAKC,UAAS,GAAG;AAC7B,cAAM;AAAA,MACR;AAAA,IACF,UAAE;AACA,aAAO,CAAC,SAAS,QAAQ;AAAA,IAC3B;AAAA,EACF;AAAA,EAEA,OAAe,kBAAkB,SAAoC;AACnE,UAAM,iBAA6C,CAAC;AAEpD,eAAW,OAAO,OAAO,KAAK,OAAO,EAAE,KAAK,GAAG;AAE7C,qBAAe,GAAG,IAAI,QAAQ,GAA6B;AAAA,IAC7D;AAEA,WAAO;AAAA,EACT;AACF;AAkBO,IAAM,gBAAN,MAAM,eAA0D;AAAA,EAC7D,YACU,OACA,SACA,SAChB;AAHgB;AACA;AACA;AAAA,EACf;AAAA,EAEH,OAAc,OACZ,OACA,SACA,SACA,UAEI;AAAA,IACF,oBAAoB;AAAA,EACtB,GACA;AACA,QAAI;AAEJ,QAAI,QAAQ,oBAAoB;AAC9B,YAAM,YAAmD,CAAC;AAC1D,YAAM,cAAqD,CAAC;AAC5D,YAAM,cAAqD,CAAC;AAE5D,YAAM,SAAS;AAAA,QACb,GAAG,OAAO,QAAQ,KAAK;AAAA,QACvB,GAAG,OAAO,QAAQ,OAAO;AAAA,QACzB,GAAG,OAAO,QAAQ,OAAO;AAAA,MAC3B;AAEA,iBAAW,CAAC,IAAIC,MAAK,KAAK,QAAQ;AAChC,YAAI,KAAK,kBAAkBA,MAAK,GAAG;AACjC,oBAAU,EAAE,IAAIA;AAAA,QAClB,WAAW,KAAK,iBAAiBA,MAAK,GAAG;AACvC,sBAAY,EAAE,IAAIA;AAAA,QACpB,OAAO;AACL,sBAAY,EAAE,IAAIA;AAAA,QACpB;AAAA,MACF;AAEA,cAAQ,IAAI,eAAc,WAAW,aAAa,WAAW;AAAA,IAC/D,OAAO;AACL,cAAQ,IAAI,eAAc,OAAO,SAAS,OAAO;AAAA,IACnD;AAEA,QAAIF,WAAU,KAAKC,UAAS,GAAG;AAC7B,qBAAc,SAAS,OAAO,SAAS,KAAK,iBAAiB;AAC7D,qBAAc,SAAS,OAAO,WAAW,KAAK,gBAAgB;AAC9D,qBAAc,SAAS,OAAO,WAAW,KAAK,eAAe;AAAA,IAC/D;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAc,QAAQ,kBAAqD;AACzE,UAAM,EAAE,OAAO,SAAS,QAAQ,IAAI;AACpC,WAAO,eAAc,OAAO,OAAO,SAAS,OAAO;AAAA,EACrD;AAAA,EAEA,OAAe,oBAAoB,CAAC;AAAA,IAClC;AAAA,IACA;AAAA,EACF;AAAA;AAAA,IAEE,QAAQ,cAAc,QAAQ,CAAC,SAAS;AAAA;AAAA,EAE1C,OAAe,mBAAmB,CAAC;AAAA,IACjC;AAAA,IACA;AAAA,EACF,MACE,CAAC,QAAQ,aAAa,SAAS,cAAc;AAAA,EAE/C,OAAe,kBAAkB,CAAC;AAAA,IAChC;AAAA,IACA;AAAA,EACF,MAA6B,CAAC,CAAC,QAAQ,cAAc,CAAC,CAAC,SAAS;AAAA,EAEhE,OAAe,6BAA6B,CAAC;AAAA,IAC3C;AAAA,IACA;AAAA,EACF,MACE,CAAC,EACC,QAAQ,WACR,SAAS;AAAA,EAET,OAAO,UAAU,QAAQ,OAAO,KAChC,OAAO,UAAU,SAAS,OAAO;AAAA,EAEjC,QAAQ,WAAW,KACnB,SAAS,WAAW;AAAA,EAEpB,QAAQ,YAAY,SAAS;AAAA,EAGjC,OAAe,SACb,eACA,MACA,2BACA;AACA,eAAW,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,cAAc,IAAI,CAAC,GAAG;AAC7D,UACE,CAAC,KAAK,2BAA2B,KAAK,KACtC,CAAC,0BAA0B,KAAK,GAChC;AACA,gBAAQ;AAAA,UACN,yBAAyB,IAAI,qBAAqB,EAAE;AAAA,UACpD;AAAA,QACF;AACA,cAAM,IAAI,MAAM,+CAA+C,EAAE,IAAI;AAAA,MACvE;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,OAAc,UACZ,cACA,cACe;AACf,QAAI,iBAAiB,cAAc;AACjC,aAAO,eAAc,MAAM;AAAA,IAC7B;AAEA,UAAM,QAA+C,CAAC;AACtD,UAAM,UAAiD,CAAC;AACxD,UAAM,UAAiD,CAAC;AAGxD,eAAW,eAAe,aAAa,OAAO,GAAG;AAC/C,YAAM,cAAc,aAAa,IAAI,YAAY,EAAE;AAEnD,UAAI,CAAC,aAAa;AAChB,cAAM,UAAU,EAAE,GAAG,aAAa,WAAW,MAAM;AAEnD,cAAM,WAAW;AAAA,UACf,WAAW;AAAA,UACX,SAAS,YAAY,UAAU;AAAA,UAC/B,cAAcE,eAAc;AAAA,QAC9B;AAEA,cAAM,QAAQ,MAAM;AAAA,UAClB;AAAA,UACA;AAAA,UACA,eAAc;AAAA,QAChB;AAEA,gBAAQ,YAAY,EAAE,IAAI;AAAA,MAC5B;AAAA,IACF;AAEA,eAAW,eAAe,aAAa,OAAO,GAAG;AAC/C,YAAM,cAAc,aAAa,IAAI,YAAY,EAAE;AAEnD,UAAI,CAAC,aAAa;AAChB,cAAM,UAAU;AAAA,UACd,WAAW;AAAA,UACX,SAAS,YAAY,UAAU;AAAA,UAC/B,cAAcA,eAAc;AAAA,QAC9B;AAEA,cAAM,WAAW;AAAA,UACf,GAAG;AAAA,UACH,WAAW;AAAA,QACb;AAEA,cAAM,QAAQ,MAAM;AAAA,UAClB;AAAA,UACA;AAAA,UACA,eAAc;AAAA,QAChB;AAEA,cAAM,YAAY,EAAE,IAAI;AAExB;AAAA,MACF;AAEA,UAAI,YAAY,iBAAiB,YAAY,cAAc;AACzD,cAAM,QAAQ,MAAM;AAAA,UAClB;AAAA,UACA;AAAA,UACA,eAAc;AAAA,UACd,eAAc;AAAA,QAChB;AAEA;AAAA;AAAA,UAEE,OAAO,YAAY,cAAc,aACjC,OAAO,YAAY,cAAc,aACjC,YAAY,cAAc,YAAY;AAAA,UACtC;AAEA,cAAI,YAAY,aAAa,CAAC,YAAY,WAAW;AACnD,kBAAM,YAAY,EAAE,IAAI;AAAA,UAC1B,OAAO;AACL,oBAAQ,YAAY,EAAE,IAAI;AAAA,UAC5B;AAEA;AAAA,QACF;AAGA,YAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,kBAAQ,YAAY,EAAE,IAAI;AAAA,QAC5B;AAAA,MACF;AAAA,IACF;AAEA,WAAO,eAAc,OAAO,OAAO,SAAS,OAAO;AAAA,EACrD;AAAA,EAEA,OAAc,QAAQ;AACpB,WAAO,eAAc,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AAAA,EACxC;AAAA,EAEO,UAAyB;AAC9B,UAAM,kBAAkB,CAAC,WAAkD;AACzE,YAAM,iBAAwD,CAAC;AAE/D,iBAAW,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAChD,uBAAe,EAAE,IAAI,MAAM,OAAO,MAAM,UAAU,MAAM,OAAO;AAAA,MACjE;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,QAAQ,gBAAgB,KAAK,KAAK;AACxC,UAAM,UAAU,gBAAgB,KAAK,OAAO;AAC5C,UAAM,UAAU,gBAAgB,KAAK,OAAO;AAG5C,WAAO,eAAc,OAAO,SAAS,OAAO,OAAO;AAAA,EACrD;AAAA,EAEO,UAAmB;AACxB,WACE,OAAO,KAAK,KAAK,KAAK,EAAE,WAAW,KACnC,OAAO,KAAK,KAAK,OAAO,EAAE,WAAW,KACrC,OAAO,KAAK,KAAK,OAAO,EAAE,WAAW;AAAA,EAEzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,mBACL,cACA,cACA,iBACe;AACf,UAAM,WACJ,CACE,aACA,gBAEF,CAAC,SAAyB,gBAAwC;AAChE,UAAI;AAEJ,cAAQ,aAAa;AAAA,QACnB,KAAK;AACH,oBAAU;AACV;AAAA,QACF,KAAK;AACH,oBAAU;AACV;AAAA,MACJ;AAGA,UAAI,CAAC,SAAS;AACZ,gBAAQ;AAAA,UACN;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAEA,YAAM,gBAA4C,CAAC;AAEnD,iBAAW,OAAO,OAAO,KAAK,OAAO,GAAkC;AAGrE,gBAAQ,KAAK;AAAA,UACX,KAAK;AACH,0BAAc,GAAG,IAAI,QAAQ,GAAG;AAChC;AAAA,UACF;AACE,0BAAc,GAAG,IAAI,QAAQ,GAAG;AAAA,QACpC;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEF,UAAM,6BAA6B,CACjC,WACG;AACH,YAAM,iBAAwD,CAAC;AAE/D,iBAAW,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AAChD,cAAM,cAAc,aAAa,IAAI,EAAE;AACvC,cAAM,cAAc,aAAa,IAAI,EAAE;AAEvC,YAAI,cAA4C;AAEhD,YAAI,eAAe,aAAa;AAC9B,wBAAc,MAAM;AAAA,YAClB,MAAM;AAAA,YACN,MAAM;AAAA,YACN,SAAS,aAAa,WAAW;AAAA,YACjC;AAAA,UACF;AAAA,QACF,OAAO;AACL,wBAAc;AAAA,QAChB;AAGA,YAAI,MAAM,iBAAiB,YAAY,SAAS,YAAY,QAAQ,GAAG;AACrE,yBAAe,EAAE,IAAI;AAAA,QACvB;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,QAAQ,2BAA2B,KAAK,KAAK;AACnD,UAAM,UAAU,2BAA2B,KAAK,OAAO;AACvD,UAAM,UAAU,2BAA2B,KAAK,OAAO;AAEvD,WAAO,eAAc,OAAO,OAAO,SAAS,SAAS;AAAA,MACnD,oBAAoB;AAAA;AAAA,IACtB,CAAC;AAAA,EACH;AAAA,EAEO,QACL,UACA,WAAsC,cAAc,MAAM,EAAE,UAC5D,UAA0B;AAAA,IACxB,oBAAoB,oBAAI,IAAI;AAAA,EAC9B,GAC6B;AAC7B,QAAI,eAAe,IAAI,IAAI,QAAQ;AACnC,QAAI;AAEJ,UAAM,QAAsB;AAAA,MAC1B,2BAA2B;AAAA,MAC3B,0BAA0B;AAAA,IAC5B;AAGA,QAAI;AACF,YAAM,cAAc,eAAc;AAAA,QAChC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,YAAM,gBAAgB,YAAY,KAAK,KAAK;AAC5C,YAAM,kBAAkB,YAAY,KAAK,OAAO;AAChD,YAAM,kBAAkB,YAAY,KAAK,OAAO;AAEhD,YAAM,mBAAmB,KAAK,iBAAiB,UAAU,YAAY;AAGrE,wBAAkB,IAAI,IAAI;AAAA,QACxB,GAAG;AAAA,QACH,GAAG;AAAA,QACH,GAAG;AAAA,QACH,GAAG;AAAA,MACL,CAAC;AAAA,IACH,SAAS,GAAG;AACV,cAAQ,MAAM,iCAAiC,CAAC;AAEhD,UAAIH,WAAU,KAAKC,UAAS,GAAG;AAC7B,cAAM;AAAA,MACR;AAMA,aAAO,CAAC,UAAU,IAAI;AAAA,IACxB;AAEA,QAAI;AAGF,qBAAe,eAAc;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAKA,YAAM,YAAY,IAAI,MAAM,YAAY;AAExC,qBAAc,wBAAwB,WAAW,eAAe;AAEhE,qBAAc,kBAAkB,WAAW,eAAe;AAAA,IAC5D,SAAS,GAAG;AACV,cAAQ;AAAA,QACN;AAAA,QACA;AAAA,MACF;AAEA,UAAID,WAAU,KAAKC,UAAS,GAAG;AAC7B,cAAM;AAAA,MACR;AAAA,IACF,UAAE;AACA,aAAO,CAAC,cAAc,MAAM,yBAAyB;AAAA,IACvD;AAAA,EACF;AAAA,EAEA,OAAe,gBACb,CACE,cACA,UACA,SACA,UAEF,CAAC,WAAkD;AACjD,UAAM,aAAa,eAAc;AAAA,MAC/B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,WAAO,OAAO,QAAQ,MAAM,EAAE,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,MAAM;AACzD,YAAM,UAAU,WAAW,IAAI,MAAM,QAAQ;AAE7C,UAAI,SAAS;AACX,cAAMG,cAAa,eAAc;AAAA,UAC/B;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAEA,qBAAa,IAAIA,YAAW,IAAIA,WAAU;AAC1C,YAAI,IAAIA,YAAW,IAAIA,WAAU;AAAA,MACnC;AAEA,aAAO;AAAA,IACT,GAAG,oBAAI,IAAsC,CAAC;AAAA,EAChD;AAAA,EAEF,OAAe,eACb,CACE,UACA,UACA,UAEF,CAAC,IAAY,YAA4B;AACvC,QAAI,UAAU,SAAS,IAAI,EAAE;AAE7B,QAAI,CAAC,SAAS;AAEZ,gBAAU,SAAS,IAAI,EAAE;AAEzB,UAAI,SAAS;AAEX,cAAM,2BAA2B;AAGjC,YAAI,CAAC,QAAQ,aAAc,QAAQ,aAAa,CAAC,QAAQ,WAAY;AACnE,gBAAM,4BAA4B;AAAA,QACpC;AAAA,MACF,OAAO;AAEL,kBAAU;AAAA,UACR,EAAE,IAAI,SAAS,EAAE;AAAA,UACjB;AAAA,YACE,GAAG;AAAA,UACL;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEF,OAAe,WACb,SACA,OACA,SACA,OACA;AACA,UAAM,4BAAqD,CAAC;AAK5D,eAAW,OAAO,OAAO,KAAK,MAAM,QAAQ,GAEzC;AACD,UAAI,QAAQ,iBAAiB;AAC3B;AAAA,MACF;AAEA,UAAI,QAAQ,mBAAmB,IAAI,GAAG,GAAG;AACvC;AAAA,MACF;AAEA,YAAM,QAAQ,MAAM,SAAS,GAAG;AAChC,cAAQ,IAAI,2BAA2B,KAAK,KAAK;AAAA,IACnD;AAEA,QACE,MAAM,QAAQ,eAAe,UAC7B,MAAM,SAAS,eAAe,QAC9B;AACA,YAAM,sBAAsB,MAAM;AAAA,QAChC,QAAQ;AAAA,QACR,MAAM,SAAS;AAAA,QACf,MAAM,QAAQ;AAAA,QACd,CAAC,MAAM,EAAE;AAAA,MACX;AAEA,aAAO,OAAO,2BAA2B;AAAA,QACvC,eAAe;AAAA,MACjB,CAAC;AAAA,IACH;AAEA,QAAI,CAAC,MAAM,2BAA2B;AAEpC,YAAM,EAAE,OAAO,GAAG,KAAK,IAAI;AAC3B,YAAM,4BAA4B,eAAc;AAAA,QAC9C;AAAA,QACA;AAAA,MACF;AAEA,YAAM,4BAA4B;AAAA,IACpC;AAEA,QAAI,CAAC,MAAM,0BAA0B;AACnC,YAAM,2BACJ,MAAM,QAAQ,UAAU,MAAM,SAAS;AAAA,IAC3C;AAEA,WAAO,eAAe,SAAS,yBAAyB;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKA,OAAe,0BACb,SACA,SACA;AACA,QAAI,QAAQ,aAAa,QAAQ,cAAc,OAAO;AAEpD,aAAO;AAAA,IACT;AAEA,QAAI,QAAQ,aAAa,QAAQ,cAAc,OAAO;AAEpD,aAAO;AAAA,IACT;AAEA,QAAI,QAAQ,cAAc,SAAS,QAAQ,WAAW;AAEpD,aAAO;AAAA,IACT;AAGA,WAAO,MAAM,iBAAiB,SAAS,OAAO;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUQ,iBACN,cACA,cACA;AACA,UAAM,uBAAuB,oBAAI,IAAsC;AACvE,UAAM,UAAU,CACd,SACA,YACG;AACH,YAAM,cAAc,aAAa,IAAI,QAAQ,EAAE;AAC/C,UAAI,CAAC,aAAa;AAChB;AAAA,MACF;AAEA,UAAI;AAEJ,UAAI,aAAa,IAAI,QAAQ,EAAE,MAAM,aAAa;AAGhD,0BAAkB;AAAA,UAChB;AAAA,UACA;AAAA,QACF;AAAA,MACF,OAAO;AACL,0BAAkB;AAAA,UAChB;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,2BAAqB,IAAI,gBAAgB,IAAI,eAAe;AAC5D,mBAAa,IAAI,gBAAgB,IAAI,eAAe;AAAA,IACtD;AAGA,eAAW,MAAM,OAAO,KAAK,KAAK,OAAO,GAAG;AAC1C,qBAAc,eAAe,cAAc,cAAc,IAAI,OAAO;AAAA,IACtE;AAGA,eAAW,MAAM,OAAO,KAAK,KAAK,KAAK,GAAG;AACxC,qBAAc,eAAe,cAAc,cAAc,IAAI,OAAO;AAAA,IACtE;AAGA,eAAW,CAAC,EAAE,KAAK,MAAM,KAAK,OAAO,QAAQ,KAAK,OAAO,CAAC,EAAE;AAAA,MAC1D,CAAC,CAAC,GAAG,KAAK,MACR,OAAO,KAAK,EAAE,GAAG,MAAM,SAAS,GAAG,MAAM,SAAS,CAAC,EAAE;AAAA,QAAK,CAAC,SACzD,kBAAkB,IAAI,IAAkC;AAAA,MAC1D;AAAA,IACJ,GAAG;AACD,YAAM,iBAAiB,aAAa,IAAI,EAAE;AAC1C,UAAI,CAAC,kBAAkB,eAAe,WAAW;AAE/C;AAAA,MACF;AAEA,qBAAc,eAAe,cAAc,cAAc,IAAI,OAAO;AAAA,IACtE;AAGA,UAAM,uBAAuB,IAAI;AAAA,MAC/B,MAAM,KAAK,YAAY,EAAE,OAAO,CAAC,CAAC,EAAE,MAAM,qBAAqB,IAAI,EAAE,CAAC;AAAA,IACxE;AAIA,UAAM,EAAE,OAAO,SAAS,QAAQ,IAAI,eAAc;AAAA,MAChD;AAAA,MACA;AAAA,IACF;AAEA,eAAW,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC/C,WAAK,MAAM,EAAE,IAAI;AAAA,IACnB;AAEA,eAAW,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,OAAO,GAAG;AACjD,WAAK,QAAQ,EAAE,IAAI;AAAA,IACrB;AAEA,eAAW,CAAC,IAAI,KAAK,KAAK,OAAO,QAAQ,OAAO,GAAG;AACjD,WAAK,QAAQ,EAAE,IAAI;AAAA,IACrB;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAe,eACb,cACA,cACA,IACA,SAIA;AAEA,UAAM,cAAc,MAAM,aAAa,IAAI,EAAE;AAC7C,UAAM,cAAc,MAAM,aAAa,IAAI,EAAE;AAE7C,iBAAa,eAAe,cAAc,YAAY,GAAG,OAAO;AAChE,iBAAa,eAAe,cAAc,YAAY,GAAG,OAAO;AAEhE,oBAAgB,eAAe,cAAc,YAAY,GAAG,OAAO;AACnE,oBAAgB,eAAe,cAAc,YAAY,GAAG,OAAO;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAe,eACb,cACA,cACA,IACA,SAIA;AAEA,UAAM,cAAc,MAAM,aAAa,IAAI,EAAE;AAC7C,UAAM,cAAc,MAAM,aAAa,IAAI,EAAE;AAE7C,iBAAa,eAAe,cAAc,YAAY,GAAG,OAAO;AAChE,iBAAa,eAAe,cAAc,YAAY,GAAG,OAAO;AAEhE,oBAAgB;AAAA,MACd;AAAA,MACA,YAAY;AAAA,MACZ,CAAC,SAAS,YAAY;AAGpB,YAAI,cAAc,OAAO,GAAG;AAC1B,kBAAQ,SAAS,OAAO;AAAA,QAC1B;AAAA,MACF;AAAA,IACF;AACA,oBAAgB,eAAe,cAAc,YAAY,GAAG,OAAO;AAAA,EACrE;AAAA,EAEA,OAAe,wBACb,OACA,SACA;AACA,UAAM,WAAW,MAAM,yBAAyB;AAChD,UAAM,gBAAgB,oBAAI,IAGxB;AAEF,eAAW,WAAW,QAAQ,OAAO,GAAG;AACtC,UAAI,mBAAmB,OAAO,GAAG;AAC/B,cAAM,EAAE,YAAY,IAAI;AACxB,cAAM,YAAY,cAAc,SAAS,IAAI,WAAW,IAAI;AAE5D,YAAI,WAAW;AACb,wBAAc,IAAI,UAAU,IAAI;AAAA,YAC9B;AAAA,YACA,WAAW;AAAA,UACb,CAAC;AAAA,QACH;AAAA,MACF;AAEA,UAAI,oBAAoB,OAAO,GAAG;AAChC,cAAM,qBAAqB,sBAAsB,OAAO;AACxD,cAAM,YAAY,qBACd,SAAS,IAAI,kBAAkB,IAC/B;AAEJ,YAAI,WAAW;AACb,wBAAc,IAAI,QAAQ,IAAI;AAAA,YAC5B,WAAW;AAAA,YACX;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAEA,eAAW,EAAE,WAAW,UAAU,KAAK,cAAc,OAAO,GAAG;AAC7D,UAAI,UAAU,aAAa,UAAU,WAAW;AAE9C;AAAA,MACF;AAEA,4BAAsB,WAAW,WAAW,KAAK;AAAA,IACnD;AAAA,EACF;AAAA,EAEA,OAAe,kBACb,OACA,SACA;AACA,eAAW,WAAW,QAAQ,OAAO,GAAG;AACtC,UAAI,CAAC,QAAQ,aAAa,kBAAkB,OAAO,GAAG;AACpD,4BAAoB,SAAS,OAAO;AAAA,UAClC,iBAAiB;AAAA,QACnB,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAe,gBACb,UACA,SACA,OAIA;AACA,QAAI,CAAC,MAAM,0BAA0B;AACnC,aAAO;AAAA,IACT;AAEA,UAAM,YAAY,MAAM,KAAK,SAAS,OAAO,CAAC;AAC9C,UAAM,UAAU,uBAAuB,CAAC,GAAG,SAAS,CAAC;AACrD,UAAM,QAAQ,MAAM,oBAAoB,WAAW,SAAS,IAAI,EAAE;AAAA,MAChE,CAAC,KAAK,eAAe;AACnB,cAAM,YAAY,UAAU,OAAO,UAAU,CAAC;AAC9C,YAAI,aAAa,QAAQ,IAAI,UAAU,EAAE,GAAG;AAC1C,cAAI,IAAI,UAAU,IAAI,SAAS;AAAA,QACjC;AAEA,eAAO;AAAA,MACT;AAAA,MACA,oBAAI,IAAI;AAAA,IACV;AAEA,QAAI,CAAC,MAAM,6BAA6B,MAAM,MAAM;AAElD,YAAM,4BAA4B;AAAA,IACpC;AAIA,WAAOC,aAAW,iBAAiB,SAAS,KAAK,CAAC;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAe,YACb,SACA,UACkC;AAClC,QAAI;AACF,YAAM,WAAW,SAAS,UAAU,iBAAiB,CAAC,MAAM,EAAE,EAAE;AAKhE,YAAM,gBAEF,QAGA,UAAU,CAAC;AAEf,YAAM,iBAEF,SAGA,UAAU,CAAC;AAEf,UAAI,CAAC,MAAM,YAAY,eAAe,cAAc,GAAG;AAErD,gBAAQ,eAAe,SAAS,QAAQ;AACxC,gBAAQ,eAAe,UAAU,QAAQ;AAAA,MAC3C;AAAA,IACF,SAAS,GAAG;AAEV,cAAQ,MAAM,sCAAsC;AAEpD,UAAIL,WAAU,KAAKC,UAAS,GAAG;AAC7B,cAAM;AAAA,MACR;AAAA,IACF,UAAE;AACA,aAAO,CAAC,SAAS,QAAQ;AAAA,IAC3B;AAAA,EACF;AAAA,EAEA,OAAe,qBACb,SACgB;AAChB,UAAM,EAAE,IAAI,SAAS,GAAG,gBAAgB,IAAI;AAE5C,WAAO;AAAA,EACT;AACF;;;AOhzDA;AAYO,IAAM,qBAAqB,CAChC,kBACA,aACA,iBACwB;AACxB,QAAM,CAAC,OAAO,KAAK,KAAK,MAAM,IAC5B,aAAa,SAAS,MACjB,CAAC,QAAQ,QAAQ,QAAQ,OAAO,IAChC,CAAC,QAAQ,QAAQ,QAAQ,QAAQ;AAExC,QAAM,SAAS,qBAAqB,gBAAgB;AACpD,QAAM,SAAS,iBAAiB,kBAAkB,WAAW,EAC1D,IAAI,CAAC,UAAU,CAAC,OAAO,qBAAqB,KAAK,CAAC,CAAU,EAC5D,KAAK,CAACK,IAAGC,OAAMD,GAAE,CAAC,EAAE,GAAG,IAAIC,GAAE,CAAC,EAAE,GAAG,CAAC;AAEvC,MAAI,OAAO;AACX,aAAW,SAAS,QAAQ;AAC1B,YAAQ,MAAM,CAAC,EAAE,MAAM;AAAA,EACzB;AAEA,QAAM,QAAQ,OAAO,MAAM,IAAI,SAAS,OAAO,SAAS;AAExD,MAAI,OAAO,GAAG;AAKZ,UAAM,SAAS,OAAO,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,KAAK,MAAM,OAAO,KAAK,CAAC;AACpE,UAAM,SAAS,OAAO,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,GAAG,MAAM,OAAO,GAAG,CAAC;AAIhE,UAAMC,SACH,OAAO,MAAM,EAAE,CAAC,EAAE,GAAG,IAAI,OAAO,MAAM,EAAE,CAAC,EAAE,GAAG,MAAM,OAAO,SAAS;AAEvE,QAAIC,OAAM,OAAO,MAAM,EAAE,CAAC,EAAE,GAAG;AAE/B,WAAO,OAAO,QAAQ,CAAC,CAAC,OAAO,GAAG,GAAG,UAAU;AAC7C,YAAM,cAAc;AAAA,QAClB,GAAG;AAAA,QACH,GAAG;AAAA,MACL;AAGA,UAAI,UAAU,UAAU,UAAU,QAAQ;AACxC,QAAAA,QAAOD;AACP,oBAAY,aAAa,IAAI,IAAIC,OAAM,IAAI,GAAG;AAAA,MAChD;AAEA,aAAO,MAAM;AAAA,QAAI,CAAC,YAChB,eAAe,SAAS;AAAA,UACtB,GAAG,QAAQ,IAAI,YAAY;AAAA,UAC3B,GAAG,QAAQ,IAAI,YAAY;AAAA,QAC7B,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AAIA,MAAI,MAAM,OAAO,KAAK;AAEtB,SAAO,OAAO,QAAQ,CAAC,CAAC,OAAO,GAAG,MAAM;AACtC,UAAM,cAAc;AAAA,MAClB,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAEA,gBAAY,aAAa,IAAI,IAAI,MAAM,IAAI,KAAK;AAEhD,WAAO;AACP,WAAO,IAAI,MAAM;AAEjB,WAAO,MAAM;AAAA,MAAI,CAAC,YAChB,eAAe,SAAS;AAAA,QACtB,GAAG,QAAQ,IAAI,YAAY;AAAA,QAC3B,GAAG,QAAQ,IAAI,YAAY;AAAA,MAC7B,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH;;;AC5FA;AAAA;AAAA,EACE;AAAA,EACA,gBAAAC;AAAA,EACA,iBAAAC;AAAA,OACK;AA6BA,IAAM,uBAAuB,CAClC,kBACA,mBACA,QACA,OACA,YAIA,aACG;AACH,MACE,kBAAkB,WAAW,KAC7B,aAAa,kBAAkB,CAAC,CAAC,MAChC,kBAAkB,CAAC,EAAE,gBAAgB,kBAAkB,CAAC,EAAE,aAC3D;AACA;AAAA,EACF;AAEA,QAAM,mBAAmB,kBAAkB,OAAO,CAAC,YAAY;AAC7D,QAAI,aAAa,OAAO,KAAK,QAAQ,gBAAgB,QAAQ,YAAY;AACvE,YAAM,eAAe,kBAAkB;AAAA,QACrC,CAAC,OAAO,GAAG,OAAO,QAAQ,cAAc;AAAA,MAC1C;AACA,YAAM,aAAa,kBAAkB;AAAA,QACnC,CAAC,OAAO,GAAG,OAAO,QAAQ,YAAY;AAAA,MACxC;AAEA,aAAO,gBAAgB;AAAA,IACzB;AAEA,WAAO;AAAA,EACT,CAAC;AAKD,QAAM,mBAAmB,IAAI;AAAA,IAC3B;AAAA,EACF;AACA,QAAM,SAAS,iBACZ,OAAO,CAAC,MAAM,mBAAmB,CAAC,CAAC,EACnC,IAAI,CAAC,MAAM,EAAE,EAAE;AAElB,MAAI,OAAO,SAAS,GAAG;AACrB,eAAW,WAAW,MAAM,sBAAsB,GAAG;AACnD,UAAI,QAAQ,YAAY,QAAQ,OAAO,SAAS,QAAQ,OAAO,GAAG;AAChE,yBAAiB,IAAI,OAAO;AAAA,MAC9B;AAAA,IACF;AAAA,EACF;AAEA,QAAM,eAAoC,CAAC;AAE3C,aAAW,WAAW,kBAAkB;AACtC,UAAM,cAAc,iBAAiB,iBAAiB,IAAI,QAAQ,EAAE;AAGpE,QAAI,CAAC,aAAa;AAChB;AAAA,IACF;AACA,iBAAa,KAAK,WAAW;AAAA,EAC/B;AAEA,QAAM,iBAAiB;AAAA,IACrB,gBAAgB,YAAY;AAAA,IAC5B;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,mBAAiB,QAAQ,CAAC,YAAY;AACpC,wBAAoB,kBAAkB,SAAS,OAAO,cAAc;AACpE,QAAI,CAAC,eAAe,OAAO,GAAG;AAE5B,YAAM,cAAc;AAAA,QAClB;AAAA,QACA,MAAM,yBAAyB;AAAA,MACjC;AACA,UAAI,aAAa;AACf;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,0BAAoB,SAAS,OAAO;AAAA,QAClC,uBAAuB,MAAM,KAAK,gBAAgB;AAAA,MACpD,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH;AAEA,IAAM,kBAAkB,CACtB,cACA,YACA,YACA,aAC6B;AAC7B,QAAM,CAAC,GAAG,CAAC,IAAI;AACf,MAAI,QAAQ,IAAI,WAAW,IAAI,WAAW;AAC1C,MAAI,QAAQ,IAAI,WAAW,IAAI,WAAW;AAE1C,MAAI,WAAW,MAAM,KAAK,WAAW,MAAM,GAAG;AAC5C,UAAM,CAAC,WAAW,SAAS,IAAIC;AAAA,MAC7B,IAAI,WAAW;AAAA,MACf,IAAI,WAAW;AAAA,MACf;AAAA,IACF;AAEA,QAAI,WAAW,MAAM,GAAG;AACtB,cAAQ;AAAA,IACV;AAEA,QAAI,WAAW,MAAM,GAAG;AACtB,cAAQ;AAAA,IACV;AAAA,EACF;AACA,SAAO;AAAA,IACL,GAAG,QAAQ;AAAA,IACX,GAAG,QAAQ;AAAA,EACb;AACF;AAEA,IAAM,sBAAsB,CAC1B,kBACA,SACA,OACA,eACG;AACH,QAAM,kBACJ,iBAAiB,iBAAiB,IAAI,QAAQ,EAAE,KAAK;AAEvD,QAAM,QAAQ,gBAAgB,IAAI,WAAW;AAC7C,QAAM,QAAQ,gBAAgB,IAAI,WAAW;AAE7C,QAAM,cAAc,SAAS;AAAA,IAC3B,GAAG;AAAA,IACH,GAAG;AAAA,EACL,CAAC;AACH;AAEO,IAAM,kBAAkB,CAC7B,kBACA,GACA,MACqB;AACrB,QAAM,CAAC,IAAI,EAAE,IAAI,gBAAgB,gBAAgB;AACjD,SAAO,CAAC,IAAI,IAAI,IAAI,EAAE;AACxB;AAEO,IAAM,iBAAiB,CAAC;AAAA,EAC7B,YAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,mBAAmB;AAAA,EACnB,eAAe;AAAA,EACf,iBAAiB;AACnB,MAqBM;AACJ,MAAI,6BAA6BA,YAAW,SAAS,aAAa;AAChE,QAAI,kBAAkB;AACpB,eAAS,QAAQ;AAAA,IACnB,OAAO;AAIL,UAAI,KAAK,IAAI,IAAI,OAAO,IAAI,KAAK,IAAI,IAAI,OAAO,GAAG;AACjD,SAAC,EAAE,OAAO,OAAO,IAAI;AAAA,UACnB;AAAA,UACA;AAAA,UACA,IAAI,UAAU,CAAC,QAAQ;AAAA,QACzB;AAAA,MACF,OAAO;AACL,SAAC,EAAE,OAAO,OAAO,IAAI;AAAA,UACnB;AAAA,UACA;AAAA,UACA,IAAI,UAAU,CAAC,SAAS;AAAA,QAC1B;AAAA,MACF;AAEA,UAAI,SAAS,GAAG;AACd,iBAAS,CAAC;AAAA,MACZ;AAAA,IACF;AAAA,EACF;AAEA,MAAI,OAAO,IAAI,UAAU,UAAU,QAAQ;AAC3C,MAAI,OAAO,IAAI,UAAU,UAAU,SAAS;AAE5C,MAAI,wBAAwB;AAC1B,aAAS;AACT,cAAU;AACV,WAAO,UAAU,QAAQ;AACzB,WAAO,UAAU,SAAS;AAAA,EAC5B;AAEA,MAAI,iBAAiB;AAErB,MAAI,cAAcA,WAAU,GAAG;AAC7B,aAASA,YAAW;AACpB,UAAM,WAAW;AAAA,MACfC,eAAc;AAAA,QACZ,UAAUD,YAAW;AAAA,QACrB,YAAYA,YAAW;AAAA,MACzB,CAAC;AAAA,MACDA,YAAW;AAAA,IACb;AACA,YAAQ,KAAK,IAAI,OAAO,QAAQ;AAEhC,QAAI,KAAK,IAAI,IAAI,OAAO,IAAI,0BAA0B,MAAM;AAC1D,uBAAiB;AAAA,QACf,YAAY;AAAA,MACd;AAAA,IACF;AAEA,WAAO;AACP,QAAI,wBAAwB;AAC1B,aAAO,UAAU,QAAQ;AAAA,IAC3B;AAAA,EACF;AAEA,MAAI,UAAU,KAAK,WAAW,GAAG;AAC/B,QAAI,wBAAwB;AAC5B,QAAI,eAAeA,WAAU,GAAG;AAC9B,8BAAwB;AAAA,QACtB,cAAc;AAAA,QACd,eAAe;AAAA,MACjB;AAAA,IACF;AAEA,UAAM;AAAA,MACJA;AAAA,MACA;AAAA,QACE,GAAG,QAAQ,cAAc,KAAK;AAAA,QAC9B,GAAG,QAAQ,cAAc,KAAK;AAAA,QAC9B;AAAA,QACA;AAAA,QACA,GAAG;AAAA,QACH,GAAG;AAAA,MACL;AAAA,MACA,EAAE,gBAAgB,YAAY,MAAM;AAAA,IACtC;AAAA,EACF;AACF;;;ACnTA;AAIA,SAAS,kBAAkB,qBAAqB;AAQzC,IAAM,qCAGT,CAAC,IAAI,SAAS;AAChB,QAAM,MAAM,OAAO,SAAS;AAE5B,MAAI;AACF,UAAM,OAAO,IAAI,IAAI,GAAG;AACxB,SAAK,aAAa,IAAI,kBAAkB,EAAE;AAE1C,WAAO,cAAc,KAAK,SAAS,CAAC;AAAA,EACtC,SAAS,OAAO;AACd,YAAQ,MAAM,KAAK;AAAA,EACrB;AAEA,SAAO,cAAc,GAAG;AAC1B;AAEO,IAAM,gCAAgC,CAC3C,kBACA,aAIU;AACV,MACE,iBAAiB,SAAS,KAC1B,0BAA0B,gBAAgB,GAC1C;AACA,QAAI,iBAAiB,WAAW,GAAG;AACjC,aAAO;AAAA,QACL,IAAI,iBAAiB,CAAC,EAAE;AAAA,QACxB,MAAM;AAAA,MACR;AAAA,IACF;AAEA,QAAI,iBAAiB,SAAS,GAAG;AAC/B,YAAM,kBAAkB,OAAO,KAAK,SAAS,gBAAgB,EAAE,CAAC;AAEhE,UAAI,iBAAiB;AACnB,eAAO;AAAA,UACL,IAAI;AAAA,UACJ,MAAM;AAAA,QACR;AAAA,MACF;AACA,aAAO;AAAA,QACL,IAAI,iBAAiB,CAAC,EAAE,SAAS,CAAC;AAAA,QAClC,MAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,4BAA4B,CACvC,qBACG;AACH,MAAI,iBAAiB,WAAW,GAAG;AACjC,WAAO;AAAA,EACT;AAEA,MAAI,iBAAiB,SAAS,KAAK,uBAAuB,gBAAgB,GAAG;AAC3E,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,IAAM,gBAAgB,CAAC,QAAgB;AAC5C,MAAI;AACF,UAAM,OAAO,IAAI,IAAI,GAAG;AACxB,WACE,KAAK,aAAa,IAAI,gBAAgB,KACtC,KAAK,SAAS,OAAO,SAAS;AAAA,EAElC,SAAS,OAAO;AACd,WAAO;AAAA,EACT;AACF;AAEO,IAAM,0BAA0B,CAAC,QAAgB;AACtD,MAAI;AACF,UAAM,EAAE,aAAa,IAAI,IAAI,IAAI,GAAG;AACpC,QAAI,aAAa,IAAI,gBAAgB,GAAG;AACtC,YAAM,KAAK,aAAa,IAAI,gBAAgB;AAC5C,aAAO;AAAA,IACT;AAAA,EACF,QAAQ;AAAA,EAAC;AAET,SAAO;AACT;;;ACvGA;AAAA;AAAA,EACE;AAAA,EACA,kBAAAE;AAAA,EACA;AAAA,EACA,iBAAAC;AAAA,OACK;;;ACLP;AAAA;AAAA,EACE;AAAA,EACA,uBAAAC;AAAA,EACA,qBAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA,kBAAAC;AAAA,EACA,iBAAAC;AAAA,EACA,YAAAC;AAAA,EACA,iBAAAC;AAAA,EACA,uBAAAC;AAAA,EACA;AAAA,OACK;AAiEP,IAAM,kBAAkB,CACtB,MACA;AAAA,EACE;AAAA,EACA;AAAA,EACA,cAAc,sBAAsB;AAAA,EACpC,kBAAkB,sBAAsB;AAAA,EACxC,YAAY,sBAAsB;AAAA,EAClC,cAAc,sBAAsB;AAAA,EACpC,cAAc,sBAAsB;AAAA,EACpC,YAAY,sBAAsB;AAAA,EAClC,UAAU,sBAAsB;AAAA,EAChC,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,WAAW,CAAC;AAAA,EACZ,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,YAAY;AAAA,EACZ,gBAAgB;AAAA,EAChB,OAAO;AAAA,EACP,SAAS,sBAAsB;AAAA,EAC/B,GAAG;AACL,MACG;AAGH,MACE,IAAI,QACJ,IAAI,OACJ,IAAI,QACJ,IAAI,OACJ,QAAQ,QACR,QAAQ,OACR,SAAS,QACT,SAAS,KACT;AACA,YAAQ,MAAM,6CAA6C;AAAA,MACzD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAEA,QAAQ,KAAK;AAAA,IACf,CAAC;AAAA,EACH;AAGA,QAAM,UAAgE;AAAA,IACpE,IAAI,KAAK,MAAMC,UAAS;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM,KAAK,QAAQC,eAAc;AAAA,IACjC,SAAS,KAAK,WAAW;AAAA,IACzB,cAAc,KAAK,gBAAgB;AAAA,IACnC,WAAW;AAAA,IACX;AAAA,IACA,SAASC,qBAAoB;AAAA,IAC7B;AAAA,IACA;AAAA,IACA,YAAY,KAAK;AAAA,EACnB;AACA,SAAO;AACT;AAEO,IAAM,aAAa,CACxB,SAIA,gBAA0C,KAAK,MAAM,IAAI;AAEpD,IAAM,uBAAuB,CAClC,SAG4C;AAC5C,SAAO,gBAA6C,cAAc,IAAI;AACxE;AAEO,IAAM,mBAAmB,CAC9B,SAGwC;AACxC,SAAO;AAAA,IACL,GAAG,gBAAyC,UAAU,IAAI;AAAA,EAC5D;AACF;AAEO,IAAM,kBAAkB,CAC7B,SAGuC;AACvC,QAAM,eAAe;AAAA,IACnB;AAAA,MACE,GAAG,gBAAwC,SAAS,IAAI;AAAA,MACxD,MAAM;AAAA,MACN,MAAM,MAAM,QAAQ;AAAA,IACtB;AAAA,IACA,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEO,IAAM,uBAAuB,CAClC,SAG4C;AAC5C,QAAM,eAAe;AAAA,IACnB;AAAA,MACE,GAAG,gBAA6C,cAAc,IAAI;AAAA,MAClE,MAAM;AAAA,MACN,MAAM,MAAM,QAAQ;AAAA,IACtB;AAAA,IACA,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAGA,IAAM,gCAAgC,CACpC,MAIA,YAIG;AACH,SAAO;AAAA,IACL,GACE,KAAK,cAAc,WACf,QAAQ,QAAQ,IAChB,KAAK,cAAc,UACnB,QAAQ,QACR;AAAA,IACN,GAAG,KAAK,kBAAkB,WAAW,QAAQ,SAAS,IAAI;AAAA,EAC5D;AACF;AAEO,IAAM,iBAAiB,CAC5B,SAWsC;AACtC,QAAM,aAAa,KAAK,cAAcC;AACtC,QAAM,WAAW,KAAK,YAAYC;AAClC,QAAM,aAAa,KAAK,cAAc,cAAc,UAAU;AAC9D,QAAM,OAAO,cAAc,KAAK,IAAI;AACpC,QAAM,UAAU;AAAA,IACd;AAAA,IACAC,eAAc,EAAE,YAAY,SAAS,CAAC;AAAA,IACtC;AAAA,EACF;AACA,QAAM,YAAY,KAAK,aAAa;AACpC,QAAM,gBAAgB,KAAK,iBAAiB;AAC5C,QAAM,UAAU;AAAA,IACd,EAAE,WAAW,cAAc;AAAA,IAC3B;AAAA,EACF;AAEA,QAAM,mBAA0C;AAAA,IAC9C,GAAG,gBAAuC,QAAQ,IAAI;AAAA,IACtD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG,KAAK,IAAI,QAAQ;AAAA,IACpB,GAAG,KAAK,IAAI,QAAQ;AAAA,IACpB,OAAO,QAAQ;AAAA,IACf,QAAQ,QAAQ;AAAA,IAChB,aAAa,KAAK,eAAe;AAAA,IACjC,cAAc,KAAK,gBAAgB;AAAA,IACnC,YAAY,KAAK,cAAc;AAAA,IAC/B;AAAA,EACF;AAEA,QAAM,cAAqC;AAAA,IACzC;AAAA,IACA,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEA,IAAM,wBAAwB,CAC5B,SACA,aACA,aAMG;AACH,MAAI,EAAE,OAAO,WAAW,QAAQ,WAAW,IAAI;AAAA,IAC7C;AAAA,IACAA,eAAc,OAAO;AAAA,IACrB,QAAQ;AAAA,EACV;AAGA,MAAI,CAAC,QAAQ,YAAY;AACvB,gBAAY,QAAQ;AAAA,EACtB;AAEA,QAAM,EAAE,WAAW,cAAc,IAAI;AACrC,MAAI;AACJ,MAAI;AACJ,MACE,cAAc,YACd,kBAAkBC,gBAAe,UACjC,CAAC,QAAQ,eACT,QAAQ,YACR;AACA,UAAM,cAAc;AAAA,MAClB,QAAQ;AAAA,MACRD,eAAc,OAAO;AAAA,MACrB,QAAQ;AAAA,IACV;AACA,UAAM,UAAU,8BAA8B,SAAS;AAAA,MACrD,OAAO,YAAY,YAAY;AAAA,MAC/B,QAAQ,aAAa,YAAY;AAAA,IACnC,CAAC;AAED,QAAI,QAAQ,IAAI,QAAQ;AACxB,QAAI,QAAQ,IAAI,QAAQ;AAAA,EAC1B,OAAO;AACL,UAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAIE,0BAAyB,SAAS,WAAW;AAEtE,UAAM,CAAC,QAAQ,QAAQ,QAAQ,MAAM,IAAI;AAAA,MACvC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,UAAM,WAAW,KAAK,UAAU;AAChC,UAAM,WAAW,KAAK,UAAU;AAChC,UAAM,WAAW,KAAK,UAAU;AAChC,UAAM,WAAW,KAAK,UAAU;AAEhC,KAAC,GAAG,CAAC,IAAI;AAAA,MACP;AAAA,QACE,GAAG;AAAA,QACH,GAAG,cAAc,YAAY,cAAc;AAAA,QAC3C,GAAG,cAAc,YAAY,cAAc;AAAA,MAC7C;AAAA,MACA,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,GAAG,OAAO,SAAS,CAAC,IAAI,IAAI,QAAQ;AAAA,IACpC,GAAG,OAAO,SAAS,CAAC,IAAI,IAAI,QAAQ;AAAA,EACtC;AACF;AAEA,IAAM,uBAAuB,CAC3B,OAMA,GACA,GACA,OACA,SACA,SACA,SACA,YACqB;AACrB,QAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,QAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,MAAI,MAAM,KAAK,MAAM,GAAG;AACtB,SAAK,UAAU;AAAA,EACjB,WAAW,MAAM,GAAG;AAClB,SAAK,WAAW,IAAI;AACpB,SAAK,UAAU;AACf,SAAK,WAAW,IAAI;AACpB,SAAK,UAAU,CAAC;AAAA,EAClB,WAAW,MAAM,GAAG;AAClB,SAAK,WAAW,IAAI;AACpB,SAAK,UAAU,CAAC;AAChB,SAAK,WAAW,IAAI;AACpB,SAAK,UAAU;AAAA,EACjB;AAEA,MAAI,MAAM,KAAK,MAAM,GAAG;AACtB,SAAK,UAAU;AAAA,EACjB,WAAW,MAAM,GAAG;AAClB,SAAK,UAAU;AACf,SAAK,WAAW,IAAI;AACpB,SAAK,UAAU,CAAC;AAChB,SAAK,WAAW,IAAI;AAAA,EACtB,WAAW,MAAM,GAAG;AAClB,SAAK,UAAU,CAAC;AAChB,SAAK,WAAW,IAAI;AACpB,SAAK,UAAU;AACf,SAAK,WAAW,IAAI;AAAA,EACtB;AACA,SAAO,CAAC,GAAG,CAAC;AACd;AAEO,IAAM,wBAAwB,CACnC,aACA,WACA,aACA,OAAO,YAAY,SAChB;AACH,MAAI,YAAY,WAAW;AACzB;AAAA,EACF;AACA,MAAI,aAAa,CAAC,YAAY,YAAY;AACxC,WAAO;AAAA,MACL;AAAA,MACAF,eAAc,WAAW;AAAA,MACzB,YACI,qBAAqB,WAAW,WAAW,IAC3C,YAAY;AAAA,IAClB;AAAA,EACF;AACA,QAAM,aAAa,sBAAsB,aAAa,aAAa,IAAI;AACvE,SAAO,EAAE,MAAM,GAAG,WAAW;AAC/B;AAEO,IAAM,qBAAqB,CAChC,SAM0C;AAC1C,SAAO;AAAA,IACL,GAAG,gBAA2C,KAAK,MAAM,IAAI;AAAA,IAC7D,QAAQ,KAAK,UAAU,CAAC;AAAA,IACxB,WAAW,KAAK,aAAa,CAAC;AAAA,IAC9B,kBAAkB,KAAK;AAAA,IACvB,oBAAoB;AAAA,EACtB;AACF;AAEO,IAAM,mBAAmB,CAC9B,SAKwC;AACxC,QAAM,UAAU;AAAA,IACd,GAAG,gBAAyC,KAAK,MAAM,IAAI;AAAA,IAC3D,QAAQ,KAAK,UAAU,CAAC;AAAA,IACxB,oBAAoB;AAAA,IACpB,cAAc;AAAA,IACd,YAAY;AAAA,IACZ,gBAAgB;AAAA,IAChB,cAAc;AAAA,EAChB;AAEA,MAAI,cAAc,OAAO,GAAG;AAC1B,UAAM,cAAiD;AAAA,MACrD,GAAG;AAAA,MACH,SAAS,KAAK,WAAW;AAAA,IAC3B;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,IAAM,kBAAkB,CAC7B,SAUwC;AACxC,MAAI,KAAK,SAAS;AAChB,WAAO;AAAA,MACL,GAAG,gBAA6C,KAAK,MAAM,IAAI;AAAA,MAC/D,QAAQ,KAAK,UAAU,CAAC;AAAA,MACxB,oBAAoB;AAAA,MACpB,cAAc;AAAA,MACd,YAAY;AAAA,MACZ,gBAAgB,KAAK,kBAAkB;AAAA,MACvC,cAAc,KAAK,gBAAgB;AAAA,MACnC,SAAS;AAAA,MACT,eAAe,KAAK,iBAAiB,CAAC;AAAA,MACtC,gBAAgB;AAAA,MAChB,cAAc;AAAA,IAChB;AAAA,EACF;AAEA,SAAO;AAAA,IACL,GAAG,gBAAwC,KAAK,MAAM,IAAI;AAAA,IAC1D,QAAQ,KAAK,UAAU,CAAC;AAAA,IACxB,oBAAoB;AAAA,IACpB,cAAc;AAAA,IACd,YAAY;AAAA,IACZ,gBAAgB,KAAK,kBAAkB;AAAA,IACvC,cAAc,KAAK,gBAAgB;AAAA,IACnC,SAAS;AAAA,EACX;AAGF;AAEO,IAAM,kBAAkB,CAC7B,SAOuC;AACvC,SAAO;AAAA,IACL,GAAG,gBAAwC,SAAS,IAAI;AAAA;AAAA;AAAA,IAGxD,aAAa;AAAA,IACb,QAAQ,KAAK,UAAU;AAAA,IACvB,QAAQ,KAAK,UAAU;AAAA,IACvB,OAAO,KAAK,SAAS,CAAC,GAAG,CAAC;AAAA,IAC1B,MAAM,KAAK,QAAQ;AAAA,EACrB;AACF;;;AD9gBA,IAAM,oBAAoB,oBAAI,IAAmC;AAEjE,IAAM,aACJ;AAEF,IAAM,WACJ;AACF,IAAM,WAAW;AAEjB,IAAM,aAAa;AACnB,IAAM,mBACJ;AAEF,IAAM,aAAa;AAGnB,IAAM,aACJ;AACF,IAAM,mBACJ;AAEF,IAAM,aACJ;AAEF,IAAM,mBACJ;AAEF,IAAM,WACJ;AAEF,IAAM,YACJ;AAEF,IAAM,kBACJ;AAEF,IAAM,kBAAkB,oBAAI,IAAI;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAED,IAAM,oBAAoB,oBAAI,IAAI;AAAA,EAChC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AAEM,IAAM,eAAe,CAAC,SAAiB;AAC5C,SAAO,eAAe,IAAI;AAC5B;AAEO,IAAM,eAAe,CAC1B,SACiC;AACjC,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACT;AAEA,MAAI,kBAAkB,IAAI,IAAI,GAAG;AAC/B,WAAO,kBAAkB,IAAI,IAAI;AAAA,EACnC;AAEA,QAAM,eAAe;AAErB,QAAM,kBAAkB,kBAAkB;AAAA,IACxC,cAAc,MAAM,iBAAiB,KAAK;AAAA,EAC5C;AAEA,MAAI,OAA4B;AAChC,MAAI,cAAc,EAAE,GAAG,KAAK,GAAG,IAAI;AACnC,QAAM,SAAS,KAAK,MAAM,UAAU;AACpC,MAAI,SAAS,CAAC,GAAG;AACf,UAAM,OAAO,OAAO,CAAC,IAAI,UAAU,OAAO,CAAC,CAAC,KAAK;AACjD,UAAM,aAAa,KAAK,SAAS,QAAQ;AACzC,WAAO;AACP,YAAQ,OAAO,CAAC,GAAG;AAAA,MACjB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,eAAO,iCAAiC,OAAO,CAAC,CAAC,iBAAiB,IAAI;AACtE;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,eAAO,kDAAkD,OAAO,CAAC,CAAC,iBAAiB,IAAI;AACvF;AAAA,MACF;AACE,eAAO,iCAAiC,OAAO,CAAC,CAAC,iBAAiB,IAAI;AACtE;AAAA,IACJ;AACA,kBAAc,aAAa,EAAE,GAAG,KAAK,GAAG,IAAI,IAAI,EAAE,GAAG,KAAK,GAAG,IAAI;AACjE,sBAAkB,IAAI,cAAc;AAAA,MAClC;AAAA,MACA,eAAe;AAAA,MACf;AAAA,MACA,SAAS,EAAE,gBAAgB;AAAA,IAC7B,CAAC;AACD,WAAO;AAAA,MACL;AAAA,MACA,eAAe;AAAA,MACf;AAAA,MACA,SAAS,EAAE,gBAAgB;AAAA,IAC7B;AAAA,EACF;AAEA,QAAM,YAAY,KAAK,MAAM,QAAQ;AACrC,MAAI,YAAY,CAAC,GAAG;AAClB,UAAM,SAAS,YAAY,CAAC;AAC5B,UAAM,QAAQ,CAAC,QAAQ,KAAK,MAAM,IAC9B,IAAI,SAAS,2BAA2B,IACxC;AACJ,WAAO;AACP,WAAO,kCAAkC,MAAM;AAC/C,kBAAc,EAAE,GAAG,KAAK,GAAG,IAAI;AAG/B,sBAAkB,IAAI,cAAc;AAAA,MAClC;AAAA,MACA,eAAe;AAAA,MACf;AAAA,MACA,SAAS,EAAE,gBAAgB;AAAA,IAC7B,CAAC;AACD,WAAO;AAAA,MACL;AAAA,MACA,eAAe;AAAA,MACf;AAAA,MACA;AAAA,MACA,SAAS,EAAE,gBAAgB;AAAA,IAC7B;AAAA,EACF;AAEA,QAAM,YAAY,KAAK,MAAM,QAAQ;AACrC,MAAI,WAAW;AACb,WAAO;AACP,WAAO,oDAAoD;AAAA,MACzD;AAAA,IACF,CAAC;AACD,kBAAc,EAAE,GAAG,KAAK,GAAG,IAAI;AAC/B,sBAAkB,IAAI,cAAc;AAAA,MAClC;AAAA,MACA,eAAe;AAAA,MACf;AAAA,MACA,SAAS,EAAE,gBAAgB;AAAA,IAC7B,CAAC;AACD,WAAO;AAAA,MACL;AAAA,MACA,eAAe;AAAA,MACf;AAAA,MACA,SAAS,EAAE,gBAAgB;AAAA,IAC7B;AAAA,EACF;AAEA,QAAM,UAAU,KAAK,MAAM,UAAU;AACrC,MAAI,SAAS;AACX,WACE,QAAQ,CAAC,MAAM,UAAU,QAAQ,CAAC,IAAI,QAAQ,CAAC,EAAE,QAAQ,MAAM,QAAQ;AACzE,sBAAkB,IAAI,cAAc;AAAA,MAClC;AAAA,MACA,eAAe;AAAA,MACf;AAAA,MACA,SAAS,EAAE,gBAAgB;AAAA,IAC7B,CAAC;AACD,WAAO;AAAA,MACL;AAAA,MACA,eAAe;AAAA,MACf;AAAA,MACA,SAAS,EAAE,gBAAgB;AAAA,IAC7B;AAAA,EACF;AAEA,MAAI,WAAW,KAAK,IAAI,KAAK,CAAC,KAAK,SAAS,YAAY,GAAG;AACzD,YAAQ,KAAK,SAAS,GAAG,IAAI,gBAAgB;AAAA,EAC/C;AAEA,MAAI,WAAW,KAAK,IAAI,GAAG;AACzB,UAAM,SAAS,KAAK,MAAM,UAAU,EAAG,CAAC;AAKxC,UAAM,UAAU;AAAA,MACd,gCAAgC,MAAM;AAAA,IACxC;AAEA,UAAM,MAA6B;AAAA,MACjC,MAAM;AAAA,MACN,QAAQ,CAAC,UACP;AAAA,QACE,iEAAiE,KAAK,cAAc,OAAO;AAAA,MAC7F;AAAA,MACF,eAAe,EAAE,GAAG,KAAK,GAAG,IAAI;AAAA,MAChC,SAAS,EAAE,gBAAgB;AAAA,IAC7B;AACA,sBAAkB,IAAI,cAAc,GAAG;AACvC,WAAO;AAAA,EACT;AAEA,MAAI,UAAU,KAAK,IAAI,GAAG;AACxB,UAAM,CAAC,EAAE,MAAM,QAAQ,KAAK,IAAI,KAAK,MAAM,SAAS;AACpD,UAAM,UAAU;AAAA,MACd,wBAAwB,IAAI,aAAa,MAAM,IAAI,KAAK;AAAA,IAC1D;AACA,UAAM,MAA6B;AAAA,MACjC,MAAM;AAAA,MACN,QAAQ,CAAC,UACP;AAAA,QACE,yDAAyD,KAAK,cAAc,OAAO;AAAA,MACrF;AAAA,MACF,eAAe,EAAE,GAAG,KAAK,GAAG,IAAI;AAAA,MAChC,SAAS,EAAE,gBAAgB;AAAA,IAC7B;AACA,sBAAkB,IAAI,cAAc,GAAG;AACvC,WAAO;AAAA,EACT;AAEA,MAAI,WAAW,KAAK,IAAI,GAAG;AACzB,UAAM,CAAC,EAAE,MAAM,MAAM,IAAI,KAAK,MAAM,UAAU;AAC9C,UAAM,UAAU;AAAA,MACd,2BAA2B,IAAI,IAAI,MAAM;AAAA,IAC3C;AACA,UAAM,MAA6B;AAAA,MACjC,MAAM;AAAA,MACN,QAAQ,MACN,aAAa;AAAA,yBACI,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAMvB;AAAA,MACH,eAAe,EAAE,GAAG,KAAK,GAAG,IAAI;AAAA,MAChC,SAAS,EAAE,gBAAgB;AAAA,IAC7B;AACA,sBAAkB,IAAI,MAAM,GAAG;AAC/B,WAAO;AAAA,EACT;AAEA,oBAAkB,IAAI,MAAM;AAAA,IAC1B;AAAA,IACA,eAAe;AAAA,IACf;AAAA,IACA,SAAS,EAAE,gBAAgB;AAAA,EAC7B,CAAC;AACD,SAAO;AAAA,IACL;AAAA,IACA,eAAe;AAAA,IACf;AAAA,IACA,SAAS,EAAE,gBAAgB;AAAA,EAC7B;AACF;AAEO,IAAM,mCAAmC,CAC9C,YACsB;AACtB,MAAI;AACJ,MAAI,gBAAgB,OAAO,GAAG;AAC5B,WAAO;AAAA,EACT,OAAO;AACL,WACE,CAAC,QAAQ,QAAQ,SAAS,SAAS,KAAK,oBAAoB,QAAQ;AAAA,EACxE;AAEA,QAAM,WAAW,KAAK;AAAA,IACpB,KAAK,IAAI,QAAQ,QAAQ,GAAG,QAAQ,QAAQ,KAAK,MAAM;AAAA,IACvD,QAAQ,QAAQ;AAAA,EAClB;AACA,QAAM,aAAa,YAAY;AAE/B,QAAM,aAAaG,eAAc;AAAA,IAC/B;AAAA,IACA;AAAA,EACF,CAAC;AAED,SAAO,eAAe;AAAA,IACpB,GAAG,QAAQ,IAAI,QAAQ,QAAQ;AAAA,IAC/B,GAAG,QAAQ,IAAI,QAAQ,SAAS;AAAA,IAChC,aACE,QAAQ,gBAAgB,gBAAgB,QAAQ,cAAc;AAAA,IAChE,iBAAiB;AAAA,IACjB;AAAA,IACA;AAAA,IACA,MAAM,SAAS,MAAM,YAAY,QAAQ,QAAQ,EAAE;AAAA,IACnD,WAAW;AAAA,IACX,eAAeC,gBAAe;AAAA,IAC9B,OAAO,QAAQ,SAAS;AAAA,EAC1B,CAAC;AACH;AAEA,IAAM,gBAAgB,CACpB,KAEA,qBACkB;AAClB,MAAI;AACF,UAAM,EAAE,SAAS,IAAI,IAAI,IAAI,GAAG;AAEhC,UAAM,aAAa,SAAS,QAAQ,UAAU,EAAE;AAEhD,QAAI,4BAA4B,KAAK;AACnC,UAAI,gBAAgB,IAAI,UAAU,GAAG;AACnC,eAAO;AAAA,MACT;AAEA,YAAM,yCAAyC,WAAW;AAAA,QACxD;AAAA,QACA;AAAA,MACF;AACA,UAAI,gBAAgB,IAAI,sCAAsC,GAAG;AAC/D,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAEA,UAAM,sBAAsB,iBAAiB,QAAQ,UAAU,EAAE;AACjE,QAAI,eAAe,qBAAqB;AACtC,aAAO;AAAA,IACT;AAAA,EACF,SAAS,OAAO;AAAA,EAEhB;AACA,SAAO;AACT;AAEO,IAAM,qBAAqB,CAAC,QAAwB;AACzD,QAAM,eAAe,IAAI,MAAM,gBAAgB;AAC/C,MAAI,gBAAgB,aAAa,WAAW,GAAG;AAC7C,WAAO,aAAa,CAAC;AAAA,EACvB;AAEA,QAAM,cAAc,IAAI,MAAM,eAAe;AAC7C,MAAI,eAAe,YAAY,WAAW,GAAG;AAC3C,WAAO,YAAY,CAAC;AAAA,EACtB;AAEA,QAAM,YAAY,IAAI,MAAM,gBAAgB;AAC5C,MAAI,aAAa,UAAU,WAAW,GAAG;AACvC,WAAO,UAAU,CAAC;AAAA,EACpB;AAEA,MAAI,SAAS,KAAK,GAAG,GAAG;AACtB,WAAO,2BAA2B,SAAS,KAAK,GAAG,EAAG,CAAC,CAAC;AAAA,EAC1D;AAEA,QAAM,QAAQ,IAAI,MAAM,gBAAgB;AACxC,MAAI,SAAS,MAAM,WAAW,GAAG;AAC/B,WAAO,MAAM,CAAC;AAAA,EAChB;AAEA,SAAO;AACT;AAEO,IAAM,yBAAyB,CACpC,KACA,uBACY;AACZ,MAAI,CAAC,KAAK;AACR,WAAO;AAAA,EACT;AACA,MAAI,sBAAsB,MAAM;AAC9B,QAAI,OAAO,uBAAuB,YAAY;AAC5C,YAAM,MAAM,mBAAmB,GAAG;AAElC,UAAI,OAAO,QAAQ,WAAW;AAC5B,eAAO;AAAA,MACT;AAAA,IACF,WAAW,OAAO,uBAAuB,WAAW;AAClD,aAAO;AAAA,IACT,WAAW,8BAA8B,QAAQ;AAC/C,aAAO,mBAAmB,KAAK,GAAG;AAAA,IACpC,WAAW,MAAM,QAAQ,kBAAkB,GAAG;AAC5C,iBAAW,UAAU,oBAAoB;AACvC,YAAI,kBAAkB,QAAQ;AAC5B,cAAI,IAAI,MAAM,MAAM,GAAG;AACrB,mBAAO;AAAA,UACT;AAAA,QACF,WAAW,cAAc,KAAK,MAAM,GAAG;AACrC,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO,CAAC,CAAC,cAAc,KAAK,eAAe;AAC7C;;;AE3aA;AAAA,SAAS,QAAAC,OAAM,aAAAC,YAAW,iBAAAC,sBAAqB;AAE/C,SAA2B,aAAAC,mBAAkC;AA2C7D,IAAM,kBAAkB;AACxB,IAAM,oBAAoB;AAEnB,IAAM,0BAA0B,CAAC,QAA+B;AACrE,UAAQ,KAAK;AAAA,IACX,KAAKC,MAAK;AACR,aAAO;AAAA,IACT,KAAKA,MAAK;AACR,aAAO;AAAA,IACT,KAAKA,MAAK;AACR,aAAO;AAAA,IACT,KAAKA,MAAK;AACR,aAAO;AAAA,IACT;AACE,aAAO;AAAA,EACX;AACF;AAEA,IAAM,mBAAmB,CACvB,MACA,MACA,aACA,cACG;AACH,QAAM,QAAQ,CAAC,GAAG,YAAY,OAAO,CAAC,EAAE;AAAA,IACtC,CAAC,KAAkE,OAAO;AACxE,UAAI;AACJ,UACE,aAAa,EAAE;AAAA;AAAA,OAGd,kBACC,GAAG,SAAS,iBAAiB,iBAAiB,YAAY;AAAA,MAE5D,GAAG,SAAS,iBAAiB,eAAe,cAAc,GACtD,cAAc,KAAK,IACvB;AACA,cAAM,WAAW,YAAY,IAAI,gBAAgB,SAAS;AAE1D,YAAI,CAAC,UAAU;AACb,iBAAO;AAAA,QACT;AAEA,QAAAC;AAAA,UACE,kBAAkB,QAAQ;AAAA,UAC1B;AAAA,QACF;AAEA,cAAM,YACJ,SAAS,iBAAiB,GAAG,OAAO,GAAG,OAAO,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC;AAGnE,cAAM,UAAU;AAAA,UACd;AAAA,UACA,eAAe,MAAM,WAAW;AAAA,UAChC,CAAC,UAAU,CAAC,IAAI,GAAG,GAAG,UAAU,CAAC,IAAI,GAAG,CAAC;AAAA,QAC3C;AAEA,YAAI,KAAK;AAAA,UACP;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EACH;AAEA,UAAQ,WAAW;AAAA,IACjB,KAAK;AACH,aAAO,MACJ,OAAO,CAAC,SAAS,eAAe,KAAK,SAAS,UAAU,CAAC,EACzD,IAAI,CAAC,SAAS,KAAK,QAAQ;AAAA,IAChC,KAAK;AACH,aAAO,MACJ,OAAO,CAAC,SAAS,eAAe,KAAK,SAAS,YAAY,CAAC,EAC3D,IAAI,CAAC,SAAS,KAAK,QAAQ;AAAA,IAChC,KAAK;AACH,aAAO,MACJ,OAAO,CAAC,SAAS,eAAe,KAAK,SAAS,aAAa,CAAC,EAC5D,IAAI,CAAC,SAAS,KAAK,QAAQ;AAAA,IAChC,KAAK;AACH,aAAO,MACJ,OAAO,CAAC,SAAS,eAAe,KAAK,SAAS,YAAY,CAAC,EAC3D,IAAI,CAAC,SAAS,KAAK,QAAQ;AAAA,EAClC;AACF;AAEA,IAAM,gBAAgB,CACpB,MACA,aACA,cACG;AACH,SAAO,iBAAiB,cAAc,MAAM,aAAa,SAAS;AACpE;AAEO,IAAM,kBAAkB,CAC7B,MACA,aACA,cACG;AACH,SAAO,iBAAiB,gBAAgB,MAAM,aAAa,SAAS;AACtE;AAEA,IAAM,aAAa,CACjB,SACA,aACA,cACG;AACH,QAAM,qBAAqB,oBAAoB,QAAQ;AAGvD,MAAI,cAAc,QAAQ,cAAc,QAAQ;AAC9C,UAAMC,oBAAmB,kBAAkB,QAAQ;AAEnD,UAAM,OAAO,QAAQ;AACrB,UAAM,OAAO,QAAQ,IAAI,QAAQ;AAGjC,QACE,YAAY;AAAA,MACV,CAAC,eACC,WAAW,IAAI,WAAW,QAAQ,QAAQ,WAAW,IAAI;AAAA,IAC7D,GACA;AACA,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAGA,qBAAoB,cAAc,OAAO,KAAK;AAAA,MACnD;AAAA,IACF;AAAA,EACF,WAAW,cAAc,WAAW,cAAc,QAAQ;AACxD,UAAM,OAAO,QAAQ;AACrB,UAAM,OAAO,QAAQ,IAAI,QAAQ;AAEjC,QACE,YAAY;AAAA,MACV,CAAC,eACC,WAAW,IAAI,WAAW,SAAS,QAAQ,WAAW,IAAI;AAAA,IAC9D,GACA;AACA,aAAO;AAAA,QACL,IACG,oBAAoB,QAAQ,UAAU,cAAc,SAAS,KAAK;AAAA,QACrE,GAAG;AAAA,MACL;AAAA,IACF;AAAA,EACF;AAEA,MAAI,cAAc,QAAQ,cAAc,QAAQ;AAC9C,UAAMA,oBAAmB,kBAAkB,QAAQ;AACnD,UAAMC,KAAI,YAAY,WAAW,IAAID,oBAAmBA;AACxD,UAAME,KACJ,YAAY,WAAW,IACnB,KACC,YAAY,SAAS,KAAK,MAAM,KAC/B,YAAY,SAAS,KAAK,IAAK,qBAChC,YAAY,SAAS,IAAK,qBAAqB;AAEtD,QAAI,cAAc,MAAM;AACtB,aAAO;AAAA,QACL,GAAAA;AAAA,QACA,GAAGD,KAAI;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,MACL,GAAAC;AAAA,MACA,GAAAD;AAAA,IACF;AAAA,EACF;AAEA,QAAM,mBAAmB,kBAAkB,QAAQ;AACnD,QAAM,KACH,YAAY,WAAW,IAAI,oBAAoB,qBAChD,QAAQ;AACV,QAAM,IACJ,YAAY,WAAW,IACnB,KACC,YAAY,SAAS,KAAK,MAAM,KAC/B,YAAY,SAAS,KAAK,IAAK,mBAChC,YAAY,SAAS,IAAK,mBAAmB;AAEpD,MAAI,cAAc,QAAQ;AACxB,WAAO;AAAA,MACL,GAAG,IAAI;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,aAAa,CACjB,SACA,UACA,WACA,UACG;AACH,QAAM,cAAc,MAAM,yBAAyB;AACnD,QAAM,aAAa,cAAc,SAAS,aAAa,SAAS;AAChE,QAAM,gBAAgB,gBAAgB,SAAS,aAAa,SAAS;AAErE,QAAM,UAAU;AAAA,IACd;AAAA,IACA,CAAC,GAAG,YAAY,GAAG,aAAa;AAAA,IAChC;AAAA,EACF;AAEA,QAAM,WAAW,WAAW;AAAA,IAC1B,MAAM,QAAQ;AAAA,IACd,GAAG,QAAQ,IAAI,QAAQ;AAAA,IACvB,GAAG,QAAQ,IAAI,QAAQ;AAAA;AAAA,IAEvB,OAAO,QAAQ;AAAA,IACf,QAAQ,QAAQ;AAAA,IAChB,WAAW,QAAQ;AAAA,IACnB,WAAW,QAAQ;AAAA,IACnB,iBAAiB,QAAQ;AAAA,IACzB,aAAa,QAAQ;AAAA,IACrB,aAAa,QAAQ;AAAA,IACrB,SAAS,QAAQ;AAAA,IACjB,WAAW,QAAQ;AAAA,IACnB,aAAa,QAAQ;AAAA,EACvB,CAAC;AAED,EAAAF;AAAA,IACE,uBAAuB,QAAQ;AAAA,IAC/B;AAAA,EACF;AAEA,QAAM,eAAe;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,cAAc,CACzB,WACA,UACA,WACA,OACA,kBACG;AAEH,QAAM,WAAgC,CAAC;AAEvC,WAAS,IAAI,GAAG,IAAI,eAAe,KAAK;AACtC,QAAI;AACJ,QAAI;AACJ,QAAI,cAAc,UAAU,cAAc,SAAS;AACjD,YAAM,cACJ,mBAAmB,gBAAgB,KACnC,gBAAgB,UAAU;AAE5B,YAAM,SAAS,UAAU,IAAI,UAAU,SAAS,IAAI,cAAc;AAElE,UAAI,UAAU,oBAAoB,UAAU;AAC5C,UAAI,cAAc,QAAQ;AACxB,mBAAW;AAAA,MACb;AACA,cAAQ,UAAU,IAAI;AACtB,YAAM,WAAW,kBAAkB,UAAU,UAAU;AACvD,cAAQ,SAAS;AAAA,IACnB,OAAO;AACL,YAAM,aACJ,qBAAqB,gBAAgB,KACrC,gBAAgB,UAAU;AAC5B,YAAM,SAAS,UAAU,IAAI,UAAU,QAAQ,IAAI,aAAa;AAChE,UAAI,UAAU,kBAAkB,UAAU;AAE1C,UAAI,cAAc,MAAM;AACtB,mBAAW;AAAA,MACb;AACA,cAAQ,UAAU,IAAI;AACtB,YAAM,WAAW,oBAAoB,UAAU,SAAS;AACxD,cAAQ,SAAS;AAAA,IACnB;AAEA,UAAM,WAAW,WAAW;AAAA,MAC1B,MAAM,UAAU;AAAA,MAChB,GAAG;AAAA,MACH,GAAG;AAAA;AAAA,MAEH,OAAO,UAAU;AAAA,MACjB,QAAQ,UAAU;AAAA,MAClB,WAAW,UAAU;AAAA,MACrB,WAAW,UAAU;AAAA,MACrB,iBAAiB,UAAU;AAAA,MAC3B,aAAa,UAAU;AAAA,MACvB,aAAa,UAAU;AAAA,MACvB,SAAS,UAAU;AAAA,MACnB,WAAW,UAAU;AAAA,MACrB,aAAa,UAAU;AAAA,IACzB,CAAC;AAED,IAAAA;AAAA,MACE,uBAAuB,QAAQ;AAAA,MAC/B;AAAA,IACF;AAEA,UAAM,eAAe;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,aAAS,KAAK,QAAQ;AACtB,aAAS,KAAK,YAAY;AAAA,EAC5B;AAEA,SAAO;AACT;AAEA,IAAM,qBAAqB,CACzB,qBACA,mBACA,WACA,UACA,UACG;AACH,MAAI;AACJ,MAAI;AAEJ,QAAM,UAAU;AAEhB,UAAQ,WAAW;AAAA,IACjB,KAAK,MAAM;AACT,eAAS,oBAAoB,IAAI,oBAAoB,QAAQ;AAC7D,eAAS,oBAAoB,IAAI;AACjC;AAAA,IACF;AAAA,IACA,KAAK,QAAQ;AACX,eAAS,oBAAoB,IAAI,oBAAoB,QAAQ;AAC7D,eAAS,oBAAoB,IAAI,oBAAoB,SAAS;AAC9D;AAAA,IACF;AAAA,IACA,KAAK,SAAS;AACZ,eAAS,oBAAoB,IAAI,oBAAoB,QAAQ;AAC7D,eAAS,oBAAoB,IAAI,oBAAoB,SAAS;AAC9D;AAAA,IACF;AAAA,IACA,KAAK,QAAQ;AACX,eAAS,oBAAoB,IAAI;AACjC,eAAS,oBAAoB,IAAI,oBAAoB,SAAS;AAC9D;AAAA,IACF;AAAA,EACF;AAEA,MAAI;AACJ,MAAI;AAEJ,UAAQ,WAAW;AAAA,IACjB,KAAK,MAAM;AACT,aAAO,kBAAkB,IAAI,kBAAkB,QAAQ,IAAI;AAC3D,aAAO,kBAAkB,IAAI,kBAAkB,SAAS,SAAS;AACjE;AAAA,IACF;AAAA,IACA,KAAK,QAAQ;AACX,aAAO,kBAAkB,IAAI,kBAAkB,QAAQ,IAAI;AAC3D,aAAO,kBAAkB,IAAI,SAAS;AACtC;AAAA,IACF;AAAA,IACA,KAAK,SAAS;AACZ,aAAO,kBAAkB,IAAI,SAAS;AACtC,aAAO,kBAAkB,IAAI,SAAS,kBAAkB,SAAS;AACjE;AAAA,IACF;AAAA,IACA,KAAK,QAAQ;AACX,aAAO,kBAAkB,IAAI,kBAAkB,QAAQ,SAAS;AAChE,aAAO,kBAAkB,IAAI,SAAS,kBAAkB,SAAS;AACjE;AAAA,IACF;AAAA,EACF;AAEA,QAAM,eAAe,gBAAgB;AAAA,IACnC,MAAM;AAAA,IACN,GAAG;AAAA,IACH,GAAG;AAAA,IACH,gBAAgB;AAAA,IAChB,cAAc,SAAS;AAAA,IACvB,aAAa,oBAAoB;AAAA,IACjC,aAAa,oBAAoB;AAAA,IACjC,aAAa,oBAAoB;AAAA,IACjC,SAAS,oBAAoB;AAAA,IAC7B,WAAW,oBAAoB;AAAA,IAC/B,QAAQ,CAACI,YAAU,GAAG,CAAC,GAAGA,YAAU,MAAM,IAAI,CAAC;AAAA,IAC/C,SAAS;AAAA,EACX,CAAC;AAED,QAAM,cAAc,MAAM,yBAAyB;AAEnD,oBAAkB,cAAc,qBAAqB,SAAS,KAAK;AACnE,oBAAkB,cAAc,mBAAmB,OAAO,KAAK;AAE/D,QAAM,kBAAkB,oBAAI,IAAsC;AAClE,kBAAgB;AAAA,IACd,oBAAoB;AAAA,IACpB;AAAA,EACF;AACA,kBAAgB;AAAA,IACd,kBAAkB;AAAA,IAClB;AAAA,EACF;AACA,kBAAgB;AAAA,IACd,aAAa;AAAA,IACb;AAAA,EACF;AAEA,sBAAoB;AAAA,IAClB;AAAA,IACA;AAAA,IACA,oBAAI,IAAI;AAAA,MACN;AAAA,QACE;AAAA,QACA;AAAA,UACE,OAAO,aAAa,OAAO,CAAC;AAAA,QAC9B;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAEA,QAAM,SAAS;AAAA,IACb;AAAA,IACAC;AAAA,MACE,IAAI,IAAI;AAAA,QACN,GAAG,YAAY,QAAQ;AAAA,QACvB,CAAC,oBAAoB,IAAI,mBAAmB;AAAA,QAC5C,CAAC,kBAAkB,IAAI,iBAAiB;AAAA,QACxC,CAAC,aAAa,IAAI,YAAY;AAAA,MAChC,CAA2C;AAAA,IAC7C;AAAA,IACA,EAAE,QAAQ,aAAa,OAAO;AAAA,EAChC;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,EACL;AACF;AAEO,IAAM,qBAAN,MAAyB;AAAA,EAC9B,cAAuB;AAAA;AAAA,EAEf,iBAAsC,CAAC;AAAA,EACvC,iBAAyB;AAAA;AAAA,EAEzB,YAAkC;AAAA;AAAA,EAElC,eAA6C,oBAAI,IAAI;AAAA,EAE7D,QAAQ;AACN,SAAK,cAAc;AACnB,SAAK,iBAAiB,CAAC;AACvB,SAAK,iBAAiB;AACtB,SAAK,YAAY;AACjB,SAAK,aAAa,MAAM;AAAA,EAC1B;AAAA,EAEA,mBACE,SACA,aACA,WACgC;AAChC,QAAI,CAAC,kBAAkB,OAAO,GAAG;AAC/B,aAAO;AAAA,IACT;AAGA,QAAI,cAAc,KAAK,WAAW;AAChC,WAAK,MAAM;AAAA,IACb;AAGA,QAAI,CAAC,KAAK,aAAa,IAAI,QAAQ,EAAE,GAAG;AACtC,WAAK,aAAa,IAAI,QAAQ,EAAE;AAAA,IAClC;AAcA,QACE,KAAK,eACL,cAAc,KAAK,aACnB,KAAK,eAAe,SAAS,GAC7B;AACA,WAAK,kBACF,KAAK,iBAAiB,KAAK,KAAK,eAAe;AAElD,aAAO,KAAK,eAAe,KAAK,cAAc,EAAE;AAAA,IAClD;AAEA,UAAM,QAAQ;AAAA,MACZ,GAAG,cAAc,SAAS,aAAa,SAAS;AAAA,MAChD,GAAG,gBAAgB,SAAS,aAAa,SAAS;AAAA,IACpD;AASA,QAAI,MAAM,SAAS,GAAG;AACpB,WAAK,iBAAiB;AACtB,WAAK,cAAc;AACnB,WAAK,iBAAiB;AACtB,WAAK,YAAY;AACjB,WAAK,aAAa,IAAI,MAAM,CAAC,EAAE,EAAE;AAEjC,aAAO,MAAM,CAAC,EAAE;AAAA,IAClB;AAcA,QAAI,cAAc,KAAK,aAAa,CAAC,KAAK,aAAa;AACrD,UAAI,CAAC,KAAK,aAAa;AAIrB,aAAK,aAAa,IAAI,QAAQ,EAAE;AAAA,MAClC;AAEA,YAAM,kBAAmC;AAAA,QACvC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,EAAE,OAAO,CAAC,QAA8B,QAAQ,SAAS;AAEzD,YAAM,mBAAmB,gBACtB,IAAI,CAAC,QAAQ;AAAA,QACZ,GAAG,cAAc,SAAS,aAAa,GAAG;AAAA,QAC1C,GAAG,gBAAgB,SAAS,aAAa,GAAG;AAAA,MAC9C,CAAC,EACA,KAAK,EACL,OAAO,CAAC,eAAe,CAAC,KAAK,aAAa,IAAI,WAAW,EAAE,CAAC;AAE/D,iBAAW,cAAc,kBAAkB;AACzC,YAAI,CAAC,KAAK,aAAa,IAAI,WAAW,EAAE,GAAG;AACzC,eAAK,aAAa,IAAI,WAAW,EAAE;AACnC,eAAK,cAAc;AACnB,eAAK,YAAY;AACjB,iBAAO,WAAW;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;AAEO,IAAM,mBAAN,MAAuB;AAAA,EAC5B,kBAA2B;AAAA,EACnB,gBAAwB;AAAA,EACxB,YAAkC;AAAA,EAC1C,eAAiD;AAAA,EAEjD,YACE,WACA,UACA,WACA,OACA;AACA,UAAM,cAAc,MAAM,yBAAyB;AACnD,QAAI,cAAc,KAAK,WAAW;AAChC,YAAM,EAAE,UAAU,aAAa,IAAI;AAAA,QACjC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,WAAK,gBAAgB;AACrB,WAAK,kBAAkB;AACvB,WAAK,YAAY;AACjB,WAAK,eAAe,CAAC,UAAU,YAAY;AAAA,IAC7C,OAAO;AACL,WAAK,iBAAiB;AACtB,YAAM,WAAW;AAAA,QACf;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,KAAK;AAAA,MACP;AAEA,WAAK,kBAAkB;AACvB,WAAK,YAAY;AACjB,WAAK,eAAe;AAAA,IACtB;AAIA,QAAI,UAAU,SAAS;AACrB,YAAM,QAAQ,YAAY,IAAI,UAAU,OAAO;AAE/C,MAAAL;AAAA,QACE,SAAS,eAAe,KAAK;AAAA,QAC7B;AAAA,MACF;AAEA,UACE,SACA,KAAK,aAAa;AAAA,QAChB,CAAC,SACC,yBAAyB,CAAC,IAAI,GAAG,OAAO,WAAW,KACnD,yBAAyB,MAAM,OAAO,WAAW;AAAA,MACrD,GACA;AACA,aAAK,eAAe,KAAK,aAAa;AAAA,UAAI,CAAC,SACzC,cAAc,MAAM,aAAa;AAAA,YAC/B,SAAS,UAAU;AAAA,UACrB,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,QAAQ;AACN,SAAK,kBAAkB;AACvB,SAAK,eAAe;AACpB,SAAK,YAAY;AACjB,SAAK,gBAAgB;AAAA,EACvB;AACF;AAEO,IAAM,oBAAoB,CAC/B,SACA,gBACG;AACH,aAAW,CAAC,EAAE,EAAE,KAAK,aAAa;AAChC,QACE,GAAG,SAAS,YACX,GAAG,cAAc,cAAc,QAAQ,MACtC,GAAG,YAAY,cAAc,QAAQ,KACvC;AACA,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;;;AC9sBA;AAIA,SAAS,cAAAM,aAAY,cAAc;AAgB5B,IAAM,uBAAuB,CAAC,YAAqB;AACxD,SAAO,IAAI,QAA0B,CAAC,SAAS,WAAW;AACxD,UAAM,QAAQ,IAAI,MAAM;AACxB,UAAM,SAAS,MAAM;AACnB,cAAQ,KAAK;AAAA,IACf;AACA,UAAM,UAAU,CAAC,UAAU;AACzB,aAAO,KAAK;AAAA,IACd;AACA,UAAM,MAAM;AAAA,EACd,CAAC;AACH;AAIO,IAAM,mBAAmB,OAAO;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AACF,MAIM;AACJ,QAAM,eAAe,oBAAI,IAAkB;AAC3C,QAAM,eAAe,oBAAI,IAAkB;AAE3C,QAAM,QAAQ;AAAA,IACZ,QAAQ,OAAO,CAAC,UAAU,WAAW;AACnC,YAAM,WAAW,MAAM,MAAgB;AACvC,UAAI,YAAY,CAAC,aAAa,IAAI,MAAM,GAAG;AACzC,qBAAa,IAAI,QAAQ,IAAI;AAC7B,eAAO,SAAS;AAAA,WACb,YAAY;AACX,gBAAI;AACF,kBAAI,SAAS,aAAaC,YAAW,QAAQ;AAC3C,sBAAM,IAAI,MAAM,wCAAwC;AAAA,cAC1D;AAEA,oBAAM,eAAe,qBAAqB,SAAS,OAAO;AAC1D,oBAAM,OAAO;AAAA,gBACX,OAAO;AAAA,gBACP,UAAU,SAAS;AAAA,cACrB;AAGA,yBAAW,IAAI,QAAQ,IAAI;AAE3B,oBAAM,QAAQ,MAAM;AAEpB,yBAAW,IAAI,QAAQ,EAAE,GAAG,MAAM,MAAM,CAAC;AAAA,YAC3C,SAAS,OAAY;AACnB,2BAAa,IAAI,QAAQ,IAAI;AAAA,YAC/B;AAAA,UACF,GAAG;AAAA,QACL;AAAA,MACF;AACA,aAAO;AAAA,IACT,GAAG,CAAC,CAAmB;AAAA,EACzB;AAEA,SAAO;AAAA,IACL;AAAA;AAAA,IAEA;AAAA;AAAA,IAEA;AAAA,EACF;AACF;AAEO,IAAM,8BAA8B,CACzC,aAEA,SAAS;AAAA,EAAO,CAAC,YACf,0BAA0B,OAAO;AACnC;AAEK,IAAM,mBAAmB,CAAC,SAA0C;AAGzE,SAAO,MAAM,SAAS,YAAY,MAAM;AAC1C;AAEO,IAAM,eAAe,CAAC,cAAsB;AACjD,QAAM,MAAM,IAAI,UAAU,EAAE,gBAAgB,WAAWA,YAAW,GAAG;AACrE,QAAM,MAAM,IAAI,cAAc,KAAK;AACnC,QAAM,YAAY,IAAI,cAAc,aAAa;AACjD,MAAI,aAAa,CAAC,iBAAiB,GAAG,GAAG;AACvC,UAAM,IAAI,MAAM,aAAa;AAAA,EAC/B,OAAO;AACL,QAAI,CAAC,IAAI,aAAa,OAAO,GAAG;AAC9B,UAAI,aAAa,SAAS,MAAM;AAAA,IAClC;AAEA,QAAI,QAAQ,IAAI,aAAa,OAAO;AACpC,QAAI,SAAS,IAAI,aAAa,QAAQ;AAItC,QAAI,OAAO,SAAS,GAAG,KAAK,UAAU,QAAQ;AAC5C,cAAQ;AAAA,IACV;AACA,QAAI,QAAQ,SAAS,GAAG,KAAK,WAAW,QAAQ;AAC9C,eAAS;AAAA,IACX;AAEA,UAAM,UAAU,IAAI,aAAa,SAAS;AAE1C,QAAI,CAAC,SAAS,CAAC,QAAQ;AACrB,cAAQ,SAAS;AACjB,eAAS,UAAU;AAEnB,UAAI,SAAS;AACX,cAAM,QAAQ,QAAQ;AAAA,UACpB;AAAA,QACF;AACA,YAAI,OAAO;AACT,WAAC,EAAE,OAAO,MAAM,IAAI;AAAA,QACtB;AAAA,MACF;AAEA,UAAI,aAAa,SAAS,KAAK;AAC/B,UAAI,aAAa,UAAU,MAAM;AAAA,IACnC;AAGA,QAAI,CAAC,SAAS;AACZ,UAAI,aAAa,WAAW,OAAO,KAAK,IAAI,MAAM,EAAE;AAAA,IACtD;AAEA,WAAO,IAAI;AAAA,EACb;AACF;;;ACxJA;AAAA;AAAA,EACE,eAAAC;AAAA,EACA,oBAAAC;AAAA,EACA,aAAAC;AAAA,EACA,mBAAAC;AAAA,OAGK;AAEP;AAAA,EACE;AAAA,EACA,uBAAAC;AAAA,EACA,iBAAAC;AAAA,EACA,iBAAAC;AAAA,OACK;AAgEA,IAAM,oBAAoB,CAC/B,kBACA,qBACA,kBACA,OACAC,gCACA,wBACA,2BACA,UACA,UACA,SACA,YACY;AACZ,QAAM,cAAc,MAAM,yBAAyB;AACnD,MAAI,iBAAiB,WAAW,GAAG;AACjC,UAAM,CAAC,OAAO,IAAI;AAClB,QAAI,wBAAwB,YAAY;AACtC,UAAI,CAAC,aAAa,OAAO,GAAG;AAC1B;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACAA;AAAA,QACF;AACA,4BAAoB,SAAS,KAAK;AAAA,MACpC;AAAA,IACF,WAAW,qBAAqB;AAC9B,YAAM,YAAY,iBAAiB,CAAC,EAAE;AACtC,YAAM,gBAAgB,YAAY,IAAI,SAAS;AAC/C,YAAM,cAAc,iBAAiB,IAAI,SAAS;AAElD,UAAI,iBAAiB,aAAa;AAChC,cAAM,EAAE,WAAW,WAAW,IAC5B;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,YACE;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAEF;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,YACE;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,QAAI,cAAc,OAAO,GAAG;AAC1B,0BAAoB,SAAS,KAAK;AAAA,IACpC;AACA,WAAO;AAAA,EACT,WAAW,iBAAiB,SAAS,GAAG;AACtC,QAAI,wBAAwB,YAAY;AACtC;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACAA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,aAAO;AAAA,IACT,WAAW,qBAAqB;AAC9B,YAAM,EAAE,WAAW,YAAY,SAAS,SAAS,oBAAoB,IACnE;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,UACE;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEF;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAEA,IAAM,sBAAsB,CAC1B,SACA,OACA,UACA,UACAA,mCACG;AACH,QAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAIC;AAAA,IACvB;AAAA,IACA,MAAM,yBAAyB;AAAA,EACjC;AACA,QAAM,MAAM,KAAK,MAAM;AACvB,QAAM,MAAM,KAAK,MAAM;AACvB,MAAI;AACJ,MAAI,mBAAmB,OAAO,GAAG;AAC/B,YAAQ;AAAA,EACV,OAAO;AACL,YAAU,IAAI,KAAK,KAAM,IACvB,KAAK,MAAM,WAAW,IAAI,WAAW,EAAE;AACzC,QAAID,gCAA+B;AACjC,cAAS,QAAQE,uBAAsB;AACvC,cAAS,QAAS,QAAQA;AAAA,IAC5B;AACA,YAAQC,kBAAiB,KAAgB;AAAA,EAC3C;AACA,QAAM,qBAAqB,sBAAsB,OAAO;AAExD,QAAM,cAAc,SAAS,EAAE,MAAM,CAAC;AACtC,MAAI,oBAAoB;AACtB,UAAM,cACJ,MAAM,WAA+C,kBAAkB;AAEzE,QAAI,eAAe,CAAC,eAAe,OAAO,GAAG;AAC3C,YAAM,cAAc,aAAa,EAAE,MAAM,CAAC;AAAA,IAC5C;AAAA,EACF;AACF;AAEO,IAAM,yBAAyB,CACpC,SACA,OACA,QACA,oBAEA,gBAAgB,OAAO,KAAK,kBAAkB,OAAO,IACjD;AAAA,EACE,QAAQC;AAAA,IACN;AAAA,IACA;AAAA,IACAA,eAAc,GAAG,QAAQ,QAAQ,QAAQ,eAAe;AAAA,IACxD;AAAA,EACF;AACF,IACA,CAAC;AAEA,IAAM,2BAA2B,CACtC,SACA,aACA,cAC4B;AAE5B,MAAI,QAAQ,QAAQ;AAEpB,QAAM,eAAe,mBAAmB,OAAO;AAC/C,MAAI,cAAc;AAChB,UAAM,YAAY,oBAAoB,SAAS,WAAW;AAC1D,QAAI,WAAW;AACb,cAAQ,qBAAqB,WAAW,OAAO;AAAA,IACjD;AAAA,EACF;AACA,QAAM,eAAe,QAAQ,YAAY,YAAY;AACrD,MAAI,eAAe,eAAe;AAChC,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,EACR;AACF;AAEO,IAAM,0BAA0B,CACrC,aACA,SACA,OACA,qBACA,wBACA,WACA,eACG;AACH,QAAM,cAAc,MAAM,yBAAyB;AAEnD,QAAM,eAAe,QAAQ,SAAS,aAAa,QAAQ;AAE3D,QAAM,UAAU,yBAAyB,SAAS,aAAa,YAAY;AAC3E,MAAI,YAAY,MAAM;AACpB;AAAA,EACF;AAEA,MAAI,oBAAoB,SAAS,GAAG,KAAK,oBAAoB,SAAS,GAAG,GAAG;AAC1E,UAAM,iBAAiBC,YAAuB,YAAY,GAAG,YAAY,CAAC;AAE1E,UAAM,YAAY;AAAA,MAChB;AAAA,MACA,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,cAAc,SAAS;AAAA,MAC3B,UAAU,QAAQ;AAAA,MAClB,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,GAAG,UAAU;AAAA,MACb,GAAG,UAAU;AAAA,IACf,CAAC;AACD;AAAA,EACF;AAEA,MAAI,wBAAwB,OAAO,wBAAwB,KAAK;AAC9D,UAAM,WAAW;AAAA,MACfC,eAAc;AAAA,QACZ,UAAU,QAAQ;AAAA,QAClB,YAAY,QAAQ;AAAA,MACtB,CAAC;AAAA,MACD,QAAQ;AAAA,IACV;AAEA,UAAM,WAAW,KAAK,IAAI,UAAU,SAAS;AAE7C,UAAM,OAAO;AAAA,MACX,QAAQ;AAAA,MACRA,eAAc,OAAO;AAAA,MACrB,KAAK,IAAI,QAAQ;AAAA,IACnB;AACA,UAAMC,WAAU;AAAA,MACd;AAAA,MACAD,eAAc,OAAO;AAAA,MACrB,QAAQ;AAAA,IACV;AAEA,UAAM,YAAYC,SAAQ;AAE1B,UAAM,iBAAiBF,YAAuB,YAAY,GAAG,YAAY,CAAC;AAE1E,UAAM,YAAY;AAAA,MAChB;AAAA,MACA,YAAY;AAAA,MACZ,YAAY;AAAA,MACZ;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,iBAAiD;AAAA,MACrD,OAAO,KAAK,IAAI,QAAQ;AAAA,MACxB,QAAQ,KAAK,IAAIE,SAAQ,MAAM;AAAA,MAC/B,GAAG,UAAU;AAAA,MACb,GAAG,UAAU;AAAA,MACb;AAAA,MACA,YAAY;AAAA,IACd;AAEA,UAAM,cAAc,SAAS,cAAc;AAAA,EAC7C;AACF;AAEA,IAAM,yBAAyB,CAC7B,kBACA,UACA,OACA,UACA,UACAP,gCACA,SACA,YACG;AACH,QAAM,cAAc,MAAM,yBAAyB;AACnD,MAAI,cACD,IAAI,KAAK,KAAM,IAAI,KAAK,MAAM,WAAW,SAAS,WAAW,OAAO;AACvE,MAAIA,gCAA+B;AACjC,mBAAeE,uBAAsB;AACrC,mBAAe,cAAcA;AAAA,EAC/B;AAEA,aAAW,WAAW,UAAU;AAC9B,QAAI,CAAC,mBAAmB,OAAO,GAAG;AAChC,YAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAID,0BAAyB,SAAS,WAAW;AACtE,YAAM,MAAM,KAAK,MAAM;AACvB,YAAM,MAAM,KAAK,MAAM;AACvB,YAAM,YACJ,iBAAiB,IAAI,QAAQ,EAAE,GAAG,SAAS,QAAQ;AACrD,YAAM,CAAC,WAAW,SAAS,IAAIO;AAAA,QAC7BH,YAAU,IAAI,EAAE;AAAA,QAChBA,YAAU,SAAS,OAAO;AAAA,QACzB,cAAc,YAAY,QAAQ;AAAA,MACrC;AAEA,YAAM,UAAU,aAAa,OAAO,IAChC;AAAA;AAAA,QAEE,QAAQ,yBAAyB,SAAS,WAAW;AAAA,MACvD,IACA;AAAA,QACE,GAAG,QAAQ,KAAK,YAAY;AAAA,QAC5B,GAAG,QAAQ,KAAK,YAAY;AAAA,QAC5B,OAAOF,kBAAkB,cAAc,SAAqB;AAAA,MAC9D;AAEJ,YAAM,cAAc,SAAS,OAAO;AAEpC,0BAAoB,SAAS,OAAO;AAAA,QAClC,uBAAuB;AAAA,MACzB,CAAC;AAED,YAAM,YAAY,oBAAoB,SAAS,WAAW;AAC1D,UAAI,aAAa,CAAC,eAAe,OAAO,GAAG;AACzC,cAAM,cAAc,WAAW;AAAA,UAC7B,GAAG,UAAU,KAAK,YAAY;AAAA,UAC9B,GAAG,UAAU,KAAK,YAAY;AAAA,UAC9B,OAAOA,kBAAkB,cAAc,SAAqB;AAAA,QAC9D,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAEA,QAAM,cAAc;AACtB;AAEO,IAAM,oBAAoB,CAC/B,qBACA,kBACA,aACA,GACA,MACqB;AACrB,QAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IACnB,iBAAiB,WAAW,IACxBF,0BAAyB,iBAAiB,CAAC,GAAG,WAAW,IACzD,gBAAgB,gBAAgB;AACtC,QAAM,MAAM,KAAK,MAAM;AACvB,QAAM,MAAM,KAAK,MAAM;AACvB,QAAM,QACJ,iBAAiB,WAAW,IAAI,iBAAiB,CAAC,EAAE,QAAQ;AAE9D,GAAC,GAAG,CAAC,IAAIO;AAAA,IACPH,YAAU,GAAG,CAAC;AAAA,IACdA,YAAU,IAAI,EAAE;AAAA,IAChB,CAAC;AAAA,EACH;AACA,UAAQ,qBAAqB;AAAA,IAC3B,KAAK;AACH,aAAOG;AAAA,QACLH,YAAU,KAAK,KAAK,MAAM,GAAG,IAAI,EAAE;AAAA,QACnCA,YAAU,GAAG,CAAC;AAAA,QACd;AAAA,MACF;AAAA,IACF,KAAK;AACH,aAAOG;AAAA,QACLH,YAAU,KAAK,KAAK,MAAM,GAAG,IAAI,EAAE;AAAA,QACnCA,YAAU,GAAG,CAAC;AAAA,QACd;AAAA,MACF;AAAA,IACF,KAAK;AACH,aAAOG;AAAA,QACLH,YAAU,IAAI,IAAI,KAAK,KAAK,MAAM,CAAC;AAAA,QACnCA,YAAU,GAAG,CAAC;AAAA,QACd;AAAA,MACF;AAAA,IACF,KAAK;AACH,aAAOG;AAAA,QACLH,YAAU,IAAI,IAAI,KAAK,KAAK,MAAM,CAAC;AAAA,QACnCA,YAAU,GAAG,CAAC;AAAA,QACd;AAAA,MACF;AAAA,IACF,KAAK;AACH,aAAOG,kBAAgBH,YAAU,IAAI,IAAI,IAAI,EAAE,GAAGA,YAAU,GAAG,CAAC,GAAG,KAAK;AAAA,IAC1E,KAAK;AACH,aAAOG,kBAAgBH,YAAU,IAAI,IAAI,IAAI,EAAE,GAAGA,YAAU,GAAG,CAAC,GAAG,KAAK;AAAA,IAC1E,KAAK;AACH,aAAOG,kBAAgBH,YAAU,IAAI,IAAI,IAAI,EAAE,GAAGA,YAAU,GAAG,CAAC,GAAG,KAAK;AAAA,IAC1E,KAAK;AACH,aAAOG,kBAAgBH,YAAU,IAAI,IAAI,IAAI,EAAE,GAAGA,YAAU,GAAG,CAAC,GAAG,KAAK;AAAA,IAC1E;AACE,aAAO,CAAC,GAAG,CAAC;AAAA,EAChB;AACF;AAEO,IAAM,0BAA0B,CACrC,qBACA,YACqB;AACrB,QAAM,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,QAAQ;AAC7B,QAAM,cACH,wBAAwB,SAAS,KAAK,KAAK,KAAK,MAChD,wBAAwB,QAAQ,MAAM,KACtC,wBAAwB,QAAQ,MAAM,KACtC,wBAAwB,SAAS,KAAK,KAAK,KAAK;AACnD,SAAO,cAAc,QAAQ;AAC/B;AAaA,IAAM,kBAAkB,CACtB,iBACA,2BACA,2BACiB;AACjB,MAAI,wBAAwB;AAC1B,WAAO;AAAA,EACT;AAEA,MAAI,2BAA2B;AAC7B,YAAQ,iBAAiB;AAAA,MACvB,KAAK;AACH,eAAO;AAAA,MACT,KAAK,KAAK;AACR,eAAO;AAAA,MACT;AAAA,MACA,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,IACX;AAAA,EACF;AAEA,MAAI,CAAC,KAAK,MAAM,GAAG,EAAE,SAAS,eAAe,GAAG;AAC9C,WAAO;AAAA,EACT,WAAW,CAAC,KAAK,MAAM,GAAG,EAAE,SAAS,eAAe,GAAG;AACrD,WAAO;AAAA,EACT,WAAW,oBAAoB,MAAM;AACnC,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEA,IAAM,mBAAmB,CACvB,YACA,WACA,YACA,UACA,WACA,OACA,iBACA,2BACA,2BAC6B;AAC7B,QAAM,SAAS;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,CAAC,GAAG,CAAC,IAAI;AAEf,UAAQ,QAAQ;AAAA,IACd,KAAK;AACH,aAAO;AAAA,QACL,GACE,KACC,YAAY,YAAY,KACvB,WAAW,aAAa,IAAK,KAAK,IAAI,KAAK,KAC3C,aAAa,aAAa,IAAK,KAAK,IAAI,KAAK;AAAA,QACjD,GACE,KACC,aAAa,aAAa,KACzB,WAAW,aAAa,IAAK,KAAK,IAAI,KAAK,KAC3C,YAAY,cAAc,IAAK,KAAK,IAAI,KAAK;AAAA,MACnD;AAAA,IACF,KAAK;AACH,aAAO;AAAA,QACL,GACE,KACE,YAAY,YAAY,KAAM,KAAK,IAAI,KAAK,IAAI,MAChD,aAAa,aAAa,IAAK,KAAK,IAAI,KAAK;AAAA,QACjD,GACE,KACC,aAAa,aAAa,KACzB,YAAY,YAAY,IAAK,KAAK,IAAI,KAAK,KAC3C,YAAY,cAAc,IAAK,KAAK,IAAI,KAAK;AAAA,MACnD;AAAA,IAEF,KAAK;AACH,aAAO;AAAA,QACL,GACE,KACE,YAAY,YAAY,KAAM,IAAI,KAAK,IAAI,KAAK,MAChD,YAAY,cAAc,IAAK,KAAK,IAAI,KAAK;AAAA,QACjD,GACE,KACE,aAAa,aAAa,KAAM,KAAK,IAAI,KAAK,IAAI,MAClD,WAAW,aAAa,IAAK,KAAK,IAAI,KAAK;AAAA,MACjD;AAAA,IACF,KAAK;AACH,aAAO;AAAA,QACL,GACE,KACE,YAAY,YAAY,KAAM,KAAK,IAAI,KAAK,IAAI,MAChD,YAAY,cAAc,IAAK,KAAK,IAAI,KAAK;AAAA,QACjD,GACE,KACE,aAAa,aAAa,KAAM,KAAK,IAAI,KAAK,IAAI,MAClD,YAAY,YAAY,IAAK,KAAK,IAAI,KAAK;AAAA,MACjD;AAAA,IACF,KAAK;AACH,aAAO;AAAA,QACL,GAAG,KAAK,WAAW,aAAa;AAAA,QAChC,GAAG,KAAK,YAAY,cAAc;AAAA,MACpC;AAAA,IACF,KAAK;AACH,aAAO;AAAA,QACL,GAAG,KAAM,YAAY,YAAY,KAAM,KAAK,IAAI,KAAK,IAAI;AAAA,QACzD,GACE,KACE,YAAY,YAAY,IAAK,KAAK,IAAI,KAAK,KAC5C,aAAa,aAAa;AAAA,MAC/B;AAAA,IACF,KAAK;AACH,aAAO;AAAA,QACL,GAAG,KAAM,YAAY,YAAY,KAAM,IAAI,KAAK,IAAI,KAAK;AAAA,QACzD,GACE,KACE,WAAW,aAAa,IAAK,KAAK,IAAI,KAAK,KAC5C,aAAa,aAAa;AAAA,MAC/B;AAAA,IACF,KAAK;AACH,aAAO;AAAA,QACL,GACE,KACC,YAAY,YAAY,KACvB,aAAa,aAAa,IAAK,KAAK,IAAI,KAAK;AAAA,QACjD,GAAG,KAAM,YAAY,cAAc,KAAM,KAAK,IAAI,KAAK,IAAI;AAAA,MAC7D;AAAA,IACF,KAAK;AACH,aAAO;AAAA,QACL,GACE,KACC,YAAY,YAAY,KACvB,YAAY,cAAc,IAAK,KAAK,IAAI,KAAK;AAAA,QACjD,GAAG,KAAM,aAAa,aAAa,KAAM,KAAK,IAAI,KAAK,IAAI;AAAA,MAC7D;AAAA,EACJ;AACF;AAEO,IAAM,sBAAsB,CACjC,WACA,YACA,eACA,aACA,qBACA,OACA,iBACA;AAAA,EACE,uBAAuB;AAAA,EACvB,4BAA4B;AAAA,EAC5B,yBAAyB;AAC3B,IAII,CAAC,MACF;AACH,MAAI,cAAc,aAAa,KAAK,cAAc,WAAW,GAAG;AAC9D,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,MAAI,gBAAuC,CAAC;AAC5C,QAAM,cAAc,MAAM,yBAAyB;AACnD,QAAM,mBAAmB,oBAAoB,eAAe,WAAW;AAEvE,MAAI,kBAAkB;AACpB,UAAM,kCAAkC,oBAAoB;AAAA,MAC1D,iBAAiB;AAAA,IACnB;AACA,QAAI,iCAAiC;AACnC,sBAAgB;AAAA,QACd,UAAU,gCAAgC;AAAA,MAC5C;AAAA,IACF;AACA,QAAI,2BAA2B;AAC7B,YAAM,iBAAiB;AAAA,QACrB,GAAG;AAAA,QACH,OAAO;AAAA,QACP,QAAQ;AAAA,MACV;AAEA,YAAM,WAAW;AAAA,QACf;AAAA,QACA;AAAA,QACA,qBAAqB,gBAAgB,gBAAgB;AAAA,MACvD;AACA,UAAI,aAAa,MAAM;AACrB;AAAA,MACF;AACA,sBAAgB;AAAA,QACd,UAAU,SAAS;AAAA,MACrB;AAAA,IACF,OAAO;AACL,YAAM,WAAW;AAAA,QACfC,eAAc,gBAAgB;AAAA,QAC9B,iBAAiB;AAAA,MACnB;AACA,YAAM,YAAY;AAAA,QAChB,iBAAiB;AAAA,QACjB,iBAAiB;AAAA,MACnB;AACA,kBAAY,KAAK,IAAI,WAAW,QAAQ;AACxC,mBAAa,KAAK,IAAI,YAAY,SAAS;AAAA,IAC7C;AAAA,EACF;AAEA,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,iBAAiBD,YAAuB,YAAY,GAAG,YAAY,CAAC;AAExE,MAAI,gBAAgB,WAAW,GAAG;AAChC,UAAM,CAAC,IAAI,EAAE,IAAI,iBAAiB,aAAa,mBAAmB;AAClE,qBAAiBA,YAAuB,IAAI,EAAE;AAAA,EAChD;AAEA,QAAM,YAGF;AAAA,IACF;AAAA,IACA,YAAY;AAAA,IACZ,YAAY;AAAA,IACZ;AAAA,IACA;AAAA,IACA,YAAY;AAAA,IACZ;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,gBAAgB,WAAW,KAAK,eAAe,QAAQ;AACzD,UAAM,UAAU,YAAY,IAAI,eAAe,CAAC;AAChD,UAAM,UAAU,YAAY,IAAI,eAAe,CAAC;AAEhD,cAAU,KAAK;AACf,cAAU,KAAK;AAEf,UAAM,UAAU,eAAe,OAAO,CAAC,EAAE,CAAC;AAC1C,UAAM,UAAU,eAAe,OAAO,CAAC,EAAE,CAAC;AAE1C,cAAU,KAAK;AACf,cAAU,KAAK;AAEf,mBAAe,SAAS,eAAe,OAAO;AAAA,MAAI,CAAC,MACjDA,YAAsB,EAAE,CAAC,IAAI,SAAS,EAAE,CAAC,IAAI,OAAO;AAAA,IACtD;AAAA,EACF;AAGA,MAAI,YAAY,GAAG;AACjB,cAAU,IAAI,UAAU,IAAI;AAAA,EAC9B;AACA,MAAI,aAAa,GAAG;AAClB,cAAU,IAAI,UAAU,IAAI;AAAA,EAC9B;AAEA,MAAI,WAAW,iBAAiB,WAAW,aAAa;AACtD,UAAM,cAAc,eAAe;AAAA,MACjC,OAAO;AAAA;AAAA,SAEJ,KAAK,KAAK,SAAS,KAAK,YAAY,MAAM,CAAC,KAAK,YAAY,MAAM,CAAC;AAAA,SACnE,KAAK,KAAK,UAAU,KAAK,YAAY,MAAM,CAAC,KAAK,YAAY,MAAM,CAAC;AAAA,MACvE;AAAA,IACF,CAAC;AAAA,EACH;AAEA,MACE,eAAe,aAAa,KAC5B,oBACA,2BACA;AACA,UAAM,WACH,YAAY,cAAc,QAAS,iBAAiB;AACvD,QAAI,WAAW,eAAe;AAC5B;AAAA,IACF;AACA,kBAAc,WAAW;AAAA,EAC3B;AAEA,MACE,cAAc,KACd,eAAe,KACf,OAAO,SAAS,UAAU,CAAC,KAC3B,OAAO,SAAS,UAAU,CAAC,GAC3B;AACA,UAAM,UAAU;AAAA,MACd,GAAG;AAAA,MACH,OAAO,KAAK,IAAI,SAAS;AAAA,MACzB,QAAQ,KAAK,IAAI,UAAU;AAAA,MAC3B,GAAG;AAAA,IACL;AAEA,UAAM,cAAc,eAAe,SAAS;AAAA,MAC1C,gBAAgB;AAAA,MAChB,YAAY;AAAA,IACd,CAAC;AAED,QAAI,oBAAoB,iBAAiB,MAAM;AAC7C,YAAM,cAAc,kBAAkB;AAAA,QACpC,UAAU,cAAc;AAAA,MAC1B,CAAC;AAAA,IACH;AACA;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,wBAAoB,eAAe,OAAO;AAAA;AAAA,MAExC,SAAS,EAAE,OAAO,WAAW,QAAQ,WAAW;AAAA,IAClD,CAAC;AAAA,EACH;AACF;AAEA,IAAM,yCAAyC,CAC7C,eACA,aACA,iBACA,UACA,UACA;AAAA,EACE,4BAA4B;AAAA,EAC5B,yBAAyB;AAC3B,IAGI,CAAC,MACF;AAEH,QAAM,CAAC,IAAI,IAAI,IAAI,EAAE,IAAI;AAAA,IACvB;AAAA,IACA,YAAY;AAAA,IACZ,YAAY;AAAA,IACZ;AAAA,EACF;AACA,QAAM,eAAeA,YAAU,IAAI,EAAE;AACrC,QAAM,mBAAmBA,YAAU,IAAI,EAAE;AACzC,QAAM,cAAcI,aAAY,cAAc,gBAAgB;AAG9D,QAAM,iBAAiBD;AAAA,IACrBH,YAAU,UAAU,QAAQ;AAAA,IAC5B;AAAA,IACA,CAAC,YAAY;AAAA,EACf;AAGA,QAAM,CAAC,MAAM,MAAM,MAAM,IAAI,IAAI;AAAA,IAC/B;AAAA,IACA,cAAc;AAAA,IACd,cAAc;AAAA,IACd;AAAA,EACF;AAEA,QAAM,qBAAqB,OAAO;AAClC,QAAM,sBAAsB,OAAO;AAInC,QAAM,qBAAqB,iBAAiB,CAAC,IAAI,aAAa,CAAC;AAC/D,QAAM,sBAAsB,iBAAiB,CAAC,IAAI,aAAa,CAAC;AAChE,MAAI,SAAS,qBAAqB;AAClC,MAAI,SAAS,sBAAsB;AAEnC,MAAI,gBAAgB,SAAS,GAAG,GAAG;AACjC,cAAU,eAAe,CAAC,IAAI,aAAa,CAAC,KAAK;AAAA,EACnD;AACA,MAAI,gBAAgB,SAAS,GAAG,GAAG;AACjC,cAAU,eAAe,CAAC,IAAI,aAAa,CAAC,KAAK;AAAA,EACnD;AACA,MAAI,gBAAgB,SAAS,GAAG,GAAG;AACjC,cAAU,iBAAiB,CAAC,IAAI,eAAe,CAAC,KAAK;AAAA,EACvD;AACA,MAAI,gBAAgB,SAAS,GAAG,GAAG;AACjC,cAAU,iBAAiB,CAAC,IAAI,eAAe,CAAC,KAAK;AAAA,EACvD;AAIA,MAAI,YAAY,cAAc,QAAQ;AACtC,MAAI,aAAa,cAAc,SAAS;AAExC,MAAI,wBAAwB;AAC1B,gBAAY,IAAI,YAAY,YAAY;AACxC,iBAAa,IAAI,aAAa,YAAY;AAAA,EAC5C;AAGA,MAAI,2BAA2B;AAC7B,UAAM,aAAa,KAAK,IAAI,SAAS,IAAI,YAAY;AACrD,UAAM,cAAc,KAAK,IAAI,UAAU,IAAI,YAAY;AACvD,QAAI,gBAAgB,WAAW,GAAG;AAChC,oBAAc;AACd,mBAAa;AAAA,IACf;AACA,QAAI,gBAAgB,WAAW,GAAG;AAChC,YAAM,QAAQ,KAAK,IAAI,YAAY,WAAW;AAC9C,kBAAY,YAAY,QAAQ,QAAQ,KAAK,KAAK,SAAS;AAC3D,mBAAa,YAAY,SAAS,QAAQ,KAAK,KAAK,UAAU;AAAA,IAChE;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,2CAA2C,CAC/C,kBACA,qBACA,aACA,iBACA,UACA,UACA;AAAA,EACE,4BAA4B;AAAA,EAC5B,yBAAyB;AAC3B,IAGI,CAAC,MACF;AACH,QAAM,wBAAwB,iBAAiB;AAAA,IAC7C,CAAC,OAAO,oBAAoB,IAAI,GAAG,EAAE;AAAA,EACvC;AAMA,QAAM,oBAAoB,sBAAsB,OAAO,CAAC,KAAK,SAAS;AACpE,QAAI,CAAC,gBAAgB,IAAI,GAAG;AAC1B,aAAO;AAAA,IACT;AACA,UAAM,SAAS,sBAAsB,IAAI;AACzC,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,IACT;AACA,UAAM,OAAO,oBAAoB,IAAI,MAAM,KAAK;AAChD,QAAI,CAAC,mBAAmB,IAAI,GAAG;AAC7B,aAAO;AAAA,IACT;AACA,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,QACE,GAAG;AAAA,QACH,GAAG,oBAAoB;AAAA,UACrB;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAyC;AAE7C,QAAM,sBAAsB;AAAA,IAC1B,sBAAsB,IAAI,CAAC,SAAS,IAAI,EAAE,OAAO,iBAAiB;AAAA,EACpE;AAEA,QAAM,EAAE,MAAM,MAAM,MAAM,MAAM,MAAM,KAAK,IAAI;AAC/C,QAAM,QAAQ,OAAO;AACrB,QAAM,SAAS,OAAO;AAEtB,QAAM,aAAa;AAAA,IACjB,IAAI,CAAC,MAAM,IAAI;AAAA,IACf,IAAI,CAAC,MAAM,IAAI;AAAA,IACf,IAAI,CAAC,MAAM,IAAI;AAAA,IACf,IAAI,CAAC,MAAM,IAAI;AAAA,IACf,GAAG,CAAC,MAAM,OAAO,SAAS,CAAC;AAAA,IAC3B,GAAG,CAAC,MAAM,OAAO,SAAS,CAAC;AAAA,IAC3B,GAAG,CAAC,OAAO,QAAQ,GAAG,IAAI;AAAA,IAC1B,GAAG,CAAC,OAAO,QAAQ,GAAG,IAAI;AAAA,EAC5B;AAIA,QAAM,CAAC,SAAS,OAAO,IAAI,yBACvB,CAAC,MAAM,IAAI,IACX,WAAW,eAAe;AAE9B,QAAM,wBAAwB,yBAAyB,IAAI;AAE3D,QAAM,QACJ,KAAK;AAAA,IACH,KAAK,IAAI,WAAW,OAAO,IAAI,SAAS;AAAA,IACxC,KAAK,IAAI,WAAW,OAAO,IAAI,UAAU;AAAA,EAC3C,IAAI;AAEN,MAAI,YACF,gBAAgB,SAAS,GAAG,KAAK,gBAAgB,SAAS,GAAG,IACzD,KAAK,IAAI,WAAW,OAAO,IAAI,wBAC/B;AACN,MAAI,aACF,gBAAgB,SAAS,GAAG,KAAK,gBAAgB,SAAS,GAAG,IACzD,KAAK,IAAI,WAAW,OAAO,IAAI,wBAC/B;AAEN,MAAI,2BAA2B;AAC7B,gBAAY,QAAQ,QAAQ,KAAK,KAAK,WAAW,OAAO;AACxD,iBAAa,SAAS,QAAQ,KAAK,KAAK,WAAW,OAAO;AAAA,EAC5D;AAEA,QAAM,oBAMF;AAAA,IACF,IAAI,CAAC,WAAW,SAAS,WAAW,OAAO;AAAA,IAC3C,IAAI,CAAC,WAAW,SAAS,WAAW,OAAO;AAAA,IAC3C,IAAI,CAAC,WAAW,SAAS,WAAW,OAAO;AAAA,IAC3C,IAAI,CAAC,WAAW,SAAS,WAAW,OAAO;AAAA;AAAA;AAAA,IAG3C,GAAG,CAAC,WAAW,SAAS,KAAK;AAAA,IAC7B,GAAG,CAAC,WAAW,SAAS,KAAK;AAAA,IAC7B,GAAG,CAAC,OAAO,WAAW,OAAO;AAAA,IAC7B,GAAG,CAAC,OAAO,WAAW,OAAO;AAAA,EAC/B;AAEA,QAAM,CAAC,SAAS,OAAO,IAAI,kBAAkB,eAAe,EAAE;AAAA,IAC5D,CAAC,cAAc;AAAA,EACjB;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,yBAAyB,CACpC,kBACA,aACA,iBACA,OACA,qBACA;AAAA,EACE,4BAA4B;AAAA,EAC5B,yBAAyB;AAAA,EACzB,UAAU;AAAA,EACV,UAAU;AAAA,EACV;AAAA,EACA;AAAA,EACA;AACF,IASI,CAAC,MACF;AAEH,MACE,cAAc,UACd,eAAe,UACf,YAAY,UACZ,YAAY,QACZ;AACA;AAAA,EACF;AAGA,MAAI,eAAe,KAAK,cAAc,GAAG;AACvC;AAAA,EACF;AAEA,MAAI,CAAC,qBAAqB;AACxB,0BAAsB;AAAA,EACxB;AAEA,QAAM,iBAAiB,iBAAiB;AAAA,IACtC,CACE,KAMA,YACG;AACH,YAAM,cAAc,oBAAqB,IAAI,QAAQ,EAAE;AACvD,UAAI,aAAa;AACf,YAAI,KAAK,EAAE,MAAM,aAAa,QAAQ,QAAQ,CAAC;AAAA,MACjD;AACA,aAAO;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EACH;AAEA,MAAI;AAEJ,MAAI,qBAAqB;AACvB,kBAAc;AAAA,EAChB,OAAO;AACL,UAAM,oBAAoB,eAAe,OAAO,CAAC,KAAK,EAAE,KAAK,MAAM;AACjE,UAAI,CAAC,gBAAgB,IAAI,GAAG;AAC1B,eAAO;AAAA,MACT;AACA,YAAM,SAAS,sBAAsB,IAAI;AACzC,UAAI,CAAC,QAAQ;AACX,eAAO;AAAA,MACT;AACA,YAAM,OAAO,oBAAqB,IAAI,MAAM,KAAK;AACjD,UAAI,CAAC,mBAAmB,IAAI,GAAG;AAC7B,eAAO;AAAA,MACT;AACA,aAAO;AAAA,QACL,GAAG;AAAA,QACH;AAAA,UACE,GAAG;AAAA,UACH,GAAG,oBAAoB;AAAA,YACrB;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF,GAAG,CAAC,CAAyC;AAE7C,kBAAc;AAAA,MACZ,eAAe,IAAI,CAAC,EAAE,KAAK,MAAM,IAAI,EAAE,OAAO,iBAAiB;AAAA,IACjE;AAAA,EACF;AACA,QAAM,EAAE,MAAM,MAAM,MAAM,MAAM,MAAM,KAAK,IAAI;AAC/C,QAAM,QAAQ,OAAO;AACrB,QAAM,SAAS,OAAO;AAEtB,MAAI,cAAc,UAAa,eAAe,QAAW;AACvD,gBAAY;AACZ,iBAAa;AAAA,EACf;AAEA,MAAI,2BAA2B;AAC7B,QAAI,cAAc,QAAW;AAC3B,kBAAY,cAAe,QAAQ;AAAA,IACrC,WAAW,eAAe,QAAW;AACnC,mBAAa,aAAc,SAAS;AAAA,IACtC,WAAW,KAAK,IAAI,YAAY,aAAa,QAAQ,MAAM,IAAI,MAAO;AACpE,kBAAY,cAAc,QAAQ;AAAA,IACpC;AAAA,EACF;AAEA,MAAI,aAAa,YAAY;AAC3B,QAAI,SACF,gBAAgB,SAAS,GAAG,KAAK,gBAAgB,SAAS,GAAG,IACzD,KAAK,IAAI,SAAS,IAAI,QACtB;AACN,QAAI,SACF,gBAAgB,SAAS,GAAG,KAAK,gBAAgB,SAAS,GAAG,IACzD,KAAK,IAAI,UAAU,IAAI,SACvB;AAEN,QAAI;AAEJ,QAAI,gBAAgB,WAAW,GAAG;AAChC,cACE,gBAAgB,SAAS,GAAG,KAAK,gBAAgB,SAAS,GAAG,IACzD,SACA;AAAA,IACR,OAAO;AACL,cAAQ,KAAK;AAAA,QACX,KAAK,IAAI,SAAS,IAAI,SAAS;AAAA,QAC/B,KAAK,IAAI,UAAU,IAAI,UAAU;AAAA,MACnC;AAAA,IACF;AAEA,UAAM,aAAa;AAAA,MACjB,IAAI,CAAC,MAAM,IAAI;AAAA,MACf,IAAI,CAAC,MAAM,IAAI;AAAA,MACf,IAAI,CAAC,MAAM,IAAI;AAAA,MACf,IAAI,CAAC,MAAM,IAAI;AAAA,MACf,GAAG,CAAC,MAAM,OAAO,SAAS,CAAC;AAAA,MAC3B,GAAG,CAAC,MAAM,OAAO,SAAS,CAAC;AAAA,MAC3B,GAAG,CAAC,OAAO,QAAQ,GAAG,IAAI;AAAA,MAC1B,GAAG,CAAC,OAAO,QAAQ,GAAG,IAAI;AAAA,IAC5B;AAIA,UAAM,CAAC,SAAS,OAAO,IAAI,yBACvB,CAAC,MAAM,IAAI,IACX,WAAW,eAAe;AAE9B,UAAM,kBACJ,6BACA,eAAe;AAAA,MACb,CAAC,SACC,KAAK,OAAO,UAAU,KACtB,cAAc,KAAK,MAAM,KACzB,UAAU,KAAK,MAAM;AAAA,IACzB;AAEF,QAAI,iBAAiB;AACnB,eAAS;AACT,eAAS;AAAA,IACX;AAUA,UAAM,CAAC,aAAa,WAAW,IAAI,CAAC,UAAU,KAAK,GAAG,UAAU,KAAK,CAAC;AAEtE,UAAM,qBAaA,CAAC;AAEP,eAAW,EAAE,MAAM,OAAO,KAAK,gBAAgB;AAE7C,UAAI,cAAc,IAAI,KAAK,mBAAmB,IAAI,GAAG;AACnD;AAAA,MACF;AAEA,YAAMK,SAAQ,KAAK,QAAQ;AAC3B,YAAMC,UAAS,KAAK,SAAS;AAC7B,YAAM,QAAQR;AAAA,QACX,KAAK,QAAQ,cAAc;AAAA,MAC9B;AAEA,YAAM,qBACJ,gBAAgB,IAAI,KAAK,kBAAkB,IAAI;AACjD,YAAM,UAAU,KAAK,IAAI;AACzB,YAAM,UAAU,KAAK,IAAI;AACzB,YAAM,SAAS,WAAW,CAAC,qBAAqBO,SAAQ;AACxD,YAAM,SAAS,WAAW,CAAC,qBAAqBC,UAAS;AACzD,YAAM,IAAI,UAAU,eAAe,UAAU,SAAS;AACtD,YAAM,IAAI,UAAU,eAAe,UAAU,SAAS;AAEtD,YAAM,iBAAiB;AAAA,QACrB;AAAA,QACAD,SAAQ;AAAA,QACRC,UAAS;AAAA,QACT;AAAA,MACF;AAEA,YAAM,SAAiD;AAAA,QACrD;AAAA,QACA;AAAA,QACA,OAAAD;AAAA,QACA,QAAAC;AAAA,QACA;AAAA,QACA,GAAG;AAAA,MACL;AAEA,UAAI,aAAa,IAAI,GAAG;AAGtB,YAAI,KAAK,cAAc;AACrB,iBAAO,eAAe;AAAA,YACpB,GAAG,KAAK;AAAA,YACR,YAAY;AAAA,cACV,UACI,CAAC,KAAK,aAAa,WAAW,CAAC,IAAI,IACnC,KAAK,aAAa,WAAW,CAAC;AAAA,cAClC,UACI,CAAC,KAAK,aAAa,WAAW,CAAC,IAAI,IACnC,KAAK,aAAa,WAAW,CAAC;AAAA,YACpC;AAAA,UACF;AAAA,QACF;AACA,YAAI,KAAK,YAAY;AACnB,iBAAO,aAAa;AAAA,YAClB,GAAG,KAAK;AAAA,YACR,YAAY;AAAA,cACV,UACI,CAAC,KAAK,WAAW,WAAW,CAAC,IAAI,IACjC,KAAK,WAAW,WAAW,CAAC;AAAA,cAChC,UACI,CAAC,KAAK,WAAW,WAAW,CAAC,IAAI,IACjC,KAAK,WAAW,WAAW,CAAC;AAAA,YAClC;AAAA,UACF;AAAA,QACF;AACA,YAAI,KAAK,iBAAiB,eAAe,QAAQ;AAC/C,iBAAO,gBAAgB,KAAK,cAAc,IAAI,CAAC,aAAa;AAAA,YAC1D,GAAG;AAAA,YACH,OAAO,eAAe,OAAO,QAAQ,QAAQ,CAAC;AAAA,YAC9C,KAAK,eAAe,OAAO,QAAQ,KAAK;AAAA,UAC1C,EAAE;AAAA,QACJ;AAAA,MACF;AAEA,UAAI,eAAe,IAAI,GAAG;AACxB,eAAO,QAAQ;AAAA,UACb,KAAK,MAAM,CAAC,IAAI;AAAA,UAChB,KAAK,MAAM,CAAC,IAAI;AAAA,QAClB;AAAA,MACF;AAEA,UAAI,cAAc,IAAI,GAAG;AACvB,cAAM,UAAU,yBAAyB,MAAM,aAAaD,MAAK;AACjE,YAAI,CAAC,SAAS;AACZ;AAAA,QACF;AACA,eAAO,WAAW,QAAQ;AAAA,MAC5B;AAEA,YAAM,mBAAmB,oBAAoB;AAAA,QAC3C,sBAAsB,IAAI,KAAK;AAAA,MACjC;AAEA,UAAI,kBAAkB;AACpB,YAAI,iBAAiB;AACnB,gBAAM,cAAc,iBAAiB,WAAW;AAChD,cAAI,cAAc,eAAe;AAC/B;AAAA,UACF;AACA,iBAAO,oBAAoB;AAAA,QAC7B,OAAO;AACL,iBAAO,oBAAoB,iBAAiB;AAAA,QAC9C;AAAA,MACF;AAEA,yBAAmB,KAAK;AAAA,QACtB,SAAS;AAAA,QACT;AAAA,MACF,CAAC;AAAA,IACH;AAEA,UAAM,mBAAmB,mBAAmB,IAAI,CAAC,EAAE,QAAQ,MAAM,OAAO;AAExE,eAAW;AAAA,MACT;AAAA,MACA,QAAQ,EAAE,mBAAmB,GAAG,OAAO;AAAA,IACzC,KAAK,oBAAoB;AACvB,YAAM,EAAE,OAAAA,QAAO,QAAAC,SAAQ,MAAM,IAAI;AAEjC,YAAM,cAAc,SAAS,MAAM;AAEnC,0BAAoB,SAAS,OAAO;AAAA,QAClC,uBAAuB;AAAA,QACvB,SAAS,EAAE,OAAAD,QAAO,QAAAC,QAAO;AAAA,MAC3B,CAAC;AAED,YAAM,mBAAmB,oBAAoB,SAAS,WAAW;AACjE,UAAI,oBAAoB,mBAAmB;AACzC,cAAM,cAAc,kBAAkB;AAAA,UACpC,UAAU;AAAA,UACV,OAAO,gBAAgB,OAAO,IAAI,SAAY;AAAA,QAChD,CAAC;AACD,6BAAqB,SAAS,OAAO,iBAAiB,IAAI;AAAA,MAC5D;AAAA,IACF;AAEA,UAAM,cAAc;AAAA,EACtB;AACF;;;ACh4CA;AAAA;AAAA,EACE,aAAAC;AAAA,EACA;AAAA,EACA,mBAAAC;AAAA,OAEK;AAEP,SAAS,+BAA+B;;;ACPxC;AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,SAAS,aAAAC,aAAW,mBAAAC,yBAAuB;AA4C3C,IAAM,uBAAuD;AAAA,EAC3D,OAAO;AAAA,EACP,KAAK;AAAA,EACL,OAAO;AACT;AAEA,IAAM,6BAA6B;AAE5B,IAAM,qBAAqB;AAAA,EAChC,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AACL;AAEO,IAAM,mCAAmC;AAAA,EAC9C,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AACL;AAEO,IAAM,uBAAuB;AAAA,EAClC,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,UAAU;AACZ;AAEA,IAAM,4BAA4B;AAAA,EAChC,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,IAAI;AACN;AAEA,IAAM,gCAAgC;AAAA,EACpC,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AACL;AAEA,IAAM,0BAA0B,CAC9B,GACA,GACA,OACA,QACA,IACA,IACA,UACoB;AACpB,QAAM,CAAC,IAAI,EAAE,IAAIC;AAAA,IACfC,YAAU,IAAI,QAAQ,GAAG,IAAI,SAAS,CAAC;AAAA,IACvCA,YAAU,IAAI,EAAE;AAAA,IAChB;AAAA,EACF;AACA,SAAO,CAAC,KAAK,QAAQ,GAAG,KAAK,SAAS,GAAG,OAAO,MAAM;AACxD;AAEO,IAAM,qBAAqB,CAAC,WAAmB;AACpD,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,kBAAkB,aAAa,QAAQ;AAChD,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,IAAM,wBAAwB,CAAC,WAAmB;AACvD,MAAI,mBAAmB,MAAM,GAAG;AAC9B,WAAO;AAAA,EACT;AAEA,SAAO,CAAC;AACV;AAEO,IAAM,gCAAgC,CAC3C,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,GACvB,OACA,MACA,aACA,YAAsD,CAAC,GACvD,SAAS,GACT,UAAU,qCACW;AACrB,QAAM,OAAO,qBAAqB,WAAW;AAC7C,QAAM,cAAc,OAAO,KAAK;AAChC,QAAM,eAAe,OAAO,KAAK;AAEjC,QAAM,gBAAgB,OAAO,KAAK;AAClC,QAAM,gBAAgB,OAAO,KAAK;AAElC,QAAM,QAAQ,KAAK;AACnB,QAAM,SAAS,KAAK;AACpB,QAAM,mBAAmB,SAAS,KAAK;AACvC,QAAM,mBAAmB,OAAO,UAAU,MAAM,IAAI,KAAK;AAEzD,QAAM,mBAAqC;AAAA,IACzC,IAAI,UAAU,KACV,SACA;AAAA,MACE,KAAK,mBAAmB,gBAAgB;AAAA,MACxC,KAAK,mBAAmB,gBAAgB;AAAA,MACxC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACJ,IAAI,UAAU,KACV,SACA;AAAA,MACE,KAAK,mBAAmB;AAAA,MACxB,KAAK,mBAAmB,gBAAgB;AAAA,MACxC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACJ,IAAI,UAAU,KACV,SACA;AAAA,MACE,KAAK,mBAAmB,gBAAgB;AAAA,MACxC,KAAK,mBAAmB;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACJ,IAAI,UAAU,KACV,SACA;AAAA,MACE,KAAK,mBAAmB;AAAA,MACxB,KAAK,mBAAmB;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACJ,UAAU,UAAU,WAChB,SACA;AAAA,MACE,KAAK,QAAQ,IAAI,cAAc;AAAA,MAC/B,KACE,mBACA,gBACA,kBACA,6BAA6B,KAAK;AAAA,MACpC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACN;AAIA,QAAM,6BACH,IAAI,qBAAqB,QAAS,KAAK;AAC1C,MAAI,KAAK,IAAI,KAAK,IAAI,4BAA4B;AAChD,QAAI,CAAC,UAAU,GAAG;AAChB,uBAAiB,IAAI;AAAA,QACnB,KAAK,QAAQ,IAAI,cAAc;AAAA,QAC/B,KAAK,mBAAmB,gBAAgB;AAAA,QACxC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,UAAU,GAAG;AAChB,uBAAiB,IAAI;AAAA,QACnB,KAAK,QAAQ,IAAI,cAAc;AAAA,QAC/B,KAAK,mBAAmB;AAAA,QACxB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,MAAI,KAAK,IAAI,MAAM,IAAI,4BAA4B;AACjD,QAAI,CAAC,UAAU,GAAG;AAChB,uBAAiB,IAAI;AAAA,QACnB,KAAK,mBAAmB,gBAAgB;AAAA,QACxC,KAAK,SAAS,IAAI,eAAe;AAAA,QACjC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,UAAU,GAAG;AAChB,uBAAiB,IAAI;AAAA,QACnB,KAAK,mBAAmB;AAAA,QACxB,KAAK,SAAS,IAAI,eAAe;AAAA,QACjC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,sBAAsB,CACjC,SACA,MACA,aACA,cAA2B,SAC3B,YAAsD,uBACjC;AAIrB,MACE,QAAQ;AAAA,EAER,aAAa,OAAO,GACpB;AACA,WAAO,CAAC;AAAA,EACV;AAEA,MAAI,QAAQ,SAAS,cAAc,gBAAgB,OAAO,GAAG;AAC3D,QAAI,QAAQ,OAAO,WAAW,GAAG;AAE/B,YAAM,CAAC,EAAE,EAAE,IAAI,QAAQ;AACvB,UAAI,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,MAAM,GAAG;AAC9B,oBAAY;AAAA,MACd,WAAW,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,GAAG;AACjC,oBAAY;AAAA,MACd,WAAW,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,GAAG;AACjC,oBAAY;AAAA,MACd,WAAW,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,GAAG;AACjC,oBAAY;AAAA,MACd,WAAW,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,GAAG;AACjC,oBAAY;AAAA,MACd;AAAA,IACF;AAAA,EACF,WAAW,mBAAmB,OAAO,GAAG;AACtC,gBAAY;AAAA,MACV,GAAG;AAAA,MACH,UAAU;AAAA,IACZ;AAAA,EACF;AACA,QAAM,SAAS,gBAAgB,OAAO,IAClC,mCAAmC,IACnC,eAAe,OAAO,IACtB,IACA;AACJ,SAAO;AAAA,IACLC,0BAAyB,SAAS,aAAa,IAAI;AAAA,IACnD,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,eAAe,OAAO,IAAI,IAAI;AAAA,EAChC;AACF;AAEO,IAAM,wBAAwB,CACnC,UACA,aACG;AACH,MAAI,SAAS,sBAAsB;AACjC,WAAO;AAAA,EACT;AACA,MAAI,SAAS,SAAS,GAAG;AACvB,WAAO;AAAA,EACT;AACA,QAAM,UAAU,SAAS,CAAC;AAC1B,MAAI,aAAa,OAAO,GAAG;AAEzB,WAAO;AAAA,EACT;AACA,MAAI,CAAC,gBAAgB,OAAO,GAAG;AAC7B,WAAO;AAAA,EACT;AAEA,SAAO,QAAQ,OAAO,SAAS;AACjC;;;ADzTA,IAAM,0BAA0B,CAC9B,iBACA,GACA,MAEA,KAAK,gBAAgB,CAAC,KACtB,KAAK,gBAAgB,CAAC,IAAI,gBAAgB,CAAC,KAC3C,KAAK,gBAAgB,CAAC,KACtB,KAAK,gBAAgB,CAAC,IAAI,gBAAgB,CAAC;AAEtC,IAAM,aAAa,CACxB,SACA,aACA,UACA,GACA,GACA,MACA,aACA,WAC6B;AAC7B,MAAI,CAAC,SAAS,mBAAmB,QAAQ,EAAE,GAAG;AAC5C,WAAO;AAAA,EACT;AAEA,QAAM,EAAE,UAAU,yBAAyB,GAAG,iBAAiB,IAC7D;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,sBAAsB,MAAM;AAAA,EAC9B;AAEF,MACE,2BACA,wBAAwB,yBAAyB,GAAG,CAAC,GACrD;AACA,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,OAAO,KAAK,gBAAgB,EAAE,OAAO,CAAC,QAAQ;AAC3D,UAAM,kBACJ,iBAAiB,GAA+C;AAClE,QAAI,CAAC,iBAAiB;AACpB,aAAO;AAAA,IACT;AACA,WAAO,wBAAwB,iBAAiB,GAAG,CAAC;AAAA,EACtD,CAAC;AAED,MAAI,OAAO,SAAS,GAAG;AACrB,WAAO,OAAO,CAAC;AAAA,EACjB;AAEA,MAAI,mBAAmB,MAAM,GAAG;AAC9B,UAAM,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,IAAIC;AAAA,MAC/B;AAAA,MACA;AAAA,IACF;AAGA,QAAI,EAAE,gBAAgB,OAAO,KAAK,QAAQ,OAAO,UAAU,IAAI;AAC7D,YAAM,UAAU,eAAe,OAAO,IAClC,IACA,0BAA0B,KAAK;AACnC,YAAM,iCACJ,0BAA0B,KAAK;AACjC,YAAM,QAAQ;AAAA,QACZC,YAAU,KAAK,SAAS,KAAK,OAAO;AAAA,QACpCA,YAAU,KAAK,SAAS,KAAK,OAAO;AAAA,QACpCA,YAAU,IAAI,EAAE;AAAA,QAChB,QAAQ;AAAA,MACV;AAEA,iBAAW,CAAC,KAAK,IAAI,KAAK,OAAO,QAAQ,KAAK,GAAG;AAE/C,YACE;AAAA,UACEA,YAAU,GAAG,CAAC;AAAA,UACd;AAAA,UACA;AAAA,QACF,GACA;AACA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,oCAAoC,CAC/C,UACA,UACA,eACA,eACA,MACA,aACA,aACA,WACG;AACH,SAAO,SAAS,OAAO,CAAC,QAAQ,YAAY;AAC1C,QAAI,QAAQ;AACV,aAAO;AAAA,IACT;AACA,UAAM,sBAAsB;AAAA,MAC1B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,sBAAsB,EAAE,SAAS,oBAAoB,IAAI;AAAA,EAClE,GAAG,IAAsG;AAC3G;AAEO,IAAM,mCAAmC,CAG9C,CAAC,IAAI,IAAI,IAAI,EAAE,GACf,eACA,eACA,MACA,aACA,WAC6B;AAC7B,QAAM,mBAAmB;AAAA,IACvB,CAAC,IAAI,IAAI,IAAI,KAAK,KAAK,MAAM,IAAI,KAAK,MAAM,CAAC;AAAA,IAC7C;AAAA,IACA;AAAA,IACA;AAAA,IACA,sBAAsB,MAAM;AAAA,EAC9B;AAEA,QAAM,QAAQ,OAAO,KAAK,gBAAgB,EAAE,KAAK,CAAC,QAAQ;AACxD,UAAM,kBACJ,iBAAiB,GAA+C;AAClE,WACE,mBACA,wBAAwB,iBAAiB,eAAe,aAAa;AAAA,EAEzE,CAAC;AAED,MAAI,OAAO;AACT,WAAO;AAAA,EACT;AAEA,MAAI,mBAAmB,MAAM,GAAG;AAC9B,UAAM,MAAM,KAAK,MAAM;AACvB,UAAM,MAAM,KAAK,MAAM;AAEvB,UAAM,UAAU,0BAA0B,KAAK;AAE/C,UAAM,QAAQ;AAAA,MACZA,YAAU,KAAK,SAAS,KAAK,OAAO;AAAA,MACpCA,YAAU,KAAK,SAAS,KAAK,OAAO;AAAA,MACpCA,YAAU,IAAI,EAAE;AAAA,MAChB;AAAA,IACF;AAEA,eAAW,CAAC,KAAK,IAAI,KAAK,OAAO,QAAQ,KAAK,GAAG;AAE/C,UACE;AAAA,QACEA,YAAU,eAAe,aAAa;AAAA,QACtC;AAAA,QACA;AAAA,MACF,GACA;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,IAAM,iBAAiB,CAAC,MAAM,QAAQ,MAAM,MAAM;AAClD,IAAM,qBAAqB,CAAC,QAAgB,UAAkB;AAC5D,QAAM,QAAQ,eAAe,QAAQ,MAAM;AAC3C,MAAI,SAAS,GAAG;AACd,UAAMC,KAAI,KAAK,MAAM,SAAS,KAAK,KAAK,EAAE;AAC1C,aAAS,gBAAgB,QAAQA,MAAK,eAAe,MAAM;AAAA,EAC7D;AACA,SAAO;AACT;AAKO,IAAM,8BAA8B,CAAC,oBAG9B;AACZ,QAAM,EAAE,SAAS,oBAAoB,IAAI;AACzC,QAAM,oBACJ,WAAW,KAAK,KAAK,QAAQ,MAAM,IAAI,KAAK,KAAK,QAAQ,KAAK,MAAM;AACtE,MAAI,SAAS;AAEb,UAAQ,qBAAqB;AAAA,IAC3B,KAAK;AAAA,IACL,KAAK;AACH,eAAS;AACT;AAAA,IACF,KAAK;AAAA,IACL,KAAK;AACH,eAAS;AACT;AAAA,IACF,KAAK;AAAA,IACL,KAAK;AACH,UAAI,mBAAmB;AACrB,iBAAS;AAAA,MACX,OAAO;AACL,iBAAS;AAAA,MACX;AACA;AAAA,IACF,KAAK;AAAA,IACL,KAAK;AACH,UAAI,mBAAmB;AACrB,iBAAS;AAAA,MACX,OAAO;AACL,iBAAS;AAAA,MACX;AACA;AAAA,IACF,KAAK;AACH,aAAO;AAAA,EACX;AAEA,MAAI,UAAU,SAAS;AACrB,aAAS,mBAAmB,QAAQ,QAAQ,KAAK;AAAA,EACnD;AAEA,SAAO,SAAS,GAAG,MAAM,YAAY;AACvC;AAEA,IAAM,sBAAsB,CAC1B,CAAC,IAAI,EAAE,GACP,CAAC,IAAI,EAAE,GACP,QACA,UACG;AACH,QAAM,UAAUC,kBAAgBF,YAAU,IAAI,EAAE,GAAG,QAAQ,KAAK;AAChE,QAAM,WAAWE,kBAAgBF,YAAU,IAAI,EAAE,GAAG,QAAQ,KAAK;AACjE,QAAM,aAAaE,kBAAgBF,YAAU,IAAI,EAAE,GAAG,QAAQ,KAAK;AACnE,QAAM,cAAcE,kBAAgBF,YAAU,IAAI,EAAE,GAAG,QAAQ,KAAK;AAEpE,SAAO;AAAA,IACL,GAAG,CAAC,SAAS,QAAQ;AAAA,IACrB,GAAG,CAAC,UAAU,WAAW;AAAA,IACzB,GAAG,CAAC,aAAa,UAAU;AAAA,IAC3B,GAAG,CAAC,YAAY,OAAO;AAAA,EACzB;AACF;;;AElSA;AAMO,IAAM,2BAA2B,CACtC,UACA,aAEA;AAAA,EACE,CAAC,SAAS,mBACR,SAAS,YAAY,SAAS,0BAC5B,SAAS,WAAW,SAAS,aAC5B,SAAS,sBACP,SAAS,WAAW,SAAS,eAC5B,SAAS,WAAW,SAAS,WAC7B,SAAS,WAAW,SAAS,YAC7B,SAAS,WAAW,SAAS,UAC7B,SAAS,WAAW,SAAS,YACjC,oBAAoB,UAAU,QAAQ,EAAE;AAC9C;;;ACrBF;AAAA,SAAS,cAAAG,cAAY,WAAW,iBAAAC,sBAAqB;AAgBrD,IAAM,kBAAkB,CAAC,SAA4B,YAAoB;AACvE,SAAO,QAAQ,YAAY,WAAW,QAAQ,OAAO;AACvD;AAUA,IAAM,mBAAmB,CACvB,UACA,UACA,sBACG;AACH,MAAI,kBAA4B,CAAC;AACjC,MAAI,iBAA2B,CAAC;AAChC,MAAI,sBAAsB;AAC1B,MAAI,QAAQ;AACZ,QAAM,qBAAqBC;AAAA,IACzB,oBACI,oBACA,oBAAoB,UAAU,UAAU;AAAA,MACtC,yBAAyB;AAAA,MACzB,yBAAyB;AAAA,IAC3B,CAAC;AAAA,EACP;AACA,SAAO,EAAE,QAAQ,SAAS,QAAQ;AAChC,UAAM,UAAU,SAAS,KAAK;AAC9B,QAAI,mBAAmB,IAAI,QAAQ,EAAE,GAAG;AACtC,UAAI,eAAe,QAAQ;AACzB,0BAAkB,gBAAgB,OAAO,cAAc;AACvD,yBAAiB,CAAC;AAAA,MACpB;AACA,sBAAgB,KAAK,KAAK;AAC1B,4BAAsB,QAAQ;AAAA,IAChC,WAAW,QAAQ,aAAa,wBAAwB,OAAO;AAC7D,4BAAsB,QAAQ;AAC9B,qBAAe,KAAK,KAAK;AAAA,IAC3B,OAAO;AACL,uBAAiB,CAAC;AAAA,IACpB;AAAA,EACF;AACA,SAAO;AACT;AAEA,IAAM,qBAAqB,CAAC,UAAoB;AAC9C,MAAI,SAAS;AACb,SAAO,MAAM,OAAO,CAAC,KAAK,OAAO,UAAU;AACzC,QAAI,QAAQ,KAAK,MAAM,QAAQ,CAAC,MAAM,QAAQ,GAAG;AAC/C,eAAS,EAAE;AAAA,IACb;AACA,KAAC,IAAI,MAAM,MAAM,IAAI,MAAM,IAAI,CAAC,IAAI,KAAK,KAAK;AAC9C,WAAO;AAAA,EACT,GAAG,CAAC,CAAe;AACrB;AAOA,IAAM,qCAAqC,CACzC,aACA,UACA,WACA,UACG;AACH,MAAI,iBAAiB,eAAe,YAAY,aAAa;AAE3D,UAAM,mBAAmB,MAAM,WAAW,YAAY,WAAW;AACjE,QAAI,kBAAkB;AACpB,aAAO,cAAc,SACjB,KAAK;AAAA,QACH,SAAS,QAAQ,gBAAgB;AAAA,QACjC,SAAS,QAAQ,WAAW;AAAA,MAC9B,IACA,KAAK;AAAA,QACH,SAAS,QAAQ,gBAAgB;AAAA,QACjC,SAAS,QAAQ,WAAW;AAAA,MAC9B;AAAA,IACN;AAAA,EACF,OAAO;AACL,UAAM,iBAAiB,YAAY,eAAe;AAAA,MAChD,CAAC,YAAY,QAAQ,SAAS;AAAA,IAChC,GAAG;AACH,QAAI,gBAAgB;AAClB,YAAM,mBAAmB,MAAM,WAAW,cAAc;AACxD,UAAI,kBAAkB;AACpB,eAAO,cAAc,SACjB,KAAK;AAAA,UACH,SAAS,QAAQ,gBAAgB;AAAA,UACjC,SAAS,QAAQ,WAAW;AAAA,QAC9B,IACA,KAAK;AAAA,UACH,SAAS,QAAQ,gBAAgB;AAAA,UACjC,SAAS,QAAQ,WAAW;AAAA,QAC9B;AAAA,MACN;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,kCAAkC,CACtC,aACA,YACG;AACH,MAAI,aAAa;AACjB,MAAI,WAAW;AACf,cAAY,QAAQ,CAAC,SAAS,UAAU;AACtC,QAAI,gBAAgB,SAAS,OAAO,GAAG;AACrC,UAAI,eAAe,IAAI;AACrB,qBAAa;AAAA,MACf;AACA,iBAAW;AAAA,IACb;AAAA,EACF,CAAC;AACD,MAAI,eAAe,IAAI;AACrB,WAAO,CAAC;AAAA,EACV;AACA,SAAO,YAAY,MAAM,YAAY,WAAW,CAAC;AACnD;AAMA,IAAM,iBAAiB,CACrB,UACA,UACA,eACA,WAKA,iBACA,UACG;AACH,QAAM,gBAAgB,SAAS,aAAa;AAE5C,QAAM,cAAc,CAAC,YAA+B;AAClD,QAAI,QAAQ,WAAW;AACrB,aAAO;AAAA,IACT;AACA,QAAI,iBAAiB;AACnB,aAAO,QAAQ,YAAY;AAAA,IAC7B;AAGA,QAAI,SAAS,gBAAgB;AAC3B,aAAO,QAAQ,SAAS,SAAS,SAAS,cAAc;AAAA,IAC1D;AACA,WAAO;AAAA,EACT;AAEA,QAAM,iBACJ,cAAc,SACVC;AAAA,IACE;AAAA,IACA,CAAC,OAAO,YAAY,EAAE;AAAA,IACtB,KAAK,IAAI,GAAG,gBAAgB,CAAC;AAAA,EAC/B,IACA,UAAU,UAAU,CAAC,OAAO,YAAY,EAAE,GAAG,gBAAgB,CAAC;AAEpE,QAAM,cAAc,SAAS,cAAc;AAE3C,MAAI,CAAC,aAAa;AAChB,WAAO;AAAA,EACT;AAEA,MAAI,SAAS,gBAAgB;AAC3B;AAAA;AAAA,MAEE,eAAe,SAAS,KAAK,EAAE,MAAM,aAAa,SAAS,KAAK,EAAE;AAAA,MAClE;AACA,aACE;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,KAAK;AAAA,IAET,WAAW,CAAC,aAAa,SAAS,SAAS,SAAS,cAAc,GAAG;AAEnE,aAAO;AAAA,IACT;AAAA,EACF;AAEA,MACE,CAAC,oBACA,YAAY,WAAW,mBAAmB,WAAW,IACtD;AACA,UAAM,gBAAgB;AAAA,MACpB;AAAA,MACA,YAAY,WAAW,YAAY;AAAA,IACrC;AACA,WAAO,cAAc,SACjB,SAAS,QAAQ,cAAc,CAAC,CAAC,IACjC,SAAS,QAAQ,cAAc,cAAc,SAAS,CAAC,CAAC;AAAA,EAC9D;AAEA,MAAI,CAAC,YAAY,SAAS,QAAQ;AAChC,WACE;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,KAAK;AAAA,EAET;AAEA,QAAM,iBAAiB,SAAS,iBAC5B,YAAY,SACV,YAAY,SAAS,QAAQ,SAAS,cAAc,IAAI,CAC1D,IACA,YAAY,SAAS,YAAY,SAAS,SAAS,CAAC;AAExD,QAAM,yBAAyB,mBAAmB,UAAU,cAAc;AAE1E,MAAI,uBAAuB,QAAQ;AAGjC,WAAO,cAAc,SACjB,SAAS,QAAQ,uBAAuB,CAAC,CAAC,IAC1C,SAAS;AAAA,MACP,uBAAuB,uBAAuB,SAAS,CAAC;AAAA,IAC1D;AAAA,EACN;AAEA,SAAO;AACT;AAEA,IAAM,uBAAuB,CAC3B,UACA,YACG;AACH,SAAO,QAAQ,OAAO,CAAC,KAAK,UAAU;AACpC,UAAM,UAAU,SAAS,KAAK;AAC9B,QAAI,IAAI,QAAQ,IAAI,OAAO;AAC3B,WAAO;AAAA,EACT,GAAG,oBAAI,IAA+B,CAAC;AACzC;AAEA,IAAM,qBAAqB,CACzB,UACA,UACA,WACA,UACG;AACH,QAAM,gBAAgB,iBAAiB,UAAU,QAAQ;AACzD,QAAM,oBAAoB,qBAAqB,UAAU,aAAa;AAEtE,MAAI,iBAAiB,mBAAmB,aAAa;AAErD,MAAI,cAAc,SAAS;AACzB,qBAAiB,eAAe,QAAQ;AAAA,EAC1C;AAEA,QAAM,iBAAiB,IAAI;AAAA,IACzB,cACG,OAAO,CAAC,QAAQ,mBAAmB,SAAS,GAAG,CAAC,CAAC,EACjD,IAAI,CAAC,QAAQ,SAAS,GAAG,EAAE,EAAE;AAAA,EAClC;AAEA,iBAAe,QAAQ,CAAC,SAAS,MAAM;AACrC,UAAM,eAAe,QAAQ,CAAC;AAC9B,UAAM,gBAAgB,QAAQ,QAAQ,SAAS,CAAC;AAChD,UAAM,gBAAgB,cAAc,SAAS,eAAe;AAE5D,UAAM,kBAAkB,QAAQ,KAAK,CAAC,QAAQ;AAC5C,YAAM,KAAK,SAAS,GAAG;AACvB,aAAO,GAAG,WAAW,eAAe,IAAI,GAAG,OAAO;AAAA,IACpD,CAAC,IACG,OACA,SAAS,aAAa,GAAG;AAE7B,UAAM,cAAc;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,QAAI,gBAAgB,MAAM,kBAAkB,aAAa;AACvD;AAAA,IACF;AAEA,UAAM,kBACJ,cAAc,SACV,SAAS,MAAM,GAAG,WAAW,IAC7B,SAAS,MAAM,GAAG,YAAY;AACpC,UAAM,iBAAiB,SAAS,MAAM,cAAc,gBAAgB,CAAC;AACrE,UAAM,oBACJ,cAAc,SACV,SAAS,MAAM,aAAa,YAAY,IACxC,SAAS,MAAM,gBAAgB,GAAG,cAAc,CAAC;AACvD,UAAM,mBACJ,cAAc,SACV,SAAS,MAAM,gBAAgB,CAAC,IAChC,SAAS,MAAM,cAAc,CAAC;AAEpC,eACE,cAAc,SACV;AAAA,MACE,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,IACL,IACA;AAAA,MACE,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAAA,EACR,CAAC;AAED,mBAAiB,UAAU,iBAAiB;AAE5C,SAAO;AACT;AAEA,IAAM,qBAAqB,CACzB,UACA,UACA,WACA,iBACA,sBACG;AACH,QAAM,gBAAgB,iBAAiB,UAAU,UAAU,iBAAiB;AAC5E,QAAM,oBAAoB,qBAAqB,UAAU,aAAa;AACtE,QAAM,oBAAyC,CAAC;AAEhD,MAAI;AACJ,MAAI;AACJ,MAAI,cAAc,QAAQ;AACxB,QAAI,iBAAiB;AACnB,qBAAe;AAAA,QAAU;AAAA,QAAU,CAAC,OAClC,gBAAgB,IAAI,eAAe;AAAA,MACrC;AAAA,IACF,WAAW,SAAS,gBAAgB;AAClC,YAAM,gBAAgB;AAAA,QACpB;AAAA,QACA,SAAS;AAAA,MACX;AACA,UAAI,CAAC,cAAc,QAAQ;AACzB,eAAO;AAAA,MACT;AACA,qBAAe,SAAS,QAAQ,cAAc,CAAC,CAAC;AAAA,IAClD,OAAO;AACL,qBAAe;AAAA,IACjB;AAEA,oBAAgB,cAAc,cAAc,SAAS,CAAC;AAAA,EACxD,OAAO;AACL,QAAI,iBAAiB;AACnB,sBAAgBA;AAAA,QAAc;AAAA,QAAU,CAAC,OACvC,gBAAgB,IAAI,eAAe;AAAA,MACrC;AAAA,IACF,WAAW,SAAS,gBAAgB;AAClC,YAAM,gBAAgB;AAAA,QACpB;AAAA,QACA,SAAS;AAAA,MACX;AACA,UAAI,CAAC,cAAc,QAAQ;AACzB,eAAO;AAAA,MACT;AACA,sBAAgB,SAAS,QAAQ,cAAc,cAAc,SAAS,CAAC,CAAC;AAAA,IAC1E,OAAO;AACL,sBAAgB,SAAS,SAAS;AAAA,IACpC;AAEA,mBAAe,cAAc,CAAC;AAAA,EAChC;AAEA,MAAI,iBAAiB,IAAI;AACvB,mBAAe;AAAA,EACjB;AAEA,WAAS,QAAQ,cAAc,QAAQ,gBAAgB,GAAG,SAAS;AACjE,QAAI,CAAC,cAAc,SAAS,KAAK,GAAG;AAClC,wBAAkB,KAAK,SAAS,KAAK,CAAC;AAAA,IACxC;AAAA,EACF;AAEA,QAAM,iBAAiB,MAAM,KAAK,kBAAkB,OAAO,CAAC;AAC5D,QAAM,kBAAkB,SAAS,MAAM,GAAG,YAAY;AACtD,QAAM,mBAAmB,SAAS,MAAM,gBAAgB,CAAC;AACzD,QAAM,eACJ,cAAc,SACV;AAAA,IACE,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,EACL,IACA;AAAA,IACE,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,IACH,GAAG;AAAA,EACL;AAEN,mBAAiB,cAAc,iBAAiB;AAEhD,SAAO;AACT;AAEA,SAAS,iCACP,aACA,UACA,WACA,eAOA;AACA,QAAM,iBAAiBD;AAAA,IACrB,oBAAoB,aAAa,UAAU;AAAA,MACzC,yBAAyB;AAAA,MACzB,yBAAyB;AAAA,IAC3B,CAAC;AAAA,EACH;AAEA,QAAM,qCAGF,EAAE,iBAAiB,CAAC,GAAG,eAAe,oBAAI,IAAI,EAAE;AAEpD,QAAM,sBAAsB,oBAAI,IAAsC;AAEtE,aAAW,WAAW,aAAa;AACjC,QAAI,eAAe,IAAI,QAAQ,EAAE,KAAK,mBAAmB,OAAO,GAAG;AACjE,0BAAoB,IAAI,QAAQ,EAAE;AAAA,IACpC;AAAA,EACF;AAEA,aAAW,WAAW,aAAa;AACjC,QAAI,eAAe,IAAI,QAAQ,EAAE,GAAG;AAClC,UACE,mBAAmB,OAAO,KACzB,QAAQ,WAAW,oBAAoB,IAAI,QAAQ,OAAO,GAC3D;AACA,2CAAmC,gBAAgB,KAAK,OAAO;AAAA,MACjE,WAAW,CAAC,QAAQ,SAAS;AAC3B,2CAAmC,gBAAgB,KAAK,OAAO;AAAA,MACjE,OAAO;AACL,cAAM,gBACJ,mCAAmC,cAAc;AAAA,UAC/C,QAAQ;AAAA,QACV,KAAK,CAAC;AACR,sBAAc,KAAK,OAAO;AAC1B,2CAAmC,cAAc;AAAA,UAC/C,QAAQ;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAI,eAAe;AAEnB,QAAM,oBAAoB,MAAM;AAAA,IAC9B,mCAAmC,cAAc,QAAQ;AAAA,EAC3D;AAEA,aAAW,CAAC,SAAS,QAAQ,KAAK,mBAAmB;AACnD,mBAAe;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,mCAAmC;AAAA,EACrC;AACF;AAKO,IAAM,cAAc,CACzB,aACA,UACA,UACG;AACH,SAAO,mBAAmB,aAAa,UAAU,QAAQ,KAAK;AAChE;AAEO,IAAM,eAAe,CAC1B,aACA,UACA,UACG;AACH,SAAO,mBAAmB,aAAa,UAAU,SAAS,KAAK;AACjE;AAEO,IAAM,cAAc,CACzB,aACA,aACG;AACH,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,eAAe,CAC1B,aACA,aACG;AACH,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AtEzhBO,IAAM,kBAAkB,CAAC,aAC9B,SAAS,OAAO,CAAC,KAAK,OAAO,MAAM,GAAG,SAAS,CAAC;AAK3C,IAAM,sBAAsB,CAAC,aAAyC;AAC3E,MAAI,OAAO;AACX,aAAW,WAAWE,YAAW,QAAQ,GAAG;AAC1C,YAAQ,QAAQ,KAAK,OAAO,QAAQ;AAAA,EACtC;AACA,SAAO,SAAS;AAClB;AAIO,IAAM,aAAa,CAAC,MAAsB;AAC/C,MAAI,OAAe;AACnB,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,UAAM,OAAe,EAAE,WAAW,CAAC;AACnC,YAAQ,QAAQ,KAAK,OAAO;AAAA,EAC9B;AACA,SAAO,SAAS;AAClB;AAEO,IAAM,qBAAqB,CAAC,aACjC,SAAS;AAAA,EACP,CAAC,OAAO,CAAC,GAAG,aAAa,CAAC,wBAAwB,EAAE;AACtD;AAEK,IAAMC,yBAAwB,CACnC,aAEA,SAAS,OAAO,CAAC,YAAY,CAAC,QAAQ,SAAS;AAE1C,IAAMC,uBAAsB,CACjC,YAC6B,CAAC,QAAQ;AAExC,IAAM,iBAAiB,CACrB,aAEAD,uBAAsB,QAAQ,EAAE;AAAA,EAAI,CAAC,YACnC,oBAAoB,QAAQ,IAAI,IAC5B,EAAE,GAAG,SAAS,oBAAoB,KAAK,IACvC;AACN;AAEK,IAAM,2BAA2B,CACtC,aACG,eAAe,QAAQ;AAErB,IAAM,yBAAyB,CACpC,aACG,eAAe,QAAQ;AAErB,IAAM,+BAA+B,CAC1C,aACG,eAAe,QAAQ;",
  "names": [
    "result",
    "throttle",
    "toIterable",
    "viewportCoordsToSceneCoords",
    "pointsEqual",
    "line",
    "polygon",
    "ae",
    "ce",
    "helper",
    "line",
    "line",
    "helper",
    "line",
    "helper",
    "line",
    "helper",
    "line",
    "helper",
    "curve",
    "r1",
    "r2",
    "b",
    "b",
    "a",
    "b",
    "distance",
    "distance",
    "distance",
    "arrayToMap",
    "invariant",
    "lineSegment",
    "pointDistance",
    "pointFrom",
    "pointFromArray",
    "pointRotateRads",
    "curve",
    "polygon",
    "curve",
    "pointFrom",
    "pointDistance",
    "pointRotateRads",
    "isTransparent",
    "assertNever",
    "BOUND_TEXT_PADDING",
    "distance",
    "getFontString",
    "pointFrom",
    "pointRotateRads",
    "vectorFromPoint",
    "vectorAdd",
    "vectorScale",
    "pointFromVector",
    "pointRotateRads",
    "pointFrom",
    "crop",
    "getElementAbsoluteCoords",
    "vectorFromPoint",
    "vectorAdd",
    "vectorScale",
    "pointFromVector",
    "pointCenter",
    "pointFrom",
    "pointRotateRads",
    "pointsEqual",
    "pointDistance",
    "vectorFromPoint",
    "KEYS",
    "invariant",
    "tupleToCoors",
    "deconstructLinearOrFreeDrawElement",
    "isPathALoop",
    "arrayToMap",
    "tupleToCoors",
    "invariant",
    "isDevEnv",
    "isTestEnv",
    "lineSegment",
    "pointFrom",
    "pointRotateRads",
    "vectorFromPoint",
    "clamp",
    "pointDistance",
    "pointFromVector",
    "vectorScale",
    "vectorNormalize",
    "vectorCross",
    "pointsEqual",
    "lineSegmentIntersectionPoints",
    "PRECISION",
    "lineSegment",
    "pointFrom",
    "pointFromVector",
    "pointRotateRads",
    "pointsEqual",
    "vectorFromPoint",
    "vectorNormalize",
    "vectorScale",
    "ellipse",
    "curve",
    "lineSegment",
    "pointDistance",
    "pointFrom",
    "pointFromArray",
    "rectangle",
    "pointFromArray",
    "lineSegment",
    "pointFrom",
    "curve",
    "rectangle",
    "distance",
    "pointDistance",
    "ROUNDNESS",
    "BOUND_TEXT_PADDING",
    "DEFAULT_FONT_SIZE",
    "getFontString",
    "invariant",
    "line",
    "isTestEnv",
    "line",
    "isTestEnv",
    "invariant",
    "getFontString",
    "index",
    "BOUND_TEXT_PADDING",
    "DEFAULT_FONT_SIZE",
    "pointRotateRads",
    "ellipse",
    "pointRotateRads",
    "a",
    "ellipse",
    "pointFrom",
    "pointRotateRads",
    "line",
    "l",
    "lineSegment",
    "ellipse",
    "pointFromVector",
    "vectorScale",
    "vectorNormalize",
    "vectorFromPoint",
    "pointsEqual",
    "invariant",
    "isDevEnv",
    "isTestEnv",
    "pointFrom",
    "pointFromVector",
    "pointRotateRads",
    "pointsEqual",
    "vectorFromPoint",
    "vectorScale",
    "vectorFromPoint",
    "a",
    "b",
    "isDevEnv",
    "isTestEnv",
    "invariant",
    "pointsEqual",
    "pointFromVector",
    "vectorScale",
    "pointRotateRads",
    "pointFrom",
    "p",
    "getSizeFromPoints",
    "clamp",
    "pointDistance",
    "pointFrom",
    "pointScaleFromOrigin",
    "pointsEqual",
    "vector",
    "vectorCross",
    "vectorFromPoint",
    "vectorScale",
    "invariant",
    "isDevEnv",
    "pointFrom",
    "pointDistance",
    "isDevEnv",
    "invariant",
    "pointsEqual",
    "vectorFromPoint",
    "vector",
    "pointScaleFromOrigin",
    "a",
    "b",
    "vectorCross",
    "global",
    "vectorScale",
    "clamp",
    "getSizeFromPoints",
    "element",
    "isBindingEnabled",
    "arrayToMap",
    "a",
    "b",
    "vectorFromPoint",
    "distance",
    "isDevEnv",
    "isTestEnv",
    "invariant",
    "pointFrom",
    "pointRotateRads",
    "lineSegment",
    "pointFromVector",
    "vectorScale",
    "vectorNormalize",
    "pointDistance",
    "PRECISION",
    "clamp",
    "global",
    "tupleToCoors",
    "duplicateElement",
    "shouldTestInside",
    "pointsEqual",
    "vectorCross",
    "lineSegmentIntersectionPoints",
    "pointFrom",
    "pointsEqual",
    "getElementAbsoluteCoords",
    "KEYS",
    "tupleToCoors",
    "isPathALoop",
    "distance",
    "pointDistance",
    "deconstructLinearOrFreeDrawElement",
    "invariant",
    "pointCenter",
    "pointRotateRads",
    "midpoint",
    "vectorFromPoint",
    "a",
    "b",
    "arrayToMap",
    "isPointWithinBounds",
    "pointFrom",
    "vectorCross",
    "vectorFromPoint",
    "line",
    "a",
    "b",
    "l",
    "arrayToMap",
    "getElementBounds",
    "isArrowElement",
    "isExcalidrawElement",
    "isFreeDrawElement",
    "isLinearElement",
    "isTextElement",
    "pointFrom",
    "pointRotateRads",
    "arrayToMap",
    "selectGroupsForSelectedElements",
    "getElementAbsoluteCoords",
    "arrayToMap",
    "arrayToMap",
    "getElementAbsoluteCoords",
    "isPointWithinBounds",
    "pointFrom",
    "element",
    "getElementAbsoluteCoords",
    "distance",
    "BOUND_TEXT_PADDING",
    "getFontString",
    "A",
    "B",
    "isTransparent",
    "arrowheadPoints",
    "options",
    "pointFrom",
    "pointRotateRads",
    "assertNever",
    "pointDistance",
    "getElementAbsoluteCoords",
    "distance",
    "getElementAbsoluteCoords",
    "pointRotateRads",
    "pointFrom",
    "curve",
    "lineSegment",
    "segments",
    "se",
    "ellipse",
    "a",
    "b",
    "pointFromArray",
    "invariant",
    "minX",
    "minY",
    "maxX",
    "maxY",
    "distance",
    "x3",
    "y3",
    "x4",
    "y4",
    "coords",
    "arrayToMap",
    "pointDistance",
    "pointsEqual",
    "viewportCoordsToSceneCoords",
    "arrayToMap",
    "assertNever",
    "isDevEnv",
    "isShallowEqual",
    "isTestEnv",
    "randomInteger",
    "assertNever",
    "COLOR_PALETTE",
    "isDevEnv",
    "isTestEnv",
    "randomId",
    "randomInteger",
    "arrayToMap",
    "getUpdatedTimestamp",
    "isTestEnv",
    "elements",
    "element",
    "isTestEnv",
    "getUpdatedTimestamp",
    "randomInteger",
    "arrayToMap",
    "elements",
    "element",
    "newElement",
    "duplicateElement",
    "assertNever",
    "isTestEnv",
    "isDevEnv",
    "randomId",
    "COLOR_PALETTE",
    "a",
    "b",
    "ib",
    "fb",
    "ia",
    "fa",
    "i",
    "c",
    "arrayToMap",
    "arrayToMap",
    "a",
    "b",
    "lowerBound",
    "upperBound",
    "i",
    "current",
    "randomInteger",
    "arrayToMap",
    "isDevEnv",
    "isTestEnv",
    "isFrameLikeElement",
    "getElementsInGroup",
    "syncInvalidIndices",
    "syncMovedIndices",
    "validateFractionalIndices",
    "getSelectedElements",
    "mutateElement",
    "getNonDeletedElements",
    "throttle",
    "assertNever",
    "isShallowEqual",
    "isTestEnv",
    "isDevEnv",
    "delta",
    "randomInteger",
    "newElement",
    "arrayToMap",
    "a",
    "b",
    "step",
    "pos",
    "getGridPoint",
    "getFontString",
    "getGridPoint",
    "newElement",
    "getFontString",
    "VERTICAL_ALIGN",
    "getFontString",
    "DEFAULT_FONT_FAMILY",
    "DEFAULT_FONT_SIZE",
    "VERTICAL_ALIGN",
    "randomInteger",
    "randomId",
    "getFontString",
    "getUpdatedTimestamp",
    "randomId",
    "randomInteger",
    "getUpdatedTimestamp",
    "DEFAULT_FONT_FAMILY",
    "DEFAULT_FONT_SIZE",
    "getFontString",
    "VERTICAL_ALIGN",
    "getElementAbsoluteCoords",
    "getFontString",
    "VERTICAL_ALIGN",
    "KEYS",
    "invariant",
    "toBrandedType",
    "pointFrom",
    "KEYS",
    "invariant",
    "_VERTICAL_OFFSET",
    "y",
    "x",
    "pointFrom",
    "toBrandedType",
    "MIME_TYPES",
    "MIME_TYPES",
    "pointCenter",
    "normalizeRadians",
    "pointFrom",
    "pointRotateRads",
    "SHIFT_LOCKING_ANGLE",
    "rescalePoints",
    "getFontString",
    "shouldRotateWithDiscreteAngle",
    "getElementAbsoluteCoords",
    "SHIFT_LOCKING_ANGLE",
    "normalizeRadians",
    "rescalePoints",
    "pointFrom",
    "getFontString",
    "metrics",
    "pointRotateRads",
    "pointCenter",
    "width",
    "height",
    "pointFrom",
    "pointRotateRads",
    "pointFrom",
    "pointRotateRads",
    "pointRotateRads",
    "pointFrom",
    "getElementAbsoluteCoords",
    "getElementAbsoluteCoords",
    "pointFrom",
    "a",
    "pointRotateRads",
    "arrayToMap",
    "findLastIndex",
    "arrayToMap",
    "findLastIndex",
    "toIterable",
    "getNonDeletedElements",
    "isNonDeletedElement"
  ]
}
