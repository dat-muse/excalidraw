{
  "version": 3,
  "sources": ["../../src/utils.ts", "../../src/angle.ts", "../../src/vector.ts", "../../src/point.ts", "../../src/constants.ts", "../../src/curve.ts", "../../src/ellipse.ts", "../../src/line.ts", "../../src/segment.ts", "../../src/polygon.ts", "../../src/range.ts", "../../src/rectangle.ts", "../../src/triangle.ts"],
  "sourcesContent": ["export const PRECISION = 10e-5;\n\nexport const clamp = (value: number, min: number, max: number) => {\n  return Math.min(Math.max(value, min), max);\n};\n\nexport const round = (\n  value: number,\n  precision: number,\n  func: \"round\" | \"floor\" | \"ceil\" = \"round\",\n) => {\n  const multiplier = Math.pow(10, precision);\n\n  return Math[func]((value + Number.EPSILON) * multiplier) / multiplier;\n};\n\nexport const roundToStep = (\n  value: number,\n  step: number,\n  func: \"round\" | \"floor\" | \"ceil\" = \"round\",\n): number => {\n  const factor = 1 / step;\n  return Math[func](value * factor) / factor;\n};\n\nexport const average = (a: number, b: number) => (a + b) / 2;\n\nexport const isFiniteNumber = (value: any): value is number => {\n  return typeof value === \"number\" && Number.isFinite(value);\n};\n\nexport const isCloseTo = (a: number, b: number, precision = PRECISION) =>\n  Math.abs(a - b) < precision;\n", "import { PRECISION } from \"./utils\";\n\nimport type {\n  Degrees,\n  GlobalPoint,\n  LocalPoint,\n  PolarCoords,\n  Radians,\n} from \"./types\";\n\nexport const normalizeRadians = (angle: Radians): Radians =>\n  angle < 0\n    ? (((angle % (2 * Math.PI)) + 2 * Math.PI) as Radians)\n    : ((angle % (2 * Math.PI)) as Radians);\n\n/**\n * Return the polar coordinates for the given cartesian point represented by\n * (x, y) for the center point 0,0 where the first number returned is the radius,\n * the second is the angle in radians.\n */\nexport const cartesian2Polar = <P extends GlobalPoint | LocalPoint>([\n  x,\n  y,\n]: P): PolarCoords => [\n  Math.hypot(x, y),\n  normalizeRadians(Math.atan2(y, x) as Radians),\n];\n\nexport function degreesToRadians(degrees: Degrees): Radians {\n  return ((degrees * Math.PI) / 180) as Radians;\n}\n\nexport function radiansToDegrees(degrees: Radians): Degrees {\n  return ((degrees * 180) / Math.PI) as Degrees;\n}\n\n/**\n * Determines if the provided angle is a right angle.\n *\n * @param rads The angle to measure\n * @returns TRUE if the provided angle is a right angle\n */\nexport function isRightAngleRads(rads: Radians): boolean {\n  return Math.abs(Math.sin(2 * rads)) < PRECISION;\n}\n\nexport function radiansBetweenAngles(\n  a: Radians,\n  min: Radians,\n  max: Radians,\n): boolean {\n  a = normalizeRadians(a);\n  min = normalizeRadians(min);\n  max = normalizeRadians(max);\n\n  if (min < max) {\n    return a >= min && a <= max;\n  }\n\n  // The range wraps around the 0 angle\n  return a >= min || a <= max;\n}\n\nexport function radiansDifference(a: Radians, b: Radians): Radians {\n  a = normalizeRadians(a);\n  b = normalizeRadians(b);\n\n  let diff = a - b;\n\n  if (diff < -Math.PI) {\n    diff = (diff + 2 * Math.PI) as Radians;\n  } else if (diff > Math.PI) {\n    diff = (diff - 2 * Math.PI) as Radians;\n  }\n\n  return Math.abs(diff) as Radians;\n}\n", "import type { GlobalPoint, LocalPoint, Vector } from \"./types\";\n\n/**\n * Create a vector from the x and y coordiante elements.\n *\n * @param x The X aspect of the vector\n * @param y T Y aspect of the vector\n * @returns The constructed vector with X and Y as the coordinates\n */\nexport function vector(\n  x: number,\n  y: number,\n  originX: number = 0,\n  originY: number = 0,\n): Vector {\n  return [x - originX, y - originY] as Vector;\n}\n\n/**\n * Turn a point into a vector with the origin point.\n *\n * @param p The point to turn into a vector\n * @param origin The origin point in a given coordiante system\n * @param threshold The threshold to consider the vector as 'undefined'\n * @param defaultValue The default value to return if the vector is 'undefined'\n * @returns The created vector from the point and the origin or default\n */\nexport function vectorFromPoint<Point extends GlobalPoint | LocalPoint>(\n  p: Point,\n  origin: Point = [0, 0] as Point,\n  threshold?: number,\n  defaultValue: Vector = [0, 1] as Vector,\n): Vector {\n  const vec = vector(p[0] - origin[0], p[1] - origin[1]);\n\n  if (threshold && vectorMagnitudeSq(vec) < threshold * threshold) {\n    return defaultValue;\n  }\n\n  return vec;\n}\n\n/**\n * Cross product is a binary operation on two vectors in 2D space.\n * It results in a vector that is perpendicular to both vectors.\n *\n * @param a One of the vectors to use for the directed area calculation\n * @param b The other vector to use for the directed area calculation\n * @returns The directed area value for the two vectos\n */\nexport function vectorCross(a: Vector, b: Vector): number {\n  return a[0] * b[1] - b[0] * a[1];\n}\n\n/**\n * Dot product is defined as the sum of the products of the\n * two vectors.\n *\n * @param a One of the vectors for which the sum of products is calculated\n * @param b The other vector for which the sum of products is calculated\n * @returns The sum of products of the two vectors\n */\nexport function vectorDot(a: Vector, b: Vector) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Determines if the value has the shape of a Vector.\n *\n * @param v The value to test\n * @returns TRUE if the value has the shape and components of a Vectors\n */\nexport function isVector(v: unknown): v is Vector {\n  return (\n    Array.isArray(v) &&\n    v.length === 2 &&\n    typeof v[0] === \"number\" &&\n    !isNaN(v[0]) &&\n    typeof v[1] === \"number\" &&\n    !isNaN(v[1])\n  );\n}\n\n/**\n * Add two vectors by adding their coordinates.\n *\n * @param a One of the vectors to add\n * @param b The other vector to add\n * @returns The sum vector of the two provided vectors\n */\nexport function vectorAdd(a: Readonly<Vector>, b: Readonly<Vector>): Vector {\n  return [a[0] + b[0], a[1] + b[1]] as Vector;\n}\n\n/**\n * Add two vectors by adding their coordinates.\n *\n * @param start One of the vectors to add\n * @param end The other vector to add\n * @returns The sum vector of the two provided vectors\n */\nexport function vectorSubtract(\n  start: Readonly<Vector>,\n  end: Readonly<Vector>,\n): Vector {\n  return [start[0] - end[0], start[1] - end[1]] as Vector;\n}\n\n/**\n * Scale vector by a scalar.\n *\n * @param v The vector to scale\n * @param scalar The scalar to multiply the vector components with\n * @returns The new scaled vector\n */\nexport function vectorScale(v: Vector, scalar: number): Vector {\n  return vector(v[0] * scalar, v[1] * scalar);\n}\n\n/**\n * Calculates the sqare magnitude of a vector. Use this if you compare\n * magnitudes as it saves you an SQRT.\n *\n * @param v The vector to measure\n * @returns The scalar squared magnitude of the vector\n */\nexport function vectorMagnitudeSq(v: Vector) {\n  return v[0] * v[0] + v[1] * v[1];\n}\n\n/**\n * Calculates the magnitude of a vector.\n *\n * @param v The vector to measure\n * @returns The scalar magnitude of the vector\n */\nexport function vectorMagnitude(v: Vector) {\n  return Math.sqrt(vectorMagnitudeSq(v));\n}\n\n/**\n * Normalize the vector (i.e. make the vector magnitue equal 1).\n *\n * @param v The vector to normalize\n * @returns The new normalized vector\n */\nexport const vectorNormalize = (v: Vector): Vector => {\n  const m = vectorMagnitude(v);\n\n  if (m === 0) {\n    return vector(0, 0);\n  }\n\n  return vector(v[0] / m, v[1] / m);\n};\n\n/**\n * Calculate the right-hand normal of the vector.\n */\nexport const vectorNormal = (v: Vector): Vector => vector(v[1], -v[0]);\n", "import { degreesToRadians } from \"./angle\";\nimport { PRECISION } from \"./utils\";\nimport { vectorFromPoint, vectorScale } from \"./vector\";\n\nimport type {\n  LocalPoint,\n  GlobalPoint,\n  Radians,\n  Degrees,\n  Vector,\n} from \"./types\";\n\n/**\n * Create a properly typed Point instance from the X and Y coordinates.\n *\n * @param x The X coordinate\n * @param y The Y coordinate\n * @returns The branded and created point\n */\nexport function pointFrom<Point extends GlobalPoint | LocalPoint>(\n  x: number,\n  y: number,\n): Point {\n  return [x, y] as Point;\n}\n\n/**\n * Converts and remaps an array containing a pair of numbers to Point.\n *\n * @param numberArray The number array to check and to convert to Point\n * @returns The point instance\n */\nexport function pointFromArray<Point extends GlobalPoint | LocalPoint>(\n  numberArray: number[],\n): Point | undefined {\n  return numberArray.length === 2\n    ? pointFrom<Point>(numberArray[0], numberArray[1])\n    : undefined;\n}\n\n/**\n * Converts and remaps a pair of numbers to Point.\n *\n * @param pair A number pair to convert to Point\n * @returns The point instance\n */\nexport function pointFromPair<Point extends GlobalPoint | LocalPoint>(\n  pair: [number, number],\n): Point {\n  return pair as Point;\n}\n\n/**\n * Convert a vector to a point.\n *\n * @param v The vector to convert\n * @returns The point the vector points at with origin 0,0\n */\nexport function pointFromVector<P extends GlobalPoint | LocalPoint>(\n  v: Vector,\n  offset: P = pointFrom(0, 0),\n): P {\n  return pointFrom<P>(offset[0] + v[0], offset[1] + v[1]);\n}\n\n/**\n * Checks if the provided value has the shape of a Point.\n *\n * @param p The value to attempt verification on\n * @returns TRUE if the provided value has the shape of a local or global point\n */\nexport function isPoint(p: unknown): p is LocalPoint | GlobalPoint {\n  return (\n    Array.isArray(p) &&\n    p.length === 2 &&\n    typeof p[0] === \"number\" &&\n    !isNaN(p[0]) &&\n    typeof p[1] === \"number\" &&\n    !isNaN(p[1])\n  );\n}\n\n/**\n * Compare two points coordinate-by-coordinate and if\n * they are closer than INVERSE_PRECISION it returns TRUE.\n *\n * @param a Point The first point to compare\n * @param b Point The second point to compare\n * @returns TRUE if the points are sufficiently close to each other\n */\nexport function pointsEqual<Point extends GlobalPoint | LocalPoint>(\n  a: Point,\n  b: Point,\n  tolerance: number = PRECISION,\n): boolean {\n  const abs = Math.abs;\n  return abs(a[0] - b[0]) < tolerance && abs(a[1] - b[1]) < tolerance;\n}\n\n/**\n * Rotate a point by [angle] radians.\n *\n * @param point The point to rotate\n * @param center The point to rotate around, the center point\n * @param angle The radians to rotate the point by\n * @returns The rotated point\n */\nexport function pointRotateRads<Point extends GlobalPoint | LocalPoint>(\n  [x, y]: Point,\n  [cx, cy]: Point,\n  angle: Radians,\n): Point {\n  return pointFrom(\n    (x - cx) * Math.cos(angle) - (y - cy) * Math.sin(angle) + cx,\n    (x - cx) * Math.sin(angle) + (y - cy) * Math.cos(angle) + cy,\n  );\n}\n\n/**\n * Rotate a point by [angle] degree.\n *\n * @param point The point to rotate\n * @param center The point to rotate around, the center point\n * @param angle The degree to rotate the point by\n * @returns The rotated point\n */\nexport function pointRotateDegs<Point extends GlobalPoint | LocalPoint>(\n  point: Point,\n  center: Point,\n  angle: Degrees,\n): Point {\n  return pointRotateRads(point, center, degreesToRadians(angle));\n}\n\n/**\n * Translate a point by a vector.\n *\n * WARNING: This is not for translating Excalidraw element points!\n *          You need to account for rotation on base coordinates\n *          on your own.\n *          CONSIDER USING AN APPROPRIATE ELEMENT-AWARE TRANSLATE!\n *\n * @param p The point to apply the translation on\n * @param v The vector to translate by\n * @returns\n */\n// TODO 99% of use is translating between global and local coords, which need to be formalized\nexport function pointTranslate<\n  From extends GlobalPoint | LocalPoint,\n  To extends GlobalPoint | LocalPoint,\n>(p: From, v: Vector = [0, 0] as Vector): To {\n  return pointFrom(p[0] + v[0], p[1] + v[1]);\n}\n\n/**\n * Find the center point at equal distance from both points.\n *\n * @param a One of the points to create the middle point for\n * @param b The other point to create the middle point for\n * @returns The middle point\n */\nexport function pointCenter<P extends LocalPoint | GlobalPoint>(a: P, b: P): P {\n  return pointFrom((a[0] + b[0]) / 2, (a[1] + b[1]) / 2);\n}\n\n/**\n * Calculate the distance between two points.\n *\n * @param a First point\n * @param b Second point\n * @returns The euclidean distance between the two points.\n */\nexport function pointDistance<P extends LocalPoint | GlobalPoint>(\n  a: P,\n  b: P,\n): number {\n  return Math.hypot(b[0] - a[0], b[1] - a[1]);\n}\n\n/**\n * Calculate the squared distance between two points.\n *\n * Note: Use this if you only compare distances, it saves a square root.\n *\n * @param a First point\n * @param b Second point\n * @returns The euclidean distance between the two points.\n */\nexport function pointDistanceSq<P extends LocalPoint | GlobalPoint>(\n  a: P,\n  b: P,\n): number {\n  const xDiff = b[0] - a[0];\n  const yDiff = b[1] - a[1];\n\n  return xDiff * xDiff + yDiff * yDiff;\n}\n\n/**\n * Scale a point from a given origin by the multiplier.\n *\n * @param p The point to scale\n * @param mid The origin to scale from\n * @param multiplier The scaling factor\n * @returns\n */\nexport const pointScaleFromOrigin = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  mid: P,\n  multiplier: number,\n) => pointTranslate(mid, vectorScale(vectorFromPoint(p, mid), multiplier));\n\n/**\n * Returns whether `q` lies inside the segment/rectangle defined by `p` and `r`.\n * This is an approximation to \"does `q` lie on a segment `pr`\" check.\n *\n * @param p The first point to compare against\n * @param q The actual point this function checks whether is in between\n * @param r The other point to compare against\n * @returns TRUE if q is indeed between p and r\n */\nexport const isPointWithinBounds = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  q: P,\n  r: P,\n) => {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n};\n", "export const PRECISION = 10e-5;\n\n// Legendre-Gauss abscissae (x values) and weights for n=24\n// Refeerence: https://pomax.github.io/bezierinfo/legendre-gauss.html\nexport const LegendreGaussN24TValues = [\n  -0.0640568928626056260850430826247450385909,\n  0.0640568928626056260850430826247450385909,\n  -0.1911188674736163091586398207570696318404,\n  0.1911188674736163091586398207570696318404,\n  -0.3150426796961633743867932913198102407864,\n  0.3150426796961633743867932913198102407864,\n  -0.4337935076260451384870842319133497124524,\n  0.4337935076260451384870842319133497124524,\n  -0.5454214713888395356583756172183723700107,\n  0.5454214713888395356583756172183723700107,\n  -0.6480936519369755692524957869107476266696,\n  0.6480936519369755692524957869107476266696,\n  -0.7401241915785543642438281030999784255232,\n  0.7401241915785543642438281030999784255232,\n  -0.8200019859739029219539498726697452080761,\n  0.8200019859739029219539498726697452080761,\n  -0.8864155270044010342131543419821967550873,\n  0.8864155270044010342131543419821967550873,\n  -0.9382745520027327585236490017087214496548,\n  0.9382745520027327585236490017087214496548,\n  -0.9747285559713094981983919930081690617411,\n  0.9747285559713094981983919930081690617411,\n  -0.9951872199970213601799974097007368118745,\n  0.9951872199970213601799974097007368118745,\n];\n\nexport const LegendreGaussN24CValues = [\n  0.1279381953467521569740561652246953718517,\n  0.1279381953467521569740561652246953718517,\n  0.1258374563468282961213753825111836887264,\n  0.1258374563468282961213753825111836887264,\n  0.121670472927803391204463153476262425607,\n  0.121670472927803391204463153476262425607,\n  0.1155056680537256013533444839067835598622,\n  0.1155056680537256013533444839067835598622,\n  0.1074442701159656347825773424466062227946,\n  0.1074442701159656347825773424466062227946,\n  0.0976186521041138882698806644642471544279,\n  0.0976186521041138882698806644642471544279,\n  0.086190161531953275917185202983742667185,\n  0.086190161531953275917185202983742667185,\n  0.0733464814110803057340336152531165181193,\n  0.0733464814110803057340336152531165181193,\n  0.0592985849154367807463677585001085845412,\n  0.0592985849154367807463677585001085845412,\n  0.0442774388174198061686027482113382288593,\n  0.0442774388174198061686027482113382288593,\n  0.0285313886289336631813078159518782864491,\n  0.0285313886289336631813078159518782864491,\n  0.0123412297999871995468056670700372915759,\n  0.0123412297999871995468056670700372915759,\n];\n", "import { isPoint, pointDistance, pointFrom, pointFromVector } from \"./point\";\nimport { vector, vectorNormal, vectorNormalize, vectorScale } from \"./vector\";\nimport { LegendreGaussN24CValues, LegendreGaussN24TValues } from \"./constants\";\n\nimport type { Curve, GlobalPoint, LineSegment, LocalPoint } from \"./types\";\n\n/**\n *\n * @param a\n * @param b\n * @param c\n * @param d\n * @returns\n */\nexport function curve<Point extends GlobalPoint | LocalPoint>(\n  a: Point,\n  b: Point,\n  c: Point,\n  d: Point,\n) {\n  return [a, b, c, d] as Curve<Point>;\n}\n\nfunction gradient(\n  f: (t: number, s: number) => number,\n  t0: number,\n  s0: number,\n  delta: number = 1e-6,\n): number[] {\n  return [\n    (f(t0 + delta, s0) - f(t0 - delta, s0)) / (2 * delta),\n    (f(t0, s0 + delta) - f(t0, s0 - delta)) / (2 * delta),\n  ];\n}\n\nfunction solve(\n  f: (t: number, s: number) => [number, number],\n  t0: number,\n  s0: number,\n  tolerance: number = 1e-3,\n  iterLimit: number = 10,\n): number[] | null {\n  let error = Infinity;\n  let iter = 0;\n\n  while (error >= tolerance) {\n    if (iter >= iterLimit) {\n      return null;\n    }\n\n    const y0 = f(t0, s0);\n    const jacobian = [\n      gradient((t, s) => f(t, s)[0], t0, s0),\n      gradient((t, s) => f(t, s)[1], t0, s0),\n    ];\n    const b = [[-y0[0]], [-y0[1]]];\n    const det =\n      jacobian[0][0] * jacobian[1][1] - jacobian[0][1] * jacobian[1][0];\n\n    if (det === 0) {\n      return null;\n    }\n\n    const iJ = [\n      [jacobian[1][1] / det, -jacobian[0][1] / det],\n      [-jacobian[1][0] / det, jacobian[0][0] / det],\n    ];\n    const h = [\n      [iJ[0][0] * b[0][0] + iJ[0][1] * b[1][0]],\n      [iJ[1][0] * b[0][0] + iJ[1][1] * b[1][0]],\n    ];\n\n    t0 = t0 + h[0][0];\n    s0 = s0 + h[1][0];\n\n    const [tErr, sErr] = f(t0, s0);\n    error = Math.max(Math.abs(tErr), Math.abs(sErr));\n    iter += 1;\n  }\n\n  return [t0, s0];\n}\n\nexport const bezierEquation = <Point extends GlobalPoint | LocalPoint>(\n  c: Curve<Point>,\n  t: number,\n) =>\n  pointFrom<Point>(\n    (1 - t) ** 3 * c[0][0] +\n      3 * (1 - t) ** 2 * t * c[1][0] +\n      3 * (1 - t) * t ** 2 * c[2][0] +\n      t ** 3 * c[3][0],\n    (1 - t) ** 3 * c[0][1] +\n      3 * (1 - t) ** 2 * t * c[1][1] +\n      3 * (1 - t) * t ** 2 * c[2][1] +\n      t ** 3 * c[3][1],\n  );\n\n/**\n * Computes the intersection between a cubic spline and a line segment.\n */\nexport function curveIntersectLineSegment<\n  Point extends GlobalPoint | LocalPoint,\n>(c: Curve<Point>, l: LineSegment<Point>): Point[] {\n  const line = (s: number) =>\n    pointFrom<Point>(\n      l[0][0] + s * (l[1][0] - l[0][0]),\n      l[0][1] + s * (l[1][1] - l[0][1]),\n    );\n\n  const initial_guesses: [number, number][] = [\n    [0.5, 0],\n    [0.2, 0],\n    [0.8, 0],\n  ];\n\n  const calculate = ([t0, s0]: [number, number]) => {\n    const solution = solve(\n      (t: number, s: number) => {\n        const bezier_point = bezierEquation(c, t);\n        const line_point = line(s);\n\n        return [\n          bezier_point[0] - line_point[0],\n          bezier_point[1] - line_point[1],\n        ];\n      },\n      t0,\n      s0,\n    );\n\n    if (!solution) {\n      return null;\n    }\n\n    const [t, s] = solution;\n\n    if (t < 0 || t > 1 || s < 0 || s > 1) {\n      return null;\n    }\n\n    return bezierEquation(c, t);\n  };\n\n  let solution = calculate(initial_guesses[0]);\n  if (solution) {\n    return [solution];\n  }\n\n  solution = calculate(initial_guesses[1]);\n  if (solution) {\n    return [solution];\n  }\n\n  solution = calculate(initial_guesses[2]);\n  if (solution) {\n    return [solution];\n  }\n\n  return [];\n}\n\n/**\n * Finds the closest point on the Bezier curve from another point\n *\n * @param x\n * @param y\n * @param P0\n * @param P1\n * @param P2\n * @param P3\n * @param tolerance\n * @param maxLevel\n * @returns\n */\nexport function curveClosestPoint<Point extends GlobalPoint | LocalPoint>(\n  c: Curve<Point>,\n  p: Point,\n  tolerance: number = 1e-3,\n): Point | null {\n  const localMinimum = (\n    min: number,\n    max: number,\n    f: (t: number) => number,\n    e: number = tolerance,\n  ) => {\n    let m = min;\n    let n = max;\n    let k;\n\n    while (n - m > e) {\n      k = (n + m) / 2;\n      if (f(k - e) < f(k + e)) {\n        n = k;\n      } else {\n        m = k;\n      }\n    }\n\n    return k;\n  };\n\n  const maxSteps = 30;\n  let closestStep = 0;\n  for (let min = Infinity, step = 0; step < maxSteps; step++) {\n    const d = pointDistance(p, bezierEquation(c, step / maxSteps));\n    if (d < min) {\n      min = d;\n      closestStep = step;\n    }\n  }\n\n  const t0 = Math.max((closestStep - 1) / maxSteps, 0);\n  const t1 = Math.min((closestStep + 1) / maxSteps, 1);\n  const solution = localMinimum(t0, t1, (t) =>\n    pointDistance(p, bezierEquation(c, t)),\n  );\n\n  if (!solution) {\n    return null;\n  }\n\n  return bezierEquation(c, solution);\n}\n\n/**\n * Determines the distance between a point and the closest point on the\n * Bezier curve.\n *\n * @param c The curve to test\n * @param p The point to measure from\n */\nexport function curvePointDistance<Point extends GlobalPoint | LocalPoint>(\n  c: Curve<Point>,\n  p: Point,\n) {\n  const closest = curveClosestPoint(c, p);\n\n  if (!closest) {\n    return 0;\n  }\n\n  return pointDistance(p, closest);\n}\n\n/**\n * Determines if the parameter is a Curve\n */\nexport function isCurve<P extends GlobalPoint | LocalPoint>(\n  v: unknown,\n): v is Curve<P> {\n  return (\n    Array.isArray(v) &&\n    v.length === 4 &&\n    isPoint(v[0]) &&\n    isPoint(v[1]) &&\n    isPoint(v[2]) &&\n    isPoint(v[3])\n  );\n}\n\nexport function curveTangent<Point extends GlobalPoint | LocalPoint>(\n  [p0, p1, p2, p3]: Curve<Point>,\n  t: number,\n) {\n  return vector(\n    -3 * (1 - t) * (1 - t) * p0[0] +\n      3 * (1 - t) * (1 - t) * p1[0] -\n      6 * t * (1 - t) * p1[0] -\n      3 * t * t * p2[0] +\n      6 * t * (1 - t) * p2[0] +\n      3 * t * t * p3[0],\n    -3 * (1 - t) * (1 - t) * p0[1] +\n      3 * (1 - t) * (1 - t) * p1[1] -\n      6 * t * (1 - t) * p1[1] -\n      3 * t * t * p2[1] +\n      6 * t * (1 - t) * p2[1] +\n      3 * t * t * p3[1],\n  );\n}\n\nexport function curveCatmullRomQuadraticApproxPoints(\n  points: GlobalPoint[],\n  tension = 0.5,\n) {\n  if (points.length < 2) {\n    return;\n  }\n\n  const pointSets: [GlobalPoint, GlobalPoint][] = [];\n  for (let i = 0; i < points.length - 1; i++) {\n    const p0 = points[i - 1 < 0 ? 0 : i - 1];\n    const p1 = points[i];\n    const p2 = points[i + 1 >= points.length ? points.length - 1 : i + 1];\n    const cpX = p1[0] + ((p2[0] - p0[0]) * tension) / 2;\n    const cpY = p1[1] + ((p2[1] - p0[1]) * tension) / 2;\n\n    pointSets.push([\n      pointFrom<GlobalPoint>(cpX, cpY),\n      pointFrom<GlobalPoint>(p2[0], p2[1]),\n    ]);\n  }\n\n  return pointSets;\n}\n\nexport function curveCatmullRomCubicApproxPoints<\n  Point extends GlobalPoint | LocalPoint,\n>(points: Point[], tension = 0.5) {\n  if (points.length < 2) {\n    return;\n  }\n\n  const pointSets: Curve<Point>[] = [];\n  for (let i = 0; i < points.length - 1; i++) {\n    const p0 = points[i - 1 < 0 ? 0 : i - 1];\n    const p1 = points[i];\n    const p2 = points[i + 1 >= points.length ? points.length - 1 : i + 1];\n    const p3 = points[i + 2 >= points.length ? points.length - 1 : i + 2];\n    const tangent1 = [(p2[0] - p0[0]) * tension, (p2[1] - p0[1]) * tension];\n    const tangent2 = [(p3[0] - p1[0]) * tension, (p3[1] - p1[1]) * tension];\n    const cp1x = p1[0] + tangent1[0] / 3;\n    const cp1y = p1[1] + tangent1[1] / 3;\n    const cp2x = p2[0] - tangent2[0] / 3;\n    const cp2y = p2[1] - tangent2[1] / 3;\n\n    pointSets.push(\n      curve(\n        pointFrom(p1[0], p1[1]),\n        pointFrom(cp1x, cp1y),\n        pointFrom(cp2x, cp2y),\n        pointFrom(p2[0], p2[1]),\n      ),\n    );\n  }\n\n  return pointSets;\n}\n\nexport function curveOffsetPoints(\n  [p0, p1, p2, p3]: Curve<GlobalPoint>,\n  offset: number,\n  steps = 50,\n) {\n  const offsetPoints = [];\n\n  for (let i = 0; i <= steps; i++) {\n    const t = i / steps;\n    const c = curve(p0, p1, p2, p3);\n    const point = bezierEquation(c, t);\n    const tangent = vectorNormalize(curveTangent(c, t));\n    const normal = vectorNormal(tangent);\n\n    offsetPoints.push(pointFromVector(vectorScale(normal, offset), point));\n  }\n\n  return offsetPoints;\n}\n\nexport function offsetPointsForQuadraticBezier(\n  p0: GlobalPoint,\n  p1: GlobalPoint,\n  p2: GlobalPoint,\n  offsetDist: number,\n  steps = 50,\n) {\n  const offsetPoints = [];\n\n  for (let i = 0; i <= steps; i++) {\n    const t = i / steps;\n    const t1 = 1 - t;\n    const point = pointFrom<GlobalPoint>(\n      t1 * t1 * p0[0] + 2 * t1 * t * p1[0] + t * t * p2[0],\n      t1 * t1 * p0[1] + 2 * t1 * t * p1[1] + t * t * p2[1],\n    );\n    const tangentX = 2 * (1 - t) * (p1[0] - p0[0]) + 2 * t * (p2[0] - p1[0]);\n    const tangentY = 2 * (1 - t) * (p1[1] - p0[1]) + 2 * t * (p2[1] - p1[1]);\n    const tangent = vectorNormalize(vector(tangentX, tangentY));\n    const normal = vectorNormal(tangent);\n\n    offsetPoints.push(pointFromVector(vectorScale(normal, offsetDist), point));\n  }\n\n  return offsetPoints;\n}\n\n/**\n * Implementation based on Legendre-Gauss quadrature for more accurate arc\n * length calculation.\n *\n * Reference: https://pomax.github.io/bezierinfo/#arclength\n *\n * @param c The curve to calculate the length of\n * @returns The approximated length of the curve\n */\nexport function curveLength<P extends GlobalPoint | LocalPoint>(\n  c: Curve<P>,\n): number {\n  const z2 = 0.5;\n  let sum = 0;\n\n  for (let i = 0; i < 24; i++) {\n    const t = z2 * LegendreGaussN24TValues[i] + z2;\n    const derivativeVector = curveTangent(c, t);\n    const magnitude = Math.sqrt(\n      derivativeVector[0] * derivativeVector[0] +\n        derivativeVector[1] * derivativeVector[1],\n    );\n    sum += LegendreGaussN24CValues[i] * magnitude;\n  }\n\n  return z2 * sum;\n}\n\n/**\n * Calculates the curve length from t=0 to t=parameter using the same\n * Legendre-Gauss quadrature method used in curveLength\n *\n * @param c The curve to calculate the partial length for\n * @param t The parameter value (0 to 1) to calculate length up to\n * @returns The length of the curve from beginning to parameter t\n */\nexport function curveLengthAtParameter<P extends GlobalPoint | LocalPoint>(\n  c: Curve<P>,\n  t: number,\n): number {\n  if (t <= 0) {\n    return 0;\n  }\n  if (t >= 1) {\n    return curveLength(c);\n  }\n\n  // Scale and shift the integration interval from [0,t] to [-1,1]\n  // which is what the Legendre-Gauss quadrature expects\n  const z1 = t / 2;\n  const z2 = t / 2;\n\n  let sum = 0;\n\n  for (let i = 0; i < 24; i++) {\n    const parameter = z1 * LegendreGaussN24TValues[i] + z2;\n    const derivativeVector = curveTangent(c, parameter);\n    const magnitude = Math.sqrt(\n      derivativeVector[0] * derivativeVector[0] +\n        derivativeVector[1] * derivativeVector[1],\n    );\n    sum += LegendreGaussN24CValues[i] * magnitude;\n  }\n\n  return z1 * sum; // Scale the result back to the original interval\n}\n\n/**\n * Calculates the point at a specific percentage of a curve's total length\n * using binary search for improved efficiency and accuracy.\n *\n * @param c The curve to calculate point on\n * @param percent A value between 0 and 1 representing the percentage of the curve's length\n * @returns The point at the specified percentage of curve length\n */\nexport function curvePointAtLength<P extends GlobalPoint | LocalPoint>(\n  c: Curve<P>,\n  percent: number,\n): P {\n  if (percent <= 0) {\n    return bezierEquation(c, 0);\n  }\n\n  if (percent >= 1) {\n    return bezierEquation(c, 1);\n  }\n\n  const totalLength = curveLength(c);\n  const targetLength = totalLength * percent;\n\n  // Binary search to find parameter t where length at t equals target length\n  let tMin = 0;\n  let tMax = 1;\n  let t = percent; // Start with a reasonable guess (t = percent)\n  let currentLength = 0;\n\n  // Tolerance for length comparison and iteration limit to avoid infinite loops\n  const tolerance = totalLength * 0.0001;\n  const maxIterations = 20;\n\n  for (let iteration = 0; iteration < maxIterations; iteration++) {\n    currentLength = curveLengthAtParameter(c, t);\n    const error = Math.abs(currentLength - targetLength);\n\n    if (error < tolerance) {\n      break;\n    }\n\n    if (currentLength < targetLength) {\n      tMin = t;\n    } else {\n      tMax = t;\n    }\n\n    t = (tMin + tMax) / 2;\n  }\n\n  return bezierEquation(c, t);\n}\n", "import {\n  pointFrom,\n  pointDistance,\n  pointFromVector,\n  pointsEqual,\n} from \"./point\";\nimport { PRECISION } from \"./utils\";\nimport {\n  vector,\n  vectorAdd,\n  vectorDot,\n  vectorFromPoint,\n  vectorScale,\n} from \"./vector\";\n\nimport type {\n  Ellipse,\n  GlobalPoint,\n  Line,\n  LineSegment,\n  LocalPoint,\n} from \"./types\";\n\n/**\n * Construct an Ellipse object from the parameters\n *\n * @param center The center of the ellipse\n * @param angle The slanting of the ellipse in radians\n * @param halfWidth Half of the width of a non-slanted version of the ellipse\n * @param halfHeight Half of the height of a non-slanted version of the ellipse\n * @returns The constructed Ellipse object\n */\nexport function ellipse<Point extends GlobalPoint | LocalPoint>(\n  center: Point,\n  halfWidth: number,\n  halfHeight: number,\n): Ellipse<Point> {\n  return {\n    center,\n    halfWidth,\n    halfHeight,\n  } as Ellipse<Point>;\n}\n\n/**\n * Determines if a point is inside or on the ellipse outline\n *\n * @param p The point to test\n * @param ellipse The ellipse to compare against\n * @returns TRUE if the point is inside or on the outline of the ellipse\n */\nexport const ellipseIncludesPoint = <Point extends GlobalPoint | LocalPoint>(\n  p: Point,\n  ellipse: Ellipse<Point>,\n) => {\n  const { center, halfWidth, halfHeight } = ellipse;\n  const normalizedX = (p[0] - center[0]) / halfWidth;\n  const normalizedY = (p[1] - center[1]) / halfHeight;\n\n  return normalizedX * normalizedX + normalizedY * normalizedY <= 1;\n};\n\n/**\n * Tests whether a point lies on the outline of the ellipse within a given\n * tolerance\n *\n * @param point The point to test\n * @param ellipse The ellipse to compare against\n * @param threshold The distance to consider a point close enough to be \"on\" the outline\n * @returns TRUE if the point is on the ellise outline\n */\nexport const ellipseTouchesPoint = <Point extends GlobalPoint | LocalPoint>(\n  point: Point,\n  ellipse: Ellipse<Point>,\n  threshold = PRECISION,\n) => {\n  return ellipseDistanceFromPoint(point, ellipse) <= threshold;\n};\n\n/**\n * Determine the shortest euclidean distance from a point to the\n * outline of the ellipse\n *\n * @param p The point to consider\n * @param ellipse The ellipse to calculate the distance to\n * @returns The eucledian distance\n */\nexport const ellipseDistanceFromPoint = <\n  Point extends GlobalPoint | LocalPoint,\n>(\n  p: Point,\n  ellipse: Ellipse<Point>,\n): number => {\n  const { halfWidth, halfHeight, center } = ellipse;\n  const a = halfWidth;\n  const b = halfHeight;\n  const translatedPoint = vectorAdd(\n    vectorFromPoint(p),\n    vectorScale(vectorFromPoint(center), -1),\n  );\n\n  const px = Math.abs(translatedPoint[0]);\n  const py = Math.abs(translatedPoint[1]);\n\n  let tx = 0.707;\n  let ty = 0.707;\n\n  for (let i = 0; i < 3; i++) {\n    const x = a * tx;\n    const y = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = x - ex;\n    const ry = y - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  }\n\n  const [minX, minY] = [\n    a * tx * Math.sign(translatedPoint[0]),\n    b * ty * Math.sign(translatedPoint[1]),\n  ];\n\n  return pointDistance(pointFromVector(translatedPoint), pointFrom(minX, minY));\n};\n\n/**\n * Calculate a maximum of two intercept points for a line going throug an\n * ellipse.\n */\nexport function ellipseSegmentInterceptPoints<\n  Point extends GlobalPoint | LocalPoint,\n>(e: Readonly<Ellipse<Point>>, s: Readonly<LineSegment<Point>>): Point[] {\n  const rx = e.halfWidth;\n  const ry = e.halfHeight;\n\n  const dir = vectorFromPoint(s[1], s[0]);\n  const diff = vector(s[0][0] - e.center[0], s[0][1] - e.center[1]);\n  const mDir = vector(dir[0] / (rx * rx), dir[1] / (ry * ry));\n  const mDiff = vector(diff[0] / (rx * rx), diff[1] / (ry * ry));\n\n  const a = vectorDot(dir, mDir);\n  const b = vectorDot(dir, mDiff);\n  const c = vectorDot(diff, mDiff) - 1.0;\n  const d = b * b - a * c;\n\n  const intersections: Point[] = [];\n\n  if (d > 0) {\n    const t_a = (-b - Math.sqrt(d)) / a;\n    const t_b = (-b + Math.sqrt(d)) / a;\n\n    if (0 <= t_a && t_a <= 1) {\n      intersections.push(\n        pointFrom(\n          s[0][0] + (s[1][0] - s[0][0]) * t_a,\n          s[0][1] + (s[1][1] - s[0][1]) * t_a,\n        ),\n      );\n    }\n\n    if (0 <= t_b && t_b <= 1) {\n      intersections.push(\n        pointFrom(\n          s[0][0] + (s[1][0] - s[0][0]) * t_b,\n          s[0][1] + (s[1][1] - s[0][1]) * t_b,\n        ),\n      );\n    }\n  } else if (d === 0) {\n    const t = -b / a;\n    if (0 <= t && t <= 1) {\n      intersections.push(\n        pointFrom(\n          s[0][0] + (s[1][0] - s[0][0]) * t,\n          s[0][1] + (s[1][1] - s[0][1]) * t,\n        ),\n      );\n    }\n  }\n\n  return intersections;\n}\n\nexport function ellipseLineIntersectionPoints<\n  Point extends GlobalPoint | LocalPoint,\n>(\n  { center, halfWidth, halfHeight }: Ellipse<Point>,\n  [g, h]: Line<Point>,\n): Point[] {\n  const [cx, cy] = center;\n  const x1 = g[0] - cx;\n  const y1 = g[1] - cy;\n  const x2 = h[0] - cx;\n  const y2 = h[1] - cy;\n  const a =\n    Math.pow(x2 - x1, 2) / Math.pow(halfWidth, 2) +\n    Math.pow(y2 - y1, 2) / Math.pow(halfHeight, 2);\n  const b =\n    2 *\n    ((x1 * (x2 - x1)) / Math.pow(halfWidth, 2) +\n      (y1 * (y2 - y1)) / Math.pow(halfHeight, 2));\n  const c =\n    Math.pow(x1, 2) / Math.pow(halfWidth, 2) +\n    Math.pow(y1, 2) / Math.pow(halfHeight, 2) -\n    1;\n  const t1 = (-b + Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);\n  const t2 = (-b - Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);\n  const candidates = [\n    pointFrom<Point>(x1 + t1 * (x2 - x1) + cx, y1 + t1 * (y2 - y1) + cy),\n    pointFrom<Point>(x1 + t2 * (x2 - x1) + cx, y1 + t2 * (y2 - y1) + cy),\n  ].filter((p) => !isNaN(p[0]) && !isNaN(p[1]));\n\n  if (candidates.length === 2 && pointsEqual(candidates[0], candidates[1])) {\n    return [candidates[0]];\n  }\n\n  return candidates;\n}\n", "import { pointFrom } from \"./point\";\n\nimport type { GlobalPoint, Line, LocalPoint } from \"./types\";\n\n/**\n * Create a line from two points.\n *\n * @param points The two points lying on the line\n * @returns The line on which the points lie\n */\nexport function line<P extends GlobalPoint | LocalPoint>(a: P, b: P): Line<P> {\n  return [a, b] as Line<P>;\n}\n\n/**\n * Determines the intersection point (unless the lines are parallel) of two\n * lines\n *\n * @param a\n * @param b\n * @returns\n */\nexport function linesIntersectAt<Point extends GlobalPoint | LocalPoint>(\n  a: Line<Point>,\n  b: Line<Point>,\n): Point | null {\n  const A1 = a[1][1] - a[0][1];\n  const B1 = a[0][0] - a[1][0];\n  const A2 = b[1][1] - b[0][1];\n  const B2 = b[0][0] - b[1][0];\n  const D = A1 * B2 - A2 * B1;\n  if (D !== 0) {\n    const C1 = A1 * a[0][0] + B1 * a[0][1];\n    const C2 = A2 * b[0][0] + B2 * b[0][1];\n    return pointFrom<Point>((C1 * B2 - C2 * B1) / D, (A1 * C2 - A2 * C1) / D);\n  }\n\n  return null;\n}\n", "import { line, linesIntersectAt } from \"./line\";\nimport {\n  isPoint,\n  pointCenter,\n  pointFromVector,\n  pointRotateRads,\n} from \"./point\";\nimport { PRECISION } from \"./utils\";\nimport {\n  vectorAdd,\n  vectorCross,\n  vectorFromPoint,\n  vectorScale,\n  vectorSubtract,\n} from \"./vector\";\n\nimport type { GlobalPoint, LineSegment, LocalPoint, Radians } from \"./types\";\n\n/**\n * Create a line segment from two points.\n *\n * @param points The two points delimiting the line segment on each end\n * @returns The line segment delineated by the points\n */\nexport function lineSegment<P extends GlobalPoint | LocalPoint>(\n  a: P,\n  b: P,\n): LineSegment<P> {\n  return [a, b] as LineSegment<P>;\n}\n\n/**\n *\n * @param segment\n * @returns\n */\nexport const isLineSegment = <Point extends GlobalPoint | LocalPoint>(\n  segment: unknown,\n): segment is LineSegment<Point> =>\n  Array.isArray(segment) &&\n  segment.length === 2 &&\n  isPoint(segment[0]) &&\n  isPoint(segment[0]);\n\n/**\n * Return the coordinates resulting from rotating the given line about an origin by an angle in radians\n * note that when the origin is not given, the midpoint of the given line is used as the origin.\n *\n * @param l\n * @param angle\n * @param origin\n * @returns\n */\nexport const lineSegmentRotate = <Point extends LocalPoint | GlobalPoint>(\n  l: LineSegment<Point>,\n  angle: Radians,\n  origin?: Point,\n): LineSegment<Point> => {\n  return lineSegment(\n    pointRotateRads(l[0], origin || pointCenter(l[0], l[1]), angle),\n    pointRotateRads(l[1], origin || pointCenter(l[0], l[1]), angle),\n  );\n};\n\n/**\n * Calculates the point two line segments with a definite start and end point\n * intersect at.\n */\nexport const segmentsIntersectAt = <Point extends GlobalPoint | LocalPoint>(\n  a: Readonly<LineSegment<Point>>,\n  b: Readonly<LineSegment<Point>>,\n): Point | null => {\n  const a0 = vectorFromPoint(a[0]);\n  const a1 = vectorFromPoint(a[1]);\n  const b0 = vectorFromPoint(b[0]);\n  const b1 = vectorFromPoint(b[1]);\n  const r = vectorSubtract(a1, a0);\n  const s = vectorSubtract(b1, b0);\n  const denominator = vectorCross(r, s);\n\n  if (denominator === 0) {\n    return null;\n  }\n\n  const i = vectorSubtract(vectorFromPoint(b[0]), vectorFromPoint(a[0]));\n  const u = vectorCross(i, r) / denominator;\n  const t = vectorCross(i, s) / denominator;\n\n  if (u === 0) {\n    return null;\n  }\n\n  const p = vectorAdd(a0, vectorScale(r, t));\n\n  if (t >= 0 && t < 1 && u >= 0 && u < 1) {\n    return pointFromVector<Point>(p);\n  }\n\n  return null;\n};\n\nexport const pointOnLineSegment = <Point extends LocalPoint | GlobalPoint>(\n  point: Point,\n  line: LineSegment<Point>,\n  threshold = PRECISION,\n) => {\n  const distance = distanceToLineSegment(point, line);\n\n  if (distance === 0) {\n    return true;\n  }\n\n  return distance < threshold;\n};\n\nexport const distanceToLineSegment = <Point extends LocalPoint | GlobalPoint>(\n  point: Point,\n  line: LineSegment<Point>,\n) => {\n  const [x, y] = point;\n  const [[x1, y1], [x2, y2]] = line;\n\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const len_sq = C * C + D * D;\n  let param = -1;\n  if (len_sq !== 0) {\n    param = dot / len_sq;\n  }\n\n  let xx;\n  let yy;\n\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\n/**\n * Returns the intersection point of a segment and a line\n *\n * @param l\n * @param s\n * @returns\n */\nexport function lineSegmentIntersectionPoints<\n  Point extends GlobalPoint | LocalPoint,\n>(\n  l: LineSegment<Point>,\n  s: LineSegment<Point>,\n  threshold?: number,\n): Point | null {\n  const candidate = linesIntersectAt(line(l[0], l[1]), line(s[0], s[1]));\n\n  if (\n    !candidate ||\n    !pointOnLineSegment(candidate, s, threshold) ||\n    !pointOnLineSegment(candidate, l, threshold)\n  ) {\n    return null;\n  }\n\n  return candidate;\n}\n", "import { pointsEqual } from \"./point\";\nimport { lineSegment, pointOnLineSegment } from \"./segment\";\nimport { PRECISION } from \"./utils\";\n\nimport type { GlobalPoint, LocalPoint, Polygon } from \"./types\";\n\nexport function polygon<Point extends GlobalPoint | LocalPoint>(\n  ...points: Point[]\n) {\n  return polygonClose(points) as Polygon<Point>;\n}\n\nexport function polygonFromPoints<Point extends GlobalPoint | LocalPoint>(\n  points: Point[],\n) {\n  return polygonClose(points) as Polygon<Point>;\n}\n\nexport const polygonIncludesPoint = <Point extends LocalPoint | GlobalPoint>(\n  point: Point,\n  polygon: Polygon<Point>,\n) => {\n  const x = point[0];\n  const y = point[1];\n  let inside = false;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i][0];\n    const yi = polygon[i][1];\n    const xj = polygon[j][0];\n    const yj = polygon[j][1];\n\n    if (\n      ((yi > y && yj <= y) || (yi <= y && yj > y)) &&\n      x < ((xj - xi) * (y - yi)) / (yj - yi) + xi\n    ) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n\nexport const polygonIncludesPointNonZero = <Point extends [number, number]>(\n  point: Point,\n  polygon: Point[],\n): boolean => {\n  const [x, y] = point;\n  let windingNumber = 0;\n\n  for (let i = 0; i < polygon.length; i++) {\n    const j = (i + 1) % polygon.length;\n    const [xi, yi] = polygon[i];\n    const [xj, yj] = polygon[j];\n\n    if (yi <= y) {\n      if (yj > y) {\n        if ((xj - xi) * (y - yi) - (x - xi) * (yj - yi) > 0) {\n          windingNumber++;\n        }\n      }\n    } else if (yj <= y) {\n      if ((xj - xi) * (y - yi) - (x - xi) * (yj - yi) < 0) {\n        windingNumber--;\n      }\n    }\n  }\n\n  return windingNumber !== 0;\n};\n\nexport const pointOnPolygon = <Point extends LocalPoint | GlobalPoint>(\n  p: Point,\n  poly: Polygon<Point>,\n  threshold = PRECISION,\n) => {\n  let on = false;\n\n  for (let i = 0, l = poly.length - 1; i < l; i++) {\n    if (pointOnLineSegment(p, lineSegment(poly[i], poly[i + 1]), threshold)) {\n      on = true;\n      break;\n    }\n  }\n\n  return on;\n};\n\nfunction polygonClose<Point extends LocalPoint | GlobalPoint>(\n  polygon: Point[],\n) {\n  return polygonIsClosed(polygon)\n    ? polygon\n    : ([...polygon, polygon[0]] as Polygon<Point>);\n}\n\nfunction polygonIsClosed<Point extends LocalPoint | GlobalPoint>(\n  polygon: Point[],\n) {\n  return pointsEqual(polygon[0], polygon[polygon.length - 1]);\n}\n", "import { toBrandedType } from \"@excalidraw/common\";\n\nimport type { InclusiveRange } from \"./types\";\n\n/**\n * Create an inclusive range from the two numbers provided.\n *\n * @param start Start of the range\n * @param end End of the range\n * @returns\n */\nexport function rangeInclusive(start: number, end: number): InclusiveRange {\n  return toBrandedType<InclusiveRange>([start, end]);\n}\n\n/**\n * Turn a number pair into an inclusive range.\n *\n * @param pair The number pair to convert to an inclusive range\n * @returns The new inclusive range\n */\nexport function rangeInclusiveFromPair(pair: [start: number, end: number]) {\n  return toBrandedType<InclusiveRange>(pair);\n}\n\n/**\n * Given two ranges, return if the two ranges overlap with each other e.g.\n * [1, 3] overlaps with [2, 4] while [1, 3] does not overlap with [4, 5].\n *\n * @param param0 One of the ranges to compare\n * @param param1 The other range to compare against\n * @returns TRUE if the ranges overlap\n */\nexport const rangesOverlap = (\n  [a0, a1]: InclusiveRange,\n  [b0, b1]: InclusiveRange,\n): boolean => {\n  if (a0 <= b0) {\n    return a1 >= b0;\n  }\n\n  if (a0 >= b0) {\n    return b1 >= a0;\n  }\n\n  return false;\n};\n\n/**\n * Given two ranges,return ther intersection of the two ranges if any e.g. the\n * intersection of [1, 3] and [2, 4] is [2, 3].\n *\n * @param param0 The first range to compare\n * @param param1 The second range to compare\n * @returns The inclusive range intersection or NULL if no intersection\n */\nexport const rangeIntersection = (\n  [a0, a1]: InclusiveRange,\n  [b0, b1]: InclusiveRange,\n): InclusiveRange | null => {\n  const rangeStart = Math.max(a0, b0);\n  const rangeEnd = Math.min(a1, b1);\n\n  if (rangeStart <= rangeEnd) {\n    return toBrandedType<InclusiveRange>([rangeStart, rangeEnd]);\n  }\n\n  return null;\n};\n\n/**\n * Determine if a value is inside a range.\n *\n * @param value The value to check\n * @param range The range\n * @returns\n */\nexport const rangeIncludesValue = (\n  value: number,\n  [min, max]: InclusiveRange,\n): boolean => {\n  return value >= min && value <= max;\n};\n", "import { pointFrom } from \"./point\";\nimport { lineSegment, lineSegmentIntersectionPoints } from \"./segment\";\n\nimport type { GlobalPoint, LineSegment, LocalPoint, Rectangle } from \"./types\";\n\nexport function rectangle<P extends GlobalPoint | LocalPoint>(\n  topLeft: P,\n  bottomRight: P,\n): Rectangle<P> {\n  return [topLeft, bottomRight] as Rectangle<P>;\n}\n\nexport function rectangleFromNumberSequence<\n  Point extends LocalPoint | GlobalPoint,\n>(minX: number, minY: number, maxX: number, maxY: number) {\n  return rectangle(pointFrom<Point>(minX, minY), pointFrom<Point>(maxX, maxY));\n}\n\nexport function rectangleIntersectLineSegment<\n  Point extends LocalPoint | GlobalPoint,\n>(r: Rectangle<Point>, l: LineSegment<Point>): Point[] {\n  return [\n    lineSegment(r[0], pointFrom(r[1][0], r[0][1])),\n    lineSegment(pointFrom(r[1][0], r[0][1]), r[1]),\n    lineSegment(r[1], pointFrom(r[0][0], r[1][1])),\n    lineSegment(pointFrom(r[0][0], r[1][1]), r[0]),\n  ]\n    .map((s) => lineSegmentIntersectionPoints(l, s))\n    .filter((i): i is Point => !!i);\n}\n\nexport function rectangleIntersectRectangle<\n  Point extends LocalPoint | GlobalPoint,\n>(rectangle1: Rectangle<Point>, rectangle2: Rectangle<Point>): boolean {\n  const [[minX1, minY1], [maxX1, maxY1]] = rectangle1;\n  const [[minX2, minY2], [maxX2, maxY2]] = rectangle2;\n\n  return minX1 < maxX2 && maxX1 > minX2 && minY1 < maxY2 && maxY1 > minY2;\n}\n", "import type { GlobalPoint, LocalPoint, Triangle } from \"./types\";\n\n// Types\n\n/**\n * Tests if a point lies inside a triangle. This function\n * will return FALSE if the point lies exactly on the sides\n * of the triangle.\n *\n * @param triangle The triangle to test the point for\n * @param p The point to test whether is in the triangle\n * @returns TRUE if the point is inside of the triangle\n */\nexport function triangleIncludesPoint<P extends GlobalPoint | LocalPoint>(\n  [a, b, c]: Triangle<P>,\n  p: P,\n): boolean {\n  const triangleSign = (p1: P, p2: P, p3: P) =>\n    (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1]);\n  const d1 = triangleSign(p, a, b);\n  const d2 = triangleSign(p, b, c);\n  const d3 = triangleSign(p, c, a);\n\n  const has_neg = d1 < 0 || d2 < 0 || d3 < 0;\n  const has_pos = d1 > 0 || d2 > 0 || d3 > 0;\n\n  return !(has_neg && has_pos);\n}\n"],
  "mappings": "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",
  "names": ["line", "solution", "t", "s", "ellipse", "line", "polygon"]
}
