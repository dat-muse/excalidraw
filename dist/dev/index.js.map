{
  "version": 3,
  "sources": [
    "../../index.tsx",
    "../../components/App.tsx",
    "../../actions/actionDeleteSelected.tsx",
    "../../i18n.ts",
    "../../editor-jotai.ts",
    "../../components/icons.tsx",
    "../../components/ToolButton.tsx",
    "../../components/Spinner.tsx",
    "../../actions/register.ts",
    "../../actions/actionZindex.tsx",
    "../../actions/actionSelectAll.ts",
    "../../actions/actionDuplicateSelection.tsx",
    "../../actions/actionProperties.tsx",
    "../../analytics.ts",
    "../../components/RadioSelection.tsx",
    "../../components/ButtonIcon.tsx",
    "../../components/ColorPicker/ColorPicker.tsx",
    "../../components/ButtonSeparator.tsx",
    "../../components/EyeDropper.tsx",
    "../../context/ui-appState.ts",
    "../../hooks/useCreatePortalContainer.ts",
    "../../hooks/useOutsideClick.ts",
    "../../hooks/useStable.ts",
    "../../components/PropertiesPopover.tsx",
    "../../components/Island.tsx",
    "../../components/ColorPicker/ColorInput.tsx",
    "../../components/ColorPicker/colorPickerUtils.ts",
    "../../components/ColorPicker/Picker.tsx",
    "../../components/ColorPicker/CustomColorList.tsx",
    "../../components/ColorPicker/HotkeyLabel.tsx",
    "../../components/ColorPicker/PickerColorList.tsx",
    "../../components/ColorPicker/PickerHeading.tsx",
    "../../components/ColorPicker/ShadeList.tsx",
    "../../components/ColorPicker/keyboardNavHandlers.ts",
    "../../components/ColorPicker/TopPicks.tsx",
    "../../components/FontPicker/FontPicker.tsx",
    "../../components/FontPicker/FontPickerList.tsx",
    "../../components/QuickSearch.tsx",
    "../../components/ScrollableList.tsx",
    "../../components/dropdownMenu/DropdownMenuGroup.tsx",
    "../../components/dropdownMenu/DropdownMenuItem.tsx",
    "../../components/dropdownMenu/DropdownMenuItemContent.tsx",
    "../../components/dropdownMenu/common.ts",
    "../../components/FontPicker/keyboardNavHandlers.ts",
    "../../components/FontPicker/FontPickerTrigger.tsx",
    "../../components/IconPicker.tsx",
    "../../components/InlineIcon.tsx",
    "../../components/Stats/Collapsible.tsx",
    "../../components/Range.tsx",
    "../../actions/actionCanvas.tsx",
    "../../components/Tooltip.tsx",
    "../../cursor.ts",
    "../../scene/zoom.ts",
    "../../actions/actionEmbeddable.ts",
    "../../actions/actionFinalize.tsx",
    "../../actions/actionExport.tsx",
    "../../components/CheckboxItem.tsx",
    "../../components/DarkModeToggle.tsx",
    "../../components/ProjectName.tsx",
    "../../data/index.ts",
    "../../clipboard.ts",
    "../../charts.ts",
    "../../data/resave.ts",
    "../../actions/actionStyles.ts",
    "../../actions/actionMenu.tsx",
    "../../actions/actionGroup.tsx",
    "../../actions/actionNavigate.tsx",
    "../../clients.ts",
    "../../renderer/roundRect.ts",
    "../../components/Avatar.tsx",
    "../../actions/actionAddToLibrary.ts",
    "../../actions/actionAlign.tsx",
    "../../actions/actionDistribute.tsx",
    "../../actions/actionFlip.ts",
    "../../actions/actionClipboard.tsx",
    "../../actions/actionToggleGridMode.tsx",
    "../../actions/actionToggleZenMode.tsx",
    "../../actions/actionToggleObjectsSnapMode.tsx",
    "../../actions/actionToggleStats.tsx",
    "../../actions/actionBoundText.tsx",
    "../../actions/actionLink.tsx",
    "../../components/hyperlink/Hyperlink.tsx",
    "../../actions/actionElementLock.ts",
    "../../actions/actionLinearEditor.tsx",
    "../../components/CommandPalette/CommandPalette.tsx",
    "../../actions/actionToggleShapeSwitch.tsx",
    "../../components/ConvertElementTypePopup.tsx",
    "../../actions/actionElementLink.ts",
    "../../actions/shortcuts.ts",
    "../../deburr.ts",
    "../../components/Dialog.tsx",
    "../../hooks/useCallbackRefState.ts",
    "../../components/LibraryMenu.tsx",
    "../../data/library.ts",
    "../../../utils/src/export.ts",
    "../../hooks/useLibraryItemSvg.ts",
    "../../components/LibraryMenuControlButtons.tsx",
    "../../components/LibraryMenuBrowseButton.tsx",
    "../../components/LibraryMenuItems.tsx",
    "../../hooks/useScrollPosition.ts",
    "../../components/LibraryMenuHeaderContent.tsx",
    "../../components/ConfirmDialog.tsx",
    "../../components/DialogActionButton.tsx",
    "../../components/PublishLibrary.tsx",
    "../../data/EditorLocalStorage.ts",
    "../../components/Trans.tsx",
    "../../components/dropdownMenu/DropdownMenuContent.tsx",
    "../../components/Stack.tsx",
    "../../components/dropdownMenu/DropdownMenuItemCustom.tsx",
    "../../components/dropdownMenu/DropdownMenuItemLink.tsx",
    "../../components/dropdownMenu/DropdownMenuSeparator.tsx",
    "../../components/dropdownMenu/DropdownMenuTrigger.tsx",
    "../../components/dropdownMenu/dropdownMenuUtils.ts",
    "../../components/dropdownMenu/DropdownMenu.tsx",
    "../../components/LibraryMenuSection.tsx",
    "../../hooks/useTransition.ts",
    "../../components/LibraryUnit.tsx",
    "../../components/Modal.tsx",
    "../../components/TextField.tsx",
    "../../components/Button.tsx",
    "../../components/shapes.tsx",
    "../../components/Actions.tsx",
    "../../context/tunnels.ts",
    "../../hooks/useStableCallback.ts",
    "../../components/ActiveConfirmDialog.tsx",
    "../../components/CommandPalette/defaultCommandPaletteItems.ts",
    "../../../element/src/mutateElement.ts",
    "../../../element/src/shape.ts",
    "../../../utils/src/shape.ts",
    "../../../element/src/renderElement.ts",
    "../../../element/src/bounds.ts",
    "../../../element/src/linearElementEditor.ts",
    "../../../element/src/binding.ts",
    "../../../element/src/collision.ts",
    "../../../element/src/utils.ts",
    "../../../element/src/typeChecks.ts",
    "../../../element/src/textElement.ts",
    "../../../element/src/textMeasurements.ts",
    "../../../element/src/textWrapping.ts",
    "../../../element/src/distance.ts",
    "../../../element/src/heading.ts",
    "../../../element/src/elbowArrow.ts",
    "../../../element/src/sizeHelpers.ts",
    "../../../element/src/cropElement.ts",
    "../../../element/src/frame.ts",
    "../../../utils/src/bbox.ts",
    "../../../utils/src/withinBounds.ts",
    "../../../element/src/selection.ts",
    "../../../element/src/groups.ts",
    "../../../element/src/comparisons.ts",
    "../../actions/actionToggleSearchMenu.ts",
    "../../actions/actionCropEditor.tsx",
    "../../actions/actionCustomHighlight.tsx",
    "../../actions/actionFrame.ts",
    "../../actions/actionHistory.tsx",
    "../../history.ts",
    "../../hooks/useEmitter.ts",
    "../../actions/actionTextAutoResize.ts",
    "../../actions/actionToggleViewMode.tsx",
    "../../actions/manager.tsx",
    "../../animation-frame-handler.ts",
    "../../gesture.ts",
    "../../snapping.ts",
    "../../data/transform.ts",
    "../../scene/Renderer.ts",
    "../../renderer/interactiveScene.ts",
    "../../renderer/renderSnaps.ts",
    "../../scene/scrollbars.ts",
    "../../components/ElementCanvasButtons.tsx",
    "../../laser-trails.ts",
    "../../animated-trail.ts",
    "../../reactUtils.ts",
    "../../wysiwyg/textWysiwyg.tsx",
    "../../mermaid.ts",
    "../../lasso/index.ts",
    "../../lasso/utils.ts",
    "../../eraser/index.ts",
    "../../components/BraveMeasureTextError.tsx",
    "../../components/ContextMenu.tsx",
    "../../components/Popover.tsx",
    "../../components/FollowMode/FollowMode.tsx",
    "../../components/LayerUI.tsx",
    "../../components/LoadingMessage.tsx",
    "../../components/LockButton.tsx",
    "../../components/MobileMenu.tsx",
    "../../components/FixedSideContainer.tsx",
    "../../components/HandButton.tsx",
    "../../components/HintViewer.tsx",
    "../../components/PenModeButton.tsx",
    "../../components/Section.tsx",
    "../../components/PasteChartDialog.tsx",
    "../../components/UserList.tsx",
    "../../components/footer/Footer.tsx",
    "../../components/HelpButton.tsx",
    "../../components/Sidebar/Sidebar.tsx",
    "../../components/Sidebar/SidebarHeader.tsx",
    "../../components/Sidebar/common.ts",
    "../../components/Sidebar/SidebarTabTrigger.tsx",
    "../../components/Sidebar/SidebarTabTriggers.tsx",
    "../../components/Sidebar/SidebarTrigger.tsx",
    "../../components/Sidebar/SidebarTabs.tsx",
    "../../components/Sidebar/SidebarTab.tsx",
    "../../components/main-menu/MainMenu.tsx",
    "../../components/hoc/withInternalFallback.tsx",
    "../../components/main-menu/DefaultItems.tsx",
    "../../components/OverwriteConfirm/OverwriteConfirmState.ts",
    "../../components/RadioGroup.tsx",
    "../../components/dropdownMenu/DropdownMenuItemContentRadio.tsx",
    "../../components/FilledButton.tsx",
    "../../components/OverwriteConfirm/OverwriteConfirmActions.tsx",
    "../../components/OverwriteConfirm/OverwriteConfirm.tsx",
    "../../components/DefaultSidebar.tsx",
    "../../components/SearchMenu.tsx",
    "../../components/TTDDialog/TTDDialog.tsx",
    "../../components/TTDDialog/MermaidToExcalidraw.tsx",
    "../../components/TTDDialog/TTDDialogInput.tsx",
    "../../components/TTDDialog/TTDDialogOutput.tsx",
    "../../components/TTDDialog/TTDDialogPanel.tsx",
    "../../components/TTDDialog/TTDDialogPanels.tsx",
    "../../components/TTDDialog/TTDDialogSubmitShortcut.tsx",
    "../../components/TTDDialog/common.ts",
    "../../components/TTDDialog/TTDDialogTabs.tsx",
    "../../components/TTDDialog/TTDDialogTabTriggers.tsx",
    "../../components/TTDDialog/TTDDialogTabTrigger.tsx",
    "../../components/TTDDialog/TTDDialogTab.tsx",
    "../../components/Stats/index.tsx",
    "../../components/Stats/Angle.tsx",
    "../../components/Stats/DragInput.tsx",
    "../../components/Stats/utils.ts",
    "../../components/Stats/CanvasGrid.tsx",
    "../../components/Stats/Dimension.tsx",
    "../../components/Stats/FontSize.tsx",
    "../../components/Stats/MultiAngle.tsx",
    "../../components/Stats/MultiDimension.tsx",
    "../../../utils/src/index.ts",
    "../../components/Stats/MultiFontSize.tsx",
    "../../components/Stats/MultiPosition.tsx",
    "../../components/Stats/Position.tsx",
    "../../components/ElementLinkDialog.tsx",
    "../../components/ErrorDialog.tsx",
    "../../components/HelpDialog.tsx",
    "../../components/ImageExportDialog.tsx",
    "../../hooks/useCopiedIndicator.ts",
    "../../components/Switch.tsx",
    "../../components/JSONExportDialog.tsx",
    "../../components/Card.tsx",
    "../../components/LaserPointerButton.tsx",
    "../../components/MagicButton.tsx",
    "../../components/CustomHighlightCanvasButtons.tsx",
    "../../components/SVGLayer.tsx",
    "../../components/canvases/InteractiveCanvas.tsx",
    "../../components/canvases/StaticCanvas.tsx",
    "../../components/canvases/NewElementCanvas.tsx",
    "../../renderer/renderNewElementScene.ts",
    "../../components/Toast.tsx",
    "../../components/UnlockPopup.tsx",
    "../../components/InitializeApp.tsx",
    "../../components/footer/FooterCenter.tsx",
    "../../components/live-collaboration/LiveCollaborationTrigger.tsx",
    "../../components/ExcalidrawLogo.tsx",
    "../../components/welcome-screen/WelcomeScreen.Center.tsx",
    "../../components/welcome-screen/WelcomeScreen.Hints.tsx",
    "../../components/welcome-screen/WelcomeScreen.tsx",
    "../../polyfill.ts",
    "../../data/reconcile.ts",
    "../../components/TTDDialog/TTDDialogTrigger.tsx",
    "../../components/DiagramToCodePlugin/DiagramToCodePlugin.tsx"
  ],
  "sourcesContent": [
    "import React, { useEffect } from \"react\";\n\nimport { DEFAULT_UI_OPTIONS, isShallowEqual } from \"@excalidraw/common\";\n\nimport App from \"./components/App\";\nimport { InitializeApp } from \"./components/InitializeApp\";\nimport Footer from \"./components/footer/FooterCenter\";\nimport LiveCollaborationTrigger from \"./components/live-collaboration/LiveCollaborationTrigger\";\nimport MainMenu from \"./components/main-menu/MainMenu\";\nimport WelcomeScreen from \"./components/welcome-screen/WelcomeScreen\";\nimport { defaultLang } from \"./i18n\";\nimport { EditorJotaiProvider, editorJotaiStore } from \"./editor-jotai\";\nimport polyfill from \"./polyfill\";\n\nimport \"./css/app.scss\";\nimport \"./css/styles.scss\";\nimport \"./fonts/fonts.css\";\n\nimport type { AppProps, ExcalidrawProps } from \"./types\";\n\npolyfill();\n\nconst ExcalidrawBase = (props: ExcalidrawProps) => {\n  const {\n    onChange,\n    onIncrement,\n    initialData,\n    excalidrawAPI,\n    isCollaborating = false,\n    onPointerUpdate,\n    renderTopRightUI,\n    langCode = defaultLang.code,\n    viewModeEnabled,\n    zenModeEnabled,\n    gridModeEnabled,\n    libraryReturnUrl,\n    theme,\n    name,\n    renderCustomStats,\n    onPaste,\n    detectScroll = true,\n    handleKeyboardGlobally = false,\n    onLibraryChange,\n    autoFocus = false,\n    generateIdForFile,\n    onLinkOpen,\n    generateLinkForSelection,\n    onPointerDown,\n    onPointerUp,\n    onScrollChange,\n    onDuplicate,\n    children,\n    validateEmbeddable,\n    renderEmbeddable,\n    aiEnabled,\n    showDeprecatedFonts,\n    renderScrollbars,\n  } = props;\n\n  const canvasActions = props.UIOptions?.canvasActions;\n\n  // FIXME normalize/set defaults in parent component so that the memo resolver\n  // compares the same values\n  const UIOptions: AppProps[\"UIOptions\"] = {\n    ...props.UIOptions,\n    canvasActions: {\n      ...DEFAULT_UI_OPTIONS.canvasActions,\n      ...canvasActions,\n    },\n    tools: {\n      image: props.UIOptions?.tools?.image ?? true,\n    },\n  };\n\n  if (canvasActions?.export) {\n    UIOptions.canvasActions.export.saveFileToDisk =\n      canvasActions.export?.saveFileToDisk ??\n      DEFAULT_UI_OPTIONS.canvasActions.export.saveFileToDisk;\n  }\n\n  if (\n    UIOptions.canvasActions.toggleTheme === null &&\n    typeof theme === \"undefined\"\n  ) {\n    UIOptions.canvasActions.toggleTheme = true;\n  }\n\n  useEffect(() => {\n    const importPolyfill = async () => {\n      //@ts-ignore\n      await import(\"canvas-roundrect-polyfill\");\n    };\n\n    importPolyfill();\n\n    // Block pinch-zooming on iOS outside of the content area\n    const handleTouchMove = (event: TouchEvent) => {\n      // @ts-ignore\n      if (typeof event.scale === \"number\" && event.scale !== 1) {\n        event.preventDefault();\n      }\n    };\n\n    document.addEventListener(\"touchmove\", handleTouchMove, {\n      passive: false,\n    });\n\n    return () => {\n      document.removeEventListener(\"touchmove\", handleTouchMove);\n    };\n  }, []);\n\n  return (\n    <EditorJotaiProvider store={editorJotaiStore}>\n      <InitializeApp langCode={langCode} theme={theme}>\n        <App\n          onChange={onChange}\n          onIncrement={onIncrement}\n          initialData={initialData}\n          excalidrawAPI={excalidrawAPI}\n          isCollaborating={isCollaborating}\n          onPointerUpdate={onPointerUpdate}\n          renderTopRightUI={renderTopRightUI}\n          langCode={langCode}\n          viewModeEnabled={viewModeEnabled}\n          zenModeEnabled={zenModeEnabled}\n          gridModeEnabled={gridModeEnabled}\n          libraryReturnUrl={libraryReturnUrl}\n          theme={theme}\n          name={name}\n          renderCustomStats={renderCustomStats}\n          UIOptions={UIOptions}\n          onPaste={onPaste}\n          detectScroll={detectScroll}\n          handleKeyboardGlobally={handleKeyboardGlobally}\n          onLibraryChange={onLibraryChange}\n          autoFocus={autoFocus}\n          generateIdForFile={generateIdForFile}\n          onLinkOpen={onLinkOpen}\n          generateLinkForSelection={generateLinkForSelection}\n          onPointerDown={onPointerDown}\n          onPointerUp={onPointerUp}\n          onScrollChange={onScrollChange}\n          onDuplicate={onDuplicate}\n          validateEmbeddable={validateEmbeddable}\n          renderEmbeddable={renderEmbeddable}\n          aiEnabled={aiEnabled !== false}\n          showDeprecatedFonts={showDeprecatedFonts}\n          renderScrollbars={renderScrollbars}\n        >\n          {children}\n        </App>\n      </InitializeApp>\n    </EditorJotaiProvider>\n  );\n};\n\nconst areEqual = (prevProps: ExcalidrawProps, nextProps: ExcalidrawProps) => {\n  // short-circuit early\n  if (prevProps.children !== nextProps.children) {\n    return false;\n  }\n\n  const {\n    initialData: prevInitialData,\n    UIOptions: prevUIOptions = {},\n    ...prev\n  } = prevProps;\n  const {\n    initialData: nextInitialData,\n    UIOptions: nextUIOptions = {},\n    ...next\n  } = nextProps;\n\n  // comparing UIOptions\n  const prevUIOptionsKeys = Object.keys(prevUIOptions) as (keyof Partial<\n    typeof DEFAULT_UI_OPTIONS\n  >)[];\n  const nextUIOptionsKeys = Object.keys(nextUIOptions) as (keyof Partial<\n    typeof DEFAULT_UI_OPTIONS\n  >)[];\n\n  if (prevUIOptionsKeys.length !== nextUIOptionsKeys.length) {\n    return false;\n  }\n\n  const isUIOptionsSame = prevUIOptionsKeys.every((key) => {\n    if (key === \"canvasActions\") {\n      const canvasOptionKeys = Object.keys(\n        prevUIOptions.canvasActions!,\n      ) as (keyof Partial<typeof DEFAULT_UI_OPTIONS.canvasActions>)[];\n      return canvasOptionKeys.every((key) => {\n        if (\n          key === \"export\" &&\n          prevUIOptions?.canvasActions?.export &&\n          nextUIOptions?.canvasActions?.export\n        ) {\n          return (\n            prevUIOptions.canvasActions.export.saveFileToDisk ===\n            nextUIOptions.canvasActions.export.saveFileToDisk\n          );\n        }\n        return (\n          prevUIOptions?.canvasActions?.[key] ===\n          nextUIOptions?.canvasActions?.[key]\n        );\n      });\n    }\n    return prevUIOptions[key] === nextUIOptions[key];\n  });\n\n  return isUIOptionsSame && isShallowEqual(prev, next);\n};\n\nexport const Excalidraw = React.memo(ExcalidrawBase, areEqual);\nExcalidraw.displayName = \"Excalidraw\";\n\nexport {\n  getSceneVersion,\n  hashElementsVersion,\n  hashString,\n  getNonDeletedElements,\n} from \"@excalidraw/element\";\n\nexport { getTextFromElements } from \"@excalidraw/element\";\nexport { isInvisiblySmallElement } from \"@excalidraw/element\";\n\nexport { defaultLang, useI18n, languages } from \"./i18n\";\nexport {\n  restore,\n  restoreAppState,\n  restoreElements,\n  restoreLibraryItems,\n} from \"./data/restore\";\n\nexport { reconcileElements } from \"./data/reconcile\";\n\nexport {\n  exportToCanvas,\n  exportToBlob,\n  exportToSvg,\n  exportToClipboard,\n} from \"@excalidraw/utils/export\";\n\nexport { serializeAsJSON, serializeLibraryAsJSON } from \"./data/json\";\nexport {\n  loadFromBlob,\n  loadSceneOrLibraryFromBlob,\n  loadLibraryFromBlob,\n} from \"./data/blob\";\nexport { getFreeDrawSvgPath } from \"@excalidraw/element\";\nexport { mergeLibraryItems, getLibraryItemsHash } from \"./data/library\";\nexport { isLinearElement } from \"@excalidraw/element\";\n\nexport {\n  FONT_FAMILY,\n  THEME,\n  MIME_TYPES,\n  ROUNDNESS,\n  DEFAULT_LASER_COLOR,\n  UserIdleState,\n  normalizeLink,\n} from \"@excalidraw/common\";\n\nexport {\n  mutateElement,\n  newElementWith,\n  bumpVersion,\n} from \"@excalidraw/element\";\n\nexport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nexport { parseLibraryTokensFromUrl, useHandleLibrary } from \"./data/library\";\n\nexport {\n  sceneCoordsToViewportCoords,\n  viewportCoordsToSceneCoords,\n} from \"@excalidraw/common\";\n\nexport { Sidebar } from \"./components/Sidebar/Sidebar\";\nexport { Button } from \"./components/Button\";\nexport { Footer };\nexport { MainMenu };\nexport { useDevice } from \"./components/App\";\nexport { WelcomeScreen };\nexport { LiveCollaborationTrigger };\nexport { Stats } from \"./components/Stats\";\n\nexport { DefaultSidebar } from \"./components/DefaultSidebar\";\nexport { TTDDialog } from \"./components/TTDDialog/TTDDialog\";\nexport { TTDDialogTrigger } from \"./components/TTDDialog/TTDDialogTrigger\";\n\nexport { zoomToFitBounds } from \"./actions/actionCanvas\";\nexport { convertToExcalidrawElements } from \"./data/transform\";\nexport { getCommonBounds, getVisibleSceneBounds } from \"@excalidraw/element\";\n\nexport {\n  elementsOverlappingBBox,\n  isElementInsideBBox,\n  elementPartiallyOverlapsWithOrContainsBBox,\n} from \"@excalidraw/utils/withinBounds\";\n\nexport { DiagramToCodePlugin } from \"./components/DiagramToCodePlugin/DiagramToCodePlugin\";\nexport { getDataURL } from \"./data/blob\";\nexport { isElementLink } from \"@excalidraw/element\";\n\nexport { setCustomTextMetricsProvider } from \"@excalidraw/element\";\n",
    "import clsx from \"clsx\";\nimport throttle from \"lodash.throttle\";\nimport React, { useContext } from \"react\";\nimport { flushSync } from \"react-dom\";\nimport rough from \"roughjs/bin/rough\";\nimport { nanoid } from \"nanoid\";\n\nimport {\n  clamp,\n  pointFrom,\n  pointDistance,\n  vector,\n  pointRotateRads,\n  vectorScale,\n  vectorFromPoint,\n  vectorSubtract,\n  vectorDot,\n  vectorNormalize,\n} from \"@excalidraw/math\";\n\nimport {\n  COLOR_PALETTE,\n  CODES,\n  shouldResizeFromCenter,\n  shouldMaintainAspectRatio,\n  shouldRotateWithDiscreteAngle,\n  isArrowKey,\n  KEYS,\n  APP_NAME,\n  CURSOR_TYPE,\n  DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT,\n  DEFAULT_VERTICAL_ALIGN,\n  DRAGGING_THRESHOLD,\n  ELEMENT_SHIFT_TRANSLATE_AMOUNT,\n  ELEMENT_TRANSLATE_AMOUNT,\n  EVENT,\n  FRAME_STYLE,\n  IMAGE_MIME_TYPES,\n  IMAGE_RENDER_TIMEOUT,\n  isBrave,\n  LINE_CONFIRM_THRESHOLD,\n  MAX_ALLOWED_FILE_BYTES,\n  MIME_TYPES,\n  MQ_MAX_HEIGHT_LANDSCAPE,\n  MQ_MAX_WIDTH_LANDSCAPE,\n  MQ_MAX_WIDTH_PORTRAIT,\n  MQ_RIGHT_SIDEBAR_MIN_WIDTH,\n  POINTER_BUTTON,\n  ROUNDNESS,\n  SCROLL_TIMEOUT,\n  TAP_TWICE_TIMEOUT,\n  TEXT_TO_CENTER_SNAP_THRESHOLD,\n  THEME,\n  THEME_FILTER,\n  TOUCH_CTX_MENU_TIMEOUT,\n  VERTICAL_ALIGN,\n  YOUTUBE_STATES,\n  ZOOM_STEP,\n  POINTER_EVENTS,\n  TOOL_TYPE,\n  isIOS,\n  supportsResizeObserver,\n  DEFAULT_COLLISION_THRESHOLD,\n  DEFAULT_TEXT_ALIGN,\n  ARROW_TYPE,\n  DEFAULT_REDUCED_GLOBAL_ALPHA,\n  isSafari,\n  isLocalLink,\n  normalizeLink,\n  toValidURL,\n  getGridPoint,\n  getLineHeight,\n  debounce,\n  distance,\n  getFontString,\n  getNearestScrollableContainer,\n  isInputLike,\n  isToolIcon,\n  isWritableElement,\n  sceneCoordsToViewportCoords,\n  tupleToCoors,\n  viewportCoordsToSceneCoords,\n  wrapEvent,\n  updateObject,\n  updateActiveTool,\n  getShortcutKey,\n  isTransparent,\n  easeToValuesRAF,\n  muteFSAbortError,\n  isTestEnv,\n  isDevEnv,\n  easeOut,\n  updateStable,\n  addEventListener,\n  normalizeEOL,\n  getDateTime,\n  isShallowEqual,\n  arrayToMap,\n  type EXPORT_IMAGE_TYPES,\n  randomInteger,\n  CLASSES,\n  Emitter,\n} from \"@excalidraw/common\";\n\nimport {\n  getObservedAppState,\n  getCommonBounds,\n  maybeSuggestBindingsForLinearElementAtCoords,\n  getElementAbsoluteCoords,\n  bindOrUnbindLinearElements,\n  fixBindingsAfterDeletion,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n  shouldEnableBindingForPointerEvent,\n  updateBoundElements,\n  getSuggestedBindingsForArrows,\n  LinearElementEditor,\n  newElementWith,\n  newFrameElement,\n  newFreeDrawElement,\n  newEmbeddableElement,\n  newMagicFrameElement,\n  newIframeElement,\n  newArrowElement,\n  newElement,\n  newImageElement,\n  newLinearElement,\n  newTextElement,\n  refreshTextDimensions,\n  deepCopyElement,\n  duplicateElements,\n  hasBoundTextElement,\n  isArrowElement,\n  isBindingElement,\n  isBindingElementType,\n  isBoundToContainer,\n  isFrameLikeElement,\n  isImageElement,\n  isEmbeddableElement,\n  isInitializedImageElement,\n  isLinearElement,\n  isLinearElementType,\n  isUsingAdaptiveRadius,\n  isIframeElement,\n  isIframeLikeElement,\n  isMagicFrameElement,\n  isTextBindableContainer,\n  isElbowArrow,\n  isFlowchartNodeElement,\n  isBindableElement,\n  isTextElement,\n  getLockedLinearCursorAlignSize,\n  getNormalizedDimensions,\n  isElementCompletelyInViewport,\n  isElementInViewport,\n  isInvisiblySmallElement,\n  getCornerRadius,\n  isPathALoop,\n  createSrcDoc,\n  embeddableURLValidator,\n  maybeParseEmbedSrc,\n  getEmbedLink,\n  getInitializedImageElements,\n  normalizeSVG,\n  updateImageCache as _updateImageCache,\n  getBoundTextElement,\n  getContainerCenter,\n  getContainerElement,\n  isValidTextContainer,\n  redrawTextBoundingBox,\n  shouldShowBoundingBox,\n  getFrameChildren,\n  isCursorInFrame,\n  addElementsToFrame,\n  replaceAllElementsInFrame,\n  removeElementsFromFrame,\n  getElementsInResizingFrame,\n  getElementsInNewFrame,\n  getContainingFrame,\n  elementOverlapsWithFrame,\n  updateFrameMembershipOfSelectedElements,\n  isElementInFrame,\n  getFrameLikeTitle,\n  getElementsOverlappingFrame,\n  filterElementsEligibleAsFrameChildren,\n  hitElementBoundText,\n  hitElementBoundingBoxOnly,\n  hitElementItself,\n  getVisibleSceneBounds,\n  FlowChartCreator,\n  FlowChartNavigator,\n  getLinkDirectionFromKey,\n  cropElement,\n  wrapText,\n  isElementLink,\n  parseElementLinkFromURL,\n  isMeasureTextSupported,\n  normalizeText,\n  measureText,\n  getLineHeightInPx,\n  getApproxMinLineWidth,\n  getApproxMinLineHeight,\n  getMinTextElementWidth,\n  ShapeCache,\n  getRenderOpacity,\n  editGroupForSelectedElement,\n  getElementsInGroup,\n  getSelectedGroupIdForElement,\n  getSelectedGroupIds,\n  isElementInGroup,\n  isSelectedViaGroup,\n  selectGroupsForSelectedElements,\n  syncInvalidIndices,\n  syncMovedIndices,\n  excludeElementsInFramesFromSelection,\n  getSelectionStateForElements,\n  makeNextSelectedElementIds,\n  getResizeOffsetXY,\n  getResizeArrowDirection,\n  transformElements,\n  getCursorForResizingElement,\n  getElementWithTransformHandleType,\n  getTransformHandleTypeFromCoords,\n  dragNewElement,\n  dragSelectedElements,\n  getDragOffsetXY,\n  isNonDeletedElement,\n  Scene,\n  Store,\n  CaptureUpdateAction,\n  type ElementUpdate,\n  hitElementBoundingBox,\n  isLineElement,\n  isSimpleArrow,\n} from \"@excalidraw/element\";\n\nimport type { LocalPoint, Radians } from \"@excalidraw/math\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawGenericElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  NonDeleted,\n  InitializedExcalidrawImageElement,\n  ExcalidrawImageElement,\n  FileId,\n  NonDeletedExcalidrawElement,\n  ExcalidrawTextContainer,\n  ExcalidrawFrameLikeElement,\n  ExcalidrawMagicFrameElement,\n  ExcalidrawIframeLikeElement,\n  IframeData,\n  ExcalidrawIframeElement,\n  ExcalidrawEmbeddableElement,\n  Ordered,\n  MagicGenerationData,\n  ExcalidrawArrowElement,\n  ExcalidrawElbowArrowElement,\n} from \"@excalidraw/element/types\";\n\nimport type { Mutable, ValueOf } from \"@excalidraw/common/utility-types\";\n\nimport {\n  actionAddToLibrary,\n  actionBringForward,\n  actionBringToFront,\n  actionCopy,\n  actionCopyAsPng,\n  actionCopyAsSvg,\n  copyText,\n  actionCopyStyles,\n  actionCut,\n  actionDeleteSelected,\n  actionDuplicateSelection,\n  actionFinalize,\n  actionFlipHorizontal,\n  actionFlipVertical,\n  actionGroup,\n  actionPasteStyles,\n  actionSelectAll,\n  actionSendBackward,\n  actionSendToBack,\n  actionToggleGridMode,\n  actionToggleStats,\n  actionToggleZenMode,\n  actionUnbindText,\n  actionBindText,\n  actionUngroup,\n  actionLink,\n  actionToggleElementLock,\n  actionToggleLinearEditor,\n  actionToggleObjectsSnapMode,\n  actionToggleCropEditor,\n} from \"../actions\";\nimport { actionWrapTextInContainer } from \"../actions/actionBoundText\";\nimport { actionToggleHandTool, zoomToFit } from \"../actions/actionCanvas\";\nimport { actionPaste } from \"../actions/actionClipboard\";\nimport { actionCopyElementLink } from \"../actions/actionElementLink\";\nimport { actionUnlockAllElements } from \"../actions/actionElementLock\";\nimport {\n  actionRemoveAllElementsFromFrame,\n  actionSelectAllElementsInFrame,\n  actionWrapSelectionInFrame,\n} from \"../actions/actionFrame\";\nimport { createRedoAction, createUndoAction } from \"../actions/actionHistory\";\nimport { actionTextAutoResize } from \"../actions/actionTextAutoResize\";\nimport { actionToggleViewMode } from \"../actions/actionToggleViewMode\";\nimport { ActionManager } from \"../actions/manager\";\nimport { actions } from \"../actions/register\";\nimport { getShortcutFromShortcutName } from \"../actions/shortcuts\";\nimport { trackEvent } from \"../analytics\";\nimport { AnimationFrameHandler } from \"../animation-frame-handler\";\nimport {\n  getDefaultAppState,\n  isEraserActive,\n  isHandToolActive,\n} from \"../appState\";\nimport { copyTextToSystemClipboard, parseClipboard } from \"../clipboard\";\nimport { exportCanvas, loadFromBlob } from \"../data\";\nimport Library, { distributeLibraryItemsOnSquareGrid } from \"../data/library\";\nimport { restore, restoreElements } from \"../data/restore\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport { History } from \"../history\";\nimport { defaultLang, getLanguage, languages, setLanguage, t } from \"../i18n\";\n\nimport {\n  calculateScrollCenter,\n  getElementsWithinSelection,\n  getNormalizedZoom,\n  getSelectedElements,\n  hasBackground,\n  isSomeElementSelected,\n} from \"../scene\";\nimport { getStateForZoom } from \"../scene/zoom\";\nimport {\n  dataURLToString,\n  generateIdFromFile,\n  getDataURL,\n  getDataURL_sync,\n  getFileFromEvent,\n  ImageURLToFile,\n  isImageFileHandle,\n  isSupportedImageFile,\n  loadSceneOrLibraryFromBlob,\n  normalizeFile,\n  parseLibraryJSON,\n  resizeImageFile,\n  SVGStringToFile,\n} from \"../data/blob\";\n\nimport { fileOpen } from \"../data/filesystem\";\nimport {\n  showHyperlinkTooltip,\n  hideHyperlinkToolip,\n  Hyperlink,\n} from \"../components/hyperlink/Hyperlink\";\n\nimport { Fonts } from \"../fonts\";\nimport { editorJotaiStore, type WritableAtom } from \"../editor-jotai\";\nimport { ImageSceneDataError } from \"../errors\";\nimport {\n  getSnapLinesAtPointer,\n  snapDraggedElements,\n  isActiveToolNonLinearSnappable,\n  snapNewElement,\n  snapResizingElements,\n  isSnappingEnabled,\n  getVisibleGaps,\n  getReferenceSnapPoints,\n  SnapCache,\n  isGridModeEnabled,\n} from \"../snapping\";\nimport { convertToExcalidrawElements } from \"../data/transform\";\nimport { Renderer } from \"../scene/Renderer\";\nimport {\n  setEraserCursor,\n  setCursor,\n  resetCursor,\n  setCursorForShape,\n} from \"../cursor\";\nimport { ElementCanvasButtons } from \"../components/ElementCanvasButtons\";\nimport { LaserTrails } from \"../laser-trails\";\nimport { withBatchedUpdates, withBatchedUpdatesThrottled } from \"../reactUtils\";\nimport { textWysiwyg } from \"../wysiwyg/textWysiwyg\";\nimport { isOverScrollBars } from \"../scene/scrollbars\";\n\nimport { isMaybeMermaidDefinition } from \"../mermaid\";\n\nimport { LassoTrail } from \"../lasso\";\n\nimport { EraserTrail } from \"../eraser\";\n\nimport ConvertElementTypePopup, {\n  getConversionTypeFromElements,\n  convertElementTypePopupAtom,\n  convertElementTypes,\n} from \"./ConvertElementTypePopup\";\n\nimport { activeConfirmDialogAtom } from \"./ActiveConfirmDialog\";\nimport BraveMeasureTextError from \"./BraveMeasureTextError\";\nimport { ContextMenu, CONTEXT_MENU_SEPARATOR } from \"./ContextMenu\";\nimport { activeEyeDropperAtom } from \"./EyeDropper\";\nimport FollowMode from \"./FollowMode/FollowMode\";\nimport LayerUI from \"./LayerUI\";\nimport { ElementCanvasButton } from \"./MagicButton\";\nimport { CustomHighlightCanvasButtons } from \"./CustomHighlightCanvasButtons\";\nimport { SVGLayer } from \"./SVGLayer\";\nimport { searchItemInFocusAtom } from \"./SearchMenu\";\nimport { isSidebarDockedAtom } from \"./Sidebar/Sidebar\";\nimport { StaticCanvas, InteractiveCanvas } from \"./canvases\";\nimport NewElementCanvas from \"./canvases/NewElementCanvas\";\nimport {\n  isPointHittingLink,\n  isPointHittingLinkIcon,\n} from \"./hyperlink/helpers\";\nimport { MagicIcon, copyIcon, fullscreenIcon } from \"./icons\";\nimport { Toast } from \"./Toast\";\n\nimport { findShapeByKey } from \"./shapes\";\n\nimport UnlockPopup from \"./UnlockPopup\";\n\nimport type {\n  RenderInteractiveSceneCallback,\n  ScrollBars,\n} from \"../scene/types\";\n\nimport type { PastedMixedContent } from \"../clipboard\";\nimport type { ExportedElements } from \"../data\";\nimport type { ContextMenuItems } from \"./ContextMenu\";\nimport type { FileSystemHandle } from \"../data/filesystem\";\nimport type { ExcalidrawElementSkeleton } from \"../data/transform\";\nimport type {\n  AppClassProperties,\n  AppProps,\n  AppState,\n  BinaryFileData,\n  ExcalidrawImperativeAPI,\n  BinaryFiles,\n  Gesture,\n  GestureEvent,\n  LibraryItems,\n  PointerDownState,\n  SceneData,\n  Device,\n  FrameNameBoundsCache,\n  SidebarName,\n  SidebarTabName,\n  KeyboardModifiersObject,\n  CollaboratorPointer,\n  ToolType,\n  OnUserFollowedPayload,\n  UnsubscribeCallback,\n  EmbedsValidationStatus,\n  ElementsPendingErasure,\n  GenerateDiagramToCode,\n  NullableGridSize,\n  Offsets,\n} from \"../types\";\nimport type { RoughCanvas } from \"roughjs/bin/canvas\";\nimport type { Action, ActionResult } from \"../actions/types\";\n\nconst AppContext = React.createContext<AppClassProperties>(null!);\nconst AppPropsContext = React.createContext<AppProps>(null!);\n\nconst deviceContextInitialValue = {\n  viewport: {\n    isMobile: false,\n    isLandscape: false,\n  },\n  editor: {\n    isMobile: false,\n    canFitSidebar: false,\n  },\n  isTouchScreen: false,\n};\nconst DeviceContext = React.createContext<Device>(deviceContextInitialValue);\nDeviceContext.displayName = \"DeviceContext\";\n\nexport const ExcalidrawContainerContext = React.createContext<{\n  container: HTMLDivElement | null;\n  id: string | null;\n}>({ container: null, id: null });\nExcalidrawContainerContext.displayName = \"ExcalidrawContainerContext\";\n\nconst ExcalidrawElementsContext = React.createContext<\n  readonly NonDeletedExcalidrawElement[]\n>([]);\nExcalidrawElementsContext.displayName = \"ExcalidrawElementsContext\";\n\nconst ExcalidrawAppStateContext = React.createContext<AppState>({\n  ...getDefaultAppState(),\n  width: 0,\n  height: 0,\n  offsetLeft: 0,\n  offsetTop: 0,\n});\nExcalidrawAppStateContext.displayName = \"ExcalidrawAppStateContext\";\n\nconst ExcalidrawSetAppStateContext = React.createContext<\n  React.Component<any, AppState>[\"setState\"]\n>(() => {\n  console.warn(\"Uninitialized ExcalidrawSetAppStateContext context!\");\n});\nExcalidrawSetAppStateContext.displayName = \"ExcalidrawSetAppStateContext\";\n\nconst ExcalidrawActionManagerContext = React.createContext<ActionManager>(\n  null!,\n);\nExcalidrawActionManagerContext.displayName = \"ExcalidrawActionManagerContext\";\n\nexport const useApp = () => useContext(AppContext);\nexport const useAppProps = () => useContext(AppPropsContext);\nexport const useDevice = () => useContext<Device>(DeviceContext);\nexport const useExcalidrawContainer = () =>\n  useContext(ExcalidrawContainerContext);\nexport const useExcalidrawElements = () =>\n  useContext(ExcalidrawElementsContext);\nexport const useExcalidrawAppState = () =>\n  useContext(ExcalidrawAppStateContext);\nexport const useExcalidrawSetAppState = () =>\n  useContext(ExcalidrawSetAppStateContext);\nexport const useExcalidrawActionManager = () =>\n  useContext(ExcalidrawActionManagerContext);\n\nlet didTapTwice: boolean = false;\nlet tappedTwiceTimer = 0;\nlet isHoldingSpace: boolean = false;\nlet isPanning: boolean = false;\nlet isDraggingScrollBar: boolean = false;\nlet currentScrollBars: ScrollBars = { horizontal: null, vertical: null };\nlet touchTimeout = 0;\nlet invalidateContextMenu = false;\n\n/**\n * Map of youtube embed video states\n */\nconst YOUTUBE_VIDEO_STATES = new Map<\n  ExcalidrawElement[\"id\"],\n  ValueOf<typeof YOUTUBE_STATES>\n>();\n\nlet IS_PLAIN_PASTE = false;\nlet IS_PLAIN_PASTE_TIMER = 0;\nlet PLAIN_PASTE_TOAST_SHOWN = false;\n\nlet lastPointerUp: (() => void) | null = null;\nconst gesture: Gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null,\n};\n\nclass App extends React.Component<AppProps, AppState> {\n  canvas: AppClassProperties[\"canvas\"];\n  interactiveCanvas: AppClassProperties[\"interactiveCanvas\"] = null;\n  rc: RoughCanvas;\n  unmounted: boolean = false;\n  actionManager: ActionManager;\n  device: Device = deviceContextInitialValue;\n\n  private excalidrawContainerRef = React.createRef<HTMLDivElement>();\n\n  public scene: Scene;\n  public fonts: Fonts;\n  public renderer: Renderer;\n  public visibleElements: readonly NonDeletedExcalidrawElement[];\n  private resizeObserver: ResizeObserver | undefined;\n  private nearestScrollableContainer: HTMLElement | Document | undefined;\n  public library: AppClassProperties[\"library\"];\n  public libraryItemsFromStorage: LibraryItems | undefined;\n  public id: string;\n  private store: Store;\n  private history: History;\n  public excalidrawContainerValue: {\n    container: HTMLDivElement | null;\n    id: string;\n  };\n\n  public files: BinaryFiles = {};\n  public imageCache: AppClassProperties[\"imageCache\"] = new Map();\n  private iFrameRefs = new Map<ExcalidrawElement[\"id\"], HTMLIFrameElement>();\n  /**\n   * Indicates whether the embeddable's url has been validated for rendering.\n   * If value not set, indicates that the validation is pending.\n   * Initially or on url change the flag is not reset so that we can guarantee\n   * the validation came from a trusted source (the editor).\n   **/\n  private embedsValidationStatus: EmbedsValidationStatus = new Map();\n  /** embeds that have been inserted to DOM (as a perf optim, we don't want to\n   * insert to DOM before user initially scrolls to them) */\n  private initializedEmbeds = new Set<ExcalidrawIframeLikeElement[\"id\"]>();\n\n  private handleToastClose = () => {\n    this.setToast(null);\n  };\n\n  private elementsPendingErasure: ElementsPendingErasure = new Set();\n\n  public flowChartCreator: FlowChartCreator = new FlowChartCreator();\n  private flowChartNavigator: FlowChartNavigator = new FlowChartNavigator();\n\n  hitLinkElement?: NonDeletedExcalidrawElement;\n  lastPointerDownEvent: React.PointerEvent<HTMLElement> | null = null;\n  lastPointerUpEvent: React.PointerEvent<HTMLElement> | PointerEvent | null =\n    null;\n  lastPointerMoveEvent: PointerEvent | null = null;\n  lastPointerMoveCoords: { x: number; y: number } | null = null;\n  lastViewportPosition = { x: 0, y: 0 };\n\n  animationFrameHandler = new AnimationFrameHandler();\n\n  laserTrails = new LaserTrails(this.animationFrameHandler, this);\n  eraserTrail = new EraserTrail(this.animationFrameHandler, this);\n  lassoTrail = new LassoTrail(this.animationFrameHandler, this);\n\n  onChangeEmitter = new Emitter<\n    [\n      elements: readonly ExcalidrawElement[],\n      appState: AppState,\n      files: BinaryFiles,\n    ]\n  >();\n\n  onPointerDownEmitter = new Emitter<\n    [\n      activeTool: AppState[\"activeTool\"],\n      pointerDownState: PointerDownState,\n      event: React.PointerEvent<HTMLElement>,\n    ]\n  >();\n\n  onPointerUpEmitter = new Emitter<\n    [\n      activeTool: AppState[\"activeTool\"],\n      pointerDownState: PointerDownState,\n      event: PointerEvent,\n    ]\n  >();\n  onUserFollowEmitter = new Emitter<[payload: OnUserFollowedPayload]>();\n  onScrollChangeEmitter = new Emitter<\n    [scrollX: number, scrollY: number, zoom: AppState[\"zoom\"]]\n  >();\n\n  missingPointerEventCleanupEmitter = new Emitter<\n    [event: PointerEvent | null]\n  >();\n  onRemoveEventListenersEmitter = new Emitter<[]>();\n\n  constructor(props: AppProps) {\n    super(props);\n    const defaultAppState = getDefaultAppState();\n    const {\n      excalidrawAPI,\n      viewModeEnabled = false,\n      zenModeEnabled = false,\n      gridModeEnabled = false,\n      objectsSnapModeEnabled = false,\n      theme = defaultAppState.theme,\n      name = `${t(\"labels.untitled\")}-${getDateTime()}`,\n    } = props;\n    this.state = {\n      ...defaultAppState,\n      theme,\n      isLoading: true,\n      ...this.getCanvasOffsets(),\n      viewModeEnabled,\n      zenModeEnabled,\n      objectsSnapModeEnabled,\n      gridModeEnabled: gridModeEnabled ?? defaultAppState.gridModeEnabled,\n      name,\n      width: window.innerWidth,\n      height: window.innerHeight,\n    };\n\n    this.id = nanoid();\n    this.library = new Library(this);\n    this.actionManager = new ActionManager(\n      this.syncActionResult,\n      () => this.state,\n      () => this.scene.getElementsIncludingDeleted(),\n      this,\n    );\n    this.scene = new Scene();\n\n    this.canvas = document.createElement(\"canvas\");\n    this.rc = rough.canvas(this.canvas);\n    this.renderer = new Renderer(this.scene);\n    this.visibleElements = [];\n\n    this.store = new Store(this);\n    this.history = new History(this.store);\n\n    if (excalidrawAPI) {\n      const api: ExcalidrawImperativeAPI = {\n        updateScene: this.updateScene,\n        mutateElement: this.mutateElement,\n        updateLibrary: this.library.updateLibrary,\n        addFiles: this.addFiles,\n        resetScene: this.resetScene,\n        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,\n        getSceneElementsMapIncludingDeleted:\n          this.getSceneElementsMapIncludingDeleted,\n        history: {\n          clear: this.resetHistory,\n        },\n        scrollToContent: this.scrollToContent,\n        getSceneElements: this.getSceneElements,\n        getAppState: () => this.state,\n        getFiles: () => this.files,\n        getName: this.getName,\n        registerAction: (action: Action) => {\n          this.actionManager.registerAction(action);\n        },\n        refresh: this.refresh,\n        setToast: this.setToast,\n        id: this.id,\n        setActiveTool: this.setActiveTool,\n        setCursor: this.setCursor,\n        resetCursor: this.resetCursor,\n        updateFrameRendering: this.updateFrameRendering,\n        toggleSidebar: this.toggleSidebar,\n        onChange: (cb) => this.onChangeEmitter.on(cb),\n        onIncrement: (cb) => this.store.onStoreIncrementEmitter.on(cb),\n        onPointerDown: (cb) => this.onPointerDownEmitter.on(cb),\n        onPointerUp: (cb) => this.onPointerUpEmitter.on(cb),\n        onScrollChange: (cb) => this.onScrollChangeEmitter.on(cb),\n        onUserFollow: (cb) => this.onUserFollowEmitter.on(cb),\n      } as const;\n      if (typeof excalidrawAPI === \"function\") {\n        excalidrawAPI(api);\n      } else {\n        console.error(\"excalidrawAPI should be a function!\");\n      }\n    }\n\n    this.excalidrawContainerValue = {\n      container: this.excalidrawContainerRef.current,\n      id: this.id,\n    };\n\n    this.fonts = new Fonts(this.scene);\n    this.history = new History(this.store);\n\n    this.actionManager.registerAll(actions);\n    this.actionManager.registerAction(createUndoAction(this.history));\n    this.actionManager.registerAction(createRedoAction(this.history));\n  }\n\n  updateEditorAtom = <Value, Args extends unknown[], Result>(\n    atom: WritableAtom<Value, Args, Result>,\n    ...args: Args\n  ): Result => {\n    const result = editorJotaiStore.set(atom, ...args);\n    this.triggerRender();\n    return result;\n  };\n\n  private onWindowMessage(event: MessageEvent) {\n    if (\n      event.origin !== \"https://player.vimeo.com\" &&\n      event.origin !== \"https://www.youtube.com\"\n    ) {\n      return;\n    }\n\n    let data = null;\n    try {\n      data = JSON.parse(event.data);\n    } catch (e) {}\n    if (!data) {\n      return;\n    }\n\n    switch (event.origin) {\n      case \"https://player.vimeo.com\":\n        //Allowing for multiple instances of Excalidraw running in the window\n        if (data.method === \"paused\") {\n          let source: Window | null = null;\n          const iframes = document.body.querySelectorAll(\n            \"iframe.excalidraw__embeddable\",\n          );\n          if (!iframes) {\n            break;\n          }\n          for (const iframe of iframes as NodeListOf<HTMLIFrameElement>) {\n            if (iframe.contentWindow === event.source) {\n              source = iframe.contentWindow;\n            }\n          }\n          source?.postMessage(\n            JSON.stringify({\n              method: data.value ? \"play\" : \"pause\",\n              value: true,\n            }),\n            \"*\",\n          );\n        }\n        break;\n      case \"https://www.youtube.com\":\n        if (\n          data.event === \"infoDelivery\" &&\n          data.info &&\n          data.id &&\n          typeof data.info.playerState === \"number\"\n        ) {\n          const id = data.id;\n          const playerState = data.info.playerState as number;\n          if (\n            (Object.values(YOUTUBE_STATES) as number[]).includes(playerState)\n          ) {\n            YOUTUBE_VIDEO_STATES.set(\n              id,\n              playerState as ValueOf<typeof YOUTUBE_STATES>,\n            );\n          }\n        }\n        break;\n    }\n  }\n\n  private cacheEmbeddableRef(\n    element: ExcalidrawIframeLikeElement,\n    ref: HTMLIFrameElement | null,\n  ) {\n    if (ref) {\n      this.iFrameRefs.set(element.id, ref);\n    }\n  }\n\n  /**\n   * Returns gridSize taking into account `gridModeEnabled`.\n   * If disabled, returns null.\n   */\n  public getEffectiveGridSize = () => {\n    return (\n      isGridModeEnabled(this) ? this.state.gridSize : null\n    ) as NullableGridSize;\n  };\n\n  private getHTMLIFrameElement(\n    element: ExcalidrawIframeLikeElement,\n  ): HTMLIFrameElement | undefined {\n    return this.iFrameRefs.get(element.id);\n  }\n\n  private handleEmbeddableCenterClick(element: ExcalidrawIframeLikeElement) {\n    if (\n      this.state.activeEmbeddable?.element === element &&\n      this.state.activeEmbeddable?.state === \"active\"\n    ) {\n      return;\n    }\n\n    // The delay serves two purposes\n    // 1. To prevent first click propagating to iframe on mobile,\n    //    else the click will immediately start and stop the video\n    // 2. If the user double clicks the frame center to activate it\n    //    without the delay youtube will immediately open the video\n    //    in fullscreen mode\n    setTimeout(() => {\n      this.setState({\n        activeEmbeddable: { element, state: \"active\" },\n        selectedElementIds: { [element.id]: true },\n        newElement: null,\n        selectionElement: null,\n      });\n    }, 100);\n\n    if (isIframeElement(element)) {\n      return;\n    }\n\n    const iframe = this.getHTMLIFrameElement(element);\n\n    if (!iframe?.contentWindow) {\n      return;\n    }\n\n    if (iframe.src.includes(\"youtube\")) {\n      const state = YOUTUBE_VIDEO_STATES.get(element.id);\n      if (!state) {\n        YOUTUBE_VIDEO_STATES.set(element.id, YOUTUBE_STATES.UNSTARTED);\n        iframe.contentWindow.postMessage(\n          JSON.stringify({\n            event: \"listening\",\n            id: element.id,\n          }),\n          \"*\",\n        );\n      }\n      switch (state) {\n        case YOUTUBE_STATES.PLAYING:\n        case YOUTUBE_STATES.BUFFERING:\n          iframe.contentWindow?.postMessage(\n            JSON.stringify({\n              event: \"command\",\n              func: \"pauseVideo\",\n              args: \"\",\n            }),\n            \"*\",\n          );\n          break;\n        default:\n          iframe.contentWindow?.postMessage(\n            JSON.stringify({\n              event: \"command\",\n              func: \"playVideo\",\n              args: \"\",\n            }),\n            \"*\",\n          );\n      }\n    }\n\n    if (iframe.src.includes(\"player.vimeo.com\")) {\n      iframe.contentWindow.postMessage(\n        JSON.stringify({\n          method: \"paused\", //video play/pause in onWindowMessage handler\n        }),\n        \"*\",\n      );\n    }\n  }\n\n  private isIframeLikeElementCenter(\n    el: ExcalidrawIframeLikeElement | null,\n    event: React.PointerEvent<HTMLElement> | PointerEvent,\n    sceneX: number,\n    sceneY: number,\n  ) {\n    return (\n      el &&\n      !event.altKey &&\n      !event.shiftKey &&\n      !event.metaKey &&\n      !event.ctrlKey &&\n      (this.state.activeEmbeddable?.element !== el ||\n        this.state.activeEmbeddable?.state === \"hover\" ||\n        !this.state.activeEmbeddable) &&\n      sceneX >= el.x + el.width / 3 &&\n      sceneX <= el.x + (2 * el.width) / 3 &&\n      sceneY >= el.y + el.height / 3 &&\n      sceneY <= el.y + (2 * el.height) / 3\n    );\n  }\n\n  private updateEmbedValidationStatus = (\n    element: ExcalidrawEmbeddableElement,\n    status: boolean,\n  ) => {\n    this.embedsValidationStatus.set(element.id, status);\n    ShapeCache.delete(element);\n  };\n\n  private updateEmbeddables = () => {\n    const iframeLikes = new Set<ExcalidrawIframeLikeElement[\"id\"]>();\n\n    let updated = false;\n    this.scene.getNonDeletedElements().filter((element) => {\n      if (isEmbeddableElement(element)) {\n        iframeLikes.add(element.id);\n        if (!this.embedsValidationStatus.has(element.id)) {\n          updated = true;\n\n          const validated = embeddableURLValidator(\n            element.link,\n            this.props.validateEmbeddable,\n          );\n\n          this.updateEmbedValidationStatus(element, validated);\n        }\n      } else if (isIframeElement(element)) {\n        iframeLikes.add(element.id);\n      }\n      return false;\n    });\n\n    if (updated) {\n      this.scene.triggerUpdate();\n    }\n\n    // GC\n    this.iFrameRefs.forEach((ref, id) => {\n      if (!iframeLikes.has(id)) {\n        this.iFrameRefs.delete(id);\n      }\n    });\n  };\n\n  private renderEmbeddables() {\n    const scale = this.state.zoom.value;\n    const normalizedWidth = this.state.width;\n    const normalizedHeight = this.state.height;\n\n    const embeddableElements = this.scene\n      .getNonDeletedElements()\n      .filter(\n        (el): el is Ordered<NonDeleted<ExcalidrawIframeLikeElement>> =>\n          (isEmbeddableElement(el) &&\n            this.embedsValidationStatus.get(el.id) === true) ||\n          isIframeElement(el),\n      );\n\n    return (\n      <>\n        {embeddableElements.map((el) => {\n          const { x, y } = sceneCoordsToViewportCoords(\n            { sceneX: el.x, sceneY: el.y },\n            this.state,\n          );\n\n          const isVisible = isElementInViewport(\n            el,\n            normalizedWidth,\n            normalizedHeight,\n            this.state,\n            this.scene.getNonDeletedElementsMap(),\n          );\n          const hasBeenInitialized = this.initializedEmbeds.has(el.id);\n\n          if (isVisible && !hasBeenInitialized) {\n            this.initializedEmbeds.add(el.id);\n          }\n          const shouldRender = isVisible || hasBeenInitialized;\n\n          if (!shouldRender) {\n            return null;\n          }\n\n          let src: IframeData | null;\n\n          if (isIframeElement(el)) {\n            src = null;\n\n            const data: MagicGenerationData = (el.customData?.generationData ??\n              this.magicGenerations.get(el.id)) || {\n              status: \"error\",\n              message: \"No generation data\",\n              code: \"ERR_NO_GENERATION_DATA\",\n            };\n\n            if (data.status === \"done\") {\n              const html = data.html;\n              src = {\n                intrinsicSize: { w: el.width, h: el.height },\n                type: \"document\",\n                srcdoc: () => {\n                  return html;\n                },\n              } as const;\n            } else if (data.status === \"pending\") {\n              src = {\n                intrinsicSize: { w: el.width, h: el.height },\n                type: \"document\",\n                srcdoc: () => {\n                  return createSrcDoc(`\n                    <style>\n                      html, body {\n                        width: 100%;\n                        height: 100%;\n                        color: ${\n                          this.state.theme === THEME.DARK ? \"white\" : \"black\"\n                        };\n                      }\n                      body {\n                        display: flex;\n                        align-items: center;\n                        justify-content: center;\n                        flex-direction: column;\n                        gap: 1rem;\n                      }\n\n                      .Spinner {\n                        display: flex;\n                        align-items: center;\n                        justify-content: center;\n                        margin-left: auto;\n                        margin-right: auto;\n                      }\n\n                      .Spinner svg {\n                        animation: rotate 1.6s linear infinite;\n                        transform-origin: center center;\n                        width: 40px;\n                        height: 40px;\n                      }\n\n                      .Spinner circle {\n                        stroke: currentColor;\n                        animation: dash 1.6s linear 0s infinite;\n                        stroke-linecap: round;\n                      }\n\n                      @keyframes rotate {\n                        100% {\n                          transform: rotate(360deg);\n                        }\n                      }\n\n                      @keyframes dash {\n                        0% {\n                          stroke-dasharray: 1, 300;\n                          stroke-dashoffset: 0;\n                        }\n                        50% {\n                          stroke-dasharray: 150, 300;\n                          stroke-dashoffset: -200;\n                        }\n                        100% {\n                          stroke-dasharray: 1, 300;\n                          stroke-dashoffset: -280;\n                        }\n                      }\n                    </style>\n                    <div class=\"Spinner\">\n                      <svg\n                        viewBox=\"0 0 100 100\"\n                      >\n                        <circle\n                          cx=\"50\"\n                          cy=\"50\"\n                          r=\"46\"\n                          stroke-width=\"8\"\n                          fill=\"none\"\n                          stroke-miter-limit=\"10\"\n                        />\n                      </svg>\n                    </div>\n                    <div>Generating...</div>\n                  `);\n                },\n              } as const;\n            } else {\n              let message: string;\n              if (data.code === \"ERR_GENERATION_INTERRUPTED\") {\n                message = \"Generation was interrupted...\";\n              } else {\n                message = data.message || \"Generation failed\";\n              }\n              src = {\n                intrinsicSize: { w: el.width, h: el.height },\n                type: \"document\",\n                srcdoc: () => {\n                  return createSrcDoc(`\n                    <style>\n                    html, body {\n                      height: 100%;\n                    }\n                      body {\n                        display: flex;\n                        flex-direction: column;\n                        align-items: center;\n                        justify-content: center;\n                        color: ${COLOR_PALETTE.red[3]};\n                      }\n                      h1, h3 {\n                        margin-top: 0;\n                        margin-bottom: 0.5rem;\n                      }\n                    </style>\n                    <h1>Error!</h1>\n                    <h3>${message}</h3>\n                  `);\n                },\n              } as const;\n            }\n          } else {\n            src = getEmbedLink(toValidURL(el.link || \"\"));\n          }\n\n          const isActive =\n            this.state.activeEmbeddable?.element === el &&\n            this.state.activeEmbeddable?.state === \"active\";\n          const isHovered =\n            this.state.activeEmbeddable?.element === el &&\n            this.state.activeEmbeddable?.state === \"hover\";\n\n          return (\n            <div\n              key={el.id}\n              className={clsx(\"excalidraw__embeddable-container\", {\n                \"is-hovered\": isHovered,\n              })}\n              style={{\n                transform: isVisible\n                  ? `translate(${x - this.state.offsetLeft}px, ${\n                      y - this.state.offsetTop\n                    }px) scale(${scale})`\n                  : \"none\",\n                display: isVisible ? \"block\" : \"none\",\n                opacity: getRenderOpacity(\n                  el,\n                  getContainingFrame(el, this.scene.getNonDeletedElementsMap()),\n                  this.elementsPendingErasure,\n                  null,\n                  this.state.openDialog?.name === \"elementLinkSelector\"\n                    ? DEFAULT_REDUCED_GLOBAL_ALPHA\n                    : 1,\n                ),\n                [\"--embeddable-radius\" as string]: `${getCornerRadius(\n                  Math.min(el.width, el.height),\n                  el,\n                )}px`,\n              }}\n            >\n              <div\n                //this is a hack that addresses isse with embedded excalidraw.com embeddable\n                //https://github.com/excalidraw/excalidraw/pull/6691#issuecomment-1607383938\n                /*ref={(ref) => {\n                  if (!this.excalidrawContainerRef.current) {\n                    return;\n                  }\n                  const container = this.excalidrawContainerRef.current;\n                  const sh = container.scrollHeight;\n                  const ch = container.clientHeight;\n                  if (sh !== ch) {\n                    container.style.height = `${sh}px`;\n                    setTimeout(() => {\n                      container.style.height = `100%`;\n                    });\n                  }\n                }}*/\n                className=\"excalidraw__embeddable-container__inner\"\n                style={{\n                  width: isVisible ? `${el.width}px` : 0,\n                  height: isVisible ? `${el.height}px` : 0,\n                  transform: isVisible ? `rotate(${el.angle}rad)` : \"none\",\n                  pointerEvents: isActive\n                    ? POINTER_EVENTS.enabled\n                    : POINTER_EVENTS.disabled,\n                }}\n              >\n                {isHovered && (\n                  <div className=\"excalidraw__embeddable-hint\">\n                    {t(\"buttons.embeddableInteractionButton\")}\n                  </div>\n                )}\n                <div\n                  className=\"excalidraw__embeddable__outer\"\n                  style={{\n                    padding: `${el.strokeWidth}px`,\n                  }}\n                >\n                  {(isEmbeddableElement(el)\n                    ? this.props.renderEmbeddable?.(el, this.state)\n                    : null) ?? (\n                    <iframe\n                      ref={(ref) => this.cacheEmbeddableRef(el, ref)}\n                      className=\"excalidraw__embeddable\"\n                      srcDoc={\n                        src?.type === \"document\"\n                          ? src.srcdoc(this.state.theme)\n                          : undefined\n                      }\n                      src={\n                        src?.type !== \"document\" ? src?.link ?? \"\" : undefined\n                      }\n                      // https://stackoverflow.com/q/18470015\n                      scrolling=\"no\"\n                      referrerPolicy=\"no-referrer-when-downgrade\"\n                      title=\"Excalidraw Embedded Content\"\n                      allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n                      allowFullScreen={true}\n                      sandbox={`${\n                        src?.sandbox?.allowSameOrigin ? \"allow-same-origin\" : \"\"\n                      } allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation allow-downloads`}\n                    />\n                  )}\n                </div>\n              </div>\n            </div>\n          );\n        })}\n      </>\n    );\n  }\n\n  private getFrameNameDOMId = (frameElement: ExcalidrawElement) => {\n    return `${this.id}-frame-name-${frameElement.id}`;\n  };\n\n  frameNameBoundsCache: FrameNameBoundsCache = {\n    get: (frameElement) => {\n      let bounds = this.frameNameBoundsCache._cache.get(frameElement.id);\n      if (\n        !bounds ||\n        bounds.zoom !== this.state.zoom.value ||\n        bounds.versionNonce !== frameElement.versionNonce\n      ) {\n        const frameNameDiv = document.getElementById(\n          this.getFrameNameDOMId(frameElement),\n        );\n\n        if (frameNameDiv) {\n          const box = frameNameDiv.getBoundingClientRect();\n          const boxSceneTopLeft = viewportCoordsToSceneCoords(\n            { clientX: box.x, clientY: box.y },\n            this.state,\n          );\n          const boxSceneBottomRight = viewportCoordsToSceneCoords(\n            { clientX: box.right, clientY: box.bottom },\n            this.state,\n          );\n\n          bounds = {\n            x: boxSceneTopLeft.x,\n            y: boxSceneTopLeft.y,\n            width: boxSceneBottomRight.x - boxSceneTopLeft.x,\n            height: boxSceneBottomRight.y - boxSceneTopLeft.y,\n            angle: 0,\n            zoom: this.state.zoom.value,\n            versionNonce: frameElement.versionNonce,\n          };\n\n          this.frameNameBoundsCache._cache.set(frameElement.id, bounds);\n\n          return bounds;\n        }\n        return null;\n      }\n\n      return bounds;\n    },\n    /**\n     * @private\n     */\n    _cache: new Map(),\n  };\n\n  private resetEditingFrame = (frame: ExcalidrawFrameLikeElement | null) => {\n    if (frame) {\n      this.scene.mutateElement(frame, { name: frame.name?.trim() || null });\n    }\n    this.setState({ editingFrame: null });\n  };\n\n  private renderFrameNames = () => {\n    if (!this.state.frameRendering.enabled || !this.state.frameRendering.name) {\n      if (this.state.editingFrame) {\n        this.resetEditingFrame(null);\n      }\n      return null;\n    }\n\n    const isDarkTheme = this.state.theme === THEME.DARK;\n    const nonDeletedFramesLikes = this.scene.getNonDeletedFramesLikes();\n\n    const focusedSearchMatch =\n      nonDeletedFramesLikes.length > 0\n        ? this.state.searchMatches?.focusedId &&\n          isFrameLikeElement(\n            this.scene.getElement(this.state.searchMatches.focusedId),\n          )\n          ? this.state.searchMatches.matches.find((sm) => sm.focus)\n          : null\n        : null;\n\n    return nonDeletedFramesLikes.map((f) => {\n      if (\n        !isElementInViewport(\n          f,\n          this.canvas.width / window.devicePixelRatio,\n          this.canvas.height / window.devicePixelRatio,\n          {\n            offsetLeft: this.state.offsetLeft,\n            offsetTop: this.state.offsetTop,\n            scrollX: this.state.scrollX,\n            scrollY: this.state.scrollY,\n            zoom: this.state.zoom,\n          },\n          this.scene.getNonDeletedElementsMap(),\n        )\n      ) {\n        if (this.state.editingFrame === f.id) {\n          this.resetEditingFrame(f);\n        }\n        // if frame not visible, don't render its name\n        return null;\n      }\n\n      const { x: x1, y: y1 } = sceneCoordsToViewportCoords(\n        { sceneX: f.x, sceneY: f.y },\n        this.state,\n      );\n\n      const FRAME_NAME_EDIT_PADDING = 6;\n\n      let frameNameJSX;\n\n      const frameName = getFrameLikeTitle(f);\n\n      if (f.id === this.state.editingFrame) {\n        const frameNameInEdit = frameName;\n\n        frameNameJSX = (\n          <input\n            autoFocus\n            value={frameNameInEdit}\n            onChange={(e) => {\n              this.scene.mutateElement(f, {\n                name: e.target.value,\n              });\n            }}\n            onFocus={(e) => e.target.select()}\n            onBlur={() => this.resetEditingFrame(f)}\n            onKeyDown={(event) => {\n              // for some inexplicable reason, `onBlur` triggered on ESC\n              // does not reset `state.editingFrame` despite being called,\n              // and we need to reset it here as well\n              if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {\n                this.resetEditingFrame(f);\n              }\n            }}\n            style={{\n              background: this.state.viewBackgroundColor,\n              filter: isDarkTheme ? THEME_FILTER : \"none\",\n              zIndex: 2,\n              border: \"none\",\n              display: \"block\",\n              padding: `${FRAME_NAME_EDIT_PADDING}px`,\n              borderRadius: 4,\n              boxShadow: \"inset 0 0 0 1px var(--color-primary)\",\n              fontFamily: \"Assistant\",\n              fontSize: `${FRAME_STYLE.nameFontSize}px`,\n              transform: `translate(-${FRAME_NAME_EDIT_PADDING}px, ${FRAME_NAME_EDIT_PADDING}px)`,\n              color: \"var(--color-gray-80)\",\n              overflow: \"hidden\",\n              maxWidth: `${\n                document.body.clientWidth - x1 - FRAME_NAME_EDIT_PADDING\n              }px`,\n            }}\n            size={frameNameInEdit.length + 1 || 1}\n            dir=\"auto\"\n            autoComplete=\"off\"\n            autoCapitalize=\"off\"\n            autoCorrect=\"off\"\n          />\n        );\n      } else {\n        frameNameJSX = frameName;\n      }\n\n      return (\n        <div\n          id={this.getFrameNameDOMId(f)}\n          key={f.id}\n          style={{\n            position: \"absolute\",\n            // Positioning from bottom so that we don't to either\n            // calculate text height or adjust using transform (which)\n            // messes up input position when editing the frame name.\n            // This makes the positioning deterministic and we can calculate\n            // the same position when rendering to canvas / svg.\n            bottom: `${\n              this.state.height +\n              FRAME_STYLE.nameOffsetY -\n              y1 +\n              this.state.offsetTop\n            }px`,\n            left: `${x1 - this.state.offsetLeft}px`,\n            zIndex: 2,\n            fontSize: FRAME_STYLE.nameFontSize,\n            color: isDarkTheme\n              ? FRAME_STYLE.nameColorDarkTheme\n              : FRAME_STYLE.nameColorLightTheme,\n            lineHeight: FRAME_STYLE.nameLineHeight,\n            width: \"max-content\",\n            maxWidth:\n              focusedSearchMatch?.id === f.id && focusedSearchMatch?.focus\n                ? \"none\"\n                : `${f.width * this.state.zoom.value}px`,\n            overflow: f.id === this.state.editingFrame ? \"visible\" : \"hidden\",\n            whiteSpace: \"nowrap\",\n            textOverflow: \"ellipsis\",\n            cursor: CURSOR_TYPE.MOVE,\n            pointerEvents: this.state.viewModeEnabled\n              ? POINTER_EVENTS.disabled\n              : POINTER_EVENTS.enabled,\n          }}\n          onPointerDown={(event) => this.handleCanvasPointerDown(event)}\n          onWheel={(event) => this.handleWheel(event)}\n          onContextMenu={this.handleCanvasContextMenu}\n          onDoubleClick={() => {\n            this.setState({\n              editingFrame: f.id,\n            });\n          }}\n        >\n          {frameNameJSX}\n        </div>\n      );\n    });\n  };\n\n  private toggleOverscrollBehavior(event: React.PointerEvent) {\n    // when pointer inside editor, disable overscroll behavior to prevent\n    // panning to trigger history back/forward on MacOS Chrome\n    document.documentElement.style.overscrollBehaviorX =\n      event.type === \"pointerenter\" ? \"none\" : \"auto\";\n  }\n\n  public render() {\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    const { renderTopRightUI, renderCustomStats } = this.props;\n\n    const sceneNonce = this.scene.getSceneNonce();\n    const { elementsMap, visibleElements } =\n      this.renderer.getRenderableElements({\n        sceneNonce,\n        zoom: this.state.zoom,\n        offsetLeft: this.state.offsetLeft,\n        offsetTop: this.state.offsetTop,\n        scrollX: this.state.scrollX,\n        scrollY: this.state.scrollY,\n        height: this.state.height,\n        width: this.state.width,\n        editingTextElement: this.state.editingTextElement,\n        newElementId: this.state.newElement?.id,\n      });\n    this.visibleElements = visibleElements;\n\n    const allElementsMap = this.scene.getNonDeletedElementsMap();\n\n    const shouldBlockPointerEvents =\n      // default back to `--ui-pointerEvents` flow if setPointerCapture\n      // not supported\n      \"setPointerCapture\" in HTMLElement.prototype\n        ? false\n        : this.state.selectionElement ||\n          this.state.newElement ||\n          this.state.selectedElementsAreBeingDragged ||\n          this.state.resizingElement ||\n          (this.state.activeTool.type === \"laser\" &&\n            // technically we can just test on this once we make it more safe\n            this.state.cursorButton === \"down\");\n\n    const firstSelectedElement = selectedElements[0];\n\n    const showShapeSwitchPanel =\n      editorJotaiStore.get(convertElementTypePopupAtom)?.type === \"panel\";\n\n    return (\n      <div\n        className={clsx(\"excalidraw excalidraw-container\", {\n          \"excalidraw--view-mode\":\n            this.state.viewModeEnabled ||\n            this.state.openDialog?.name === \"elementLinkSelector\",\n          \"excalidraw--mobile\": this.device.editor.isMobile,\n        })}\n        style={{\n          [\"--ui-pointerEvents\" as any]: shouldBlockPointerEvents\n            ? POINTER_EVENTS.disabled\n            : POINTER_EVENTS.enabled,\n          [\"--right-sidebar-width\" as any]: \"302px\",\n        }}\n        ref={this.excalidrawContainerRef}\n        onDrop={this.handleAppOnDrop}\n        tabIndex={0}\n        onKeyDown={\n          this.props.handleKeyboardGlobally ? undefined : this.onKeyDown\n        }\n        onPointerEnter={this.toggleOverscrollBehavior}\n        onPointerLeave={this.toggleOverscrollBehavior}\n      >\n        <AppContext.Provider value={this}>\n          <AppPropsContext.Provider value={this.props}>\n            <ExcalidrawContainerContext.Provider\n              value={this.excalidrawContainerValue}\n            >\n              <DeviceContext.Provider value={this.device}>\n                <ExcalidrawSetAppStateContext.Provider value={this.setAppState}>\n                  <ExcalidrawAppStateContext.Provider value={this.state}>\n                    <ExcalidrawElementsContext.Provider\n                      value={this.scene.getNonDeletedElements()}\n                    >\n                      <ExcalidrawActionManagerContext.Provider\n                        value={this.actionManager}\n                      >\n                        <LayerUI\n                          canvas={this.canvas}\n                          appState={this.state}\n                          files={this.files}\n                          setAppState={this.setAppState}\n                          actionManager={this.actionManager}\n                          elements={this.scene.getNonDeletedElements()}\n                          onLockToggle={this.toggleLock}\n                          onPenModeToggle={this.togglePenMode}\n                          onHandToolToggle={this.onHandToolToggle}\n                          langCode={getLanguage().code}\n                          renderTopRightUI={renderTopRightUI}\n                          renderCustomStats={renderCustomStats}\n                          showExitZenModeBtn={\n                            typeof this.props?.zenModeEnabled === \"undefined\" &&\n                            this.state.zenModeEnabled\n                          }\n                          UIOptions={this.props.UIOptions}\n                          onExportImage={this.onExportImage}\n                          renderWelcomeScreen={\n                            !this.state.isLoading &&\n                            this.state.showWelcomeScreen &&\n                            this.state.activeTool.type === \"selection\" &&\n                            !this.state.zenModeEnabled &&\n                            !this.scene.getElementsIncludingDeleted().length\n                          }\n                          app={this}\n                          isCollaborating={this.props.isCollaborating}\n                          generateLinkForSelection={\n                            this.props.generateLinkForSelection\n                          }\n                        >\n                          {this.props.children}\n                        </LayerUI>\n\n                        <div className=\"excalidraw-textEditorContainer\" />\n                        <div className=\"excalidraw-contextMenuContainer\" />\n                        <div className=\"excalidraw-eye-dropper-container\" />\n                        <SVGLayer\n                          trails={[\n                            this.laserTrails,\n                            this.lassoTrail,\n                            this.eraserTrail,\n                          ]}\n                        />\n                        {selectedElements.length === 1 &&\n                          this.state.openDialog?.name !==\n                            \"elementLinkSelector\" &&\n                          this.state.showHyperlinkPopup && (\n                            <Hyperlink\n                              key={firstSelectedElement.id}\n                              element={firstSelectedElement}\n                              scene={this.scene}\n                              setAppState={this.setAppState}\n                              onLinkOpen={this.props.onLinkOpen}\n                              setToast={this.setToast}\n                              updateEmbedValidationStatus={\n                                this.updateEmbedValidationStatus\n                              }\n                            />\n                          )}\n                        {this.props.aiEnabled !== false &&\n                          selectedElements.length === 1 &&\n                          isMagicFrameElement(firstSelectedElement) && (\n                            <ElementCanvasButtons\n                              element={firstSelectedElement}\n                              elementsMap={elementsMap}\n                            >\n                              <ElementCanvasButton\n                                title={t(\"labels.convertToCode\")}\n                                icon={MagicIcon}\n                                checked={false}\n                                onChange={() =>\n                                  this.onMagicFrameGenerate(\n                                    firstSelectedElement,\n                                    \"button\",\n                                  )\n                                }\n                              />\n                            </ElementCanvasButtons>\n                          )}\n                        {selectedElements.length === 1 &&\n                          isIframeElement(firstSelectedElement) &&\n                          firstSelectedElement.customData?.generationData\n                            ?.status === \"done\" && (\n                            <ElementCanvasButtons\n                              element={firstSelectedElement}\n                              elementsMap={elementsMap}\n                            >\n                              <ElementCanvasButton\n                                title={t(\"labels.copySource\")}\n                                icon={copyIcon}\n                                checked={false}\n                                onChange={() =>\n                                  this.onIframeSrcCopy(firstSelectedElement)\n                                }\n                              />\n                              <ElementCanvasButton\n                                title=\"Enter fullscreen\"\n                                icon={fullscreenIcon}\n                                checked={false}\n                                onChange={() => {\n                                  const iframe =\n                                    this.getHTMLIFrameElement(\n                                      firstSelectedElement,\n                                    );\n                                  if (iframe) {\n                                    try {\n                                      iframe.requestFullscreen();\n                                      this.setState({\n                                        activeEmbeddable: {\n                                          element: firstSelectedElement,\n                                          state: \"active\",\n                                        },\n                                        selectedElementIds: {\n                                          [firstSelectedElement.id]: true,\n                                        },\n                                        newElement: null,\n                                        selectionElement: null,\n                                      });\n                                    } catch (err: any) {\n                                      console.warn(err);\n                                      this.setState({\n                                        errorMessage:\n                                          \"Couldn't enter fullscreen\",\n                                      });\n                                    }\n                                  }\n                                }}\n                              />\n                            </ElementCanvasButtons>\n                          )}\n\n                        {/* Custom Highlight Canvas Buttons */}\n                        <CustomHighlightCanvasButtons\n                          elements={this.scene.getNonDeletedElements()}\n                          elementsMap={elementsMap}\n                          app={this}\n                        />\n\n                        {this.state.toast !== null && (\n                          <Toast\n                            message={this.state.toast.message}\n                            onClose={this.handleToastClose}\n                            duration={this.state.toast.duration}\n                            closable={this.state.toast.closable}\n                          />\n                        )}\n\n                        {this.state.contextMenu && (\n                          <ContextMenu\n                            items={this.state.contextMenu.items}\n                            top={this.state.contextMenu.top}\n                            left={this.state.contextMenu.left}\n                            actionManager={this.actionManager}\n                            onClose={(callback) => {\n                              this.setState({ contextMenu: null }, () => {\n                                this.focusContainer();\n                                callback?.();\n                              });\n                            }}\n                          />\n                        )}\n                        <StaticCanvas\n                          canvas={this.canvas}\n                          rc={this.rc}\n                          elementsMap={elementsMap}\n                          allElementsMap={allElementsMap}\n                          visibleElements={visibleElements}\n                          sceneNonce={sceneNonce}\n                          selectionNonce={\n                            this.state.selectionElement?.versionNonce\n                          }\n                          scale={window.devicePixelRatio}\n                          appState={this.state}\n                          renderConfig={{\n                            imageCache: this.imageCache,\n                            isExporting: false,\n                            renderGrid: isGridModeEnabled(this),\n                            canvasBackgroundColor:\n                              this.state.viewBackgroundColor,\n                            embedsValidationStatus: this.embedsValidationStatus,\n                            elementsPendingErasure: this.elementsPendingErasure,\n                            pendingFlowchartNodes:\n                              this.flowChartCreator.pendingNodes,\n                          }}\n                        />\n                        {this.state.newElement && (\n                          <NewElementCanvas\n                            appState={this.state}\n                            scale={window.devicePixelRatio}\n                            rc={this.rc}\n                            elementsMap={elementsMap}\n                            allElementsMap={allElementsMap}\n                            renderConfig={{\n                              imageCache: this.imageCache,\n                              isExporting: false,\n                              renderGrid: false,\n                              canvasBackgroundColor:\n                                this.state.viewBackgroundColor,\n                              embedsValidationStatus:\n                                this.embedsValidationStatus,\n                              elementsPendingErasure:\n                                this.elementsPendingErasure,\n                              pendingFlowchartNodes: null,\n                            }}\n                          />\n                        )}\n                        <InteractiveCanvas\n                          containerRef={this.excalidrawContainerRef}\n                          canvas={this.interactiveCanvas}\n                          elementsMap={elementsMap}\n                          visibleElements={visibleElements}\n                          allElementsMap={allElementsMap}\n                          selectedElements={selectedElements}\n                          sceneNonce={sceneNonce}\n                          selectionNonce={\n                            this.state.selectionElement?.versionNonce\n                          }\n                          scale={window.devicePixelRatio}\n                          appState={this.state}\n                          renderScrollbars={\n                            this.props.renderScrollbars === true\n                          }\n                          device={this.device}\n                          renderInteractiveSceneCallback={\n                            this.renderInteractiveSceneCallback\n                          }\n                          handleCanvasRef={this.handleInteractiveCanvasRef}\n                          onContextMenu={this.handleCanvasContextMenu}\n                          onPointerMove={this.handleCanvasPointerMove}\n                          onPointerUp={this.handleCanvasPointerUp}\n                          onPointerCancel={this.removePointer}\n                          onTouchMove={this.handleTouchMove}\n                          onPointerDown={this.handleCanvasPointerDown}\n                          onDoubleClick={this.handleCanvasDoubleClick}\n                        />\n                        {this.state.userToFollow && (\n                          <FollowMode\n                            width={this.state.width}\n                            height={this.state.height}\n                            userToFollow={this.state.userToFollow}\n                            onDisconnect={this.maybeUnfollowRemoteUser}\n                          />\n                        )}\n                        {this.renderFrameNames()}\n                        {this.state.activeLockedId && (\n                          <UnlockPopup\n                            app={this}\n                            activeLockedId={this.state.activeLockedId}\n                          />\n                        )}\n                        {showShapeSwitchPanel && (\n                          <ConvertElementTypePopup app={this} />\n                        )}\n                      </ExcalidrawActionManagerContext.Provider>\n                      {this.renderEmbeddables()}\n                    </ExcalidrawElementsContext.Provider>\n                  </ExcalidrawAppStateContext.Provider>\n                </ExcalidrawSetAppStateContext.Provider>\n              </DeviceContext.Provider>\n            </ExcalidrawContainerContext.Provider>\n          </AppPropsContext.Provider>\n        </AppContext.Provider>\n      </div>\n    );\n  }\n\n  public focusContainer: AppClassProperties[\"focusContainer\"] = () => {\n    this.excalidrawContainerRef.current?.focus();\n  };\n\n  public getSceneElementsIncludingDeleted = () => {\n    return this.scene.getElementsIncludingDeleted();\n  };\n\n  public getSceneElementsMapIncludingDeleted = () => {\n    return this.scene.getElementsMapIncludingDeleted();\n  };\n\n  public getSceneElements = () => {\n    return this.scene.getNonDeletedElements();\n  };\n\n  public onInsertElements = (elements: readonly ExcalidrawElement[]) => {\n    this.addElementsFromPasteOrLibrary({\n      elements,\n      position: \"center\",\n      files: null,\n    });\n  };\n\n  public onExportImage = async (\n    type: keyof typeof EXPORT_IMAGE_TYPES,\n    elements: ExportedElements,\n    opts: { exportingFrame: ExcalidrawFrameLikeElement | null },\n  ) => {\n    trackEvent(\"export\", type, \"ui\");\n    const fileHandle = await exportCanvas(\n      type,\n      elements,\n      this.state,\n      this.files,\n      {\n        exportBackground: this.state.exportBackground,\n        name: this.getName(),\n        viewBackgroundColor: this.state.viewBackgroundColor,\n        exportingFrame: opts.exportingFrame,\n      },\n    )\n      .catch(muteFSAbortError)\n      .catch((error) => {\n        console.error(error);\n        this.setState({ errorMessage: error.message });\n      });\n\n    if (\n      this.state.exportEmbedScene &&\n      fileHandle &&\n      isImageFileHandle(fileHandle)\n    ) {\n      this.setState({ fileHandle });\n    }\n  };\n\n  private magicGenerations = new Map<\n    ExcalidrawIframeElement[\"id\"],\n    MagicGenerationData\n  >();\n\n  private updateMagicGeneration = ({\n    frameElement,\n    data,\n  }: {\n    frameElement: ExcalidrawIframeElement;\n    data: MagicGenerationData;\n  }) => {\n    if (data.status === \"pending\") {\n      // We don't wanna persist pending state to storage. It should be in-app\n      // state only.\n      // Thus reset so that we prefer local cache (if there was some\n      // generationData set previously)\n      this.scene.mutateElement(\n        frameElement,\n        {\n          customData: { generationData: undefined },\n        },\n        { informMutation: false, isDragging: false },\n      );\n    } else {\n      this.scene.mutateElement(\n        frameElement,\n        {\n          customData: { generationData: data },\n        },\n        { informMutation: false, isDragging: false },\n      );\n    }\n    this.magicGenerations.set(frameElement.id, data);\n    this.triggerRender();\n  };\n\n  public plugins: {\n    diagramToCode?: {\n      generate: GenerateDiagramToCode;\n    };\n  } = {};\n\n  public setPlugins(plugins: Partial<App[\"plugins\"]>) {\n    Object.assign(this.plugins, plugins);\n  }\n\n  private async onMagicFrameGenerate(\n    magicFrame: ExcalidrawMagicFrameElement,\n    source: \"button\" | \"upstream\",\n  ) {\n    const generateDiagramToCode = this.plugins.diagramToCode?.generate;\n\n    if (!generateDiagramToCode) {\n      this.setState({\n        errorMessage: \"No diagram to code plugin found\",\n      });\n      return;\n    }\n\n    const magicFrameChildren = getElementsOverlappingFrame(\n      this.scene.getNonDeletedElements(),\n      magicFrame,\n    ).filter((el) => !isMagicFrameElement(el));\n\n    if (!magicFrameChildren.length) {\n      if (source === \"button\") {\n        this.setState({ errorMessage: \"Cannot generate from an empty frame\" });\n        trackEvent(\"ai\", \"generate (no-children)\", \"d2c\");\n      } else {\n        this.setActiveTool({ type: \"magicframe\" });\n      }\n      return;\n    }\n\n    const frameElement = this.insertIframeElement({\n      sceneX: magicFrame.x + magicFrame.width + 30,\n      sceneY: magicFrame.y,\n      width: magicFrame.width,\n      height: magicFrame.height,\n    });\n\n    if (!frameElement) {\n      return;\n    }\n\n    this.updateMagicGeneration({\n      frameElement,\n      data: { status: \"pending\" },\n    });\n\n    this.setState({\n      selectedElementIds: { [frameElement.id]: true },\n    });\n\n    trackEvent(\"ai\", \"generate (start)\", \"d2c\");\n    try {\n      const { html } = await generateDiagramToCode({\n        frame: magicFrame,\n        children: magicFrameChildren,\n      });\n\n      trackEvent(\"ai\", \"generate (success)\", \"d2c\");\n\n      if (!html.trim()) {\n        this.updateMagicGeneration({\n          frameElement,\n          data: {\n            status: \"error\",\n            code: \"ERR_OAI\",\n            message: \"Nothing genereated :(\",\n          },\n        });\n        return;\n      }\n\n      const parsedHtml =\n        html.includes(\"<!DOCTYPE html>\") && html.includes(\"</html>\")\n          ? html.slice(\n              html.indexOf(\"<!DOCTYPE html>\"),\n              html.indexOf(\"</html>\") + \"</html>\".length,\n            )\n          : html;\n\n      this.updateMagicGeneration({\n        frameElement,\n        data: { status: \"done\", html: parsedHtml },\n      });\n    } catch (error: any) {\n      trackEvent(\"ai\", \"generate (failed)\", \"d2c\");\n      this.updateMagicGeneration({\n        frameElement,\n        data: {\n          status: \"error\",\n          code: \"ERR_OAI\",\n          message: error.message || \"Unknown error during generation\",\n        },\n      });\n    }\n  }\n\n  private onIframeSrcCopy(element: ExcalidrawIframeElement) {\n    if (element.customData?.generationData?.status === \"done\") {\n      copyTextToSystemClipboard(element.customData.generationData.html);\n      this.setToast({\n        message: \"copied to clipboard\",\n        closable: false,\n        duration: 1500,\n      });\n    }\n  }\n\n  public onMagicframeToolSelect = () => {\n    const selectedElements = this.scene.getSelectedElements({\n      selectedElementIds: this.state.selectedElementIds,\n    });\n\n    if (selectedElements.length === 0) {\n      this.setActiveTool({ type: TOOL_TYPE.magicframe });\n      trackEvent(\"ai\", \"tool-select (empty-selection)\", \"d2c\");\n    } else {\n      const selectedMagicFrame: ExcalidrawMagicFrameElement | false =\n        selectedElements.length === 1 &&\n        isMagicFrameElement(selectedElements[0]) &&\n        selectedElements[0];\n\n      // case: user selected elements containing frame-like(s) or are frame\n      // members, we don't want to wrap into another magicframe\n      // (unless the only selected element is a magic frame which we reuse)\n      if (\n        !selectedMagicFrame &&\n        selectedElements.some((el) => isFrameLikeElement(el) || el.frameId)\n      ) {\n        this.setActiveTool({ type: TOOL_TYPE.magicframe });\n        return;\n      }\n\n      trackEvent(\"ai\", \"tool-select (existing selection)\", \"d2c\");\n\n      let frame: ExcalidrawMagicFrameElement;\n      if (selectedMagicFrame) {\n        // a single magicframe already selected -> use it\n        frame = selectedMagicFrame;\n      } else {\n        // selected elements aren't wrapped in magic frame yet -> wrap now\n\n        const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);\n        const padding = 50;\n\n        frame = newMagicFrameElement({\n          ...FRAME_STYLE,\n          x: minX - padding,\n          y: minY - padding,\n          width: maxX - minX + padding * 2,\n          height: maxY - minY + padding * 2,\n          opacity: 100,\n          locked: false,\n        });\n\n        this.scene.insertElement(frame);\n\n        for (const child of selectedElements) {\n          this.scene.mutateElement(child, { frameId: frame.id });\n        }\n\n        this.setState({\n          selectedElementIds: { [frame.id]: true },\n        });\n      }\n\n      this.onMagicFrameGenerate(frame, \"upstream\");\n    }\n  };\n\n  private openEyeDropper = ({ type }: { type: \"stroke\" | \"background\" }) => {\n    this.updateEditorAtom(activeEyeDropperAtom, {\n      swapPreviewOnAlt: true,\n      colorPickerType:\n        type === \"stroke\" ? \"elementStroke\" : \"elementBackground\",\n      onSelect: (color, event) => {\n        const shouldUpdateStrokeColor =\n          (type === \"background\" && event.altKey) ||\n          (type === \"stroke\" && !event.altKey);\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        if (\n          !selectedElements.length ||\n          this.state.activeTool.type !== \"selection\"\n        ) {\n          if (shouldUpdateStrokeColor) {\n            this.syncActionResult({\n              appState: { ...this.state, currentItemStrokeColor: color },\n              captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n            });\n          } else {\n            this.syncActionResult({\n              appState: { ...this.state, currentItemBackgroundColor: color },\n              captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n            });\n          }\n        } else {\n          this.updateScene({\n            elements: this.scene.getElementsIncludingDeleted().map((el) => {\n              if (this.state.selectedElementIds[el.id]) {\n                return newElementWith(el, {\n                  [shouldUpdateStrokeColor ? \"strokeColor\" : \"backgroundColor\"]:\n                    color,\n                });\n              }\n              return el;\n            }),\n            captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n          });\n        }\n      },\n      keepOpenOnAlt: false,\n    });\n  };\n\n  public dismissLinearEditor = () => {\n    setTimeout(() => {\n      this.setState({\n        editingLinearElement: null,\n      });\n    });\n  };\n\n  public syncActionResult = withBatchedUpdates((actionResult: ActionResult) => {\n    if (this.unmounted || actionResult === false) {\n      return;\n    }\n\n    this.store.scheduleAction(actionResult.captureUpdate);\n\n    let didUpdate = false;\n\n    let editingTextElement: AppState[\"editingTextElement\"] | null = null;\n    if (actionResult.elements) {\n      this.scene.replaceAllElements(actionResult.elements);\n      didUpdate = true;\n    }\n\n    if (actionResult.files) {\n      this.addMissingFiles(actionResult.files, actionResult.replaceFiles);\n      this.addNewImagesToImageCache();\n    }\n\n    if (actionResult.appState || editingTextElement || this.state.contextMenu) {\n      let viewModeEnabled = actionResult?.appState?.viewModeEnabled || false;\n      let zenModeEnabled = actionResult?.appState?.zenModeEnabled || false;\n      const theme =\n        actionResult?.appState?.theme || this.props.theme || THEME.LIGHT;\n      const name = actionResult?.appState?.name ?? this.state.name;\n      const errorMessage =\n        actionResult?.appState?.errorMessage ?? this.state.errorMessage;\n      if (typeof this.props.viewModeEnabled !== \"undefined\") {\n        viewModeEnabled = this.props.viewModeEnabled;\n      }\n\n      if (typeof this.props.zenModeEnabled !== \"undefined\") {\n        zenModeEnabled = this.props.zenModeEnabled;\n      }\n\n      editingTextElement = actionResult.appState?.editingTextElement || null;\n\n      // make sure editingTextElement points to latest element reference\n      if (actionResult.elements && editingTextElement) {\n        actionResult.elements.forEach((element) => {\n          if (\n            editingTextElement?.id === element.id &&\n            editingTextElement !== element &&\n            isNonDeletedElement(element) &&\n            isTextElement(element)\n          ) {\n            editingTextElement = element;\n          }\n        });\n      }\n\n      if (editingTextElement?.isDeleted) {\n        editingTextElement = null;\n      }\n\n      this.setState((prevAppState) => {\n        const actionAppState = actionResult.appState || {};\n\n        return {\n          ...prevAppState,\n          ...actionAppState,\n          // NOTE this will prevent opening context menu using an action\n          // or programmatically from the host, so it will need to be\n          // rewritten later\n          contextMenu: null,\n          editingTextElement,\n          viewModeEnabled,\n          zenModeEnabled,\n          theme,\n          name,\n          errorMessage,\n        };\n      });\n\n      didUpdate = true;\n    }\n\n    if (!didUpdate) {\n      this.scene.triggerUpdate();\n    }\n  });\n\n  // Lifecycle\n\n  private onBlur = withBatchedUpdates(() => {\n    isHoldingSpace = false;\n    this.setState({ isBindingEnabled: true });\n  });\n\n  private onUnload = () => {\n    this.onBlur();\n  };\n\n  private disableEvent: EventListener = (event) => {\n    event.preventDefault();\n  };\n\n  private resetHistory = () => {\n    this.history.clear();\n  };\n\n  private resetStore = () => {\n    this.store.clear();\n  };\n\n  /**\n   * Resets scene & history.\n   * ! Do not use to clear scene user action !\n   */\n  private resetScene = withBatchedUpdates(\n    (opts?: { resetLoadingState: boolean }) => {\n      this.scene.replaceAllElements([]);\n      this.setState((state) => ({\n        ...getDefaultAppState(),\n        isLoading: opts?.resetLoadingState ? false : state.isLoading,\n        theme: this.state.theme,\n      }));\n      this.resetStore();\n      this.resetHistory();\n    },\n  );\n\n  private initializeScene = async () => {\n    if (\"launchQueue\" in window && \"LaunchParams\" in window) {\n      (window as any).launchQueue.setConsumer(\n        async (launchParams: { files: any[] }) => {\n          if (!launchParams.files.length) {\n            return;\n          }\n          const fileHandle = launchParams.files[0];\n          const blob: Blob = await fileHandle.getFile();\n          this.loadFileToCanvas(\n            new File([blob], blob.name || \"\", { type: blob.type }),\n            fileHandle,\n          );\n        },\n      );\n    }\n\n    if (this.props.theme) {\n      this.setState({ theme: this.props.theme });\n    }\n    if (!this.state.isLoading) {\n      this.setState({ isLoading: true });\n    }\n    let initialData = null;\n    try {\n      if (typeof this.props.initialData === \"function\") {\n        initialData = (await this.props.initialData()) || null;\n      } else {\n        initialData = (await this.props.initialData) || null;\n      }\n      if (initialData?.libraryItems) {\n        this.library\n          .updateLibrary({\n            libraryItems: initialData.libraryItems,\n            merge: true,\n          })\n          .catch((error) => {\n            console.error(error);\n          });\n      }\n    } catch (error: any) {\n      console.error(error);\n      initialData = {\n        appState: {\n          errorMessage:\n            error.message ||\n            \"Encountered an error during importing or restoring scene data\",\n        },\n      };\n    }\n    const scene = restore(initialData, null, null, { repairBindings: true });\n    scene.appState = {\n      ...scene.appState,\n      theme: this.props.theme || scene.appState.theme,\n      // we're falling back to current (pre-init) state when deciding\n      // whether to open the library, to handle a case where we\n      // update the state outside of initialData (e.g. when loading the app\n      // with a library install link, which should auto-open the library)\n      openSidebar: scene.appState?.openSidebar || this.state.openSidebar,\n      activeTool:\n        scene.appState.activeTool.type === \"image\"\n          ? { ...scene.appState.activeTool, type: \"selection\" }\n          : scene.appState.activeTool,\n      isLoading: false,\n      toast: this.state.toast,\n    };\n    if (initialData?.scrollToContent) {\n      scene.appState = {\n        ...scene.appState,\n        ...calculateScrollCenter(scene.elements, {\n          ...scene.appState,\n          width: this.state.width,\n          height: this.state.height,\n          offsetTop: this.state.offsetTop,\n          offsetLeft: this.state.offsetLeft,\n        }),\n      };\n    }\n\n    this.resetStore();\n    this.resetHistory();\n    this.syncActionResult({\n      ...scene,\n      captureUpdate: CaptureUpdateAction.NEVER,\n    });\n\n    // clear the shape and image cache so that any images in initialData\n    // can be loaded fresh\n    this.clearImageShapeCache();\n\n    // manually loading the font faces seems faster even in browsers that do fire the loadingdone event\n    this.fonts.loadSceneFonts().then((fontFaces) => {\n      this.fonts.onLoaded(fontFaces);\n    });\n\n    if (isElementLink(window.location.href)) {\n      this.scrollToContent(window.location.href, { animate: false });\n    }\n  };\n\n  private isMobileBreakpoint = (width: number, height: number) => {\n    return (\n      width < MQ_MAX_WIDTH_PORTRAIT ||\n      (height < MQ_MAX_HEIGHT_LANDSCAPE && width < MQ_MAX_WIDTH_LANDSCAPE)\n    );\n  };\n\n  private refreshViewportBreakpoints = () => {\n    const container = this.excalidrawContainerRef.current;\n    if (!container) {\n      return;\n    }\n\n    const { clientWidth: viewportWidth, clientHeight: viewportHeight } =\n      document.body;\n\n    const prevViewportState = this.device.viewport;\n\n    const nextViewportState = updateObject(prevViewportState, {\n      isLandscape: viewportWidth > viewportHeight,\n      isMobile: this.isMobileBreakpoint(viewportWidth, viewportHeight),\n    });\n\n    if (prevViewportState !== nextViewportState) {\n      this.device = { ...this.device, viewport: nextViewportState };\n      return true;\n    }\n    return false;\n  };\n\n  private refreshEditorBreakpoints = () => {\n    const container = this.excalidrawContainerRef.current;\n    if (!container) {\n      return;\n    }\n\n    const { width: editorWidth, height: editorHeight } =\n      container.getBoundingClientRect();\n\n    const sidebarBreakpoint =\n      this.props.UIOptions.dockedSidebarBreakpoint != null\n        ? this.props.UIOptions.dockedSidebarBreakpoint\n        : MQ_RIGHT_SIDEBAR_MIN_WIDTH;\n\n    const prevEditorState = this.device.editor;\n\n    const nextEditorState = updateObject(prevEditorState, {\n      isMobile: this.isMobileBreakpoint(editorWidth, editorHeight),\n      canFitSidebar: editorWidth > sidebarBreakpoint,\n    });\n\n    if (prevEditorState !== nextEditorState) {\n      this.device = { ...this.device, editor: nextEditorState };\n      return true;\n    }\n    return false;\n  };\n\n  private clearImageShapeCache(filesMap?: BinaryFiles) {\n    const files = filesMap ?? this.files;\n    this.scene.getNonDeletedElements().forEach((element) => {\n      if (isInitializedImageElement(element) && files[element.fileId]) {\n        this.imageCache.delete(element.fileId);\n        ShapeCache.delete(element);\n      }\n    });\n  }\n\n  public async componentDidMount() {\n    this.unmounted = false;\n    this.excalidrawContainerValue.container =\n      this.excalidrawContainerRef.current;\n\n    if (isTestEnv() || isDevEnv()) {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          },\n        },\n        setState: {\n          configurable: true,\n          value: (...args: Parameters<typeof setState>) => {\n            return this.setState(...args);\n          },\n        },\n        app: {\n          configurable: true,\n          value: this,\n        },\n        history: {\n          configurable: true,\n          value: this.history,\n        },\n        store: {\n          configurable: true,\n          value: this.store,\n        },\n        fonts: {\n          configurable: true,\n          value: this.fonts,\n        },\n      });\n    }\n\n    this.store.onDurableIncrementEmitter.on((increment) => {\n      this.history.record(increment.delta);\n    });\n\n    const { onIncrement } = this.props;\n\n    // per. optimmisation, only subscribe if there is the `onIncrement` prop registered, to avoid unnecessary computation\n    if (onIncrement) {\n      this.store.onStoreIncrementEmitter.on((increment) => {\n        onIncrement(increment);\n      });\n    }\n\n    this.scene.onUpdate(this.triggerRender);\n    this.addEventListeners();\n\n    if (this.props.autoFocus && this.excalidrawContainerRef.current) {\n      this.focusContainer();\n    }\n\n    if (\n      // bounding rects don't work in tests so updating\n      // the state on init would result in making the test enviro run\n      // in mobile breakpoint (0 width/height), making everything fail\n      !isTestEnv()\n    ) {\n      this.refreshViewportBreakpoints();\n      this.refreshEditorBreakpoints();\n    }\n\n    if (supportsResizeObserver && this.excalidrawContainerRef.current) {\n      this.resizeObserver = new ResizeObserver(() => {\n        this.refreshEditorBreakpoints();\n        this.updateDOMRect();\n      });\n      this.resizeObserver?.observe(this.excalidrawContainerRef.current);\n    }\n\n    const searchParams = new URLSearchParams(window.location.search.slice(1));\n\n    if (searchParams.has(\"web-share-target\")) {\n      // Obtain a file that was shared via the Web Share Target API.\n      this.restoreFileFromShare();\n    } else {\n      this.updateDOMRect(this.initializeScene);\n    }\n\n    // note that this check seems to always pass in localhost\n    if (isBrave() && !isMeasureTextSupported()) {\n      this.setState({\n        errorMessage: <BraveMeasureTextError />,\n      });\n    }\n  }\n\n  public componentWillUnmount() {\n    (window as any).launchQueue?.setConsumer(() => {});\n    this.renderer.destroy();\n    this.scene.destroy();\n    this.scene = new Scene();\n    this.fonts = new Fonts(this.scene);\n    this.renderer = new Renderer(this.scene);\n    this.files = {};\n    this.imageCache.clear();\n    this.resizeObserver?.disconnect();\n    this.unmounted = true;\n    this.removeEventListeners();\n    this.library.destroy();\n    this.laserTrails.stop();\n    this.eraserTrail.stop();\n    this.onChangeEmitter.clear();\n    this.store.onStoreIncrementEmitter.clear();\n    this.store.onDurableIncrementEmitter.clear();\n    ShapeCache.destroy();\n    SnapCache.destroy();\n    clearTimeout(touchTimeout);\n    isSomeElementSelected.clearCache();\n    selectGroupsForSelectedElements.clearCache();\n    touchTimeout = 0;\n    document.documentElement.style.overscrollBehaviorX = \"\";\n  }\n\n  private onResize = withBatchedUpdates(() => {\n    this.scene\n      .getElementsIncludingDeleted()\n      .forEach((element) => ShapeCache.delete(element));\n    this.refreshViewportBreakpoints();\n    this.updateDOMRect();\n    if (!supportsResizeObserver) {\n      this.refreshEditorBreakpoints();\n    }\n    this.setState({});\n  });\n\n  /** generally invoked only if fullscreen was invoked programmatically */\n  private onFullscreenChange = () => {\n    if (\n      // points to the iframe element we fullscreened\n      !document.fullscreenElement &&\n      this.state.activeEmbeddable?.state === \"active\"\n    ) {\n      this.setState({\n        activeEmbeddable: null,\n      });\n    }\n  };\n\n  private removeEventListeners() {\n    this.onRemoveEventListenersEmitter.trigger();\n  }\n\n  private addEventListeners() {\n    // remove first as we can add event listeners multiple times\n    this.removeEventListeners();\n\n    // -------------------------------------------------------------------------\n    //                        view+edit mode listeners\n    // -------------------------------------------------------------------------\n\n    if (this.props.handleKeyboardGlobally) {\n      this.onRemoveEventListenersEmitter.once(\n        addEventListener(document, EVENT.KEYDOWN, this.onKeyDown, false),\n      );\n    }\n\n    this.onRemoveEventListenersEmitter.once(\n      addEventListener(\n        this.excalidrawContainerRef.current,\n        EVENT.WHEEL,\n        this.handleWheel,\n        { passive: false },\n      ),\n      addEventListener(window, EVENT.MESSAGE, this.onWindowMessage, false),\n      addEventListener(document, EVENT.POINTER_UP, this.removePointer, {\n        passive: false,\n      }), // #3553\n      addEventListener(document, EVENT.COPY, this.onCopy, { passive: false }),\n      addEventListener(document, EVENT.KEYUP, this.onKeyUp, { passive: true }),\n      addEventListener(\n        document,\n        EVENT.POINTER_MOVE,\n        this.updateCurrentCursorPosition,\n        { passive: false },\n      ),\n      // rerender text elements on font load to fix #637 && #1553\n      addEventListener(\n        document.fonts,\n        \"loadingdone\",\n        (event) => {\n          const fontFaces = (event as FontFaceSetLoadEvent).fontfaces;\n          this.fonts.onLoaded(fontFaces);\n        },\n        { passive: false },\n      ),\n      // Safari-only desktop pinch zoom\n      addEventListener(\n        document,\n        EVENT.GESTURE_START,\n        this.onGestureStart as any,\n        false,\n      ),\n      addEventListener(\n        document,\n        EVENT.GESTURE_CHANGE,\n        this.onGestureChange as any,\n        false,\n      ),\n      addEventListener(\n        document,\n        EVENT.GESTURE_END,\n        this.onGestureEnd as any,\n        false,\n      ),\n      addEventListener(\n        window,\n        EVENT.FOCUS,\n        () => {\n          this.maybeCleanupAfterMissingPointerUp(null);\n          // browsers (chrome?) tend to free up memory a lot, which results\n          // in canvas context being cleared. Thus re-render on focus.\n          this.triggerRender(true);\n        },\n        { passive: false },\n      ),\n    );\n\n    if (this.state.viewModeEnabled) {\n      return;\n    }\n\n    // -------------------------------------------------------------------------\n    //                        edit-mode listeners only\n    // -------------------------------------------------------------------------\n\n    this.onRemoveEventListenersEmitter.once(\n      addEventListener(\n        document,\n        EVENT.FULLSCREENCHANGE,\n        this.onFullscreenChange,\n        { passive: false },\n      ),\n      addEventListener(document, EVENT.PASTE, this.pasteFromClipboard, {\n        passive: false,\n      }),\n      addEventListener(document, EVENT.CUT, this.onCut, { passive: false }),\n      addEventListener(window, EVENT.RESIZE, this.onResize, false),\n      addEventListener(window, EVENT.UNLOAD, this.onUnload, false),\n      addEventListener(window, EVENT.BLUR, this.onBlur, false),\n      addEventListener(\n        this.excalidrawContainerRef.current,\n        EVENT.WHEEL,\n        this.handleWheel,\n        { passive: false },\n      ),\n      addEventListener(\n        this.excalidrawContainerRef.current,\n        EVENT.DRAG_OVER,\n        this.disableEvent,\n        false,\n      ),\n      addEventListener(\n        this.excalidrawContainerRef.current,\n        EVENT.DROP,\n        this.disableEvent,\n        false,\n      ),\n    );\n\n    if (this.props.detectScroll) {\n      this.onRemoveEventListenersEmitter.once(\n        addEventListener(\n          getNearestScrollableContainer(this.excalidrawContainerRef.current!),\n          EVENT.SCROLL,\n          this.onScroll,\n          { passive: false },\n        ),\n      );\n    }\n  }\n\n  componentDidUpdate(prevProps: AppProps, prevState: AppState) {\n    this.updateEmbeddables();\n    const elements = this.scene.getElementsIncludingDeleted();\n    const elementsMap = this.scene.getElementsMapIncludingDeleted();\n\n    if (!this.state.showWelcomeScreen && !elements.length) {\n      this.setState({ showWelcomeScreen: true });\n    }\n\n    if (\n      prevProps.UIOptions.dockedSidebarBreakpoint !==\n      this.props.UIOptions.dockedSidebarBreakpoint\n    ) {\n      this.refreshEditorBreakpoints();\n    }\n\n    const hasFollowedPersonLeft =\n      prevState.userToFollow &&\n      !this.state.collaborators.has(prevState.userToFollow.socketId);\n\n    if (hasFollowedPersonLeft) {\n      this.maybeUnfollowRemoteUser();\n    }\n\n    if (\n      prevState.zoom.value !== this.state.zoom.value ||\n      prevState.scrollX !== this.state.scrollX ||\n      prevState.scrollY !== this.state.scrollY\n    ) {\n      this.props?.onScrollChange?.(\n        this.state.scrollX,\n        this.state.scrollY,\n        this.state.zoom,\n      );\n      this.onScrollChangeEmitter.trigger(\n        this.state.scrollX,\n        this.state.scrollY,\n        this.state.zoom,\n      );\n    }\n\n    if (prevState.userToFollow !== this.state.userToFollow) {\n      if (prevState.userToFollow) {\n        this.onUserFollowEmitter.trigger({\n          userToFollow: prevState.userToFollow,\n          action: \"UNFOLLOW\",\n        });\n      }\n\n      if (this.state.userToFollow) {\n        this.onUserFollowEmitter.trigger({\n          userToFollow: this.state.userToFollow,\n          action: \"FOLLOW\",\n        });\n      }\n    }\n\n    if (\n      Object.keys(this.state.selectedElementIds).length &&\n      isEraserActive(this.state)\n    ) {\n      this.setState({\n        activeTool: updateActiveTool(this.state, { type: \"selection\" }),\n      });\n    }\n    if (\n      this.state.activeTool.type === \"eraser\" &&\n      prevState.theme !== this.state.theme\n    ) {\n      setEraserCursor(this.interactiveCanvas, this.state.theme);\n    }\n    // Hide hyperlink popup if shown when element type is not selection\n    if (\n      prevState.activeTool.type === \"selection\" &&\n      this.state.activeTool.type !== \"selection\" &&\n      this.state.showHyperlinkPopup\n    ) {\n      this.setState({ showHyperlinkPopup: false });\n    }\n    if (prevProps.langCode !== this.props.langCode) {\n      this.updateLanguage();\n    }\n\n    if (isEraserActive(prevState) && !isEraserActive(this.state)) {\n      this.eraserTrail.endPath();\n    }\n\n    if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {\n      this.setState({ viewModeEnabled: !!this.props.viewModeEnabled });\n    }\n\n    if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {\n      this.addEventListeners();\n      this.deselectElements();\n    }\n\n    // cleanup\n    if (\n      (prevState.openDialog?.name === \"elementLinkSelector\" ||\n        this.state.openDialog?.name === \"elementLinkSelector\") &&\n      prevState.openDialog?.name !== this.state.openDialog?.name\n    ) {\n      this.deselectElements();\n      this.setState({\n        hoveredElementIds: {},\n      });\n    }\n\n    if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {\n      this.setState({ zenModeEnabled: !!this.props.zenModeEnabled });\n    }\n\n    if (prevProps.theme !== this.props.theme && this.props.theme) {\n      this.setState({ theme: this.props.theme });\n    }\n\n    this.excalidrawContainerRef.current?.classList.toggle(\n      \"theme--dark\",\n      this.state.theme === THEME.DARK,\n    );\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.selectedElementIds[this.state.editingLinearElement.elementId]\n    ) {\n      // defer so that the scheduleCapture flag isn't reset via current update\n      setTimeout(() => {\n        // execute only if the condition still holds when the deferred callback\n        // executes (it can be scheduled multiple times depending on how\n        // many times the component renders)\n        this.state.editingLinearElement &&\n          this.actionManager.executeAction(actionFinalize);\n      });\n    }\n\n    // failsafe in case the state is being updated in incorrect order resulting\n    // in the editingTextElement being now a deleted element\n    if (this.state.editingTextElement?.isDeleted) {\n      this.setState({ editingTextElement: null });\n    }\n\n    if (\n      this.state.selectedLinearElement &&\n      !this.state.selectedElementIds[this.state.selectedLinearElement.elementId]\n    ) {\n      // To make sure `selectedLinearElement` is in sync with `selectedElementIds`, however this shouldn't be needed once\n      // we have a single API to update `selectedElementIds`\n      this.setState({ selectedLinearElement: null });\n    }\n\n    this.store.commit(elementsMap, this.state);\n\n    // Do not notify consumers if we're still loading the scene. Among other\n    // potential issues, this fixes a case where the tab isn't focused during\n    // init, which would trigger onChange with empty elements, which would then\n    // override whatever is in localStorage currently.\n    if (!this.state.isLoading) {\n      this.props.onChange?.(elements, this.state, this.files);\n      this.onChangeEmitter.trigger(elements, this.state, this.files);\n    }\n  }\n\n  private renderInteractiveSceneCallback = ({\n    atLeastOneVisibleElement,\n    scrollBars,\n    elementsMap,\n  }: RenderInteractiveSceneCallback) => {\n    if (scrollBars) {\n      currentScrollBars = scrollBars;\n    }\n    const scrolledOutside =\n      // hide when editing text\n      this.state.editingTextElement\n        ? false\n        : !atLeastOneVisibleElement && elementsMap.size > 0;\n    if (this.state.scrolledOutside !== scrolledOutside) {\n      this.setState({ scrolledOutside });\n    }\n\n    this.scheduleImageRefresh();\n  };\n\n  private onScroll = debounce(() => {\n    const { offsetTop, offsetLeft } = this.getCanvasOffsets();\n    this.setState((state) => {\n      if (state.offsetLeft === offsetLeft && state.offsetTop === offsetTop) {\n        return null;\n      }\n      return { offsetTop, offsetLeft };\n    });\n  }, SCROLL_TIMEOUT);\n\n  // Copy/paste\n\n  private onCut = withBatchedUpdates((event: ClipboardEvent) => {\n    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(\n      document.activeElement,\n    );\n    if (!isExcalidrawActive || isWritableElement(event.target)) {\n      return;\n    }\n    this.actionManager.executeAction(actionCut, \"keyboard\", event);\n    event.preventDefault();\n    event.stopPropagation();\n  });\n\n  private onCopy = withBatchedUpdates((event: ClipboardEvent) => {\n    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(\n      document.activeElement,\n    );\n    if (!isExcalidrawActive || isWritableElement(event.target)) {\n      return;\n    }\n    this.actionManager.executeAction(actionCopy, \"keyboard\", event);\n    event.preventDefault();\n    event.stopPropagation();\n  });\n\n  private static resetTapTwice() {\n    didTapTwice = false;\n  }\n\n  private onTouchStart = (event: TouchEvent) => {\n    // fix for Apple Pencil Scribble (do not prevent for other devices)\n    if (isIOS) {\n      event.preventDefault();\n    }\n\n    if (!didTapTwice) {\n      didTapTwice = true;\n      clearTimeout(tappedTwiceTimer);\n      tappedTwiceTimer = window.setTimeout(\n        App.resetTapTwice,\n        TAP_TWICE_TIMEOUT,\n      );\n      return;\n    }\n    // insert text only if we tapped twice with a single finger\n    // event.touches.length === 1 will also prevent inserting text when user's zooming\n    if (didTapTwice && event.touches.length === 1) {\n      const touch = event.touches[0];\n      // @ts-ignore\n      this.handleCanvasDoubleClick({\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n      });\n      didTapTwice = false;\n      clearTimeout(tappedTwiceTimer);\n    }\n\n    if (event.touches.length === 2) {\n      this.setState({\n        selectedElementIds: makeNextSelectedElementIds({}, this.state),\n        activeEmbeddable: null,\n      });\n    }\n  };\n\n  private onTouchEnd = (event: TouchEvent) => {\n    this.resetContextMenuTimer();\n    if (event.touches.length > 0) {\n      this.setState({\n        previousSelectedElementIds: {},\n        selectedElementIds: makeNextSelectedElementIds(\n          this.state.previousSelectedElementIds,\n          this.state,\n        ),\n      });\n    } else {\n      gesture.pointers.clear();\n    }\n  };\n\n  // TODO: this is so spaghetti, we should refactor it and cover it with tests\n  public pasteFromClipboard = withBatchedUpdates(\n    async (event: ClipboardEvent) => {\n      const isPlainPaste = !!IS_PLAIN_PASTE;\n\n      // #686\n      const target = document.activeElement;\n      const isExcalidrawActive =\n        this.excalidrawContainerRef.current?.contains(target);\n      if (event && !isExcalidrawActive) {\n        return;\n      }\n\n      const elementUnderCursor = document.elementFromPoint(\n        this.lastViewportPosition.x,\n        this.lastViewportPosition.y,\n      );\n      if (\n        event &&\n        (!(elementUnderCursor instanceof HTMLCanvasElement) ||\n          isWritableElement(target))\n      ) {\n        return;\n      }\n\n      const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n        {\n          clientX: this.lastViewportPosition.x,\n          clientY: this.lastViewportPosition.y,\n        },\n        this.state,\n      );\n\n      // must be called in the same frame (thus before any awaits) as the paste\n      // event else some browsers (FF...) will clear the clipboardData\n      // (something something security)\n      let file = event?.clipboardData?.files[0];\n      const data = await parseClipboard(event, isPlainPaste);\n      if (!file && !isPlainPaste) {\n        if (data.mixedContent) {\n          return this.addElementsFromMixedContentPaste(data.mixedContent, {\n            isPlainPaste,\n            sceneX,\n            sceneY,\n          });\n        } else if (data.text) {\n          const string = data.text.trim();\n          if (string.startsWith(\"<svg\") && string.endsWith(\"</svg>\")) {\n            // ignore SVG validation/normalization which will be done during image\n            // initialization\n            file = SVGStringToFile(string);\n          }\n        }\n      }\n\n      // prefer spreadsheet data over image file (MS Office/Libre Office)\n      if (isSupportedImageFile(file) && !data.spreadsheet) {\n        if (!this.isToolSupported(\"image\")) {\n          this.setState({ errorMessage: t(\"errors.imageToolNotSupported\") });\n          return;\n        }\n\n        this.createImageElement({ sceneX, sceneY, imageFile: file });\n\n        return;\n      }\n\n      if (this.props.onPaste) {\n        try {\n          if ((await this.props.onPaste(data, event)) === false) {\n            return;\n          }\n        } catch (error: any) {\n          console.error(error);\n        }\n      }\n\n      if (data.errorMessage) {\n        this.setState({ errorMessage: data.errorMessage });\n      } else if (data.spreadsheet && !isPlainPaste) {\n        this.setState({\n          pasteDialog: {\n            data: data.spreadsheet,\n            shown: true,\n          },\n        });\n      } else if (data.elements) {\n        const elements = (\n          data.programmaticAPI\n            ? convertToExcalidrawElements(\n                data.elements as ExcalidrawElementSkeleton[],\n              )\n            : data.elements\n        ) as readonly ExcalidrawElement[];\n        // TODO remove formatting from elements if isPlainPaste\n        this.addElementsFromPasteOrLibrary({\n          elements,\n          files: data.files || null,\n          position: \"cursor\",\n          retainSeed: isPlainPaste,\n        });\n      } else if (data.text) {\n        if (data.text && isMaybeMermaidDefinition(data.text)) {\n          const api = await import(\"@excalidraw/mermaid-to-excalidraw\");\n\n          try {\n            const { elements: skeletonElements, files } =\n              await api.parseMermaidToExcalidraw(data.text);\n\n            const elements = convertToExcalidrawElements(skeletonElements, {\n              regenerateIds: true,\n            });\n\n            this.addElementsFromPasteOrLibrary({\n              elements,\n              files,\n              position: \"cursor\",\n            });\n\n            return;\n          } catch (err: any) {\n            console.warn(\n              `parsing pasted text as mermaid definition failed: ${err.message}`,\n            );\n          }\n        }\n\n        const nonEmptyLines = normalizeEOL(data.text)\n          .split(/\\n+/)\n          .map((s) => s.trim())\n          .filter(Boolean);\n\n        const embbeddableUrls = nonEmptyLines\n          .map((str) => maybeParseEmbedSrc(str))\n          .filter((string) => {\n            return (\n              embeddableURLValidator(string, this.props.validateEmbeddable) &&\n              (/^(http|https):\\/\\/[^\\s/$.?#].[^\\s]*$/.test(string) ||\n                getEmbedLink(string)?.type === \"video\")\n            );\n          });\n\n        if (\n          !IS_PLAIN_PASTE &&\n          embbeddableUrls.length > 0 &&\n          // if there were non-embeddable text (lines) mixed in with embeddable\n          // urls, ignore and paste as text\n          embbeddableUrls.length === nonEmptyLines.length\n        ) {\n          const embeddables: NonDeleted<ExcalidrawEmbeddableElement>[] = [];\n          for (const url of embbeddableUrls) {\n            const prevEmbeddable: ExcalidrawEmbeddableElement | undefined =\n              embeddables[embeddables.length - 1];\n            const embeddable = this.insertEmbeddableElement({\n              sceneX: prevEmbeddable\n                ? prevEmbeddable.x + prevEmbeddable.width + 20\n                : sceneX,\n              sceneY,\n              link: normalizeLink(url),\n            });\n            if (embeddable) {\n              embeddables.push(embeddable);\n            }\n          }\n          if (embeddables.length) {\n            this.store.scheduleCapture();\n            this.setState({\n              selectedElementIds: Object.fromEntries(\n                embeddables.map((embeddable) => [embeddable.id, true]),\n              ),\n            });\n          }\n          return;\n        }\n        this.addTextFromPaste(data.text, isPlainPaste);\n      }\n      this.setActiveTool({ type: \"selection\" });\n      event?.preventDefault();\n    },\n  );\n\n  addElementsFromPasteOrLibrary = (opts: {\n    elements: readonly ExcalidrawElement[];\n    files: BinaryFiles | null;\n    position: { clientX: number; clientY: number } | \"cursor\" | \"center\";\n    retainSeed?: boolean;\n    fitToContent?: boolean;\n  }) => {\n    const elements = restoreElements(opts.elements, null, undefined);\n    const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n\n    const elementsCenterX = distance(minX, maxX) / 2;\n    const elementsCenterY = distance(minY, maxY) / 2;\n\n    const clientX =\n      typeof opts.position === \"object\"\n        ? opts.position.clientX\n        : opts.position === \"cursor\"\n        ? this.lastViewportPosition.x\n        : this.state.width / 2 + this.state.offsetLeft;\n    const clientY =\n      typeof opts.position === \"object\"\n        ? opts.position.clientY\n        : opts.position === \"cursor\"\n        ? this.lastViewportPosition.y\n        : this.state.height / 2 + this.state.offsetTop;\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX, clientY },\n      this.state,\n    );\n\n    const dx = x - elementsCenterX;\n    const dy = y - elementsCenterY;\n\n    const [gridX, gridY] = getGridPoint(dx, dy, this.getEffectiveGridSize());\n\n    const { duplicatedElements } = duplicateElements({\n      type: \"everything\",\n      elements: elements.map((element) => {\n        return newElementWith(element, {\n          x: element.x + gridX - minX,\n          y: element.y + gridY - minY,\n        });\n      }),\n      randomizeSeed: !opts.retainSeed,\n    });\n\n    const prevElements = this.scene.getElementsIncludingDeleted();\n    let nextElements = [...prevElements, ...duplicatedElements];\n\n    const mappedNewSceneElements = this.props.onDuplicate?.(\n      nextElements,\n      prevElements,\n    );\n\n    nextElements = mappedNewSceneElements || nextElements;\n\n    syncMovedIndices(nextElements, arrayToMap(duplicatedElements));\n\n    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({ x, y });\n\n    if (topLayerFrame) {\n      const eligibleElements = filterElementsEligibleAsFrameChildren(\n        duplicatedElements,\n        topLayerFrame,\n      );\n      addElementsToFrame(\n        nextElements,\n        eligibleElements,\n        topLayerFrame,\n        this.state,\n      );\n    }\n\n    this.scene.replaceAllElements(nextElements);\n\n    duplicatedElements.forEach((newElement) => {\n      if (isTextElement(newElement) && isBoundToContainer(newElement)) {\n        const container = getContainerElement(\n          newElement,\n          this.scene.getElementsMapIncludingDeleted(),\n        );\n        redrawTextBoundingBox(newElement, container, this.scene);\n      }\n    });\n\n    // paste event may not fire FontFace loadingdone event in Safari, hence loading font faces manually\n    if (isSafari) {\n      Fonts.loadElementsFonts(duplicatedElements).then((fontFaces) => {\n        this.fonts.onLoaded(fontFaces);\n      });\n    }\n\n    if (opts.files) {\n      this.addMissingFiles(opts.files);\n    }\n\n    const nextElementsToSelect =\n      excludeElementsInFramesFromSelection(duplicatedElements);\n\n    this.store.scheduleCapture();\n    this.setState(\n      {\n        ...this.state,\n        // keep sidebar (presumably the library) open if it's docked and\n        // can fit.\n        //\n        // Note, we should close the sidebar only if we're dropping items\n        // from library, not when pasting from clipboard. Alas.\n        openSidebar:\n          this.state.openSidebar &&\n          this.device.editor.canFitSidebar &&\n          editorJotaiStore.get(isSidebarDockedAtom)\n            ? this.state.openSidebar\n            : null,\n        ...selectGroupsForSelectedElements(\n          {\n            editingGroupId: null,\n            selectedElementIds: nextElementsToSelect.reduce(\n              (acc: Record<ExcalidrawElement[\"id\"], true>, element) => {\n                if (!isBoundToContainer(element)) {\n                  acc[element.id] = true;\n                }\n                return acc;\n              },\n              {},\n            ),\n          },\n          this.scene.getNonDeletedElements(),\n          this.state,\n          this,\n        ),\n      },\n      () => {\n        if (opts.files) {\n          this.addNewImagesToImageCache();\n        }\n      },\n    );\n    this.setActiveTool({ type: \"selection\" });\n\n    if (opts.fitToContent) {\n      this.scrollToContent(duplicatedElements, {\n        fitToContent: true,\n        canvasOffsets: this.getEditorUIOffsets(),\n      });\n    }\n  };\n\n  // TODO rewrite this to paste both text & images at the same time if\n  // pasted data contains both\n  private async addElementsFromMixedContentPaste(\n    mixedContent: PastedMixedContent,\n    {\n      isPlainPaste,\n      sceneX,\n      sceneY,\n    }: { isPlainPaste: boolean; sceneX: number; sceneY: number },\n  ) {\n    if (\n      !isPlainPaste &&\n      mixedContent.some((node) => node.type === \"imageUrl\") &&\n      this.isToolSupported(\"image\")\n    ) {\n      const imageURLs = mixedContent\n        .filter((node) => node.type === \"imageUrl\")\n        .map((node) => node.value);\n      const responses = await Promise.all(\n        imageURLs.map(async (url) => {\n          try {\n            return { file: await ImageURLToFile(url) };\n          } catch (error: any) {\n            let errorMessage = error.message;\n            if (error.cause === \"FETCH_ERROR\") {\n              errorMessage = t(\"errors.failedToFetchImage\");\n            } else if (error.cause === \"UNSUPPORTED\") {\n              errorMessage = t(\"errors.unsupportedFileType\");\n            }\n            return { errorMessage };\n          }\n        }),\n      );\n      let y = sceneY;\n      let firstImageYOffsetDone = false;\n      const nextSelectedIds: Record<ExcalidrawElement[\"id\"], true> = {};\n      for (const response of responses) {\n        if (response.file) {\n          const initializedImageElement = await this.createImageElement({\n            sceneX,\n            sceneY: y,\n            imageFile: response.file,\n          });\n\n          if (initializedImageElement) {\n            // vertically center first image in the batch\n            if (!firstImageYOffsetDone) {\n              firstImageYOffsetDone = true;\n              y -= initializedImageElement.height / 2;\n            }\n            // hack to reset the `y` coord because we vertically center during\n            // insertImageElement\n            this.scene.mutateElement(\n              initializedImageElement,\n              { y },\n              { informMutation: false, isDragging: false },\n            );\n\n            y = initializedImageElement.y + initializedImageElement.height + 25;\n\n            nextSelectedIds[initializedImageElement.id] = true;\n          }\n        }\n      }\n\n      this.setState({\n        selectedElementIds: makeNextSelectedElementIds(\n          nextSelectedIds,\n          this.state,\n        ),\n      });\n\n      const error = responses.find((response) => !!response.errorMessage);\n      if (error && error.errorMessage) {\n        this.setState({ errorMessage: error.errorMessage });\n      }\n    } else {\n      const textNodes = mixedContent.filter((node) => node.type === \"text\");\n      if (textNodes.length) {\n        this.addTextFromPaste(\n          textNodes.map((node) => node.value).join(\"\\n\\n\"),\n          isPlainPaste,\n        );\n      }\n    }\n  }\n\n  private addTextFromPaste(text: string, isPlainPaste = false) {\n    const { x, y } = viewportCoordsToSceneCoords(\n      {\n        clientX: this.lastViewportPosition.x,\n        clientY: this.lastViewportPosition.y,\n      },\n      this.state,\n    );\n\n    const textElementProps = {\n      x,\n      y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roundness: null,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      text,\n      fontSize: this.state.currentItemFontSize,\n      fontFamily: this.state.currentItemFontFamily,\n      textAlign: DEFAULT_TEXT_ALIGN,\n      verticalAlign: DEFAULT_VERTICAL_ALIGN,\n      locked: false,\n    };\n    const fontString = getFontString({\n      fontSize: textElementProps.fontSize,\n      fontFamily: textElementProps.fontFamily,\n    });\n    const lineHeight = getLineHeight(textElementProps.fontFamily);\n    const [x1, , x2] = getVisibleSceneBounds(this.state);\n    // long texts should not go beyond 800 pixels in width nor should it go below 200 px\n    const maxTextWidth = Math.max(Math.min((x2 - x1) * 0.5, 800), 200);\n    const LINE_GAP = 10;\n    let currentY = y;\n\n    const lines = isPlainPaste ? [text] : text.split(\"\\n\");\n    const textElements = lines.reduce(\n      (acc: ExcalidrawTextElement[], line, idx) => {\n        const originalText = normalizeText(line).trim();\n        if (originalText.length) {\n          const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n            x,\n            y: currentY,\n          });\n\n          let metrics = measureText(originalText, fontString, lineHeight);\n          const isTextUnwrapped = metrics.width > maxTextWidth;\n\n          const text = isTextUnwrapped\n            ? wrapText(originalText, fontString, maxTextWidth)\n            : originalText;\n\n          metrics = isTextUnwrapped\n            ? measureText(text, fontString, lineHeight)\n            : metrics;\n\n          const startX = x - metrics.width / 2;\n          const startY = currentY - metrics.height / 2;\n\n          const element = newTextElement({\n            ...textElementProps,\n            x: startX,\n            y: startY,\n            text,\n            originalText,\n            lineHeight,\n            autoResize: !isTextUnwrapped,\n            frameId: topLayerFrame ? topLayerFrame.id : null,\n          });\n          acc.push(element);\n          currentY += element.height + LINE_GAP;\n        } else {\n          const prevLine = lines[idx - 1]?.trim();\n          // add paragraph only if previous line was not empty, IOW don't add\n          // more than one empty line\n          if (prevLine) {\n            currentY +=\n              getLineHeightInPx(textElementProps.fontSize, lineHeight) +\n              LINE_GAP;\n          }\n        }\n\n        return acc;\n      },\n      [],\n    );\n\n    if (textElements.length === 0) {\n      return;\n    }\n\n    this.scene.insertElements(textElements);\n    this.store.scheduleCapture();\n    this.setState({\n      selectedElementIds: makeNextSelectedElementIds(\n        Object.fromEntries(textElements.map((el) => [el.id, true])),\n        this.state,\n      ),\n    });\n\n    if (\n      !isPlainPaste &&\n      textElements.length > 1 &&\n      PLAIN_PASTE_TOAST_SHOWN === false &&\n      !this.device.editor.isMobile\n    ) {\n      this.setToast({\n        message: t(\"toast.pasteAsSingleElement\", {\n          shortcut: getShortcutKey(\"CtrlOrCmd+Shift+V\"),\n        }),\n        duration: 5000,\n      });\n      PLAIN_PASTE_TOAST_SHOWN = true;\n    }\n  }\n\n  setAppState: React.Component<any, AppState>[\"setState\"] = (\n    state,\n    callback,\n  ) => {\n    this.setState(state, callback);\n  };\n\n  removePointer = (event: React.PointerEvent<HTMLElement> | PointerEvent) => {\n    if (touchTimeout) {\n      this.resetContextMenuTimer();\n    }\n\n    gesture.pointers.delete(event.pointerId);\n  };\n\n  toggleLock = (source: \"keyboard\" | \"ui\" = \"ui\") => {\n    if (!this.state.activeTool.locked) {\n      trackEvent(\n        \"toolbar\",\n        \"toggleLock\",\n        `${source} (${this.device.editor.isMobile ? \"mobile\" : \"desktop\"})`,\n      );\n    }\n    this.setState((prevState) => {\n      return {\n        activeTool: {\n          ...prevState.activeTool,\n          ...updateActiveTool(\n            this.state,\n            prevState.activeTool.locked\n              ? { type: \"selection\" }\n              : prevState.activeTool,\n          ),\n          locked: !prevState.activeTool.locked,\n        },\n      };\n    });\n  };\n\n  updateFrameRendering = (\n    opts:\n      | Partial<AppState[\"frameRendering\"]>\n      | ((\n          prevState: AppState[\"frameRendering\"],\n        ) => Partial<AppState[\"frameRendering\"]>),\n  ) => {\n    this.setState((prevState) => {\n      const next =\n        typeof opts === \"function\" ? opts(prevState.frameRendering) : opts;\n      return {\n        frameRendering: {\n          enabled: next?.enabled ?? prevState.frameRendering.enabled,\n          clip: next?.clip ?? prevState.frameRendering.clip,\n          name: next?.name ?? prevState.frameRendering.name,\n          outline: next?.outline ?? prevState.frameRendering.outline,\n        },\n      };\n    });\n  };\n\n  togglePenMode = (force: boolean | null) => {\n    this.setState((prevState) => {\n      return {\n        penMode: force ?? !prevState.penMode,\n        penDetected: true,\n      };\n    });\n  };\n\n  onHandToolToggle = () => {\n    this.actionManager.executeAction(actionToggleHandTool);\n  };\n\n  /**\n   * Zooms on canvas viewport center\n   */\n  zoomCanvas = (\n    /**\n     * Decimal fraction, auto-clamped between MIN_ZOOM and MAX_ZOOM.\n     * 1 = 100% zoom, 2 = 200% zoom, 0.5 = 50% zoom\n     */\n    value: number,\n  ) => {\n    this.setState({\n      ...getStateForZoom(\n        {\n          viewportX: this.state.width / 2 + this.state.offsetLeft,\n          viewportY: this.state.height / 2 + this.state.offsetTop,\n          nextZoom: getNormalizedZoom(value),\n        },\n        this.state,\n      ),\n    });\n  };\n\n  private cancelInProgressAnimation: (() => void) | null = null;\n\n  scrollToContent = (\n    /**\n     * target to scroll to\n     *\n     * - string - id of element or group, or url containing elementLink\n     * - ExcalidrawElement | ExcalidrawElement[] - element(s) objects\n     */\n    target:\n      | string\n      | ExcalidrawElement\n      | readonly ExcalidrawElement[] = this.scene.getNonDeletedElements(),\n    opts?: (\n      | {\n          fitToContent?: boolean;\n          fitToViewport?: never;\n          viewportZoomFactor?: number;\n          animate?: boolean;\n          duration?: number;\n        }\n      | {\n          fitToContent?: never;\n          fitToViewport?: boolean;\n          /** when fitToViewport=true, how much screen should the content cover,\n           * between 0.1 (10%) and 1 (100%)\n           */\n          viewportZoomFactor?: number;\n          animate?: boolean;\n          duration?: number;\n        }\n    ) & {\n      minZoom?: number;\n      maxZoom?: number;\n      canvasOffsets?: Offsets;\n    },\n  ) => {\n    if (typeof target === \"string\") {\n      let id: string | null;\n      if (isElementLink(target)) {\n        id = parseElementLinkFromURL(target);\n      } else {\n        id = target;\n      }\n      if (id) {\n        const elements = this.scene.getElementsFromId(id);\n\n        if (elements?.length) {\n          this.scrollToContent(elements, {\n            fitToContent: opts?.fitToContent ?? true,\n            animate: opts?.animate ?? true,\n          });\n        } else if (isElementLink(target)) {\n          this.setState({\n            toast: {\n              message: t(\"elementLink.notFound\"),\n              duration: 3000,\n              closable: true,\n            },\n          });\n        }\n      }\n      return;\n    }\n\n    this.cancelInProgressAnimation?.();\n\n    // convert provided target into ExcalidrawElement[] if necessary\n    const targetElements = Array.isArray(target) ? target : [target];\n\n    let zoom = this.state.zoom;\n    let scrollX = this.state.scrollX;\n    let scrollY = this.state.scrollY;\n\n    if (opts?.fitToContent || opts?.fitToViewport) {\n      const { appState } = zoomToFit({\n        canvasOffsets: opts.canvasOffsets,\n        targetElements,\n        appState: this.state,\n        fitToViewport: !!opts?.fitToViewport,\n        viewportZoomFactor: opts?.viewportZoomFactor,\n        minZoom: opts?.minZoom,\n        maxZoom: opts?.maxZoom,\n      });\n      zoom = appState.zoom;\n      scrollX = appState.scrollX;\n      scrollY = appState.scrollY;\n    } else {\n      // compute only the viewport location, without any zoom adjustment\n      const scroll = calculateScrollCenter(targetElements, this.state);\n      scrollX = scroll.scrollX;\n      scrollY = scroll.scrollY;\n    }\n\n    // when animating, we use RequestAnimationFrame to prevent the animation\n    // from slowing down other processes\n    if (opts?.animate) {\n      const origScrollX = this.state.scrollX;\n      const origScrollY = this.state.scrollY;\n      const origZoom = this.state.zoom.value;\n\n      const cancel = easeToValuesRAF({\n        fromValues: {\n          scrollX: origScrollX,\n          scrollY: origScrollY,\n          zoom: origZoom,\n        },\n        toValues: { scrollX, scrollY, zoom: zoom.value },\n        interpolateValue: (from, to, progress, key) => {\n          // for zoom, use different easing\n          if (key === \"zoom\") {\n            return from * Math.pow(to / from, easeOut(progress));\n          }\n          // handle using default\n          return undefined;\n        },\n        onStep: ({ scrollX, scrollY, zoom }) => {\n          this.setState({\n            scrollX,\n            scrollY,\n            zoom: { value: zoom },\n          });\n        },\n        onStart: () => {\n          this.setState({ shouldCacheIgnoreZoom: true });\n        },\n        onEnd: () => {\n          this.setState({ shouldCacheIgnoreZoom: false });\n        },\n        onCancel: () => {\n          this.setState({ shouldCacheIgnoreZoom: false });\n        },\n        duration: opts?.duration ?? 500,\n      });\n\n      this.cancelInProgressAnimation = () => {\n        cancel();\n        this.cancelInProgressAnimation = null;\n      };\n    } else {\n      this.setState({ scrollX, scrollY, zoom });\n    }\n  };\n\n  private maybeUnfollowRemoteUser = () => {\n    if (this.state.userToFollow) {\n      this.setState({ userToFollow: null });\n    }\n  };\n\n  /** use when changing scrollX/scrollY/zoom based on user interaction */\n  private translateCanvas: React.Component<any, AppState>[\"setState\"] = (\n    state,\n  ) => {\n    this.cancelInProgressAnimation?.();\n    this.maybeUnfollowRemoteUser();\n    this.setState(state);\n  };\n\n  setToast = (\n    toast: {\n      message: string;\n      closable?: boolean;\n      duration?: number;\n    } | null,\n  ) => {\n    this.setState({ toast });\n  };\n\n  restoreFileFromShare = async () => {\n    try {\n      const webShareTargetCache = await caches.open(\"web-share-target\");\n\n      const response = await webShareTargetCache.match(\"shared-file\");\n      if (response) {\n        const blob = await response.blob();\n        const file = new File([blob], blob.name || \"\", { type: blob.type });\n        this.loadFileToCanvas(file, null);\n        await webShareTargetCache.delete(\"shared-file\");\n        window.history.replaceState(null, APP_NAME, window.location.pathname);\n      }\n    } catch (error: any) {\n      this.setState({ errorMessage: error.message });\n    }\n  };\n\n  /**\n   * adds supplied files to existing files in the appState.\n   * NOTE if file already exists in editor state, the file data is not updated\n   * */\n  public addFiles: ExcalidrawImperativeAPI[\"addFiles\"] = withBatchedUpdates(\n    (files) => {\n      const { addedFiles } = this.addMissingFiles(files);\n\n      this.clearImageShapeCache(addedFiles);\n      this.scene.triggerUpdate();\n\n      this.addNewImagesToImageCache();\n    },\n  );\n\n  private addMissingFiles = (\n    files: BinaryFiles | BinaryFileData[],\n    replace = false,\n  ) => {\n    const nextFiles = replace ? {} : { ...this.files };\n    const addedFiles: BinaryFiles = {};\n\n    const _files = Array.isArray(files) ? files : Object.values(files);\n\n    for (const fileData of _files) {\n      if (nextFiles[fileData.id]) {\n        continue;\n      }\n\n      addedFiles[fileData.id] = fileData;\n      nextFiles[fileData.id] = fileData;\n\n      if (fileData.mimeType === MIME_TYPES.svg) {\n        try {\n          const restoredDataURL = getDataURL_sync(\n            normalizeSVG(dataURLToString(fileData.dataURL)),\n            MIME_TYPES.svg,\n          );\n          if (fileData.dataURL !== restoredDataURL) {\n            // bump version so persistence layer can update the store\n            fileData.version = (fileData.version ?? 1) + 1;\n            fileData.dataURL = restoredDataURL;\n          }\n        } catch (error) {\n          console.error(error);\n        }\n      }\n    }\n\n    this.files = nextFiles;\n\n    return { addedFiles };\n  };\n\n  public updateScene = withBatchedUpdates(\n    <K extends keyof AppState>(sceneData: {\n      elements?: SceneData[\"elements\"];\n      appState?: Pick<AppState, K> | null;\n      collaborators?: SceneData[\"collaborators\"];\n      /**\n       *  Controls which updates should be captured by the `Store`. Captured updates are emmitted and listened to by other components, such as `History` for undo / redo purposes.\n       *\n       *  - `CaptureUpdateAction.IMMEDIATELY`: Updates are immediately undoable. Use for most local updates.\n       *  - `CaptureUpdateAction.NEVER`: Updates never make it to undo/redo stack. Use for remote updates or scene initialization.\n       *  - `CaptureUpdateAction.EVENTUALLY`: Updates will be eventually be captured as part of a future increment.\n       *\n       * Check [API docs](https://docs.excalidraw.com/docs/excalidraw-custom/api/props/excalidraw-api#captureUpdate) for more details.\n       *\n       * @default CaptureUpdateAction.EVENTUALLY\n       */\n      captureUpdate?: SceneData[\"captureUpdate\"];\n    }) => {\n      const { elements, appState, collaborators, captureUpdate } = sceneData;\n\n      if (captureUpdate) {\n        const nextElements = elements ? elements : undefined;\n        const observedAppState = appState\n          ? getObservedAppState({\n              ...this.store.snapshot.appState,\n              ...appState,\n            })\n          : undefined;\n\n        this.store.scheduleMicroAction({\n          action: captureUpdate,\n          elements: nextElements,\n          appState: observedAppState,\n        });\n      }\n\n      if (appState) {\n        this.setState(appState);\n      }\n\n      if (elements) {\n        this.scene.replaceAllElements(elements);\n      }\n\n      if (collaborators) {\n        this.setState({ collaborators });\n      }\n    },\n  );\n\n  public mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n    element: TElement,\n    updates: ElementUpdate<TElement>,\n    informMutation = true,\n  ) => {\n    return this.scene.mutateElement(element, updates, {\n      informMutation,\n      isDragging: false,\n    });\n  };\n\n  private triggerRender = (\n    /** force always re-renders canvas even if no change */\n    force?: boolean,\n  ) => {\n    if (force === true) {\n      this.scene.triggerUpdate();\n    } else {\n      this.setState({});\n    }\n  };\n\n  /**\n   * @returns whether the menu was toggled on or off\n   */\n  public toggleSidebar = ({\n    name,\n    tab,\n    force,\n  }: {\n    name: SidebarName | null;\n    tab?: SidebarTabName;\n    force?: boolean;\n  }): boolean => {\n    let nextName;\n    if (force === undefined) {\n      nextName =\n        this.state.openSidebar?.name === name &&\n        this.state.openSidebar?.tab === tab\n          ? null\n          : name;\n    } else {\n      nextName = force ? name : null;\n    }\n\n    const nextState: AppState[\"openSidebar\"] = nextName\n      ? { name: nextName }\n      : null;\n    if (nextState && tab) {\n      nextState.tab = tab;\n    }\n\n    this.setState({ openSidebar: nextState });\n\n    return !!nextName;\n  };\n\n  private updateCurrentCursorPosition = withBatchedUpdates(\n    (event: MouseEvent) => {\n      this.lastViewportPosition.x = event.clientX;\n      this.lastViewportPosition.y = event.clientY;\n    },\n  );\n\n  public getEditorUIOffsets = (): Offsets => {\n    const toolbarBottom =\n      this.excalidrawContainerRef?.current\n        ?.querySelector(\".App-toolbar\")\n        ?.getBoundingClientRect()?.bottom ?? 0;\n    const sidebarRect = this.excalidrawContainerRef?.current\n      ?.querySelector(\".sidebar\")\n      ?.getBoundingClientRect();\n    const propertiesPanelRect = this.excalidrawContainerRef?.current\n      ?.querySelector(\".App-menu__left\")\n      ?.getBoundingClientRect();\n\n    const PADDING = 16;\n\n    return getLanguage().rtl\n      ? {\n          top: toolbarBottom + PADDING,\n          right:\n            Math.max(\n              this.state.width -\n                (propertiesPanelRect?.left ?? this.state.width),\n              0,\n            ) + PADDING,\n          bottom: PADDING,\n          left: Math.max(sidebarRect?.right ?? 0, 0) + PADDING,\n        }\n      : {\n          top: toolbarBottom + PADDING,\n          right: Math.max(\n            this.state.width -\n              (sidebarRect?.left ?? this.state.width) +\n              PADDING,\n            0,\n          ),\n          bottom: PADDING,\n          left: Math.max(propertiesPanelRect?.right ?? 0, 0) + PADDING,\n        };\n  };\n\n  // Input handling\n  private onKeyDown = withBatchedUpdates(\n    (event: React.KeyboardEvent | KeyboardEvent) => {\n      // normalize `event.key` when CapsLock is pressed #2372\n\n      if (\n        \"Proxy\" in window &&\n        ((!event.shiftKey && /^[A-Z]$/.test(event.key)) ||\n          (event.shiftKey && /^[a-z]$/.test(event.key)))\n      ) {\n        event = new Proxy(event, {\n          get(ev: any, prop) {\n            const value = ev[prop];\n            if (typeof value === \"function\") {\n              // fix for Proxies hijacking `this`\n              return value.bind(ev);\n            }\n            return prop === \"key\"\n              ? // CapsLock inverts capitalization based on ShiftKey, so invert\n                // it back\n                event.shiftKey\n                ? ev.key.toUpperCase()\n                : ev.key.toLowerCase()\n              : value;\n          },\n        });\n      }\n\n      if (!isInputLike(event.target)) {\n        if (\n          (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) &&\n          this.state.croppingElementId\n        ) {\n          this.finishImageCropping();\n          return;\n        }\n\n        const selectedElements = getSelectedElements(\n          this.scene.getNonDeletedElementsMap(),\n          this.state,\n        );\n\n        if (\n          selectedElements.length === 1 &&\n          isImageElement(selectedElements[0]) &&\n          event.key === KEYS.ENTER\n        ) {\n          this.startImageCropping(selectedElements[0]);\n          return;\n        }\n\n        // Shape switching\n        if (event.key === KEYS.ESCAPE) {\n          this.updateEditorAtom(convertElementTypePopupAtom, null);\n        } else if (\n          event.key === KEYS.TAB &&\n          (document.activeElement === this.excalidrawContainerRef?.current ||\n            document.activeElement?.classList.contains(\n              CLASSES.CONVERT_ELEMENT_TYPE_POPUP,\n            ))\n        ) {\n          event.preventDefault();\n\n          const conversionType =\n            getConversionTypeFromElements(selectedElements);\n\n          if (\n            editorJotaiStore.get(convertElementTypePopupAtom)?.type === \"panel\"\n          ) {\n            if (\n              convertElementTypes(this, {\n                conversionType,\n                direction: event.shiftKey ? \"left\" : \"right\",\n              })\n            ) {\n              this.store.scheduleCapture();\n            }\n          }\n          if (conversionType) {\n            this.updateEditorAtom(convertElementTypePopupAtom, {\n              type: \"panel\",\n            });\n          }\n        }\n\n        if (\n          event.key === KEYS.ESCAPE &&\n          this.flowChartCreator.isCreatingChart\n        ) {\n          this.flowChartCreator.clear();\n          this.triggerRender(true);\n          return;\n        }\n\n        const arrowKeyPressed = isArrowKey(event.key);\n\n        if (event[KEYS.CTRL_OR_CMD] && arrowKeyPressed && !event.shiftKey) {\n          event.preventDefault();\n\n          const selectedElements = getSelectedElements(\n            this.scene.getNonDeletedElementsMap(),\n            this.state,\n          );\n\n          if (\n            selectedElements.length === 1 &&\n            isFlowchartNodeElement(selectedElements[0])\n          ) {\n            this.flowChartCreator.createNodes(\n              selectedElements[0],\n              this.state,\n              getLinkDirectionFromKey(event.key),\n              this.scene,\n            );\n          }\n\n          if (\n            this.flowChartCreator.pendingNodes?.length &&\n            !isElementCompletelyInViewport(\n              this.flowChartCreator.pendingNodes,\n              this.canvas.width / window.devicePixelRatio,\n              this.canvas.height / window.devicePixelRatio,\n              {\n                offsetLeft: this.state.offsetLeft,\n                offsetTop: this.state.offsetTop,\n                scrollX: this.state.scrollX,\n                scrollY: this.state.scrollY,\n                zoom: this.state.zoom,\n              },\n              this.scene.getNonDeletedElementsMap(),\n              this.getEditorUIOffsets(),\n            )\n          ) {\n            this.scrollToContent(this.flowChartCreator.pendingNodes, {\n              animate: true,\n              duration: 300,\n              fitToContent: true,\n              canvasOffsets: this.getEditorUIOffsets(),\n            });\n          }\n\n          return;\n        }\n\n        if (event.altKey) {\n          const selectedElements = getSelectedElements(\n            this.scene.getNonDeletedElementsMap(),\n            this.state,\n          );\n\n          if (selectedElements.length === 1 && arrowKeyPressed) {\n            event.preventDefault();\n\n            const nextId = this.flowChartNavigator.exploreByDirection(\n              selectedElements[0],\n              this.scene.getNonDeletedElementsMap(),\n              getLinkDirectionFromKey(event.key),\n            );\n\n            if (nextId) {\n              this.setState((prevState) => ({\n                selectedElementIds: makeNextSelectedElementIds(\n                  {\n                    [nextId]: true,\n                  },\n                  prevState,\n                ),\n              }));\n\n              const nextNode = this.scene\n                .getNonDeletedElementsMap()\n                .get(nextId);\n\n              if (\n                nextNode &&\n                !isElementCompletelyInViewport(\n                  [nextNode],\n                  this.canvas.width / window.devicePixelRatio,\n                  this.canvas.height / window.devicePixelRatio,\n                  {\n                    offsetLeft: this.state.offsetLeft,\n                    offsetTop: this.state.offsetTop,\n                    scrollX: this.state.scrollX,\n                    scrollY: this.state.scrollY,\n                    zoom: this.state.zoom,\n                  },\n                  this.scene.getNonDeletedElementsMap(),\n                  this.getEditorUIOffsets(),\n                )\n              ) {\n                this.scrollToContent(nextNode, {\n                  animate: true,\n                  duration: 300,\n                  canvasOffsets: this.getEditorUIOffsets(),\n                });\n              }\n            }\n            return;\n          }\n        }\n      }\n\n      if (\n        event[KEYS.CTRL_OR_CMD] &&\n        event.key === KEYS.P &&\n        !event.shiftKey &&\n        !event.altKey\n      ) {\n        this.setToast({\n          message: t(\"commandPalette.shortcutHint\", {\n            shortcut: getShortcutFromShortcutName(\"commandPalette\"),\n          }),\n        });\n        event.preventDefault();\n        return;\n      }\n\n      if (event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.V) {\n        IS_PLAIN_PASTE = event.shiftKey;\n        clearTimeout(IS_PLAIN_PASTE_TIMER);\n        // reset (100ms to be safe that we it runs after the ensuing\n        // paste event). Though, technically unnecessary to reset since we\n        // (re)set the flag before each paste event.\n        IS_PLAIN_PASTE_TIMER = window.setTimeout(() => {\n          IS_PLAIN_PASTE = false;\n        }, 100);\n      }\n\n      // prevent browser zoom in input fields\n      if (event[KEYS.CTRL_OR_CMD] && isWritableElement(event.target)) {\n        if (event.code === CODES.MINUS || event.code === CODES.EQUAL) {\n          event.preventDefault();\n          return;\n        }\n      }\n\n      // bail if\n      if (\n        // inside an input\n        (isWritableElement(event.target) &&\n          // unless pressing escape (finalize action)\n          event.key !== KEYS.ESCAPE) ||\n        // or unless using arrows (to move between buttons)\n        (isArrowKey(event.key) && isInputLike(event.target))\n      ) {\n        return;\n      }\n\n      if (event.key === KEYS.QUESTION_MARK) {\n        this.setState({\n          openDialog: { name: \"help\" },\n        });\n        return;\n      } else if (\n        event.key.toLowerCase() === KEYS.E &&\n        event.shiftKey &&\n        event[KEYS.CTRL_OR_CMD]\n      ) {\n        event.preventDefault();\n        this.setState({ openDialog: { name: \"imageExport\" } });\n        return;\n      }\n\n      if (event.key === KEYS.PAGE_UP || event.key === KEYS.PAGE_DOWN) {\n        let offset =\n          (event.shiftKey ? this.state.width : this.state.height) /\n          this.state.zoom.value;\n        if (event.key === KEYS.PAGE_DOWN) {\n          offset = -offset;\n        }\n        if (event.shiftKey) {\n          this.translateCanvas((state) => ({\n            scrollX: state.scrollX + offset,\n          }));\n        } else {\n          this.translateCanvas((state) => ({\n            scrollY: state.scrollY + offset,\n          }));\n        }\n      }\n\n      if (this.state.openDialog?.name === \"elementLinkSelector\") {\n        return;\n      }\n\n      if (this.actionManager.handleKeyDown(event)) {\n        return;\n      }\n\n      if (this.state.viewModeEnabled) {\n        return;\n      }\n\n      if (event[KEYS.CTRL_OR_CMD] && this.state.isBindingEnabled) {\n        this.setState({ isBindingEnabled: false });\n      }\n\n      if (isArrowKey(event.key)) {\n        let selectedElements = this.scene.getSelectedElements({\n          selectedElementIds: this.state.selectedElementIds,\n          includeBoundTextElement: true,\n          includeElementsInFrames: true,\n        });\n\n        const elbowArrow = selectedElements.find(isElbowArrow) as\n          | ExcalidrawArrowElement\n          | undefined;\n\n        const arrowIdsToRemove = new Set<string>();\n\n        selectedElements\n          .filter(isElbowArrow)\n          .filter((arrow) => {\n            const startElementNotInSelection =\n              arrow.startBinding &&\n              !selectedElements.some(\n                (el) => el.id === arrow.startBinding?.elementId,\n              );\n            const endElementNotInSelection =\n              arrow.endBinding &&\n              !selectedElements.some(\n                (el) => el.id === arrow.endBinding?.elementId,\n              );\n            return startElementNotInSelection || endElementNotInSelection;\n          })\n          .forEach((arrow) => arrowIdsToRemove.add(arrow.id));\n\n        selectedElements = selectedElements.filter(\n          (el) => !arrowIdsToRemove.has(el.id),\n        );\n\n        const step =\n          (this.getEffectiveGridSize() &&\n            (event.shiftKey\n              ? ELEMENT_TRANSLATE_AMOUNT\n              : this.getEffectiveGridSize())) ||\n          (event.shiftKey\n            ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n            : ELEMENT_TRANSLATE_AMOUNT);\n\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (event.key === KEYS.ARROW_LEFT) {\n          offsetX = -step;\n        } else if (event.key === KEYS.ARROW_RIGHT) {\n          offsetX = step;\n        } else if (event.key === KEYS.ARROW_UP) {\n          offsetY = -step;\n        } else if (event.key === KEYS.ARROW_DOWN) {\n          offsetY = step;\n        }\n\n        selectedElements.forEach((element) => {\n          this.scene.mutateElement(\n            element,\n            {\n              x: element.x + offsetX,\n              y: element.y + offsetY,\n            },\n            { informMutation: false, isDragging: false },\n          );\n\n          updateBoundElements(element, this.scene, {\n            simultaneouslyUpdated: selectedElements,\n          });\n        });\n\n        this.setState({\n          suggestedBindings: getSuggestedBindingsForArrows(\n            selectedElements.filter(\n              (element) => element.id !== elbowArrow?.id || step !== 0,\n            ),\n            this.scene.getNonDeletedElementsMap(),\n            this.state.zoom,\n          ),\n        });\n\n        this.scene.triggerUpdate();\n\n        event.preventDefault();\n      } else if (event.key === KEYS.ENTER) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        if (selectedElements.length === 1) {\n          const selectedElement = selectedElements[0];\n          if (event[KEYS.CTRL_OR_CMD] || isLineElement(selectedElement)) {\n            if (isLinearElement(selectedElement)) {\n              if (\n                !this.state.editingLinearElement ||\n                this.state.editingLinearElement.elementId !== selectedElement.id\n              ) {\n                this.store.scheduleCapture();\n                if (!isElbowArrow(selectedElement)) {\n                  this.setState({\n                    editingLinearElement: new LinearElementEditor(\n                      selectedElement,\n                      this.scene.getNonDeletedElementsMap(),\n                    ),\n                  });\n                }\n              }\n            }\n          } else if (\n            isTextElement(selectedElement) ||\n            isValidTextContainer(selectedElement)\n          ) {\n            let container;\n            if (!isTextElement(selectedElement)) {\n              container = selectedElement as ExcalidrawTextContainer;\n            }\n            const midPoint = getContainerCenter(\n              selectedElement,\n              this.state,\n              this.scene.getNonDeletedElementsMap(),\n            );\n            const sceneX = midPoint.x;\n            const sceneY = midPoint.y;\n            this.startTextEditing({\n              sceneX,\n              sceneY,\n              container,\n            });\n            event.preventDefault();\n            return;\n          } else if (isFrameLikeElement(selectedElement)) {\n            this.setState({\n              editingFrame: selectedElement.id,\n            });\n          }\n        }\n      } else if (\n        !event.ctrlKey &&\n        !event.altKey &&\n        !event.metaKey &&\n        !this.state.newElement &&\n        !this.state.selectionElement &&\n        !this.state.selectedElementsAreBeingDragged\n      ) {\n        const shape = findShapeByKey(event.key);\n        if (shape) {\n          if (this.state.activeTool.type !== shape) {\n            trackEvent(\n              \"toolbar\",\n              shape,\n              `keyboard (${\n                this.device.editor.isMobile ? \"mobile\" : \"desktop\"\n              })`,\n            );\n          }\n          if (shape === \"arrow\" && this.state.activeTool.type === \"arrow\") {\n            this.setState((prevState) => ({\n              currentItemArrowType:\n                prevState.currentItemArrowType === ARROW_TYPE.sharp\n                  ? ARROW_TYPE.round\n                  : prevState.currentItemArrowType === ARROW_TYPE.round\n                  ? ARROW_TYPE.elbow\n                  : ARROW_TYPE.sharp,\n            }));\n          }\n          this.setActiveTool({ type: shape });\n          event.stopPropagation();\n        } else if (event.key === KEYS.Q) {\n          this.toggleLock(\"keyboard\");\n          event.stopPropagation();\n        }\n      }\n      if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n        isHoldingSpace = true;\n        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);\n        event.preventDefault();\n      }\n\n      if (\n        (event.key === KEYS.G || event.key === KEYS.S) &&\n        !event.altKey &&\n        !event[KEYS.CTRL_OR_CMD]\n      ) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        if (\n          this.state.activeTool.type === \"selection\" &&\n          !selectedElements.length\n        ) {\n          return;\n        }\n\n        if (\n          event.key === KEYS.G &&\n          (hasBackground(this.state.activeTool.type) ||\n            selectedElements.some((element) => hasBackground(element.type)))\n        ) {\n          this.setState({ openPopup: \"elementBackground\" });\n          event.stopPropagation();\n        }\n        if (event.key === KEYS.S) {\n          this.setState({ openPopup: \"elementStroke\" });\n          event.stopPropagation();\n        }\n      }\n\n      if (\n        !event[KEYS.CTRL_OR_CMD] &&\n        event.shiftKey &&\n        event.key.toLowerCase() === KEYS.F\n      ) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n\n        if (\n          this.state.activeTool.type === \"selection\" &&\n          !selectedElements.length\n        ) {\n          return;\n        }\n\n        if (\n          this.state.activeTool.type === \"text\" ||\n          selectedElements.find(\n            (element) =>\n              isTextElement(element) ||\n              getBoundTextElement(\n                element,\n                this.scene.getNonDeletedElementsMap(),\n              ),\n          )\n        ) {\n          event.preventDefault();\n          this.setState({ openPopup: \"fontFamily\" });\n        }\n      }\n\n      if (event.key === KEYS.K && !event.altKey && !event[KEYS.CTRL_OR_CMD]) {\n        if (this.state.activeTool.type === \"laser\") {\n          this.setActiveTool({ type: \"selection\" });\n        } else {\n          this.setActiveTool({ type: \"laser\" });\n        }\n        return;\n      }\n\n      if (\n        event[KEYS.CTRL_OR_CMD] &&\n        (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE)\n      ) {\n        this.updateEditorAtom(activeConfirmDialogAtom, \"clearCanvas\");\n      }\n\n      // eye dropper\n      // -----------------------------------------------------------------------\n      const lowerCased = event.key.toLocaleLowerCase();\n      const isPickingStroke = lowerCased === KEYS.S && event.shiftKey;\n      const isPickingBackground =\n        event.key === KEYS.I || (lowerCased === KEYS.G && event.shiftKey);\n\n      if (isPickingStroke || isPickingBackground) {\n        this.openEyeDropper({\n          type: isPickingStroke ? \"stroke\" : \"background\",\n        });\n      }\n      // -----------------------------------------------------------------------\n    },\n  );\n\n  private onKeyUp = withBatchedUpdates((event: KeyboardEvent) => {\n    if (event.key === KEYS.SPACE) {\n      if (\n        this.state.viewModeEnabled ||\n        this.state.openDialog?.name === \"elementLinkSelector\"\n      ) {\n        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);\n      } else if (\n        this.state.activeTool.type === \"selection\" ||\n        this.state.activeTool.type === \"lasso\"\n      ) {\n        resetCursor(this.interactiveCanvas);\n      } else {\n        setCursorForShape(this.interactiveCanvas, this.state);\n        this.setState({\n          selectedElementIds: makeNextSelectedElementIds({}, this.state),\n          selectedGroupIds: {},\n          editingGroupId: null,\n          activeEmbeddable: null,\n        });\n      }\n      isHoldingSpace = false;\n    }\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {\n      this.setState({ isBindingEnabled: true });\n    }\n    if (isArrowKey(event.key)) {\n      bindOrUnbindLinearElements(\n        this.scene.getSelectedElements(this.state).filter(isLinearElement),\n        isBindingEnabled(this.state),\n        this.state.selectedLinearElement?.selectedPointsIndices ?? [],\n        this.scene,\n        this.state.zoom,\n      );\n      this.setState({ suggestedBindings: [] });\n    }\n\n    if (!event.altKey) {\n      if (this.flowChartNavigator.isExploring) {\n        this.flowChartNavigator.clear();\n        this.syncActionResult({\n          captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n        });\n      }\n    }\n\n    if (!event[KEYS.CTRL_OR_CMD]) {\n      if (this.flowChartCreator.isCreatingChart) {\n        if (this.flowChartCreator.pendingNodes?.length) {\n          this.scene.insertElements(this.flowChartCreator.pendingNodes);\n        }\n\n        const firstNode = this.flowChartCreator.pendingNodes?.[0];\n\n        if (firstNode) {\n          this.setState((prevState) => ({\n            selectedElementIds: makeNextSelectedElementIds(\n              {\n                [firstNode.id]: true,\n              },\n              prevState,\n            ),\n          }));\n\n          if (\n            !isElementCompletelyInViewport(\n              [firstNode],\n              this.canvas.width / window.devicePixelRatio,\n              this.canvas.height / window.devicePixelRatio,\n              {\n                offsetLeft: this.state.offsetLeft,\n                offsetTop: this.state.offsetTop,\n                scrollX: this.state.scrollX,\n                scrollY: this.state.scrollY,\n                zoom: this.state.zoom,\n              },\n              this.scene.getNonDeletedElementsMap(),\n              this.getEditorUIOffsets(),\n            )\n          ) {\n            this.scrollToContent(firstNode, {\n              animate: true,\n              duration: 300,\n              canvasOffsets: this.getEditorUIOffsets(),\n            });\n          }\n        }\n\n        this.flowChartCreator.clear();\n        this.syncActionResult({\n          captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n        });\n      }\n    }\n  });\n\n  // We purposely widen the `tool` type so this helper can be called with\n  // any tool without having to type check it\n  private isToolSupported = <T extends ToolType | \"custom\">(tool: T) => {\n    return (\n      this.props.UIOptions.tools?.[\n        tool as Extract<T, keyof AppProps[\"UIOptions\"][\"tools\"]>\n      ] !== false\n    );\n  };\n\n  setActiveTool = (\n    tool: ({ type: ToolType } | { type: \"custom\"; customType: string }) & {\n      locked?: boolean;\n      fromSelection?: boolean;\n    },\n    keepSelection = false,\n  ) => {\n    if (!this.isToolSupported(tool.type)) {\n      console.warn(\n        `\"${tool.type}\" tool is disabled via \"UIOptions.canvasActions.tools.${tool.type}\"`,\n      );\n      return;\n    }\n\n    const nextActiveTool = updateActiveTool(this.state, tool);\n    if (nextActiveTool.type === \"hand\") {\n      setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);\n    } else if (!isHoldingSpace) {\n      setCursorForShape(this.interactiveCanvas, {\n        ...this.state,\n        activeTool: nextActiveTool,\n      });\n    }\n    if (isToolIcon(document.activeElement)) {\n      this.focusContainer();\n    }\n    if (!isLinearElementType(nextActiveTool.type)) {\n      this.setState({ suggestedBindings: [] });\n    }\n    if (nextActiveTool.type === \"image\") {\n      this.onImageAction();\n    }\n\n    this.setState((prevState) => {\n      const commonResets = {\n        snapLines: prevState.snapLines.length ? [] : prevState.snapLines,\n        originSnapOffset: null,\n        activeEmbeddable: null,\n      } as const;\n\n      if (nextActiveTool.type === \"freedraw\") {\n        this.store.scheduleCapture();\n      }\n\n      if (nextActiveTool.type === \"lasso\") {\n        return {\n          ...prevState,\n          activeTool: nextActiveTool,\n          ...(keepSelection\n            ? {}\n            : {\n                selectedElementIds: makeNextSelectedElementIds({}, prevState),\n                selectedGroupIds: makeNextSelectedElementIds({}, prevState),\n                editingGroupId: null,\n                multiElement: null,\n              }),\n          ...commonResets,\n        };\n      } else if (nextActiveTool.type !== \"selection\") {\n        return {\n          ...prevState,\n          activeTool: nextActiveTool,\n          selectedElementIds: makeNextSelectedElementIds({}, prevState),\n          selectedGroupIds: makeNextSelectedElementIds({}, prevState),\n          editingGroupId: null,\n          multiElement: null,\n          ...commonResets,\n        };\n      }\n      return {\n        ...prevState,\n        activeTool: nextActiveTool,\n        ...commonResets,\n      };\n    });\n  };\n\n  setOpenDialog = (dialogType: AppState[\"openDialog\"]) => {\n    this.setState({ openDialog: dialogType });\n  };\n\n  private setCursor = (cursor: string) => {\n    setCursor(this.interactiveCanvas, cursor);\n  };\n\n  private resetCursor = () => {\n    resetCursor(this.interactiveCanvas);\n  };\n  /**\n   * returns whether user is making a gesture with >= 2 fingers (points)\n   * on o touch screen (not on a trackpad). Currently only relates to Darwin\n   * (iOS/iPadOS,MacOS), but may work on other devices in the future if\n   * GestureEvent is standardized.\n   */\n  private isTouchScreenMultiTouchGesture = () => {\n    // we don't want to deselect when using trackpad, and multi-point gestures\n    // only work on touch screens, so checking for >= pointers means we're on a\n    // touchscreen\n    return gesture.pointers.size >= 2;\n  };\n\n  public getName = () => {\n    return (\n      this.state.name ||\n      this.props.name ||\n      `${t(\"labels.untitled\")}-${getDateTime()}`\n    );\n  };\n\n  // fires only on Safari\n  private onGestureStart = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n\n    // we only want to deselect on touch screens because user may have selected\n    // elements by mistake while zooming\n    if (this.isTouchScreenMultiTouchGesture()) {\n      this.setState({\n        selectedElementIds: makeNextSelectedElementIds({}, this.state),\n        activeEmbeddable: null,\n      });\n    }\n    gesture.initialScale = this.state.zoom.value;\n  });\n\n  // fires only on Safari\n  private onGestureChange = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n\n    // onGestureChange only has zoom factor but not the center.\n    // If we're on iPad or iPhone, then we recognize multi-touch and will\n    // zoom in at the right location in the touchmove handler\n    // (handleCanvasPointerMove).\n    //\n    // On Macbook trackpad, we don't have those events so will zoom in at the\n    // current location instead.\n    //\n    // As such, bail from this handler on touch devices.\n    if (this.isTouchScreenMultiTouchGesture()) {\n      return;\n    }\n\n    const initialScale = gesture.initialScale;\n    if (initialScale) {\n      this.setState((state) => ({\n        ...getStateForZoom(\n          {\n            viewportX: this.lastViewportPosition.x,\n            viewportY: this.lastViewportPosition.y,\n            nextZoom: getNormalizedZoom(initialScale * event.scale),\n          },\n          state,\n        ),\n      }));\n    }\n  });\n\n  // fires only on Safari\n  private onGestureEnd = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    // reselect elements only on touch screens (see onGestureStart)\n    if (this.isTouchScreenMultiTouchGesture()) {\n      this.setState({\n        previousSelectedElementIds: {},\n        selectedElementIds: makeNextSelectedElementIds(\n          this.state.previousSelectedElementIds,\n          this.state,\n        ),\n      });\n    }\n    gesture.initialScale = null;\n  });\n\n  private handleTextWysiwyg(\n    element: ExcalidrawTextElement,\n    {\n      isExistingElement = false,\n    }: {\n      isExistingElement?: boolean;\n    },\n  ) {\n    const elementsMap = this.scene.getElementsMapIncludingDeleted();\n\n    const updateElement = (nextOriginalText: string, isDeleted: boolean) => {\n      this.scene.replaceAllElements([\n        // Not sure why we include deleted elements as well hence using deleted elements map\n        ...this.scene.getElementsIncludingDeleted().map((_element) => {\n          if (_element.id === element.id && isTextElement(_element)) {\n            return newElementWith(_element, {\n              originalText: nextOriginalText,\n              isDeleted: isDeleted ?? _element.isDeleted,\n              // returns (wrapped) text and new dimensions\n              ...refreshTextDimensions(\n                _element,\n                getContainerElement(_element, elementsMap),\n                elementsMap,\n                nextOriginalText,\n              ),\n            });\n          }\n          return _element;\n        }),\n      ]);\n    };\n\n    textWysiwyg({\n      id: element.id,\n      canvas: this.canvas,\n      getViewportCoords: (x, y) => {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          {\n            sceneX: x,\n            sceneY: y,\n          },\n          this.state,\n        );\n        return [\n          viewportX - this.state.offsetLeft,\n          viewportY - this.state.offsetTop,\n        ];\n      },\n      onChange: withBatchedUpdates((nextOriginalText) => {\n        updateElement(nextOriginalText, false);\n        if (isNonDeletedElement(element)) {\n          updateBoundElements(element, this.scene);\n        }\n      }),\n      onSubmit: withBatchedUpdates(({ viaKeyboard, nextOriginalText }) => {\n        const isDeleted = !nextOriginalText.trim();\n        updateElement(nextOriginalText, isDeleted);\n        // select the created text element only if submitting via keyboard\n        // (when submitting via click it should act as signal to deselect)\n        if (!isDeleted && viaKeyboard) {\n          const elementIdToSelect = element.containerId\n            ? element.containerId\n            : element.id;\n\n          // needed to ensure state is updated before \"finalize\" action\n          // that's invoked on keyboard-submit as well\n          // TODO either move this into finalize as well, or handle all state\n          // updates in one place, skipping finalize action\n          flushSync(() => {\n            this.setState((prevState) => ({\n              selectedElementIds: makeNextSelectedElementIds(\n                {\n                  ...prevState.selectedElementIds,\n                  [elementIdToSelect]: true,\n                },\n                prevState,\n              ),\n            }));\n          });\n        }\n        if (isDeleted) {\n          fixBindingsAfterDeletion(this.scene.getNonDeletedElements(), [\n            element,\n          ]);\n        }\n        if (!isDeleted || isExistingElement) {\n          this.store.scheduleCapture();\n        }\n\n        flushSync(() => {\n          this.setState({\n            newElement: null,\n            editingTextElement: null,\n          });\n        });\n\n        if (this.state.activeTool.locked) {\n          setCursorForShape(this.interactiveCanvas, this.state);\n        }\n\n        this.focusContainer();\n      }),\n      element,\n      excalidrawContainer: this.excalidrawContainerRef.current,\n      app: this,\n      // when text is selected, it's hard (at least on iOS) to re-position the\n      // caret (i.e. deselect). There's not much use for always selecting\n      // the text on edit anyway (and users can select-all from contextmenu\n      // if needed)\n      autoSelect: !this.device.isTouchScreen,\n    });\n    // deselect all other elements when inserting text\n    this.deselectElements();\n\n    // do an initial update to re-initialize element position since we were\n    // modifying element's x/y for sake of editor (case: syncing to remote)\n    updateElement(element.originalText, false);\n  }\n\n  private deselectElements() {\n    this.setState({\n      selectedElementIds: makeNextSelectedElementIds({}, this.state),\n      selectedGroupIds: {},\n      editingGroupId: null,\n      activeEmbeddable: null,\n    });\n  }\n\n  private getTextElementAtPosition(\n    x: number,\n    y: number,\n  ): NonDeleted<ExcalidrawTextElement> | null {\n    const element = this.getElementAtPosition(x, y, {\n      includeBoundTextElement: true,\n    });\n    if (element && isTextElement(element) && !element.isDeleted) {\n      return element;\n    }\n    return null;\n  }\n\n  // NOTE: Hot path for hit testing, so avoid unnecessary computations\n  private getElementAtPosition(\n    x: number,\n    y: number,\n    opts?: (\n      | {\n          includeBoundTextElement?: boolean;\n          includeLockedElements?: boolean;\n        }\n      | {\n          allHitElements: NonDeleted<ExcalidrawElement>[];\n        }\n    ) & {\n      preferSelected?: boolean;\n    },\n  ): NonDeleted<ExcalidrawElement> | null {\n    let allHitElements: NonDeleted<ExcalidrawElement>[] = [];\n    if (opts && \"allHitElements\" in opts) {\n      allHitElements = opts?.allHitElements || [];\n    } else {\n      allHitElements = this.getElementsAtPosition(x, y, {\n        includeBoundTextElement: opts?.includeBoundTextElement,\n        includeLockedElements: opts?.includeLockedElements,\n      });\n    }\n\n    if (allHitElements.length > 1) {\n      if (opts?.preferSelected) {\n        for (let index = allHitElements.length - 1; index > -1; index--) {\n          if (this.state.selectedElementIds[allHitElements[index].id]) {\n            return allHitElements[index];\n          }\n        }\n      }\n      const elementWithHighestZIndex =\n        allHitElements[allHitElements.length - 1];\n\n      // If we're hitting element with highest z-index only on its bounding box\n      // while also hitting other element figure, the latter should be considered.\n      return hitElementItself({\n        point: pointFrom(x, y),\n        element: elementWithHighestZIndex,\n        // when overlapping, we would like to be more precise\n        // this also avoids the need to update past tests\n        threshold: this.getElementHitThreshold(elementWithHighestZIndex) / 2,\n        elementsMap: this.scene.getNonDeletedElementsMap(),\n        frameNameBound: isFrameLikeElement(elementWithHighestZIndex)\n          ? this.frameNameBoundsCache.get(elementWithHighestZIndex)\n          : null,\n      })\n        ? elementWithHighestZIndex\n        : allHitElements[allHitElements.length - 2];\n    }\n    if (allHitElements.length === 1) {\n      return allHitElements[0];\n    }\n\n    return null;\n  }\n\n  // NOTE: Hot path for hit testing, so avoid unnecessary computations\n  private getElementsAtPosition(\n    x: number,\n    y: number,\n    opts?: {\n      includeBoundTextElement?: boolean;\n      includeLockedElements?: boolean;\n    },\n  ): NonDeleted<ExcalidrawElement>[] {\n    const iframeLikes: Ordered<ExcalidrawIframeElement>[] = [];\n\n    const elementsMap = this.scene.getNonDeletedElementsMap();\n\n    const elements = (\n      opts?.includeBoundTextElement && opts?.includeLockedElements\n        ? this.scene.getNonDeletedElements()\n        : this.scene\n            .getNonDeletedElements()\n            .filter(\n              (element) =>\n                (opts?.includeLockedElements || !element.locked) &&\n                (opts?.includeBoundTextElement ||\n                  !(isTextElement(element) && element.containerId)),\n            )\n    )\n      .filter((el) => this.hitElement(x, y, el))\n      .filter((element) => {\n        // hitting a frame's element from outside the frame is not considered a hit\n        const containingFrame = getContainingFrame(element, elementsMap);\n        return containingFrame &&\n          this.state.frameRendering.enabled &&\n          this.state.frameRendering.clip\n          ? isCursorInFrame({ x, y }, containingFrame, elementsMap)\n          : true;\n      })\n      .filter((el) => {\n        // The parameter elements comes ordered from lower z-index to higher.\n        // We want to preserve that order on the returned array.\n        // Exception being embeddables which should be on top of everything else in\n        // terms of hit testing.\n        if (isIframeElement(el)) {\n          iframeLikes.push(el);\n          return false;\n        }\n        return true;\n      })\n      .concat(iframeLikes) as NonDeleted<ExcalidrawElement>[];\n\n    return elements;\n  }\n\n  getElementHitThreshold(element: ExcalidrawElement) {\n    return Math.max(\n      element.strokeWidth / 2 + 0.1,\n      // NOTE: Here be dragons. Do not go under the 0.63 multiplier unless you're\n      // willing to test extensively. The hit testing starts to become unreliable\n      // due to FP imprecision under 0.63 in high zoom levels.\n      0.85 * (DEFAULT_COLLISION_THRESHOLD / this.state.zoom.value),\n    );\n  }\n\n  private hitElement(\n    x: number,\n    y: number,\n    element: ExcalidrawElement,\n    considerBoundingBox = true,\n  ) {\n    // if the element is selected, then hit test is done against its bounding box\n    if (\n      considerBoundingBox &&\n      this.state.selectedElementIds[element.id] &&\n      shouldShowBoundingBox([element], this.state)\n    ) {\n      // if hitting the bounding box, return early\n      // but if not, we should check for other cases as well (e.g. frame name)\n      if (\n        hitElementBoundingBox(\n          pointFrom(x, y),\n          element,\n          this.scene.getNonDeletedElementsMap(),\n          this.getElementHitThreshold(element),\n        )\n      ) {\n        return true;\n      }\n    }\n\n    // take bound text element into consideration for hit collision as well\n    const hitBoundTextOfElement = hitElementBoundText(\n      pointFrom(x, y),\n      element,\n      this.scene.getNonDeletedElementsMap(),\n    );\n    if (hitBoundTextOfElement) {\n      return true;\n    }\n\n    return hitElementItself({\n      point: pointFrom(x, y),\n      element,\n      threshold: this.getElementHitThreshold(element),\n      elementsMap: this.scene.getNonDeletedElementsMap(),\n      frameNameBound: isFrameLikeElement(element)\n        ? this.frameNameBoundsCache.get(element)\n        : null,\n    });\n  }\n\n  private getTextBindableContainerAtPosition(x: number, y: number) {\n    const elements = this.scene.getNonDeletedElements();\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    if (selectedElements.length === 1) {\n      return isTextBindableContainer(selectedElements[0], false)\n        ? selectedElements[0]\n        : null;\n    }\n    let hitElement = null;\n    // We need to do hit testing from front (end of the array) to back (beginning of the array)\n    for (let index = elements.length - 1; index >= 0; --index) {\n      if (elements[index].isDeleted) {\n        continue;\n      }\n      const [x1, y1, x2, y2] = getElementAbsoluteCoords(\n        elements[index],\n        this.scene.getNonDeletedElementsMap(),\n      );\n      if (\n        isArrowElement(elements[index]) &&\n        hitElementItself({\n          point: pointFrom(x, y),\n          element: elements[index],\n          elementsMap: this.scene.getNonDeletedElementsMap(),\n          threshold: this.getElementHitThreshold(elements[index]),\n        })\n      ) {\n        hitElement = elements[index];\n        break;\n      } else if (x1 < x && x < x2 && y1 < y && y < y2) {\n        hitElement = elements[index];\n        break;\n      }\n    }\n\n    return isTextBindableContainer(hitElement, false) ? hitElement : null;\n  }\n\n  private startTextEditing = ({\n    sceneX,\n    sceneY,\n    insertAtParentCenter = true,\n    container,\n    autoEdit = true,\n  }: {\n    /** X position to insert text at */\n    sceneX: number;\n    /** Y position to insert text at */\n    sceneY: number;\n    /** whether to attempt to insert at element center if applicable */\n    insertAtParentCenter?: boolean;\n    container?: ExcalidrawTextContainer | null;\n    autoEdit?: boolean;\n  }) => {\n    let shouldBindToContainer = false;\n\n    let parentCenterPosition =\n      insertAtParentCenter &&\n      this.getTextWysiwygSnappedToCenterPosition(\n        sceneX,\n        sceneY,\n        this.state,\n        container,\n      );\n    if (container && parentCenterPosition) {\n      const boundTextElementToContainer = getBoundTextElement(\n        container,\n        this.scene.getNonDeletedElementsMap(),\n      );\n      if (!boundTextElementToContainer) {\n        shouldBindToContainer = true;\n      }\n    }\n    let existingTextElement: NonDeleted<ExcalidrawTextElement> | null = null;\n\n    const selectedElements = this.scene.getSelectedElements(this.state);\n\n    if (selectedElements.length === 1) {\n      if (isTextElement(selectedElements[0])) {\n        existingTextElement = selectedElements[0];\n      } else if (container) {\n        existingTextElement = getBoundTextElement(\n          selectedElements[0],\n          this.scene.getNonDeletedElementsMap(),\n        );\n      } else {\n        existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n      }\n    } else {\n      existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);\n    }\n\n    const fontFamily =\n      existingTextElement?.fontFamily || this.state.currentItemFontFamily;\n\n    const lineHeight =\n      existingTextElement?.lineHeight || getLineHeight(fontFamily);\n    const fontSize = this.state.currentItemFontSize;\n\n    if (\n      !existingTextElement &&\n      shouldBindToContainer &&\n      container &&\n      !isArrowElement(container)\n    ) {\n      const fontString = {\n        fontSize,\n        fontFamily,\n      };\n      const minWidth = getApproxMinLineWidth(\n        getFontString(fontString),\n        lineHeight,\n      );\n      const minHeight = getApproxMinLineHeight(fontSize, lineHeight);\n      const newHeight = Math.max(container.height, minHeight);\n      const newWidth = Math.max(container.width, minWidth);\n      this.scene.mutateElement(container, {\n        height: newHeight,\n        width: newWidth,\n      });\n      sceneX = container.x + newWidth / 2;\n      sceneY = container.y + newHeight / 2;\n      if (parentCenterPosition) {\n        parentCenterPosition = this.getTextWysiwygSnappedToCenterPosition(\n          sceneX,\n          sceneY,\n          this.state,\n          container,\n        );\n      }\n    }\n\n    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n      x: sceneX,\n      y: sceneY,\n    });\n\n    const element =\n      existingTextElement ||\n      newTextElement({\n        x: parentCenterPosition ? parentCenterPosition.elementCenterX : sceneX,\n        y: parentCenterPosition ? parentCenterPosition.elementCenterY : sceneY,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        strokeStyle: this.state.currentItemStrokeStyle,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        text: \"\",\n        fontSize,\n        fontFamily,\n        textAlign: parentCenterPosition\n          ? \"center\"\n          : this.state.currentItemTextAlign,\n        verticalAlign: parentCenterPosition\n          ? VERTICAL_ALIGN.MIDDLE\n          : DEFAULT_VERTICAL_ALIGN,\n        containerId: shouldBindToContainer ? container?.id : undefined,\n        groupIds: container?.groupIds ?? [],\n        lineHeight,\n        angle: container\n          ? isArrowElement(container)\n            ? (0 as Radians)\n            : container.angle\n          : (0 as Radians),\n        frameId: topLayerFrame ? topLayerFrame.id : null,\n      });\n\n    if (!existingTextElement && shouldBindToContainer && container) {\n      this.scene.mutateElement(container, {\n        boundElements: (container.boundElements || []).concat({\n          type: \"text\",\n          id: element.id,\n        }),\n      });\n    }\n    this.setState({ editingTextElement: element });\n\n    if (!existingTextElement) {\n      if (container && shouldBindToContainer) {\n        const containerIndex = this.scene.getElementIndex(container.id);\n        this.scene.insertElementAtIndex(element, containerIndex + 1);\n      } else {\n        this.scene.insertElement(element);\n      }\n    }\n\n    if (autoEdit || existingTextElement || container) {\n      this.handleTextWysiwyg(element, {\n        isExistingElement: !!existingTextElement,\n      });\n    } else {\n      this.setState({\n        newElement: element,\n        multiElement: null,\n      });\n    }\n  };\n\n  private startImageCropping = (image: ExcalidrawImageElement) => {\n    this.store.scheduleCapture();\n    this.setState({\n      croppingElementId: image.id,\n    });\n  };\n\n  private finishImageCropping = () => {\n    if (this.state.croppingElementId) {\n      this.store.scheduleCapture();\n      this.setState({\n        croppingElementId: null,\n      });\n    }\n  };\n\n  private handleCanvasDoubleClick = (\n    event: React.MouseEvent<HTMLCanvasElement>,\n  ) => {\n    // case: double-clicking with arrow/line tool selected would both create\n    // text and enter multiElement mode\n    if (this.state.multiElement) {\n      return;\n    }\n    // we should only be able to double click when mode is selection\n    if (this.state.activeTool.type !== \"selection\") {\n      return;\n    }\n\n    const selectedElements = this.scene.getSelectedElements(this.state);\n\n    let { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n    );\n\n    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {\n      const selectedLinearElement: ExcalidrawLinearElement =\n        selectedElements[0];\n      if (\n        ((event[KEYS.CTRL_OR_CMD] && isSimpleArrow(selectedLinearElement)) ||\n          isLineElement(selectedLinearElement)) &&\n        this.state.editingLinearElement?.elementId !== selectedLinearElement.id\n      ) {\n        this.store.scheduleCapture();\n        this.setState({\n          editingLinearElement: new LinearElementEditor(\n            selectedLinearElement,\n            this.scene.getNonDeletedElementsMap(),\n          ),\n        });\n        return;\n      } else if (\n        this.state.selectedLinearElement &&\n        isElbowArrow(selectedElements[0])\n      ) {\n        const hitCoords = LinearElementEditor.getSegmentMidpointHitCoords(\n          this.state.selectedLinearElement,\n          { x: sceneX, y: sceneY },\n          this.state,\n          this.scene.getNonDeletedElementsMap(),\n        );\n        const midPoint = hitCoords\n          ? LinearElementEditor.getSegmentMidPointIndex(\n              this.state.selectedLinearElement,\n              this.state,\n              hitCoords,\n              this.scene.getNonDeletedElementsMap(),\n            )\n          : -1;\n\n        if (midPoint && midPoint > -1) {\n          this.store.scheduleCapture();\n          LinearElementEditor.deleteFixedSegment(\n            selectedElements[0],\n            this.scene,\n            midPoint,\n          );\n\n          const nextCoords = LinearElementEditor.getSegmentMidpointHitCoords(\n            {\n              ...this.state.selectedLinearElement,\n              segmentMidPointHoveredCoords: null,\n            },\n            { x: sceneX, y: sceneY },\n            this.state,\n            this.scene.getNonDeletedElementsMap(),\n          );\n          const nextIndex = nextCoords\n            ? LinearElementEditor.getSegmentMidPointIndex(\n                this.state.selectedLinearElement,\n                this.state,\n                nextCoords,\n                this.scene.getNonDeletedElementsMap(),\n              )\n            : null;\n\n          this.setState({\n            selectedLinearElement: {\n              ...this.state.selectedLinearElement,\n              pointerDownState: {\n                ...this.state.selectedLinearElement.pointerDownState,\n                segmentMidpoint: {\n                  index: nextIndex,\n                  value: hitCoords,\n                  added: false,\n                },\n              },\n              segmentMidPointHoveredCoords: nextCoords,\n            },\n          });\n\n          return;\n        }\n      } else if (\n        this.state.editingLinearElement &&\n        this.state.editingLinearElement.elementId ===\n          selectedLinearElement.id &&\n        isLineElement(selectedLinearElement)\n      ) {\n        return;\n      }\n    }\n\n    if (selectedElements.length === 1 && isImageElement(selectedElements[0])) {\n      this.startImageCropping(selectedElements[0]);\n      return;\n    }\n\n    resetCursor(this.interactiveCanvas);\n\n    const selectedGroupIds = getSelectedGroupIds(this.state);\n\n    if (selectedGroupIds.length > 0) {\n      const hitElement = this.getElementAtPosition(sceneX, sceneY);\n\n      const selectedGroupId =\n        hitElement &&\n        getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);\n\n      if (selectedGroupId) {\n        this.store.scheduleCapture();\n        this.setState((prevState) => ({\n          ...prevState,\n          ...selectGroupsForSelectedElements(\n            {\n              editingGroupId: selectedGroupId,\n              selectedElementIds: { [hitElement!.id]: true },\n            },\n            this.scene.getNonDeletedElements(),\n            prevState,\n            this,\n          ),\n        }));\n        return;\n      }\n    }\n\n    resetCursor(this.interactiveCanvas);\n    if (!event[KEYS.CTRL_OR_CMD] && !this.state.viewModeEnabled) {\n      const hitElement = this.getElementAtPosition(sceneX, sceneY);\n\n      if (isIframeLikeElement(hitElement)) {\n        this.setState({\n          activeEmbeddable: { element: hitElement, state: \"active\" },\n        });\n        return;\n      }\n\n      // shouldn't edit/create text when inside line editor (often false positive)\n\n      if (!this.state.editingLinearElement) {\n        const container = this.getTextBindableContainerAtPosition(\n          sceneX,\n          sceneY,\n        );\n\n        if (container) {\n          if (\n            hasBoundTextElement(container) ||\n            !isTransparent(container.backgroundColor) ||\n            hitElementItself({\n              point: pointFrom(sceneX, sceneY),\n              element: container,\n              elementsMap: this.scene.getNonDeletedElementsMap(),\n              threshold: this.getElementHitThreshold(container),\n            })\n          ) {\n            const midPoint = getContainerCenter(\n              container,\n              this.state,\n              this.scene.getNonDeletedElementsMap(),\n            );\n\n            sceneX = midPoint.x;\n            sceneY = midPoint.y;\n          }\n        }\n\n        this.startTextEditing({\n          sceneX,\n          sceneY,\n          insertAtParentCenter: !event.altKey,\n          container,\n        });\n      }\n    }\n  };\n\n  private getElementLinkAtPosition = (\n    scenePointer: Readonly<{ x: number; y: number }>,\n    hitElementMightBeLocked: NonDeletedExcalidrawElement | null,\n  ): ExcalidrawElement | undefined => {\n    if (hitElementMightBeLocked && hitElementMightBeLocked.locked) {\n      return undefined;\n    }\n\n    const elements = this.scene.getNonDeletedElements();\n    let hitElementIndex = -1;\n\n    for (let index = elements.length - 1; index >= 0; index--) {\n      const element = elements[index];\n      if (\n        hitElementMightBeLocked &&\n        element.id === hitElementMightBeLocked.id\n      ) {\n        hitElementIndex = index;\n      }\n      if (\n        element.link &&\n        index >= hitElementIndex &&\n        isPointHittingLink(\n          element,\n          this.scene.getNonDeletedElementsMap(),\n          this.state,\n          pointFrom(scenePointer.x, scenePointer.y),\n          this.device.editor.isMobile,\n        )\n      ) {\n        return element;\n      }\n    }\n  };\n\n  private redirectToLink = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n    isTouchScreen: boolean,\n  ) => {\n    const draggedDistance = pointDistance(\n      pointFrom(\n        this.lastPointerDownEvent!.clientX,\n        this.lastPointerDownEvent!.clientY,\n      ),\n      pointFrom(\n        this.lastPointerUpEvent!.clientX,\n        this.lastPointerUpEvent!.clientY,\n      ),\n    );\n    if (!this.hitLinkElement || draggedDistance > DRAGGING_THRESHOLD) {\n      return;\n    }\n    const lastPointerDownCoords = viewportCoordsToSceneCoords(\n      this.lastPointerDownEvent!,\n      this.state,\n    );\n    const elementsMap = this.scene.getNonDeletedElementsMap();\n    const lastPointerDownHittingLinkIcon = isPointHittingLink(\n      this.hitLinkElement,\n      elementsMap,\n      this.state,\n      pointFrom(lastPointerDownCoords.x, lastPointerDownCoords.y),\n      this.device.editor.isMobile,\n    );\n    const lastPointerUpCoords = viewportCoordsToSceneCoords(\n      this.lastPointerUpEvent!,\n      this.state,\n    );\n    const lastPointerUpHittingLinkIcon = isPointHittingLink(\n      this.hitLinkElement,\n      elementsMap,\n      this.state,\n      pointFrom(lastPointerUpCoords.x, lastPointerUpCoords.y),\n      this.device.editor.isMobile,\n    );\n    if (lastPointerDownHittingLinkIcon && lastPointerUpHittingLinkIcon) {\n      hideHyperlinkToolip();\n      let url = this.hitLinkElement.link;\n      if (url) {\n        url = normalizeLink(url);\n        let customEvent;\n        if (this.props.onLinkOpen) {\n          customEvent = wrapEvent(EVENT.EXCALIDRAW_LINK, event.nativeEvent);\n          this.props.onLinkOpen(\n            {\n              ...this.hitLinkElement,\n              link: url,\n            },\n            customEvent,\n          );\n        }\n        if (!customEvent?.defaultPrevented) {\n          const target = isLocalLink(url) ? \"_self\" : \"_blank\";\n          const newWindow = window.open(undefined, target);\n          // https://mathiasbynens.github.io/rel-noopener/\n          if (newWindow) {\n            newWindow.opener = null;\n            newWindow.location = url;\n          }\n        }\n      }\n    }\n  };\n\n  private getTopLayerFrameAtSceneCoords = (sceneCoords: {\n    x: number;\n    y: number;\n  }) => {\n    const elementsMap = this.scene.getNonDeletedElementsMap();\n    const frames = this.scene\n      .getNonDeletedFramesLikes()\n      .filter((frame): frame is ExcalidrawFrameLikeElement =>\n        isCursorInFrame(sceneCoords, frame, elementsMap),\n      );\n\n    return frames.length ? frames[frames.length - 1] : null;\n  };\n\n  private handleCanvasPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n    this.lastPointerMoveEvent = event.nativeEvent;\n\n    if (gesture.pointers.has(event.pointerId)) {\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY,\n      });\n    }\n\n    const initialScale = gesture.initialScale;\n    if (\n      gesture.pointers.size === 2 &&\n      gesture.lastCenter &&\n      initialScale &&\n      gesture.initialDistance\n    ) {\n      const center = getCenter(gesture.pointers);\n      const deltaX = center.x - gesture.lastCenter.x;\n      const deltaY = center.y - gesture.lastCenter.y;\n      gesture.lastCenter = center;\n\n      const distance = getDistance(Array.from(gesture.pointers.values()));\n      const scaleFactor =\n        this.state.activeTool.type === \"freedraw\" && this.state.penMode\n          ? 1\n          : distance / gesture.initialDistance;\n\n      const nextZoom = scaleFactor\n        ? getNormalizedZoom(initialScale * scaleFactor)\n        : this.state.zoom.value;\n\n      this.setState((state) => {\n        const zoomState = getStateForZoom(\n          {\n            viewportX: center.x,\n            viewportY: center.y,\n            nextZoom,\n          },\n          state,\n        );\n\n        this.translateCanvas({\n          zoom: zoomState.zoom,\n          // 2x multiplier is just a magic number that makes this work correctly\n          // on touchscreen devices (note: if we get report that panning is slower/faster\n          // than actual movement, consider swapping with devicePixelRatio)\n          scrollX: zoomState.scrollX + 2 * (deltaX / nextZoom),\n          scrollY: zoomState.scrollY + 2 * (deltaY / nextZoom),\n          shouldCacheIgnoreZoom: true,\n        });\n      });\n      this.resetShouldCacheIgnoreZoomDebounced();\n    } else {\n      gesture.lastCenter =\n        gesture.initialDistance =\n        gesture.initialScale =\n          null;\n    }\n\n    if (\n      isHoldingSpace ||\n      isPanning ||\n      isDraggingScrollBar ||\n      isHandToolActive(this.state)\n    ) {\n      return;\n    }\n\n    const isPointerOverScrollBars = isOverScrollBars(\n      currentScrollBars,\n      event.clientX - this.state.offsetLeft,\n      event.clientY - this.state.offsetTop,\n    );\n    const isOverScrollBar = isPointerOverScrollBars.isOverEither;\n    if (\n      !this.state.newElement &&\n      !this.state.selectionElement &&\n      !this.state.selectedElementsAreBeingDragged &&\n      !this.state.multiElement\n    ) {\n      if (isOverScrollBar) {\n        resetCursor(this.interactiveCanvas);\n      } else {\n        setCursorForShape(this.interactiveCanvas, this.state);\n      }\n    }\n\n    const scenePointer = viewportCoordsToSceneCoords(event, this.state);\n    const { x: scenePointerX, y: scenePointerY } = scenePointer;\n\n    if (\n      !this.state.newElement &&\n      isActiveToolNonLinearSnappable(this.state.activeTool.type)\n    ) {\n      const { originOffset, snapLines } = getSnapLinesAtPointer(\n        this.scene.getNonDeletedElements(),\n        this,\n        {\n          x: scenePointerX,\n          y: scenePointerY,\n        },\n        event,\n        this.scene.getNonDeletedElementsMap(),\n      );\n\n      this.setState((prevState) => {\n        const nextSnapLines = updateStable(prevState.snapLines, snapLines);\n        const nextOriginOffset = prevState.originSnapOffset\n          ? updateStable(prevState.originSnapOffset, originOffset)\n          : originOffset;\n\n        if (\n          prevState.snapLines === nextSnapLines &&\n          prevState.originSnapOffset === nextOriginOffset\n        ) {\n          return null;\n        }\n        return {\n          snapLines: nextSnapLines,\n          originSnapOffset: nextOriginOffset,\n        };\n      });\n    } else if (\n      !this.state.newElement &&\n      !this.state.selectedElementsAreBeingDragged &&\n      !this.state.selectionElement\n    ) {\n      this.setState((prevState) => {\n        if (prevState.snapLines.length) {\n          return {\n            snapLines: [],\n          };\n        }\n        return null;\n      });\n    }\n\n    if (\n      this.state.editingLinearElement &&\n      !this.state.editingLinearElement.isDragging\n    ) {\n      const editingLinearElement = LinearElementEditor.handlePointerMove(\n        event,\n        scenePointerX,\n        scenePointerY,\n        this,\n      );\n\n      if (\n        editingLinearElement &&\n        editingLinearElement !== this.state.editingLinearElement\n      ) {\n        // Since we are reading from previous state which is not possible with\n        // automatic batching in React 18 hence using flush sync to synchronously\n        // update the state. Check https://github.com/excalidraw/excalidraw/pull/5508 for more details.\n        flushSync(() => {\n          this.setState({\n            editingLinearElement,\n          });\n        });\n      }\n      if (editingLinearElement?.lastUncommittedPoint != null) {\n        this.maybeSuggestBindingAtCursor(\n          scenePointer,\n          editingLinearElement.elbowed,\n        );\n      } else {\n        // causes stack overflow if not sync\n        flushSync(() => {\n          this.setState({ suggestedBindings: [] });\n        });\n      }\n    }\n\n    if (isBindingElementType(this.state.activeTool.type)) {\n      // Hovering with a selected tool or creating new linear element via click\n      // and point\n      const { newElement } = this.state;\n      if (isBindingElement(newElement, false)) {\n        this.setState({\n          suggestedBindings: maybeSuggestBindingsForLinearElementAtCoords(\n            newElement,\n            [scenePointer],\n            this.scene,\n            this.state.zoom,\n            this.state.startBoundElement,\n          ),\n        });\n      } else {\n        this.maybeSuggestBindingAtCursor(scenePointer, false);\n      }\n    }\n\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n      const { x: rx, y: ry } = multiElement;\n\n      const { points, lastCommittedPoint } = multiElement;\n      const lastPoint = points[points.length - 1];\n\n      setCursorForShape(this.interactiveCanvas, this.state);\n\n      if (lastPoint === lastCommittedPoint) {\n        // if we haven't yet created a temp point and we're beyond commit-zone\n        // threshold, add a point\n        if (\n          pointDistance(\n            pointFrom(scenePointerX - rx, scenePointerY - ry),\n            lastPoint,\n          ) >= LINE_CONFIRM_THRESHOLD\n        ) {\n          this.scene.mutateElement(\n            multiElement,\n            {\n              points: [\n                ...points,\n                pointFrom<LocalPoint>(scenePointerX - rx, scenePointerY - ry),\n              ],\n            },\n            { informMutation: false, isDragging: false },\n          );\n        } else {\n          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);\n          // in this branch, we're inside the commit zone, and no uncommitted\n          // point exists. Thus do nothing (don't add/remove points).\n        }\n      } else if (\n        points.length > 2 &&\n        lastCommittedPoint &&\n        pointDistance(\n          pointFrom(scenePointerX - rx, scenePointerY - ry),\n          lastCommittedPoint,\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);\n        this.scene.mutateElement(\n          multiElement,\n          {\n            points: points.slice(0, -1),\n          },\n          { informMutation: false, isDragging: false },\n        );\n      } else {\n        const [gridX, gridY] = getGridPoint(\n          scenePointerX,\n          scenePointerY,\n          event[KEYS.CTRL_OR_CMD] || isElbowArrow(multiElement)\n            ? null\n            : this.getEffectiveGridSize(),\n        );\n\n        const [lastCommittedX, lastCommittedY] =\n          multiElement?.lastCommittedPoint ?? [0, 0];\n\n        let dxFromLastCommitted = gridX - rx - lastCommittedX;\n        let dyFromLastCommitted = gridY - ry - lastCommittedY;\n\n        if (shouldRotateWithDiscreteAngle(event)) {\n          ({ width: dxFromLastCommitted, height: dyFromLastCommitted } =\n            getLockedLinearCursorAlignSize(\n              // actual coordinate of the last committed point\n              lastCommittedX + rx,\n              lastCommittedY + ry,\n              // cursor-grid coordinate\n              gridX,\n              gridY,\n            ));\n        }\n\n        if (isPathALoop(points, this.state.zoom.value)) {\n          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);\n        }\n\n        // update last uncommitted point\n        this.scene.mutateElement(\n          multiElement,\n          {\n            points: [\n              ...points.slice(0, -1),\n              pointFrom<LocalPoint>(\n                lastCommittedX + dxFromLastCommitted,\n                lastCommittedY + dyFromLastCommitted,\n              ),\n            ],\n          },\n          {\n            isDragging: true,\n            informMutation: false,\n          },\n        );\n\n        // in this path, we're mutating multiElement to reflect\n        // how it will be after adding pointer position as the next point\n        // trigger update here so that new element canvas renders again to reflect this\n        this.triggerRender(false);\n      }\n\n      return;\n    }\n\n    const hasDeselectedButton = Boolean(event.buttons);\n    if (\n      hasDeselectedButton ||\n      (this.state.activeTool.type !== \"selection\" &&\n        this.state.activeTool.type !== \"text\" &&\n        this.state.activeTool.type !== \"eraser\")\n    ) {\n      return;\n    }\n\n    const elements = this.scene.getNonDeletedElements();\n\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    if (\n      selectedElements.length === 1 &&\n      !isOverScrollBar &&\n      !this.state.editingLinearElement\n    ) {\n      // for linear elements, we'd like to prioritize point dragging over edge resizing\n      // therefore, we update and check hovered point index first\n      if (this.state.selectedLinearElement) {\n        this.handleHoverSelectedLinearElement(\n          this.state.selectedLinearElement,\n          scenePointerX,\n          scenePointerY,\n        );\n      }\n\n      if (\n        (!this.state.selectedLinearElement ||\n          this.state.selectedLinearElement.hoverPointIndex === -1) &&\n        this.state.openDialog?.name !== \"elementLinkSelector\" &&\n        !(selectedElements.length === 1 && isElbowArrow(selectedElements[0]))\n      ) {\n        const elementWithTransformHandleType =\n          getElementWithTransformHandleType(\n            elements,\n            this.state,\n            scenePointerX,\n            scenePointerY,\n            this.state.zoom,\n            event.pointerType,\n            this.scene.getNonDeletedElementsMap(),\n            this.device,\n          );\n        if (\n          elementWithTransformHandleType &&\n          elementWithTransformHandleType.transformHandleType\n        ) {\n          setCursor(\n            this.interactiveCanvas,\n            getCursorForResizingElement(elementWithTransformHandleType),\n          );\n          return;\n        }\n      }\n    } else if (\n      selectedElements.length > 1 &&\n      !isOverScrollBar &&\n      this.state.openDialog?.name !== \"elementLinkSelector\"\n    ) {\n      const transformHandleType = getTransformHandleTypeFromCoords(\n        getCommonBounds(selectedElements),\n        scenePointerX,\n        scenePointerY,\n        this.state.zoom,\n        event.pointerType,\n        this.device,\n      );\n      if (transformHandleType) {\n        setCursor(\n          this.interactiveCanvas,\n          getCursorForResizingElement({\n            transformHandleType,\n          }),\n        );\n        return;\n      }\n    }\n\n    const hitElementMightBeLocked = this.getElementAtPosition(\n      scenePointerX,\n      scenePointerY,\n      {\n        preferSelected: true,\n        includeLockedElements: true,\n      },\n    );\n\n    let hitElement: ExcalidrawElement | null = null;\n    if (hitElementMightBeLocked && hitElementMightBeLocked.locked) {\n      hitElement = null;\n    } else {\n      hitElement = hitElementMightBeLocked;\n    }\n\n    this.hitLinkElement = this.getElementLinkAtPosition(\n      scenePointer,\n      hitElementMightBeLocked,\n    );\n    if (isEraserActive(this.state)) {\n      return;\n    }\n    if (\n      this.hitLinkElement &&\n      !this.state.selectedElementIds[this.hitLinkElement.id]\n    ) {\n      setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);\n      showHyperlinkTooltip(\n        this.hitLinkElement,\n        this.state,\n        this.scene.getNonDeletedElementsMap(),\n      );\n    } else {\n      hideHyperlinkToolip();\n      if (\n        hitElement &&\n        (hitElement.link || isEmbeddableElement(hitElement)) &&\n        this.state.selectedElementIds[hitElement.id] &&\n        !this.state.contextMenu &&\n        !this.state.showHyperlinkPopup\n      ) {\n        this.setState({ showHyperlinkPopup: \"info\" });\n      } else if (this.state.activeTool.type === \"text\") {\n        setCursor(\n          this.interactiveCanvas,\n          isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR,\n        );\n      } else if (this.state.viewModeEnabled) {\n        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);\n      } else if (this.state.openDialog?.name === \"elementLinkSelector\") {\n        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);\n      } else if (isOverScrollBar) {\n        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);\n      } else if (\n        this.state.selectedLinearElement &&\n        hitElement?.id === this.state.selectedLinearElement.elementId\n      ) {\n        this.handleHoverSelectedLinearElement(\n          this.state.selectedLinearElement,\n          scenePointerX,\n          scenePointerY,\n        );\n      } else if (\n        // if using cmd/ctrl, we're not dragging\n        !event[KEYS.CTRL_OR_CMD]\n      ) {\n        if (\n          (hitElement ||\n            this.isHittingCommonBoundingBoxOfSelectedElements(\n              scenePointer,\n              selectedElements,\n            )) &&\n          !hitElement?.locked\n        ) {\n          if (\n            hitElement &&\n            isIframeLikeElement(hitElement) &&\n            this.isIframeLikeElementCenter(\n              hitElement,\n              event,\n              scenePointerX,\n              scenePointerY,\n            )\n          ) {\n            setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);\n            this.setState({\n              activeEmbeddable: { element: hitElement, state: \"hover\" },\n            });\n          } else if (\n            !hitElement ||\n            // Ebow arrows can only be moved when unconnected\n            !isElbowArrow(hitElement) ||\n            !(hitElement.startBinding || hitElement.endBinding)\n          ) {\n            setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);\n            if (this.state.activeEmbeddable?.state === \"hover\") {\n              this.setState({ activeEmbeddable: null });\n            }\n          }\n        }\n      } else {\n        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);\n      }\n    }\n\n    if (this.state.openDialog?.name === \"elementLinkSelector\" && hitElement) {\n      this.setState((prevState) => {\n        return {\n          hoveredElementIds: updateStable(\n            prevState.hoveredElementIds,\n            selectGroupsForSelectedElements(\n              {\n                editingGroupId: prevState.editingGroupId,\n                selectedElementIds: { [hitElement!.id]: true },\n              },\n              this.scene.getNonDeletedElements(),\n              prevState,\n              this,\n            ).selectedElementIds,\n          ),\n        };\n      });\n    } else if (\n      this.state.openDialog?.name === \"elementLinkSelector\" &&\n      !hitElement\n    ) {\n      this.setState((prevState) => ({\n        hoveredElementIds: updateStable(prevState.hoveredElementIds, {}),\n      }));\n    }\n  };\n\n  private handleEraser = (\n    event: PointerEvent,\n    scenePointer: { x: number; y: number },\n  ) => {\n    const elementsToErase = this.eraserTrail.addPointToPath(\n      scenePointer.x,\n      scenePointer.y,\n      event.altKey,\n    );\n\n    this.elementsPendingErasure = new Set(elementsToErase);\n    this.triggerRender();\n  };\n\n  // set touch moving for mobile context menu\n  private handleTouchMove = (event: React.TouchEvent<HTMLCanvasElement>) => {\n    invalidateContextMenu = true;\n  };\n\n  handleHoverSelectedLinearElement(\n    linearElementEditor: LinearElementEditor,\n    scenePointerX: number,\n    scenePointerY: number,\n  ) {\n    const elementsMap = this.scene.getNonDeletedElementsMap();\n\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n      elementsMap,\n    );\n\n    if (!element) {\n      return;\n    }\n    if (this.state.selectedLinearElement) {\n      let hoverPointIndex = -1;\n      let segmentMidPointHoveredCoords = null;\n      if (\n        hitElementItself({\n          point: pointFrom(scenePointerX, scenePointerY),\n          element,\n          elementsMap,\n          threshold: this.getElementHitThreshold(element),\n        })\n      ) {\n        hoverPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n          element,\n          elementsMap,\n          this.state.zoom,\n          scenePointerX,\n          scenePointerY,\n        );\n        segmentMidPointHoveredCoords =\n          LinearElementEditor.getSegmentMidpointHitCoords(\n            linearElementEditor,\n            { x: scenePointerX, y: scenePointerY },\n            this.state,\n            this.scene.getNonDeletedElementsMap(),\n          );\n        const isHoveringAPointHandle = isElbowArrow(element)\n          ? hoverPointIndex === 0 ||\n            hoverPointIndex === element.points.length - 1\n          : hoverPointIndex >= 0;\n        if (isHoveringAPointHandle || segmentMidPointHoveredCoords) {\n          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);\n        } else if (this.hitElement(scenePointerX, scenePointerY, element)) {\n          if (\n            // Ebow arrows can only be moved when unconnected\n            !isElbowArrow(element) ||\n            !(element.startBinding || element.endBinding)\n          ) {\n            setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);\n          }\n        }\n      } else if (this.hitElement(scenePointerX, scenePointerY, element)) {\n        if (\n          // Ebow arrows can only be moved when unconnected\n          !isElbowArrow(element) ||\n          !(element.startBinding || element.endBinding)\n        ) {\n          setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);\n        }\n      }\n\n      if (\n        this.state.selectedLinearElement.hoverPointIndex !== hoverPointIndex\n      ) {\n        this.setState({\n          selectedLinearElement: {\n            ...this.state.selectedLinearElement,\n            hoverPointIndex,\n          },\n        });\n      }\n\n      if (\n        !LinearElementEditor.arePointsEqual(\n          this.state.selectedLinearElement.segmentMidPointHoveredCoords,\n          segmentMidPointHoveredCoords,\n        )\n      ) {\n        this.setState({\n          selectedLinearElement: {\n            ...this.state.selectedLinearElement,\n            segmentMidPointHoveredCoords,\n          },\n        });\n      }\n    } else {\n      setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);\n    }\n  }\n\n  private handleCanvasPointerDown = (\n    event: React.PointerEvent<HTMLElement>,\n  ) => {\n    const target = event.target as HTMLElement;\n    // capture subsequent pointer events to the canvas\n    // this makes other elements non-interactive until pointer up\n    if (target.setPointerCapture) {\n      target.setPointerCapture(event.pointerId);\n    }\n\n    this.maybeCleanupAfterMissingPointerUp(event.nativeEvent);\n    this.maybeUnfollowRemoteUser();\n\n    if (this.state.searchMatches) {\n      this.setState((state) => {\n        return {\n          searchMatches: state.searchMatches && {\n            focusedId: null,\n            matches: state.searchMatches.matches.map((searchMatch) => ({\n              ...searchMatch,\n              focus: false,\n            })),\n          },\n        };\n      });\n      this.updateEditorAtom(searchItemInFocusAtom, null);\n    }\n\n    if (editorJotaiStore.get(convertElementTypePopupAtom)) {\n      this.updateEditorAtom(convertElementTypePopupAtom, null);\n    }\n\n    // since contextMenu options are potentially evaluated on each render,\n    // and an contextMenu action may depend on selection state, we must\n    // close the contextMenu before we update the selection on pointerDown\n    // (e.g. resetting selection)\n    if (this.state.contextMenu) {\n      this.setState({ contextMenu: null });\n    }\n\n    if (this.state.snapLines) {\n      this.setAppState({ snapLines: [] });\n    }\n\n    this.updateGestureOnPointerDown(event);\n\n    // if dragging element is freedraw and another pointerdown event occurs\n    // a second finger is on the screen\n    // discard the freedraw element if it is very short because it is likely\n    // just a spike, otherwise finalize the freedraw element when the second\n    // finger is lifted\n    if (\n      event.pointerType === \"touch\" &&\n      this.state.newElement &&\n      this.state.newElement.type === \"freedraw\"\n    ) {\n      const element = this.state.newElement as ExcalidrawFreeDrawElement;\n      this.updateScene({\n        ...(element.points.length < 10\n          ? {\n              elements: this.scene\n                .getElementsIncludingDeleted()\n                .filter((el) => el.id !== element.id),\n            }\n          : {}),\n        appState: {\n          newElement: null,\n          editingTextElement: null,\n          startBoundElement: null,\n          suggestedBindings: [],\n          selectedElementIds: makeNextSelectedElementIds(\n            Object.keys(this.state.selectedElementIds)\n              .filter((key) => key !== element.id)\n              .reduce((obj: { [id: string]: true }, key) => {\n                obj[key] = this.state.selectedElementIds[key];\n                return obj;\n              }, {}),\n            this.state,\n          ),\n        },\n        captureUpdate:\n          this.state.openDialog?.name === \"elementLinkSelector\"\n            ? CaptureUpdateAction.EVENTUALLY\n            : CaptureUpdateAction.NEVER,\n      });\n      return;\n    }\n\n    // remove any active selection when we start to interact with canvas\n    // (mainly, we care about removing selection outside the component which\n    //  would prevent our copy handling otherwise)\n    const selection = document.getSelection();\n    if (selection?.anchorNode) {\n      selection.removeAllRanges();\n    }\n    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);\n\n    //fires only once, if pen is detected, penMode is enabled\n    //the user can disable this by toggling the penMode button\n    if (!this.state.penDetected && event.pointerType === \"pen\") {\n      this.setState((prevState) => {\n        return {\n          penMode: true,\n          penDetected: true,\n        };\n      });\n    }\n\n    if (\n      !this.device.isTouchScreen &&\n      [\"pen\", \"touch\"].includes(event.pointerType)\n    ) {\n      this.device = updateObject(this.device, { isTouchScreen: true });\n    }\n\n    if (isPanning) {\n      return;\n    }\n\n    this.lastPointerDownEvent = event;\n\n    // we must exit before we set `cursorButton` state and `savePointer`\n    // else it will send pointer state & laser pointer events in collab when\n    // panning\n    if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {\n      return;\n    }\n\n    this.setState({\n      lastPointerDownWith: event.pointerType,\n      cursorButton: \"down\",\n    });\n    this.savePointer(event.clientX, event.clientY, \"down\");\n\n    if (\n      event.button === POINTER_BUTTON.ERASER &&\n      this.state.activeTool.type !== TOOL_TYPE.eraser\n    ) {\n      this.setState(\n        {\n          activeTool: updateActiveTool(this.state, {\n            type: TOOL_TYPE.eraser,\n            lastActiveToolBeforeEraser: this.state.activeTool,\n          }),\n        },\n        () => {\n          this.handleCanvasPointerDown(event);\n          const onPointerUp = () => {\n            unsubPointerUp();\n            unsubCleanup?.();\n            if (isEraserActive(this.state)) {\n              this.setState({\n                activeTool: updateActiveTool(this.state, {\n                  ...(this.state.activeTool.lastActiveTool || {\n                    type: TOOL_TYPE.selection,\n                  }),\n                  lastActiveToolBeforeEraser: null,\n                }),\n              });\n            }\n          };\n\n          const unsubPointerUp = addEventListener(\n            window,\n            EVENT.POINTER_UP,\n            onPointerUp,\n            {\n              once: true,\n            },\n          );\n          let unsubCleanup: UnsubscribeCallback | undefined;\n          // subscribe inside rAF lest it'd be triggered on the same pointerdown\n          // if we start erasing while coming from blurred document since\n          // we cleanup pointer events on focus\n          requestAnimationFrame(() => {\n            unsubCleanup =\n              this.missingPointerEventCleanupEmitter.once(onPointerUp);\n          });\n        },\n      );\n      return;\n    }\n\n    // only handle left mouse button or touch\n    if (\n      event.button !== POINTER_BUTTON.MAIN &&\n      event.button !== POINTER_BUTTON.TOUCH &&\n      event.button !== POINTER_BUTTON.ERASER\n    ) {\n      return;\n    }\n\n    // don't select while panning\n    if (gesture.pointers.size > 1) {\n      return;\n    }\n\n    // State for the duration of a pointer interaction, which starts with a\n    // pointerDown event, ends with a pointerUp event (or another pointerDown)\n    const pointerDownState = this.initialPointerDownState(event);\n\n    this.setState({\n      selectedElementsAreBeingDragged: false,\n    });\n\n    if (this.handleDraggingScrollBar(event, pointerDownState)) {\n      return;\n    }\n\n    this.clearSelectionIfNotUsingSelection();\n    this.updateBindingEnabledOnPointerMove(event);\n\n    if (this.handleSelectionOnPointerDown(event, pointerDownState)) {\n      return;\n    }\n\n    const allowOnPointerDown =\n      !this.state.penMode ||\n      event.pointerType !== \"touch\" ||\n      this.state.activeTool.type === \"selection\" ||\n      this.state.activeTool.type === \"lasso\" ||\n      this.state.activeTool.type === \"text\" ||\n      this.state.activeTool.type === \"image\";\n\n    if (!allowOnPointerDown) {\n      return;\n    }\n\n    if (this.state.activeTool.type === \"lasso\") {\n      this.lassoTrail.startPath(\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        event.shiftKey,\n      );\n    } else if (this.state.activeTool.type === \"text\") {\n      this.handleTextOnPointerDown(event, pointerDownState);\n    } else if (\n      this.state.activeTool.type === \"arrow\" ||\n      this.state.activeTool.type === \"line\"\n    ) {\n      this.handleLinearElementOnPointerDown(\n        event,\n        this.state.activeTool.type,\n        pointerDownState,\n      );\n    } else if (this.state.activeTool.type === \"freedraw\") {\n      this.handleFreeDrawElementOnPointerDown(\n        event,\n        this.state.activeTool.type,\n        pointerDownState,\n      );\n    } else if (this.state.activeTool.type === \"custom\") {\n      setCursorForShape(this.interactiveCanvas, this.state);\n    } else if (\n      this.state.activeTool.type === TOOL_TYPE.frame ||\n      this.state.activeTool.type === TOOL_TYPE.magicframe\n    ) {\n      this.createFrameElementOnPointerDown(\n        pointerDownState,\n        this.state.activeTool.type,\n      );\n    } else if (this.state.activeTool.type === \"laser\") {\n      this.laserTrails.startPath(\n        pointerDownState.lastCoords.x,\n        pointerDownState.lastCoords.y,\n      );\n    } else if (\n      this.state.activeTool.type !== \"eraser\" &&\n      this.state.activeTool.type !== \"hand\" &&\n      this.state.activeTool.type !== \"image\"\n    ) {\n      this.createGenericElementOnPointerDown(\n        this.state.activeTool.type,\n        pointerDownState,\n      );\n    }\n\n    this.props?.onPointerDown?.(this.state.activeTool, pointerDownState);\n    this.onPointerDownEmitter.trigger(\n      this.state.activeTool,\n      pointerDownState,\n      event,\n    );\n\n    if (this.state.activeTool.type === \"eraser\") {\n      this.eraserTrail.startPath(\n        pointerDownState.lastCoords.x,\n        pointerDownState.lastCoords.y,\n      );\n    }\n\n    const onPointerMove =\n      this.onPointerMoveFromPointerDownHandler(pointerDownState);\n\n    const onPointerUp =\n      this.onPointerUpFromPointerDownHandler(pointerDownState);\n\n    const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);\n    const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);\n\n    this.missingPointerEventCleanupEmitter.once((_event) =>\n      onPointerUp(_event || event.nativeEvent),\n    );\n\n    if (!this.state.viewModeEnabled || this.state.activeTool.type === \"laser\") {\n      window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n      window.addEventListener(EVENT.KEYDOWN, onKeyDown);\n      window.addEventListener(EVENT.KEYUP, onKeyUp);\n      pointerDownState.eventListeners.onMove = onPointerMove;\n      pointerDownState.eventListeners.onUp = onPointerUp;\n      pointerDownState.eventListeners.onKeyUp = onKeyUp;\n      pointerDownState.eventListeners.onKeyDown = onKeyDown;\n    }\n  };\n\n  private handleCanvasPointerUp = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    this.removePointer(event);\n    this.lastPointerUpEvent = event;\n\n    const scenePointer = viewportCoordsToSceneCoords(\n      { clientX: event.clientX, clientY: event.clientY },\n      this.state,\n    );\n    const clicklength =\n      event.timeStamp - (this.lastPointerDownEvent?.timeStamp ?? 0);\n\n    if (this.device.editor.isMobile && clicklength < 300) {\n      const hitElement = this.getElementAtPosition(\n        scenePointer.x,\n        scenePointer.y,\n      );\n      if (\n        isIframeLikeElement(hitElement) &&\n        this.isIframeLikeElementCenter(\n          hitElement,\n          event,\n          scenePointer.x,\n          scenePointer.y,\n        )\n      ) {\n        this.handleEmbeddableCenterClick(hitElement);\n        return;\n      }\n    }\n\n    if (this.device.isTouchScreen) {\n      const hitElement = this.getElementAtPosition(\n        scenePointer.x,\n        scenePointer.y,\n        {\n          includeLockedElements: true,\n        },\n      );\n      this.hitLinkElement = this.getElementLinkAtPosition(\n        scenePointer,\n        hitElement,\n      );\n    }\n\n    if (\n      this.hitLinkElement &&\n      !this.state.selectedElementIds[this.hitLinkElement.id]\n    ) {\n      if (\n        clicklength < 300 &&\n        isIframeLikeElement(this.hitLinkElement) &&\n        !isPointHittingLinkIcon(\n          this.hitLinkElement,\n          this.scene.getNonDeletedElementsMap(),\n          this.state,\n          pointFrom(scenePointer.x, scenePointer.y),\n        )\n      ) {\n        this.handleEmbeddableCenterClick(this.hitLinkElement);\n      } else {\n        this.redirectToLink(event, this.device.isTouchScreen);\n      }\n    } else if (this.state.viewModeEnabled) {\n      this.setState({\n        activeEmbeddable: null,\n        selectedElementIds: {},\n      });\n    }\n  };\n\n  private maybeOpenContextMenuAfterPointerDownOnTouchDevices = (\n    event: React.PointerEvent<HTMLElement>,\n  ): void => {\n    // deal with opening context menu on touch devices\n    if (event.pointerType === \"touch\") {\n      invalidateContextMenu = false;\n\n      if (touchTimeout) {\n        // If there's already a touchTimeout, this means that there's another\n        // touch down and we are doing another touch, so we shouldn't open the\n        // context menu.\n        invalidateContextMenu = true;\n      } else {\n        // open the context menu with the first touch's clientX and clientY\n        // if the touch is not moving\n        touchTimeout = window.setTimeout(() => {\n          touchTimeout = 0;\n          if (!invalidateContextMenu) {\n            this.handleCanvasContextMenu(event);\n          }\n        }, TOUCH_CTX_MENU_TIMEOUT);\n      }\n    }\n  };\n\n  private resetContextMenuTimer = () => {\n    clearTimeout(touchTimeout);\n    touchTimeout = 0;\n    invalidateContextMenu = false;\n  };\n\n  /**\n   * pointerup may not fire in certian cases (user tabs away...), so in order\n   * to properly cleanup pointerdown state, we need to fire any hanging\n   * pointerup handlers manually\n   */\n  private maybeCleanupAfterMissingPointerUp = (event: PointerEvent | null) => {\n    lastPointerUp?.();\n    this.missingPointerEventCleanupEmitter.trigger(event).clear();\n  };\n\n  // Returns whether the event is a panning\n  public handleCanvasPanUsingWheelOrSpaceDrag = (\n    event: React.PointerEvent<HTMLElement> | MouseEvent,\n  ): boolean => {\n    if (\n      !(\n        gesture.pointers.size <= 1 &&\n        (event.button === POINTER_BUTTON.WHEEL ||\n          (event.button === POINTER_BUTTON.MAIN && isHoldingSpace) ||\n          isHandToolActive(this.state) ||\n          this.state.viewModeEnabled)\n      )\n    ) {\n      return false;\n    }\n    isPanning = true;\n\n    // due to event.preventDefault below, container wouldn't get focus\n    // automatically\n    this.focusContainer();\n\n    // preventing defualt while text editing messes with cursor/focus\n    if (!this.state.editingTextElement) {\n      // necessary to prevent browser from scrolling the page if excalidraw\n      // not full-page #4489\n      //\n      // as such, the above is broken when panning canvas while in wysiwyg\n      event.preventDefault();\n    }\n\n    let nextPastePrevented = false;\n    const isLinux =\n      typeof window === undefined\n        ? false\n        : /Linux/.test(window.navigator.platform);\n\n    setCursor(this.interactiveCanvas, CURSOR_TYPE.GRABBING);\n    let { clientX: lastX, clientY: lastY } = event;\n    const onPointerMove = withBatchedUpdatesThrottled((event: PointerEvent) => {\n      const deltaX = lastX - event.clientX;\n      const deltaY = lastY - event.clientY;\n      lastX = event.clientX;\n      lastY = event.clientY;\n\n      /*\n       * Prevent paste event if we move while middle clicking on Linux.\n       * See issue #1383.\n       */\n      if (\n        isLinux &&\n        !nextPastePrevented &&\n        (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)\n      ) {\n        nextPastePrevented = true;\n\n        /* Prevent the next paste event */\n        const preventNextPaste = (event: ClipboardEvent) => {\n          document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n          event.stopPropagation();\n        };\n\n        /*\n         * Reenable next paste in case of disabled middle click paste for\n         * any reason:\n         * - right click paste\n         * - empty clipboard\n         */\n        const enableNextPaste = () => {\n          setTimeout(() => {\n            document.body.removeEventListener(EVENT.PASTE, preventNextPaste);\n            window.removeEventListener(EVENT.POINTER_UP, enableNextPaste);\n          }, 100);\n        };\n\n        document.body.addEventListener(EVENT.PASTE, preventNextPaste);\n        window.addEventListener(EVENT.POINTER_UP, enableNextPaste);\n      }\n\n      this.translateCanvas({\n        scrollX: this.state.scrollX - deltaX / this.state.zoom.value,\n        scrollY: this.state.scrollY - deltaY / this.state.zoom.value,\n      });\n    });\n    const teardown = withBatchedUpdates(\n      (lastPointerUp = () => {\n        lastPointerUp = null;\n        isPanning = false;\n        if (!isHoldingSpace) {\n          if (this.state.viewModeEnabled) {\n            setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);\n          } else {\n            setCursorForShape(this.interactiveCanvas, this.state);\n          }\n        }\n        this.setState({\n          cursorButton: \"up\",\n        });\n        this.savePointer(event.clientX, event.clientY, \"up\");\n        window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n        window.removeEventListener(EVENT.POINTER_UP, teardown);\n        window.removeEventListener(EVENT.BLUR, teardown);\n        onPointerMove.flush();\n      }),\n    );\n    window.addEventListener(EVENT.BLUR, teardown);\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove, {\n      passive: true,\n    });\n    window.addEventListener(EVENT.POINTER_UP, teardown);\n    return true;\n  };\n\n  private updateGestureOnPointerDown(\n    event: React.PointerEvent<HTMLElement>,\n  ): void {\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom.value;\n      gesture.initialDistance = getDistance(\n        Array.from(gesture.pointers.values()),\n      );\n    }\n  }\n\n  private initialPointerDownState(\n    event: React.PointerEvent<HTMLElement>,\n  ): PointerDownState {\n    const origin = viewportCoordsToSceneCoords(event, this.state);\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);\n    const isElbowArrowOnly = selectedElements.findIndex(isElbowArrow) === 0;\n\n    return {\n      origin,\n      withCmdOrCtrl: event[KEYS.CTRL_OR_CMD],\n      originInGrid: tupleToCoors(\n        getGridPoint(\n          origin.x,\n          origin.y,\n          event[KEYS.CTRL_OR_CMD] || isElbowArrowOnly\n            ? null\n            : this.getEffectiveGridSize(),\n        ),\n      ),\n      scrollbars: isOverScrollBars(\n        currentScrollBars,\n        event.clientX - this.state.offsetLeft,\n        event.clientY - this.state.offsetTop,\n      ),\n      // we need to duplicate because we'll be updating this state\n      lastCoords: { ...origin },\n      originalElements: this.scene\n        .getNonDeletedElements()\n        .reduce((acc, element) => {\n          acc.set(element.id, deepCopyElement(element));\n          return acc;\n        }, new Map() as PointerDownState[\"originalElements\"]),\n      resize: {\n        handleType: false,\n        isResizing: false,\n        offset: { x: 0, y: 0 },\n        arrowDirection: \"origin\",\n        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 },\n      },\n      hit: {\n        element: null,\n        allHitElements: [],\n        wasAddedToSelection: false,\n        hasBeenDuplicated: false,\n        hasHitCommonBoundingBoxOfSelectedElements:\n          this.isHittingCommonBoundingBoxOfSelectedElements(\n            origin,\n            selectedElements,\n          ),\n      },\n      drag: {\n        hasOccurred: false,\n        offset: null,\n        origin: { ...origin },\n      },\n      eventListeners: {\n        onMove: null,\n        onUp: null,\n        onKeyUp: null,\n        onKeyDown: null,\n      },\n      boxSelection: {\n        hasOccurred: false,\n      },\n    };\n  }\n\n  // Returns whether the event is a dragging a scrollbar\n  private handleDraggingScrollBar(\n    event: React.PointerEvent<HTMLElement>,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (\n      !(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)\n    ) {\n      return false;\n    }\n    isDraggingScrollBar = true;\n    pointerDownState.lastCoords.x = event.clientX;\n    pointerDownState.lastCoords.y = event.clientY;\n    const onPointerMove = withBatchedUpdatesThrottled((event: PointerEvent) => {\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      this.handlePointerMoveOverScrollbars(event, pointerDownState);\n    });\n    const onPointerUp = withBatchedUpdates(() => {\n      lastPointerUp = null;\n      isDraggingScrollBar = false;\n      setCursorForShape(this.interactiveCanvas, this.state);\n      this.setState({\n        cursorButton: \"up\",\n      });\n      this.savePointer(event.clientX, event.clientY, \"up\");\n      window.removeEventListener(EVENT.POINTER_MOVE, onPointerMove);\n      window.removeEventListener(EVENT.POINTER_UP, onPointerUp);\n      onPointerMove.flush();\n    });\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(EVENT.POINTER_MOVE, onPointerMove);\n    window.addEventListener(EVENT.POINTER_UP, onPointerUp);\n    return true;\n  }\n\n  private clearSelectionIfNotUsingSelection = (): void => {\n    if (\n      this.state.activeTool.type !== \"selection\" &&\n      this.state.activeTool.type !== \"lasso\"\n    ) {\n      this.setState({\n        selectedElementIds: makeNextSelectedElementIds({}, this.state),\n        selectedGroupIds: {},\n        editingGroupId: null,\n        activeEmbeddable: null,\n      });\n    }\n  };\n\n  /**\n   * @returns whether the pointer event has been completely handled\n   */\n  private handleSelectionOnPointerDown = (\n    event: React.PointerEvent<HTMLElement>,\n    pointerDownState: PointerDownState,\n  ): boolean => {\n    if (this.state.activeTool.type === \"selection\") {\n      const elements = this.scene.getNonDeletedElements();\n      const elementsMap = this.scene.getNonDeletedElementsMap();\n      const selectedElements = this.scene.getSelectedElements(this.state);\n\n      if (\n        selectedElements.length === 1 &&\n        !this.state.editingLinearElement &&\n        !isElbowArrow(selectedElements[0]) &&\n        !(\n          this.state.selectedLinearElement &&\n          this.state.selectedLinearElement.hoverPointIndex !== -1\n        )\n      ) {\n        const elementWithTransformHandleType =\n          getElementWithTransformHandleType(\n            elements,\n            this.state,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n            this.state.zoom,\n            event.pointerType,\n            this.scene.getNonDeletedElementsMap(),\n            this.device,\n          );\n        if (elementWithTransformHandleType != null) {\n          if (\n            elementWithTransformHandleType.transformHandleType === \"rotation\"\n          ) {\n            this.setState({\n              resizingElement: elementWithTransformHandleType.element,\n            });\n            pointerDownState.resize.handleType =\n              elementWithTransformHandleType.transformHandleType;\n          } else if (this.state.croppingElementId) {\n            pointerDownState.resize.handleType =\n              elementWithTransformHandleType.transformHandleType;\n          } else {\n            this.setState({\n              resizingElement: elementWithTransformHandleType.element,\n            });\n            pointerDownState.resize.handleType =\n              elementWithTransformHandleType.transformHandleType;\n          }\n        }\n      } else if (selectedElements.length > 1) {\n        pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(\n          getCommonBounds(selectedElements),\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          this.state.zoom,\n          event.pointerType,\n          this.device,\n        );\n      }\n      if (pointerDownState.resize.handleType) {\n        pointerDownState.resize.isResizing = true;\n        pointerDownState.resize.offset = tupleToCoors(\n          getResizeOffsetXY(\n            pointerDownState.resize.handleType,\n            selectedElements,\n            elementsMap,\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n        if (\n          selectedElements.length === 1 &&\n          isLinearElement(selectedElements[0]) &&\n          selectedElements[0].points.length === 2\n        ) {\n          pointerDownState.resize.arrowDirection = getResizeArrowDirection(\n            pointerDownState.resize.handleType,\n            selectedElements[0],\n          );\n        }\n      } else {\n        if (this.state.selectedLinearElement) {\n          const linearElementEditor =\n            this.state.editingLinearElement || this.state.selectedLinearElement;\n          const ret = LinearElementEditor.handlePointerDown(\n            event,\n            this,\n            this.store,\n            pointerDownState.origin,\n            linearElementEditor,\n            this.scene,\n          );\n          if (ret.hitElement) {\n            pointerDownState.hit.element = ret.hitElement;\n          }\n          if (ret.linearElementEditor) {\n            this.setState({ selectedLinearElement: ret.linearElementEditor });\n\n            if (this.state.editingLinearElement) {\n              this.setState({ editingLinearElement: ret.linearElementEditor });\n            }\n          }\n          if (ret.didAddPoint) {\n            return true;\n          }\n        }\n\n        const allHitElements = this.getElementsAtPosition(\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          {\n            includeLockedElements: true,\n          },\n        );\n        const unlockedHitElements = allHitElements.filter((e) => !e.locked);\n\n        // Cannot set preferSelected in getElementAtPosition as we do in pointer move; consider:\n        // A & B: both unlocked, A selected, B on top, A & B overlaps in some way\n        // we want to select B when clicking on the overlapping area\n        const hitElementMightBeLocked = this.getElementAtPosition(\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n          {\n            allHitElements,\n          },\n        );\n\n        if (\n          !hitElementMightBeLocked ||\n          hitElementMightBeLocked.id !== this.state.activeLockedId\n        ) {\n          this.setState({\n            activeLockedId: null,\n          });\n        }\n\n        if (\n          hitElementMightBeLocked &&\n          hitElementMightBeLocked.locked &&\n          !unlockedHitElements.some(\n            (el) => this.state.selectedElementIds[el.id],\n          )\n        ) {\n          pointerDownState.hit.element = null;\n        } else {\n          // hitElement may already be set above, so check first\n          pointerDownState.hit.element =\n            pointerDownState.hit.element ??\n            this.getElementAtPosition(\n              pointerDownState.origin.x,\n              pointerDownState.origin.y,\n            );\n        }\n\n        this.hitLinkElement = this.getElementLinkAtPosition(\n          pointerDownState.origin,\n          hitElementMightBeLocked,\n        );\n\n        if (this.hitLinkElement) {\n          return true;\n        }\n\n        if (\n          this.state.croppingElementId &&\n          pointerDownState.hit.element?.id !== this.state.croppingElementId\n        ) {\n          this.finishImageCropping();\n        }\n\n        if (pointerDownState.hit.element) {\n          // Early return if pointer is hitting link icon\n          const hitLinkElement = this.getElementLinkAtPosition(\n            {\n              x: pointerDownState.origin.x,\n              y: pointerDownState.origin.y,\n            },\n            pointerDownState.hit.element,\n          );\n          if (hitLinkElement) {\n            return false;\n          }\n        }\n\n        // For overlapped elements one position may hit\n        // multiple elements\n        pointerDownState.hit.allHitElements = unlockedHitElements;\n\n        const hitElement = pointerDownState.hit.element;\n        const someHitElementIsSelected =\n          pointerDownState.hit.allHitElements.some((element) =>\n            this.isASelectedElement(element),\n          );\n        if (\n          (hitElement === null || !someHitElementIsSelected) &&\n          !event.shiftKey &&\n          !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n        ) {\n          this.clearSelection(hitElement);\n        }\n\n        if (this.state.editingLinearElement) {\n          this.setState({\n            selectedElementIds: makeNextSelectedElementIds(\n              {\n                [this.state.editingLinearElement.elementId]: true,\n              },\n              this.state,\n            ),\n          });\n          // If we click on something\n        } else if (hitElement != null) {\n          // == deep selection ==\n          // on CMD/CTRL, drill down to hit element regardless of groups etc.\n          if (event[KEYS.CTRL_OR_CMD]) {\n            if (event.altKey) {\n              // ctrl + alt means we're lasso selecting\n              return false;\n            }\n            if (!this.state.selectedElementIds[hitElement.id]) {\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n            this.setState((prevState) => ({\n              ...editGroupForSelectedElement(prevState, hitElement),\n              previousSelectedElementIds: this.state.selectedElementIds,\n            }));\n            // mark as not completely handled so as to allow dragging etc.\n            return false;\n          }\n\n          // deselect if item is selected\n          // if shift is not clicked, this will always return true\n          // otherwise, it will trigger selection based on current\n          // state of the box\n          if (!this.state.selectedElementIds[hitElement.id]) {\n            // if we are currently editing a group, exiting editing mode and deselect the group.\n            if (\n              this.state.editingGroupId &&\n              !isElementInGroup(hitElement, this.state.editingGroupId)\n            ) {\n              this.setState({\n                selectedElementIds: makeNextSelectedElementIds({}, this.state),\n                selectedGroupIds: {},\n                editingGroupId: null,\n                activeEmbeddable: null,\n              });\n            }\n\n            // Add hit element to selection. At this point if we're not holding\n            // SHIFT the previously selected element(s) were deselected above\n            // (make sure you use setState updater to use latest state)\n            // With shift-selection, we want to make sure that frames and their containing\n            // elements are not selected at the same time.\n            if (\n              !someHitElementIsSelected &&\n              !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements\n            ) {\n              this.setState((prevState) => {\n                let nextSelectedElementIds: { [id: string]: true } = {\n                  ...prevState.selectedElementIds,\n                  [hitElement.id]: true,\n                };\n\n                const previouslySelectedElements: ExcalidrawElement[] = [];\n\n                Object.keys(prevState.selectedElementIds).forEach((id) => {\n                  const element = this.scene.getElement(id);\n                  element && previouslySelectedElements.push(element);\n                });\n\n                // if hitElement is frame-like, deselect all of its elements\n                // if they are selected\n                if (isFrameLikeElement(hitElement)) {\n                  getFrameChildren(\n                    previouslySelectedElements,\n                    hitElement.id,\n                  ).forEach((element) => {\n                    delete nextSelectedElementIds[element.id];\n                  });\n                } else if (hitElement.frameId) {\n                  // if hitElement is in a frame and its frame has been selected\n                  // disable selection for the given element\n                  if (nextSelectedElementIds[hitElement.frameId]) {\n                    delete nextSelectedElementIds[hitElement.id];\n                  }\n                } else {\n                  // hitElement is neither a frame nor an element in a frame\n                  // but since hitElement could be in a group with some frames\n                  // this means selecting hitElement will have the frames selected as well\n                  // because we want to keep the invariant:\n                  // - frames and their elements are not selected at the same time\n                  // we deselect elements in those frames that were previously selected\n\n                  const groupIds = hitElement.groupIds;\n                  const framesInGroups = new Set(\n                    groupIds\n                      .flatMap((gid) =>\n                        getElementsInGroup(\n                          this.scene.getNonDeletedElements(),\n                          gid,\n                        ),\n                      )\n                      .filter((element) => isFrameLikeElement(element))\n                      .map((frame) => frame.id),\n                  );\n\n                  if (framesInGroups.size > 0) {\n                    previouslySelectedElements.forEach((element) => {\n                      if (\n                        element.frameId &&\n                        framesInGroups.has(element.frameId)\n                      ) {\n                        // deselect element and groups containing the element\n                        delete nextSelectedElementIds[element.id];\n                        element.groupIds\n                          .flatMap((gid) =>\n                            getElementsInGroup(\n                              this.scene.getNonDeletedElements(),\n                              gid,\n                            ),\n                          )\n                          .forEach((element) => {\n                            delete nextSelectedElementIds[element.id];\n                          });\n                      }\n                    });\n                  }\n                }\n\n                // Finally, in shape selection mode, we'd like to\n                // keep only one shape or group selected at a time.\n                // This means, if the hitElement is a different shape or group\n                // than the previously selected ones, we deselect the previous ones\n                // and select the hitElement\n                if (prevState.openDialog?.name === \"elementLinkSelector\") {\n                  if (\n                    !hitElement.groupIds.some(\n                      (gid) => prevState.selectedGroupIds[gid],\n                    )\n                  ) {\n                    nextSelectedElementIds = {\n                      [hitElement.id]: true,\n                    };\n                  }\n                }\n\n                return {\n                  ...selectGroupsForSelectedElements(\n                    {\n                      editingGroupId: prevState.editingGroupId,\n                      selectedElementIds: nextSelectedElementIds,\n                    },\n                    this.scene.getNonDeletedElements(),\n                    prevState,\n                    this,\n                  ),\n                  showHyperlinkPopup:\n                    hitElement.link || isEmbeddableElement(hitElement)\n                      ? \"info\"\n                      : false,\n                };\n              });\n              pointerDownState.hit.wasAddedToSelection = true;\n            }\n          }\n        }\n\n        this.setState({\n          previousSelectedElementIds: this.state.selectedElementIds,\n        });\n      }\n    }\n    return false;\n  };\n\n  private isASelectedElement(hitElement: ExcalidrawElement | null): boolean {\n    return hitElement != null && this.state.selectedElementIds[hitElement.id];\n  }\n\n  private isHittingCommonBoundingBoxOfSelectedElements(\n    point: Readonly<{ x: number; y: number }>,\n    selectedElements: readonly ExcalidrawElement[],\n  ): boolean {\n    if (selectedElements.length < 2) {\n      return false;\n    }\n\n    // How many pixels off the shape boundary we still consider a hit\n    const threshold = Math.max(\n      DEFAULT_COLLISION_THRESHOLD / this.state.zoom.value,\n      1,\n    );\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    return (\n      point.x > x1 - threshold &&\n      point.x < x2 + threshold &&\n      point.y > y1 - threshold &&\n      point.y < y2 + threshold\n    );\n  }\n\n  private handleTextOnPointerDown = (\n    event: React.PointerEvent<HTMLElement>,\n    pointerDownState: PointerDownState,\n  ): void => {\n    // if we're currently still editing text, clicking outside\n    // should only finalize it, not create another (irrespective\n    // of state.activeTool.locked)\n    if (this.state.editingTextElement) {\n      return;\n    }\n    let sceneX = pointerDownState.origin.x;\n    let sceneY = pointerDownState.origin.y;\n\n    const element = this.getElementAtPosition(sceneX, sceneY, {\n      includeBoundTextElement: true,\n    });\n\n    // FIXME\n    let container = this.getTextBindableContainerAtPosition(sceneX, sceneY);\n\n    if (hasBoundTextElement(element)) {\n      container = element as ExcalidrawTextContainer;\n      sceneX = element.x + element.width / 2;\n      sceneY = element.y + element.height / 2;\n    }\n    this.startTextEditing({\n      sceneX,\n      sceneY,\n      insertAtParentCenter: !event.altKey,\n      container,\n      autoEdit: false,\n    });\n\n    resetCursor(this.interactiveCanvas);\n    if (!this.state.activeTool.locked) {\n      this.setState({\n        activeTool: updateActiveTool(this.state, { type: \"selection\" }),\n      });\n    }\n  };\n\n  private handleFreeDrawElementOnPointerDown = (\n    event: React.PointerEvent<HTMLElement>,\n    elementType: ExcalidrawFreeDrawElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ) => {\n    // Begin a mark capture. This does not have to update state yet.\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      null,\n    );\n\n    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n      x: gridX,\n      y: gridY,\n    });\n\n    const simulatePressure = event.pressure === 0.5;\n\n    const element = newFreeDrawElement({\n      type: elementType,\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      roundness: null,\n      simulatePressure,\n      locked: false,\n      frameId: topLayerFrame ? topLayerFrame.id : null,\n      points: [pointFrom<LocalPoint>(0, 0)],\n      pressures: simulatePressure ? [] : [event.pressure],\n    });\n\n    this.scene.insertElement(element);\n\n    this.setState((prevState) => {\n      const nextSelectedElementIds = {\n        ...prevState.selectedElementIds,\n      };\n      delete nextSelectedElementIds[element.id];\n      return {\n        selectedElementIds: makeNextSelectedElementIds(\n          nextSelectedElementIds,\n          prevState,\n        ),\n      };\n    });\n\n    const boundElement = getHoveredElementForBinding(\n      pointerDownState.origin,\n      this.scene.getNonDeletedElements(),\n      this.scene.getNonDeletedElementsMap(),\n      this.state.zoom,\n    );\n\n    this.setState({\n      newElement: element,\n      startBoundElement: boundElement,\n      suggestedBindings: [],\n    });\n  };\n\n  public insertIframeElement = ({\n    sceneX,\n    sceneY,\n    width,\n    height,\n  }: {\n    sceneX: number;\n    sceneY: number;\n    width: number;\n    height: number;\n  }) => {\n    const [gridX, gridY] = getGridPoint(\n      sceneX,\n      sceneY,\n      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD]\n        ? null\n        : this.getEffectiveGridSize(),\n    );\n\n    const element = newIframeElement({\n      type: \"iframe\",\n      x: gridX,\n      y: gridY,\n      strokeColor: \"transparent\",\n      backgroundColor: \"transparent\",\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      roundness: this.getCurrentItemRoundness(\"iframe\"),\n      opacity: this.state.currentItemOpacity,\n      locked: false,\n      width,\n      height,\n    });\n\n    this.scene.insertElement(element);\n\n    return element;\n  };\n\n  //create rectangle element with youtube top left on nearest grid point width / hight 640/360\n  public insertEmbeddableElement = ({\n    sceneX,\n    sceneY,\n    link,\n  }: {\n    sceneX: number;\n    sceneY: number;\n    link: string;\n  }) => {\n    const [gridX, gridY] = getGridPoint(\n      sceneX,\n      sceneY,\n      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD]\n        ? null\n        : this.getEffectiveGridSize(),\n    );\n\n    const embedLink = getEmbedLink(link);\n\n    if (!embedLink) {\n      return;\n    }\n\n    if (embedLink.error instanceof URIError) {\n      this.setToast({\n        message: t(\"toast.unrecognizedLinkFormat\"),\n        closable: true,\n      });\n    }\n\n    const element = newEmbeddableElement({\n      type: \"embeddable\",\n      x: gridX,\n      y: gridY,\n      strokeColor: \"transparent\",\n      backgroundColor: \"transparent\",\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      roundness: this.getCurrentItemRoundness(\"embeddable\"),\n      opacity: this.state.currentItemOpacity,\n      locked: false,\n      width: embedLink.intrinsicSize.w,\n      height: embedLink.intrinsicSize.h,\n      link,\n    });\n\n    this.scene.insertElement(element);\n\n    return element;\n  };\n\n  private createImageElement = async ({\n    sceneX,\n    sceneY,\n    addToFrameUnderCursor = true,\n    imageFile,\n  }: {\n    sceneX: number;\n    sceneY: number;\n    addToFrameUnderCursor?: boolean;\n    imageFile: File;\n  }) => {\n    const [gridX, gridY] = getGridPoint(\n      sceneX,\n      sceneY,\n      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD]\n        ? null\n        : this.getEffectiveGridSize(),\n    );\n\n    const topLayerFrame = addToFrameUnderCursor\n      ? this.getTopLayerFrameAtSceneCoords({\n          x: gridX,\n          y: gridY,\n        })\n      : null;\n\n    const placeholderSize = 100 / this.state.zoom.value;\n\n    const placeholderImageElement = newImageElement({\n      type: \"image\",\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      roundness: null,\n      opacity: this.state.currentItemOpacity,\n      locked: false,\n      frameId: topLayerFrame ? topLayerFrame.id : null,\n      x: gridX - placeholderSize / 2,\n      y: gridY - placeholderSize / 2,\n      width: placeholderSize,\n      height: placeholderSize,\n    });\n\n    const initializedImageElement = await this.insertImageElement(\n      placeholderImageElement,\n      imageFile,\n    );\n\n    return initializedImageElement;\n  };\n\n  private handleLinearElementOnPointerDown = (\n    event: React.PointerEvent<HTMLElement>,\n    elementType: ExcalidrawLinearElement[\"type\"],\n    pointerDownState: PointerDownState,\n  ): void => {\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n\n      // finalize if completing a loop\n      if (\n        multiElement.type === \"line\" &&\n        isPathALoop(multiElement.points, this.state.zoom.value)\n      ) {\n        this.scene.mutateElement(multiElement, {\n          lastCommittedPoint:\n            multiElement.points[multiElement.points.length - 1],\n        });\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      // Elbow arrows cannot be created by putting down points\n      // only the start and end points can be defined\n      if (isElbowArrow(multiElement) && multiElement.points.length > 1) {\n        this.scene.mutateElement(multiElement, {\n          lastCommittedPoint:\n            multiElement.points[multiElement.points.length - 1],\n        });\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      const { x: rx, y: ry, lastCommittedPoint } = multiElement;\n\n      // clicking inside commit zone → finalize arrow\n      if (\n        multiElement.points.length > 1 &&\n        lastCommittedPoint &&\n        pointDistance(\n          pointFrom(\n            pointerDownState.origin.x - rx,\n            pointerDownState.origin.y - ry,\n          ),\n          lastCommittedPoint,\n        ) < LINE_CONFIRM_THRESHOLD\n      ) {\n        this.actionManager.executeAction(actionFinalize);\n        return;\n      }\n\n      this.setState((prevState) => ({\n        selectedElementIds: makeNextSelectedElementIds(\n          {\n            ...prevState.selectedElementIds,\n            [multiElement.id]: true,\n          },\n          prevState,\n        ),\n      }));\n      // clicking outside commit zone → update reference for last committed\n      // point\n      this.scene.mutateElement(multiElement, {\n        lastCommittedPoint: multiElement.points[multiElement.points.length - 1],\n      });\n      setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);\n    } else {\n      const [gridX, gridY] = getGridPoint(\n        pointerDownState.origin.x,\n        pointerDownState.origin.y,\n        event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize(),\n      );\n\n      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n        x: gridX,\n        y: gridY,\n      });\n\n      /* If arrow is pre-arrowheads, it will have undefined for both start and end arrowheads.\n      If so, we want it to be null for start and \"arrow\" for end. If the linear item is not\n      an arrow, we want it to be null for both. Otherwise, we want it to use the\n      values from appState. */\n\n      const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;\n      const [startArrowhead, endArrowhead] =\n        elementType === \"arrow\"\n          ? [currentItemStartArrowhead, currentItemEndArrowhead]\n          : [null, null];\n\n      const element =\n        elementType === \"arrow\"\n          ? newArrowElement({\n              type: elementType,\n              x: gridX,\n              y: gridY,\n              strokeColor: this.state.currentItemStrokeColor,\n              backgroundColor: this.state.currentItemBackgroundColor,\n              fillStyle: this.state.currentItemFillStyle,\n              strokeWidth: this.state.currentItemStrokeWidth,\n              strokeStyle: this.state.currentItemStrokeStyle,\n              roughness: this.state.currentItemRoughness,\n              opacity: this.state.currentItemOpacity,\n              roundness:\n                this.state.currentItemArrowType === ARROW_TYPE.round\n                  ? { type: ROUNDNESS.PROPORTIONAL_RADIUS }\n                  : // note, roundness doesn't have any effect for elbow arrows,\n                    // but it's best to set it to null as well\n                    null,\n              startArrowhead,\n              endArrowhead,\n              locked: false,\n              frameId: topLayerFrame ? topLayerFrame.id : null,\n              elbowed: this.state.currentItemArrowType === ARROW_TYPE.elbow,\n              fixedSegments:\n                this.state.currentItemArrowType === ARROW_TYPE.elbow\n                  ? []\n                  : null,\n            })\n          : newLinearElement({\n              type: elementType,\n              x: gridX,\n              y: gridY,\n              strokeColor: this.state.currentItemStrokeColor,\n              backgroundColor: this.state.currentItemBackgroundColor,\n              fillStyle: this.state.currentItemFillStyle,\n              strokeWidth: this.state.currentItemStrokeWidth,\n              strokeStyle: this.state.currentItemStrokeStyle,\n              roughness: this.state.currentItemRoughness,\n              opacity: this.state.currentItemOpacity,\n              roundness:\n                this.state.currentItemRoundness === \"round\"\n                  ? { type: ROUNDNESS.PROPORTIONAL_RADIUS }\n                  : null,\n              locked: false,\n              frameId: topLayerFrame ? topLayerFrame.id : null,\n            });\n      this.setState((prevState) => {\n        const nextSelectedElementIds = {\n          ...prevState.selectedElementIds,\n        };\n        delete nextSelectedElementIds[element.id];\n        return {\n          selectedElementIds: makeNextSelectedElementIds(\n            nextSelectedElementIds,\n            prevState,\n          ),\n        };\n      });\n      this.scene.mutateElement(element, {\n        points: [...element.points, pointFrom<LocalPoint>(0, 0)],\n      });\n      const boundElement = getHoveredElementForBinding(\n        pointerDownState.origin,\n        this.scene.getNonDeletedElements(),\n        this.scene.getNonDeletedElementsMap(),\n        this.state.zoom,\n        isElbowArrow(element),\n        isElbowArrow(element),\n      );\n\n      this.scene.insertElement(element);\n      this.setState({\n        newElement: element,\n        startBoundElement: boundElement,\n        suggestedBindings: [],\n      });\n    }\n  };\n\n  private getCurrentItemRoundness(\n    elementType:\n      | \"selection\"\n      | \"rectangle\"\n      | \"diamond\"\n      | \"ellipse\"\n      | \"iframe\"\n      | \"embeddable\",\n  ) {\n    return this.state.currentItemRoundness === \"round\"\n      ? {\n          type: isUsingAdaptiveRadius(elementType)\n            ? ROUNDNESS.ADAPTIVE_RADIUS\n            : ROUNDNESS.PROPORTIONAL_RADIUS,\n        }\n      : null;\n  }\n\n  private createGenericElementOnPointerDown = (\n    elementType: ExcalidrawGenericElement[\"type\"] | \"embeddable\",\n    pointerDownState: PointerDownState,\n  ): void => {\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD]\n        ? null\n        : this.getEffectiveGridSize(),\n    );\n\n    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({\n      x: gridX,\n      y: gridY,\n    });\n\n    const baseElementAttributes = {\n      x: gridX,\n      y: gridY,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      strokeStyle: this.state.currentItemStrokeStyle,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      roundness: this.getCurrentItemRoundness(elementType),\n      locked: false,\n      frameId: topLayerFrame ? topLayerFrame.id : null,\n    } as const;\n\n    let element;\n    if (elementType === \"embeddable\") {\n      element = newEmbeddableElement({\n        type: \"embeddable\",\n        ...baseElementAttributes,\n      });\n    } else {\n      element = newElement({\n        type: elementType,\n        ...baseElementAttributes,\n      });\n    }\n\n    if (element.type === \"selection\") {\n      this.setState({\n        selectionElement: element,\n      });\n    } else {\n      this.scene.insertElement(element);\n      this.setState({\n        multiElement: null,\n        newElement: element,\n      });\n    }\n  };\n\n  private createFrameElementOnPointerDown = (\n    pointerDownState: PointerDownState,\n    type: Extract<ToolType, \"frame\" | \"magicframe\">,\n  ): void => {\n    const [gridX, gridY] = getGridPoint(\n      pointerDownState.origin.x,\n      pointerDownState.origin.y,\n      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD]\n        ? null\n        : this.getEffectiveGridSize(),\n    );\n\n    const constructorOpts = {\n      x: gridX,\n      y: gridY,\n      opacity: this.state.currentItemOpacity,\n      locked: false,\n      ...FRAME_STYLE,\n    } as const;\n\n    const frame =\n      type === TOOL_TYPE.magicframe\n        ? newMagicFrameElement(constructorOpts)\n        : newFrameElement(constructorOpts);\n\n    this.scene.insertElement(frame);\n\n    this.setState({\n      multiElement: null,\n      newElement: frame,\n    });\n  };\n\n  private maybeCacheReferenceSnapPoints(\n    event: KeyboardModifiersObject,\n    selectedElements: ExcalidrawElement[],\n    recomputeAnyways: boolean = false,\n  ) {\n    if (\n      isSnappingEnabled({\n        event,\n        app: this,\n        selectedElements,\n      }) &&\n      (recomputeAnyways || !SnapCache.getReferenceSnapPoints())\n    ) {\n      SnapCache.setReferenceSnapPoints(\n        getReferenceSnapPoints(\n          this.scene.getNonDeletedElements(),\n          selectedElements,\n          this.state,\n          this.scene.getNonDeletedElementsMap(),\n        ),\n      );\n    }\n  }\n\n  private maybeCacheVisibleGaps(\n    event: KeyboardModifiersObject,\n    selectedElements: ExcalidrawElement[],\n    recomputeAnyways: boolean = false,\n  ) {\n    if (\n      isSnappingEnabled({\n        event,\n        app: this,\n        selectedElements,\n      }) &&\n      (recomputeAnyways || !SnapCache.getVisibleGaps())\n    ) {\n      SnapCache.setVisibleGaps(\n        getVisibleGaps(\n          this.scene.getNonDeletedElements(),\n          selectedElements,\n          this.state,\n          this.scene.getNonDeletedElementsMap(),\n        ),\n      );\n    }\n  }\n\n  private onKeyDownFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onKeyUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: KeyboardEvent) => void {\n    return withBatchedUpdates((event: KeyboardEvent) => {\n      // Prevents focus from escaping excalidraw tab\n      event.key === KEYS.ALT && event.preventDefault();\n      if (this.maybeHandleResize(pointerDownState, event)) {\n        return;\n      }\n      this.maybeDragNewGenericElement(pointerDownState, event);\n    });\n  }\n\n  private onPointerMoveFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ) {\n    return withBatchedUpdatesThrottled((event: PointerEvent) => {\n      if (this.state.openDialog?.name === \"elementLinkSelector\") {\n        return;\n      }\n      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);\n\n      if (this.state.activeLockedId) {\n        this.setState({\n          activeLockedId: null,\n        });\n      }\n\n      if (\n        this.state.selectedLinearElement &&\n        this.state.selectedLinearElement.elbowed &&\n        this.state.selectedLinearElement.pointerDownState.segmentMidpoint.index\n      ) {\n        const [gridX, gridY] = getGridPoint(\n          pointerCoords.x,\n          pointerCoords.y,\n          event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize(),\n        );\n\n        let index =\n          this.state.selectedLinearElement.pointerDownState.segmentMidpoint\n            .index;\n        if (index < 0) {\n          const nextCoords = LinearElementEditor.getSegmentMidpointHitCoords(\n            {\n              ...this.state.selectedLinearElement,\n              segmentMidPointHoveredCoords: null,\n            },\n            { x: gridX, y: gridY },\n            this.state,\n            this.scene.getNonDeletedElementsMap(),\n          );\n          index = nextCoords\n            ? LinearElementEditor.getSegmentMidPointIndex(\n                this.state.selectedLinearElement,\n                this.state,\n                nextCoords,\n                this.scene.getNonDeletedElementsMap(),\n              )\n            : -1;\n        }\n\n        const ret = LinearElementEditor.moveFixedSegment(\n          this.state.selectedLinearElement,\n          index,\n          gridX,\n          gridY,\n          this.scene,\n        );\n\n        flushSync(() => {\n          if (this.state.selectedLinearElement) {\n            this.setState({\n              selectedLinearElement: {\n                ...this.state.selectedLinearElement,\n                segmentMidPointHoveredCoords: ret.segmentMidPointHoveredCoords,\n                pointerDownState: ret.pointerDownState,\n              },\n            });\n          }\n        });\n        return;\n      }\n\n      const lastPointerCoords =\n        this.lastPointerMoveCoords ?? pointerDownState.origin;\n      this.lastPointerMoveCoords = pointerCoords;\n\n      // We need to initialize dragOffsetXY only after we've updated\n      // `state.selectedElementIds` on pointerDown. Doing it here in pointerMove\n      // event handler should hopefully ensure we're already working with\n      // the updated state.\n      if (pointerDownState.drag.offset === null) {\n        pointerDownState.drag.offset = tupleToCoors(\n          getDragOffsetXY(\n            this.scene.getSelectedElements(this.state),\n            pointerDownState.origin.x,\n            pointerDownState.origin.y,\n          ),\n        );\n      }\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {\n        return;\n      }\n\n      if (isEraserActive(this.state)) {\n        this.handleEraser(event, pointerCoords);\n        return;\n      }\n\n      if (this.state.activeTool.type === \"laser\") {\n        this.laserTrails.addPointToPath(pointerCoords.x, pointerCoords.y);\n      }\n\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize(),\n      );\n\n      // for arrows/lines, don't start dragging until a given threshold\n      // to ensure we don't create a 2-point arrow by mistake when\n      // user clicks mouse in a way that it moves a tiny bit (thus\n      // triggering pointermove)\n      if (\n        !pointerDownState.drag.hasOccurred &&\n        (this.state.activeTool.type === \"arrow\" ||\n          this.state.activeTool.type === \"line\")\n      ) {\n        if (\n          pointDistance(\n            pointFrom(pointerCoords.x, pointerCoords.y),\n            pointFrom(pointerDownState.origin.x, pointerDownState.origin.y),\n          ) < DRAGGING_THRESHOLD\n        ) {\n          return;\n        }\n      }\n      if (pointerDownState.resize.isResizing) {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        if (this.maybeHandleCrop(pointerDownState, event)) {\n          return true;\n        }\n        if (this.maybeHandleResize(pointerDownState, event)) {\n          return true;\n        }\n      }\n      const elementsMap = this.scene.getNonDeletedElementsMap();\n\n      if (this.state.selectedLinearElement) {\n        const linearElementEditor =\n          this.state.editingLinearElement || this.state.selectedLinearElement;\n\n        if (\n          LinearElementEditor.shouldAddMidpoint(\n            this.state.selectedLinearElement,\n            pointerCoords,\n            this.state,\n            elementsMap,\n          )\n        ) {\n          const ret = LinearElementEditor.addMidpoint(\n            this.state.selectedLinearElement,\n            pointerCoords,\n            this,\n            !event[KEYS.CTRL_OR_CMD],\n            this.scene,\n          );\n          if (!ret) {\n            return;\n          }\n\n          // Since we are reading from previous state which is not possible with\n          // automatic batching in React 18 hence using flush sync to synchronously\n          // update the state. Check https://github.com/excalidraw/excalidraw/pull/5508 for more details.\n\n          flushSync(() => {\n            if (this.state.selectedLinearElement) {\n              this.setState({\n                selectedLinearElement: {\n                  ...this.state.selectedLinearElement,\n                  pointerDownState: ret.pointerDownState,\n                  selectedPointsIndices: ret.selectedPointsIndices,\n                  segmentMidPointHoveredCoords: null,\n                },\n              });\n            }\n            if (this.state.editingLinearElement) {\n              this.setState({\n                editingLinearElement: {\n                  ...this.state.editingLinearElement,\n                  pointerDownState: ret.pointerDownState,\n                  selectedPointsIndices: ret.selectedPointsIndices,\n                  segmentMidPointHoveredCoords: null,\n                },\n              });\n            }\n          });\n\n          return;\n        } else if (\n          linearElementEditor.pointerDownState.segmentMidpoint.value !== null &&\n          !linearElementEditor.pointerDownState.segmentMidpoint.added\n        ) {\n          return;\n        }\n\n        const newState = LinearElementEditor.handlePointDragging(\n          event,\n          this,\n          pointerCoords.x,\n          pointerCoords.y,\n          linearElementEditor,\n        );\n        if (newState) {\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          pointerDownState.drag.hasOccurred = true;\n\n          this.setState(newState);\n\n          return;\n        }\n      }\n\n      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(\n        (element) => this.isASelectedElement(element),\n      );\n\n      const isSelectingPointsInLineEditor =\n        this.state.editingLinearElement &&\n        event.shiftKey &&\n        this.state.editingLinearElement.elementId ===\n          pointerDownState.hit.element?.id;\n      if (\n        (hasHitASelectedElement ||\n          pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) &&\n        !isSelectingPointsInLineEditor &&\n        this.state.activeTool.type !== \"lasso\"\n      ) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n\n        if (selectedElements.every((element) => element.locked)) {\n          return;\n        }\n\n        const selectedElementsHasAFrame = selectedElements.find((e) =>\n          isFrameLikeElement(e),\n        );\n        const topLayerFrame = this.getTopLayerFrameAtSceneCoords(pointerCoords);\n        const frameToHighlight =\n          topLayerFrame && !selectedElementsHasAFrame ? topLayerFrame : null;\n        // Only update the state if there is a difference\n        if (this.state.frameToHighlight !== frameToHighlight) {\n          flushSync(() => {\n            this.setState({ frameToHighlight });\n          });\n        }\n\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        pointerDownState.drag.hasOccurred = true;\n\n        // prevent dragging even if we're no longer holding cmd/ctrl otherwise\n        // it would have weird results (stuff jumping all over the screen)\n        // Checking for editingTextElement to avoid jump while editing on mobile #6503\n        if (\n          selectedElements.length > 0 &&\n          !pointerDownState.withCmdOrCtrl &&\n          !this.state.editingTextElement &&\n          this.state.activeEmbeddable?.state !== \"active\"\n        ) {\n          const dragOffset = {\n            x: pointerCoords.x - pointerDownState.drag.origin.x,\n            y: pointerCoords.y - pointerDownState.drag.origin.y,\n          };\n\n          const originalElements = [\n            ...pointerDownState.originalElements.values(),\n          ];\n\n          // We only drag in one direction if shift is pressed\n          const lockDirection = event.shiftKey;\n\n          if (lockDirection) {\n            const distanceX = Math.abs(dragOffset.x);\n            const distanceY = Math.abs(dragOffset.y);\n\n            const lockX = lockDirection && distanceX < distanceY;\n            const lockY = lockDirection && distanceX > distanceY;\n\n            if (lockX) {\n              dragOffset.x = 0;\n            }\n\n            if (lockY) {\n              dragOffset.y = 0;\n            }\n          }\n\n          // #region move crop region\n          if (this.state.croppingElementId) {\n            const croppingElement = this.scene\n              .getNonDeletedElementsMap()\n              .get(this.state.croppingElementId);\n\n            if (\n              croppingElement &&\n              isImageElement(croppingElement) &&\n              croppingElement.crop !== null &&\n              pointerDownState.hit.element === croppingElement\n            ) {\n              const crop = croppingElement.crop;\n              const image =\n                isInitializedImageElement(croppingElement) &&\n                this.imageCache.get(croppingElement.fileId)?.image;\n\n              if (image && !(image instanceof Promise)) {\n                const instantDragOffset = vectorScale(\n                  vector(\n                    pointerCoords.x - lastPointerCoords.x,\n                    pointerCoords.y - lastPointerCoords.y,\n                  ),\n                  Math.max(this.state.zoom.value, 2),\n                );\n\n                const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n                  croppingElement,\n                  elementsMap,\n                );\n\n                const topLeft = vectorFromPoint(\n                  pointRotateRads(\n                    pointFrom(x1, y1),\n                    pointFrom(cx, cy),\n                    croppingElement.angle,\n                  ),\n                );\n                const topRight = vectorFromPoint(\n                  pointRotateRads(\n                    pointFrom(x2, y1),\n                    pointFrom(cx, cy),\n                    croppingElement.angle,\n                  ),\n                );\n                const bottomLeft = vectorFromPoint(\n                  pointRotateRads(\n                    pointFrom(x1, y2),\n                    pointFrom(cx, cy),\n                    croppingElement.angle,\n                  ),\n                );\n                const topEdge = vectorNormalize(\n                  vectorSubtract(topRight, topLeft),\n                );\n                const leftEdge = vectorNormalize(\n                  vectorSubtract(bottomLeft, topLeft),\n                );\n\n                // project instantDrafOffset onto leftEdge and topEdge to decompose\n                const offsetVector = vector(\n                  vectorDot(instantDragOffset, topEdge),\n                  vectorDot(instantDragOffset, leftEdge),\n                );\n\n                const nextCrop = {\n                  ...crop,\n                  x: clamp(\n                    crop.x -\n                      offsetVector[0] * Math.sign(croppingElement.scale[0]),\n                    0,\n                    image.naturalWidth - crop.width,\n                  ),\n                  y: clamp(\n                    crop.y -\n                      offsetVector[1] * Math.sign(croppingElement.scale[1]),\n                    0,\n                    image.naturalHeight - crop.height,\n                  ),\n                };\n\n                this.scene.mutateElement(croppingElement, {\n                  crop: nextCrop,\n                });\n\n                return;\n              }\n            }\n          }\n\n          // Snap cache *must* be synchronously popuplated before initial drag,\n          // otherwise the first drag even will not snap, causing a jump before\n          // it snaps to its position if previously snapped already.\n          this.maybeCacheVisibleGaps(event, selectedElements);\n          this.maybeCacheReferenceSnapPoints(event, selectedElements);\n\n          const { snapOffset, snapLines } = snapDraggedElements(\n            originalElements,\n            dragOffset,\n            this,\n            event,\n            this.scene.getNonDeletedElementsMap(),\n          );\n\n          this.setState({ snapLines });\n\n          // when we're editing the name of a frame, we want the user to be\n          // able to select and interact with the text input\n          if (!this.state.editingFrame) {\n            dragSelectedElements(\n              pointerDownState,\n              selectedElements,\n              dragOffset,\n              this.scene,\n              snapOffset,\n              event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize(),\n            );\n          }\n\n          this.setState({\n            selectedElementsAreBeingDragged: true,\n            // element is being dragged and selectionElement that was created on pointer down\n            // should be removed\n            selectionElement: null,\n          });\n\n          if (\n            selectedElements.length !== 1 ||\n            !isElbowArrow(selectedElements[0])\n          ) {\n            this.setState({\n              suggestedBindings: getSuggestedBindingsForArrows(\n                selectedElements,\n                this.scene.getNonDeletedElementsMap(),\n                this.state.zoom,\n              ),\n            });\n          }\n\n          // We duplicate the selected element if alt is pressed on pointer move\n          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            // (the origin point where the dragging started)\n\n            pointerDownState.hit.hasBeenDuplicated = true;\n\n            const elements = this.scene.getElementsIncludingDeleted();\n            const hitElement = pointerDownState.hit.element;\n            const selectedElements = this.scene.getSelectedElements({\n              selectedElementIds: this.state.selectedElementIds,\n              includeBoundTextElement: true,\n              includeElementsInFrames: true,\n            });\n            if (\n              hitElement &&\n              // hit element may not end up being selected\n              // if we're alt-dragging a common bounding box\n              // over the hit element\n              pointerDownState.hit.wasAddedToSelection &&\n              !selectedElements.find((el) => el.id === hitElement.id)\n            ) {\n              selectedElements.push(hitElement);\n            }\n\n            const idsOfElementsToDuplicate = new Map(\n              selectedElements.map((el) => [el.id, el]),\n            );\n\n            const {\n              duplicatedElements,\n              duplicateElementsMap,\n              elementsWithDuplicates,\n              origIdToDuplicateId,\n            } = duplicateElements({\n              type: \"in-place\",\n              elements,\n              appState: this.state,\n              randomizeSeed: true,\n              idsOfElementsToDuplicate,\n              overrides: ({ duplicateElement, origElement }) => {\n                return {\n                  // reset to the original element's frameId (unless we've\n                  // duplicated alongside a frame in which case we need to\n                  // keep the duplicate frame's id) so that the element\n                  // frame membership is refreshed on pointerup\n                  // NOTE this is a hacky solution and should be done\n                  // differently\n                  frameId: duplicateElement.frameId ?? origElement.frameId,\n                  seed: randomInteger(),\n                };\n              },\n            });\n            duplicatedElements.forEach((element) => {\n              pointerDownState.originalElements.set(\n                element.id,\n                deepCopyElement(element),\n              );\n            });\n\n            const mappedClonedElements = elementsWithDuplicates.map((el) => {\n              if (idsOfElementsToDuplicate.has(el.id)) {\n                const origEl = pointerDownState.originalElements.get(el.id);\n\n                if (origEl) {\n                  return newElementWith(el, {\n                    x: origEl.x,\n                    y: origEl.y,\n                  });\n                }\n              }\n              return el;\n            });\n\n            const mappedNewSceneElements = this.props.onDuplicate?.(\n              mappedClonedElements,\n              elements,\n            );\n\n            const elementsWithIndices = syncMovedIndices(\n              mappedNewSceneElements || mappedClonedElements,\n              arrayToMap(duplicatedElements),\n            );\n\n            // we need to update synchronously so as to keep pointerDownState,\n            // appState, and scene elements in sync\n            flushSync(() => {\n              // swap hit element with the duplicated one\n              if (pointerDownState.hit.element) {\n                const cloneId = origIdToDuplicateId.get(\n                  pointerDownState.hit.element.id,\n                );\n                const clonedElement =\n                  cloneId && duplicateElementsMap.get(cloneId);\n                pointerDownState.hit.element = clonedElement || null;\n              }\n              // swap hit elements with the duplicated ones\n              pointerDownState.hit.allHitElements =\n                pointerDownState.hit.allHitElements.reduce(\n                  (\n                    acc: typeof pointerDownState.hit.allHitElements,\n                    origHitElement,\n                  ) => {\n                    const cloneId = origIdToDuplicateId.get(origHitElement.id);\n                    const clonedElement =\n                      cloneId && duplicateElementsMap.get(cloneId);\n                    if (clonedElement) {\n                      acc.push(clonedElement);\n                    }\n\n                    return acc;\n                  },\n                  [],\n                );\n\n              // update drag origin to the position at which we started\n              // the duplication so that the drag offset is correct\n              pointerDownState.drag.origin = viewportCoordsToSceneCoords(\n                event,\n                this.state,\n              );\n\n              // switch selected elements to the duplicated ones\n              this.setState((prevState) => ({\n                ...getSelectionStateForElements(\n                  duplicatedElements,\n                  this.scene.getNonDeletedElements(),\n                  prevState,\n                ),\n              }));\n\n              this.scene.replaceAllElements(elementsWithIndices);\n              this.maybeCacheVisibleGaps(event, selectedElements, true);\n              this.maybeCacheReferenceSnapPoints(event, selectedElements, true);\n            });\n          }\n\n          return;\n        }\n      }\n\n      if (this.state.selectionElement) {\n        pointerDownState.lastCoords.x = pointerCoords.x;\n        pointerDownState.lastCoords.y = pointerCoords.y;\n        if (event.altKey) {\n          flushSync(() => {\n            this.setActiveTool(\n              { type: \"lasso\", fromSelection: true },\n              event.shiftKey,\n            );\n            this.lassoTrail.startPath(\n              pointerDownState.origin.x,\n              pointerDownState.origin.y,\n              event.shiftKey,\n            );\n            this.setAppState({\n              selectionElement: null,\n            });\n          });\n        } else {\n          this.maybeDragNewGenericElement(pointerDownState, event);\n        }\n      } else if (this.state.activeTool.type === \"lasso\") {\n        if (!event.altKey && this.state.activeTool.fromSelection) {\n          this.setActiveTool({ type: \"selection\" });\n          this.createGenericElementOnPointerDown(\"selection\", pointerDownState);\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          this.maybeDragNewGenericElement(pointerDownState, event);\n          this.lassoTrail.endPath();\n        } else {\n          this.lassoTrail.addPointToPath(\n            pointerCoords.x,\n            pointerCoords.y,\n            event.shiftKey,\n          );\n        }\n      } else {\n        // It is very important to read this.state within each move event,\n        // otherwise we would read a stale one!\n        const newElement = this.state.newElement;\n\n        if (!newElement) {\n          return;\n        }\n\n        if (newElement.type === \"freedraw\") {\n          const points = newElement.points;\n          const dx = pointerCoords.x - newElement.x;\n          const dy = pointerCoords.y - newElement.y;\n\n          const lastPoint = points.length > 0 && points[points.length - 1];\n          const discardPoint =\n            lastPoint && lastPoint[0] === dx && lastPoint[1] === dy;\n\n          if (!discardPoint) {\n            const pressures = newElement.simulatePressure\n              ? newElement.pressures\n              : [...newElement.pressures, event.pressure];\n\n            this.scene.mutateElement(\n              newElement,\n              {\n                points: [...points, pointFrom<LocalPoint>(dx, dy)],\n                pressures,\n              },\n              {\n                informMutation: false,\n                isDragging: false,\n              },\n            );\n\n            this.setState({\n              newElement,\n            });\n          }\n        } else if (isLinearElement(newElement)) {\n          pointerDownState.drag.hasOccurred = true;\n          const points = newElement.points;\n          let dx = gridX - newElement.x;\n          let dy = gridY - newElement.y;\n\n          if (shouldRotateWithDiscreteAngle(event) && points.length === 2) {\n            ({ width: dx, height: dy } = getLockedLinearCursorAlignSize(\n              newElement.x,\n              newElement.y,\n              pointerCoords.x,\n              pointerCoords.y,\n            ));\n          }\n\n          if (points.length === 1) {\n            this.scene.mutateElement(\n              newElement,\n              {\n                points: [...points, pointFrom<LocalPoint>(dx, dy)],\n              },\n              { informMutation: false, isDragging: false },\n            );\n          } else if (\n            points.length === 2 ||\n            (points.length > 1 && isElbowArrow(newElement))\n          ) {\n            this.scene.mutateElement(\n              newElement,\n              {\n                points: [...points.slice(0, -1), pointFrom<LocalPoint>(dx, dy)],\n              },\n              { isDragging: true, informMutation: false },\n            );\n          }\n\n          this.setState({\n            newElement,\n          });\n\n          if (isBindingElement(newElement, false)) {\n            // When creating a linear element by dragging\n            this.setState({\n              suggestedBindings: maybeSuggestBindingsForLinearElementAtCoords(\n                newElement,\n                [pointerCoords],\n                this.scene,\n                this.state.zoom,\n                this.state.startBoundElement,\n              ),\n            });\n          }\n        } else {\n          pointerDownState.lastCoords.x = pointerCoords.x;\n          pointerDownState.lastCoords.y = pointerCoords.y;\n          this.maybeDragNewGenericElement(pointerDownState, event, false);\n        }\n      }\n\n      if (this.state.activeTool.type === \"selection\") {\n        pointerDownState.boxSelection.hasOccurred = true;\n\n        const elements = this.scene.getNonDeletedElements();\n\n        // box-select line editor points\n        if (this.state.editingLinearElement) {\n          LinearElementEditor.handleBoxSelection(\n            event,\n            this.state,\n            this.setState.bind(this),\n            this.scene.getNonDeletedElementsMap(),\n          );\n          // regular box-select\n        } else {\n          let shouldReuseSelection = true;\n\n          if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {\n            if (\n              pointerDownState.withCmdOrCtrl &&\n              pointerDownState.hit.element\n            ) {\n              this.setState((prevState) =>\n                selectGroupsForSelectedElements(\n                  {\n                    ...prevState,\n                    selectedElementIds: {\n                      [pointerDownState.hit.element!.id]: true,\n                    },\n                  },\n                  this.scene.getNonDeletedElements(),\n                  prevState,\n                  this,\n                ),\n              );\n            } else {\n              shouldReuseSelection = false;\n            }\n          }\n          const elementsWithinSelection = this.state.selectionElement\n            ? getElementsWithinSelection(\n                elements,\n                this.state.selectionElement,\n                this.scene.getNonDeletedElementsMap(),\n                false,\n              )\n            : [];\n\n          this.setState((prevState) => {\n            const nextSelectedElementIds = {\n              ...(shouldReuseSelection && prevState.selectedElementIds),\n              ...elementsWithinSelection.reduce(\n                (acc: Record<ExcalidrawElement[\"id\"], true>, element) => {\n                  acc[element.id] = true;\n                  return acc;\n                },\n                {},\n              ),\n            };\n\n            if (pointerDownState.hit.element) {\n              // if using ctrl/cmd, select the hitElement only if we\n              // haven't box-selected anything else\n              if (!elementsWithinSelection.length) {\n                nextSelectedElementIds[pointerDownState.hit.element.id] = true;\n              } else {\n                delete nextSelectedElementIds[pointerDownState.hit.element.id];\n              }\n            }\n\n            prevState = !shouldReuseSelection\n              ? { ...prevState, selectedGroupIds: {}, editingGroupId: null }\n              : prevState;\n\n            return {\n              ...selectGroupsForSelectedElements(\n                {\n                  editingGroupId: prevState.editingGroupId,\n                  selectedElementIds: nextSelectedElementIds,\n                },\n                this.scene.getNonDeletedElements(),\n                prevState,\n                this,\n              ),\n              // select linear element only when we haven't box-selected anything else\n              selectedLinearElement:\n                elementsWithinSelection.length === 1 &&\n                isLinearElement(elementsWithinSelection[0])\n                  ? new LinearElementEditor(\n                      elementsWithinSelection[0],\n                      this.scene.getNonDeletedElementsMap(),\n                    )\n                  : null,\n              showHyperlinkPopup:\n                elementsWithinSelection.length === 1 &&\n                (elementsWithinSelection[0].link ||\n                  isEmbeddableElement(elementsWithinSelection[0]))\n                  ? \"info\"\n                  : false,\n            };\n          });\n        }\n      }\n    });\n  }\n\n  // Returns whether the pointer move happened over either scrollbar\n  private handlePointerMoveOverScrollbars(\n    event: PointerEvent,\n    pointerDownState: PointerDownState,\n  ): boolean {\n    if (pointerDownState.scrollbars.isOverHorizontal) {\n      const x = event.clientX;\n      const dx = x - pointerDownState.lastCoords.x;\n      this.translateCanvas({\n        scrollX:\n          this.state.scrollX -\n          (dx * (currentScrollBars.horizontal?.deltaMultiplier || 1)) /\n            this.state.zoom.value,\n      });\n      pointerDownState.lastCoords.x = x;\n      return true;\n    }\n\n    if (pointerDownState.scrollbars.isOverVertical) {\n      const y = event.clientY;\n      const dy = y - pointerDownState.lastCoords.y;\n      this.translateCanvas({\n        scrollY:\n          this.state.scrollY -\n          (dy * (currentScrollBars.vertical?.deltaMultiplier || 1)) /\n            this.state.zoom.value,\n      });\n      pointerDownState.lastCoords.y = y;\n      return true;\n    }\n    return false;\n  }\n\n  private onPointerUpFromPointerDownHandler(\n    pointerDownState: PointerDownState,\n  ): (event: PointerEvent) => void {\n    return withBatchedUpdates((childEvent: PointerEvent) => {\n      this.removePointer(childEvent);\n      if (pointerDownState.eventListeners.onMove) {\n        pointerDownState.eventListeners.onMove.flush();\n      }\n      const {\n        newElement,\n        resizingElement,\n        croppingElementId,\n        multiElement,\n        activeTool,\n        isResizing,\n        isRotating,\n        isCropping,\n      } = this.state;\n\n      this.setState((prevState) => ({\n        isResizing: false,\n        isRotating: false,\n        isCropping: false,\n        resizingElement: null,\n        selectionElement: null,\n        frameToHighlight: null,\n        elementsToHighlight: null,\n        cursorButton: \"up\",\n        snapLines: updateStable(prevState.snapLines, []),\n        originSnapOffset: null,\n      }));\n\n      // just in case, tool changes mid drag, always clean up\n      this.lassoTrail.endPath();\n      this.lastPointerMoveCoords = null;\n\n      SnapCache.setReferenceSnapPoints(null);\n      SnapCache.setVisibleGaps(null);\n\n      this.savePointer(childEvent.clientX, childEvent.clientY, \"up\");\n\n      // if current elements are still selected\n      // and the pointer is just over a locked element\n      // do not allow activeLockedId to be set\n\n      const hitElements = pointerDownState.hit.allHitElements;\n\n      const sceneCoords = viewportCoordsToSceneCoords(\n        { clientX: childEvent.clientX, clientY: childEvent.clientY },\n        this.state,\n      );\n\n      if (\n        this.state.activeTool.type === \"selection\" &&\n        !pointerDownState.boxSelection.hasOccurred &&\n        !pointerDownState.resize.isResizing &&\n        !hitElements.some((el) => this.state.selectedElementIds[el.id])\n      ) {\n        const hitLockedElement = this.getElementAtPosition(\n          sceneCoords.x,\n          sceneCoords.y,\n          {\n            includeLockedElements: true,\n          },\n        );\n\n        this.store.scheduleCapture();\n\n        if (hitLockedElement?.locked) {\n          this.setState({\n            activeLockedId:\n              hitLockedElement.groupIds.length > 0\n                ? hitLockedElement.groupIds.at(-1) || \"\"\n                : hitLockedElement.id,\n          });\n        } else {\n          this.setState({\n            activeLockedId: null,\n          });\n        }\n      } else {\n        this.setState({\n          activeLockedId: null,\n        });\n      }\n\n      this.setState({\n        selectedElementsAreBeingDragged: false,\n      });\n      const elementsMap = this.scene.getNonDeletedElementsMap();\n\n      if (\n        pointerDownState.drag.hasOccurred &&\n        pointerDownState.hit?.element?.id\n      ) {\n        const element = elementsMap.get(pointerDownState.hit.element.id);\n        if (isBindableElement(element)) {\n          // Renormalize elbow arrows when they are changed via indirect move\n          element.boundElements\n            ?.filter((e) => e.type === \"arrow\")\n            .map((e) => elementsMap.get(e.id))\n            .filter((e) => isElbowArrow(e))\n            .forEach((e) => {\n              !!e && this.scene.mutateElement(e, {});\n            });\n        }\n      }\n\n      // Handle end of dragging a point of a linear element, might close a loop\n      // and sets binding element\n      if (this.state.editingLinearElement) {\n        if (\n          !pointerDownState.boxSelection.hasOccurred &&\n          pointerDownState.hit?.element?.id !==\n            this.state.editingLinearElement.elementId\n        ) {\n          this.actionManager.executeAction(actionFinalize);\n        } else {\n          const editingLinearElement = LinearElementEditor.handlePointerUp(\n            childEvent,\n            this.state.editingLinearElement,\n            this.state,\n            this.scene,\n          );\n          if (editingLinearElement !== this.state.editingLinearElement) {\n            this.setState({\n              editingLinearElement,\n              suggestedBindings: [],\n            });\n          }\n        }\n      } else if (this.state.selectedLinearElement) {\n        // Normalize elbow arrow points, remove close parallel segments\n        if (this.state.selectedLinearElement.elbowed) {\n          const element = LinearElementEditor.getElement(\n            this.state.selectedLinearElement.elementId,\n            this.scene.getNonDeletedElementsMap(),\n          );\n          if (element) {\n            this.scene.mutateElement(\n              element as ExcalidrawElbowArrowElement,\n              {},\n            );\n          }\n        }\n\n        if (\n          pointerDownState.hit?.element?.id !==\n          this.state.selectedLinearElement.elementId\n        ) {\n          const selectedELements = this.scene.getSelectedElements(this.state);\n          // set selectedLinearElement to null if there is more than one element selected since we don't want to show linear element handles\n          if (selectedELements.length > 1) {\n            this.setState({ selectedLinearElement: null });\n          }\n        } else if (this.state.selectedLinearElement.isDragging) {\n          this.actionManager.executeAction(actionFinalize, \"ui\", {\n            event: childEvent,\n            sceneCoords,\n          });\n        }\n      }\n\n      this.missingPointerEventCleanupEmitter.clear();\n\n      window.removeEventListener(\n        EVENT.POINTER_MOVE,\n        pointerDownState.eventListeners.onMove!,\n      );\n      window.removeEventListener(\n        EVENT.POINTER_UP,\n        pointerDownState.eventListeners.onUp!,\n      );\n      window.removeEventListener(\n        EVENT.KEYDOWN,\n        pointerDownState.eventListeners.onKeyDown!,\n      );\n      window.removeEventListener(\n        EVENT.KEYUP,\n        pointerDownState.eventListeners.onKeyUp!,\n      );\n\n      this.props?.onPointerUp?.(activeTool, pointerDownState);\n      this.onPointerUpEmitter.trigger(\n        this.state.activeTool,\n        pointerDownState,\n        childEvent,\n      );\n\n      if (newElement?.type === \"freedraw\") {\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        const points = newElement.points;\n        let dx = pointerCoords.x - newElement.x;\n        let dy = pointerCoords.y - newElement.y;\n\n        // Allows dots to avoid being flagged as infinitely small\n        if (dx === points[0][0] && dy === points[0][1]) {\n          dy += 0.0001;\n          dx += 0.0001;\n        }\n\n        const pressures = newElement.simulatePressure\n          ? []\n          : [...newElement.pressures, childEvent.pressure];\n\n        this.scene.mutateElement(newElement, {\n          points: [...points, pointFrom<LocalPoint>(dx, dy)],\n          pressures,\n          lastCommittedPoint: pointFrom<LocalPoint>(dx, dy),\n        });\n\n        this.actionManager.executeAction(actionFinalize);\n\n        return;\n      }\n\n      if (isLinearElement(newElement)) {\n        if (newElement!.points.length > 1) {\n          this.store.scheduleCapture();\n        }\n        const pointerCoords = viewportCoordsToSceneCoords(\n          childEvent,\n          this.state,\n        );\n\n        if (!pointerDownState.drag.hasOccurred && newElement && !multiElement) {\n          this.scene.mutateElement(\n            newElement,\n            {\n              points: [\n                ...newElement.points,\n                pointFrom<LocalPoint>(\n                  pointerCoords.x - newElement.x,\n                  pointerCoords.y - newElement.y,\n                ),\n              ],\n            },\n            { informMutation: false, isDragging: false },\n          );\n\n          this.setState({\n            multiElement: newElement,\n            newElement,\n          });\n        } else if (pointerDownState.drag.hasOccurred && !multiElement) {\n          if (\n            isBindingEnabled(this.state) &&\n            isBindingElement(newElement, false)\n          ) {\n            this.actionManager.executeAction(actionFinalize, \"ui\", {\n              event: childEvent,\n              sceneCoords,\n            });\n          }\n          this.setState({ suggestedBindings: [], startBoundElement: null });\n          if (!activeTool.locked) {\n            resetCursor(this.interactiveCanvas);\n            this.setState((prevState) => ({\n              newElement: null,\n              activeTool: updateActiveTool(this.state, {\n                type: \"selection\",\n              }),\n              selectedElementIds: makeNextSelectedElementIds(\n                {\n                  ...prevState.selectedElementIds,\n                  [newElement.id]: true,\n                },\n                prevState,\n              ),\n              selectedLinearElement: new LinearElementEditor(\n                newElement,\n                this.scene.getNonDeletedElementsMap(),\n              ),\n            }));\n          } else {\n            this.setState((prevState) => ({\n              newElement: null,\n            }));\n          }\n          // so that the scene gets rendered again to display the newly drawn linear as well\n          this.scene.triggerUpdate();\n        }\n        return;\n      }\n\n      if (isTextElement(newElement)) {\n        const minWidth = getMinTextElementWidth(\n          getFontString({\n            fontSize: newElement.fontSize,\n            fontFamily: newElement.fontFamily,\n          }),\n          newElement.lineHeight,\n        );\n\n        if (newElement.width < minWidth) {\n          this.scene.mutateElement(newElement, {\n            autoResize: true,\n          });\n        }\n\n        this.resetCursor();\n\n        this.handleTextWysiwyg(newElement, {\n          isExistingElement: true,\n        });\n      }\n\n      if (\n        activeTool.type !== \"selection\" &&\n        newElement &&\n        isInvisiblySmallElement(newElement)\n      ) {\n        // remove invisible element which was added in onPointerDown\n        // update the store snapshot, so that invisible elements are not captured by the store\n        this.updateScene({\n          elements: this.scene\n            .getElementsIncludingDeleted()\n            .filter((el) => el.id !== newElement.id),\n          appState: {\n            newElement: null,\n          },\n          captureUpdate: CaptureUpdateAction.NEVER,\n        });\n\n        return;\n      }\n\n      if (isFrameLikeElement(newElement)) {\n        const elementsInsideFrame = getElementsInNewFrame(\n          this.scene.getElementsIncludingDeleted(),\n          newElement,\n          this.scene.getNonDeletedElementsMap(),\n        );\n\n        this.scene.replaceAllElements(\n          addElementsToFrame(\n            this.scene.getElementsMapIncludingDeleted(),\n            elementsInsideFrame,\n            newElement,\n            this.state,\n          ),\n        );\n      }\n\n      if (newElement) {\n        this.scene.mutateElement(\n          newElement,\n          getNormalizedDimensions(newElement),\n          {\n            informMutation: false,\n            isDragging: false,\n          },\n        );\n        // the above does not guarantee the scene to be rendered again, hence the trigger below\n        this.scene.triggerUpdate();\n      }\n\n      if (pointerDownState.drag.hasOccurred) {\n        const sceneCoords = viewportCoordsToSceneCoords(childEvent, this.state);\n\n        // when editing the points of a linear element, we check if the\n        // linear element still is in the frame afterwards\n        // if not, the linear element will be removed from its frame (if any)\n        if (\n          this.state.selectedLinearElement &&\n          this.state.selectedLinearElement.isDragging\n        ) {\n          const linearElement = this.scene.getElement(\n            this.state.selectedLinearElement.elementId,\n          );\n\n          if (linearElement?.frameId) {\n            const frame = getContainingFrame(linearElement, elementsMap);\n\n            if (frame && linearElement) {\n              if (\n                !elementOverlapsWithFrame(\n                  linearElement,\n                  frame,\n                  this.scene.getNonDeletedElementsMap(),\n                )\n              ) {\n                // remove the linear element from all groups\n                // before removing it from the frame as well\n                this.scene.mutateElement(linearElement, {\n                  groupIds: [],\n                });\n\n                removeElementsFromFrame(\n                  [linearElement],\n                  this.scene.getNonDeletedElementsMap(),\n                );\n\n                this.scene.triggerUpdate();\n              }\n            }\n          }\n        } else {\n          // update the relationships between selected elements and frames\n          const topLayerFrame = this.getTopLayerFrameAtSceneCoords(sceneCoords);\n\n          const selectedElements = this.scene.getSelectedElements(this.state);\n          let nextElements = this.scene.getElementsMapIncludingDeleted();\n\n          const updateGroupIdsAfterEditingGroup = (\n            elements: ExcalidrawElement[],\n          ) => {\n            if (elements.length > 0) {\n              for (const element of elements) {\n                const index = element.groupIds.indexOf(\n                  this.state.editingGroupId!,\n                );\n\n                this.scene.mutateElement(\n                  element,\n                  {\n                    groupIds: element.groupIds.slice(0, index),\n                  },\n                  { informMutation: false, isDragging: false },\n                );\n              }\n\n              nextElements.forEach((element) => {\n                if (\n                  element.groupIds.length &&\n                  getElementsInGroup(\n                    nextElements,\n                    element.groupIds[element.groupIds.length - 1],\n                  ).length < 2\n                ) {\n                  this.scene.mutateElement(\n                    element,\n                    {\n                      groupIds: [],\n                    },\n                    { informMutation: false, isDragging: false },\n                  );\n                }\n              });\n\n              this.setState({\n                editingGroupId: null,\n              });\n            }\n          };\n\n          if (\n            topLayerFrame &&\n            !this.state.selectedElementIds[topLayerFrame.id]\n          ) {\n            const elementsToAdd = selectedElements.filter(\n              (element) =>\n                element.frameId !== topLayerFrame.id &&\n                isElementInFrame(element, nextElements, this.state),\n            );\n\n            if (this.state.editingGroupId) {\n              updateGroupIdsAfterEditingGroup(elementsToAdd);\n            }\n\n            nextElements = addElementsToFrame(\n              nextElements,\n              elementsToAdd,\n              topLayerFrame,\n              this.state,\n            );\n          } else if (!topLayerFrame) {\n            if (this.state.editingGroupId) {\n              const elementsToRemove = selectedElements.filter(\n                (element) =>\n                  element.frameId &&\n                  !isElementInFrame(element, nextElements, this.state),\n              );\n\n              updateGroupIdsAfterEditingGroup(elementsToRemove);\n            }\n          }\n\n          nextElements = updateFrameMembershipOfSelectedElements(\n            nextElements,\n            this.state,\n            this,\n          );\n\n          this.scene.replaceAllElements(nextElements);\n        }\n      }\n\n      if (resizingElement) {\n        this.store.scheduleCapture();\n      }\n\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        // update the store snapshot, so that invisible elements are not captured by the store\n        this.updateScene({\n          elements: this.scene\n            .getElementsIncludingDeleted()\n            .filter((el) => el.id !== resizingElement.id),\n          captureUpdate: CaptureUpdateAction.NEVER,\n        });\n      }\n\n      // handle frame membership for resizing frames and/or selected elements\n      if (pointerDownState.resize.isResizing) {\n        let nextElements = updateFrameMembershipOfSelectedElements(\n          this.scene.getElementsIncludingDeleted(),\n          this.state,\n          this,\n        );\n\n        const selectedFrames = this.scene\n          .getSelectedElements(this.state)\n          .filter((element): element is ExcalidrawFrameLikeElement =>\n            isFrameLikeElement(element),\n          );\n\n        for (const frame of selectedFrames) {\n          nextElements = replaceAllElementsInFrame(\n            nextElements,\n            getElementsInResizingFrame(\n              this.scene.getElementsIncludingDeleted(),\n              frame,\n              this.state,\n              elementsMap,\n            ),\n            frame,\n            this,\n          );\n        }\n\n        this.scene.replaceAllElements(nextElements);\n      }\n\n      // Code below handles selection when element(s) weren't\n      // drag or added to selection on pointer down phase.\n      const hitElement = pointerDownState.hit.element;\n      if (\n        this.state.selectedLinearElement?.elementId !== hitElement?.id &&\n        isLinearElement(hitElement)\n      ) {\n        const selectedElements = this.scene.getSelectedElements(this.state);\n        // set selectedLinearElement when no other element selected except\n        // the one we've hit\n        if (selectedElements.length === 1) {\n          this.setState({\n            selectedLinearElement: new LinearElementEditor(\n              hitElement,\n              this.scene.getNonDeletedElementsMap(),\n            ),\n          });\n        }\n      }\n\n      // click outside the cropping region to exit\n      if (\n        // not in the cropping mode at all\n        !croppingElementId ||\n        // in the cropping mode\n        (croppingElementId &&\n          // not cropping and no hit element\n          ((!hitElement && !isCropping) ||\n            // hitting something else\n            (hitElement && hitElement.id !== croppingElementId)))\n      ) {\n        this.finishImageCropping();\n      }\n\n      const pointerStart = this.lastPointerDownEvent;\n      const pointerEnd = this.lastPointerUpEvent || this.lastPointerMoveEvent;\n\n      if (isEraserActive(this.state) && pointerStart && pointerEnd) {\n        this.eraserTrail.endPath();\n\n        const draggedDistance = pointDistance(\n          pointFrom(pointerStart.clientX, pointerStart.clientY),\n          pointFrom(pointerEnd.clientX, pointerEnd.clientY),\n        );\n\n        if (draggedDistance === 0) {\n          const scenePointer = viewportCoordsToSceneCoords(\n            {\n              clientX: pointerEnd.clientX,\n              clientY: pointerEnd.clientY,\n            },\n            this.state,\n          );\n          const hitElements = this.getElementsAtPosition(\n            scenePointer.x,\n            scenePointer.y,\n          );\n          hitElements.forEach((hitElement) =>\n            this.elementsPendingErasure.add(hitElement.id),\n          );\n        }\n        this.eraseElements();\n        return;\n      } else if (this.elementsPendingErasure.size) {\n        this.restoreReadyToEraseElements();\n      }\n\n      if (\n        hitElement &&\n        !pointerDownState.drag.hasOccurred &&\n        !pointerDownState.hit.wasAddedToSelection &&\n        // if we're editing a line, pointerup shouldn't switch selection if\n        // box selected\n        (!this.state.editingLinearElement ||\n          !pointerDownState.boxSelection.hasOccurred) &&\n        // hitElement can be set when alt + ctrl to toggle lasso and we will\n        // just respect the selected elements from lasso instead\n        this.state.activeTool.type !== \"lasso\"\n      ) {\n        // when inside line editor, shift selects points instead\n        if (childEvent.shiftKey && !this.state.editingLinearElement) {\n          if (this.state.selectedElementIds[hitElement.id]) {\n            if (isSelectedViaGroup(this.state, hitElement)) {\n              this.setState((_prevState) => {\n                const nextSelectedElementIds = {\n                  ..._prevState.selectedElementIds,\n                };\n\n                // We want to unselect all groups hitElement is part of\n                // as well as all elements that are part of the groups\n                // hitElement is part of\n                for (const groupedElement of hitElement.groupIds.flatMap(\n                  (groupId) =>\n                    getElementsInGroup(\n                      this.scene.getNonDeletedElements(),\n                      groupId,\n                    ),\n                )) {\n                  delete nextSelectedElementIds[groupedElement.id];\n                }\n\n                return {\n                  selectedGroupIds: {\n                    ..._prevState.selectedElementIds,\n                    ...hitElement.groupIds\n                      .map((gId) => ({ [gId]: false }))\n                      .reduce((prev, acc) => ({ ...prev, ...acc }), {}),\n                  },\n                  selectedElementIds: makeNextSelectedElementIds(\n                    nextSelectedElementIds,\n                    _prevState,\n                  ),\n                };\n              });\n              // if not dragging a linear element point (outside editor)\n            } else if (!this.state.selectedLinearElement?.isDragging) {\n              // remove element from selection while\n              // keeping prev elements selected\n\n              this.setState((prevState) => {\n                const newSelectedElementIds = {\n                  ...prevState.selectedElementIds,\n                };\n                delete newSelectedElementIds[hitElement!.id];\n                const newSelectedElements = getSelectedElements(\n                  this.scene.getNonDeletedElements(),\n                  { selectedElementIds: newSelectedElementIds },\n                );\n\n                return {\n                  ...selectGroupsForSelectedElements(\n                    {\n                      editingGroupId: prevState.editingGroupId,\n                      selectedElementIds: newSelectedElementIds,\n                    },\n                    this.scene.getNonDeletedElements(),\n                    prevState,\n                    this,\n                  ),\n                  // set selectedLinearElement only if thats the only element selected\n                  selectedLinearElement:\n                    newSelectedElements.length === 1 &&\n                    isLinearElement(newSelectedElements[0])\n                      ? new LinearElementEditor(\n                          newSelectedElements[0],\n                          this.scene.getNonDeletedElementsMap(),\n                        )\n                      : prevState.selectedLinearElement,\n                };\n              });\n            }\n          } else if (\n            hitElement.frameId &&\n            this.state.selectedElementIds[hitElement.frameId]\n          ) {\n            // when hitElement is part of a selected frame, deselect the frame\n            // to avoid frame and containing elements selected simultaneously\n            this.setState((prevState) => {\n              const nextSelectedElementIds: {\n                [id: string]: true;\n              } = {\n                ...prevState.selectedElementIds,\n                [hitElement.id]: true,\n              };\n              // deselect the frame\n              delete nextSelectedElementIds[hitElement.frameId!];\n\n              // deselect groups containing the frame\n              (this.scene.getElement(hitElement.frameId!)?.groupIds ?? [])\n                .flatMap((gid) =>\n                  getElementsInGroup(this.scene.getNonDeletedElements(), gid),\n                )\n                .forEach((element) => {\n                  delete nextSelectedElementIds[element.id];\n                });\n\n              return {\n                ...selectGroupsForSelectedElements(\n                  {\n                    editingGroupId: prevState.editingGroupId,\n                    selectedElementIds: nextSelectedElementIds,\n                  },\n                  this.scene.getNonDeletedElements(),\n                  prevState,\n                  this,\n                ),\n                showHyperlinkPopup:\n                  hitElement.link || isEmbeddableElement(hitElement)\n                    ? \"info\"\n                    : false,\n              };\n            });\n          } else {\n            // add element to selection while keeping prev elements selected\n            this.setState((_prevState) => ({\n              selectedElementIds: makeNextSelectedElementIds(\n                {\n                  ..._prevState.selectedElementIds,\n                  [hitElement!.id]: true,\n                },\n                _prevState,\n              ),\n            }));\n          }\n        } else {\n          this.setState((prevState) => ({\n            ...selectGroupsForSelectedElements(\n              {\n                editingGroupId: prevState.editingGroupId,\n                selectedElementIds: { [hitElement.id]: true },\n              },\n              this.scene.getNonDeletedElements(),\n              prevState,\n              this,\n            ),\n            selectedLinearElement:\n              isLinearElement(hitElement) &&\n              // Don't set `selectedLinearElement` if its same as the hitElement, this is mainly to prevent resetting the `hoverPointIndex` to -1.\n              // Future we should update the API to take care of setting the correct `hoverPointIndex` when initialized\n              prevState.selectedLinearElement?.elementId !== hitElement.id\n                ? new LinearElementEditor(\n                    hitElement,\n                    this.scene.getNonDeletedElementsMap(),\n                  )\n                : prevState.selectedLinearElement,\n          }));\n        }\n      }\n\n      if (\n        // do not clear selection if lasso is active\n        this.state.activeTool.type !== \"lasso\" &&\n        // not elbow midpoint dragged\n        !(hitElement && isElbowArrow(hitElement)) &&\n        // not dragged\n        !pointerDownState.drag.hasOccurred &&\n        // not resized\n        !this.state.isResizing &&\n        // only hitting the bounding box of the previous hit element\n        ((hitElement &&\n          hitElementBoundingBoxOnly(\n            {\n              point: pointFrom(\n                pointerDownState.origin.x,\n                pointerDownState.origin.y,\n              ),\n              element: hitElement,\n              elementsMap,\n              threshold: this.getElementHitThreshold(hitElement),\n              frameNameBound: isFrameLikeElement(hitElement)\n                ? this.frameNameBoundsCache.get(hitElement)\n                : null,\n            },\n            elementsMap,\n          )) ||\n          (!hitElement &&\n            pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements))\n      ) {\n        if (this.state.editingLinearElement) {\n          this.setState({ editingLinearElement: null });\n        } else {\n          // Deselect selected elements\n          this.setState({\n            selectedElementIds: makeNextSelectedElementIds({}, this.state),\n            selectedGroupIds: {},\n            editingGroupId: null,\n            activeEmbeddable: null,\n          });\n        }\n        // reset cursor\n        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);\n        return;\n      }\n\n      if (!activeTool.locked && activeTool.type !== \"freedraw\" && newElement) {\n        this.setState((prevState) => ({\n          selectedElementIds: makeNextSelectedElementIds(\n            {\n              ...prevState.selectedElementIds,\n              [newElement.id]: true,\n            },\n            prevState,\n          ),\n          showHyperlinkPopup:\n            isEmbeddableElement(newElement) && !newElement.link\n              ? \"editor\"\n              : prevState.showHyperlinkPopup,\n        }));\n      }\n\n      if (\n        activeTool.type !== \"selection\" ||\n        isSomeElementSelected(this.scene.getNonDeletedElements(), this.state) ||\n        !isShallowEqual(\n          this.state.previousSelectedElementIds,\n          this.state.selectedElementIds,\n        )\n      ) {\n        this.store.scheduleCapture();\n      }\n\n      if (\n        (pointerDownState.drag.hasOccurred &&\n          !this.state.selectedLinearElement) ||\n        isResizing ||\n        isRotating ||\n        isCropping\n      ) {\n        // We only allow binding via linear elements, specifically via dragging\n        // the endpoints (\"start\" or \"end\").\n        const linearElements = this.scene\n          .getSelectedElements(this.state)\n          .filter(isLinearElement);\n\n        bindOrUnbindLinearElements(\n          linearElements,\n          isBindingEnabled(this.state),\n          this.state.selectedLinearElement?.selectedPointsIndices ?? [],\n          this.scene,\n          this.state.zoom,\n        );\n      }\n\n      if (activeTool.type === \"laser\") {\n        this.laserTrails.endPath();\n        return;\n      }\n\n      if (\n        !activeTool.locked &&\n        activeTool.type !== \"freedraw\" &&\n        (activeTool.type !== \"lasso\" ||\n          // if lasso is turned on but from selection => reset to selection\n          (activeTool.type === \"lasso\" && activeTool.fromSelection))\n      ) {\n        resetCursor(this.interactiveCanvas);\n        this.setState({\n          newElement: null,\n          suggestedBindings: [],\n          activeTool: updateActiveTool(this.state, { type: \"selection\" }),\n        });\n      } else {\n        this.setState({\n          newElement: null,\n          suggestedBindings: [],\n        });\n      }\n\n      if (\n        hitElement &&\n        this.lastPointerUpEvent &&\n        this.lastPointerDownEvent &&\n        this.lastPointerUpEvent.timeStamp -\n          this.lastPointerDownEvent.timeStamp <\n          300 &&\n        gesture.pointers.size <= 1 &&\n        isIframeLikeElement(hitElement) &&\n        this.isIframeLikeElementCenter(\n          hitElement,\n          this.lastPointerUpEvent,\n          pointerDownState.origin.x,\n          pointerDownState.origin.y,\n        )\n      ) {\n        this.handleEmbeddableCenterClick(hitElement);\n      }\n    });\n  }\n\n  private restoreReadyToEraseElements = () => {\n    this.elementsPendingErasure = new Set();\n    this.triggerRender();\n  };\n\n  private eraseElements = () => {\n    let didChange = false;\n    const elements = this.scene.getElementsIncludingDeleted().map((ele) => {\n      if (\n        this.elementsPendingErasure.has(ele.id) ||\n        (ele.frameId && this.elementsPendingErasure.has(ele.frameId)) ||\n        (isBoundToContainer(ele) &&\n          this.elementsPendingErasure.has(ele.containerId))\n      ) {\n        didChange = true;\n        return newElementWith(ele, { isDeleted: true });\n      }\n      return ele;\n    });\n\n    this.elementsPendingErasure = new Set();\n\n    if (didChange) {\n      this.store.scheduleCapture();\n      this.scene.replaceAllElements(elements);\n    }\n  };\n\n  private initializeImage = async (\n    placeholderImageElement: ExcalidrawImageElement,\n    imageFile: File,\n  ) => {\n    // at this point this should be guaranteed image file, but we do this check\n    // to satisfy TS down the line\n    if (!isSupportedImageFile(imageFile)) {\n      throw new Error(t(\"errors.unsupportedFileType\"));\n    }\n    const mimeType = imageFile.type;\n\n    setCursor(this.interactiveCanvas, \"wait\");\n\n    if (mimeType === MIME_TYPES.svg) {\n      try {\n        imageFile = SVGStringToFile(\n          normalizeSVG(await imageFile.text()),\n          imageFile.name,\n        );\n      } catch (error: any) {\n        console.warn(error);\n        throw new Error(t(\"errors.svgImageInsertError\"));\n      }\n    }\n\n    // generate image id (by default the file digest) before any\n    // resizing/compression takes place to keep it more portable\n    const fileId = await ((this.props.generateIdForFile?.(\n      imageFile,\n    ) as Promise<FileId>) || generateIdFromFile(imageFile));\n\n    if (!fileId) {\n      console.warn(\n        \"Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one.\",\n      );\n      throw new Error(t(\"errors.imageInsertError\"));\n    }\n\n    const existingFileData = this.files[fileId];\n    if (!existingFileData?.dataURL) {\n      try {\n        imageFile = await resizeImageFile(imageFile, {\n          maxWidthOrHeight: DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT,\n        });\n      } catch (error: any) {\n        console.error(\n          \"Error trying to resizing image file on insertion\",\n          error,\n        );\n      }\n\n      if (imageFile.size > MAX_ALLOWED_FILE_BYTES) {\n        throw new Error(\n          t(\"errors.fileTooBig\", {\n            maxSize: `${Math.trunc(MAX_ALLOWED_FILE_BYTES / 1024 / 1024)}MB`,\n          }),\n        );\n      }\n    }\n\n    const dataURL =\n      this.files[fileId]?.dataURL || (await getDataURL(imageFile));\n\n    return new Promise<NonDeleted<InitializedExcalidrawImageElement>>(\n      async (resolve, reject) => {\n        try {\n          let initializedImageElement = this.getLatestInitializedImageElement(\n            placeholderImageElement,\n            fileId,\n          );\n\n          this.addMissingFiles([\n            {\n              mimeType,\n              id: fileId,\n              dataURL,\n              created: Date.now(),\n              lastRetrieved: Date.now(),\n            },\n          ]);\n\n          if (!this.imageCache.get(fileId)) {\n            this.addNewImagesToImageCache();\n\n            const { erroredFiles } = await this.updateImageCache([\n              initializedImageElement,\n            ]);\n\n            if (erroredFiles.size) {\n              throw new Error(\"Image cache update resulted with an error.\");\n            }\n          }\n\n          const imageHTML = await this.imageCache.get(fileId)?.image;\n\n          if (\n            imageHTML &&\n            this.state.newElement?.id !== initializedImageElement.id\n          ) {\n            initializedImageElement = this.getLatestInitializedImageElement(\n              placeholderImageElement,\n              fileId,\n            );\n\n            const naturalDimensions = this.getImageNaturalDimensions(\n              initializedImageElement,\n              imageHTML,\n            );\n\n            // no need to create a new instance anymore, just assign the natural dimensions\n            Object.assign(initializedImageElement, naturalDimensions);\n          }\n\n          resolve(initializedImageElement);\n        } catch (error: any) {\n          console.error(error);\n          reject(new Error(t(\"errors.imageInsertError\")));\n        }\n      },\n    );\n  };\n\n  /**\n   * use during async image initialization,\n   * when the placeholder image could have been modified in the meantime,\n   * and when you don't want to loose those modifications\n   */\n  private getLatestInitializedImageElement = (\n    imagePlaceholder: ExcalidrawImageElement,\n    fileId: FileId,\n  ) => {\n    const latestImageElement =\n      this.scene.getElement(imagePlaceholder.id) ?? imagePlaceholder;\n\n    return newElementWith(\n      latestImageElement as InitializedExcalidrawImageElement,\n      {\n        fileId,\n      },\n    );\n  };\n\n  /**\n   * inserts image into elements array and rerenders\n   */\n  private insertImageElement = async (\n    placeholderImageElement: ExcalidrawImageElement,\n    imageFile: File,\n  ) => {\n    // we should be handling all cases upstream, but in case we forget to handle\n    // a future case, let's throw here\n    if (!this.isToolSupported(\"image\")) {\n      this.setState({ errorMessage: t(\"errors.imageToolNotSupported\") });\n      return;\n    }\n\n    this.scene.insertElement(placeholderImageElement);\n\n    try {\n      const initializedImageElement = await this.initializeImage(\n        placeholderImageElement,\n        imageFile,\n      );\n\n      const nextElements = this.scene\n        .getElementsIncludingDeleted()\n        .map((element) => {\n          if (element.id === initializedImageElement.id) {\n            return initializedImageElement;\n          }\n\n          return element;\n        });\n\n      this.updateScene({\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n        elements: nextElements,\n        appState: {\n          selectedElementIds: makeNextSelectedElementIds(\n            { [initializedImageElement.id]: true },\n            this.state,\n          ),\n        },\n      });\n\n      return initializedImageElement;\n    } catch (error: any) {\n      this.store.scheduleAction(CaptureUpdateAction.NEVER);\n      this.scene.mutateElement(placeholderImageElement, {\n        isDeleted: true,\n      });\n      this.actionManager.executeAction(actionFinalize);\n      this.setState({\n        errorMessage: error.message || t(\"errors.imageInsertError\"),\n      });\n      return null;\n    }\n  };\n\n  private onImageAction = async () => {\n    try {\n      const clientX = this.state.width / 2 + this.state.offsetLeft;\n      const clientY = this.state.height / 2 + this.state.offsetTop;\n\n      const { x, y } = viewportCoordsToSceneCoords(\n        { clientX, clientY },\n        this.state,\n      );\n\n      const imageFile = await fileOpen({\n        description: \"Image\",\n        extensions: Object.keys(\n          IMAGE_MIME_TYPES,\n        ) as (keyof typeof IMAGE_MIME_TYPES)[],\n      });\n\n      await this.createImageElement({\n        sceneX: x,\n        sceneY: y,\n        addToFrameUnderCursor: false,\n        imageFile,\n      });\n\n      // avoid being batched (just in case)\n      this.setState({}, () => {\n        this.actionManager.executeAction(actionFinalize);\n      });\n    } catch (error: any) {\n      if (error.name !== \"AbortError\") {\n        console.error(error);\n      } else {\n        console.warn(error);\n      }\n      this.setState(\n        {\n          newElement: null,\n          activeTool: updateActiveTool(this.state, { type: \"selection\" }),\n        },\n        () => {\n          this.actionManager.executeAction(actionFinalize);\n        },\n      );\n    }\n  };\n\n  private getImageNaturalDimensions = (\n    imageElement: ExcalidrawImageElement,\n    imageHTML: HTMLImageElement,\n  ) => {\n    const minHeight = Math.max(this.state.height - 120, 160);\n    // max 65% of canvas height, clamped to <300px, vh - 120px>\n    const maxHeight = Math.min(\n      minHeight,\n      Math.floor(this.state.height * 0.5) / this.state.zoom.value,\n    );\n\n    const height = Math.min(imageHTML.naturalHeight, maxHeight);\n    const width = height * (imageHTML.naturalWidth / imageHTML.naturalHeight);\n\n    // add current imageElement width/height to account for previous centering\n    // of the placeholder image\n    const x = imageElement.x + imageElement.width / 2 - width / 2;\n    const y = imageElement.y + imageElement.height / 2 - height / 2;\n\n    return {\n      x,\n      y,\n      width,\n      height,\n      crop: null,\n    };\n  };\n\n  /** updates image cache, refreshing updated elements and/or setting status\n      to error for images that fail during <img> element creation */\n  private updateImageCache = async (\n    elements: readonly InitializedExcalidrawImageElement[],\n    files = this.files,\n  ) => {\n    const { updatedFiles, erroredFiles } = await _updateImageCache({\n      imageCache: this.imageCache,\n      fileIds: elements.map((element) => element.fileId),\n      files,\n    });\n\n    if (erroredFiles.size) {\n      this.store.scheduleAction(CaptureUpdateAction.NEVER);\n      this.scene.replaceAllElements(\n        elements.map((element) => {\n          if (\n            isInitializedImageElement(element) &&\n            erroredFiles.has(element.fileId)\n          ) {\n            return newElementWith(element, {\n              status: \"error\",\n            });\n          }\n          return element;\n        }),\n      );\n    }\n\n    return { updatedFiles, erroredFiles };\n  };\n\n  /** adds new images to imageCache and re-renders if needed */\n  private addNewImagesToImageCache = async (\n    imageElements: InitializedExcalidrawImageElement[] = getInitializedImageElements(\n      this.scene.getNonDeletedElements(),\n    ),\n    files: BinaryFiles = this.files,\n  ) => {\n    const uncachedImageElements = imageElements.filter(\n      (element) => !element.isDeleted && !this.imageCache.has(element.fileId),\n    );\n\n    if (uncachedImageElements.length) {\n      const { updatedFiles } = await this.updateImageCache(\n        uncachedImageElements,\n        files,\n      );\n\n      if (updatedFiles.size) {\n        for (const element of uncachedImageElements) {\n          if (updatedFiles.has(element.fileId)) {\n            ShapeCache.delete(element);\n          }\n        }\n      }\n\n      if (updatedFiles.size) {\n        this.scene.triggerUpdate();\n      }\n    }\n  };\n\n  /** generally you should use `addNewImagesToImageCache()` directly if you need\n   *  to render new images. This is just a failsafe  */\n  private scheduleImageRefresh = throttle(() => {\n    this.addNewImagesToImageCache();\n  }, IMAGE_RENDER_TIMEOUT);\n\n  private updateBindingEnabledOnPointerMove = (\n    event: React.PointerEvent<HTMLElement>,\n  ) => {\n    const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);\n    if (this.state.isBindingEnabled !== shouldEnableBinding) {\n      this.setState({ isBindingEnabled: shouldEnableBinding });\n    }\n  };\n\n  private maybeSuggestBindingAtCursor = (\n    pointerCoords: {\n      x: number;\n      y: number;\n    },\n    considerAll: boolean,\n  ): void => {\n    const hoveredBindableElement = getHoveredElementForBinding(\n      pointerCoords,\n      this.scene.getNonDeletedElements(),\n      this.scene.getNonDeletedElementsMap(),\n      this.state.zoom,\n      false,\n      considerAll,\n    );\n    this.setState({\n      suggestedBindings:\n        hoveredBindableElement != null ? [hoveredBindableElement] : [],\n    });\n  };\n\n  private clearSelection(hitElement: ExcalidrawElement | null): void {\n    this.setState((prevState) => ({\n      selectedElementIds: makeNextSelectedElementIds({}, prevState),\n      activeEmbeddable: null,\n      selectedGroupIds: {},\n      // Continue editing the same group if the user selected a different\n      // element from it\n      editingGroupId:\n        prevState.editingGroupId &&\n        hitElement != null &&\n        isElementInGroup(hitElement, prevState.editingGroupId)\n          ? prevState.editingGroupId\n          : null,\n    }));\n    this.setState({\n      selectedElementIds: makeNextSelectedElementIds({}, this.state),\n      activeEmbeddable: null,\n      previousSelectedElementIds: this.state.selectedElementIds,\n    });\n  }\n\n  private handleInteractiveCanvasRef = (canvas: HTMLCanvasElement | null) => {\n    // canvas is null when unmounting\n    if (canvas !== null) {\n      this.interactiveCanvas = canvas;\n\n      // -----------------------------------------------------------------------\n      // NOTE wheel, touchstart, touchend events must be registered outside\n      // of react because react binds them them passively (so we can't prevent\n      // default on them)\n      this.interactiveCanvas.addEventListener(\n        EVENT.TOUCH_START,\n        this.onTouchStart,\n        { passive: false },\n      );\n      this.interactiveCanvas.addEventListener(EVENT.TOUCH_END, this.onTouchEnd);\n      // -----------------------------------------------------------------------\n    } else {\n      this.interactiveCanvas?.removeEventListener(\n        EVENT.TOUCH_START,\n        this.onTouchStart,\n      );\n      this.interactiveCanvas?.removeEventListener(\n        EVENT.TOUCH_END,\n        this.onTouchEnd,\n      );\n    }\n  };\n\n  private handleAppOnDrop = async (event: React.DragEvent<HTMLDivElement>) => {\n    // must be retrieved first, in the same frame\n    const { file, fileHandle } = await getFileFromEvent(event);\n    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n    );\n\n    try {\n      // if image tool not supported, don't show an error here and let it fall\n      // through so we still support importing scene data from images. If no\n      // scene data encoded, we'll show an error then\n      if (isSupportedImageFile(file) && this.isToolSupported(\"image\")) {\n        // first attempt to decode scene from the image if it's embedded\n        // ---------------------------------------------------------------------\n\n        if (file?.type === MIME_TYPES.png || file?.type === MIME_TYPES.svg) {\n          try {\n            const scene = await loadFromBlob(\n              file,\n              this.state,\n              this.scene.getElementsIncludingDeleted(),\n              fileHandle,\n            );\n            this.syncActionResult({\n              ...scene,\n              appState: {\n                ...(scene.appState || this.state),\n                isLoading: false,\n              },\n              replaceFiles: true,\n              captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n            });\n            return;\n          } catch (error: any) {\n            // Don't throw for image scene daa\n            if (error.name !== \"EncodingError\") {\n              throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n            }\n          }\n        }\n\n        // if no scene is embedded or we fail for whatever reason, fall back\n        // to importing as regular image\n        // ---------------------------------------------------------------------\n        this.createImageElement({ sceneX, sceneY, imageFile: file });\n\n        return;\n      }\n    } catch (error: any) {\n      return this.setState({\n        isLoading: false,\n        errorMessage: error.message,\n      });\n    }\n\n    const libraryJSON = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);\n    if (libraryJSON && typeof libraryJSON === \"string\") {\n      try {\n        const libraryItems = parseLibraryJSON(libraryJSON);\n        this.addElementsFromPasteOrLibrary({\n          elements: distributeLibraryItemsOnSquareGrid(libraryItems),\n          position: event,\n          files: null,\n        });\n      } catch (error: any) {\n        this.setState({ errorMessage: error.message });\n      }\n      return;\n    }\n\n    if (file) {\n      // Attempt to parse an excalidraw/excalidrawlib file\n      await this.loadFileToCanvas(file, fileHandle);\n    }\n\n    if (event.dataTransfer?.types?.includes(\"text/plain\")) {\n      const text = event.dataTransfer?.getData(\"text\");\n      if (\n        text &&\n        embeddableURLValidator(text, this.props.validateEmbeddable) &&\n        (/^(http|https):\\/\\/[^\\s/$.?#].[^\\s]*$/.test(text) ||\n          getEmbedLink(text)?.type === \"video\")\n      ) {\n        const embeddable = this.insertEmbeddableElement({\n          sceneX,\n          sceneY,\n          link: normalizeLink(text),\n        });\n        if (embeddable) {\n          this.store.scheduleCapture();\n          this.setState({ selectedElementIds: { [embeddable.id]: true } });\n        }\n      }\n    }\n  };\n\n  loadFileToCanvas = async (\n    file: File,\n    fileHandle: FileSystemHandle | null,\n  ) => {\n    file = await normalizeFile(file);\n    try {\n      const elements = this.scene.getElementsIncludingDeleted();\n      let ret;\n      try {\n        ret = await loadSceneOrLibraryFromBlob(\n          file,\n          this.state,\n          elements,\n          fileHandle,\n        );\n      } catch (error: any) {\n        const imageSceneDataError = error instanceof ImageSceneDataError;\n        if (\n          imageSceneDataError &&\n          error.code === \"IMAGE_NOT_CONTAINS_SCENE_DATA\" &&\n          !this.isToolSupported(\"image\")\n        ) {\n          this.setState({\n            isLoading: false,\n            errorMessage: t(\"errors.imageToolNotSupported\"),\n          });\n          return;\n        }\n        const errorMessage = imageSceneDataError\n          ? t(\"alerts.cannotRestoreFromImage\")\n          : t(\"alerts.couldNotLoadInvalidFile\");\n        this.setState({\n          isLoading: false,\n          errorMessage,\n        });\n      }\n      if (!ret) {\n        return;\n      }\n\n      if (ret.type === MIME_TYPES.excalidraw) {\n        // restore the fractional indices by mutating elements\n        syncInvalidIndices(elements.concat(ret.data.elements));\n\n        // don't capture and only update the store snapshot for old elements,\n        // otherwise we would end up with duplicated fractional indices on undo\n        this.store.scheduleMicroAction({\n          action: CaptureUpdateAction.NEVER,\n          elements,\n          appState: undefined,\n        });\n\n        this.setState({ isLoading: true });\n        this.syncActionResult({\n          ...ret.data,\n          appState: {\n            ...(ret.data.appState || this.state),\n            isLoading: false,\n          },\n          replaceFiles: true,\n          captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n        });\n      } else if (ret.type === MIME_TYPES.excalidrawlib) {\n        await this.library\n          .updateLibrary({\n            libraryItems: file,\n            merge: true,\n            openLibraryMenu: true,\n          })\n          .catch((error) => {\n            console.error(error);\n            this.setState({ errorMessage: t(\"errors.importLibraryError\") });\n          });\n      }\n    } catch (error: any) {\n      this.setState({ isLoading: false, errorMessage: error.message });\n    }\n  };\n\n  private handleCanvasContextMenu = (\n    event: React.MouseEvent<HTMLElement | HTMLCanvasElement>,\n  ) => {\n    event.preventDefault();\n\n    if (\n      ((\"pointerType\" in event.nativeEvent &&\n        event.nativeEvent.pointerType === \"touch\") ||\n        (\"pointerType\" in event.nativeEvent &&\n          event.nativeEvent.pointerType === \"pen\" &&\n          // always allow if user uses a pen secondary button\n          event.button !== POINTER_BUTTON.SECONDARY)) &&\n      this.state.activeTool.type !== \"selection\"\n    ) {\n      return;\n    }\n\n    const { x, y } = viewportCoordsToSceneCoords(event, this.state);\n    const element = this.getElementAtPosition(x, y, {\n      preferSelected: true,\n      includeLockedElements: true,\n    });\n\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    const isHittingCommonBoundBox =\n      this.isHittingCommonBoundingBoxOfSelectedElements(\n        { x, y },\n        selectedElements,\n      );\n\n    const type = element || isHittingCommonBoundBox ? \"element\" : \"canvas\";\n\n    const container = this.excalidrawContainerRef.current!;\n    const { top: offsetTop, left: offsetLeft } =\n      container.getBoundingClientRect();\n    const left = event.clientX - offsetLeft;\n    const top = event.clientY - offsetTop;\n\n    trackEvent(\"contextMenu\", \"openContextMenu\", type);\n\n    this.setState(\n      {\n        ...(element && !this.state.selectedElementIds[element.id]\n          ? {\n              ...this.state,\n              ...selectGroupsForSelectedElements(\n                {\n                  editingGroupId: this.state.editingGroupId,\n                  selectedElementIds: { [element.id]: true },\n                },\n                this.scene.getNonDeletedElements(),\n                this.state,\n                this,\n              ),\n              selectedLinearElement: isLinearElement(element)\n                ? new LinearElementEditor(\n                    element,\n                    this.scene.getNonDeletedElementsMap(),\n                  )\n                : null,\n            }\n          : this.state),\n        showHyperlinkPopup: false,\n      },\n      () => {\n        this.setState({\n          contextMenu: { top, left, items: this.getContextMenuItems(type) },\n        });\n      },\n    );\n  };\n\n  private maybeDragNewGenericElement = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n    informMutation = true,\n  ): void => {\n    const selectionElement = this.state.selectionElement;\n    const pointerCoords = pointerDownState.lastCoords;\n    if (selectionElement && this.state.activeTool.type !== \"eraser\") {\n      dragNewElement({\n        newElement: selectionElement,\n        elementType: this.state.activeTool.type,\n        originX: pointerDownState.origin.x,\n        originY: pointerDownState.origin.y,\n        x: pointerCoords.x,\n        y: pointerCoords.y,\n        width: distance(pointerDownState.origin.x, pointerCoords.x),\n        height: distance(pointerDownState.origin.y, pointerCoords.y),\n        shouldMaintainAspectRatio: shouldMaintainAspectRatio(event),\n        shouldResizeFromCenter: false,\n        scene: this.scene,\n        zoom: this.state.zoom.value,\n        informMutation: false,\n      });\n      return;\n    }\n\n    const newElement = this.state.newElement;\n    if (!newElement) {\n      return;\n    }\n\n    let [gridX, gridY] = getGridPoint(\n      pointerCoords.x,\n      pointerCoords.y,\n      event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize(),\n    );\n\n    const image =\n      isInitializedImageElement(newElement) &&\n      this.imageCache.get(newElement.fileId)?.image;\n    const aspectRatio =\n      image && !(image instanceof Promise) ? image.width / image.height : null;\n\n    this.maybeCacheReferenceSnapPoints(event, [newElement]);\n\n    const { snapOffset, snapLines } = snapNewElement(\n      newElement,\n      this,\n      event,\n      {\n        x:\n          pointerDownState.originInGrid.x +\n          (this.state.originSnapOffset?.x ?? 0),\n        y:\n          pointerDownState.originInGrid.y +\n          (this.state.originSnapOffset?.y ?? 0),\n      },\n      {\n        x: gridX - pointerDownState.originInGrid.x,\n        y: gridY - pointerDownState.originInGrid.y,\n      },\n      this.scene.getNonDeletedElementsMap(),\n    );\n\n    gridX += snapOffset.x;\n    gridY += snapOffset.y;\n\n    this.setState({\n      snapLines,\n    });\n\n    dragNewElement({\n      newElement,\n      elementType: this.state.activeTool.type,\n      originX: pointerDownState.originInGrid.x,\n      originY: pointerDownState.originInGrid.y,\n      x: gridX,\n      y: gridY,\n      width: distance(pointerDownState.originInGrid.x, gridX),\n      height: distance(pointerDownState.originInGrid.y, gridY),\n      shouldMaintainAspectRatio: isImageElement(newElement)\n        ? !shouldMaintainAspectRatio(event)\n        : shouldMaintainAspectRatio(event),\n      shouldResizeFromCenter: shouldResizeFromCenter(event),\n      zoom: this.state.zoom.value,\n      scene: this.scene,\n      widthAspectRatio: aspectRatio,\n      originOffset: this.state.originSnapOffset,\n      informMutation,\n    });\n\n    this.setState({\n      newElement,\n    });\n\n    // highlight elements that are to be added to frames on frames creation\n    if (\n      this.state.activeTool.type === TOOL_TYPE.frame ||\n      this.state.activeTool.type === TOOL_TYPE.magicframe\n    ) {\n      this.setState({\n        elementsToHighlight: getElementsInResizingFrame(\n          this.scene.getNonDeletedElements(),\n          newElement as ExcalidrawFrameLikeElement,\n          this.state,\n          this.scene.getNonDeletedElementsMap(),\n        ),\n      });\n    }\n  };\n\n  private maybeHandleCrop = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): boolean => {\n    // to crop, we must already be in the cropping mode, where croppingElement has been set\n    if (!this.state.croppingElementId) {\n      return false;\n    }\n\n    const transformHandleType = pointerDownState.resize.handleType;\n    const pointerCoords = pointerDownState.lastCoords;\n    const [x, y] = getGridPoint(\n      pointerCoords.x - pointerDownState.resize.offset.x,\n      pointerCoords.y - pointerDownState.resize.offset.y,\n      event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize(),\n    );\n\n    const croppingElement = this.scene\n      .getNonDeletedElementsMap()\n      .get(this.state.croppingElementId);\n\n    if (\n      transformHandleType &&\n      croppingElement &&\n      isImageElement(croppingElement)\n    ) {\n      const croppingAtStateStart = pointerDownState.originalElements.get(\n        croppingElement.id,\n      );\n\n      const image =\n        isInitializedImageElement(croppingElement) &&\n        this.imageCache.get(croppingElement.fileId)?.image;\n\n      if (\n        croppingAtStateStart &&\n        isImageElement(croppingAtStateStart) &&\n        image &&\n        !(image instanceof Promise)\n      ) {\n        const [gridX, gridY] = getGridPoint(\n          pointerCoords.x,\n          pointerCoords.y,\n          event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize(),\n        );\n\n        const dragOffset = {\n          x: gridX - pointerDownState.originInGrid.x,\n          y: gridY - pointerDownState.originInGrid.y,\n        };\n\n        this.maybeCacheReferenceSnapPoints(event, [croppingElement]);\n\n        const { snapOffset, snapLines } = snapResizingElements(\n          [croppingElement],\n          [croppingAtStateStart],\n          this,\n          event,\n          dragOffset,\n          transformHandleType,\n        );\n\n        this.scene.mutateElement(\n          croppingElement,\n          cropElement(\n            croppingElement,\n            this.scene.getNonDeletedElementsMap(),\n            transformHandleType,\n            image.naturalWidth,\n            image.naturalHeight,\n            x + snapOffset.x,\n            y + snapOffset.y,\n            event.shiftKey\n              ? croppingAtStateStart.width / croppingAtStateStart.height\n              : undefined,\n          ),\n        );\n\n        updateBoundElements(croppingElement, this.scene, {\n          newSize: {\n            width: croppingElement.width,\n            height: croppingElement.height,\n          },\n        });\n\n        this.setState({\n          isCropping: transformHandleType && transformHandleType !== \"rotation\",\n          snapLines,\n        });\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  private maybeHandleResize = (\n    pointerDownState: PointerDownState,\n    event: MouseEvent | KeyboardEvent,\n  ): boolean => {\n    const selectedElements = this.scene.getSelectedElements(this.state);\n    const selectedFrames = selectedElements.filter(\n      (element): element is ExcalidrawFrameLikeElement =>\n        isFrameLikeElement(element),\n    );\n\n    const transformHandleType = pointerDownState.resize.handleType;\n\n    if (\n      // Frames cannot be rotated.\n      (selectedFrames.length > 0 && transformHandleType === \"rotation\") ||\n      // Elbow arrows cannot be transformed (resized or rotated).\n      (selectedElements.length === 1 && isElbowArrow(selectedElements[0])) ||\n      // Do not resize when in crop mode\n      this.state.croppingElementId\n    ) {\n      return false;\n    }\n\n    this.setState({\n      // TODO: rename this state field to \"isScaling\" to distinguish\n      // it from the generic \"isResizing\" which includes scaling and\n      // rotating\n      isResizing: transformHandleType && transformHandleType !== \"rotation\",\n      isRotating: transformHandleType === \"rotation\",\n      activeEmbeddable: null,\n    });\n    const pointerCoords = pointerDownState.lastCoords;\n    let [resizeX, resizeY] = getGridPoint(\n      pointerCoords.x - pointerDownState.resize.offset.x,\n      pointerCoords.y - pointerDownState.resize.offset.y,\n      event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize(),\n    );\n\n    const frameElementsOffsetsMap = new Map<\n      string,\n      {\n        x: number;\n        y: number;\n      }\n    >();\n\n    selectedFrames.forEach((frame) => {\n      const elementsInFrame = getFrameChildren(\n        this.scene.getNonDeletedElements(),\n        frame.id,\n      );\n\n      elementsInFrame.forEach((element) => {\n        frameElementsOffsetsMap.set(frame.id + element.id, {\n          x: element.x - frame.x,\n          y: element.y - frame.y,\n        });\n      });\n    });\n\n    // check needed for avoiding flickering when a key gets pressed\n    // during dragging\n    if (!this.state.selectedElementsAreBeingDragged) {\n      const [gridX, gridY] = getGridPoint(\n        pointerCoords.x,\n        pointerCoords.y,\n        event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize(),\n      );\n\n      const dragOffset = {\n        x: gridX - pointerDownState.originInGrid.x,\n        y: gridY - pointerDownState.originInGrid.y,\n      };\n\n      const originalElements = [...pointerDownState.originalElements.values()];\n\n      this.maybeCacheReferenceSnapPoints(event, selectedElements);\n\n      const { snapOffset, snapLines } = snapResizingElements(\n        selectedElements,\n        getSelectedElements(originalElements, this.state),\n        this,\n        event,\n        dragOffset,\n        transformHandleType,\n      );\n\n      resizeX += snapOffset.x;\n      resizeY += snapOffset.y;\n\n      this.setState({\n        snapLines,\n      });\n    }\n\n    if (\n      transformElements(\n        pointerDownState.originalElements,\n        transformHandleType,\n        selectedElements,\n        this.scene,\n        shouldRotateWithDiscreteAngle(event),\n        shouldResizeFromCenter(event),\n        selectedElements.some((element) => isImageElement(element))\n          ? !shouldMaintainAspectRatio(event)\n          : shouldMaintainAspectRatio(event),\n        resizeX,\n        resizeY,\n        pointerDownState.resize.center.x,\n        pointerDownState.resize.center.y,\n      )\n    ) {\n      const suggestedBindings = getSuggestedBindingsForArrows(\n        selectedElements,\n        this.scene.getNonDeletedElementsMap(),\n        this.state.zoom,\n      );\n\n      const elementsToHighlight = new Set<ExcalidrawElement>();\n      selectedFrames.forEach((frame) => {\n        getElementsInResizingFrame(\n          this.scene.getNonDeletedElements(),\n          frame,\n          this.state,\n          this.scene.getNonDeletedElementsMap(),\n        ).forEach((element) => elementsToHighlight.add(element));\n      });\n\n      this.setState({\n        elementsToHighlight: [...elementsToHighlight],\n        suggestedBindings,\n      });\n\n      return true;\n    }\n    return false;\n  };\n\n  private getContextMenuItems = (\n    type: \"canvas\" | \"element\",\n  ): ContextMenuItems => {\n    const options: ContextMenuItems = [];\n\n    options.push(actionCopyAsPng, actionCopyAsSvg);\n\n    // canvas contextMenu\n    // -------------------------------------------------------------------------\n\n    if (type === \"canvas\") {\n      if (this.state.viewModeEnabled) {\n        return [\n          ...options,\n          actionToggleGridMode,\n          actionToggleZenMode,\n          actionToggleViewMode,\n          actionToggleStats,\n        ];\n      }\n\n      return [\n        actionPaste,\n        CONTEXT_MENU_SEPARATOR,\n        actionCopyAsPng,\n        actionCopyAsSvg,\n        copyText,\n        CONTEXT_MENU_SEPARATOR,\n        actionSelectAll,\n        actionUnlockAllElements,\n        CONTEXT_MENU_SEPARATOR,\n        actionToggleGridMode,\n        actionToggleObjectsSnapMode,\n        actionToggleZenMode,\n        actionToggleViewMode,\n        actionToggleStats,\n      ];\n    }\n\n    // element contextMenu\n    // -------------------------------------------------------------------------\n\n    options.push(copyText);\n\n    if (this.state.viewModeEnabled) {\n      return [actionCopy, ...options];\n    }\n\n    return [\n      CONTEXT_MENU_SEPARATOR,\n      actionCut,\n      actionCopy,\n      actionPaste,\n      CONTEXT_MENU_SEPARATOR,\n      actionSelectAllElementsInFrame,\n      actionRemoveAllElementsFromFrame,\n      actionWrapSelectionInFrame,\n      CONTEXT_MENU_SEPARATOR,\n      actionToggleCropEditor,\n      CONTEXT_MENU_SEPARATOR,\n      ...options,\n      CONTEXT_MENU_SEPARATOR,\n      actionCopyStyles,\n      actionPasteStyles,\n      CONTEXT_MENU_SEPARATOR,\n      actionGroup,\n      actionTextAutoResize,\n      actionUnbindText,\n      actionBindText,\n      actionWrapTextInContainer,\n      actionUngroup,\n      CONTEXT_MENU_SEPARATOR,\n      actionAddToLibrary,\n      CONTEXT_MENU_SEPARATOR,\n      actionSendBackward,\n      actionBringForward,\n      actionSendToBack,\n      actionBringToFront,\n      CONTEXT_MENU_SEPARATOR,\n      actionFlipHorizontal,\n      actionFlipVertical,\n      CONTEXT_MENU_SEPARATOR,\n      actionToggleLinearEditor,\n      CONTEXT_MENU_SEPARATOR,\n      actionLink,\n      actionCopyElementLink,\n      CONTEXT_MENU_SEPARATOR,\n      actionDuplicateSelection,\n      actionToggleElementLock,\n      CONTEXT_MENU_SEPARATOR,\n      actionDeleteSelected,\n    ];\n  };\n\n  private handleWheel = withBatchedUpdates(\n    (\n      event: WheelEvent | React.WheelEvent<HTMLDivElement | HTMLCanvasElement>,\n    ) => {\n      // if not scrolling on canvas/wysiwyg, ignore\n      if (\n        !(\n          event.target instanceof HTMLCanvasElement ||\n          event.target instanceof HTMLTextAreaElement ||\n          event.target instanceof HTMLIFrameElement\n        )\n      ) {\n        // prevent zooming the browser (but allow scrolling DOM)\n        if (event[KEYS.CTRL_OR_CMD]) {\n          event.preventDefault();\n        }\n\n        return;\n      }\n\n      event.preventDefault();\n\n      if (isPanning) {\n        return;\n      }\n\n      const { deltaX, deltaY } = event;\n      // note that event.ctrlKey is necessary to handle pinch zooming\n      if (event.metaKey || event.ctrlKey) {\n        const sign = Math.sign(deltaY);\n        const MAX_STEP = ZOOM_STEP * 100;\n        const absDelta = Math.abs(deltaY);\n        let delta = deltaY;\n        if (absDelta > MAX_STEP) {\n          delta = MAX_STEP * sign;\n        }\n\n        let newZoom = this.state.zoom.value - delta / 100;\n        // increase zoom steps the more zoomed-in we are (applies to >100% only)\n        newZoom +=\n          Math.log10(Math.max(1, this.state.zoom.value)) *\n          -sign *\n          // reduced amplification for small deltas (small movements on a trackpad)\n          Math.min(1, absDelta / 20);\n\n        this.translateCanvas((state) => ({\n          ...getStateForZoom(\n            {\n              viewportX: this.lastViewportPosition.x,\n              viewportY: this.lastViewportPosition.y,\n              nextZoom: getNormalizedZoom(newZoom),\n            },\n            state,\n          ),\n          shouldCacheIgnoreZoom: true,\n        }));\n        this.resetShouldCacheIgnoreZoomDebounced();\n        return;\n      }\n\n      // scroll horizontally when shift pressed\n      if (event.shiftKey) {\n        this.translateCanvas(({ zoom, scrollX }) => ({\n          // on Mac, shift+wheel tends to result in deltaX\n          scrollX: scrollX - (deltaY || deltaX) / zoom.value,\n        }));\n        return;\n      }\n\n      this.translateCanvas(({ zoom, scrollX, scrollY }) => ({\n        scrollX: scrollX - deltaX / zoom.value,\n        scrollY: scrollY - deltaY / zoom.value,\n      }));\n    },\n  );\n\n  private getTextWysiwygSnappedToCenterPosition(\n    x: number,\n    y: number,\n    appState: AppState,\n    container?: ExcalidrawTextContainer | null,\n  ) {\n    if (container) {\n      let elementCenterX = container.x + container.width / 2;\n      let elementCenterY = container.y + container.height / 2;\n\n      const elementCenter = getContainerCenter(\n        container,\n        appState,\n        this.scene.getNonDeletedElementsMap(),\n      );\n      if (elementCenter) {\n        elementCenterX = elementCenter.x;\n        elementCenterY = elementCenter.y;\n      }\n      const distanceToCenter = Math.hypot(\n        x - elementCenterX,\n        y - elementCenterY,\n      );\n      const isSnappedToCenter =\n        distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n          { sceneX: elementCenterX, sceneY: elementCenterY },\n          appState,\n        );\n        return { viewportX, viewportY, elementCenterX, elementCenterY };\n      }\n    }\n  }\n\n  private savePointer = (x: number, y: number, button: \"up\" | \"down\") => {\n    if (!x || !y) {\n      return;\n    }\n    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n      { clientX: x, clientY: y },\n      this.state,\n    );\n\n    if (isNaN(sceneX) || isNaN(sceneY)) {\n      // sometimes the pointer goes off screen\n    }\n\n    const pointer: CollaboratorPointer = {\n      x: sceneX,\n      y: sceneY,\n      tool: this.state.activeTool.type === \"laser\" ? \"laser\" : \"pointer\",\n    };\n\n    this.props.onPointerUpdate?.({\n      pointer,\n      button,\n      pointersMap: gesture.pointers,\n    });\n  };\n\n  private resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n    if (!this.unmounted) {\n      this.setState({ shouldCacheIgnoreZoom: false });\n    }\n  }, 300);\n\n  private updateDOMRect = (cb?: () => void) => {\n    if (this.excalidrawContainerRef?.current) {\n      const excalidrawContainer = this.excalidrawContainerRef.current;\n      const {\n        width,\n        height,\n        left: offsetLeft,\n        top: offsetTop,\n      } = excalidrawContainer.getBoundingClientRect();\n      const {\n        width: currentWidth,\n        height: currentHeight,\n        offsetTop: currentOffsetTop,\n        offsetLeft: currentOffsetLeft,\n      } = this.state;\n\n      if (\n        width === currentWidth &&\n        height === currentHeight &&\n        offsetLeft === currentOffsetLeft &&\n        offsetTop === currentOffsetTop\n      ) {\n        if (cb) {\n          cb();\n        }\n        return;\n      }\n\n      this.setState(\n        {\n          width,\n          height,\n          offsetLeft,\n          offsetTop,\n        },\n        () => {\n          cb && cb();\n        },\n      );\n    }\n  };\n\n  public refresh = () => {\n    this.setState({ ...this.getCanvasOffsets() });\n  };\n\n  private getCanvasOffsets(): Pick<AppState, \"offsetTop\" | \"offsetLeft\"> {\n    if (this.excalidrawContainerRef?.current) {\n      const excalidrawContainer = this.excalidrawContainerRef.current;\n      const { left, top } = excalidrawContainer.getBoundingClientRect();\n      return {\n        offsetLeft: left,\n        offsetTop: top,\n      };\n    }\n    return {\n      offsetLeft: 0,\n      offsetTop: 0,\n    };\n  }\n\n  private async updateLanguage() {\n    const currentLang =\n      languages.find((lang) => lang.code === this.props.langCode) ||\n      defaultLang;\n    await setLanguage(currentLang);\n    this.setAppState({});\n  }\n}\n\n// -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\ndeclare global {\n  interface Window {\n    h: {\n      scene: Scene;\n      elements: readonly ExcalidrawElement[];\n      state: AppState;\n      setState: React.Component<any, AppState>[\"setState\"];\n      app: InstanceType<typeof App>;\n      history: History;\n      store: Store;\n    };\n  }\n}\n\nexport const createTestHook = () => {\n  if (isTestEnv() || isDevEnv()) {\n    window.h = window.h || ({} as Window[\"h\"]);\n\n    Object.defineProperties(window.h, {\n      elements: {\n        configurable: true,\n        get() {\n          return this.app?.scene.getElementsIncludingDeleted();\n        },\n        set(elements: ExcalidrawElement[]) {\n          return this.app?.scene.replaceAllElements(\n            syncInvalidIndices(elements),\n          );\n        },\n      },\n      scene: {\n        configurable: true,\n        get() {\n          return this.app?.scene;\n        },\n      },\n    });\n  }\n};\n\ncreateTestHook();\nexport default App;\n",
    "import { KEYS, updateActiveTool } from \"@excalidraw/common\";\n\nimport { getNonDeletedElements } from \"@excalidraw/element\";\nimport { fixBindingsAfterDeletion } from \"@excalidraw/element\";\nimport { LinearElementEditor } from \"@excalidraw/element\";\nimport { newElementWith } from \"@excalidraw/element\";\nimport { getContainerElement } from \"@excalidraw/element\";\nimport {\n  isBoundToContainer,\n  isElbowArrow,\n  isFrameLikeElement,\n} from \"@excalidraw/element\";\nimport { getFrameChildren } from \"@excalidraw/element\";\n\nimport {\n  getElementsInGroup,\n  selectGroupsForSelectedElements,\n} from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { t } from \"../i18n\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { TrashIcon } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\n\nimport { register } from \"./register\";\n\nimport type { AppClassProperties, AppState } from \"../types\";\n\nconst deleteSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  app: AppClassProperties,\n) => {\n  const framesToBeDeleted = new Set(\n    getSelectedElements(\n      elements.filter((el) => isFrameLikeElement(el)),\n      appState,\n    ).map((el) => el.id),\n  );\n\n  const selectedElementIds: Record<ExcalidrawElement[\"id\"], true> = {};\n\n  const elementsMap = app.scene.getNonDeletedElementsMap();\n\n  const processedElements = new Set<ExcalidrawElement[\"id\"]>();\n\n  for (const frameId of framesToBeDeleted) {\n    const frameChildren = getFrameChildren(elements, frameId);\n    for (const el of frameChildren) {\n      if (processedElements.has(el.id)) {\n        continue;\n      }\n\n      if (isBoundToContainer(el)) {\n        const containerElement = getContainerElement(el, elementsMap);\n        if (containerElement) {\n          selectedElementIds[containerElement.id] = true;\n        }\n      } else {\n        selectedElementIds[el.id] = true;\n      }\n      processedElements.add(el.id);\n    }\n  }\n\n  let shouldSelectEditingGroup = true;\n\n  const nextElements = elements.map((el) => {\n    if (appState.selectedElementIds[el.id]) {\n      const boundElement = isBoundToContainer(el)\n        ? getContainerElement(el, elementsMap)\n        : null;\n\n      if (el.frameId && framesToBeDeleted.has(el.frameId)) {\n        shouldSelectEditingGroup = false;\n        selectedElementIds[el.id] = true;\n        return el;\n      }\n\n      if (\n        boundElement?.frameId &&\n        framesToBeDeleted.has(boundElement?.frameId)\n      ) {\n        return el;\n      }\n\n      if (el.boundElements) {\n        el.boundElements.forEach((candidate) => {\n          const bound = app.scene.getNonDeletedElementsMap().get(candidate.id);\n          if (bound && isElbowArrow(bound)) {\n            app.scene.mutateElement(bound, {\n              startBinding:\n                el.id === bound.startBinding?.elementId\n                  ? null\n                  : bound.startBinding,\n              endBinding:\n                el.id === bound.endBinding?.elementId ? null : bound.endBinding,\n            });\n          }\n        });\n      }\n      return newElementWith(el, { isDeleted: true });\n    }\n\n    // if deleting a frame, remove the children from it and select them\n    if (el.frameId && framesToBeDeleted.has(el.frameId)) {\n      shouldSelectEditingGroup = false;\n      if (!isBoundToContainer(el)) {\n        selectedElementIds[el.id] = true;\n      }\n      return newElementWith(el, { frameId: null });\n    }\n\n    if (isBoundToContainer(el) && appState.selectedElementIds[el.containerId]) {\n      return newElementWith(el, { isDeleted: true });\n    }\n    return el;\n  });\n\n  let nextEditingGroupId = appState.editingGroupId;\n\n  // select next eligible element in currently editing group or supergroup\n  if (shouldSelectEditingGroup && appState.editingGroupId) {\n    const elems = getElementsInGroup(\n      nextElements,\n      appState.editingGroupId,\n    ).filter((el) => !el.isDeleted);\n    if (elems.length > 1) {\n      if (elems[0]) {\n        selectedElementIds[elems[0].id] = true;\n      }\n    } else {\n      nextEditingGroupId = null;\n      if (elems[0]) {\n        selectedElementIds[elems[0].id] = true;\n      }\n\n      const lastElementInGroup = elems[0];\n      if (lastElementInGroup) {\n        const editingGroupIdx = lastElementInGroup.groupIds.findIndex(\n          (groupId) => {\n            return groupId === appState.editingGroupId;\n          },\n        );\n        const superGroupId = lastElementInGroup.groupIds[editingGroupIdx + 1];\n        if (superGroupId) {\n          const elems = getElementsInGroup(nextElements, superGroupId).filter(\n            (el) => !el.isDeleted,\n          );\n          if (elems.length > 1) {\n            nextEditingGroupId = superGroupId;\n\n            elems.forEach((el) => {\n              selectedElementIds[el.id] = true;\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    elements: nextElements,\n    appState: {\n      ...appState,\n      ...selectGroupsForSelectedElements(\n        {\n          selectedElementIds,\n          editingGroupId: nextEditingGroupId,\n        },\n        nextElements,\n        appState,\n        null,\n      ),\n    },\n  };\n};\n\nconst handleGroupEditingState = (\n  appState: AppState,\n  elements: readonly ExcalidrawElement[],\n): AppState => {\n  if (appState.editingGroupId) {\n    const siblingElements = getElementsInGroup(\n      getNonDeletedElements(elements),\n      appState.editingGroupId!,\n    );\n    if (siblingElements.length) {\n      return {\n        ...appState,\n        selectedElementIds: { [siblingElements[0].id]: true },\n      };\n    }\n  }\n  return appState;\n};\n\nexport const actionDeleteSelected = register({\n  name: \"deleteSelectedElements\",\n  label: \"labels.delete\",\n  icon: TrashIcon,\n  trackEvent: { category: \"element\", action: \"delete\" },\n  perform: (elements, appState, formData, app) => {\n    if (appState.editingLinearElement) {\n      const {\n        elementId,\n        selectedPointsIndices,\n        startBindingElement,\n        endBindingElement,\n      } = appState.editingLinearElement;\n      const elementsMap = app.scene.getNonDeletedElementsMap();\n      const element = LinearElementEditor.getElement(elementId, elementsMap);\n      if (!element) {\n        return false;\n      }\n      // case: no point selected → do nothing, as deleting the whole element\n      // is most likely a mistake, where you wanted to delete a specific point\n      // but failed to select it (or you thought it's selected, while it was\n      // only in a hover state)\n      if (selectedPointsIndices == null) {\n        return false;\n      }\n\n      // case: deleting last remaining point\n      if (element.points.length < 2) {\n        const nextElements = elements.map((el) => {\n          if (el.id === element.id) {\n            return newElementWith(el, { isDeleted: true });\n          }\n          return el;\n        });\n        const nextAppState = handleGroupEditingState(appState, nextElements);\n\n        return {\n          elements: nextElements,\n          appState: {\n            ...nextAppState,\n            editingLinearElement: null,\n          },\n          captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n        };\n      }\n\n      // We cannot do this inside `movePoint` because it is also called\n      // when deleting the uncommitted point (which hasn't caused any binding)\n      const binding = {\n        startBindingElement: selectedPointsIndices?.includes(0)\n          ? null\n          : startBindingElement,\n        endBindingElement: selectedPointsIndices?.includes(\n          element.points.length - 1,\n        )\n          ? null\n          : endBindingElement,\n      };\n\n      LinearElementEditor.deletePoints(element, app, selectedPointsIndices);\n\n      return {\n        elements,\n        appState: {\n          ...appState,\n          editingLinearElement: {\n            ...appState.editingLinearElement,\n            ...binding,\n            selectedPointsIndices:\n              selectedPointsIndices?.[0] > 0\n                ? [selectedPointsIndices[0] - 1]\n                : [0],\n          },\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    }\n\n    let { elements: nextElements, appState: nextAppState } =\n      deleteSelectedElements(elements, appState, app);\n\n    fixBindingsAfterDeletion(\n      nextElements,\n      nextElements.filter((el) => el.isDeleted),\n    );\n\n    nextAppState = handleGroupEditingState(nextAppState, nextElements);\n\n    return {\n      elements: nextElements,\n      appState: {\n        ...nextAppState,\n        activeTool: updateActiveTool(appState, { type: \"selection\" }),\n        multiElement: null,\n        activeEmbeddable: null,\n        selectedLinearElement: null,\n      },\n      captureUpdate: isSomeElementSelected(\n        getNonDeletedElements(elements),\n        appState,\n      )\n        ? CaptureUpdateAction.IMMEDIATELY\n        : CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  keyTest: (event, appState, elements) =>\n    (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) &&\n    !event[KEYS.CTRL_OR_CMD],\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={TrashIcon}\n      title={t(\"labels.delete\")}\n      aria-label={t(\"labels.delete\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n",
    "import { isDevEnv } from \"@excalidraw/common\";\n\nimport type { NestedKeyOf } from \"@excalidraw/common/utility-types\";\n\nimport { useAtomValue, editorJotaiStore, atom } from \"./editor-jotai\";\nimport fallbackLangData from \"./locales/en.json\";\nimport percentages from \"./locales/percentages.json\";\n\nconst COMPLETION_THRESHOLD = 85;\n\nexport interface Language {\n  code: string;\n  label: string;\n  rtl?: boolean;\n}\n\nexport type TranslationKeys = NestedKeyOf<typeof fallbackLangData>;\n\nexport const defaultLang = { code: \"en\", label: \"English\" };\n\nexport const languages: Language[] = [\n  defaultLang,\n  ...[\n    { code: \"ar-SA\", label: \"العربية\", rtl: true },\n    { code: \"bg-BG\", label: \"Български\" },\n    { code: \"ca-ES\", label: \"Català\" },\n    { code: \"cs-CZ\", label: \"Česky\" },\n    { code: \"de-DE\", label: \"Deutsch\" },\n    { code: \"el-GR\", label: \"Ελληνικά\" },\n    { code: \"es-ES\", label: \"Español\" },\n    { code: \"eu-ES\", label: \"Euskara\" },\n    { code: \"fa-IR\", label: \"فارسی\", rtl: true },\n    { code: \"fi-FI\", label: \"Suomi\" },\n    { code: \"fr-FR\", label: \"Français\" },\n    { code: \"gl-ES\", label: \"Galego\" },\n    { code: \"he-IL\", label: \"עברית\", rtl: true },\n    { code: \"hi-IN\", label: \"हिन्दी\" },\n    { code: \"hu-HU\", label: \"Magyar\" },\n    { code: \"id-ID\", label: \"Bahasa Indonesia\" },\n    { code: \"it-IT\", label: \"Italiano\" },\n    { code: \"ja-JP\", label: \"日本語\" },\n    { code: \"kab-KAB\", label: \"Taqbaylit\" },\n    { code: \"kk-KZ\", label: \"Қазақ тілі\" },\n    { code: \"ko-KR\", label: \"한국어\" },\n    { code: \"ku-TR\", label: \"Kurdî\" },\n    { code: \"lt-LT\", label: \"Lietuvių\" },\n    { code: \"lv-LV\", label: \"Latviešu\" },\n    { code: \"my-MM\", label: \"Burmese\" },\n    { code: \"nb-NO\", label: \"Norsk bokmål\" },\n    { code: \"nl-NL\", label: \"Nederlands\" },\n    { code: \"nn-NO\", label: \"Norsk nynorsk\" },\n    { code: \"oc-FR\", label: \"Occitan\" },\n    { code: \"pa-IN\", label: \"ਪੰਜਾਬੀ\" },\n    { code: \"pl-PL\", label: \"Polski\" },\n    { code: \"pt-BR\", label: \"Português Brasileiro\" },\n    { code: \"pt-PT\", label: \"Português\" },\n    { code: \"ro-RO\", label: \"Română\" },\n    { code: \"ru-RU\", label: \"Русский\" },\n    { code: \"sk-SK\", label: \"Slovenčina\" },\n    { code: \"sv-SE\", label: \"Svenska\" },\n    { code: \"sl-SI\", label: \"Slovenščina\" },\n    { code: \"tr-TR\", label: \"Türkçe\" },\n    { code: \"uk-UA\", label: \"Українська\" },\n    { code: \"zh-CN\", label: \"简体中文\" },\n    { code: \"zh-TW\", label: \"繁體中文\" },\n    { code: \"vi-VN\", label: \"Tiếng Việt\" },\n    { code: \"mr-IN\", label: \"मराठी\" },\n  ]\n    .filter(\n      (lang) =>\n        (percentages as Record<string, number>)[lang.code] >=\n        COMPLETION_THRESHOLD,\n    )\n    .sort((left, right) => (left.label > right.label ? 1 : -1)),\n];\n\nconst TEST_LANG_CODE = \"__test__\";\nif (isDevEnv()) {\n  languages.unshift(\n    { code: TEST_LANG_CODE, label: \"test language\" },\n    {\n      code: `${TEST_LANG_CODE}.rtl`,\n      label: \"\\u{202a}test language (rtl)\\u{202c}\",\n      rtl: true,\n    },\n  );\n}\n\nlet currentLang: Language = defaultLang;\nlet currentLangData = {};\n\nexport const setLanguage = async (lang: Language) => {\n  currentLang = lang;\n  document.documentElement.dir = currentLang.rtl ? \"rtl\" : \"ltr\";\n  document.documentElement.lang = currentLang.code;\n\n  if (lang.code.startsWith(TEST_LANG_CODE)) {\n    currentLangData = {};\n  } else {\n    try {\n      currentLangData = await import(`./locales/${currentLang.code}.json`);\n    } catch (error: any) {\n      console.error(`Failed to load language ${lang.code}:`, error.message);\n      currentLangData = fallbackLangData;\n    }\n  }\n\n  editorJotaiStore.set(editorLangCodeAtom, lang.code);\n};\n\nexport const getLanguage = () => currentLang;\n\nconst findPartsForData = (data: any, parts: string[]) => {\n  for (let index = 0; index < parts.length; ++index) {\n    const part = parts[index];\n    if (data[part] === undefined) {\n      return undefined;\n    }\n    data = data[part];\n  }\n  if (typeof data !== \"string\") {\n    return undefined;\n  }\n  return data;\n};\n\nexport const t = (\n  path: NestedKeyOf<typeof fallbackLangData>,\n  replacement?: { [key: string]: string | number } | null,\n  fallback?: string,\n) => {\n  if (currentLang.code.startsWith(TEST_LANG_CODE)) {\n    const name = replacement\n      ? `${path}(${JSON.stringify(replacement).slice(1, -1)})`\n      : path;\n    return `\\u{202a}[[${name}]]\\u{202c}`;\n  }\n\n  const parts = path.split(\".\");\n  let translation =\n    findPartsForData(currentLangData, parts) ||\n    findPartsForData(fallbackLangData, parts) ||\n    fallback;\n  if (translation === undefined) {\n    const errorMessage = `Can't find translation for ${path}`;\n    // in production, don't blow up the app on a missing translation key\n    if (import.meta.env.PROD) {\n      console.warn(errorMessage);\n      return \"\";\n    }\n    throw new Error(errorMessage);\n  }\n\n  if (replacement) {\n    for (const key in replacement) {\n      translation = translation.replace(`{{${key}}}`, String(replacement[key]));\n    }\n  }\n  return translation;\n};\n\n/** @private atom used solely to rerender components using `useI18n` hook */\nconst editorLangCodeAtom = atom(defaultLang.code);\n\n// Should be used in components that fall under these cases:\n// - component is rendered as an <Excalidraw> child\n// - component is rendered internally by <Excalidraw>, but the component\n//   is memoized w/o being updated on `langCode`, `AppState`, or `UIAppState`\nexport const useI18n = () => {\n  const langCode = useAtomValue(editorLangCodeAtom);\n  return { t, langCode };\n};\n",
    "// eslint-disable-next-line no-restricted-imports\nimport {\n  atom,\n  createStore,\n  type PrimitiveAtom,\n  type WritableAtom,\n} from \"jotai\";\nimport { createIsolation } from \"jotai-scope\";\n\nconst jotai = createIsolation();\n\nexport { atom, PrimitiveAtom, WritableAtom };\nexport const { useAtom, useSetAtom, useAtomValue, useStore } = jotai;\nexport const EditorJotaiProvider: ReturnType<\n  typeof createIsolation\n>[\"Provider\"] = jotai.Provider;\n\nexport const editorJotaiStore: ReturnType<typeof createStore> = createStore();\n",
    "//\n// All icons are imported from https://fontawesome.com/icons?d=gallery\n// Icons are under the license https://fontawesome.com/license\n//\n\n// Note: when adding new icons, review https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/RTL_Guidelines\n// to determine whether or not the icons should be mirrored in right-to-left languages.\n\nimport clsx from \"clsx\";\nimport oc from \"open-color\";\nimport React from \"react\";\n\nimport { THEME } from \"@excalidraw/common\";\n\nimport type { Theme } from \"@excalidraw/element/types\";\n\nexport const iconFillColor = (theme: Theme) => \"var(--icon-fill-color)\";\n\nconst handlerColor = (theme: Theme) =>\n  theme === THEME.LIGHT ? oc.white : \"#1e1e1e\";\n\ntype Opts = {\n  width?: number;\n  height?: number;\n  mirror?: true;\n} & React.SVGProps<SVGSVGElement>;\n\nexport const createIcon = (\n  d: string | React.ReactNode,\n  opts: number | Opts = 512,\n) => {\n  const {\n    width = 512,\n    height = width,\n    mirror,\n    style,\n    ...rest\n  } = typeof opts === \"number\" ? ({ width: opts } as Opts) : opts;\n  return (\n    <svg\n      aria-hidden=\"true\"\n      focusable=\"false\"\n      role=\"img\"\n      viewBox={`0 0 ${width} ${height}`}\n      className={clsx({ \"rtl-mirror\": mirror })}\n      style={style}\n      {...rest}\n    >\n      {typeof d === \"string\" ? <path fill=\"currentColor\" d={d} /> : d}\n    </svg>\n  );\n};\n\nconst tablerIconProps: Opts = {\n  width: 24,\n  height: 24,\n  fill: \"none\",\n  strokeWidth: 2,\n  stroke: \"currentColor\",\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n} as const;\n\nconst modifiedTablerIconProps: Opts = {\n  width: 20,\n  height: 20,\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\",\n} as const;\n\n// -----------------------------------------------------------------------------\n\n// tabler-icons: present\nexport const PlusPromoIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <rect x={3} y={8} width={18} height={4} rx={1} />\n    <line x1={12} y1={8} x2={12} y2={21} />\n    <path d=\"M19 12v7a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-7\" />\n    <path d=\"M7.5 8a2.5 2.5 0 0 1 0 -5a4.8 8 0 0 1 4.5 5a4.8 8 0 0 1 4.5 -5a2.5 2.5 0 0 1 0 5\" />\n  </g>,\n  tablerIconProps,\n);\n\n// tabler-icons: book\nexport const LibraryIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0\" />\n    <path d=\"M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0\" />\n    <line x1=\"3\" y1=\"6\" x2=\"3\" y2=\"19\" />\n    <line x1=\"12\" y1=\"6\" x2=\"12\" y2=\"19\" />\n    <line x1=\"21\" y1=\"6\" x2=\"21\" y2=\"19\" />\n  </g>,\n  tablerIconProps,\n);\n\n// tabler-icons: plus\nexport const PlusIcon = createIcon(\n  <svg strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\" />\n    <line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\" />\n  </svg>,\n  tablerIconProps,\n);\n\n// tabler-icons: dots-vertical\nexport const DotsIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <circle cx=\"12\" cy=\"12\" r=\"1\"></circle>\n    <circle cx=\"12\" cy=\"19\" r=\"1\"></circle>\n    <circle cx=\"12\" cy=\"5\" r=\"1\"></circle>\n  </g>,\n  tablerIconProps,\n);\n\n// tabler-icons: pinned\nexport const PinIcon = createIcon(\n  <svg strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M9 4v6l-2 4v2h10v-2l-2 -4v-6\"></path>\n    <line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"21\"></line>\n    <line x1=\"8\" y1=\"4\" x2=\"16\" y2=\"4\"></line>\n  </svg>,\n  tablerIconProps,\n);\n\nexport const polygonIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M12 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0\" />\n    <path d=\"M19 8m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0\" />\n    <path d=\"M5 11m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0\" />\n    <path d=\"M15 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0\" />\n    <path d=\"M6.5 9.5l3.5 -3\" />\n    <path d=\"M14 5.5l3 1.5\" />\n    <path d=\"M18.5 10l-2.5 7\" />\n    <path d=\"M13.5 17.5l-7 -5\" />\n  </g>,\n  tablerIconProps,\n);\n\n// tabler-icons: lock-open (via Figma)\nexport const UnlockedIcon = createIcon(\n  <g>\n    <path\n      d=\"M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z\"\n      stroke=\"currentColor\"\n      strokeWidth=\"1.25\"\n    />\n    <path\n      d=\"M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z\"\n      stroke=\"currentColor\"\n      strokeWidth=\"1.25\"\n    />\n    <mask\n      id=\"UnlockedIcon\"\n      style={{ maskType: \"alpha\" }}\n      maskUnits=\"userSpaceOnUse\"\n      x={6}\n      y={1}\n      width={9}\n      height={9}\n    >\n      <path\n        stroke=\"none\"\n        d=\"M6.399 9.561V5.175c0-.93.401-1.823 1.116-2.48a3.981 3.981 0 0 1 2.693-1.028c1.01 0 1.98.37 2.694 1.027.715.658 1.116 1.55 1.116 2.481\"\n        fill=\"#fff\"\n      />\n    </mask>\n    <g mask=\"url(#UnlockedIcon)\">\n      <path\n        stroke=\"none\"\n        d=\"M5.149 9.561v1.25h2.5v-1.25h-2.5Zm5.06-7.894V.417v1.25Zm2.559 3.508v1.25h2.5v-1.25h-2.5ZM7.648 8.51V5.175h-2.5V8.51h2.5Zm0-3.334c0-.564.243-1.128.713-1.561L6.668 1.775c-.959.883-1.52 2.104-1.52 3.4h2.5Zm.713-1.561a2.732 2.732 0 0 1 1.847-.697v-2.5c-1.31 0-2.585.478-3.54 1.358L8.36 3.614Zm1.847-.697c.71 0 1.374.26 1.847.697l1.694-1.839a5.231 5.231 0 0 0-3.54-1.358v2.5Zm1.847.697c.47.433.713.997.713 1.561h2.5c0-1.296-.56-2.517-1.52-3.4l-1.693 1.839Z\"\n        fill=\"currentColor\"\n      />\n    </g>\n  </g>,\n  modifiedTablerIconProps,\n);\n\n// tabler-icons: lock (via Figma)\nexport const LockedIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path d=\"M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z\" />\n    <path d=\"M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z\" />\n    <path d=\"M6.667 8.333V5.417C6.667 3.806 8.159 2.5 10 2.5c1.841 0 3.333 1.306 3.333 2.917v2.916\" />\n  </g>,\n  modifiedTablerIconProps,\n);\n\nexport const LockedIconFilled = createIcon(\n  <g fill=\"currentColor\">\n    <path d=\"M12 2a5 5 0 0 1 5 5v3a3 3 0 0 1 3 3v6a3 3 0 0 1 -3 3h-10a3 3 0 0 1 -3 -3v-6a3 3 0 0 1 3 -3v-3a5 5 0 0 1 5 -5m0 12a2 2 0 0 0 -1.995 1.85l-.005 .15a2 2 0 1 0 2 -2m0 -10a3 3 0 0 0 -3 3v3h6v-3a3 3 0 0 0 -3 -3\" />\n  </g>,\n  {\n    width: 24,\n    height: 24,\n  },\n);\n\n// custom\nexport const WelcomeScreenMenuArrow = createIcon(\n  <>\n    <path\n      d=\"M38.5 83.5c-14-2-17.833-10.473-21-22.5C14.333 48.984 12 22 12 12.5\"\n      stroke=\"currentColor\"\n      strokeWidth={2}\n      strokeLinecap=\"round\"\n    />\n    <path\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n      d=\"m12.005 10.478 7.905 14.423L6 25.75l6.005-15.273Z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"M12.005 10.478c1.92 3.495 3.838 7 7.905 14.423m-7.905-14.423c3.11 5.683 6.23 11.368 7.905 14.423m0 0c-3.68.226-7.35.455-13.91.85m13.91-.85c-5.279.33-10.566.647-13.91.85m0 0c1.936-4.931 3.882-9.86 6.005-15.273M6 25.75c2.069-5.257 4.135-10.505 6.005-15.272\"\n      stroke=\"currentColor\"\n      strokeWidth={2}\n      strokeLinecap=\"round\"\n    />\n  </>,\n  { width: 41, height: 94, fill: \"none\" },\n);\n\n// custom\nexport const WelcomeScreenHelpArrow = createIcon(\n  <>\n    <path\n      d=\"M18.026 1.232c-5.268 13.125-5.548 33.555 3.285 42.311 8.823 8.75 33.31 12.304 42.422 13.523\"\n      stroke=\"currentColor\"\n      strokeWidth={2}\n      strokeLinecap=\"round\"\n    />\n    <path\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n      d=\"m72.181 59.247-13.058-10-2.948 13.62 16.006-3.62Z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"M72.181 59.247c-3.163-2.429-6.337-4.856-13.058-10m13.058 10c-5.145-3.936-10.292-7.882-13.058-10m0 0c-.78 3.603-1.563 7.196-2.948 13.62m2.948-13.62c-1.126 5.168-2.24 10.346-2.948 13.62m0 0c5.168-1.166 10.334-2.343 16.006-3.62m-16.006 3.62c5.51-1.248 11.01-2.495 16.006-3.62\"\n      stroke=\"currentColor\"\n      strokeWidth={2}\n      strokeLinecap=\"round\"\n    />\n  </>,\n  { width: 85, height: 71, fill: \"none\" },\n);\n\n// custom\nexport const WelcomeScreenTopToolbarArrow = createIcon(\n  <>\n    <path\n      d=\"M1 77c14-2 31.833-11.973 35-24 3.167-12.016-6-35-9.5-43.5\"\n      stroke=\"currentColor\"\n      strokeWidth={2}\n      strokeLinecap=\"round\"\n    />\n    <path\n      fillRule=\"evenodd\"\n      clipRule=\"evenodd\"\n      d=\"m24.165 1.093-2.132 16.309 13.27-4.258-11.138-12.05Z\"\n      fill=\"currentColor\"\n    />\n    <path\n      d=\"M24.165 1.093c-.522 3.953-1.037 7.916-2.132 16.309m2.131-16.309c-.835 6.424-1.68 12.854-2.13 16.308m0 0c3.51-1.125 7.013-2.243 13.27-4.257m-13.27 4.257c5.038-1.608 10.08-3.232 13.27-4.257m0 0c-3.595-3.892-7.197-7.777-11.14-12.05m11.14 12.05c-3.837-4.148-7.667-8.287-11.14-12.05\"\n      stroke=\"currentColor\"\n      strokeWidth={2}\n      strokeLinecap=\"round\"\n    />\n  </>,\n  { width: 38, height: 78, fill: \"none\" },\n);\n\n// custom\nexport const ExcalLogo = createIcon(\n  <g fill=\"currentColor\">\n    <path\n      d=\"M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z\"\n      fill=\"currentColor\"\n    />\n  </g>,\n  { width: 40, height: 40, fill: \"none\" },\n);\n\n// custom\nexport const SelectionIcon = createIcon(\n  <g stroke=\"currentColor\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M6 6l4.153 11.793a0.365 .365 0 0 0 .331 .207a0.366 .366 0 0 0 .332 -.207l2.184 -4.793l4.787 -1.994a0.355 .355 0 0 0 .213 -.323a0.355 .355 0 0 0 -.213 -.323l-11.787 -4.36z\" />\n    <path d=\"M13.5 13.5l4.5 4.5\" />\n  </g>,\n  { fill: \"none\", width: 22, height: 22, strokeWidth: 1.25 },\n);\n\nexport const LassoIcon = createIcon(\n  <g\n    stroke=\"currentColor\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n    strokeWidth={1.5}\n  >\n    <path d=\"M4.028 13.252c-.657 -.972 -1.028 -2.078 -1.028 -3.252c0 -3.866 4.03 -7 9 -7s9 3.134 9 7s-4.03 7 -9 7c-1.913 0 -3.686 -.464 -5.144 -1.255\" />\n    <path d=\"M5 15m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0\" />\n    <path d=\"M5 17c0 1.42 .316 2.805 1 4\" />\n  </g>,\n\n  { fill: \"none\", width: 22, height: 22, strokeWidth: 1.25 },\n);\n\n// tabler-icons: square\nexport const RectangleIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <rect x=\"4\" y=\"4\" width=\"16\" height=\"16\" rx=\"2\"></rect>\n  </g>,\n  tablerIconProps,\n);\n\n// tabler-icons: square-rotated\nexport const DiamondIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M10.5 20.4l-6.9 -6.9c-.781 -.781 -.781 -2.219 0 -3l6.9 -6.9c.781 -.781 2.219 -.781 3 0l6.9 6.9c.781 .781 .781 2.219 0 3l-6.9 6.9c-.781 .781 -2.219 .781 -3 0z\" />\n  </g>,\n\n  tablerIconProps,\n);\n\n// tabler-icons: circle\nexport const EllipseIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <circle cx=\"12\" cy=\"12\" r=\"9\"></circle>\n  </g>,\n\n  tablerIconProps,\n);\n\n// tabler-icons: arrow-narrow-right\nexport const ArrowIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\" />\n    <line x1=\"15\" y1=\"16\" x2=\"19\" y2=\"12\" />\n    <line x1=\"15\" y1=\"8\" x2=\"19\" y2=\"12\" />\n  </g>,\n  tablerIconProps,\n);\n\n// custom?\nexport const LineIcon = createIcon(\n  <path d=\"M4.167 10h11.666\" strokeWidth=\"1.5\" />,\n  modifiedTablerIconProps,\n);\n\nexport const PenModeIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M20 17v-12c0 -1.121 -.879 -2 -2 -2s-2 .879 -2 2v12l2 2l2 -2z\"></path>\n    <path d=\"M16 7h4\"></path>\n    <path d=\"M18 19h-13a2 2 0 1 1 0 -4h4a2 2 0 1 0 0 -4h-3\"></path>\n  </g>,\n  tablerIconProps,\n);\n\n// modified tabler-icons: pencil\nexport const FreedrawIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path\n      clipRule=\"evenodd\"\n      d=\"m7.643 15.69 7.774-7.773a2.357 2.357 0 1 0-3.334-3.334L4.31 12.357a3.333 3.333 0 0 0-.977 2.357v1.953h1.953c.884 0 1.732-.352 2.357-.977Z\"\n    />\n    <path d=\"m11.25 5.417 3.333 3.333\" />\n  </g>,\n\n  modifiedTablerIconProps,\n);\n\n// tabler-icons: typography\nexport const TextIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <line x1=\"4\" y1=\"20\" x2=\"7\" y2=\"20\" />\n    <line x1=\"14\" y1=\"20\" x2=\"21\" y2=\"20\" />\n    <line x1=\"6.9\" y1=\"15\" x2=\"13.8\" y2=\"15\" />\n    <line x1=\"10.2\" y1=\"6.3\" x2=\"16\" y2=\"20\" />\n    <polyline points=\"5 20 11 4 13 4 20 20\"></polyline>\n  </g>,\n  tablerIconProps,\n);\n\n// modified tabler-icons: photo\nexport const ImageIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path d=\"M12.5 6.667h.01\" />\n    <path d=\"M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z\" />\n    <path d=\"m3.333 12.5 3.334-3.333c.773-.745 1.726-.745 2.5 0l4.166 4.166\" />\n    <path d=\"m11.667 11.667.833-.834c.774-.744 1.726-.744 2.5 0l1.667 1.667\" />\n  </g>,\n  modifiedTablerIconProps,\n);\n\n// tabler-icons: eraser\nexport const EraserIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M19 20h-10.5l-4.21 -4.3a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9.2 9.3\" />\n    <path d=\"M18 13.3l-6.3 -6.3\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const ZoomInIcon = createIcon(\n  <path strokeWidth=\"1.25\" d=\"M10 4.167v11.666M4.167 10h11.666\" />,\n  modifiedTablerIconProps,\n);\n\nexport const ZoomOutIcon = createIcon(\n  <path d=\"M5 10h10\" strokeWidth=\"1.25\" />,\n  modifiedTablerIconProps,\n);\n\nexport const ZoomResetIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M21 21l-6 -6\" />\n    <path d=\"M3.268 12.043a7.017 7.017 0 0 0 6.634 4.957a7.012 7.012 0 0 0 7.043 -6.131a7 7 0 0 0 -5.314 -7.672a7.021 7.021 0 0 0 -8.241 4.403\" />\n    <path d=\"M3 4v4h4\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const TrashIcon = createIcon(\n  <path\n    strokeWidth=\"1.25\"\n    d=\"M3.333 5.833h13.334M8.333 9.167v5M11.667 9.167v5M4.167 5.833l.833 10c0 .92.746 1.667 1.667 1.667h6.666c.92 0 1.667-.746 1.667-1.667l.833-10M7.5 5.833v-2.5c0-.46.373-.833.833-.833h3.334c.46 0 .833.373.833.833v2.5\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const EmbedIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <polyline points=\"12 16 18 10 12 4\" />\n    <polyline points=\"8 4 2 10 8 16\" />\n  </g>,\n  modifiedTablerIconProps,\n);\n\nexport const DuplicateIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path d=\"M14.375 6.458H8.958a2.5 2.5 0 0 0-2.5 2.5v5.417a2.5 2.5 0 0 0 2.5 2.5h5.417a2.5 2.5 0 0 0 2.5-2.5V8.958a2.5 2.5 0 0 0-2.5-2.5Z\" />\n    <path\n      clipRule=\"evenodd\"\n      d=\"M11.667 3.125c.517 0 .986.21 1.325.55.34.338.55.807.55 1.325v1.458H8.333c-.485 0-.927.185-1.26.487-.343.312-.57.75-.609 1.24l-.005 5.357H5a1.87 1.87 0 0 1-1.326-.55 1.87 1.87 0 0 1-.549-1.325V5c0-.518.21-.987.55-1.326.338-.34.807-.549 1.325-.549h6.667Z\"\n    />\n  </g>,\n  modifiedTablerIconProps,\n);\n\nexport const MoonIcon = createIcon(\n  <path\n    clipRule=\"evenodd\"\n    d=\"M10 2.5h.328a6.25 6.25 0 0 0 6.6 10.372A7.5 7.5 0 1 1 10 2.493V2.5Z\"\n    stroke=\"currentColor\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const SunIcon = createIcon(\n  <g stroke=\"currentColor\" strokeLinejoin=\"round\">\n    <path d=\"M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM10 4.167V2.5M14.167 5.833l1.166-1.166M15.833 10H17.5M14.167 14.167l1.166 1.166M10 15.833V17.5M5.833 14.167l-1.166 1.166M5 10H3.333M5.833 5.833 4.667 4.667\" />\n  </g>,\n  { ...modifiedTablerIconProps, strokeWidth: 1.5 },\n);\n\nexport const HamburgerMenuIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <line x1=\"4\" y1=\"6\" x2=\"20\" y2=\"6\"></line>\n    <line x1=\"4\" y1=\"12\" x2=\"20\" y2=\"12\"></line>\n    <line x1=\"4\" y1=\"18\" x2=\"20\" y2=\"18\"></line>\n  </g>,\n  tablerIconProps,\n);\n\nexport const ExportIcon = createIcon(\n  <path\n    strokeWidth=\"1.25\"\n    d=\"M3.333 14.167v1.666c0 .92.747 1.667 1.667 1.667h10c.92 0 1.667-.746 1.667-1.667v-1.666M5.833 9.167 10 13.333l4.167-4.166M10 3.333v10\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const HelpIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <circle cx=\"12\" cy=\"12\" r=\"9\"></circle>\n    <line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"17.01\"></line>\n    <path d=\"M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4\"></path>\n  </g>,\n  tablerIconProps,\n);\n\nexport const HelpIconThin = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <circle cx=\"12\" cy=\"12\" r=\"9\"></circle>\n    <line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"17.01\"></line>\n    <path d=\"M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4\"></path>\n  </g>,\n  tablerIconProps,\n);\n\nexport const ExternalLinkIcon = createIcon(\n  <path\n    strokeWidth=\"1.25\"\n    d=\"M9.167 5.833H5.833c-1.254 0-2.5 1.282-2.5 2.5v5.834c0 1.283 1.252 2.5 2.5 2.5h5.834c1.251 0 2.5-1.25 2.5-2.5v-3.334M8.333 11.667l8.334-8.334M12.5 3.333h4.167V7.5\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const GithubIcon = createIcon(\n  <path\n    d=\"M7.5 15.833c-3.583 1.167-3.583-2.083-5-2.5m10 4.167v-2.917c0-.833.083-1.166-.417-1.666 2.334-.25 4.584-1.167 4.584-5a3.833 3.833 0 0 0-1.084-2.667 3.5 3.5 0 0 0-.083-2.667s-.917-.25-2.917 1.084a10.25 10.25 0 0 0-5.166 0C5.417 2.333 4.5 2.583 4.5 2.583a3.5 3.5 0 0 0-.083 2.667 3.833 3.833 0 0 0-1.084 2.667c0 3.833 2.25 4.75 4.584 5-.5.5-.5 1-.417 1.666V17.5\"\n    strokeWidth=\"1.25\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const DiscordIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path d=\"M7.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM12.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM6.25 6.25c2.917-.833 4.583-.833 7.5 0M5.833 13.75c2.917.833 5.417.833 8.334 0\" />\n    <path d=\"M12.917 14.167c0 .833 1.25 2.5 1.666 2.5 1.25 0 2.361-1.39 2.917-2.5.556-1.39.417-4.861-1.25-9.584-1.214-.846-2.5-1.116-3.75-1.25l-.833 2.084M7.083 14.167c0 .833-1.13 2.5-1.526 2.5-1.191 0-2.249-1.39-2.778-2.5-.529-1.39-.397-4.861 1.19-9.584 1.157-.846 2.318-1.116 3.531-1.25l.833 2.084\" />\n  </g>,\n  modifiedTablerIconProps,\n);\n\nexport const XBrandIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M4 4l11.733 16h4.267l-11.733 -16z\" />\n    <path d=\"M4 20l6.768 -6.768m2.46 -2.46l6.772 -6.772\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const checkIcon = createIcon(\n  <polyline fill=\"none\" stroke=\"currentColor\" points=\"20 6 9 17 4 12\" />,\n  {\n    width: 24,\n    height: 24,\n  },\n);\n\nexport const LinkIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path d=\"M8.333 11.667a2.917 2.917 0 0 0 4.167 0l3.333-3.334a2.946 2.946 0 1 0-4.166-4.166l-.417.416\" />\n    <path d=\"M11.667 8.333a2.917 2.917 0 0 0-4.167 0l-3.333 3.334a2.946 2.946 0 0 0 4.166 4.166l.417-.416\" />\n  </g>,\n  modifiedTablerIconProps,\n);\n\nexport const save = createIcon(\n  \"M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z\",\n  { width: 448, height: 512 },\n);\n\nexport const saveAs = createIcon(\n  \"M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z\",\n  { width: 448, height: 512 },\n);\n\n// tabler-icon: folder\nexport const LoadIcon = createIcon(\n  <path\n    d=\"m9.257 6.351.183.183H15.819c.34 0 .727.182 1.051.506.323.323.505.708.505 1.05v5.819c0 .316-.183.7-.52 1.035-.337.338-.723.522-1.037.522H4.182c-.352 0-.74-.181-1.058-.5-.318-.318-.499-.705-.499-1.057V5.182c0-.351.181-.736.5-1.054.32-.321.71-.503 1.057-.503H6.53l2.726 2.726Z\"\n    strokeWidth=\"1.25\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const clipboard = createIcon(\n  \"M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z\",\n  { width: 384, height: 512 },\n);\n\nexport const palette = createIcon(\n  \"M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z\",\n);\n\nexport const bucketFillIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M5 16l1.465 1.638a2 2 0 1 1 -3.015 .099l1.55 -1.737z\" />\n    <path d=\"M13.737 9.737c2.299 -2.3 3.23 -5.095 2.081 -6.245c-1.15 -1.15 -3.945 -.217 -6.244 2.082c-2.3 2.299 -3.231 5.095 -2.082 6.244c1.15 1.15 3.946 .218 6.245 -2.081z\" />\n    <path d=\"M7.492 11.818c.362 .362 .768 .676 1.208 .934l6.895 4.047c1.078 .557 2.255 -.075 3.692 -1.512c1.437 -1.437 2.07 -2.614 1.512 -3.692c-.372 -.718 -1.72 -3.017 -4.047 -6.895a6.015 6.015 0 0 0 -.934 -1.208\" />\n  </g>,\n  tablerIconProps,\n);\n\n// simple / icon\nexport const slashIcon = createIcon(\n  <g strokeWidth={1.5}>\n    <path d=\"M6 18l12 -12\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const ExportImageIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M15 8h.01\"></path>\n    <path d=\"M12 20h-5a3 3 0 0 1 -3 -3v-10a3 3 0 0 1 3 -3h10a3 3 0 0 1 3 3v5\"></path>\n    <path d=\"M4 15l4 -4c.928 -.893 2.072 -.893 3 0l4 4\"></path>\n    <path d=\"M14 14l1 -1c.617 -.593 1.328 -.793 2.009 -.598\"></path>\n    <path d=\"M19 16v6\"></path>\n    <path d=\"M22 19l-3 3l-3 -3\"></path>\n  </g>,\n  tablerIconProps,\n);\n\nexport const exportToFileIcon = createIcon(\n  \"M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z\",\n  { width: 512, height: 512 },\n);\n\nexport const zoomIn = createIcon(\n  \"M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z\",\n  { width: 448, height: 512 },\n);\n\nexport const zoomOut = createIcon(\n  \"M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z\",\n  { width: 448, height: 512 },\n);\n\nexport const done = createIcon(\n  \"M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z\",\n);\n\nexport const menu = createIcon(\n  \"M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z\",\n);\n\nexport const UndoIcon = createIcon(\n  <path\n    d=\"M7.5 10.833 4.167 7.5 7.5 4.167M4.167 7.5h9.166a3.333 3.333 0 0 1 0 6.667H12.5\"\n    strokeWidth=\"1.25\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const RedoIcon = createIcon(\n  <path\n    d=\"M12.5 10.833 15.833 7.5 12.5 4.167M15.833 7.5H6.667a3.333 3.333 0 1 0 0 6.667H7.5\"\n    strokeWidth=\"1.25\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const questionCircle = createIcon(\n  \"M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z\",\n  { mirror: true },\n);\n\nexport const share = createIcon(\n  <path\n    d=\"M5 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 7.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 17.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM7.25 8.917l5.5-2.834M7.25 11.083l5.5 2.834\"\n    strokeWidth=\"1.5\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const warning = createIcon(\n  \"M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z\",\n);\n\nexport const shareIOS = createIcon(\n  \"M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.11 0-2-.9-2-2V10c0-1.11.89-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .89 2 2z\",\n  { width: 24, height: 24 },\n);\n\nexport const exportToPlus = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1\" />\n    <path d=\"M12 14v-11\" />\n    <path d=\"M9 6l3 -3l3 3\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const shareWindows = createIcon(\n  <>\n    <path\n      fill=\"currentColor\"\n      d=\"M40 5.6v6.1l-4.1.7c-8.9 1.4-16.5 6.9-20.6 15C13 32 10.9 43 12.4 43c.4 0 2.4-1.3 4.4-3 5-3.9 12.1-7 18.2-7.7l5-.6v12.8l11.2-11.3L62.5 22 51.2 10.8 40-.5v6.1zm10.2 22.6L44 34.5v-6.8l-6.9.6c-3.9.3-9.8 1.7-13.2 3.1-3.5 1.4-6.5 2.4-6.7 2.2-.9-1 3-7.5 6.4-10.8C28 18.6 34.4 16 40.1 16c3.7 0 3.9-.1 3.9-3.2V9.5l6.2 6.3 6.3 6.2-6.3 6.2z\"\n    />\n    <path\n      stroke=\"currentColor\"\n      fill=\"currentColor\"\n      d=\"M0 36v20h48v-6.2c0-6 0-6.1-2-4.3-1.1 1-2 2.9-2 4.2V52H4V34c0-17.3-.1-18-2-18s-2 .7-2 20z\"\n    />\n  </>,\n  { width: 64, height: 64 },\n);\n\n// Icon imported form Storybook\n// Storybook is licensed under MIT https://github.com/storybookjs/storybook/blob/next/LICENSE\nexport const resetZoom = createIcon(\n  <path\n    stroke=\"currentColor\"\n    strokeWidth=\"40\"\n    fill=\"currentColor\"\n    d=\"M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z\"\n  />,\n  { width: 1024 },\n);\n\nconst arrowBarToTopJSX = (\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M12 10l0 10\" />\n    <path d=\"M12 10l4 4\" />\n    <path d=\"M12 10l-4 4\" />\n    <path d=\"M4 4l16 0\" />\n  </g>\n);\n\nconst arrownNarrowUpJSX = (\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M12 5l0 14\" />\n    <path d=\"M16 9l-4 -4\" />\n    <path d=\"M8 9l4 -4\" />\n  </g>\n);\n\nexport const BringForwardIcon = createIcon(arrownNarrowUpJSX, tablerIconProps);\n\nexport const SendBackwardIcon = createIcon(arrownNarrowUpJSX, {\n  ...tablerIconProps,\n  style: {\n    transform: \"rotate(180deg)\",\n  },\n});\n\nexport const BringToFrontIcon = createIcon(arrowBarToTopJSX, tablerIconProps);\n\nexport const SendToBackIcon = createIcon(arrowBarToTopJSX, {\n  ...tablerIconProps,\n  style: {\n    transform: \"rotate(180deg)\",\n  },\n});\n\n//\n// Align action icons created from scratch to match those of z-index actions\n// Note: vertical align icons are flipped so the larger item is always the\n// first one the user sees. Horizontal align icons should not be flipped since\n// that would make them lie about their function.\n//\nexport const AlignTopIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\" stroke=\"currentColor\" strokeWidth=\"1.25\">\n      <path\n        d=\"M3.333 3.333h13.334\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path d=\"M13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v7.083c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V8.125c0-.92-.746-1.667-1.666-1.667ZM6.875 6.458h-.417c-.92 0-1.666.747-1.666 1.667v3.75c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667v-3.75c0-.92-.747-1.667-1.667-1.667Z\" />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const AlignBottomIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\" stroke=\"currentColor\" strokeWidth=\"1.25\">\n      <path\n        d=\"M3.333 16.667h13.334\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path d=\"M6.875 3.125h-.417c-.92 0-1.666.746-1.666 1.667v7.083c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667V4.792c0-.92-.747-1.667-1.667-1.667ZM13.542 5.817h-.417c-.92 0-1.667.747-1.667 1.667v4.391c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V7.484c0-.92-.746-1.667-1.666-1.667Z\" />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const AlignLeftIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\" stroke=\"currentColor\" strokeWidth=\"1.25\">\n      <path\n        d=\"M3.333 3.333v13.334\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path d=\"M15.208 4.792H8.125c-.92 0-1.667.746-1.667 1.666v.417c0 .92.747 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM12.516 11.458H8.125c-.92 0-1.667.746-1.667 1.667v.417c0 .92.747 1.666 1.667 1.666h4.391c.92 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.667-1.667Z\" />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const AlignRightIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\" stroke=\"currentColor\" strokeWidth=\"1.25\">\n      <path\n        d=\"M16.667 3.333v13.334\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path d=\"M11.875 4.792H4.792c-.92 0-1.667.746-1.667 1.666v.417c0 .92.746 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM11.683 11.458H7.292c-.92 0-1.667.746-1.667 1.667v.417c0 .92.746 1.666 1.667 1.666h4.39c.921 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.666-1.667Z\" />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const DistributeHorizontallyIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\" stroke=\"currentColor\" strokeWidth=\"1.25\">\n      <path\n        d=\"M16.667 3.333v13.334M3.333 3.333v13.334\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path d=\"M14.375 10.208v-.416c0-.92-.746-1.667-1.667-1.667H7.292c-.92 0-1.667.746-1.667 1.667v.416c0 .92.746 1.667 1.667 1.667h5.416c.92 0 1.667-.746 1.667-1.667Z\" />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const DistributeVerticallyIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\" stroke=\"currentColor\" strokeWidth=\"1.25\">\n      <path\n        d=\"M3.333 3.333h13.334M3.333 16.667h13.334\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n      <path d=\"M10.208 5.625h-.416c-.92 0-1.667.746-1.667 1.667v5.416c0 .92.746 1.667 1.667 1.667h.416c.92 0 1.667-.746 1.667-1.667V7.292c0-.92-.746-1.667-1.667-1.667Z\" />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const CenterVerticallyIcon = createIcon(\n  <g stroke=\"currentColor\" strokeWidth=\"1.25\">\n    <path d=\"M1.667 10h2.916\" strokeLinecap=\"round\" strokeLinejoin=\"round\" />\n    <path d=\"M8.333 10h3.334\" strokeLinejoin=\"round\" />\n    <path d=\"M15.417 10h2.916\" strokeLinecap=\"round\" strokeLinejoin=\"round\" />\n    <path d=\"M6.875 4.792h-.417c-.92 0-1.666.746-1.666 1.666v7.084c0 .92.746 1.666 1.666 1.666h.417c.92 0 1.667-.746 1.667-1.666V6.458c0-.92-.747-1.666-1.667-1.666ZM13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v3.75c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667v-3.75c0-.92-.746-1.667-1.666-1.667Z\" />\n  </g>,\n  modifiedTablerIconProps,\n);\n\nexport const CenterHorizontallyIcon = createIcon(\n  <g stroke=\"currentColor\" strokeWidth=\"1.25\">\n    <path d=\"M10 18.333v-2.916\" strokeLinecap=\"round\" strokeLinejoin=\"round\" />\n    <path d=\"M10 11.667V8.333\" strokeLinejoin=\"round\" />\n    <path d=\"M10 4.583V1.667\" strokeLinecap=\"round\" strokeLinejoin=\"round\" />\n    <path d=\"M4.792 13.125v.417c0 .92.746 1.666 1.666 1.666h7.084c.92 0 1.666-.746 1.666-1.666v-.417c0-.92-.746-1.667-1.666-1.667H6.458c-.92 0-1.666.746-1.666 1.667ZM6.458 6.458v.417c0 .92.747 1.667 1.667 1.667h3.75c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666h-3.75c-.92 0-1.667.746-1.667 1.666Z\" />\n  </g>,\n  modifiedTablerIconProps,\n);\n\nexport const usersIcon = createIcon(\n  <g strokeWidth=\"1.5\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <circle cx=\"9\" cy=\"7\" r=\"4\"></circle>\n    <path d=\"M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2\"></path>\n    <path d=\"M16 3.13a4 4 0 0 1 0 7.75\"></path>\n    <path d=\"M21 21v-2a4 4 0 0 0 -3 -3.85\"></path>\n  </g>,\n  tablerIconProps,\n);\n\n// not mirrored because it's inspired by a playback control, which is always RTL\nexport const start = createIcon(\n  \"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z\",\n);\n\nexport const stop = createIcon(\n  \"M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z\",\n);\n\nexport const CloseIcon = createIcon(\n  <>\n    <g\n      clipPath=\"url(#a)\"\n      stroke=\"currentColor\"\n      strokeWidth=\"1.25\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <path d=\"M15 5 5 15M5 5l10 10\" />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const clone = createIcon(\n  \"M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z\",\n  { mirror: true },\n);\n\n// modified https://feathericons.com/?query=shield\nexport const shield = createIcon(\n  \"M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z\",\n  { width: 24 },\n);\n\nexport const file = createIcon(\n  \"M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm32-48h224V288l-23.5-23.5c-4.7-4.7-12.3-4.7-17 0L176 352l-39.5-39.5c-4.7-4.7-12.3-4.7-17 0L80 352v64zm48-240c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48z\",\n  { width: 384, height: 512 },\n);\n\n// TODO barnabasmolnar/editor-redesign\n// couldn't find a new icon for this\nexport const GroupIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path d=\"M25 26H111V111H25\" fill={iconFillColor(theme)} />\n      <path\n        d=\"M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z\"\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <path d=\"M100 100H160V160H100\" fill={iconFillColor(theme)} />\n      <path\n        d=\"M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z\"\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <g\n        fill={handlerColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"6\"\n      >\n        <rect x=\"2.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n        <rect x=\"2.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n        <rect x=\"147.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n        <rect x=\"147.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n      </g>\n    </>,\n    { width: 182, height: 182, mirror: true },\n  ),\n);\n\nexport const UngroupIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <>\n      <path d=\"M25 26H111V111H25\" fill={iconFillColor(theme)} />\n      <path\n        d=\"M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z\"\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <path d=\"M100 100H160V160H100\" fill={iconFillColor(theme)} />\n      <path\n        d=\"M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z\"\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"2\"\n      />\n      <g\n        fill={handlerColor(theme)}\n        stroke={iconFillColor(theme)}\n        strokeWidth=\"6\"\n      >\n        <rect x=\"2.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n        <rect x=\"78.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n        <rect x=\"147.5\" y=\"149.5\" width=\"30\" height=\"30\" />\n        <rect x=\"147.5\" y=\"78.5\" width=\"30\" height=\"30\" />\n        <rect x=\"105.5\" y=\"2.5\" width=\"30\" height=\"30\" />\n        <rect x=\"2.5\" y=\"102.5\" width=\"30\" height=\"30\" />\n      </g>\n    </>,\n    { width: 182, height: 182, mirror: true },\n  ),\n);\n\nexport const FillZigZagIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path d=\"M5.879 2.625h8.242a3.27 3.27 0 0 1 3.254 3.254v8.242a3.27 3.27 0 0 1-3.254 3.254H5.88a3.27 3.27 0 0 1-3.254-3.254V5.88A3.27 3.27 0 0 1 5.88 2.626l-.001-.001ZM4.518 16.118l7.608-12.83m.198 13.934 5.051-9.897M2.778 9.675l9.348-6.387m-7.608 12.83 12.857-8.793\" />\n  </g>,\n  modifiedTablerIconProps,\n);\n\nexport const FillHachureIcon = createIcon(\n  <>\n    <path\n      d=\"M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z\"\n      stroke=\"currentColor\"\n      strokeWidth=\"1.25\"\n    />\n    <mask\n      id=\"FillHachureIcon\"\n      style={{ maskType: \"alpha\" }}\n      maskUnits=\"userSpaceOnUse\"\n      x={2}\n      y={2}\n      width={16}\n      height={16}\n    >\n      <path\n        d=\"M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z\"\n        fill=\"currentColor\"\n        stroke=\"currentColor\"\n        strokeWidth=\"1.25\"\n      />\n    </mask>\n    <g mask=\"url(#FillHachureIcon)\">\n      <path\n        d=\"M2.258 15.156 15.156 2.258M7.324 20.222 20.222 7.325m-20.444 5.35L12.675-.222m-8.157 18.34L17.416 5.22\"\n        stroke=\"currentColor\"\n        strokeWidth=\"1.25\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n    </g>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const FillCrossHatchIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\">\n      <path\n        d=\"M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z\"\n        stroke=\"currentColor\"\n        strokeWidth=\"1.25\"\n      />\n      <mask\n        id=\"FillCrossHatchIcon\"\n        style={{ maskType: \"alpha\" }}\n        maskUnits=\"userSpaceOnUse\"\n        x={-1}\n        y={-1}\n        width={22}\n        height={22}\n      >\n        <path\n          d=\"M2.426 15.044 15.044 2.426M7.383 20 20 7.383M0 12.617 12.617 0m-7.98 17.941L17.256 5.324m-2.211 12.25L2.426 4.956M20 12.617 7.383 0m5.234 20L0 7.383m17.941 7.98L5.324 2.745\"\n          stroke=\"currentColor\"\n          strokeWidth=\"1.25\"\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n        />\n      </mask>\n      <g mask=\"url(#FillCrossHatchIcon)\">\n        <path\n          d=\"M14.121 2H5.88A3.879 3.879 0 0 0 2 5.879v8.242A3.879 3.879 0 0 0 5.879 18h8.242A3.879 3.879 0 0 0 18 14.121V5.88A3.879 3.879 0 0 0 14.121 2Z\"\n          fill=\"currentColor\"\n        />\n      </g>\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const FillSolidIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\">\n      <path\n        d=\"M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z\"\n        stroke=\"currentColor\"\n        strokeWidth=\"1.25\"\n      />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  { ...modifiedTablerIconProps, fill: \"currentColor\" },\n);\n\nexport const StrokeWidthBaseIcon = createIcon(\n  <>\n    <path\n      d=\"M4.167 10h11.666\"\n      stroke=\"currentColor\"\n      strokeWidth=\"1.25\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    />\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const StrokeWidthBoldIcon = createIcon(\n  <path\n    d=\"M5 10h10\"\n    stroke=\"currentColor\"\n    strokeWidth=\"2.5\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const StrokeWidthExtraBoldIcon = createIcon(\n  <path\n    d=\"M5 10h10\"\n    stroke=\"currentColor\"\n    strokeWidth=\"3.75\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const StrokeStyleSolidIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <path\n      d=\"M6 10H34\"\n      stroke={iconFillColor(theme)}\n      strokeWidth={2}\n      fill=\"none\"\n      strokeLinecap=\"round\"\n    />,\n    {\n      width: 40,\n      height: 20,\n    },\n  ),\n);\n\nexport const StrokeStyleDashedIcon = createIcon(\n  <g strokeWidth=\"2\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M5 12h2\" />\n    <path d=\"M17 12h2\" />\n    <path d=\"M11 12h2\" />\n  </g>,\n  tablerIconProps,\n);\n\n// tabler-icons: line-dotted\nexport const StrokeStyleDottedIcon = createIcon(\n  <g strokeWidth=\"2\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M4 12v.01\" />\n    <path d=\"M8 12v.01\" />\n    <path d=\"M12 12v.01\" />\n    <path d=\"M16 12v.01\" />\n    <path d=\"M20 12v.01\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const SloppinessArchitectIcon = createIcon(\n  <path\n    d=\"M2.5 12.038c1.655-.885 5.9-3.292 8.568-4.354 2.668-1.063.101 2.821 1.32 3.104 1.218.283 5.112-1.814 5.112-1.814\"\n    strokeWidth=\"1.25\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const SloppinessArtistIcon = createIcon(\n  <path\n    d=\"M2.5 12.563c1.655-.886 5.9-3.293 8.568-4.355 2.668-1.062.101 2.822 1.32 3.105 1.218.283 5.112-1.814 5.112-1.814m-13.469 2.23c2.963-1.586 6.13-5.62 7.468-4.998 1.338.623-1.153 4.11-.132 5.595 1.02 1.487 6.133-1.43 6.133-1.43\"\n    strokeWidth=\"1.25\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const SloppinessCartoonistIcon = createIcon(\n  <path\n    d=\"M2.5 11.936c1.737-.879 8.627-5.346 10.42-5.268 1.795.078-.418 5.138.345 5.736.763.598 3.53-1.789 4.235-2.147M2.929 9.788c1.164-.519 5.47-3.28 6.987-3.114 1.519.165 1 3.827 2.121 4.109 1.122.281 3.839-2.016 4.606-2.42\"\n    strokeWidth=\"1.25\"\n  />,\n  modifiedTablerIconProps,\n);\n\nexport const EdgeSharpIcon = createIcon(\n  <svg strokeWidth=\"1.5\">\n    <path d=\"M3.33334 9.99998V6.66665C3.33334 6.04326 3.33403 4.9332 3.33539 3.33646C4.95233 3.33436 6.06276 3.33331 6.66668 3.33331H10\" />\n    <path d=\"M13.3333 3.33331V3.34331\" />\n    <path d=\"M16.6667 3.33331V3.34331\" />\n    <path d=\"M16.6667 6.66669V6.67669\" />\n    <path d=\"M16.6667 10V10.01\" />\n    <path d=\"M3.33334 13.3333V13.3433\" />\n    <path d=\"M16.6667 13.3333V13.3433\" />\n    <path d=\"M3.33334 16.6667V16.6767\" />\n    <path d=\"M6.66666 16.6667V16.6767\" />\n    <path d=\"M10 16.6667V16.6767\" />\n    <path d=\"M13.3333 16.6667V16.6767\" />\n    <path d=\"M16.6667 16.6667V16.6767\" />\n  </svg>,\n  modifiedTablerIconProps,\n);\n\n// tabler-icons: border-radius\nexport const EdgeRoundIcon = createIcon(\n  <g\n    strokeWidth=\"1.5\"\n    stroke=\"currentColor\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n  >\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M4 12v-4a4 4 0 0 1 4 -4h4\" />\n    <line x1=\"16\" y1=\"4\" x2=\"16\" y2=\"4.01\" />\n    <line x1=\"20\" y1=\"4\" x2=\"20\" y2=\"4.01\" />\n    <line x1=\"20\" y1=\"8\" x2=\"20\" y2=\"8.01\" />\n    <line x1=\"20\" y1=\"12\" x2=\"20\" y2=\"12.01\" />\n    <line x1=\"4\" y1=\"16\" x2=\"4\" y2=\"16.01\" />\n    <line x1=\"20\" y1=\"16\" x2=\"20\" y2=\"16.01\" />\n    <line x1=\"4\" y1=\"20\" x2=\"4\" y2=\"20.01\" />\n    <line x1=\"8\" y1=\"20\" x2=\"8\" y2=\"20.01\" />\n    <line x1=\"12\" y1=\"20\" x2=\"12\" y2=\"20.01\" />\n    <line x1=\"16\" y1=\"20\" x2=\"16\" y2=\"20.01\" />\n    <line x1=\"20\" y1=\"20\" x2=\"20\" y2=\"20.01\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const ArrowheadNoneIcon = createIcon(\n  <g stroke=\"currentColor\" opacity={0.3} strokeWidth={2}>\n    <path d=\"M12 12l9 0\" />\n    <path d=\"M3 9l6 6\" />\n    <path d=\"M3 15l6 -6\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const ArrowheadArrowIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n        stroke=\"currentColor\"\n        strokeWidth={2}\n        fill=\"none\"\n      >\n        <path d=\"M34 10H6M34 10L27 5M34 10L27 15\" />\n        <path d=\"M27.5 5L34.5 10L27.5 15\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadCircleIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke=\"currentColor\"\n        fill=\"currentColor\"\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n      >\n        <path d=\"M32 10L6 10\" strokeWidth={2} />\n        <circle r=\"4\" transform=\"matrix(-1 0 0 1 30 10)\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadCircleOutlineIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke=\"currentColor\"\n        fill=\"none\"\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n        strokeWidth={2}\n      >\n        <path d=\"M26 10L6 10\" />\n        <circle r=\"4\" transform=\"matrix(-1 0 0 1 30 10)\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadBarIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}>\n        <path\n          d=\"M34 10H5.99996M34 10L34 5M34 10L34 15\"\n          stroke=\"currentColor\"\n          strokeWidth={2}\n          fill=\"none\"\n        />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadTriangleIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke=\"currentColor\"\n        fill=\"currentColor\"\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n      >\n        <path d=\"M32 10L6 10\" strokeWidth={2} />\n        <path d=\"M27.5 5.5L34.5 10L27.5 14.5L27.5 5.5\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadTriangleOutlineIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke=\"currentColor\"\n        fill=\"none\"\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n        strokeWidth={2}\n        strokeLinejoin=\"round\"\n      >\n        <path d=\"M6,9.5H27\" />\n        <path d=\"M27,5L34,10L27,14Z\" fill=\"none\" />\n      </g>,\n\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadDiamondIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke=\"currentColor\"\n        fill=\"currentColor\"\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n        strokeLinejoin=\"round\"\n        strokeWidth={2}\n      >\n        <path d=\"M6,9.5H20\" />\n        <path d=\"M27,5L34,10L27,14L20,9.5Z\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadDiamondOutlineIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke=\"currentColor\"\n        fill=\"none\"\n        transform={flip ? \"translate(40, 0) scale(-1, 1)\" : \"\"}\n        strokeLinejoin=\"round\"\n        strokeWidth={2}\n      >\n        <path d=\"M6,9.5H20\" />\n        <path d=\"M27,5L34,10L27,14L20,9.5Z\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadCrowfootIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke=\"currentColor\"\n        fill=\"none\"\n        transform={flip ? \"\" : \"translate(40, 0) scale(-1, 1)\"}\n        strokeLinejoin=\"round\"\n        strokeWidth={2}\n      >\n        <path d=\"M34,10 H6 M15,10 L7,5 M15,10 L7,15\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadCrowfootOneIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke=\"currentColor\"\n        fill=\"none\"\n        transform={flip ? \"\" : \"translate(40, 0) scale(-1, 1)\"}\n        strokeLinejoin=\"round\"\n        strokeWidth={2}\n      >\n        <path d=\"M34,10 H6 M15,10 L15,15 L15,5\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const ArrowheadCrowfootOneOrManyIcon = React.memo(\n  ({ flip = false }: { flip?: boolean }) =>\n    createIcon(\n      <g\n        stroke=\"currentColor\"\n        fill=\"none\"\n        transform={flip ? \"\" : \"translate(40, 0) scale(-1, 1)\"}\n        strokeLinejoin=\"round\"\n        strokeWidth={2}\n      >\n        <path d=\"M34,10 H6 M15,10 L15,16 L15,4 M15,10 L7,5 M15,10 L7,15\" />\n      </g>,\n      { width: 40, height: 20 },\n    ),\n);\n\nexport const FontSizeSmallIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\">\n      <path\n        d=\"M14.167 6.667a3.333 3.333 0 0 0-3.334-3.334H9.167a3.333 3.333 0 0 0 0 6.667h1.666a3.333 3.333 0 0 1 0 6.667H9.167a3.333 3.333 0 0 1-3.334-3.334\"\n        stroke=\"currentColor\"\n        strokeWidth=\"1.25\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const FontSizeMediumIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\">\n      <path\n        d=\"M5 16.667V3.333L10 15l5-11.667v13.334\"\n        stroke=\"currentColor\"\n        strokeWidth=\"1.25\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const FontSizeLargeIcon = createIcon(\n  <>\n    <g clipPath=\"url(#a)\">\n      <path\n        d=\"M5.833 3.333v13.334h8.334\"\n        stroke=\"currentColor\"\n        strokeWidth=\"1.25\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const FontSizeExtraLargeIcon = createIcon(\n  <>\n    <path\n      d=\"m1.667 3.333 6.666 13.334M8.333 3.333 1.667 16.667M11.667 3.333v13.334h6.666\"\n      stroke=\"currentColor\"\n      strokeWidth=\"1.25\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    />\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const fontSizeIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M3 7v-2h13v2\" />\n    <path d=\"M10 5v14\" />\n    <path d=\"M12 19h-4\" />\n    <path d=\"M15 13v-1h6v1\" />\n    <path d=\"M18 12v7\" />\n    <path d=\"M17 19h2\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const FontFamilyHeadingIcon = createIcon(\n  <>\n    <g\n      stroke=\"currentColor\"\n      strokeWidth=\"1.25\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M7 12h10\" />\n      <path d=\"M7 5v14\" />\n      <path d=\"M17 5v14\" />\n      <path d=\"M15 19h4\" />\n      <path d=\"M15 5h4\" />\n      <path d=\"M5 19h4\" />\n      <path d=\"M5 5h4\" />\n    </g>\n  </>,\n  tablerIconProps,\n);\n\nexport const FontFamilyNormalIcon = createIcon(\n  <>\n    <g\n      stroke=\"currentColor\"\n      strokeWidth=\"1.25\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <path d=\"M5.833 16.667v-10a3.333 3.333 0 0 1 3.334-3.334h1.666a3.333 3.333 0 0 1 3.334 3.334v10M5.833 10.833h8.334\" />\n    </g>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const FontFamilyCodeIcon = createIcon(\n  <>\n    <g\n      clipPath=\"url(#a)\"\n      stroke=\"currentColor\"\n      strokeWidth=\"1.25\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <path d=\"M5.833 6.667 2.5 10l3.333 3.333M14.167 6.667 17.5 10l-3.333 3.333M11.667 3.333 8.333 16.667\" />\n    </g>\n    <defs>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M0 0h20v20H0z\" />\n      </clipPath>\n    </defs>\n  </>,\n  modifiedTablerIconProps,\n);\n\nexport const TextAlignLeftIcon = createIcon(\n  <g\n    stroke=\"currentColor\"\n    fill=\"none\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n    strokeWidth={2}\n  >\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <line x1=\"4\" y1=\"8\" x2=\"20\" y2=\"8\" />\n    <line x1=\"4\" y1=\"12\" x2=\"12\" y2=\"12\" />\n    <line x1=\"4\" y1=\"16\" x2=\"16\" y2=\"16\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const TextAlignCenterIcon = createIcon(\n  <g\n    stroke=\"currentColor\"\n    fill=\"none\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n  >\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <line x1=\"4\" y1=\"8\" x2=\"20\" y2=\"8\" />\n    <line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\" />\n    <line x1=\"6\" y1=\"16\" x2=\"18\" y2=\"16\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const TextAlignRightIcon = createIcon(\n  <g\n    stroke=\"currentColor\"\n    fill=\"none\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n  >\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <line x1=\"4\" y1=\"8\" x2=\"20\" y2=\"8\" />\n    <line x1=\"10\" y1=\"12\" x2=\"20\" y2=\"12\" />\n    <line x1=\"8\" y1=\"16\" x2=\"20\" y2=\"16\" />\n  </g>,\n  tablerIconProps,\n);\n\n// tabler-icons: layout-align-top\nexport const TextAlignTopIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <g\n      strokeWidth=\"1.5\"\n      stroke=\"currentColor\"\n      fill=\"none\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <line x1=\"4\" y1=\"4\" x2=\"20\" y2=\"4\" />\n      <rect x=\"9\" y=\"8\" width=\"6\" height=\"12\" rx=\"2\" />\n    </g>,\n    tablerIconProps,\n  ),\n);\n\n// tabler-icons: layout-align-bottom\nexport const TextAlignBottomIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <g\n      strokeWidth=\"2\"\n      stroke=\"currentColor\"\n      fill=\"none\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <line x1=\"4\" y1=\"20\" x2=\"20\" y2=\"20\" />\n      <rect x=\"9\" y=\"4\" width=\"6\" height=\"12\" rx=\"2\"></rect>\n    </g>,\n    tablerIconProps,\n  ),\n);\n\n// tabler-icons: layout-align-middle\nexport const TextAlignMiddleIcon = React.memo(({ theme }: { theme: Theme }) =>\n  createIcon(\n    <g\n      strokeWidth=\"1.5\"\n      stroke=\"currentColor\"\n      fill=\"none\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <line x1=\"4\" y1=\"12\" x2=\"9\" y2=\"12\" />\n      <line x1=\"15\" y1=\"12\" x2=\"20\" y2=\"12\" />\n      <rect x=\"9\" y=\"6\" width=\"6\" height=\"12\" rx=\"2\" />\n    </g>,\n    tablerIconProps,\n  ),\n);\n\nexport const angleIcon = createIcon(\n  <g>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M21 19h-18l9 -15\" />\n    <path d=\"M20.615 15.171h.015\" />\n    <path d=\"M19.515 11.771h.015\" />\n    <path d=\"M17.715 8.671h.015\" />\n    <path d=\"M15.415 5.971h.015\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const publishIcon = createIcon(\n  <path\n    d=\"M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zM393.4 288H328v112c0 8.8-7.2 16-16 16h-48c-8.8 0-16-7.2-16-16V288h-65.4c-14.3 0-21.4-17.2-11.3-27.3l105.4-105.4c6.2-6.2 16.4-6.2 22.6 0l105.4 105.4c10.1 10.1 2.9 27.3-11.3 27.3z\"\n    fill=\"currentColor\"\n  />,\n  { width: 640, height: 512 },\n);\n\nexport const eraser = createIcon(\n  <path d=\"M480 416C497.7 416 512 430.3 512 448C512 465.7 497.7 480 480 480H150.6C133.7 480 117.4 473.3 105.4 461.3L25.37 381.3C.3786 356.3 .3786 315.7 25.37 290.7L258.7 57.37C283.7 32.38 324.3 32.38 349.3 57.37L486.6 194.7C511.6 219.7 511.6 260.3 486.6 285.3L355.9 416H480zM265.4 416L332.7 348.7L195.3 211.3L70.63 336L150.6 416L265.4 416z\" />,\n);\n\nexport const handIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M8 13v-7.5a1.5 1.5 0 0 1 3 0v6.5\"></path>\n    <path d=\"M11 5.5v-2a1.5 1.5 0 1 1 3 0v8.5\"></path>\n    <path d=\"M14 5.5a1.5 1.5 0 0 1 3 0v6.5\"></path>\n    <path d=\"M17 7.5a1.5 1.5 0 0 1 3 0v8.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47\"></path>\n  </g>,\n  tablerIconProps,\n);\n\nexport const downloadIcon = createIcon(\n  <>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2\"></path>\n    <path d=\"M7 11l5 5l5 -5\"></path>\n    <path d=\"M12 4l0 12\"></path>\n  </>,\n  tablerIconProps,\n);\n\nexport const copyIcon = createIcon(\n  <>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z\"></path>\n    <path d=\"M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2\"></path>\n  </>,\n  tablerIconProps,\n);\n\nexport const cutIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M7 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0\" />\n    <path d=\"M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0\" />\n    <path d=\"M9.15 14.85l8.85 -10.85\" />\n    <path d=\"M6 4l8.85 10.85\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const helpIcon = createIcon(\n  <>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0\"></path>\n    <path d=\"M12 17l0 .01\"></path>\n    <path d=\"M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4\"></path>\n  </>,\n  tablerIconProps,\n);\n\nexport const playerPlayIcon = createIcon(\n  <>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M7 4v16l13 -8z\"></path>\n  </>,\n  tablerIconProps,\n);\n\nexport const playerStopFilledIcon = createIcon(\n  <>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path\n      d=\"M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z\"\n      strokeWidth=\"0\"\n      fill=\"currentColor\"\n    ></path>\n  </>,\n  tablerIconProps,\n);\n\nexport const tablerCheckIcon = createIcon(\n  <>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M5 12l5 5l10 -10\"></path>\n  </>,\n  tablerIconProps,\n);\n\nexport const alertTriangleIcon = createIcon(\n  <>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M10.24 3.957l-8.422 14.06a1.989 1.989 0 0 0 1.7 2.983h16.845a1.989 1.989 0 0 0 1.7 -2.983l-8.423 -14.06a1.989 1.989 0 0 0 -3.4 0z\" />\n    <path d=\"M12 9v4\" />\n    <path d=\"M12 17h.01\" />\n  </>,\n  tablerIconProps,\n);\n\nexport const eyeDropperIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M11 7l6 6\"></path>\n    <path d=\"M4 16l11.7 -11.7a1 1 0 0 1 1.4 0l2.6 2.6a1 1 0 0 1 0 1.4l-11.7 11.7h-4v-4z\"></path>\n  </g>,\n  tablerIconProps,\n);\n\nexport const extraToolsIcon = createIcon(\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M12 3l-4 7h8z\"></path>\n    <path d=\"M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0\"></path>\n    <path d=\"M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z\"></path>\n  </g>,\n  tablerIconProps,\n);\n\nexport const frameToolIcon = createIcon(\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"></path>\n    <path d=\"M4 7l16 0\"></path>\n    <path d=\"M4 17l16 0\"></path>\n    <path d=\"M7 4l0 16\"></path>\n    <path d=\"M17 4l0 16\"></path>\n  </g>,\n  tablerIconProps,\n);\n\nexport const mermaidLogoIcon = createIcon(\n  <path\n    fill=\"currentColor\"\n    d=\"M407.48,111.18C335.587,108.103 269.573,152.338 245.08,220C220.587,152.338 154.573,108.103 82.68,111.18C80.285,168.229 107.577,222.632 154.74,254.82C178.908,271.419 193.35,298.951 193.27,328.27L193.27,379.13L296.9,379.13L296.9,328.27C296.816,298.953 311.255,271.42 335.42,254.82C382.596,222.644 409.892,168.233 407.48,111.18Z\"\n  />,\n);\n\nexport const ArrowRightIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path d=\"M4.16602 10H15.8327\" />\n    <path d=\"M12.5 13.3333L15.8333 10\" />\n    <path d=\"M12.5 6.66666L15.8333 9.99999\" />\n  </g>,\n  modifiedTablerIconProps,\n);\n\nexport const laserPointerToolIcon = createIcon(\n  <g\n    fill=\"none\"\n    stroke=\"currentColor\"\n    strokeWidth=\"1.25\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n    transform=\"rotate(90 10 10)\"\n  >\n    <path\n      clipRule=\"evenodd\"\n      d=\"m9.644 13.69 7.774-7.773a2.357 2.357 0 0 0-3.334-3.334l-7.773 7.774L8 12l1.643 1.69Z\"\n    />\n    <path d=\"m13.25 3.417 3.333 3.333M10 10l2-2M5 15l3-3M2.156 17.894l1-1M5.453 19.029l-.144-1.407M2.377 11.887l.866 1.118M8.354 17.273l-1.194-.758M.953 14.652l1.408.13\" />\n  </g>,\n\n  20,\n);\n\nexport const MagicIcon = createIcon(\n  <g stroke=\"currentColor\" fill=\"none\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" />\n    <path d=\"M6 21l15 -15l-3 -3l-15 15l3 3\" />\n    <path d=\"M15 6l3 3\" />\n    <path d=\"M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2\" />\n    <path d=\"M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const MagicIconThin = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" />\n    <path d=\"M6 21l15 -15l-3 -3l-15 15l3 3\" />\n    <path d=\"M15 6l3 3\" />\n    <path d=\"M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2\" />\n    <path d=\"M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const OpenAIIcon = createIcon(\n  <g stroke=\"currentColor\" fill=\"none\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M11.217 19.384a3.501 3.501 0 0 0 6.783 -1.217v-5.167l-6 -3.35\" />\n    <path d=\"M5.214 15.014a3.501 3.501 0 0 0 4.446 5.266l4.34 -2.534v-6.946\" />\n    <path d=\"M6 7.63c-1.391 -.236 -2.787 .395 -3.534 1.689a3.474 3.474 0 0 0 1.271 4.745l4.263 2.514l6 -3.348\" />\n    <path d=\"M12.783 4.616a3.501 3.501 0 0 0 -6.783 1.217v5.067l6 3.45\" />\n    <path d=\"M18.786 8.986a3.501 3.501 0 0 0 -4.446 -5.266l-4.34 2.534v6.946\" />\n    <path d=\"M18 16.302c1.391 .236 2.787 -.395 3.534 -1.689a3.474 3.474 0 0 0 -1.271 -4.745l-4.308 -2.514l-5.955 3.42\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const fullscreenIcon = createIcon(\n  <g stroke=\"currentColor\" fill=\"none\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M4 8v-2a2 2 0 0 1 2 -2h2\" />\n    <path d=\"M4 16v2a2 2 0 0 0 2 2h2\" />\n    <path d=\"M16 4h2a2 2 0 0 1 2 2v2\" />\n    <path d=\"M16 20h2a2 2 0 0 0 2 -2v-2\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const eyeIcon = createIcon(\n  <g stroke=\"currentColor\" fill=\"none\" strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0\" />\n    <path d=\"M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const eyeClosedIcon = createIcon(\n  <g stroke=\"currentColor\" fill=\"none\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M10.585 10.587a2 2 0 0 0 2.829 2.828\" />\n    <path d=\"M16.681 16.673a8.717 8.717 0 0 1 -4.681 1.327c-3.6 0 -6.6 -2 -9 -6c1.272 -2.12 2.712 -3.678 4.32 -4.674m2.86 -1.146a9.055 9.055 0 0 1 1.82 -.18c3.6 0 6.6 2 9 6c-.666 1.11 -1.379 2.067 -2.138 2.87\" />\n    <path d=\"M3 3l18 18\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const brainIcon = createIcon(\n  <g stroke=\"currentColor\" fill=\"none\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8\" />\n    <path d=\"M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8\" />\n    <path d=\"M17.5 16a3.5 3.5 0 0 0 0 -7h-.5\" />\n    <path d=\"M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0\" />\n    <path d=\"M6.5 16a3.5 3.5 0 0 1 0 -7h.5\" />\n    <path d=\"M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const brainIconThin = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8\" />\n    <path d=\"M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8\" />\n    <path d=\"M17.5 16a3.5 3.5 0 0 0 0 -7h-.5\" />\n    <path d=\"M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0\" />\n    <path d=\"M6.5 16a3.5 3.5 0 0 1 0 -7h.5\" />\n    <path d=\"M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const searchIcon = createIcon(\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0\" />\n    <path d=\"M21 21l-6 -6\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const clockIcon = createIcon(\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M20.984 12.53a9 9 0 1 0 -7.552 8.355\" />\n    <path d=\"M12 7v5l3 3\" />\n    <path d=\"M19 16l-2 3h4l-2 3\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const microphoneIcon = createIcon(\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M9 2m0 3a3 3 0 0 1 3 -3h0a3 3 0 0 1 3 3v5a3 3 0 0 1 -3 3h0a3 3 0 0 1 -3 -3z\" />\n    <path d=\"M5 10a7 7 0 0 0 14 0\" />\n    <path d=\"M8 21l8 0\" />\n    <path d=\"M12 17l0 4\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const microphoneMutedIcon = createIcon(\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M3 3l18 18\" />\n    <path d=\"M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1\" />\n    <path d=\"M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85\" />\n    <path d=\"M8 21l8 0\" />\n    <path d=\"M12 17l0 4\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const boltIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M13 3l0 7l6 0l-8 11l0 -7l-6 0l8 -11\" />\n  </g>,\n  tablerIconProps,\n);\nexport const selectAllIcon = createIcon(\n  <g>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M8 8m0 1a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-6a1 1 0 0 1 -1 -1z\" />\n    <path d=\"M12 20v.01\" />\n    <path d=\"M16 20v.01\" />\n    <path d=\"M8 20v.01\" />\n    <path d=\"M4 20v.01\" />\n    <path d=\"M4 16v.01\" />\n    <path d=\"M4 12v.01\" />\n    <path d=\"M4 8v.01\" />\n    <path d=\"M4 4v.01\" />\n    <path d=\"M8 4v.01\" />\n    <path d=\"M12 4v.01\" />\n    <path d=\"M16 4v.01\" />\n    <path d=\"M20 4v.01\" />\n    <path d=\"M20 8v.01\" />\n    <path d=\"M20 12v.01\" />\n    <path d=\"M20 16v.01\" />\n    <path d=\"M20 20v.01\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const abacusIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M5 3v18\" />\n    <path d=\"M19 21v-18\" />\n    <path d=\"M5 7h14\" />\n    <path d=\"M5 15h14\" />\n    <path d=\"M8 13v4\" />\n    <path d=\"M11 13v4\" />\n    <path d=\"M16 13v4\" />\n    <path d=\"M14 5v4\" />\n    <path d=\"M11 5v4\" />\n    <path d=\"M8 5v4\" />\n    <path d=\"M3 21h18\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const flipVertical = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M3 12l18 0\" />\n    <path d=\"M7 16l10 0l-10 5l0 -5\" />\n    <path d=\"M7 8l10 0l-10 -5l0 5\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const flipHorizontal = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M12 3l0 18\" />\n    <path d=\"M16 7l0 10l5 0l-5 -10\" />\n    <path d=\"M8 7l0 10l-5 0l5 -10\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const paintIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M5 3m0 2a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z\" />\n    <path d=\"M19 6h1a2 2 0 0 1 2 2a5 5 0 0 1 -5 5l-5 0v2\" />\n    <path d=\"M10 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const zoomAreaIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M15 15m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0\" />\n    <path d=\"M22 22l-3 -3\" />\n    <path d=\"M6 18h-1a2 2 0 0 1 -2 -2v-1\" />\n    <path d=\"M3 11v-1\" />\n    <path d=\"M3 6v-1a2 2 0 0 1 2 -2h1\" />\n    <path d=\"M10 3h1\" />\n    <path d=\"M15 3h1a2 2 0 0 1 2 2v1\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const svgIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M14 3v4a1 1 0 0 0 1 1h4\" />\n    <path d=\"M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4\" />\n    <path d=\"M4 20.25c0 .414 .336 .75 .75 .75h1.25a1 1 0 0 0 1 -1v-1a1 1 0 0 0 -1 -1h-1a1 1 0 0 1 -1 -1v-1a1 1 0 0 1 1 -1h1.25a.75 .75 0 0 1 .75 .75\" />\n    <path d=\"M10 15l2 6l2 -6\" />\n    <path d=\"M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const pngIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M14 3v4a1 1 0 0 0 1 1h4\" />\n    <path d=\"M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4\" />\n    <path d=\"M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3\" />\n    <path d=\"M5 18h1.5a1.5 1.5 0 0 0 0 -3h-1.5v6\" />\n    <path d=\"M11 21v-6l3 6v-6\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const magnetIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M4 13v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a2 2 0 0 0 6 0v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a8 8 0 0 1 -16 0\" />\n    <path d=\"M4 8l5 0\" />\n    <path d=\"M15 8l4 0\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const coffeeIcon = createIcon(\n  <g strokeWidth={1.25}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M3 14c.83 .642 2.077 1.017 3.5 1c1.423 .017 2.67 -.358 3.5 -1c.83 -.642 2.077 -1.017 3.5 -1c1.423 -.017 2.67 .358 3.5 1\" />\n    <path d=\"M8 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2\" />\n    <path d=\"M12 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2\" />\n    <path d=\"M3 10h14v5a6 6 0 0 1 -6 6h-2a6 6 0 0 1 -6 -6v-5z\" />\n    <path d=\"M16.746 16.726a3 3 0 1 0 .252 -5.555\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const DeviceDesktopIcon = createIcon(\n  <g stroke=\"currentColor\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M3 5a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1h-16a1 1 0 0 1-1-1v-10zM7 20h10M9 16v4M15 16v4\" />\n  </g>,\n  { ...tablerIconProps, strokeWidth: 1.5 },\n);\n\n// login\nexport const loginIcon = createIcon(\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M15 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2\" />\n    <path d=\"M21 12h-13l3 -3\" />\n    <path d=\"M11 15l-3 -3\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const youtubeIcon = createIcon(\n  <g>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M2 8a4 4 0 0 1 4 -4h12a4 4 0 0 1 4 4v8a4 4 0 0 1 -4 4h-12a4 4 0 0 1 -4 -4v-8z\" />\n    <path d=\"M10 9l5 3l-5 3z\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const gridIcon = createIcon(\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M3 6h18\" />\n    <path d=\"M3 12h18\" />\n    <path d=\"M3 18h18\" />\n    <path d=\"M6 3v18\" />\n    <path d=\"M12 3v18\" />\n    <path d=\"M18 3v18\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const lineEditorIcon = createIcon(\n  <g strokeWidth={1.5}>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M17 3m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z\" />\n    <path d=\"M3 17m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z\" />\n    <path d=\"M17 5c-6.627 0 -12 5.373 -12 12\" />\n  </g>,\n  tablerIconProps,\n);\n\n// arrow-up-right (modified)\nexport const sharpArrowIcon = createIcon(\n  <g>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M6 18l12 -12\" />\n    <path d=\"M18 10v-4h-4\" />\n  </g>,\n  tablerIconProps,\n);\n\n// arrow-guide (modified)\nexport const elbowArrowIcon = createIcon(\n  <g>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M4,19L10,19C11.097,19 12,18.097 12,17L12,9C12,7.903 12.903,7 14,7L21,7\" />\n    <path d=\"M18 4l3 3l-3 3\" />\n  </g>,\n  tablerIconProps,\n);\n\n// arrow-ramp-right-2 (heavily modified)\nexport const roundArrowIcon = createIcon(\n  <g>\n    <path d=\"M16,12L20,9L16,6\" />\n    <path d=\"M6 20c0 -6.075 4.925 -11 11 -11h3\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const collapseDownIcon = createIcon(\n  <g>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M6 9l6 6l6 -6\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const collapseUpIcon = createIcon(\n  <g>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M6 15l6 -6l6 6\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const upIcon = createIcon(\n  <g>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M6 15l6 -6l6 6\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const cropIcon = createIcon(\n  <g strokeWidth=\"1.25\">\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M8 5v10a1 1 0 0 0 1 1h10\" />\n    <path d=\"M5 8h10a1 1 0 0 1 1 1v10\" />\n  </g>,\n  tablerIconProps,\n);\n\nexport const elementLinkIcon = createIcon(\n  <g>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n    <path d=\"M5 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0\" />\n    <path d=\"M19 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0\" />\n    <path d=\"M5 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0\" />\n    <path d=\"M19 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0\" />\n    <path d=\"M5 7l0 10\" />\n    <path d=\"M7 5l10 0\" />\n    <path d=\"M7 19l10 0\" />\n    <path d=\"M19 7l0 10\" />\n  </g>,\n  tablerIconProps,\n);\n",
    "import clsx from \"clsx\";\nimport React, { useEffect, useRef, useState } from \"react\";\n\nimport { isPromiseLike } from \"@excalidraw/common\";\n\nimport type { PointerType } from \"@excalidraw/element/types\";\n\nimport { AbortError } from \"../errors\";\n\nimport \"./ToolIcon.scss\";\n\nimport Spinner from \"./Spinner\";\nimport { useExcalidrawContainer } from \"./App\";\n\nimport type { CSSProperties } from \"react\";\n\nexport type ToolButtonSize = \"small\" | \"medium\";\n\ntype ToolButtonBaseProps = {\n  icon?: React.ReactNode;\n  \"aria-label\": string;\n  \"aria-keyshortcuts\"?: string;\n  \"data-testid\"?: string;\n  label?: string;\n  title?: string;\n  name?: string;\n  id?: string;\n  size?: ToolButtonSize;\n  keyBindingLabel?: string | null;\n  showAriaLabel?: boolean;\n  hidden?: boolean;\n  visible?: boolean;\n  selected?: boolean;\n  disabled?: boolean;\n  className?: string;\n  style?: CSSProperties;\n  isLoading?: boolean;\n};\n\ntype ToolButtonProps =\n  | (ToolButtonBaseProps & {\n      type: \"button\";\n      children?: React.ReactNode;\n      onClick?(event: React.MouseEvent): void;\n    })\n  | (ToolButtonBaseProps & {\n      type: \"submit\";\n      children?: React.ReactNode;\n      onClick?(event: React.MouseEvent): void;\n    })\n  | (ToolButtonBaseProps & {\n      type: \"icon\";\n      children?: React.ReactNode;\n      onClick?(): void;\n    })\n  | (ToolButtonBaseProps & {\n      type: \"radio\";\n      checked: boolean;\n      onChange?(data: { pointerType: PointerType | null }): void;\n      onPointerDown?(data: { pointerType: PointerType }): void;\n    });\n\nexport const ToolButton = React.forwardRef(\n  (\n    {\n      size = \"medium\",\n      visible = true,\n      className = \"\",\n      ...props\n    }: ToolButtonProps,\n    ref,\n  ) => {\n    const { id: excalId } = useExcalidrawContainer();\n    const innerRef = React.useRef(null);\n    React.useImperativeHandle(ref, () => innerRef.current);\n    const sizeCn = `ToolIcon_size_${size}`;\n\n    const [isLoading, setIsLoading] = useState(false);\n\n    const isMountedRef = useRef(true);\n\n    const onClick = async (event: React.MouseEvent) => {\n      const ret = \"onClick\" in props && props.onClick?.(event);\n\n      if (isPromiseLike(ret)) {\n        try {\n          setIsLoading(true);\n          await ret;\n        } catch (error: any) {\n          if (!(error instanceof AbortError)) {\n            throw error;\n          } else {\n            console.warn(error);\n          }\n        } finally {\n          if (isMountedRef.current) {\n            setIsLoading(false);\n          }\n        }\n      }\n    };\n\n    useEffect(() => {\n      isMountedRef.current = true;\n      return () => {\n        isMountedRef.current = false;\n      };\n    }, []);\n\n    const lastPointerTypeRef = useRef<PointerType | null>(null);\n\n    if (\n      props.type === \"button\" ||\n      props.type === \"icon\" ||\n      props.type === \"submit\"\n    ) {\n      const type = (props.type === \"icon\" ? \"button\" : props.type) as\n        | \"button\"\n        | \"submit\";\n      return (\n        <button\n          className={clsx(\n            \"ToolIcon_type_button\",\n            sizeCn,\n            className,\n            visible && !props.hidden\n              ? \"ToolIcon_type_button--show\"\n              : \"ToolIcon_type_button--hide\",\n            {\n              ToolIcon: !props.hidden,\n              \"ToolIcon--selected\": props.selected,\n              \"ToolIcon--plain\": props.type === \"icon\",\n            },\n          )}\n          style={props.style}\n          data-testid={props[\"data-testid\"]}\n          hidden={props.hidden}\n          title={props.title}\n          aria-label={props[\"aria-label\"]}\n          type={type}\n          onClick={onClick}\n          ref={innerRef}\n          disabled={isLoading || props.isLoading || !!props.disabled}\n        >\n          {(props.icon || props.label) && (\n            <div\n              className=\"ToolIcon__icon\"\n              aria-hidden=\"true\"\n              aria-disabled={!!props.disabled}\n            >\n              {props.icon || props.label}\n              {props.keyBindingLabel && (\n                <span className=\"ToolIcon__keybinding\">\n                  {props.keyBindingLabel}\n                </span>\n              )}\n              {props.isLoading && <Spinner />}\n            </div>\n          )}\n          {props.showAriaLabel && (\n            <div className=\"ToolIcon__label\">\n              {props[\"aria-label\"]} {isLoading && <Spinner />}\n            </div>\n          )}\n          {props.children}\n        </button>\n      );\n    }\n\n    return (\n      <label\n        className={clsx(\"ToolIcon\", className)}\n        title={props.title}\n        onPointerDown={(event) => {\n          lastPointerTypeRef.current = event.pointerType || null;\n          props.onPointerDown?.({ pointerType: event.pointerType || null });\n        }}\n        onPointerUp={() => {\n          requestAnimationFrame(() => {\n            lastPointerTypeRef.current = null;\n          });\n        }}\n      >\n        <input\n          className={`ToolIcon_type_radio ${sizeCn}`}\n          type=\"radio\"\n          name={props.name}\n          aria-label={props[\"aria-label\"]}\n          aria-keyshortcuts={props[\"aria-keyshortcuts\"]}\n          data-testid={props[\"data-testid\"]}\n          id={`${excalId}-${props.id}`}\n          onChange={() => {\n            props.onChange?.({ pointerType: lastPointerTypeRef.current });\n          }}\n          checked={props.checked}\n          ref={innerRef}\n        />\n        <div className=\"ToolIcon__icon\">\n          {props.icon}\n          {props.keyBindingLabel && (\n            <span className=\"ToolIcon__keybinding\">\n              {props.keyBindingLabel}\n            </span>\n          )}\n        </div>\n      </label>\n    );\n  },\n);\n\nToolButton.displayName = \"ToolButton\";\n",
    "import React from \"react\";\n\nimport \"./Spinner.scss\";\n\nconst Spinner = ({\n  size = \"1em\",\n  circleWidth = 8,\n  synchronized = false,\n  className = \"\",\n}: {\n  size?: string | number;\n  circleWidth?: number;\n  synchronized?: boolean;\n  className?: string;\n}) => {\n  const mountTime = React.useRef(Date.now());\n  const mountDelay = -(mountTime.current % 1600);\n\n  return (\n    <div className={`Spinner ${className}`}>\n      <svg\n        viewBox=\"0 0 100 100\"\n        style={{\n          width: size,\n          height: size,\n          // fix for remounting causing spinner flicker\n          [\"--spinner-delay\" as any]: synchronized ? `${mountDelay}ms` : 0,\n        }}\n      >\n        <circle\n          cx=\"50\"\n          cy=\"50\"\n          r={50 - circleWidth / 2}\n          strokeWidth={circleWidth}\n          fill=\"none\"\n          strokeMiterlimit=\"10\"\n        />\n      </svg>\n    </div>\n  );\n};\n\nexport default Spinner;\n",
    "import type { Action } from \"./types\";\n\nexport let actions: readonly Action[] = [];\n\nexport const register = <T extends Action>(action: T) => {\n  actions = actions.concat(action);\n  return action as T & {\n    keyTest?: unknown extends T[\"keyTest\"] ? never : T[\"keyTest\"];\n  };\n};\n",
    "import { KEYS, CODES, getShortcutKey, isDarwin } from \"@excalidraw/common\";\n\nimport {\n  moveOneLeft,\n  moveOneRight,\n  moveAllLeft,\n  moveAllRight,\n} from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport {\n  BringForwardIcon,\n  BringToFrontIcon,\n  SendBackwardIcon,\n  SendToBackIcon,\n} from \"../components/icons\";\nimport { t } from \"../i18n\";\n\nimport { register } from \"./register\";\n\nexport const actionSendBackward = register({\n  name: \"sendBackward\",\n  label: \"labels.sendBackward\",\n  keywords: [\"move down\", \"zindex\", \"layer\"],\n  icon: SendBackwardIcon,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, value, app) => {\n    return {\n      elements: moveOneLeft(elements, appState, app.scene),\n      appState,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyPriority: 40,\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    !event.shiftKey &&\n    event.code === CODES.BRACKET_LEFT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.sendBackward\")} — ${getShortcutKey(\"CtrlOrCmd+[\")}`}\n    >\n      {SendBackwardIcon}\n    </button>\n  ),\n});\n\nexport const actionBringForward = register({\n  name: \"bringForward\",\n  label: \"labels.bringForward\",\n  keywords: [\"move up\", \"zindex\", \"layer\"],\n  icon: BringForwardIcon,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, value, app) => {\n    return {\n      elements: moveOneRight(elements, appState, app.scene),\n      appState,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyPriority: 40,\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] &&\n    !event.shiftKey &&\n    event.code === CODES.BRACKET_RIGHT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.bringForward\")} — ${getShortcutKey(\"CtrlOrCmd+]\")}`}\n    >\n      {BringForwardIcon}\n    </button>\n  ),\n});\n\nexport const actionSendToBack = register({\n  name: \"sendToBack\",\n  label: \"labels.sendToBack\",\n  keywords: [\"move down\", \"zindex\", \"layer\"],\n  icon: SendToBackIcon,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState) => {\n    return {\n      elements: moveAllLeft(elements, appState),\n      appState,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    isDarwin\n      ? event[KEYS.CTRL_OR_CMD] &&\n        event.altKey &&\n        event.code === CODES.BRACKET_LEFT\n      : event[KEYS.CTRL_OR_CMD] &&\n        event.shiftKey &&\n        event.code === CODES.BRACKET_LEFT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.sendToBack\")} — ${\n        isDarwin\n          ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n          : getShortcutKey(\"CtrlOrCmd+Shift+[\")\n      }`}\n    >\n      {SendToBackIcon}\n    </button>\n  ),\n});\n\nexport const actionBringToFront = register({\n  name: \"bringToFront\",\n  label: \"labels.bringToFront\",\n  keywords: [\"move up\", \"zindex\", \"layer\"],\n  icon: BringToFrontIcon,\n  trackEvent: { category: \"element\" },\n\n  perform: (elements, appState) => {\n    return {\n      elements: moveAllRight(elements, appState),\n      appState,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    isDarwin\n      ? event[KEYS.CTRL_OR_CMD] &&\n        event.altKey &&\n        event.code === CODES.BRACKET_RIGHT\n      : event[KEYS.CTRL_OR_CMD] &&\n        event.shiftKey &&\n        event.code === CODES.BRACKET_RIGHT,\n  PanelComponent: ({ updateData, appState }) => (\n    <button\n      type=\"button\"\n      className=\"zIndexButton\"\n      onClick={(event) => updateData(null)}\n      title={`${t(\"labels.bringToFront\")} — ${\n        isDarwin\n          ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n          : getShortcutKey(\"CtrlOrCmd+Shift+]\")\n      }`}\n    >\n      {BringToFrontIcon}\n    </button>\n  ),\n});\n",
    "import { getNonDeletedElements } from \"@excalidraw/element\";\nimport { LinearElementEditor } from \"@excalidraw/element\";\nimport { isLinearElement, isTextElement } from \"@excalidraw/element\";\n\nimport { arrayToMap, KEYS } from \"@excalidraw/common\";\n\nimport { selectGroupsForSelectedElements } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { selectAllIcon } from \"../components/icons\";\n\nimport { register } from \"./register\";\n\nexport const actionSelectAll = register({\n  name: \"selectAll\",\n  label: \"labels.selectAll\",\n  icon: selectAllIcon,\n  trackEvent: { category: \"canvas\" },\n  viewMode: false,\n  perform: (elements, appState, value, app) => {\n    if (appState.editingLinearElement) {\n      return false;\n    }\n\n    const selectedElementIds = elements\n      .filter(\n        (element) =>\n          !element.isDeleted &&\n          !(isTextElement(element) && element.containerId) &&\n          !element.locked,\n      )\n      .reduce((map: Record<ExcalidrawElement[\"id\"], true>, element) => {\n        map[element.id] = true;\n        return map;\n      }, {});\n\n    return {\n      appState: {\n        ...appState,\n        ...selectGroupsForSelectedElements(\n          {\n            editingGroupId: null,\n            selectedElementIds,\n          },\n          getNonDeletedElements(elements),\n          appState,\n          app,\n        ),\n        selectedLinearElement:\n          // single linear element selected\n          Object.keys(selectedElementIds).length === 1 &&\n          isLinearElement(elements[0])\n            ? new LinearElementEditor(elements[0], arrayToMap(elements))\n            : null,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.A,\n});\n",
    "import {\n  DEFAULT_GRID_SIZE,\n  KEYS,\n  arrayToMap,\n  getShortcutKey,\n} from \"@excalidraw/common\";\n\nimport { getNonDeletedElements } from \"@excalidraw/element\";\n\nimport { LinearElementEditor } from \"@excalidraw/element\";\n\nimport {\n  getSelectedElements,\n  getSelectionStateForElements,\n} from \"@excalidraw/element\";\n\nimport { syncMovedIndices } from \"@excalidraw/element\";\n\nimport { duplicateElements } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { ToolButton } from \"../components/ToolButton\";\nimport { DuplicateIcon } from \"../components/icons\";\n\nimport { t } from \"../i18n\";\nimport { isSomeElementSelected } from \"../scene\";\n\nimport { register } from \"./register\";\n\nexport const actionDuplicateSelection = register({\n  name: \"duplicateSelection\",\n  label: \"labels.duplicateSelection\",\n  icon: DuplicateIcon,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, formData, app) => {\n    if (appState.selectedElementsAreBeingDragged) {\n      return false;\n    }\n\n    // duplicate selected point(s) if editing a line\n    if (appState.editingLinearElement) {\n      // TODO: Invariants should be checked here instead of duplicateSelectedPoints()\n      try {\n        const newAppState = LinearElementEditor.duplicateSelectedPoints(\n          appState,\n          app.scene,\n        );\n\n        return {\n          elements,\n          appState: newAppState,\n          captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n        };\n      } catch {\n        return false;\n      }\n    }\n\n    let { duplicatedElements, elementsWithDuplicates } = duplicateElements({\n      type: \"in-place\",\n      elements,\n      idsOfElementsToDuplicate: arrayToMap(\n        getSelectedElements(elements, appState, {\n          includeBoundTextElement: true,\n          includeElementsInFrames: true,\n        }),\n      ),\n      appState,\n      randomizeSeed: true,\n      overrides: ({ origElement, origIdToDuplicateId }) => {\n        const duplicateFrameId =\n          origElement.frameId && origIdToDuplicateId.get(origElement.frameId);\n        return {\n          x: origElement.x + DEFAULT_GRID_SIZE / 2,\n          y: origElement.y + DEFAULT_GRID_SIZE / 2,\n          frameId: duplicateFrameId ?? origElement.frameId,\n        };\n      },\n    });\n\n    if (app.props.onDuplicate && elementsWithDuplicates) {\n      const mappedElements = app.props.onDuplicate(\n        elementsWithDuplicates,\n        elements,\n      );\n      if (mappedElements) {\n        elementsWithDuplicates = mappedElements;\n      }\n    }\n\n    return {\n      elements: syncMovedIndices(\n        elementsWithDuplicates,\n        arrayToMap(duplicatedElements),\n      ),\n      appState: {\n        ...appState,\n        ...getSelectionStateForElements(\n          duplicatedElements,\n          getNonDeletedElements(elementsWithDuplicates),\n          appState,\n        ),\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={DuplicateIcon}\n      title={`${t(\"labels.duplicateSelection\")} — ${getShortcutKey(\n        \"CtrlOrCmd+D\",\n      )}`}\n      aria-label={t(\"labels.duplicateSelection\")}\n      onClick={() => updateData(null)}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n",
    "import { pointFrom } from \"@excalidraw/math\";\nimport { useEffect, useMemo, useRef, useState } from \"react\";\n\nimport {\n  DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE,\n  DEFAULT_ELEMENT_BACKGROUND_PICKS,\n  DEFAULT_ELEMENT_STROKE_COLOR_PALETTE,\n  DEFAULT_ELEMENT_STROKE_PICKS,\n  ARROW_TYPE,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  FONT_FAMILY,\n  ROUNDNESS,\n  STROKE_WIDTH,\n  VERTICAL_ALIGN,\n  KEYS,\n  randomInteger,\n  arrayToMap,\n  getFontFamilyString,\n  getShortcutKey,\n  getLineHeight,\n  isTransparent,\n  reduceToCommonValue,\n} from \"@excalidraw/common\";\n\nimport { canBecomePolygon, getNonDeletedElements } from \"@excalidraw/element\";\n\nimport {\n  bindLinearElement,\n  calculateFixedPointForElbowArrowBinding,\n  updateBoundElements,\n} from \"@excalidraw/element\";\n\nimport { LinearElementEditor } from \"@excalidraw/element\";\n\nimport { newElementWith } from \"@excalidraw/element\";\n\nimport {\n  getBoundTextElement,\n  redrawTextBoundingBox,\n} from \"@excalidraw/element\";\n\nimport {\n  isArrowElement,\n  isBoundToContainer,\n  isElbowArrow,\n  isLinearElement,\n  isLineElement,\n  isTextElement,\n  isUsingAdaptiveRadius,\n} from \"@excalidraw/element\";\n\nimport { hasStrokeColor } from \"@excalidraw/element\";\n\nimport {\n  updateElbowArrowPoints,\n  CaptureUpdateAction,\n  toggleLinePolygonState,\n} from \"@excalidraw/element\";\n\nimport type { LocalPoint } from \"@excalidraw/math\";\n\nimport type {\n  Arrowhead,\n  ElementsMap,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  FontFamilyValues,\n  TextAlign,\n  VerticalAlign,\n} from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport type { CaptureUpdateActionType } from \"@excalidraw/element\";\n\nimport { trackEvent } from \"../analytics\";\nimport { RadioSelection } from \"../components/RadioSelection\";\nimport { ColorPicker } from \"../components/ColorPicker/ColorPicker\";\nimport { FontPicker } from \"../components/FontPicker/FontPicker\";\nimport { IconPicker } from \"../components/IconPicker\";\n// TODO barnabasmolnar/editor-redesign\n// TextAlignTopIcon, TextAlignBottomIcon,TextAlignMiddleIcon,\n// ArrowHead icons\nimport { Range } from \"../components/Range\";\nimport {\n  ArrowheadArrowIcon,\n  ArrowheadBarIcon,\n  ArrowheadCircleIcon,\n  ArrowheadTriangleIcon,\n  ArrowheadNoneIcon,\n  StrokeStyleDashedIcon,\n  StrokeStyleDottedIcon,\n  TextAlignTopIcon,\n  TextAlignBottomIcon,\n  TextAlignMiddleIcon,\n  FillHachureIcon,\n  FillCrossHatchIcon,\n  FillSolidIcon,\n  SloppinessArchitectIcon,\n  SloppinessArtistIcon,\n  SloppinessCartoonistIcon,\n  StrokeWidthBaseIcon,\n  StrokeWidthBoldIcon,\n  StrokeWidthExtraBoldIcon,\n  FontSizeSmallIcon,\n  FontSizeMediumIcon,\n  FontSizeLargeIcon,\n  FontSizeExtraLargeIcon,\n  EdgeSharpIcon,\n  EdgeRoundIcon,\n  TextAlignLeftIcon,\n  TextAlignCenterIcon,\n  TextAlignRightIcon,\n  FillZigZagIcon,\n  ArrowheadTriangleOutlineIcon,\n  ArrowheadCircleOutlineIcon,\n  ArrowheadDiamondIcon,\n  ArrowheadDiamondOutlineIcon,\n  fontSizeIcon,\n  sharpArrowIcon,\n  roundArrowIcon,\n  elbowArrowIcon,\n  ArrowheadCrowfootIcon,\n  ArrowheadCrowfootOneIcon,\n  ArrowheadCrowfootOneOrManyIcon,\n} from \"../components/icons\";\n\nimport { Fonts } from \"../fonts\";\nimport { getLanguage, t } from \"../i18n\";\nimport {\n  canHaveArrowheads,\n  getSelectedElements,\n  getTargetElements,\n  isSomeElementSelected,\n} from \"../scene\";\n\nimport { register } from \"./register\";\n\nimport type { AppClassProperties, AppState, Primitive } from \"../types\";\n\nconst FONT_SIZE_RELATIVE_INCREASE_STEP = 0.1;\n\nexport const changeProperty = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  callback: (element: ExcalidrawElement) => ExcalidrawElement,\n  includeBoundText = false,\n) => {\n  const selectedElementIds = arrayToMap(\n    getSelectedElements(elements, appState, {\n      includeBoundTextElement: includeBoundText,\n    }),\n  );\n\n  return elements.map((element) => {\n    if (\n      selectedElementIds.get(element.id) ||\n      element.id === appState.editingTextElement?.id\n    ) {\n      return callback(element);\n    }\n    return element;\n  });\n};\n\nexport const getFormValue = function <T extends Primitive>(\n  elements: readonly ExcalidrawElement[],\n  app: AppClassProperties,\n  getAttribute: (element: ExcalidrawElement) => T,\n  isRelevantElement: true | ((element: ExcalidrawElement) => boolean),\n  defaultValue: T | ((isSomeElementSelected: boolean) => T),\n): T {\n  const editingTextElement = app.state.editingTextElement;\n  const nonDeletedElements = getNonDeletedElements(elements);\n\n  let ret: T | null = null;\n\n  if (editingTextElement) {\n    ret = getAttribute(editingTextElement);\n  }\n\n  if (!ret) {\n    const hasSelection = isSomeElementSelected(nonDeletedElements, app.state);\n\n    if (hasSelection) {\n      const selectedElements = app.scene.getSelectedElements(app.state);\n      const targetElements =\n        isRelevantElement === true\n          ? selectedElements\n          : selectedElements.filter((el) => isRelevantElement(el));\n\n      ret =\n        reduceToCommonValue(targetElements, getAttribute) ??\n        (typeof defaultValue === \"function\"\n          ? defaultValue(true)\n          : defaultValue);\n    } else {\n      ret =\n        typeof defaultValue === \"function\" ? defaultValue(false) : defaultValue;\n    }\n  }\n\n  return ret;\n};\n\nconst offsetElementAfterFontResize = (\n  prevElement: ExcalidrawTextElement,\n  nextElement: ExcalidrawTextElement,\n  scene: Scene,\n) => {\n  if (isBoundToContainer(nextElement) || !nextElement.autoResize) {\n    return nextElement;\n  }\n  return scene.mutateElement(nextElement, {\n    x:\n      prevElement.textAlign === \"left\"\n        ? prevElement.x\n        : prevElement.x +\n          (prevElement.width - nextElement.width) /\n            (prevElement.textAlign === \"center\" ? 2 : 1),\n    // centering vertically is non-standard, but for Excalidraw I think\n    // it makes sense\n    y: prevElement.y + (prevElement.height - nextElement.height) / 2,\n  });\n};\n\nconst changeFontSize = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  app: AppClassProperties,\n  getNewFontSize: (element: ExcalidrawTextElement) => number,\n  fallbackValue?: ExcalidrawTextElement[\"fontSize\"],\n) => {\n  const newFontSizes = new Set<number>();\n\n  const updatedElements = changeProperty(\n    elements,\n    appState,\n    (oldElement) => {\n      if (isTextElement(oldElement)) {\n        const newFontSize = getNewFontSize(oldElement);\n        newFontSizes.add(newFontSize);\n\n        let newElement: ExcalidrawTextElement = newElementWith(oldElement, {\n          fontSize: newFontSize,\n        });\n        redrawTextBoundingBox(\n          newElement,\n          app.scene.getContainerElement(oldElement),\n          app.scene,\n        );\n\n        newElement = offsetElementAfterFontResize(\n          oldElement,\n          newElement,\n          app.scene,\n        );\n\n        return newElement;\n      }\n      return oldElement;\n    },\n    true,\n  );\n\n  // Update arrow elements after text elements have been updated\n  getSelectedElements(elements, appState, {\n    includeBoundTextElement: true,\n  }).forEach((element) => {\n    if (isTextElement(element)) {\n      updateBoundElements(element, app.scene);\n    }\n  });\n\n  return {\n    elements: updatedElements,\n    appState: {\n      ...appState,\n      // update state only if we've set all select text elements to\n      // the same font size\n      currentItemFontSize:\n        newFontSizes.size === 1\n          ? [...newFontSizes][0]\n          : fallbackValue ?? appState.currentItemFontSize,\n    },\n    captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n  };\n};\n\n// -----------------------------------------------------------------------------\n\nexport const actionChangeStrokeColor = register({\n  name: \"changeStrokeColor\",\n  label: \"labels.stroke\",\n  trackEvent: false,\n  perform: (elements, appState, value) => {\n    return {\n      ...(value.currentItemStrokeColor && {\n        elements: changeProperty(\n          elements,\n          appState,\n          (el) => {\n            return hasStrokeColor(el.type)\n              ? newElementWith(el, {\n                  strokeColor: value.currentItemStrokeColor,\n                })\n              : el;\n          },\n          true,\n        ),\n      }),\n      appState: {\n        ...appState,\n        ...value,\n      },\n      captureUpdate: !!value.currentItemStrokeColor\n        ? CaptureUpdateAction.IMMEDIATELY\n        : CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <>\n      <h3 aria-hidden=\"true\">{t(\"labels.stroke\")}</h3>\n      <ColorPicker\n        topPicks={DEFAULT_ELEMENT_STROKE_PICKS}\n        palette={DEFAULT_ELEMENT_STROKE_COLOR_PALETTE}\n        type=\"elementStroke\"\n        label={t(\"labels.stroke\")}\n        color={getFormValue(\n          elements,\n          app,\n          (element) => element.strokeColor,\n          true,\n          (hasSelection) =>\n            !hasSelection ? appState.currentItemStrokeColor : null,\n        )}\n        onChange={(color) => updateData({ currentItemStrokeColor: color })}\n        elements={elements}\n        appState={appState}\n        updateData={updateData}\n      />\n    </>\n  ),\n});\n\nexport const actionChangeBackgroundColor = register({\n  name: \"changeBackgroundColor\",\n  label: \"labels.changeBackground\",\n  trackEvent: false,\n  perform: (elements, appState, value, app) => {\n    if (!value.currentItemBackgroundColor) {\n      return {\n        appState: {\n          ...appState,\n          ...value,\n        },\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    }\n\n    let nextElements;\n\n    const selectedElements = app.scene.getSelectedElements(appState);\n    const shouldEnablePolygon =\n      !isTransparent(value.currentItemBackgroundColor) &&\n      selectedElements.every(\n        (el) => isLineElement(el) && canBecomePolygon(el.points),\n      );\n\n    if (shouldEnablePolygon) {\n      const selectedElementsMap = arrayToMap(selectedElements);\n      nextElements = elements.map((el) => {\n        if (selectedElementsMap.has(el.id) && isLineElement(el)) {\n          return newElementWith(el, {\n            backgroundColor: value.currentItemBackgroundColor,\n            ...toggleLinePolygonState(el, true),\n          });\n        }\n        return el;\n      });\n    } else {\n      nextElements = changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          backgroundColor: value.currentItemBackgroundColor,\n        }),\n      );\n    }\n\n    return {\n      elements: nextElements,\n      appState: {\n        ...appState,\n        ...value,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <>\n      <h3 aria-hidden=\"true\">{t(\"labels.background\")}</h3>\n      <ColorPicker\n        topPicks={DEFAULT_ELEMENT_BACKGROUND_PICKS}\n        palette={DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE}\n        type=\"elementBackground\"\n        label={t(\"labels.background\")}\n        color={getFormValue(\n          elements,\n          app,\n          (element) => element.backgroundColor,\n          true,\n          (hasSelection) =>\n            !hasSelection ? appState.currentItemBackgroundColor : null,\n        )}\n        onChange={(color) => updateData({ currentItemBackgroundColor: color })}\n        elements={elements}\n        appState={appState}\n        updateData={updateData}\n      />\n    </>\n  ),\n});\n\nexport const actionChangeFillStyle = register({\n  name: \"changeFillStyle\",\n  label: \"labels.fill\",\n  trackEvent: false,\n  perform: (elements, appState, value, app) => {\n    trackEvent(\n      \"element\",\n      \"changeFillStyle\",\n      `${value} (${app.device.editor.isMobile ? \"mobile\" : \"desktop\"})`,\n    );\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          fillStyle: value,\n        }),\n      ),\n      appState: { ...appState, currentItemFillStyle: value },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => {\n    const selectedElements = getSelectedElements(elements, appState);\n    const allElementsZigZag =\n      selectedElements.length > 0 &&\n      selectedElements.every((el) => el.fillStyle === \"zigzag\");\n\n    return (\n      <fieldset>\n        <legend>{t(\"labels.fill\")}</legend>\n        <div className=\"buttonList\">\n          <RadioSelection\n            type=\"button\"\n            options={[\n              {\n                value: \"hachure\",\n                text: `${\n                  allElementsZigZag ? t(\"labels.zigzag\") : t(\"labels.hachure\")\n                } (${getShortcutKey(\"Alt-Click\")})`,\n                icon: allElementsZigZag ? FillZigZagIcon : FillHachureIcon,\n                active: allElementsZigZag ? true : undefined,\n                testId: `fill-hachure`,\n              },\n              {\n                value: \"cross-hatch\",\n                text: t(\"labels.crossHatch\"),\n                icon: FillCrossHatchIcon,\n                testId: `fill-cross-hatch`,\n              },\n              {\n                value: \"solid\",\n                text: t(\"labels.solid\"),\n                icon: FillSolidIcon,\n                testId: `fill-solid`,\n              },\n            ]}\n            value={getFormValue(\n              elements,\n              app,\n              (element) => element.fillStyle,\n              (element) => element.hasOwnProperty(\"fillStyle\"),\n              (hasSelection) =>\n                hasSelection ? null : appState.currentItemFillStyle,\n            )}\n            onClick={(value, event) => {\n              const nextValue =\n                event.altKey &&\n                value === \"hachure\" &&\n                selectedElements.every((el) => el.fillStyle === \"hachure\")\n                  ? \"zigzag\"\n                  : value;\n\n              updateData(nextValue);\n            }}\n          />\n        </div>\n      </fieldset>\n    );\n  },\n});\n\nexport const actionChangeStrokeWidth = register({\n  name: \"changeStrokeWidth\",\n  label: \"labels.strokeWidth\",\n  trackEvent: false,\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeWidth: value,\n        }),\n      ),\n      appState: { ...appState, currentItemStrokeWidth: value },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <fieldset>\n      <legend>{t(\"labels.strokeWidth\")}</legend>\n      <div className=\"buttonList\">\n        <RadioSelection\n          group=\"stroke-width\"\n          options={[\n            {\n              value: STROKE_WIDTH.thin,\n              text: t(\"labels.thin\"),\n              icon: StrokeWidthBaseIcon,\n              testId: \"strokeWidth-thin\",\n            },\n            {\n              value: STROKE_WIDTH.bold,\n              text: t(\"labels.bold\"),\n              icon: StrokeWidthBoldIcon,\n              testId: \"strokeWidth-bold\",\n            },\n            {\n              value: STROKE_WIDTH.extraBold,\n              text: t(\"labels.extraBold\"),\n              icon: StrokeWidthExtraBoldIcon,\n              testId: \"strokeWidth-extraBold\",\n            },\n          ]}\n          value={getFormValue(\n            elements,\n            app,\n            (element) => element.strokeWidth,\n            (element) => element.hasOwnProperty(\"strokeWidth\"),\n            (hasSelection) =>\n              hasSelection ? null : appState.currentItemStrokeWidth,\n          )}\n          onChange={(value) => updateData(value)}\n        />\n      </div>\n    </fieldset>\n  ),\n});\n\nexport const actionChangeSloppiness = register({\n  name: \"changeSloppiness\",\n  label: \"labels.sloppiness\",\n  trackEvent: false,\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          seed: randomInteger(),\n          roughness: value,\n        }),\n      ),\n      appState: { ...appState, currentItemRoughness: value },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <fieldset>\n      <legend>{t(\"labels.sloppiness\")}</legend>\n      <div className=\"buttonList\">\n        <RadioSelection\n          group=\"sloppiness\"\n          options={[\n            {\n              value: 0,\n              text: t(\"labels.architect\"),\n              icon: SloppinessArchitectIcon,\n            },\n            {\n              value: 1,\n              text: t(\"labels.artist\"),\n              icon: SloppinessArtistIcon,\n            },\n            {\n              value: 2,\n              text: t(\"labels.cartoonist\"),\n              icon: SloppinessCartoonistIcon,\n            },\n          ]}\n          value={getFormValue(\n            elements,\n            app,\n            (element) => element.roughness,\n            (element) => element.hasOwnProperty(\"roughness\"),\n            (hasSelection) =>\n              hasSelection ? null : appState.currentItemRoughness,\n          )}\n          onChange={(value) => updateData(value)}\n        />\n      </div>\n    </fieldset>\n  ),\n});\n\nexport const actionChangeStrokeStyle = register({\n  name: \"changeStrokeStyle\",\n  label: \"labels.strokeStyle\",\n  trackEvent: false,\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) =>\n        newElementWith(el, {\n          strokeStyle: value,\n        }),\n      ),\n      appState: { ...appState, currentItemStrokeStyle: value },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <fieldset>\n      <legend>{t(\"labels.strokeStyle\")}</legend>\n      <div className=\"buttonList\">\n        <RadioSelection\n          group=\"strokeStyle\"\n          options={[\n            {\n              value: \"solid\",\n              text: t(\"labels.strokeStyle_solid\"),\n              icon: StrokeWidthBaseIcon,\n            },\n            {\n              value: \"dashed\",\n              text: t(\"labels.strokeStyle_dashed\"),\n              icon: StrokeStyleDashedIcon,\n            },\n            {\n              value: \"dotted\",\n              text: t(\"labels.strokeStyle_dotted\"),\n              icon: StrokeStyleDottedIcon,\n            },\n          ]}\n          value={getFormValue(\n            elements,\n            app,\n            (element) => element.strokeStyle,\n            (element) => element.hasOwnProperty(\"strokeStyle\"),\n            (hasSelection) =>\n              hasSelection ? null : appState.currentItemStrokeStyle,\n          )}\n          onChange={(value) => updateData(value)}\n        />\n      </div>\n    </fieldset>\n  ),\n});\n\nexport const actionChangeOpacity = register({\n  name: \"changeOpacity\",\n  label: \"labels.opacity\",\n  trackEvent: false,\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(\n        elements,\n        appState,\n        (el) =>\n          newElementWith(el, {\n            opacity: value,\n          }),\n        true,\n      ),\n      appState: { ...appState, currentItemOpacity: value },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ app, updateData }) => (\n    <Range updateData={updateData} app={app} testId=\"opacity\" />\n  ),\n});\n\nexport const actionChangeFontSize = register({\n  name: \"changeFontSize\",\n  label: \"labels.fontSize\",\n  trackEvent: false,\n  perform: (elements, appState, value, app) => {\n    return changeFontSize(elements, appState, app, () => value, value);\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <fieldset>\n      <legend>{t(\"labels.fontSize\")}</legend>\n      <div className=\"buttonList\">\n        <RadioSelection\n          group=\"font-size\"\n          options={[\n            {\n              value: 16,\n              text: t(\"labels.small\"),\n              icon: FontSizeSmallIcon,\n              testId: \"fontSize-small\",\n            },\n            {\n              value: 20,\n              text: t(\"labels.medium\"),\n              icon: FontSizeMediumIcon,\n              testId: \"fontSize-medium\",\n            },\n            {\n              value: 28,\n              text: t(\"labels.large\"),\n              icon: FontSizeLargeIcon,\n              testId: \"fontSize-large\",\n            },\n            {\n              value: 36,\n              text: t(\"labels.veryLarge\"),\n              icon: FontSizeExtraLargeIcon,\n              testId: \"fontSize-veryLarge\",\n            },\n          ]}\n          value={getFormValue(\n            elements,\n            app,\n            (element) => {\n              if (isTextElement(element)) {\n                return element.fontSize;\n              }\n              const boundTextElement = getBoundTextElement(\n                element,\n                app.scene.getNonDeletedElementsMap(),\n              );\n              if (boundTextElement) {\n                return boundTextElement.fontSize;\n              }\n              return null;\n            },\n            (element) =>\n              isTextElement(element) ||\n              getBoundTextElement(\n                element,\n                app.scene.getNonDeletedElementsMap(),\n              ) !== null,\n            (hasSelection) =>\n              hasSelection\n                ? null\n                : appState.currentItemFontSize || DEFAULT_FONT_SIZE,\n          )}\n          onChange={(value) => updateData(value)}\n        />\n      </div>\n    </fieldset>\n  ),\n});\n\nexport const actionDecreaseFontSize = register({\n  name: \"decreaseFontSize\",\n  label: \"labels.decreaseFontSize\",\n  icon: fontSizeIcon,\n  trackEvent: false,\n  perform: (elements, appState, value, app) => {\n    return changeFontSize(elements, appState, app, (element) =>\n      Math.round(\n        // get previous value before relative increase (doesn't work fully\n        // due to rounding and float precision issues)\n        (1 / (1 + FONT_SIZE_RELATIVE_INCREASE_STEP)) * element.fontSize,\n      ),\n    );\n  },\n  keyTest: (event) => {\n    return (\n      event[KEYS.CTRL_OR_CMD] &&\n      event.shiftKey &&\n      // KEYS.COMMA needed for MacOS\n      (event.key === KEYS.CHEVRON_LEFT || event.key === KEYS.COMMA)\n    );\n  },\n});\n\nexport const actionIncreaseFontSize = register({\n  name: \"increaseFontSize\",\n  label: \"labels.increaseFontSize\",\n  icon: fontSizeIcon,\n  trackEvent: false,\n  perform: (elements, appState, value, app) => {\n    return changeFontSize(elements, appState, app, (element) =>\n      Math.round(element.fontSize * (1 + FONT_SIZE_RELATIVE_INCREASE_STEP)),\n    );\n  },\n  keyTest: (event) => {\n    return (\n      event[KEYS.CTRL_OR_CMD] &&\n      event.shiftKey &&\n      // KEYS.PERIOD needed for MacOS\n      (event.key === KEYS.CHEVRON_RIGHT || event.key === KEYS.PERIOD)\n    );\n  },\n});\n\ntype ChangeFontFamilyData = Partial<\n  Pick<\n    AppState,\n    \"openPopup\" | \"currentItemFontFamily\" | \"currentHoveredFontFamily\"\n  >\n> & {\n  /** cache of selected & editing elements populated on opened popup */\n  cachedElements?: ElementsMap;\n  /** flag to reset all elements to their cached versions  */\n  resetAll?: true;\n  /** flag to reset all containers to their cached versions */\n  resetContainers?: true;\n};\n\nexport const actionChangeFontFamily = register({\n  name: \"changeFontFamily\",\n  label: \"labels.fontFamily\",\n  trackEvent: false,\n  perform: (elements, appState, value, app) => {\n    const { cachedElements, resetAll, resetContainers, ...nextAppState } =\n      value as ChangeFontFamilyData;\n\n    if (resetAll) {\n      const nextElements = changeProperty(\n        elements,\n        appState,\n        (element) => {\n          const cachedElement = cachedElements?.get(element.id);\n          if (cachedElement) {\n            const newElement = newElementWith(element, {\n              ...cachedElement,\n            });\n\n            return newElement;\n          }\n\n          return element;\n        },\n        true,\n      );\n\n      return {\n        elements: nextElements,\n        appState: {\n          ...appState,\n          ...nextAppState,\n        },\n        captureUpdate: CaptureUpdateAction.NEVER,\n      };\n    }\n\n    const { currentItemFontFamily, currentHoveredFontFamily } = value;\n\n    let nextCaptureUpdateAction: CaptureUpdateActionType =\n      CaptureUpdateAction.EVENTUALLY;\n    let nextFontFamily: FontFamilyValues | undefined;\n    let skipOnHoverRender = false;\n\n    if (currentItemFontFamily) {\n      nextFontFamily = currentItemFontFamily;\n      nextCaptureUpdateAction = CaptureUpdateAction.IMMEDIATELY;\n    } else if (currentHoveredFontFamily) {\n      nextFontFamily = currentHoveredFontFamily;\n      nextCaptureUpdateAction = CaptureUpdateAction.EVENTUALLY;\n\n      const selectedTextElements = getSelectedElements(elements, appState, {\n        includeBoundTextElement: true,\n      }).filter((element) => isTextElement(element));\n\n      // skip on hover re-render for more than 200 text elements or for text element with more than 5000 chars combined\n      if (selectedTextElements.length > 200) {\n        skipOnHoverRender = true;\n      } else {\n        let i = 0;\n        let textLengthAccumulator = 0;\n\n        while (\n          i < selectedTextElements.length &&\n          textLengthAccumulator < 5000\n        ) {\n          const textElement = selectedTextElements[i] as ExcalidrawTextElement;\n          textLengthAccumulator += textElement?.originalText.length || 0;\n          i++;\n        }\n\n        if (textLengthAccumulator > 5000) {\n          skipOnHoverRender = true;\n        }\n      }\n    }\n\n    const result = {\n      appState: {\n        ...appState,\n        ...nextAppState,\n      },\n      captureUpdate: nextCaptureUpdateAction,\n    };\n\n    if (nextFontFamily && !skipOnHoverRender) {\n      const elementContainerMapping = new Map<\n        ExcalidrawTextElement,\n        ExcalidrawElement | null\n      >();\n      let uniqueChars = new Set<string>();\n      let skipFontFaceCheck = false;\n\n      const fontsCache = Array.from(Fonts.loadedFontsCache.values());\n      const fontFamily = Object.entries(FONT_FAMILY).find(\n        ([_, value]) => value === nextFontFamily,\n      )?.[0];\n\n      // skip `document.font.check` check on hover, if at least one font family has loaded as it's super slow (could result in slightly different bbox, which is fine)\n      if (\n        currentHoveredFontFamily &&\n        fontFamily &&\n        fontsCache.some((sig) => sig.startsWith(fontFamily))\n      ) {\n        skipFontFaceCheck = true;\n      }\n\n      // following causes re-render so make sure we changed the family\n      // otherwise it could cause unexpected issues, such as preventing opening the popover when in wysiwyg\n      Object.assign(result, {\n        elements: changeProperty(\n          elements,\n          appState,\n          (oldElement) => {\n            if (\n              isTextElement(oldElement) &&\n              (oldElement.fontFamily !== nextFontFamily ||\n                currentItemFontFamily) // force update on selection\n            ) {\n              const newElement: ExcalidrawTextElement = newElementWith(\n                oldElement,\n                {\n                  fontFamily: nextFontFamily,\n                  lineHeight: getLineHeight(nextFontFamily!),\n                },\n              );\n\n              const cachedContainer =\n                cachedElements?.get(oldElement.containerId || \"\") || {};\n\n              const container = app.scene.getContainerElement(oldElement);\n\n              if (resetContainers && container && cachedContainer) {\n                // reset the container back to it's cached version\n                app.scene.mutateElement(container, { ...cachedContainer });\n              }\n\n              if (!skipFontFaceCheck) {\n                uniqueChars = new Set([\n                  ...uniqueChars,\n                  ...Array.from(newElement.originalText),\n                ]);\n              }\n\n              elementContainerMapping.set(newElement, container);\n\n              return newElement;\n            }\n\n            return oldElement;\n          },\n          true,\n        ),\n      });\n\n      // size is irrelevant, but necessary\n      const fontString = `10px ${getFontFamilyString({\n        fontFamily: nextFontFamily,\n      })}`;\n      const chars = Array.from(uniqueChars.values()).join();\n\n      if (skipFontFaceCheck || window.document.fonts.check(fontString, chars)) {\n        // we either skip the check (have at least one font face loaded) or do the check and find out all the font faces have loaded\n        for (const [element, container] of elementContainerMapping) {\n          // trigger synchronous redraw\n          redrawTextBoundingBox(element, container, app.scene);\n        }\n      } else {\n        // otherwise try to load all font faces for the given chars and redraw elements once our font faces loaded\n        window.document.fonts.load(fontString, chars).then((fontFaces) => {\n          for (const [element, container] of elementContainerMapping) {\n            // use latest element state to ensure we don't have closure over an old instance in order to avoid possible race conditions (i.e. font faces load out-of-order while rapidly switching fonts)\n            const latestElement = app.scene.getElement(element.id);\n            const latestContainer = container\n              ? app.scene.getElement(container.id)\n              : null;\n\n            if (latestElement) {\n              // trigger async redraw\n              redrawTextBoundingBox(\n                latestElement as ExcalidrawTextElement,\n                latestContainer,\n                app.scene,\n              );\n            }\n          }\n\n          // trigger update once we've mutated all the elements, which also updates our cache\n          app.fonts.onLoaded(fontFaces);\n        });\n      }\n    }\n\n    return result;\n  },\n  PanelComponent: ({ elements, appState, app, updateData }) => {\n    const cachedElementsRef = useRef<ElementsMap>(new Map());\n    const prevSelectedFontFamilyRef = useRef<number | null>(null);\n    // relying on state batching as multiple `FontPicker` handlers could be called in rapid succession and we want to combine them\n    const [batchedData, setBatchedData] = useState<ChangeFontFamilyData>({});\n    const isUnmounted = useRef(true);\n\n    const selectedFontFamily = useMemo(() => {\n      const getFontFamily = (\n        elementsArray: readonly ExcalidrawElement[],\n        elementsMap: ElementsMap,\n      ) =>\n        getFormValue(\n          elementsArray,\n          app,\n          (element) => {\n            if (isTextElement(element)) {\n              return element.fontFamily;\n            }\n            const boundTextElement = getBoundTextElement(element, elementsMap);\n            if (boundTextElement) {\n              return boundTextElement.fontFamily;\n            }\n            return null;\n          },\n          (element) =>\n            isTextElement(element) ||\n            getBoundTextElement(element, elementsMap) !== null,\n          (hasSelection) =>\n            hasSelection\n              ? null\n              : appState.currentItemFontFamily || DEFAULT_FONT_FAMILY,\n        );\n\n      // popup opened, use cached elements\n      if (\n        batchedData.openPopup === \"fontFamily\" &&\n        appState.openPopup === \"fontFamily\"\n      ) {\n        return getFontFamily(\n          Array.from(cachedElementsRef.current?.values() ?? []),\n          cachedElementsRef.current,\n        );\n      }\n\n      // popup closed, use all elements\n      if (!batchedData.openPopup && appState.openPopup !== \"fontFamily\") {\n        return getFontFamily(elements, app.scene.getNonDeletedElementsMap());\n      }\n\n      // popup props are not in sync, hence we are in the middle of an update, so keeping the previous value we've had\n      return prevSelectedFontFamilyRef.current;\n    }, [batchedData.openPopup, appState, elements, app]);\n\n    useEffect(() => {\n      prevSelectedFontFamilyRef.current = selectedFontFamily;\n    }, [selectedFontFamily]);\n\n    useEffect(() => {\n      if (Object.keys(batchedData).length) {\n        updateData(batchedData);\n        // reset the data after we've used the data\n        setBatchedData({});\n      }\n      // call update only on internal state changes\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [batchedData]);\n\n    useEffect(() => {\n      isUnmounted.current = false;\n\n      return () => {\n        isUnmounted.current = true;\n      };\n    }, []);\n\n    return (\n      <fieldset>\n        <legend>{t(\"labels.fontFamily\")}</legend>\n        <FontPicker\n          isOpened={appState.openPopup === \"fontFamily\"}\n          selectedFontFamily={selectedFontFamily}\n          hoveredFontFamily={appState.currentHoveredFontFamily}\n          onSelect={(fontFamily) => {\n            setBatchedData({\n              openPopup: null,\n              currentHoveredFontFamily: null,\n              currentItemFontFamily: fontFamily,\n            });\n\n            // defensive clear so immediate close won't abuse the cached elements\n            cachedElementsRef.current.clear();\n          }}\n          onHover={(fontFamily) => {\n            setBatchedData({\n              currentHoveredFontFamily: fontFamily,\n              cachedElements: new Map(cachedElementsRef.current),\n              resetContainers: true,\n            });\n          }}\n          onLeave={() => {\n            setBatchedData({\n              currentHoveredFontFamily: null,\n              cachedElements: new Map(cachedElementsRef.current),\n              resetAll: true,\n            });\n          }}\n          onPopupChange={(open) => {\n            if (open) {\n              // open, populate the cache from scratch\n              cachedElementsRef.current.clear();\n\n              const { editingTextElement } = appState;\n\n              // still check type to be safe\n              if (editingTextElement?.type === \"text\") {\n                // retrieve the latest version from the scene, as `editingTextElement` isn't mutated\n                const latesteditingTextElement = app.scene.getElement(\n                  editingTextElement.id,\n                );\n\n                // inside the wysiwyg editor\n                cachedElementsRef.current.set(\n                  editingTextElement.id,\n                  newElementWith(\n                    latesteditingTextElement || editingTextElement,\n                    {},\n                    true,\n                  ),\n                );\n              } else {\n                const selectedElements = getSelectedElements(\n                  elements,\n                  appState,\n                  {\n                    includeBoundTextElement: true,\n                  },\n                );\n\n                for (const element of selectedElements) {\n                  cachedElementsRef.current.set(\n                    element.id,\n                    newElementWith(element, {}, true),\n                  );\n                }\n              }\n\n              setBatchedData({\n                openPopup: \"fontFamily\",\n              });\n            } else {\n              // close, use the cache and clear it afterwards\n              const data = {\n                openPopup: null,\n                currentHoveredFontFamily: null,\n                cachedElements: new Map(cachedElementsRef.current),\n                resetAll: true,\n              } as ChangeFontFamilyData;\n\n              if (isUnmounted.current) {\n                // in case the component was unmounted by the parent, trigger the update directly\n                updateData({ ...batchedData, ...data });\n              } else {\n                setBatchedData(data);\n              }\n\n              cachedElementsRef.current.clear();\n            }\n          }}\n        />\n      </fieldset>\n    );\n  },\n});\n\nexport const actionChangeTextAlign = register({\n  name: \"changeTextAlign\",\n  label: \"Change text alignment\",\n  trackEvent: false,\n  perform: (elements, appState, value, app) => {\n    return {\n      elements: changeProperty(\n        elements,\n        appState,\n        (oldElement) => {\n          if (isTextElement(oldElement)) {\n            const newElement: ExcalidrawTextElement = newElementWith(\n              oldElement,\n              { textAlign: value },\n            );\n            redrawTextBoundingBox(\n              newElement,\n              app.scene.getContainerElement(oldElement),\n              app.scene,\n            );\n            return newElement;\n          }\n\n          return oldElement;\n        },\n        true,\n      ),\n      appState: {\n        ...appState,\n        currentItemTextAlign: value,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => {\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n    return (\n      <fieldset>\n        <legend>{t(\"labels.textAlign\")}</legend>\n        <div className=\"buttonList\">\n          <RadioSelection<TextAlign | false>\n            group=\"text-align\"\n            options={[\n              {\n                value: \"left\",\n                text: t(\"labels.left\"),\n                icon: TextAlignLeftIcon,\n                testId: \"align-left\",\n              },\n              {\n                value: \"center\",\n                text: t(\"labels.center\"),\n                icon: TextAlignCenterIcon,\n                testId: \"align-horizontal-center\",\n              },\n              {\n                value: \"right\",\n                text: t(\"labels.right\"),\n                icon: TextAlignRightIcon,\n                testId: \"align-right\",\n              },\n            ]}\n            value={getFormValue(\n              elements,\n              app,\n              (element) => {\n                if (isTextElement(element)) {\n                  return element.textAlign;\n                }\n                const boundTextElement = getBoundTextElement(\n                  element,\n                  elementsMap,\n                );\n                if (boundTextElement) {\n                  return boundTextElement.textAlign;\n                }\n                return null;\n              },\n              (element) =>\n                isTextElement(element) ||\n                getBoundTextElement(element, elementsMap) !== null,\n              (hasSelection) =>\n                hasSelection ? null : appState.currentItemTextAlign,\n            )}\n            onChange={(value) => updateData(value)}\n          />\n        </div>\n      </fieldset>\n    );\n  },\n});\n\nexport const actionChangeVerticalAlign = register({\n  name: \"changeVerticalAlign\",\n  label: \"Change vertical alignment\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, value, app) => {\n    return {\n      elements: changeProperty(\n        elements,\n        appState,\n        (oldElement) => {\n          if (isTextElement(oldElement)) {\n            const newElement: ExcalidrawTextElement = newElementWith(\n              oldElement,\n              { verticalAlign: value },\n            );\n\n            redrawTextBoundingBox(\n              newElement,\n              app.scene.getContainerElement(oldElement),\n              app.scene,\n            );\n            return newElement;\n          }\n\n          return oldElement;\n        },\n        true,\n      ),\n      appState: {\n        ...appState,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => {\n    return (\n      <fieldset>\n        <div className=\"buttonList\">\n          <RadioSelection<VerticalAlign | false>\n            group=\"text-align\"\n            options={[\n              {\n                value: VERTICAL_ALIGN.TOP,\n                text: t(\"labels.alignTop\"),\n                icon: <TextAlignTopIcon theme={appState.theme} />,\n                testId: \"align-top\",\n              },\n              {\n                value: VERTICAL_ALIGN.MIDDLE,\n                text: t(\"labels.centerVertically\"),\n                icon: <TextAlignMiddleIcon theme={appState.theme} />,\n                testId: \"align-middle\",\n              },\n              {\n                value: VERTICAL_ALIGN.BOTTOM,\n                text: t(\"labels.alignBottom\"),\n                icon: <TextAlignBottomIcon theme={appState.theme} />,\n                testId: \"align-bottom\",\n              },\n            ]}\n            value={getFormValue(\n              elements,\n              app,\n              (element) => {\n                if (isTextElement(element) && element.containerId) {\n                  return element.verticalAlign;\n                }\n                const boundTextElement = getBoundTextElement(\n                  element,\n                  app.scene.getNonDeletedElementsMap(),\n                );\n                if (boundTextElement) {\n                  return boundTextElement.verticalAlign;\n                }\n                return null;\n              },\n              (element) =>\n                isTextElement(element) ||\n                getBoundTextElement(\n                  element,\n                  app.scene.getNonDeletedElementsMap(),\n                ) !== null,\n              (hasSelection) => (hasSelection ? null : VERTICAL_ALIGN.MIDDLE),\n            )}\n            onChange={(value) => updateData(value)}\n          />\n        </div>\n      </fieldset>\n    );\n  },\n});\n\nexport const actionChangeRoundness = register({\n  name: \"changeRoundness\",\n  label: \"Change edge roundness\",\n  trackEvent: false,\n  perform: (elements, appState, value) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isElbowArrow(el)) {\n          return el;\n        }\n\n        return newElementWith(el, {\n          roundness:\n            value === \"round\"\n              ? {\n                  type: isUsingAdaptiveRadius(el.type)\n                    ? ROUNDNESS.ADAPTIVE_RADIUS\n                    : ROUNDNESS.PROPORTIONAL_RADIUS,\n                }\n              : null,\n        });\n      }),\n      appState: {\n        ...appState,\n        currentItemRoundness: value,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app, renderAction }) => {\n    const targetElements = getTargetElements(\n      getNonDeletedElements(elements),\n      appState,\n    );\n\n    const hasLegacyRoundness = targetElements.some(\n      (el) => el.roundness?.type === ROUNDNESS.LEGACY,\n    );\n\n    return (\n      <fieldset>\n        <legend>{t(\"labels.edges\")}</legend>\n        <div className=\"buttonList\">\n          <RadioSelection\n            group=\"edges\"\n            options={[\n              {\n                value: \"sharp\",\n                text: t(\"labels.sharp\"),\n                icon: EdgeSharpIcon,\n              },\n              {\n                value: \"round\",\n                text: t(\"labels.round\"),\n                icon: EdgeRoundIcon,\n              },\n            ]}\n            value={getFormValue(\n              elements,\n              app,\n              (element) =>\n                hasLegacyRoundness\n                  ? null\n                  : element.roundness\n                  ? \"round\"\n                  : \"sharp\",\n              (element) =>\n                !isArrowElement(element) && element.hasOwnProperty(\"roundness\"),\n              (hasSelection) =>\n                hasSelection ? null : appState.currentItemRoundness,\n            )}\n            onChange={(value) => updateData(value)}\n          />\n          {renderAction(\"togglePolygon\")}\n        </div>\n      </fieldset>\n    );\n  },\n});\n\nconst getArrowheadOptions = (flip: boolean) => {\n  return [\n    {\n      value: null,\n      text: t(\"labels.arrowhead_none\"),\n      keyBinding: \"q\",\n      icon: ArrowheadNoneIcon,\n    },\n    {\n      value: \"arrow\",\n      text: t(\"labels.arrowhead_arrow\"),\n      keyBinding: \"w\",\n      icon: <ArrowheadArrowIcon flip={flip} />,\n    },\n    {\n      value: \"triangle\",\n      text: t(\"labels.arrowhead_triangle\"),\n      icon: <ArrowheadTriangleIcon flip={flip} />,\n      keyBinding: \"e\",\n    },\n    {\n      value: \"triangle_outline\",\n      text: t(\"labels.arrowhead_triangle_outline\"),\n      icon: <ArrowheadTriangleOutlineIcon flip={flip} />,\n      keyBinding: \"r\",\n    },\n    {\n      value: \"circle\",\n      text: t(\"labels.arrowhead_circle\"),\n      keyBinding: \"a\",\n      icon: <ArrowheadCircleIcon flip={flip} />,\n    },\n    {\n      value: \"circle_outline\",\n      text: t(\"labels.arrowhead_circle_outline\"),\n      keyBinding: \"s\",\n      icon: <ArrowheadCircleOutlineIcon flip={flip} />,\n    },\n    {\n      value: \"diamond\",\n      text: t(\"labels.arrowhead_diamond\"),\n      icon: <ArrowheadDiamondIcon flip={flip} />,\n      keyBinding: \"d\",\n    },\n    {\n      value: \"diamond_outline\",\n      text: t(\"labels.arrowhead_diamond_outline\"),\n      icon: <ArrowheadDiamondOutlineIcon flip={flip} />,\n      keyBinding: \"f\",\n    },\n    {\n      value: \"bar\",\n      text: t(\"labels.arrowhead_bar\"),\n      keyBinding: \"z\",\n      icon: <ArrowheadBarIcon flip={flip} />,\n    },\n    {\n      value: \"crowfoot_one\",\n      text: t(\"labels.arrowhead_crowfoot_one\"),\n      icon: <ArrowheadCrowfootOneIcon flip={flip} />,\n      keyBinding: \"x\",\n    },\n    {\n      value: \"crowfoot_many\",\n      text: t(\"labels.arrowhead_crowfoot_many\"),\n      icon: <ArrowheadCrowfootIcon flip={flip} />,\n      keyBinding: \"c\",\n    },\n    {\n      value: \"crowfoot_one_or_many\",\n      text: t(\"labels.arrowhead_crowfoot_one_or_many\"),\n      icon: <ArrowheadCrowfootOneOrManyIcon flip={flip} />,\n      keyBinding: \"v\",\n    },\n  ] as const;\n};\n\nexport const actionChangeArrowhead = register({\n  name: \"changeArrowhead\",\n  label: \"Change arrowheads\",\n  trackEvent: false,\n  perform: (\n    elements,\n    appState,\n    value: { position: \"start\" | \"end\"; type: Arrowhead },\n  ) => {\n    return {\n      elements: changeProperty(elements, appState, (el) => {\n        if (isLinearElement(el)) {\n          const { position, type } = value;\n\n          if (position === \"start\") {\n            const element: ExcalidrawLinearElement = newElementWith(el, {\n              startArrowhead: type,\n            });\n            return element;\n          } else if (position === \"end\") {\n            const element: ExcalidrawLinearElement = newElementWith(el, {\n              endArrowhead: type,\n            });\n            return element;\n          }\n        }\n\n        return el;\n      }),\n      appState: {\n        ...appState,\n        [value.position === \"start\"\n          ? \"currentItemStartArrowhead\"\n          : \"currentItemEndArrowhead\"]: value.type,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => {\n    const isRTL = getLanguage().rtl;\n\n    return (\n      <fieldset>\n        <legend>{t(\"labels.arrowheads\")}</legend>\n        <div className=\"iconSelectList buttonList\">\n          <IconPicker\n            label=\"arrowhead_start\"\n            options={getArrowheadOptions(!isRTL)}\n            value={getFormValue<Arrowhead | null>(\n              elements,\n              app,\n              (element) =>\n                isLinearElement(element) && canHaveArrowheads(element.type)\n                  ? element.startArrowhead\n                  : appState.currentItemStartArrowhead,\n              true,\n              appState.currentItemStartArrowhead,\n            )}\n            onChange={(value) => updateData({ position: \"start\", type: value })}\n            numberOfOptionsToAlwaysShow={4}\n          />\n          <IconPicker\n            label=\"arrowhead_end\"\n            group=\"arrowheads\"\n            options={getArrowheadOptions(!!isRTL)}\n            value={getFormValue<Arrowhead | null>(\n              elements,\n              app,\n              (element) =>\n                isLinearElement(element) && canHaveArrowheads(element.type)\n                  ? element.endArrowhead\n                  : appState.currentItemEndArrowhead,\n              true,\n              appState.currentItemEndArrowhead,\n            )}\n            onChange={(value) => updateData({ position: \"end\", type: value })}\n            numberOfOptionsToAlwaysShow={4}\n          />\n        </div>\n      </fieldset>\n    );\n  },\n});\n\nexport const actionChangeArrowType = register({\n  name: \"changeArrowType\",\n  label: \"Change arrow types\",\n  trackEvent: false,\n  perform: (elements, appState, value, app) => {\n    const newElements = changeProperty(elements, appState, (el) => {\n      if (!isArrowElement(el)) {\n        return el;\n      }\n      let newElement = newElementWith(el, {\n        roundness:\n          value === ARROW_TYPE.round\n            ? {\n                type: ROUNDNESS.PROPORTIONAL_RADIUS,\n              }\n            : null,\n        elbowed: value === ARROW_TYPE.elbow,\n        points:\n          value === ARROW_TYPE.elbow || el.elbowed\n            ? [el.points[0], el.points[el.points.length - 1]]\n            : el.points,\n      });\n\n      if (isElbowArrow(newElement)) {\n        newElement.fixedSegments = null;\n\n        const elementsMap = app.scene.getNonDeletedElementsMap();\n\n        app.dismissLinearEditor();\n\n        const startGlobalPoint =\n          LinearElementEditor.getPointAtIndexGlobalCoordinates(\n            newElement,\n            0,\n            elementsMap,\n          );\n        const endGlobalPoint =\n          LinearElementEditor.getPointAtIndexGlobalCoordinates(\n            newElement,\n            -1,\n            elementsMap,\n          );\n        const startElement =\n          newElement.startBinding &&\n          (elementsMap.get(\n            newElement.startBinding.elementId,\n          ) as ExcalidrawBindableElement);\n        const endElement =\n          newElement.endBinding &&\n          (elementsMap.get(\n            newElement.endBinding.elementId,\n          ) as ExcalidrawBindableElement);\n\n        const startBinding =\n          startElement && newElement.startBinding\n            ? {\n                // @ts-ignore TS cannot discern check above\n                ...newElement.startBinding!,\n                ...calculateFixedPointForElbowArrowBinding(\n                  newElement,\n                  startElement,\n                  \"start\",\n                  elementsMap,\n                ),\n              }\n            : null;\n        const endBinding =\n          endElement && newElement.endBinding\n            ? {\n                // @ts-ignore TS cannot discern check above\n                ...newElement.endBinding,\n                ...calculateFixedPointForElbowArrowBinding(\n                  newElement,\n                  endElement,\n                  \"end\",\n                  elementsMap,\n                ),\n              }\n            : null;\n\n        newElement = {\n          ...newElement,\n          startBinding,\n          endBinding,\n          ...updateElbowArrowPoints(newElement, elementsMap, {\n            points: [startGlobalPoint, endGlobalPoint].map(\n              (p): LocalPoint =>\n                pointFrom(p[0] - newElement.x, p[1] - newElement.y),\n            ),\n            startBinding,\n            endBinding,\n            fixedSegments: null,\n          }),\n        };\n      } else {\n        const elementsMap = app.scene.getNonDeletedElementsMap();\n        if (newElement.startBinding) {\n          const startElement = elementsMap.get(\n            newElement.startBinding.elementId,\n          ) as ExcalidrawBindableElement;\n          if (startElement) {\n            bindLinearElement(newElement, startElement, \"start\", app.scene);\n          }\n        }\n        if (newElement.endBinding) {\n          const endElement = elementsMap.get(\n            newElement.endBinding.elementId,\n          ) as ExcalidrawBindableElement;\n          if (endElement) {\n            bindLinearElement(newElement, endElement, \"end\", app.scene);\n          }\n        }\n      }\n\n      return newElement;\n    });\n\n    const newState = {\n      ...appState,\n      currentItemArrowType: value,\n    };\n\n    // Change the arrow type and update any other state settings for\n    // the arrow.\n    const selectedId = appState.selectedLinearElement?.elementId;\n    if (selectedId) {\n      const selected = newElements.find((el) => el.id === selectedId);\n      if (selected) {\n        newState.selectedLinearElement = new LinearElementEditor(\n          selected as ExcalidrawLinearElement,\n          arrayToMap(elements),\n        );\n      }\n    }\n\n    return {\n      elements: newElements,\n      appState: newState,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => {\n    return (\n      <fieldset>\n        <legend>{t(\"labels.arrowtypes\")}</legend>\n        <div className=\"buttonList\">\n          <RadioSelection\n            group=\"arrowtypes\"\n            options={[\n              {\n                value: ARROW_TYPE.sharp,\n                text: t(\"labels.arrowtype_sharp\"),\n                icon: sharpArrowIcon,\n                testId: \"sharp-arrow\",\n              },\n              {\n                value: ARROW_TYPE.round,\n                text: t(\"labels.arrowtype_round\"),\n                icon: roundArrowIcon,\n                testId: \"round-arrow\",\n              },\n              {\n                value: ARROW_TYPE.elbow,\n                text: t(\"labels.arrowtype_elbowed\"),\n                icon: elbowArrowIcon,\n                testId: \"elbow-arrow\",\n              },\n            ]}\n            value={getFormValue(\n              elements,\n              app,\n              (element) => {\n                if (isArrowElement(element)) {\n                  return element.elbowed\n                    ? ARROW_TYPE.elbow\n                    : element.roundness\n                    ? ARROW_TYPE.round\n                    : ARROW_TYPE.sharp;\n                }\n\n                return null;\n              },\n              (element) => isArrowElement(element),\n              (hasSelection) =>\n                hasSelection ? null : appState.currentItemArrowType,\n            )}\n            onChange={(value) => updateData(value)}\n          />\n        </div>\n      </fieldset>\n    );\n  },\n});\n",
    "// place here categories that you want to track. We want to track just a\n\nimport { isDevEnv } from \"@excalidraw/common\";\n\n// small subset of categories at a given time.\nconst ALLOWED_CATEGORIES_TO_TRACK = new Set([\"command_palette\", \"export\"]);\n\nexport const trackEvent = (\n  category: string,\n  action: string,\n  label?: string,\n  value?: number,\n) => {\n  try {\n    if (\n      typeof window === \"undefined\" ||\n      import.meta.env.VITE_WORKER_ID ||\n      import.meta.env.VITE_APP_ENABLE_TRACKING !== \"true\"\n    ) {\n      return;\n    }\n\n    if (!ALLOWED_CATEGORIES_TO_TRACK.has(category)) {\n      return;\n    }\n\n    if (isDevEnv()) {\n      // comment out to debug in dev\n      return;\n    }\n\n    if (!import.meta.env.PROD) {\n      console.info(\"trackEvent\", { category, action, label, value });\n    }\n\n    if (window.sa_event) {\n      window.sa_event(action, {\n        category,\n        label,\n        value,\n      });\n    }\n  } catch (error) {\n    console.error(\"error during analytics\", error);\n  }\n};\n",
    "import clsx from \"clsx\";\n\nimport { ButtonIcon } from \"./ButtonIcon\";\n\nimport type { JSX } from \"react\";\n\nexport const RadioSelection = <T extends Object>(\n  props: {\n    options: {\n      value: T;\n      text: string;\n      icon: JSX.Element;\n      testId?: string;\n      /** if not supplied, defaults to value identity check */\n      active?: boolean;\n    }[];\n    value: T | null;\n    type?: \"radio\" | \"button\";\n  } & (\n    | { type?: \"radio\"; group: string; onChange: (value: T) => void }\n    | {\n        type: \"button\";\n        onClick: (\n          value: T,\n          event: React.MouseEvent<HTMLButtonElement, MouseEvent>,\n        ) => void;\n      }\n  ),\n) => (\n  <>\n    {props.options.map((option) =>\n      props.type === \"button\" ? (\n        <ButtonIcon\n          key={option.text}\n          icon={option.icon}\n          title={option.text}\n          testId={option.testId}\n          active={option.active ?? props.value === option.value}\n          onClick={(event) => props.onClick(option.value, event)}\n        />\n      ) : (\n        <label\n          key={option.text}\n          className={clsx({ active: props.value === option.value })}\n          title={option.text}\n        >\n          <input\n            type=\"radio\"\n            name={props.group}\n            onChange={() => props.onChange(option.value)}\n            checked={props.value === option.value}\n            data-testid={option.testId}\n          />\n          {option.icon}\n        </label>\n      ),\n    )}\n  </>\n);\n",
    "import clsx from \"clsx\";\nimport { forwardRef } from \"react\";\n\nimport \"./ButtonIcon.scss\";\n\nimport type { JSX } from \"react\";\n\ninterface ButtonIconProps {\n  icon: JSX.Element;\n  title: string;\n  className?: string;\n  testId?: string;\n  /** if not supplied, defaults to value identity check */\n  active?: boolean;\n  /** include standalone style (could interfere with parent styles) */\n  standalone?: boolean;\n  onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n  style?: React.CSSProperties;\n}\n\nexport const ButtonIcon = forwardRef<HTMLButtonElement, ButtonIconProps>(\n  (props, ref) => {\n    const { title, className, testId, active, standalone, icon, onClick } =\n      props;\n    return (\n      <button\n        type=\"button\"\n        ref={ref}\n        key={title}\n        title={title}\n        data-testid={testId}\n        className={clsx(className, { standalone, active })}\n        onClick={onClick}\n        style={props.style}\n      >\n        {icon}\n      </button>\n    );\n  },\n);\n",
    "import * as Popover from \"@radix-ui/react-popover\";\nimport clsx from \"clsx\";\nimport { useRef } from \"react\";\n\nimport {\n  COLOR_OUTLINE_CONTRAST_THRESHOLD,\n  COLOR_PALETTE,\n  isTransparent,\n} from \"@excalidraw/common\";\n\nimport type { ColorTuple, ColorPaletteCustom } from \"@excalidraw/common\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { useAtom } from \"../../editor-jotai\";\nimport { t } from \"../../i18n\";\nimport { useExcalidrawContainer } from \"../App\";\nimport { ButtonSeparator } from \"../ButtonSeparator\";\nimport { activeEyeDropperAtom } from \"../EyeDropper\";\nimport { PropertiesPopover } from \"../PropertiesPopover\";\nimport { slashIcon } from \"../icons\";\n\nimport { ColorInput } from \"./ColorInput\";\nimport { Picker } from \"./Picker\";\nimport PickerHeading from \"./PickerHeading\";\nimport { TopPicks } from \"./TopPicks\";\nimport { activeColorPickerSectionAtom, isColorDark } from \"./colorPickerUtils\";\n\nimport \"./ColorPicker.scss\";\n\nimport type { ColorPickerType } from \"./colorPickerUtils\";\n\nimport type { AppState } from \"../../types\";\n\nconst isValidColor = (color: string) => {\n  const style = new Option().style;\n  style.color = color;\n  return !!style.color;\n};\n\nexport const getColor = (color: string): string | null => {\n  if (isTransparent(color)) {\n    return color;\n  }\n\n  // testing for `#` first fixes a bug on Electron (more specfically, an\n  // Obsidian popout window), where a hex color without `#` is (incorrectly)\n  // considered valid\n  return isValidColor(`#${color}`)\n    ? `#${color}`\n    : isValidColor(color)\n    ? color\n    : null;\n};\n\ninterface ColorPickerProps {\n  type: ColorPickerType;\n  /**\n   * null indicates no color should be displayed as active\n   * (e.g. when multiple shapes selected with different colors)\n   */\n  color: string | null;\n  onChange: (color: string) => void;\n  label: string;\n  elements: readonly ExcalidrawElement[];\n  appState: AppState;\n  palette?: ColorPaletteCustom | null;\n  topPicks?: ColorTuple;\n  updateData: (formData?: any) => void;\n}\n\nconst ColorPickerPopupContent = ({\n  type,\n  color,\n  onChange,\n  label,\n  elements,\n  palette = COLOR_PALETTE,\n  updateData,\n}: Pick<\n  ColorPickerProps,\n  | \"type\"\n  | \"color\"\n  | \"onChange\"\n  | \"label\"\n  | \"elements\"\n  | \"palette\"\n  | \"updateData\"\n>) => {\n  const { container } = useExcalidrawContainer();\n  const [, setActiveColorPickerSection] = useAtom(activeColorPickerSectionAtom);\n\n  const [eyeDropperState, setEyeDropperState] = useAtom(activeEyeDropperAtom);\n\n  const colorInputJSX = (\n    <div>\n      <PickerHeading>{t(\"colorPicker.hexCode\")}</PickerHeading>\n      <ColorInput\n        color={color || \"\"}\n        label={label}\n        onChange={(color) => {\n          onChange(color);\n        }}\n        colorPickerType={type}\n        placeholder={t(\"colorPicker.color\")}\n      />\n    </div>\n  );\n\n  const colorPickerContentRef = useRef<HTMLDivElement>(null);\n\n  const focusPickerContent = () => {\n    colorPickerContentRef.current?.focus();\n  };\n\n  return (\n    <PropertiesPopover\n      container={container}\n      style={{ maxWidth: \"13rem\" }}\n      onFocusOutside={(event) => {\n        // refocus due to eye dropper\n        focusPickerContent();\n        event.preventDefault();\n      }}\n      onPointerDownOutside={(event) => {\n        if (eyeDropperState) {\n          // prevent from closing if we click outside the popover\n          // while eyedropping (e.g. click when clicking the sidebar;\n          // the eye-dropper-backdrop is prevented downstream)\n          event.preventDefault();\n        }\n      }}\n      onClose={() => {\n        updateData({ openPopup: null });\n        setActiveColorPickerSection(null);\n      }}\n    >\n      {palette ? (\n        <Picker\n          ref={colorPickerContentRef}\n          palette={palette}\n          color={color}\n          onChange={(changedColor) => {\n            onChange(changedColor);\n          }}\n          onEyeDropperToggle={(force) => {\n            setEyeDropperState((state) => {\n              if (force) {\n                state = state || {\n                  keepOpenOnAlt: true,\n                  onSelect: onChange,\n                  colorPickerType: type,\n                };\n                state.keepOpenOnAlt = true;\n                return state;\n              }\n\n              return force === false || state\n                ? null\n                : {\n                    keepOpenOnAlt: false,\n                    onSelect: onChange,\n                    colorPickerType: type,\n                  };\n            });\n          }}\n          onEscape={(event) => {\n            if (eyeDropperState) {\n              setEyeDropperState(null);\n            } else {\n              updateData({ openPopup: null });\n            }\n          }}\n          type={type}\n          elements={elements}\n          updateData={updateData}\n        >\n          {colorInputJSX}\n        </Picker>\n      ) : (\n        colorInputJSX\n      )}\n    </PropertiesPopover>\n  );\n};\n\nconst ColorPickerTrigger = ({\n  label,\n  color,\n  type,\n}: {\n  color: string | null;\n  label: string;\n  type: ColorPickerType;\n}) => {\n  return (\n    <Popover.Trigger\n      type=\"button\"\n      className={clsx(\"color-picker__button active-color properties-trigger\", {\n        \"is-transparent\": !color || color === \"transparent\",\n        \"has-outline\":\n          !color || !isColorDark(color, COLOR_OUTLINE_CONTRAST_THRESHOLD),\n      })}\n      aria-label={label}\n      style={color ? { \"--swatch-color\": color } : undefined}\n      title={\n        type === \"elementStroke\"\n          ? t(\"labels.showStroke\")\n          : t(\"labels.showBackground\")\n      }\n    >\n      <div className=\"color-picker__button-outline\">{!color && slashIcon}</div>\n    </Popover.Trigger>\n  );\n};\n\nexport const ColorPicker = ({\n  type,\n  color,\n  onChange,\n  label,\n  elements,\n  palette = COLOR_PALETTE,\n  topPicks,\n  updateData,\n  appState,\n}: ColorPickerProps) => {\n  return (\n    <div>\n      <div role=\"dialog\" aria-modal=\"true\" className=\"color-picker-container\">\n        <TopPicks\n          activeColor={color}\n          onChange={onChange}\n          type={type}\n          topPicks={topPicks}\n        />\n        <ButtonSeparator />\n        <Popover.Root\n          open={appState.openPopup === type}\n          onOpenChange={(open) => {\n            updateData({ openPopup: open ? type : null });\n          }}\n        >\n          {/* serves as an active color indicator as well */}\n          <ColorPickerTrigger color={color} label={label} type={type} />\n          {/* popup content */}\n          {appState.openPopup === type && (\n            <ColorPickerPopupContent\n              type={type}\n              color={color}\n              onChange={onChange}\n              label={label}\n              elements={elements}\n              palette={palette}\n              updateData={updateData}\n            />\n          )}\n        </Popover.Root>\n      </div>\n    </div>\n  );\n};\n",
    "export const ButtonSeparator = () => (\n  <div\n    style={{\n      width: 1,\n      height: \"1rem\",\n      backgroundColor: \"var(--default-border-color)\",\n      margin: \"0 auto\",\n    }}\n  />\n);\n",
    "import { useEffect, useRef } from \"react\";\nimport { createPortal } from \"react-dom\";\n\nimport { EVENT, KEYS, rgbToHex } from \"@excalidraw/common\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { useUIAppState } from \"../context/ui-appState\";\nimport { atom } from \"../editor-jotai\";\nimport { useCreatePortalContainer } from \"../hooks/useCreatePortalContainer\";\nimport { useOutsideClick } from \"../hooks/useOutsideClick\";\nimport { useStable } from \"../hooks/useStable\";\nimport { getSelectedElements } from \"../scene\";\n\nimport { useApp, useExcalidrawContainer, useExcalidrawElements } from \"./App\";\n\nimport \"./EyeDropper.scss\";\n\nimport type { ColorPickerType } from \"./ColorPicker/colorPickerUtils\";\n\nexport type EyeDropperProperties = {\n  keepOpenOnAlt: boolean;\n  swapPreviewOnAlt?: boolean;\n  /** called when user picks color (on pointerup) */\n  onSelect: (color: string, event: PointerEvent) => void;\n  /**\n   * property of selected elements to update live when alt-dragging.\n   * Supply `null` if not applicable (e.g. updating the canvas bg instead of\n   * elements)\n   **/\n  colorPickerType: ColorPickerType;\n};\n\nexport const activeEyeDropperAtom = atom<null | EyeDropperProperties>(null);\n\nexport const EyeDropper: React.FC<{\n  onCancel: () => void;\n  onSelect: EyeDropperProperties[\"onSelect\"];\n  /** called when color changes, on pointerdown for preview */\n  onChange: (\n    type: ColorPickerType,\n    color: string,\n    selectedElements: ExcalidrawElement[],\n    event: { altKey: boolean },\n  ) => void;\n  colorPickerType: EyeDropperProperties[\"colorPickerType\"];\n}> = ({ onCancel, onChange, onSelect, colorPickerType }) => {\n  const eyeDropperContainer = useCreatePortalContainer({\n    className: \"excalidraw-eye-dropper-backdrop\",\n    parentSelector: \".excalidraw-eye-dropper-container\",\n  });\n  const appState = useUIAppState();\n  const elements = useExcalidrawElements();\n  const app = useApp();\n\n  const selectedElements = getSelectedElements(elements, appState);\n\n  const stableProps = useStable({\n    app,\n    onCancel,\n    onChange,\n    onSelect,\n    selectedElements,\n  });\n\n  const { container: excalidrawContainer } = useExcalidrawContainer();\n\n  useEffect(() => {\n    const colorPreviewDiv = ref.current;\n\n    if (!colorPreviewDiv || !app.canvas || !eyeDropperContainer) {\n      return;\n    }\n\n    let isHoldingPointerDown = false;\n\n    const ctx = app.canvas.getContext(\"2d\")!;\n\n    const getCurrentColor = ({\n      clientX,\n      clientY,\n    }: {\n      clientX: number;\n      clientY: number;\n    }) => {\n      const pixel = ctx.getImageData(\n        (clientX - appState.offsetLeft) * window.devicePixelRatio,\n        (clientY - appState.offsetTop) * window.devicePixelRatio,\n        1,\n        1,\n      ).data;\n\n      return rgbToHex(pixel[0], pixel[1], pixel[2]);\n    };\n\n    const mouseMoveListener = ({\n      clientX,\n      clientY,\n      altKey,\n    }: {\n      clientX: number;\n      clientY: number;\n      altKey: boolean;\n    }) => {\n      // FIXME swap offset when the preview gets outside viewport\n      colorPreviewDiv.style.top = `${clientY + 20}px`;\n      colorPreviewDiv.style.left = `${clientX + 20}px`;\n\n      const currentColor = getCurrentColor({ clientX, clientY });\n\n      if (isHoldingPointerDown) {\n        stableProps.onChange(\n          colorPickerType,\n          currentColor,\n          stableProps.selectedElements,\n          { altKey },\n        );\n      }\n\n      colorPreviewDiv.style.background = currentColor;\n    };\n\n    const onCancel = () => {\n      stableProps.onCancel();\n    };\n\n    const onSelect: Required<EyeDropperProperties>[\"onSelect\"] = (\n      color,\n      event,\n    ) => {\n      stableProps.onSelect(color, event);\n    };\n\n    const pointerDownListener = (event: PointerEvent) => {\n      isHoldingPointerDown = true;\n      // NOTE we can't event.preventDefault() as that would stop\n      // pointermove events\n      event.stopImmediatePropagation();\n    };\n\n    const pointerUpListener = (event: PointerEvent) => {\n      isHoldingPointerDown = false;\n\n      // since we're not preventing default on pointerdown, the focus would\n      // goes back to `body` so we want to refocus the editor container instead\n      excalidrawContainer?.focus();\n\n      event.stopImmediatePropagation();\n      event.preventDefault();\n\n      onSelect(getCurrentColor(event), event);\n    };\n\n    const keyDownListener = (event: KeyboardEvent) => {\n      if (event.key === KEYS.ESCAPE) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        onCancel();\n      }\n    };\n\n    // -------------------------------------------------------------------------\n\n    eyeDropperContainer.tabIndex = -1;\n    // focus container so we can listen on keydown events\n    eyeDropperContainer.focus();\n\n    // init color preview else it would show only after the first mouse move\n    mouseMoveListener({\n      clientX: stableProps.app.lastViewportPosition.x,\n      clientY: stableProps.app.lastViewportPosition.y,\n      altKey: false,\n    });\n\n    eyeDropperContainer.addEventListener(EVENT.KEYDOWN, keyDownListener);\n    eyeDropperContainer.addEventListener(\n      EVENT.POINTER_DOWN,\n      pointerDownListener,\n    );\n    eyeDropperContainer.addEventListener(EVENT.POINTER_UP, pointerUpListener);\n    window.addEventListener(\"pointermove\", mouseMoveListener, {\n      passive: true,\n    });\n    window.addEventListener(EVENT.BLUR, onCancel);\n\n    return () => {\n      isHoldingPointerDown = false;\n      eyeDropperContainer.removeEventListener(EVENT.KEYDOWN, keyDownListener);\n      eyeDropperContainer.removeEventListener(\n        EVENT.POINTER_DOWN,\n        pointerDownListener,\n      );\n      eyeDropperContainer.removeEventListener(\n        EVENT.POINTER_UP,\n        pointerUpListener,\n      );\n      window.removeEventListener(\"pointermove\", mouseMoveListener);\n      window.removeEventListener(EVENT.BLUR, onCancel);\n    };\n  }, [\n    stableProps,\n    app.canvas,\n    eyeDropperContainer,\n    colorPickerType,\n    excalidrawContainer,\n    appState.offsetLeft,\n    appState.offsetTop,\n  ]);\n\n  const ref = useRef<HTMLDivElement>(null);\n\n  useOutsideClick(\n    ref,\n    () => {\n      onCancel();\n    },\n    (event) => {\n      if (\n        event.target.closest(\n          \".excalidraw-eye-dropper-trigger, .excalidraw-eye-dropper-backdrop\",\n        )\n      ) {\n        return true;\n      }\n      // consider all other clicks as outside\n      return false;\n    },\n  );\n\n  if (!eyeDropperContainer) {\n    return null;\n  }\n\n  return createPortal(\n    <div ref={ref} className=\"excalidraw-eye-dropper-preview\" />,\n    eyeDropperContainer,\n  );\n};\n",
    "import React from \"react\";\n\nimport type { UIAppState } from \"../types\";\n\nexport const UIAppStateContext = React.createContext<UIAppState>(null!);\nexport const useUIAppState = () => React.useContext(UIAppStateContext);\n",
    "import { useState, useLayoutEffect } from \"react\";\n\nimport { THEME } from \"@excalidraw/common\";\n\nimport { useDevice, useExcalidrawContainer } from \"../components/App\";\nimport { useUIAppState } from \"../context/ui-appState\";\n\nexport const useCreatePortalContainer = (opts?: {\n  className?: string;\n  parentSelector?: string;\n}) => {\n  const [div, setDiv] = useState<HTMLDivElement | null>(null);\n\n  const device = useDevice();\n  const { theme } = useUIAppState();\n\n  const { container: excalidrawContainer } = useExcalidrawContainer();\n\n  useLayoutEffect(() => {\n    if (div) {\n      div.className = \"\";\n      div.classList.add(\"excalidraw\", ...(opts?.className?.split(/\\s+/) || []));\n      div.classList.toggle(\"excalidraw--mobile\", device.editor.isMobile);\n      div.classList.toggle(\"theme--dark\", theme === THEME.DARK);\n    }\n  }, [div, theme, device.editor.isMobile, opts?.className]);\n\n  useLayoutEffect(() => {\n    const container = opts?.parentSelector\n      ? excalidrawContainer?.querySelector(opts.parentSelector)\n      : document.body;\n\n    if (!container) {\n      return;\n    }\n\n    const div = document.createElement(\"div\");\n\n    container.appendChild(div);\n\n    setDiv(div);\n\n    return () => {\n      container.removeChild(div);\n    };\n  }, [excalidrawContainer, opts?.parentSelector]);\n\n  return div;\n};\n",
    "import { useEffect } from \"react\";\n\nimport { EVENT } from \"@excalidraw/common\";\n\nexport function useOutsideClick<T extends HTMLElement>(\n  ref: React.RefObject<T | null>,\n  /** if performance is of concern, memoize the callback */\n  callback: (event: Event) => void,\n  /**\n   * Optional callback which is called on every click.\n   *\n   * Should return `true` if click should be considered as inside the container,\n   * and `false` if it falls outside and should call the `callback`.\n   *\n   * Returning `true` overrides the default behavior and `callback` won't be\n   * called.\n   *\n   * Returning `undefined` will fallback to the default behavior.\n   */\n  isInside?: (\n    event: Event & { target: HTMLElement },\n    /** the element of the passed ref */\n    container: T,\n  ) => boolean | undefined,\n) {\n  useEffect(() => {\n    function onOutsideClick(event: Event) {\n      const _event = event as Event & { target: T };\n\n      if (!ref.current) {\n        return;\n      }\n\n      const isInsideOverride = isInside?.(_event, ref.current);\n\n      if (isInsideOverride === true) {\n        return;\n      } else if (isInsideOverride === false) {\n        return callback(_event);\n      }\n\n      // clicked element is in the descenendant of the target container\n      if (\n        ref.current.contains(_event.target) ||\n        // target is detached from DOM (happens when the element is removed\n        // on a pointerup event fired *before* this handler's pointerup is\n        // dispatched)\n        !document.documentElement.contains(_event.target)\n      ) {\n        return;\n      }\n\n      const isClickOnRadixPortal =\n        _event.target.closest(\"[data-radix-portal]\") ||\n        // when radix popup is in \"modal\" mode, it disables pointer events on\n        // the `body` element, so the target element is going to be the `html`\n        // (note: this won't work if we selectively re-enable pointer events on\n        // specific elements as we do with navbar or excalidraw UI elements)\n        (_event.target === document.documentElement &&\n          document.body.style.pointerEvents === \"none\");\n\n      // if clicking on radix portal, assume it's a popup that\n      // should be considered as part of the UI. Obviously this is a terrible\n      // hack you can end up click on radix popups that outside the tree,\n      // but it works for most cases and the downside is minimal for now\n      if (isClickOnRadixPortal) {\n        return;\n      }\n\n      // clicking on a container that ignores outside clicks\n      if (_event.target.closest(\"[data-prevent-outside-click]\")) {\n        return;\n      }\n\n      callback(_event);\n    }\n\n    // note: don't use `click` because it often reports incorrect `event.target`\n    document.addEventListener(EVENT.POINTER_DOWN, onOutsideClick);\n    document.addEventListener(EVENT.TOUCH_START, onOutsideClick);\n\n    return () => {\n      document.removeEventListener(EVENT.POINTER_DOWN, onOutsideClick);\n      document.removeEventListener(EVENT.TOUCH_START, onOutsideClick);\n    };\n  }, [ref, callback, isInside]);\n}\n",
    "import { useRef } from \"react\";\n\nexport const useStable = <T extends Record<string, any>>(value: T) => {\n  const ref = useRef<T>(value);\n  Object.assign(ref.current, value);\n  return ref.current;\n};\n",
    "import * as Popover from \"@radix-ui/react-popover\";\nimport clsx from \"clsx\";\nimport React, { type ReactNode } from \"react\";\n\nimport { isInteractive } from \"@excalidraw/common\";\n\nimport { useDevice } from \"./App\";\nimport { Island } from \"./Island\";\n\ninterface PropertiesPopoverProps {\n  className?: string;\n  container: HTMLDivElement | null;\n  children: ReactNode;\n  style?: object;\n  onClose: () => void;\n  onKeyDown?: React.KeyboardEventHandler<HTMLDivElement>;\n  onPointerLeave?: React.PointerEventHandler<HTMLDivElement>;\n  onFocusOutside?: Popover.PopoverContentProps[\"onFocusOutside\"];\n  onPointerDownOutside?: Popover.PopoverContentProps[\"onPointerDownOutside\"];\n}\n\nexport const PropertiesPopover = React.forwardRef<\n  HTMLDivElement,\n  PropertiesPopoverProps\n>(\n  (\n    {\n      className,\n      container,\n      children,\n      style,\n      onClose,\n      onKeyDown,\n      onFocusOutside,\n      onPointerLeave,\n      onPointerDownOutside,\n    },\n    ref,\n  ) => {\n    const device = useDevice();\n\n    return (\n      <Popover.Portal container={container}>\n        <Popover.Content\n          ref={ref}\n          className={clsx(\"focus-visible-none\", className)}\n          data-prevent-outside-click\n          side={\n            device.editor.isMobile && !device.viewport.isLandscape\n              ? \"bottom\"\n              : \"right\"\n          }\n          align={\n            device.editor.isMobile && !device.viewport.isLandscape\n              ? \"center\"\n              : \"start\"\n          }\n          alignOffset={-16}\n          sideOffset={20}\n          style={{\n            zIndex: \"var(--zIndex-popup)\",\n          }}\n          onPointerLeave={onPointerLeave}\n          onKeyDown={onKeyDown}\n          onFocusOutside={onFocusOutside}\n          onPointerDownOutside={onPointerDownOutside}\n          onCloseAutoFocus={(e) => {\n            e.stopPropagation();\n            // prevents focusing the trigger\n            e.preventDefault();\n\n            // return focus to excalidraw container unless\n            // user focuses an interactive element, such as a button, or\n            // enters the text editor by clicking on canvas with the text tool\n            if (container && !isInteractive(document.activeElement)) {\n              container.focus();\n            }\n\n            onClose();\n          }}\n        >\n          <Island padding={3} style={style}>\n            {children}\n          </Island>\n          <Popover.Arrow\n            width={20}\n            height={10}\n            style={{\n              fill: \"var(--popup-bg-color)\",\n              filter: \"drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)\",\n            }}\n          />\n        </Popover.Content>\n      </Popover.Portal>\n    );\n  },\n);\n",
    "import React from \"react\";\nimport clsx from \"clsx\";\n\nimport \"./Island.scss\";\n\ntype IslandProps = {\n  children: React.ReactNode;\n  padding?: number;\n  className?: string | boolean;\n  style?: object;\n};\n\nexport const Island = React.forwardRef<HTMLDivElement, IslandProps>(\n  ({ children, padding, className, style }, ref) => (\n    <div\n      className={clsx(\"Island\", className)}\n      style={{ \"--padding\": padding, ...style }}\n      ref={ref}\n    >\n      {children}\n    </div>\n  ),\n);\n",
    "import clsx from \"clsx\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\nimport { KEYS, getShortcutKey } from \"@excalidraw/common\";\n\nimport { useAtom } from \"../../editor-jotai\";\nimport { t } from \"../../i18n\";\nimport { useDevice } from \"../App\";\nimport { activeEyeDropperAtom } from \"../EyeDropper\";\nimport { eyeDropperIcon } from \"../icons\";\n\nimport { getColor } from \"./ColorPicker\";\nimport { activeColorPickerSectionAtom } from \"./colorPickerUtils\";\n\nimport type { ColorPickerType } from \"./colorPickerUtils\";\n\ninterface ColorInputProps {\n  color: string;\n  onChange: (color: string) => void;\n  label: string;\n  colorPickerType: ColorPickerType;\n  placeholder?: string;\n}\n\nexport const ColorInput = ({\n  color,\n  onChange,\n  label,\n  colorPickerType,\n  placeholder,\n}: ColorInputProps) => {\n  const device = useDevice();\n  const [innerValue, setInnerValue] = useState(color);\n  const [activeSection, setActiveColorPickerSection] = useAtom(\n    activeColorPickerSectionAtom,\n  );\n\n  useEffect(() => {\n    setInnerValue(color);\n  }, [color]);\n\n  const changeColor = useCallback(\n    (inputValue: string) => {\n      const value = inputValue.toLowerCase();\n      const color = getColor(value);\n\n      if (color) {\n        onChange(color);\n      }\n      setInnerValue(value);\n    },\n    [onChange],\n  );\n\n  const inputRef = useRef<HTMLInputElement>(null);\n  const eyeDropperTriggerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, [activeSection]);\n\n  const [eyeDropperState, setEyeDropperState] = useAtom(activeEyeDropperAtom);\n\n  useEffect(() => {\n    return () => {\n      setEyeDropperState(null);\n    };\n  }, [setEyeDropperState]);\n\n  return (\n    <div className=\"color-picker__input-label\">\n      <div className=\"color-picker__input-hash\">#</div>\n      <input\n        ref={activeSection === \"hex\" ? inputRef : undefined}\n        style={{ border: 0, padding: 0 }}\n        spellCheck={false}\n        className=\"color-picker-input\"\n        aria-label={label}\n        onChange={(event) => {\n          changeColor(event.target.value);\n        }}\n        value={(innerValue || \"\").replace(/^#/, \"\")}\n        onBlur={() => {\n          setInnerValue(color);\n        }}\n        tabIndex={-1}\n        onFocus={() => setActiveColorPickerSection(\"hex\")}\n        onKeyDown={(event) => {\n          if (event.key === KEYS.TAB) {\n            return;\n          } else if (event.key === KEYS.ESCAPE) {\n            eyeDropperTriggerRef.current?.focus();\n          }\n          event.stopPropagation();\n        }}\n        placeholder={placeholder}\n      />\n      {/* TODO reenable on mobile with a better UX */}\n      {!device.editor.isMobile && (\n        <>\n          <div\n            style={{\n              width: \"1px\",\n              height: \"1.25rem\",\n              backgroundColor: \"var(--default-border-color)\",\n            }}\n          />\n          <div\n            ref={eyeDropperTriggerRef}\n            className={clsx(\"excalidraw-eye-dropper-trigger\", {\n              selected: eyeDropperState,\n            })}\n            onClick={() =>\n              setEyeDropperState((s) =>\n                s\n                  ? null\n                  : {\n                      keepOpenOnAlt: false,\n                      onSelect: (color) => onChange(color),\n                      colorPickerType,\n                    },\n              )\n            }\n            title={`${t(\n              \"labels.eyeDropper\",\n            )} — ${KEYS.I.toLocaleUpperCase()} or ${getShortcutKey(\"Alt\")} `}\n          >\n            {eyeDropperIcon}\n          </div>\n        </>\n      )}\n    </div>\n  );\n};\n",
    "import { MAX_CUSTOM_COLORS_USED_IN_CANVAS } from \"@excalidraw/common\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { ColorPickerColor, ColorPaletteCustom } from \"@excalidraw/common\";\n\nimport { atom } from \"../../editor-jotai\";\n\nexport const getColorNameAndShadeFromColor = ({\n  palette,\n  color,\n}: {\n  palette: ColorPaletteCustom;\n  color: string | null;\n}): {\n  colorName: ColorPickerColor;\n  shade: number | null;\n} | null => {\n  if (!color) {\n    return null;\n  }\n  for (const [colorName, colorVal] of Object.entries(palette)) {\n    if (Array.isArray(colorVal)) {\n      const shade = colorVal.indexOf(color);\n      if (shade > -1) {\n        return { colorName: colorName as ColorPickerColor, shade };\n      }\n    } else if (colorVal === color) {\n      return { colorName: colorName as ColorPickerColor, shade: null };\n    }\n  }\n  return null;\n};\n\nexport const colorPickerHotkeyBindings = [\n  [\"q\", \"w\", \"e\", \"r\", \"t\"],\n  [\"a\", \"s\", \"d\", \"f\", \"g\"],\n  [\"z\", \"x\", \"c\", \"v\", \"b\"],\n].flat();\n\nexport const isCustomColor = ({\n  color,\n  palette,\n}: {\n  color: string;\n  palette: ColorPaletteCustom;\n}) => {\n  const paletteValues = Object.values(palette).flat();\n  return !paletteValues.includes(color);\n};\n\nexport const getMostUsedCustomColors = (\n  elements: readonly ExcalidrawElement[],\n  type: \"elementBackground\" | \"elementStroke\",\n  palette: ColorPaletteCustom,\n) => {\n  const elementColorTypeMap = {\n    elementBackground: \"backgroundColor\",\n    elementStroke: \"strokeColor\",\n  };\n\n  const colors = elements.filter((element) => {\n    if (element.isDeleted) {\n      return false;\n    }\n\n    const color =\n      element[elementColorTypeMap[type] as \"backgroundColor\" | \"strokeColor\"];\n\n    return isCustomColor({ color, palette });\n  });\n\n  const colorCountMap = new Map<string, number>();\n  colors.forEach((element) => {\n    const color =\n      element[elementColorTypeMap[type] as \"backgroundColor\" | \"strokeColor\"];\n    if (colorCountMap.has(color)) {\n      colorCountMap.set(color, colorCountMap.get(color)! + 1);\n    } else {\n      colorCountMap.set(color, 1);\n    }\n  });\n\n  return [...colorCountMap.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .map((c) => c[0])\n    .slice(0, MAX_CUSTOM_COLORS_USED_IN_CANVAS);\n};\n\nexport type ActiveColorPickerSectionAtomType =\n  | \"custom\"\n  | \"baseColors\"\n  | \"shades\"\n  | \"hex\"\n  | null;\nexport const activeColorPickerSectionAtom =\n  atom<ActiveColorPickerSectionAtomType>(null);\n\nconst calculateContrast = (r: number, g: number, b: number): number => {\n  const yiq = (r * 299 + g * 587 + b * 114) / 1000;\n  return yiq;\n};\n\n// YIQ algo, inspiration from https://stackoverflow.com/a/11868398\nexport const isColorDark = (color: string, threshold = 160): boolean => {\n  // no color (\"\") -> assume it default to black\n  if (!color) {\n    return true;\n  }\n\n  if (color === \"transparent\") {\n    return false;\n  }\n\n  // a string color (white etc) or any other format -> convert to rgb by way\n  // of creating a DOM node and retrieving the computeStyle\n  if (!color.startsWith(\"#\")) {\n    const node = document.createElement(\"div\");\n    node.style.color = color;\n\n    if (node.style.color) {\n      // making invisible so document doesn't reflow (hopefully).\n      // display=none works too, but supposedly not in all browsers\n      node.style.position = \"absolute\";\n      node.style.visibility = \"hidden\";\n      node.style.width = \"0\";\n      node.style.height = \"0\";\n\n      // needs to be in DOM else browser won't compute the style\n      document.body.appendChild(node);\n      const computedColor = getComputedStyle(node).color;\n      document.body.removeChild(node);\n      // computed style is in rgb() format\n      const rgb = computedColor\n        .replace(/^(rgb|rgba)\\(/, \"\")\n        .replace(/\\)$/, \"\")\n        .replace(/\\s/g, \"\")\n        .split(\",\");\n      const r = parseInt(rgb[0]);\n      const g = parseInt(rgb[1]);\n      const b = parseInt(rgb[2]);\n\n      return calculateContrast(r, g, b) < threshold;\n    }\n    // invalid color -> assume it default to black\n    return true;\n  }\n\n  const r = parseInt(color.slice(1, 3), 16);\n  const g = parseInt(color.slice(3, 5), 16);\n  const b = parseInt(color.slice(5, 7), 16);\n\n  return calculateContrast(r, g, b) < threshold;\n};\n\nexport type ColorPickerType =\n  | \"canvasBackground\"\n  | \"elementBackground\"\n  | \"elementStroke\";\n",
    "import React, { useEffect, useImperativeHandle, useState } from \"react\";\n\nimport { EVENT } from \"@excalidraw/common\";\n\nimport {\n  DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX,\n  DEFAULT_ELEMENT_STROKE_COLOR_INDEX,\n  KEYS,\n} from \"@excalidraw/common\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { ColorPaletteCustom } from \"@excalidraw/common\";\n\nimport { useAtom } from \"../../editor-jotai\";\nimport { t } from \"../../i18n\";\n\nimport { CustomColorList } from \"./CustomColorList\";\nimport PickerColorList from \"./PickerColorList\";\nimport PickerHeading from \"./PickerHeading\";\nimport { ShadeList } from \"./ShadeList\";\nimport {\n  activeColorPickerSectionAtom,\n  getColorNameAndShadeFromColor,\n  getMostUsedCustomColors,\n  isCustomColor,\n} from \"./colorPickerUtils\";\nimport { colorPickerKeyNavHandler } from \"./keyboardNavHandlers\";\n\nimport type { ColorPickerType } from \"./colorPickerUtils\";\n\ninterface PickerProps {\n  color: string | null;\n  onChange: (color: string) => void;\n  type: ColorPickerType;\n  elements: readonly ExcalidrawElement[];\n  palette: ColorPaletteCustom;\n  updateData: (formData?: any) => void;\n  children?: React.ReactNode;\n  onEyeDropperToggle: (force?: boolean) => void;\n  onEscape: (event: React.KeyboardEvent | KeyboardEvent) => void;\n}\n\nexport const Picker = React.forwardRef(\n  (\n    {\n      color,\n      onChange,\n      type,\n      elements,\n      palette,\n      updateData,\n      children,\n      onEyeDropperToggle,\n      onEscape,\n    }: PickerProps,\n    ref,\n  ) => {\n    const [customColors] = React.useState(() => {\n      if (type === \"canvasBackground\") {\n        return [];\n      }\n      return getMostUsedCustomColors(elements, type, palette);\n    });\n\n    const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(\n      activeColorPickerSectionAtom,\n    );\n\n    const colorObj = getColorNameAndShadeFromColor({\n      color,\n      palette,\n    });\n\n    useEffect(() => {\n      if (!activeColorPickerSection) {\n        const isCustom = !!color && isCustomColor({ color, palette });\n        const isCustomButNotInList = isCustom && !customColors.includes(color);\n\n        setActiveColorPickerSection(\n          isCustomButNotInList\n            ? null\n            : isCustom\n            ? \"custom\"\n            : colorObj?.shade != null\n            ? \"shades\"\n            : \"baseColors\",\n        );\n      }\n    }, [\n      activeColorPickerSection,\n      color,\n      palette,\n      setActiveColorPickerSection,\n      colorObj,\n      customColors,\n    ]);\n\n    const [activeShade, setActiveShade] = useState(\n      colorObj?.shade ??\n        (type === \"elementBackground\"\n          ? DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX\n          : DEFAULT_ELEMENT_STROKE_COLOR_INDEX),\n    );\n\n    useEffect(() => {\n      if (colorObj?.shade != null) {\n        setActiveShade(colorObj.shade);\n      }\n\n      const keyup = (event: KeyboardEvent) => {\n        if (event.key === KEYS.ALT) {\n          onEyeDropperToggle(false);\n        }\n      };\n      document.addEventListener(EVENT.KEYUP, keyup, { capture: true });\n      return () => {\n        document.removeEventListener(EVENT.KEYUP, keyup, { capture: true });\n      };\n    }, [colorObj, onEyeDropperToggle]);\n    const pickerRef = React.useRef<HTMLDivElement>(null);\n\n    useImperativeHandle(ref, () => pickerRef.current!);\n\n    useEffect(() => {\n      pickerRef?.current?.focus();\n    }, []);\n\n    return (\n      <div role=\"dialog\" aria-modal=\"true\" aria-label={t(\"labels.colorPicker\")}>\n        <div\n          ref={pickerRef}\n          onKeyDown={(event) => {\n            const handled = colorPickerKeyNavHandler({\n              event,\n              activeColorPickerSection,\n              palette,\n              color,\n              onChange,\n              onEyeDropperToggle,\n              customColors,\n              setActiveColorPickerSection,\n              updateData,\n              activeShade,\n              onEscape,\n            });\n\n            if (handled) {\n              event.preventDefault();\n              event.stopPropagation();\n            }\n          }}\n          className=\"color-picker-content properties-content\"\n          // to allow focusing by clicking but not by tabbing\n          tabIndex={-1}\n        >\n          {!!customColors.length && (\n            <div>\n              <PickerHeading>\n                {t(\"colorPicker.mostUsedCustomColors\")}\n              </PickerHeading>\n              <CustomColorList\n                colors={customColors}\n                color={color}\n                label={t(\"colorPicker.mostUsedCustomColors\")}\n                onChange={onChange}\n              />\n            </div>\n          )}\n\n          <div>\n            <PickerHeading>{t(\"colorPicker.colors\")}</PickerHeading>\n            <PickerColorList\n              color={color}\n              palette={palette}\n              onChange={onChange}\n              activeShade={activeShade}\n            />\n          </div>\n\n          <div>\n            <PickerHeading>{t(\"colorPicker.shades\")}</PickerHeading>\n            <ShadeList color={color} onChange={onChange} palette={palette} />\n          </div>\n          {children}\n        </div>\n      </div>\n    );\n  },\n);\n",
    "import clsx from \"clsx\";\nimport { useEffect, useRef } from \"react\";\n\nimport { useAtom } from \"../../editor-jotai\";\n\nimport HotkeyLabel from \"./HotkeyLabel\";\nimport { activeColorPickerSectionAtom } from \"./colorPickerUtils\";\n\ninterface CustomColorListProps {\n  colors: string[];\n  color: string | null;\n  onChange: (color: string) => void;\n  label: string;\n}\n\nexport const CustomColorList = ({\n  colors,\n  color,\n  onChange,\n  label,\n}: CustomColorListProps) => {\n  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(\n    activeColorPickerSectionAtom,\n  );\n\n  const btnRef = useRef<HTMLButtonElement>(null);\n\n  useEffect(() => {\n    if (btnRef.current) {\n      btnRef.current.focus();\n    }\n  }, [color, activeColorPickerSection]);\n\n  return (\n    <div className=\"color-picker-content--default\">\n      {colors.map((c, i) => {\n        return (\n          <button\n            ref={color === c ? btnRef : undefined}\n            tabIndex={-1}\n            type=\"button\"\n            className={clsx(\n              \"color-picker__button color-picker__button--large has-outline\",\n              {\n                active: color === c,\n                \"is-transparent\": c === \"transparent\" || !c,\n              },\n            )}\n            onClick={() => {\n              onChange(c);\n              setActiveColorPickerSection(\"custom\");\n            }}\n            title={c}\n            aria-label={label}\n            style={{ \"--swatch-color\": c }}\n            key={i}\n          >\n            <div className=\"color-picker__button-outline\" />\n            <HotkeyLabel color={c} keyLabel={i + 1} />\n          </button>\n        );\n      })}\n    </div>\n  );\n};\n",
    "import React from \"react\";\n\nimport { isColorDark } from \"./colorPickerUtils\";\n\ninterface HotkeyLabelProps {\n  color: string;\n  keyLabel: string | number;\n  isShade?: boolean;\n}\nconst HotkeyLabel = ({\n  color,\n  keyLabel,\n  isShade = false,\n}: HotkeyLabelProps) => {\n  return (\n    <div\n      className=\"color-picker__button__hotkey-label\"\n      style={{\n        color: isColorDark(color) ? \"#fff\" : \"#000\",\n      }}\n    >\n      {isShade && \"⇧\"}\n      {keyLabel}\n    </div>\n  );\n};\n\nexport default HotkeyLabel;\n",
    "import clsx from \"clsx\";\nimport { useEffect, useRef } from \"react\";\n\nimport type { ColorPaletteCustom } from \"@excalidraw/common\";\n\nimport { useAtom } from \"../../editor-jotai\";\nimport { t } from \"../../i18n\";\n\nimport HotkeyLabel from \"./HotkeyLabel\";\nimport {\n  activeColorPickerSectionAtom,\n  colorPickerHotkeyBindings,\n  getColorNameAndShadeFromColor,\n} from \"./colorPickerUtils\";\n\nimport type { TranslationKeys } from \"../../i18n\";\n\ninterface PickerColorListProps {\n  palette: ColorPaletteCustom;\n  color: string | null;\n  onChange: (color: string) => void;\n  activeShade: number;\n}\n\nconst PickerColorList = ({\n  palette,\n  color,\n  onChange,\n  activeShade,\n}: PickerColorListProps) => {\n  const colorObj = getColorNameAndShadeFromColor({\n    color,\n    palette,\n  });\n  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(\n    activeColorPickerSectionAtom,\n  );\n\n  const btnRef = useRef<HTMLButtonElement>(null);\n\n  useEffect(() => {\n    if (btnRef.current && activeColorPickerSection === \"baseColors\") {\n      btnRef.current.focus();\n    }\n  }, [colorObj?.colorName, activeColorPickerSection]);\n\n  return (\n    <div className=\"color-picker-content--default\">\n      {Object.entries(palette).map(([key, value], index) => {\n        const color =\n          (Array.isArray(value) ? value[activeShade] : value) || \"transparent\";\n\n        const keybinding = colorPickerHotkeyBindings[index];\n        const label = t(\n          `colors.${key.replace(/\\d+/, \"\")}` as unknown as TranslationKeys,\n          null,\n          \"\",\n        );\n\n        return (\n          <button\n            ref={colorObj?.colorName === key ? btnRef : undefined}\n            tabIndex={-1}\n            type=\"button\"\n            className={clsx(\n              \"color-picker__button color-picker__button--large has-outline\",\n              {\n                active: colorObj?.colorName === key,\n                \"is-transparent\": color === \"transparent\" || !color,\n              },\n            )}\n            onClick={() => {\n              onChange(color);\n              setActiveColorPickerSection(\"baseColors\");\n            }}\n            title={`${label}${\n              color.startsWith(\"#\") ? ` ${color}` : \"\"\n            } — ${keybinding}`}\n            aria-label={`${label} — ${keybinding}`}\n            style={color ? { \"--swatch-color\": color } : undefined}\n            data-testid={`color-${key}`}\n            key={key}\n          >\n            <div className=\"color-picker__button-outline\" />\n            <HotkeyLabel color={color} keyLabel={keybinding} />\n          </button>\n        );\n      })}\n    </div>\n  );\n};\n\nexport default PickerColorList;\n",
    "import type { ReactNode } from \"react\";\n\nconst PickerHeading = ({ children }: { children: ReactNode }) => (\n  <div className=\"color-picker__heading\">{children}</div>\n);\n\nexport default PickerHeading;\n",
    "import clsx from \"clsx\";\nimport { useEffect, useRef } from \"react\";\n\nimport type { ColorPaletteCustom } from \"@excalidraw/common\";\n\nimport { useAtom } from \"../../editor-jotai\";\nimport { t } from \"../../i18n\";\n\nimport HotkeyLabel from \"./HotkeyLabel\";\nimport {\n  activeColorPickerSectionAtom,\n  getColorNameAndShadeFromColor,\n} from \"./colorPickerUtils\";\n\ninterface ShadeListProps {\n  color: string | null;\n  onChange: (color: string) => void;\n  palette: ColorPaletteCustom;\n}\n\nexport const ShadeList = ({ color, onChange, palette }: ShadeListProps) => {\n  const colorObj = getColorNameAndShadeFromColor({\n    color: color || \"transparent\",\n    palette,\n  });\n\n  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(\n    activeColorPickerSectionAtom,\n  );\n\n  const btnRef = useRef<HTMLButtonElement>(null);\n\n  useEffect(() => {\n    if (btnRef.current && activeColorPickerSection === \"shades\") {\n      btnRef.current.focus();\n    }\n  }, [colorObj, activeColorPickerSection]);\n\n  if (colorObj) {\n    const { colorName, shade } = colorObj;\n\n    const shades = palette[colorName];\n\n    if (Array.isArray(shades)) {\n      return (\n        <div className=\"color-picker-content--default shades\">\n          {shades.map((color, i) => (\n            <button\n              ref={\n                i === shade && activeColorPickerSection === \"shades\"\n                  ? btnRef\n                  : undefined\n              }\n              tabIndex={-1}\n              key={i}\n              type=\"button\"\n              className={clsx(\n                \"color-picker__button color-picker__button--large has-outline\",\n                { active: i === shade },\n              )}\n              aria-label=\"Shade\"\n              title={`${colorName} - ${i + 1}`}\n              style={color ? { \"--swatch-color\": color } : undefined}\n              onClick={() => {\n                onChange(color);\n                setActiveColorPickerSection(\"shades\");\n              }}\n            >\n              <div className=\"color-picker__button-outline\" />\n              <HotkeyLabel color={color} keyLabel={i + 1} isShade />\n            </button>\n          ))}\n        </div>\n      );\n    }\n  }\n\n  return (\n    <div\n      className=\"color-picker-content--default\"\n      style={{ position: \"relative\" }}\n      tabIndex={-1}\n    >\n      <button\n        type=\"button\"\n        tabIndex={-1}\n        className=\"color-picker__button color-picker__button--large color-picker__button--no-focus-visible\"\n      />\n      <div\n        tabIndex={-1}\n        style={{\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0,\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          textAlign: \"center\",\n          fontSize: \"0.75rem\",\n        }}\n      >\n        {t(\"colorPicker.noShades\")}\n      </div>\n    </div>\n  );\n};\n",
    "import { COLORS_PER_ROW, COLOR_PALETTE, KEYS } from \"@excalidraw/common\";\n\nimport type {\n  ColorPickerColor,\n  ColorPalette,\n  ColorPaletteCustom,\n} from \"@excalidraw/common\";\n\nimport type { ValueOf } from \"@excalidraw/common/utility-types\";\n\nimport {\n  colorPickerHotkeyBindings,\n  getColorNameAndShadeFromColor,\n} from \"./colorPickerUtils\";\n\nimport type { ActiveColorPickerSectionAtomType } from \"./colorPickerUtils\";\n\nconst arrowHandler = (\n  eventKey: string,\n  currentIndex: number | null,\n  length: number,\n) => {\n  const rows = Math.ceil(length / COLORS_PER_ROW);\n\n  currentIndex = currentIndex ?? -1;\n\n  switch (eventKey) {\n    case \"ArrowLeft\": {\n      const prevIndex = currentIndex - 1;\n      return prevIndex < 0 ? length - 1 : prevIndex;\n    }\n    case \"ArrowRight\": {\n      return (currentIndex + 1) % length;\n    }\n    case \"ArrowDown\": {\n      const nextIndex = currentIndex + COLORS_PER_ROW;\n      return nextIndex >= length ? currentIndex % COLORS_PER_ROW : nextIndex;\n    }\n    case \"ArrowUp\": {\n      const prevIndex = currentIndex - COLORS_PER_ROW;\n      const newIndex =\n        prevIndex < 0 ? COLORS_PER_ROW * rows + prevIndex : prevIndex;\n      return newIndex >= length ? undefined : newIndex;\n    }\n  }\n};\n\ninterface HotkeyHandlerProps {\n  e: React.KeyboardEvent;\n  colorObj: { colorName: ColorPickerColor; shade: number | null } | null;\n  onChange: (color: string) => void;\n  palette: ColorPaletteCustom;\n  customColors: string[];\n  setActiveColorPickerSection: (\n    update: React.SetStateAction<ActiveColorPickerSectionAtomType>,\n  ) => void;\n  activeShade: number;\n}\n\n/**\n * @returns true if the event was handled\n */\nconst hotkeyHandler = ({\n  e,\n  colorObj,\n  onChange,\n  palette,\n  customColors,\n  setActiveColorPickerSection,\n  activeShade,\n}: HotkeyHandlerProps): boolean => {\n  if (colorObj?.shade != null) {\n    // shift + numpad is extremely messed up on windows apparently\n    if (\n      [\"Digit1\", \"Digit2\", \"Digit3\", \"Digit4\", \"Digit5\"].includes(e.code) &&\n      e.shiftKey\n    ) {\n      const newShade = Number(e.code.slice(-1)) - 1;\n      onChange(palette[colorObj.colorName][newShade]);\n      setActiveColorPickerSection(\"shades\");\n      return true;\n    }\n  }\n\n  if ([\"1\", \"2\", \"3\", \"4\", \"5\"].includes(e.key)) {\n    const c = customColors[Number(e.key) - 1];\n    if (c) {\n      onChange(customColors[Number(e.key) - 1]);\n      setActiveColorPickerSection(\"custom\");\n      return true;\n    }\n  }\n\n  if (colorPickerHotkeyBindings.includes(e.key)) {\n    const index = colorPickerHotkeyBindings.indexOf(e.key);\n    const paletteKey = Object.keys(palette)[index] as keyof ColorPalette;\n    const paletteValue = palette[paletteKey];\n    const r = Array.isArray(paletteValue)\n      ? paletteValue[activeShade]\n      : paletteValue;\n    onChange(r);\n    setActiveColorPickerSection(\"baseColors\");\n    return true;\n  }\n  return false;\n};\n\ninterface ColorPickerKeyNavHandlerProps {\n  event: React.KeyboardEvent;\n  activeColorPickerSection: ActiveColorPickerSectionAtomType;\n  palette: ColorPaletteCustom;\n  color: string | null;\n  onChange: (color: string) => void;\n  customColors: string[];\n  setActiveColorPickerSection: (\n    update: React.SetStateAction<ActiveColorPickerSectionAtomType>,\n  ) => void;\n  updateData: (formData?: any) => void;\n  activeShade: number;\n  onEyeDropperToggle: (force?: boolean) => void;\n  onEscape: (event: React.KeyboardEvent | KeyboardEvent) => void;\n}\n\n/**\n * @returns true if the event was handled\n */\nexport const colorPickerKeyNavHandler = ({\n  event,\n  activeColorPickerSection,\n  palette,\n  color,\n  onChange,\n  customColors,\n  setActiveColorPickerSection,\n  updateData,\n  activeShade,\n  onEyeDropperToggle,\n  onEscape,\n}: ColorPickerKeyNavHandlerProps): boolean => {\n  if (event[KEYS.CTRL_OR_CMD]) {\n    return false;\n  }\n\n  if (event.key === KEYS.ESCAPE) {\n    onEscape(event);\n    return true;\n  }\n\n  // checkt using `key` to ignore combos with Alt modifier\n  if (event.key === KEYS.ALT) {\n    onEyeDropperToggle(true);\n    return true;\n  }\n\n  if (event.key === KEYS.I) {\n    onEyeDropperToggle();\n    return true;\n  }\n\n  const colorObj = getColorNameAndShadeFromColor({ color, palette });\n\n  if (event.key === KEYS.TAB) {\n    const sectionsMap: Record<\n      NonNullable<ActiveColorPickerSectionAtomType>,\n      boolean\n    > = {\n      custom: !!customColors.length,\n      baseColors: true,\n      shades: colorObj?.shade != null,\n      hex: true,\n    };\n\n    const sections = Object.entries(sectionsMap).reduce((acc, [key, value]) => {\n      if (value) {\n        acc.push(key as ActiveColorPickerSectionAtomType);\n      }\n      return acc;\n    }, [] as ActiveColorPickerSectionAtomType[]);\n\n    const activeSectionIndex = sections.indexOf(activeColorPickerSection);\n    const indexOffset = event.shiftKey ? -1 : 1;\n    const nextSectionIndex =\n      activeSectionIndex + indexOffset > sections.length - 1\n        ? 0\n        : activeSectionIndex + indexOffset < 0\n        ? sections.length - 1\n        : activeSectionIndex + indexOffset;\n\n    const nextSection = sections[nextSectionIndex];\n\n    if (nextSection) {\n      setActiveColorPickerSection(nextSection);\n    }\n\n    if (nextSection === \"custom\") {\n      onChange(customColors[0]);\n    } else if (nextSection === \"baseColors\") {\n      const baseColorName = (\n        Object.entries(palette) as [string, ValueOf<ColorPalette>][]\n      ).find(([name, shades]) => {\n        if (Array.isArray(shades)) {\n          return shades.includes(color);\n        } else if (shades === color) {\n          return name;\n        }\n        return null;\n      });\n\n      if (!baseColorName) {\n        onChange(COLOR_PALETTE.black);\n      }\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    return true;\n  }\n\n  if (\n    hotkeyHandler({\n      e: event,\n      colorObj,\n      onChange,\n      palette,\n      customColors,\n      setActiveColorPickerSection,\n      activeShade,\n    })\n  ) {\n    return true;\n  }\n\n  if (activeColorPickerSection === \"shades\") {\n    if (colorObj) {\n      const { shade } = colorObj;\n      const newShade = arrowHandler(event.key, shade, COLORS_PER_ROW);\n\n      if (newShade !== undefined) {\n        onChange(palette[colorObj.colorName][newShade]);\n        return true;\n      }\n    }\n  }\n\n  if (activeColorPickerSection === \"baseColors\") {\n    if (colorObj) {\n      const { colorName } = colorObj;\n      const colorNames = Object.keys(palette) as (keyof ColorPalette)[];\n      const indexOfColorName = colorNames.indexOf(colorName);\n\n      const newColorIndex = arrowHandler(\n        event.key,\n        indexOfColorName,\n        colorNames.length,\n      );\n\n      if (newColorIndex !== undefined) {\n        const newColorName = colorNames[newColorIndex];\n        const newColorNameValue = palette[newColorName];\n\n        onChange(\n          Array.isArray(newColorNameValue)\n            ? newColorNameValue[activeShade]\n            : newColorNameValue,\n        );\n        return true;\n      }\n    }\n  }\n\n  if (activeColorPickerSection === \"custom\") {\n    const indexOfColor = color != null ? customColors.indexOf(color) : 0;\n\n    const newColorIndex = arrowHandler(\n      event.key,\n      indexOfColor,\n      customColors.length,\n    );\n\n    if (newColorIndex !== undefined) {\n      const newColor = customColors[newColorIndex];\n      onChange(newColor);\n      return true;\n    }\n  }\n\n  return false;\n};\n",
    "import clsx from \"clsx\";\n\nimport {\n  COLOR_OUTLINE_CONTRAST_THRESHOLD,\n  DEFAULT_CANVAS_BACKGROUND_PICKS,\n  DEFAULT_ELEMENT_BACKGROUND_PICKS,\n  DEFAULT_ELEMENT_STROKE_PICKS,\n} from \"@excalidraw/common\";\n\nimport { isColorDark } from \"./colorPickerUtils\";\n\nimport type { ColorPickerType } from \"./colorPickerUtils\";\n\ninterface TopPicksProps {\n  onChange: (color: string) => void;\n  type: ColorPickerType;\n  activeColor: string | null;\n  topPicks?: readonly string[];\n}\n\nexport const TopPicks = ({\n  onChange,\n  type,\n  activeColor,\n  topPicks,\n}: TopPicksProps) => {\n  let colors;\n  if (type === \"elementStroke\") {\n    colors = DEFAULT_ELEMENT_STROKE_PICKS;\n  }\n\n  if (type === \"elementBackground\") {\n    colors = DEFAULT_ELEMENT_BACKGROUND_PICKS;\n  }\n\n  if (type === \"canvasBackground\") {\n    colors = DEFAULT_CANVAS_BACKGROUND_PICKS;\n  }\n\n  // this one can overwrite defaults\n  if (topPicks) {\n    colors = topPicks;\n  }\n\n  if (!colors) {\n    console.error(\"Invalid type for TopPicks\");\n    return null;\n  }\n\n  return (\n    <div className=\"color-picker__top-picks\">\n      {colors.map((color: string) => (\n        <button\n          className={clsx(\"color-picker__button\", {\n            active: color === activeColor,\n            \"is-transparent\": color === \"transparent\" || !color,\n            \"has-outline\": !isColorDark(\n              color,\n              COLOR_OUTLINE_CONTRAST_THRESHOLD,\n            ),\n          })}\n          style={{ \"--swatch-color\": color }}\n          key={color}\n          type=\"button\"\n          title={color}\n          onClick={() => onChange(color)}\n          data-testid={`color-top-pick-${color}`}\n        >\n          <div className=\"color-picker__button-outline\" />\n        </button>\n      ))}\n    </div>\n  );\n};\n",
    "import * as Popover from \"@radix-ui/react-popover\";\nimport React, { useCallback, useMemo } from \"react\";\n\nimport { FONT_FAMILY } from \"@excalidraw/common\";\n\nimport type { FontFamilyValues } from \"@excalidraw/element/types\";\n\nimport { t } from \"../../i18n\";\nimport { RadioSelection } from \"../RadioSelection\";\nimport { ButtonSeparator } from \"../ButtonSeparator\";\nimport {\n  FontFamilyCodeIcon,\n  FontFamilyNormalIcon,\n  FreedrawIcon,\n} from \"../icons\";\n\nimport { FontPickerList } from \"./FontPickerList\";\nimport { FontPickerTrigger } from \"./FontPickerTrigger\";\n\nimport \"./FontPicker.scss\";\n\nexport const DEFAULT_FONTS = [\n  {\n    value: FONT_FAMILY.Excalifont,\n    icon: FreedrawIcon,\n    text: t(\"labels.handDrawn\"),\n    testId: \"font-family-hand-drawn\",\n  },\n  {\n    value: FONT_FAMILY.Nunito,\n    icon: FontFamilyNormalIcon,\n    text: t(\"labels.normal\"),\n    testId: \"font-family-normal\",\n  },\n  {\n    value: FONT_FAMILY[\"Comic Shanns\"],\n    icon: FontFamilyCodeIcon,\n    text: t(\"labels.code\"),\n    testId: \"font-family-code\",\n  },\n];\n\nconst defaultFontFamilies = new Set(DEFAULT_FONTS.map((x) => x.value));\n\nexport const isDefaultFont = (fontFamily: number | null) => {\n  if (!fontFamily) {\n    return false;\n  }\n\n  return defaultFontFamilies.has(fontFamily);\n};\n\ninterface FontPickerProps {\n  isOpened: boolean;\n  selectedFontFamily: FontFamilyValues | null;\n  hoveredFontFamily: FontFamilyValues | null;\n  onSelect: (fontFamily: FontFamilyValues) => void;\n  onHover: (fontFamily: FontFamilyValues) => void;\n  onLeave: () => void;\n  onPopupChange: (open: boolean) => void;\n}\n\nexport const FontPicker = React.memo(\n  ({\n    isOpened,\n    selectedFontFamily,\n    hoveredFontFamily,\n    onSelect,\n    onHover,\n    onLeave,\n    onPopupChange,\n  }: FontPickerProps) => {\n    const defaultFonts = useMemo(() => DEFAULT_FONTS, []);\n    const onSelectCallback = useCallback(\n      (value: number | false) => {\n        if (value) {\n          onSelect(value);\n        }\n      },\n      [onSelect],\n    );\n\n    return (\n      <div role=\"dialog\" aria-modal=\"true\" className=\"FontPicker__container\">\n        <div className=\"buttonList\">\n          <RadioSelection<FontFamilyValues | false>\n            type=\"button\"\n            options={defaultFonts}\n            value={selectedFontFamily}\n            onClick={onSelectCallback}\n          />\n        </div>\n        <ButtonSeparator />\n        <Popover.Root open={isOpened} onOpenChange={onPopupChange}>\n          <FontPickerTrigger selectedFontFamily={selectedFontFamily} />\n          {isOpened && (\n            <FontPickerList\n              selectedFontFamily={selectedFontFamily}\n              hoveredFontFamily={hoveredFontFamily}\n              onSelect={onSelectCallback}\n              onHover={onHover}\n              onLeave={onLeave}\n              onOpen={() => onPopupChange(true)}\n              onClose={() => onPopupChange(false)}\n            />\n          )}\n        </Popover.Root>\n      </div>\n    );\n  },\n  (prev, next) =>\n    prev.isOpened === next.isOpened &&\n    prev.selectedFontFamily === next.selectedFontFamily &&\n    prev.hoveredFontFamily === next.hoveredFontFamily,\n);\n",
    "import React, {\n  useMemo,\n  useState,\n  useRef,\n  useEffect,\n  useCallback,\n  type KeyboardEventHandler,\n} from \"react\";\n\nimport { type FontFamilyValues } from \"@excalidraw/element/types\";\n\nimport {\n  arrayToList,\n  debounce,\n  FONT_FAMILY,\n  getFontFamilyString,\n} from \"@excalidraw/common\";\n\nimport type { ValueOf } from \"@excalidraw/common/utility-types\";\n\nimport { Fonts } from \"../../fonts\";\nimport { t } from \"../../i18n\";\nimport { useApp, useAppProps, useExcalidrawContainer } from \"../App\";\nimport { PropertiesPopover } from \"../PropertiesPopover\";\nimport { QuickSearch } from \"../QuickSearch\";\nimport { ScrollableList } from \"../ScrollableList\";\nimport DropdownMenuGroup from \"../dropdownMenu/DropdownMenuGroup\";\nimport DropdownMenuItem, {\n  DropDownMenuItemBadgeType,\n  DropDownMenuItemBadge,\n} from \"../dropdownMenu/DropdownMenuItem\";\nimport {\n  FontFamilyCodeIcon,\n  FontFamilyHeadingIcon,\n  FontFamilyNormalIcon,\n  FreedrawIcon,\n} from \"../icons\";\n\nimport { fontPickerKeyHandler } from \"./keyboardNavHandlers\";\n\nimport type { JSX } from \"react\";\n\nexport interface FontDescriptor {\n  value: number;\n  icon: JSX.Element;\n  text: string;\n  deprecated?: true;\n  badge?: {\n    type: ValueOf<typeof DropDownMenuItemBadgeType>;\n    placeholder: string;\n  };\n}\n\ninterface FontPickerListProps {\n  selectedFontFamily: FontFamilyValues | null;\n  hoveredFontFamily: FontFamilyValues | null;\n  onSelect: (value: number) => void;\n  onHover: (value: number) => void;\n  onLeave: () => void;\n  onOpen: () => void;\n  onClose: () => void;\n}\n\nconst getFontFamilyIcon = (fontFamily: FontFamilyValues): JSX.Element => {\n  switch (fontFamily) {\n    case FONT_FAMILY.Excalifont:\n    case FONT_FAMILY.Virgil:\n      return FreedrawIcon;\n    case FONT_FAMILY.Nunito:\n    case FONT_FAMILY.Helvetica:\n      return FontFamilyNormalIcon;\n    case FONT_FAMILY[\"Lilita One\"]:\n      return FontFamilyHeadingIcon;\n    case FONT_FAMILY[\"Comic Shanns\"]:\n    case FONT_FAMILY.Cascadia:\n      return FontFamilyCodeIcon;\n    default:\n      return FontFamilyNormalIcon;\n  }\n};\n\nexport const FontPickerList = React.memo(\n  ({\n    selectedFontFamily,\n    hoveredFontFamily,\n    onSelect,\n    onHover,\n    onLeave,\n    onOpen,\n    onClose,\n  }: FontPickerListProps) => {\n    const { container } = useExcalidrawContainer();\n    const { fonts } = useApp();\n    const { showDeprecatedFonts } = useAppProps();\n\n    const [searchTerm, setSearchTerm] = useState(\"\");\n    const inputRef = useRef<HTMLInputElement>(null);\n    const allFonts = useMemo(\n      () =>\n        Array.from(Fonts.registered.entries())\n          .filter(\n            ([_, { metadata }]) => !metadata.private && !metadata.fallback,\n          )\n          .map(([familyId, { metadata, fontFaces }]) => {\n            const fontDescriptor = {\n              value: familyId,\n              icon: getFontFamilyIcon(familyId),\n              text: fontFaces[0]?.fontFace?.family ?? \"Unknown\",\n            };\n\n            if (metadata.deprecated) {\n              Object.assign(fontDescriptor, {\n                deprecated: metadata.deprecated,\n                badge: {\n                  type: DropDownMenuItemBadgeType.RED,\n                  placeholder: t(\"fontList.badge.old\"),\n                },\n              });\n            }\n\n            return fontDescriptor as FontDescriptor;\n          })\n          .sort((a, b) =>\n            a.text.toLowerCase() > b.text.toLowerCase() ? 1 : -1,\n          ),\n      [],\n    );\n\n    const sceneFamilies = useMemo(\n      () => new Set(fonts.getSceneFamilies()),\n      // cache per selected font family, so hover re-render won't mess it up\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [selectedFontFamily],\n    );\n\n    const sceneFonts = useMemo(\n      () => allFonts.filter((font) => sceneFamilies.has(font.value)), // always show all the fonts in the scene, even those that were deprecated\n      [allFonts, sceneFamilies],\n    );\n\n    const availableFonts = useMemo(\n      () =>\n        allFonts.filter(\n          (font) =>\n            !sceneFamilies.has(font.value) &&\n            (showDeprecatedFonts || !font.deprecated), // skip deprecated fonts\n        ),\n      [allFonts, sceneFamilies, showDeprecatedFonts],\n    );\n\n    const filteredFonts = useMemo(\n      () =>\n        arrayToList(\n          [...sceneFonts, ...availableFonts].filter((font) =>\n            font.text?.toLowerCase().includes(searchTerm),\n          ),\n        ),\n      [sceneFonts, availableFonts, searchTerm],\n    );\n\n    const hoveredFont = useMemo(() => {\n      let font;\n\n      if (hoveredFontFamily) {\n        font = filteredFonts.find((font) => font.value === hoveredFontFamily);\n      } else if (selectedFontFamily) {\n        font = filteredFonts.find((font) => font.value === selectedFontFamily);\n      }\n\n      if (!font && searchTerm) {\n        if (filteredFonts[0]?.value) {\n          // hover first element on search\n          onHover(filteredFonts[0].value);\n        } else {\n          // re-render cache on no results\n          onLeave();\n        }\n      }\n\n      return font;\n    }, [\n      hoveredFontFamily,\n      selectedFontFamily,\n      searchTerm,\n      filteredFonts,\n      onHover,\n      onLeave,\n    ]);\n\n    const onKeyDown = useCallback<KeyboardEventHandler<HTMLDivElement>>(\n      (event) => {\n        const handled = fontPickerKeyHandler({\n          event,\n          inputRef,\n          hoveredFont,\n          filteredFonts,\n          onSelect,\n          onHover,\n          onClose,\n        });\n\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      },\n      [hoveredFont, filteredFonts, onSelect, onHover, onClose],\n    );\n\n    useEffect(() => {\n      onOpen();\n\n      return () => {\n        onClose();\n      };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    const sceneFilteredFonts = useMemo(\n      () => filteredFonts.filter((font) => sceneFamilies.has(font.value)),\n      [filteredFonts, sceneFamilies],\n    );\n\n    const availableFilteredFonts = useMemo(\n      () => filteredFonts.filter((font) => !sceneFamilies.has(font.value)),\n      [filteredFonts, sceneFamilies],\n    );\n\n    const renderFont = (font: FontDescriptor, index: number) => (\n      <DropdownMenuItem\n        key={font.value}\n        icon={font.icon}\n        value={font.value}\n        order={index}\n        textStyle={{\n          fontFamily: getFontFamilyString({ fontFamily: font.value }),\n        }}\n        hovered={font.value === hoveredFont?.value}\n        selected={font.value === selectedFontFamily}\n        // allow to tab between search and selected font\n        tabIndex={font.value === selectedFontFamily ? 0 : -1}\n        onClick={(e) => {\n          onSelect(Number(e.currentTarget.value));\n        }}\n        onMouseMove={() => {\n          if (hoveredFont?.value !== font.value) {\n            onHover(font.value);\n          }\n        }}\n      >\n        {font.text}\n        {font.badge && (\n          <DropDownMenuItemBadge type={font.badge.type}>\n            {font.badge.placeholder}\n          </DropDownMenuItemBadge>\n        )}\n      </DropdownMenuItem>\n    );\n\n    const groups = [];\n\n    if (sceneFilteredFonts.length) {\n      groups.push(\n        <DropdownMenuGroup title={t(\"fontList.sceneFonts\")} key=\"group_1\">\n          {sceneFilteredFonts.map(renderFont)}\n        </DropdownMenuGroup>,\n      );\n    }\n\n    if (availableFilteredFonts.length) {\n      groups.push(\n        <DropdownMenuGroup title={t(\"fontList.availableFonts\")} key=\"group_2\">\n          {availableFilteredFonts.map((font, index) =>\n            renderFont(font, index + sceneFilteredFonts.length),\n          )}\n        </DropdownMenuGroup>,\n      );\n    }\n\n    return (\n      <PropertiesPopover\n        className=\"properties-content\"\n        container={container}\n        style={{ width: \"15rem\" }}\n        onClose={onClose}\n        onPointerLeave={onLeave}\n        onKeyDown={onKeyDown}\n      >\n        <QuickSearch\n          ref={inputRef}\n          placeholder={t(\"quickSearch.placeholder\")}\n          onChange={debounce(setSearchTerm, 20)}\n        />\n        <ScrollableList\n          className=\"dropdown-menu fonts manual-hover\"\n          placeholder={t(\"fontList.empty\")}\n        >\n          {groups.length ? groups : null}\n        </ScrollableList>\n      </PropertiesPopover>\n    );\n  },\n  (prev, next) =>\n    prev.selectedFontFamily === next.selectedFontFamily &&\n    prev.hoveredFontFamily === next.hoveredFontFamily,\n);\n",
    "import clsx from \"clsx\";\nimport React from \"react\";\n\nimport { searchIcon } from \"./icons\";\n\nimport \"./QuickSearch.scss\";\n\ninterface QuickSearchProps {\n  className?: string;\n  placeholder: string;\n  onChange: (term: string) => void;\n}\n\nexport const QuickSearch = React.forwardRef<HTMLInputElement, QuickSearchProps>(\n  ({ className, placeholder, onChange }, ref) => {\n    return (\n      <div className={clsx(\"QuickSearch__wrapper\", className)}>\n        {searchIcon}\n        <input\n          ref={ref}\n          className=\"QuickSearch__input\"\n          type=\"text\"\n          placeholder={placeholder}\n          onChange={(e) => onChange(e.target.value.trim().toLowerCase())}\n        />\n      </div>\n    );\n  },\n);\n",
    "import clsx from \"clsx\";\nimport { Children } from \"react\";\n\nimport \"./ScrollableList.scss\";\n\ninterface ScrollableListProps {\n  className?: string;\n  placeholder: string;\n  children: React.ReactNode;\n}\n\nexport const ScrollableList = ({\n  className,\n  placeholder,\n  children,\n}: ScrollableListProps) => {\n  const isEmpty = !Children.count(children);\n\n  return (\n    <div className={clsx(\"ScrollableList__wrapper\", className)} role=\"menu\">\n      {isEmpty ? <div className=\"empty\">{placeholder}</div> : children}\n    </div>\n  );\n};\n",
    "import React from \"react\";\n\nconst MenuGroup = ({\n  children,\n  className = \"\",\n  style,\n  title,\n}: {\n  children: React.ReactNode;\n  className?: string;\n  style?: React.CSSProperties;\n  title?: string;\n}) => {\n  return (\n    <div className={`dropdown-menu-group ${className}`} style={style}>\n      {title && <p className=\"dropdown-menu-group-title\">{title}</p>}\n      {children}\n    </div>\n  );\n};\n\nexport default MenuGroup;\nMenuGroup.displayName = \"DropdownMenuGroup\";\n",
    "import React, { useEffect, useRef } from \"react\";\n\nimport { THEME } from \"@excalidraw/common\";\n\nimport type { ValueOf } from \"@excalidraw/common/utility-types\";\n\nimport { useExcalidrawAppState } from \"../App\";\n\nimport MenuItemContent from \"./DropdownMenuItemContent\";\nimport {\n  getDropdownMenuItemClassName,\n  useHandleDropdownMenuItemClick,\n} from \"./common\";\n\nimport type { JSX } from \"react\";\n\nconst DropdownMenuItem = ({\n  icon,\n  value,\n  order,\n  children,\n  shortcut,\n  className,\n  hovered,\n  selected,\n  textStyle,\n  onSelect,\n  onClick,\n  ...rest\n}: {\n  icon?: JSX.Element;\n  value?: string | number | undefined;\n  order?: number;\n  onSelect?: (event: Event) => void;\n  children: React.ReactNode;\n  shortcut?: string;\n  hovered?: boolean;\n  selected?: boolean;\n  textStyle?: React.CSSProperties;\n  className?: string;\n} & Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, \"onSelect\">) => {\n  const handleClick = useHandleDropdownMenuItemClick(onClick, onSelect);\n  const ref = useRef<HTMLButtonElement>(null);\n\n  useEffect(() => {\n    if (hovered) {\n      if (order === 0) {\n        // scroll into the first item differently, so it's visible what is above (i.e. group title)\n        ref.current?.scrollIntoView({ block: \"end\" });\n      } else {\n        ref.current?.scrollIntoView({ block: \"nearest\" });\n      }\n    }\n  }, [hovered, order]);\n\n  return (\n    <button\n      {...rest}\n      ref={ref}\n      value={value}\n      onClick={handleClick}\n      className={getDropdownMenuItemClassName(className, selected, hovered)}\n      title={rest.title ?? rest[\"aria-label\"]}\n    >\n      <MenuItemContent textStyle={textStyle} icon={icon} shortcut={shortcut}>\n        {children}\n      </MenuItemContent>\n    </button>\n  );\n};\nDropdownMenuItem.displayName = \"DropdownMenuItem\";\n\nexport const DropDownMenuItemBadgeType = {\n  GREEN: \"green\",\n  RED: \"red\",\n  BLUE: \"blue\",\n} as const;\n\nexport const DropDownMenuItemBadge = ({\n  type = DropDownMenuItemBadgeType.BLUE,\n  children,\n}: {\n  type?: ValueOf<typeof DropDownMenuItemBadgeType>;\n  children: React.ReactNode;\n}) => {\n  const { theme } = useExcalidrawAppState();\n  const style = {\n    display: \"inline-flex\",\n    marginLeft: \"auto\",\n    padding: \"2px 4px\",\n    borderRadius: 6,\n    fontSize: 9,\n    fontFamily: \"Cascadia, monospace\",\n    border: theme === THEME.LIGHT ? \"1.5px solid white\" : \"none\",\n  };\n\n  switch (type) {\n    case DropDownMenuItemBadgeType.GREEN:\n      Object.assign(style, {\n        backgroundColor: \"var(--background-color-badge)\",\n        color: \"var(--color-badge)\",\n      });\n      break;\n    case DropDownMenuItemBadgeType.RED:\n      Object.assign(style, {\n        backgroundColor: \"pink\",\n        color: \"darkred\",\n      });\n      break;\n    case DropDownMenuItemBadgeType.BLUE:\n    default:\n      Object.assign(style, {\n        background: \"var(--color-promo)\",\n        color: \"var(--color-surface-lowest)\",\n      });\n  }\n\n  return (\n    <div className=\"DropDownMenuItemBadge\" style={style}>\n      {children}\n    </div>\n  );\n};\nDropDownMenuItemBadge.displayName = \"DropdownMenuItemBadge\";\n\nDropdownMenuItem.Badge = DropDownMenuItemBadge;\n\nexport default DropdownMenuItem;\n",
    "import { useDevice } from \"../App\";\n\nimport type { JSX } from \"react\";\n\nconst MenuItemContent = ({\n  textStyle,\n  icon,\n  shortcut,\n  children,\n}: {\n  icon?: JSX.Element;\n  shortcut?: string;\n  textStyle?: React.CSSProperties;\n  children: React.ReactNode;\n}) => {\n  const device = useDevice();\n  return (\n    <>\n      {icon && <div className=\"dropdown-menu-item__icon\">{icon}</div>}\n      <div style={textStyle} className=\"dropdown-menu-item__text\">\n        {children}\n      </div>\n      {shortcut && !device.editor.isMobile && (\n        <div className=\"dropdown-menu-item__shortcut\">{shortcut}</div>\n      )}\n    </>\n  );\n};\nexport default MenuItemContent;\n",
    "import React, { useContext } from \"react\";\n\nimport { EVENT, composeEventHandlers } from \"@excalidraw/common\";\n\nexport const DropdownMenuContentPropsContext = React.createContext<{\n  onSelect?: (event: Event) => void;\n}>({});\n\nexport const getDropdownMenuItemClassName = (\n  className = \"\",\n  selected = false,\n  hovered = false,\n) => {\n  return `dropdown-menu-item dropdown-menu-item-base ${className}\n  ${selected ? \"dropdown-menu-item--selected\" : \"\"} ${\n    hovered ? \"dropdown-menu-item--hovered\" : \"\"\n  }`.trim();\n};\n\nexport const useHandleDropdownMenuItemClick = (\n  origOnClick:\n    | React.MouseEventHandler<HTMLAnchorElement | HTMLButtonElement>\n    | undefined,\n  onSelect: ((event: Event) => void) | undefined,\n) => {\n  const DropdownMenuContentProps = useContext(DropdownMenuContentPropsContext);\n\n  return composeEventHandlers(origOnClick, (event) => {\n    const itemSelectEvent = new CustomEvent(EVENT.MENU_ITEM_SELECT, {\n      bubbles: true,\n      cancelable: true,\n    });\n    onSelect?.(itemSelectEvent);\n    if (!itemSelectEvent.defaultPrevented) {\n      DropdownMenuContentProps.onSelect?.(itemSelectEvent);\n    }\n  });\n};\n",
    "import { KEYS } from \"@excalidraw/common\";\n\nimport type { Node } from \"@excalidraw/common\";\n\nimport { type FontDescriptor } from \"./FontPickerList\";\n\ninterface FontPickerKeyNavHandlerProps {\n  event: React.KeyboardEvent<HTMLDivElement>;\n  inputRef: React.RefObject<HTMLInputElement | null>;\n  hoveredFont: Node<FontDescriptor> | undefined;\n  filteredFonts: Node<FontDescriptor>[];\n  onClose: () => void;\n  onSelect: (value: number) => void;\n  onHover: (value: number) => void;\n}\n\nexport const fontPickerKeyHandler = ({\n  event,\n  inputRef,\n  hoveredFont,\n  filteredFonts,\n  onClose,\n  onSelect,\n  onHover,\n}: FontPickerKeyNavHandlerProps) => {\n  if (\n    !event[KEYS.CTRL_OR_CMD] &&\n    event.shiftKey &&\n    event.key.toLowerCase() === KEYS.F\n  ) {\n    // refocus input on the popup trigger shortcut\n    inputRef.current?.focus();\n    return true;\n  }\n\n  if (event.key === KEYS.ESCAPE) {\n    onClose();\n    return true;\n  }\n\n  if (event.key === KEYS.ENTER) {\n    if (hoveredFont?.value) {\n      onSelect(hoveredFont.value);\n    }\n\n    return true;\n  }\n\n  if (event.key === KEYS.ARROW_DOWN) {\n    if (hoveredFont?.next) {\n      onHover(hoveredFont.next.value);\n    } else if (filteredFonts[0]?.value) {\n      onHover(filteredFonts[0].value);\n    }\n\n    return true;\n  }\n\n  if (event.key === KEYS.ARROW_UP) {\n    if (hoveredFont?.prev) {\n      onHover(hoveredFont.prev.value);\n    } else if (filteredFonts[filteredFonts.length - 1]?.value) {\n      onHover(filteredFonts[filteredFonts.length - 1].value);\n    }\n\n    return true;\n  }\n};\n",
    "import * as Popover from \"@radix-ui/react-popover\";\nimport { useMemo } from \"react\";\n\nimport type { FontFamilyValues } from \"@excalidraw/element/types\";\n\nimport { t } from \"../../i18n\";\nimport { ButtonIcon } from \"../ButtonIcon\";\nimport { TextIcon } from \"../icons\";\n\nimport { isDefaultFont } from \"./FontPicker\";\n\ninterface FontPickerTriggerProps {\n  selectedFontFamily: FontFamilyValues | null;\n}\n\nexport const FontPickerTrigger = ({\n  selectedFontFamily,\n}: FontPickerTriggerProps) => {\n  const isTriggerActive = useMemo(\n    () => Boolean(selectedFontFamily && !isDefaultFont(selectedFontFamily)),\n    [selectedFontFamily],\n  );\n\n  return (\n    <Popover.Trigger asChild>\n      {/* Empty div as trigger so it's stretched 100% due to different button sizes */}\n      <div>\n        <ButtonIcon\n          standalone\n          icon={TextIcon}\n          title={t(\"labels.showFonts\")}\n          className=\"properties-trigger\"\n          testId={\"font-family-show-fonts\"}\n          active={isTriggerActive}\n          // no-op\n          onClick={() => {}}\n        />\n      </div>\n    </Popover.Trigger>\n  );\n};\n",
    "import * as Popover from \"@radix-ui/react-popover\";\nimport clsx from \"clsx\";\nimport React, { useEffect } from \"react\";\n\nimport { isArrowKey, KEYS } from \"@excalidraw/common\";\n\nimport { atom, useAtom } from \"../editor-jotai\";\nimport { getLanguage, t } from \"../i18n\";\n\nimport Collapsible from \"./Stats/Collapsible\";\nimport { useDevice } from \"./App\";\n\nimport \"./IconPicker.scss\";\n\nimport type { JSX } from \"react\";\n\nconst moreOptionsAtom = atom(false);\n\ntype Option<T> = {\n  value: T;\n  text: string;\n  icon: JSX.Element;\n  keyBinding: string | null;\n};\n\nfunction Picker<T>({\n  options,\n  value,\n  label,\n  onChange,\n  onClose,\n  numberOfOptionsToAlwaysShow = options.length,\n}: {\n  label: string;\n  value: T;\n  options: readonly Option<T>[];\n  onChange: (value: T) => void;\n  onClose: () => void;\n  numberOfOptionsToAlwaysShow?: number;\n}) {\n  const device = useDevice();\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    const pressedOption = options.find(\n      (option) => option.keyBinding === event.key.toLowerCase(),\n    )!;\n\n    if (!(event.metaKey || event.altKey || event.ctrlKey) && pressedOption) {\n      // Keybinding navigation\n      onChange(pressedOption.value);\n\n      event.preventDefault();\n    } else if (event.key === KEYS.TAB) {\n      const index = options.findIndex((option) => option.value === value);\n      const nextIndex = event.shiftKey\n        ? (options.length + index - 1) % options.length\n        : (index + 1) % options.length;\n      onChange(options[nextIndex].value);\n    } else if (isArrowKey(event.key)) {\n      // Arrow navigation\n      const isRTL = getLanguage().rtl;\n      const index = options.findIndex((option) => option.value === value);\n      if (index !== -1) {\n        const length = options.length;\n        let nextIndex = index;\n\n        switch (event.key) {\n          // Select the next option\n          case isRTL ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT:\n            nextIndex = (index + 1) % length;\n            break;\n          // Select the previous option\n          case isRTL ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT:\n            nextIndex = (length + index - 1) % length;\n            break;\n          // Go the next row\n          case KEYS.ARROW_DOWN: {\n            nextIndex = (index + (numberOfOptionsToAlwaysShow ?? 1)) % length;\n            break;\n          }\n          // Go the previous row\n          case KEYS.ARROW_UP: {\n            nextIndex =\n              (length + index - (numberOfOptionsToAlwaysShow ?? 1)) % length;\n            break;\n          }\n        }\n\n        onChange(options[nextIndex].value);\n      }\n      event.preventDefault();\n    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {\n      // Close on escape or enter\n      event.preventDefault();\n      onClose();\n    }\n    event.nativeEvent.stopImmediatePropagation();\n    event.stopPropagation();\n  };\n\n  const [showMoreOptions, setShowMoreOptions] = useAtom(moreOptionsAtom);\n\n  const alwaysVisibleOptions = React.useMemo(\n    () => options.slice(0, numberOfOptionsToAlwaysShow),\n    [options, numberOfOptionsToAlwaysShow],\n  );\n  const moreOptions = React.useMemo(\n    () => options.slice(numberOfOptionsToAlwaysShow),\n    [options, numberOfOptionsToAlwaysShow],\n  );\n\n  useEffect(() => {\n    if (!alwaysVisibleOptions.some((option) => option.value === value)) {\n      setShowMoreOptions(true);\n    }\n  }, [value, alwaysVisibleOptions, setShowMoreOptions]);\n\n  const renderOptions = (options: Option<T>[]) => {\n    return (\n      <div className=\"picker-content\">\n        {options.map((option, i) => (\n          <button\n            type=\"button\"\n            className={clsx(\"picker-option\", {\n              active: value === option.value,\n            })}\n            onClick={(event) => {\n              onChange(option.value);\n            }}\n            title={`${option.text} ${\n              option.keyBinding && `— ${option.keyBinding.toUpperCase()}`\n            }`}\n            aria-label={option.text || \"none\"}\n            aria-keyshortcuts={option.keyBinding || undefined}\n            key={option.text}\n            ref={(ref) => {\n              if (value === option.value) {\n                // Use a timeout here to render focus properly\n                setTimeout(() => {\n                  ref?.focus();\n                }, 0);\n              }\n            }}\n          >\n            {option.icon}\n            {option.keyBinding && (\n              <span className=\"picker-keybinding\">{option.keyBinding}</span>\n            )}\n          </button>\n        ))}\n      </div>\n    );\n  };\n\n  return (\n    <Popover.Content\n      side={\n        device.editor.isMobile && !device.viewport.isLandscape\n          ? \"top\"\n          : \"bottom\"\n      }\n      align=\"start\"\n      sideOffset={12}\n      style={{ zIndex: \"var(--zIndex-popup)\" }}\n      onKeyDown={handleKeyDown}\n    >\n      <div\n        className={`picker`}\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-label={label}\n      >\n        {renderOptions(alwaysVisibleOptions)}\n\n        {moreOptions.length > 0 && (\n          <Collapsible\n            label={t(\"labels.more_options\")}\n            open={showMoreOptions}\n            openTrigger={() => {\n              setShowMoreOptions((value) => !value);\n            }}\n            className=\"picker-collapsible\"\n          >\n            {renderOptions(moreOptions)}\n          </Collapsible>\n        )}\n      </div>\n    </Popover.Content>\n  );\n}\n\nexport function IconPicker<T>({\n  value,\n  label,\n  options,\n  onChange,\n  group = \"\",\n  numberOfOptionsToAlwaysShow,\n}: {\n  label: string;\n  value: T;\n  options: readonly {\n    value: T;\n    text: string;\n    icon: JSX.Element;\n    keyBinding: string | null;\n  }[];\n  onChange: (value: T) => void;\n  numberOfOptionsToAlwaysShow?: number;\n  group?: string;\n}) {\n  const [isActive, setActive] = React.useState(false);\n  const rPickerButton = React.useRef<any>(null);\n\n  return (\n    <div>\n      <Popover.Root open={isActive} onOpenChange={(open) => setActive(open)}>\n        <Popover.Trigger\n          name={group}\n          type=\"button\"\n          aria-label={label}\n          onClick={() => setActive(!isActive)}\n          ref={rPickerButton}\n          className={isActive ? \"active\" : \"\"}\n        >\n          {options.find((option) => option.value === value)?.icon}\n        </Popover.Trigger>\n        {isActive && (\n          <Picker\n            options={options}\n            value={value}\n            label={label}\n            onChange={onChange}\n            onClose={() => {\n              setActive(false);\n            }}\n            numberOfOptionsToAlwaysShow={numberOfOptionsToAlwaysShow}\n          />\n        )}\n      </Popover.Root>\n    </div>\n  );\n}\n",
    "export const InlineIcon = ({ icon }: { icon: React.ReactNode }) => {\n  return (\n    <span\n      style={{\n        width: \"1em\",\n        margin: \"0 0.5ex 0 0.5ex\",\n        display: \"inline-block\",\n        lineHeight: 0,\n        verticalAlign: \"middle\",\n      }}\n    >\n      {icon}\n    </span>\n  );\n};\n",
    "import { InlineIcon } from \"../InlineIcon\";\nimport { collapseDownIcon, collapseUpIcon } from \"../icons\";\n\ninterface CollapsibleProps {\n  label: React.ReactNode;\n  // having it controlled so that the state is managed outside\n  // this is to keep the user's previous choice even when the\n  // Collapsible is unmounted\n  open: boolean;\n  openTrigger: () => void;\n  children: React.ReactNode;\n  className?: string;\n  showCollapsedIcon?: boolean;\n}\n\nconst Collapsible = ({\n  label,\n  open,\n  openTrigger,\n  children,\n  className,\n  showCollapsedIcon = true,\n}: CollapsibleProps) => {\n  return (\n    <>\n      <div\n        style={{\n          cursor: \"pointer\",\n          display: \"flex\",\n          justifyContent: \"space-between\",\n          alignItems: \"center\",\n        }}\n        className={className}\n        onClick={openTrigger}\n      >\n        {label}\n        {showCollapsedIcon && (\n          <InlineIcon icon={open ? collapseUpIcon : collapseDownIcon} />\n        )}\n      </div>\n      {open && (\n        <div style={{ display: \"flex\", flexDirection: \"column\" }}>\n          {children}\n        </div>\n      )}\n    </>\n  );\n};\n\nexport default Collapsible;\n",
    "import React, { useEffect } from \"react\";\n\nimport { t } from \"../i18n\";\n\nimport \"./Range.scss\";\n\nimport type { AppClassProperties } from \"../types\";\n\nexport type RangeProps = {\n  updateData: (value: number) => void;\n  app: AppClassProperties;\n  testId?: string;\n};\n\nexport const Range = ({ updateData, app, testId }: RangeProps) => {\n  const rangeRef = React.useRef<HTMLInputElement>(null);\n  const valueRef = React.useRef<HTMLDivElement>(null);\n  const selectedElements = app.scene.getSelectedElements(app.state);\n  let hasCommonOpacity = true;\n  const firstElement = selectedElements.at(0);\n  const leastCommonOpacity = selectedElements.reduce((acc, element) => {\n    if (acc != null && acc !== element.opacity) {\n      hasCommonOpacity = false;\n    }\n    if (acc == null || acc > element.opacity) {\n      return element.opacity;\n    }\n    return acc;\n  }, firstElement?.opacity ?? null);\n\n  const value = leastCommonOpacity ?? app.state.currentItemOpacity;\n\n  useEffect(() => {\n    if (rangeRef.current && valueRef.current) {\n      const rangeElement = rangeRef.current;\n      const valueElement = valueRef.current;\n      const inputWidth = rangeElement.offsetWidth;\n      const thumbWidth = 15; // 15 is the width of the thumb\n      const position =\n        (value / 100) * (inputWidth - thumbWidth) + thumbWidth / 2;\n      valueElement.style.left = `${position}px`;\n      rangeElement.style.background = `linear-gradient(to right, var(--color-slider-track) 0%, var(--color-slider-track) ${value}%, var(--button-bg) ${value}%, var(--button-bg) 100%)`;\n    }\n  }, [value]);\n\n  return (\n    <label className=\"control-label\">\n      {t(\"labels.opacity\")}\n      <div className=\"range-wrapper\">\n        <input\n          style={{\n            [\"--color-slider-track\" as string]: hasCommonOpacity\n              ? undefined\n              : \"var(--button-bg)\",\n          }}\n          ref={rangeRef}\n          type=\"range\"\n          min=\"0\"\n          max=\"100\"\n          step=\"10\"\n          onChange={(event) => {\n            updateData(+event.target.value);\n          }}\n          value={value}\n          className=\"range-input\"\n          data-testid={testId}\n        />\n        <div className=\"value-bubble\" ref={valueRef}>\n          {value !== 0 ? value : null}\n        </div>\n        <div className=\"zero-label\">0</div>\n      </div>\n    </label>\n  );\n};\n",
    "import { clamp, roundToStep } from \"@excalidraw/math\";\n\nimport {\n  DEFAULT_CANVAS_BACKGROUND_PICKS,\n  CURSOR_TYPE,\n  MAX_ZOOM,\n  MIN_ZOOM,\n  THEME,\n  ZOOM_STEP,\n  getShortcutKey,\n  updateActiveTool,\n  CODES,\n  KEYS,\n} from \"@excalidraw/common\";\n\nimport { getNonDeletedElements } from \"@excalidraw/element\";\nimport { newElementWith } from \"@excalidraw/element\";\nimport { getCommonBounds, type SceneBounds } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport {\n  getDefaultAppState,\n  isEraserActive,\n  isHandToolActive,\n} from \"../appState\";\nimport { ColorPicker } from \"../components/ColorPicker/ColorPicker\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { Tooltip } from \"../components/Tooltip\";\nimport {\n  handIcon,\n  LassoIcon,\n  MoonIcon,\n  SunIcon,\n  TrashIcon,\n  zoomAreaIcon,\n  ZoomInIcon,\n  ZoomOutIcon,\n  ZoomResetIcon,\n} from \"../components/icons\";\nimport { setCursor } from \"../cursor\";\n\nimport { t } from \"../i18n\";\nimport { getNormalizedZoom } from \"../scene\";\nimport { centerScrollOn } from \"../scene/scroll\";\nimport { getStateForZoom } from \"../scene/zoom\";\n\nimport { register } from \"./register\";\n\nimport type { AppState, Offsets } from \"../types\";\n\nexport const actionChangeViewBackgroundColor = register({\n  name: \"changeViewBackgroundColor\",\n  label: \"labels.canvasBackground\",\n  trackEvent: false,\n  predicate: (elements, appState, props, app) => {\n    return (\n      !!app.props.UIOptions.canvasActions.changeViewBackgroundColor &&\n      !appState.viewModeEnabled\n    );\n  },\n  perform: (_, appState, value) => {\n    return {\n      appState: { ...appState, ...value },\n      captureUpdate: !!value.viewBackgroundColor\n        ? CaptureUpdateAction.IMMEDIATELY\n        : CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, appProps }) => {\n    // FIXME move me to src/components/mainMenu/DefaultItems.tsx\n    return (\n      <ColorPicker\n        palette={null}\n        topPicks={DEFAULT_CANVAS_BACKGROUND_PICKS}\n        label={t(\"labels.canvasBackground\")}\n        type=\"canvasBackground\"\n        color={appState.viewBackgroundColor}\n        onChange={(color) => updateData({ viewBackgroundColor: color })}\n        data-testid=\"canvas-background-picker\"\n        elements={elements}\n        appState={appState}\n        updateData={updateData}\n      />\n    );\n  },\n});\n\nexport const actionClearCanvas = register({\n  name: \"clearCanvas\",\n  label: \"labels.clearCanvas\",\n  icon: TrashIcon,\n  trackEvent: { category: \"canvas\" },\n  predicate: (elements, appState, props, app) => {\n    return (\n      !!app.props.UIOptions.canvasActions.clearCanvas &&\n      !appState.viewModeEnabled &&\n      appState.openDialog?.name !== \"elementLinkSelector\"\n    );\n  },\n  perform: (elements, appState, _, app) => {\n    app.imageCache.clear();\n    return {\n      elements: elements.map((element) =>\n        newElementWith(element, { isDeleted: true }),\n      ),\n      appState: {\n        ...getDefaultAppState(),\n        files: {},\n        theme: appState.theme,\n        penMode: appState.penMode,\n        penDetected: appState.penDetected,\n        exportBackground: appState.exportBackground,\n        exportEmbedScene: appState.exportEmbedScene,\n        gridSize: appState.gridSize,\n        gridStep: appState.gridStep,\n        gridModeEnabled: appState.gridModeEnabled,\n        stats: appState.stats,\n        pasteDialog: appState.pasteDialog,\n        activeTool:\n          appState.activeTool.type === \"image\"\n            ? { ...appState.activeTool, type: \"selection\" }\n            : appState.activeTool,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n});\n\nexport const actionZoomIn = register({\n  name: \"zoomIn\",\n  label: \"buttons.zoomIn\",\n  viewMode: true,\n  icon: ZoomInIcon,\n  trackEvent: { category: \"canvas\" },\n  perform: (_elements, appState, _, app) => {\n    return {\n      appState: {\n        ...appState,\n        ...getStateForZoom(\n          {\n            viewportX: appState.width / 2 + appState.offsetLeft,\n            viewportY: appState.height / 2 + appState.offsetTop,\n            nextZoom: getNormalizedZoom(appState.zoom.value + ZOOM_STEP),\n          },\n          appState,\n        ),\n        userToFollow: null,\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ updateData, appState }) => (\n    <ToolButton\n      type=\"button\"\n      className=\"zoom-in-button zoom-button\"\n      icon={ZoomInIcon}\n      title={`${t(\"buttons.zoomIn\")} — ${getShortcutKey(\"CtrlOrCmd++\")}`}\n      aria-label={t(\"buttons.zoomIn\")}\n      disabled={appState.zoom.value >= MAX_ZOOM}\n      onClick={() => {\n        updateData(null);\n      }}\n    />\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.EQUAL || event.code === CODES.NUM_ADD) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nexport const actionZoomOut = register({\n  name: \"zoomOut\",\n  label: \"buttons.zoomOut\",\n  icon: ZoomOutIcon,\n  viewMode: true,\n  trackEvent: { category: \"canvas\" },\n  perform: (_elements, appState, _, app) => {\n    return {\n      appState: {\n        ...appState,\n        ...getStateForZoom(\n          {\n            viewportX: appState.width / 2 + appState.offsetLeft,\n            viewportY: appState.height / 2 + appState.offsetTop,\n            nextZoom: getNormalizedZoom(appState.zoom.value - ZOOM_STEP),\n          },\n          appState,\n        ),\n        userToFollow: null,\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ updateData, appState }) => (\n    <ToolButton\n      type=\"button\"\n      className=\"zoom-out-button zoom-button\"\n      icon={ZoomOutIcon}\n      title={`${t(\"buttons.zoomOut\")} — ${getShortcutKey(\"CtrlOrCmd+-\")}`}\n      aria-label={t(\"buttons.zoomOut\")}\n      disabled={appState.zoom.value <= MIN_ZOOM}\n      onClick={() => {\n        updateData(null);\n      }}\n    />\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.MINUS || event.code === CODES.NUM_SUBTRACT) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nexport const actionResetZoom = register({\n  name: \"resetZoom\",\n  label: \"buttons.resetZoom\",\n  icon: ZoomResetIcon,\n  viewMode: true,\n  trackEvent: { category: \"canvas\" },\n  perform: (_elements, appState, _, app) => {\n    return {\n      appState: {\n        ...appState,\n        ...getStateForZoom(\n          {\n            viewportX: appState.width / 2 + appState.offsetLeft,\n            viewportY: appState.height / 2 + appState.offsetTop,\n            nextZoom: getNormalizedZoom(1),\n          },\n          appState,\n        ),\n        userToFollow: null,\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ updateData, appState }) => (\n    <Tooltip label={t(\"buttons.resetZoom\")} style={{ height: \"100%\" }}>\n      <ToolButton\n        type=\"button\"\n        className=\"reset-zoom-button zoom-button\"\n        title={t(\"buttons.resetZoom\")}\n        aria-label={t(\"buttons.resetZoom\")}\n        onClick={() => {\n          updateData(null);\n        }}\n      >\n        {(appState.zoom.value * 100).toFixed(0)}%\n      </ToolButton>\n    </Tooltip>\n  ),\n  keyTest: (event) =>\n    (event.code === CODES.ZERO || event.code === CODES.NUM_ZERO) &&\n    (event[KEYS.CTRL_OR_CMD] || event.shiftKey),\n});\n\nconst zoomValueToFitBoundsOnViewport = (\n  bounds: SceneBounds,\n  viewportDimensions: { width: number; height: number },\n  viewportZoomFactor: number = 1, // default to 1 if not provided\n) => {\n  const [x1, y1, x2, y2] = bounds;\n  const commonBoundsWidth = x2 - x1;\n  const zoomValueForWidth = viewportDimensions.width / commonBoundsWidth;\n  const commonBoundsHeight = y2 - y1;\n  const zoomValueForHeight = viewportDimensions.height / commonBoundsHeight;\n  const smallestZoomValue = Math.min(zoomValueForWidth, zoomValueForHeight);\n\n  const adjustedZoomValue =\n    smallestZoomValue * clamp(viewportZoomFactor, 0.1, 1);\n\n  return Math.min(adjustedZoomValue, 1);\n};\n\nexport const zoomToFitBounds = ({\n  bounds,\n  appState,\n  canvasOffsets,\n  fitToViewport = false,\n  viewportZoomFactor = 1,\n  minZoom = -Infinity,\n  maxZoom = Infinity,\n}: {\n  bounds: SceneBounds;\n  canvasOffsets?: Offsets;\n  appState: Readonly<AppState>;\n  /** whether to fit content to viewport (beyond >100%) */\n  fitToViewport: boolean;\n  /** zoom content to cover X of the viewport, when fitToViewport=true */\n  viewportZoomFactor?: number;\n  minZoom?: number;\n  maxZoom?: number;\n}) => {\n  viewportZoomFactor = clamp(viewportZoomFactor, MIN_ZOOM, MAX_ZOOM);\n\n  const [x1, y1, x2, y2] = bounds;\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n\n  const canvasOffsetLeft = canvasOffsets?.left ?? 0;\n  const canvasOffsetTop = canvasOffsets?.top ?? 0;\n  const canvasOffsetRight = canvasOffsets?.right ?? 0;\n  const canvasOffsetBottom = canvasOffsets?.bottom ?? 0;\n\n  const effectiveCanvasWidth =\n    appState.width - canvasOffsetLeft - canvasOffsetRight;\n  const effectiveCanvasHeight =\n    appState.height - canvasOffsetTop - canvasOffsetBottom;\n\n  let adjustedZoomValue;\n\n  if (fitToViewport) {\n    const commonBoundsWidth = x2 - x1;\n    const commonBoundsHeight = y2 - y1;\n\n    adjustedZoomValue =\n      Math.min(\n        effectiveCanvasWidth / commonBoundsWidth,\n        effectiveCanvasHeight / commonBoundsHeight,\n      ) * viewportZoomFactor;\n  } else {\n    adjustedZoomValue = zoomValueToFitBoundsOnViewport(\n      bounds,\n      {\n        width: effectiveCanvasWidth,\n        height: effectiveCanvasHeight,\n      },\n      viewportZoomFactor,\n    );\n  }\n\n  const newZoomValue = getNormalizedZoom(\n    clamp(roundToStep(adjustedZoomValue, ZOOM_STEP, \"floor\"), minZoom, maxZoom),\n  );\n\n  const centerScroll = centerScrollOn({\n    scenePoint: { x: centerX, y: centerY },\n    viewportDimensions: {\n      width: appState.width,\n      height: appState.height,\n    },\n    offsets: canvasOffsets,\n    zoom: { value: newZoomValue },\n  });\n\n  return {\n    appState: {\n      ...appState,\n      scrollX: centerScroll.scrollX,\n      scrollY: centerScroll.scrollY,\n      zoom: { value: newZoomValue },\n    },\n    captureUpdate: CaptureUpdateAction.EVENTUALLY,\n  };\n};\n\nexport const zoomToFit = ({\n  canvasOffsets,\n  targetElements,\n  appState,\n  fitToViewport,\n  viewportZoomFactor,\n  minZoom,\n  maxZoom,\n}: {\n  canvasOffsets?: Offsets;\n  targetElements: readonly ExcalidrawElement[];\n  appState: Readonly<AppState>;\n  /** whether to fit content to viewport (beyond >100%) */\n  fitToViewport: boolean;\n  /** zoom content to cover X of the viewport, when fitToViewport=true */\n  viewportZoomFactor?: number;\n  minZoom?: number;\n  maxZoom?: number;\n}) => {\n  const commonBounds = getCommonBounds(getNonDeletedElements(targetElements));\n\n  return zoomToFitBounds({\n    canvasOffsets,\n    bounds: commonBounds,\n    appState,\n    fitToViewport,\n    viewportZoomFactor,\n    minZoom,\n    maxZoom,\n  });\n};\n\n// Note, this action differs from actionZoomToFitSelection in that it doesn't\n// zoom beyond 100%. In other words, if the content is smaller than viewport\n// size, it won't be zoomed in.\nexport const actionZoomToFitSelectionInViewport = register({\n  name: \"zoomToFitSelectionInViewport\",\n  label: \"labels.zoomToFitViewport\",\n  icon: zoomAreaIcon,\n  trackEvent: { category: \"canvas\" },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    return zoomToFit({\n      targetElements: selectedElements.length ? selectedElements : elements,\n      appState: {\n        ...appState,\n        userToFollow: null,\n      },\n      fitToViewport: false,\n      canvasOffsets: app.getEditorUIOffsets(),\n    });\n  },\n  // NOTE shift-2 should have been assigned actionZoomToFitSelection.\n  // TBD on how proceed\n  keyTest: (event) =>\n    event.code === CODES.TWO &&\n    event.shiftKey &&\n    !event.altKey &&\n    !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionZoomToFitSelection = register({\n  name: \"zoomToFitSelection\",\n  label: \"helpDialog.zoomToSelection\",\n  icon: zoomAreaIcon,\n  trackEvent: { category: \"canvas\" },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    return zoomToFit({\n      targetElements: selectedElements.length ? selectedElements : elements,\n      appState: {\n        ...appState,\n        userToFollow: null,\n      },\n      fitToViewport: true,\n      canvasOffsets: app.getEditorUIOffsets(),\n    });\n  },\n  // NOTE this action should use shift-2 per figma, alas\n  keyTest: (event) =>\n    event.code === CODES.THREE &&\n    event.shiftKey &&\n    !event.altKey &&\n    !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionZoomToFit = register({\n  name: \"zoomToFit\",\n  label: \"helpDialog.zoomToFit\",\n  icon: zoomAreaIcon,\n  viewMode: true,\n  trackEvent: { category: \"canvas\" },\n  perform: (elements, appState, _, app) =>\n    zoomToFit({\n      targetElements: elements,\n      appState: {\n        ...appState,\n        userToFollow: null,\n      },\n      fitToViewport: false,\n      canvasOffsets: app.getEditorUIOffsets(),\n    }),\n  keyTest: (event) =>\n    event.code === CODES.ONE &&\n    event.shiftKey &&\n    !event.altKey &&\n    !event[KEYS.CTRL_OR_CMD],\n});\n\nexport const actionToggleTheme = register({\n  name: \"toggleTheme\",\n  label: (_, appState) => {\n    return appState.theme === THEME.DARK\n      ? \"buttons.lightMode\"\n      : \"buttons.darkMode\";\n  },\n  keywords: [\"toggle\", \"dark\", \"light\", \"mode\", \"theme\"],\n  icon: (appState) => (appState.theme === THEME.LIGHT ? MoonIcon : SunIcon),\n  viewMode: true,\n  trackEvent: { category: \"canvas\" },\n  perform: (_, appState, value) => {\n    return {\n      appState: {\n        ...appState,\n        theme:\n          value || (appState.theme === THEME.LIGHT ? THEME.DARK : THEME.LIGHT),\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  keyTest: (event) => event.altKey && event.shiftKey && event.code === CODES.D,\n  predicate: (elements, appState, props, app) => {\n    return !!app.props.UIOptions.canvasActions.toggleTheme;\n  },\n});\n\nexport const actionToggleEraserTool = register({\n  name: \"toggleEraserTool\",\n  label: \"toolBar.eraser\",\n  trackEvent: { category: \"toolbar\" },\n  perform: (elements, appState) => {\n    let activeTool: AppState[\"activeTool\"];\n\n    if (isEraserActive(appState)) {\n      activeTool = updateActiveTool(appState, {\n        ...(appState.activeTool.lastActiveTool || {\n          type: \"selection\",\n        }),\n        lastActiveToolBeforeEraser: null,\n      });\n    } else {\n      activeTool = updateActiveTool(appState, {\n        type: \"eraser\",\n        lastActiveToolBeforeEraser: appState.activeTool,\n      });\n    }\n\n    return {\n      appState: {\n        ...appState,\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        activeEmbeddable: null,\n        activeTool,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) => event.key === KEYS.E,\n});\n\nexport const actionToggleLassoTool = register({\n  name: \"toggleLassoTool\",\n  label: \"toolBar.lasso\",\n  icon: LassoIcon,\n  trackEvent: { category: \"toolbar\" },\n  perform: (elements, appState, _, app) => {\n    let activeTool: AppState[\"activeTool\"];\n\n    if (appState.activeTool.type !== \"lasso\") {\n      activeTool = updateActiveTool(appState, {\n        type: \"lasso\",\n        fromSelection: false,\n      });\n      setCursor(app.interactiveCanvas, CURSOR_TYPE.CROSSHAIR);\n    } else {\n      activeTool = updateActiveTool(appState, {\n        type: \"selection\",\n      });\n    }\n\n    return {\n      appState: {\n        ...appState,\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        activeEmbeddable: null,\n        activeTool,\n      },\n      captureUpdate: CaptureUpdateAction.NEVER,\n    };\n  },\n});\n\nexport const actionToggleHandTool = register({\n  name: \"toggleHandTool\",\n  label: \"toolBar.hand\",\n  trackEvent: { category: \"toolbar\" },\n  icon: handIcon,\n  viewMode: false,\n  perform: (elements, appState, _, app) => {\n    let activeTool: AppState[\"activeTool\"];\n\n    if (isHandToolActive(appState)) {\n      activeTool = updateActiveTool(appState, {\n        ...(appState.activeTool.lastActiveTool || {\n          type: \"selection\",\n        }),\n        lastActiveToolBeforeEraser: null,\n      });\n    } else {\n      activeTool = updateActiveTool(appState, {\n        type: \"hand\",\n        lastActiveToolBeforeEraser: appState.activeTool,\n      });\n      setCursor(app.interactiveCanvas, CURSOR_TYPE.GRAB);\n    }\n\n    return {\n      appState: {\n        ...appState,\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        activeEmbeddable: null,\n        activeTool,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    !event.altKey && !event[KEYS.CTRL_OR_CMD] && event.key === KEYS.H,\n});\n",
    "import React, { useEffect } from \"react\";\n\nimport \"./Tooltip.scss\";\n\nexport const getTooltipDiv = () => {\n  const existingDiv = document.querySelector<HTMLDivElement>(\n    \".excalidraw-tooltip\",\n  );\n  if (existingDiv) {\n    return existingDiv;\n  }\n  const div = document.createElement(\"div\");\n  document.body.appendChild(div);\n  div.classList.add(\"excalidraw-tooltip\");\n  return div;\n};\n\nexport const updateTooltipPosition = (\n  tooltip: HTMLDivElement,\n  item: {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  },\n  position: \"bottom\" | \"top\" = \"bottom\",\n) => {\n  const tooltipRect = tooltip.getBoundingClientRect();\n\n  const viewportWidth = window.innerWidth;\n  const viewportHeight = window.innerHeight;\n\n  const margin = 5;\n\n  let left = item.left + item.width / 2 - tooltipRect.width / 2;\n  if (left < 0) {\n    left = margin;\n  } else if (left + tooltipRect.width >= viewportWidth) {\n    left = viewportWidth - tooltipRect.width - margin;\n  }\n\n  let top: number;\n\n  if (position === \"bottom\") {\n    top = item.top + item.height + margin;\n    if (top + tooltipRect.height >= viewportHeight) {\n      top = item.top - tooltipRect.height - margin;\n    }\n  } else {\n    top = item.top - tooltipRect.height - margin;\n    if (top < 0) {\n      top = item.top + item.height + margin;\n    }\n  }\n\n  Object.assign(tooltip.style, {\n    top: `${top}px`,\n    left: `${left}px`,\n  });\n};\n\nconst updateTooltip = (\n  item: HTMLDivElement,\n  tooltip: HTMLDivElement,\n  label: string,\n  long: boolean,\n) => {\n  tooltip.classList.add(\"excalidraw-tooltip--visible\");\n  tooltip.style.minWidth = long ? \"50ch\" : \"10ch\";\n  tooltip.style.maxWidth = long ? \"50ch\" : \"15ch\";\n\n  tooltip.textContent = label;\n\n  const itemRect = item.getBoundingClientRect();\n  updateTooltipPosition(tooltip, itemRect);\n};\n\ntype TooltipProps = {\n  children: React.ReactNode;\n  label: string;\n  long?: boolean;\n  style?: React.CSSProperties;\n  disabled?: boolean;\n};\n\nexport const Tooltip = ({\n  children,\n  label,\n  long = false,\n  style,\n  disabled,\n}: TooltipProps) => {\n  useEffect(() => {\n    return () =>\n      getTooltipDiv().classList.remove(\"excalidraw-tooltip--visible\");\n  }, []);\n  if (disabled) {\n    return null;\n  }\n  return (\n    <div\n      className=\"excalidraw-tooltip-wrapper\"\n      onPointerEnter={(event) =>\n        updateTooltip(\n          event.currentTarget as HTMLDivElement,\n          getTooltipDiv(),\n          label,\n          long,\n        )\n      }\n      onPointerLeave={() =>\n        getTooltipDiv().classList.remove(\"excalidraw-tooltip--visible\")\n      }\n      style={style}\n    >\n      {children}\n    </div>\n  );\n};\n",
    "import OpenColor from \"open-color\";\n\nimport { CURSOR_TYPE, MIME_TYPES, THEME } from \"@excalidraw/common\";\n\nimport { isHandToolActive, isEraserActive } from \"./appState\";\n\nimport type { AppState, DataURL } from \"./types\";\n\nconst laserPointerCursorSVG_tag = `<svg viewBox=\"0 0 24 24\" stroke-width=\"1\" width=\"28\" height=\"28\" xmlns=\"http://www.w3.org/2000/svg\">`;\nconst laserPointerCursorBackgroundSVG = `<path d=\"M6.164 11.755a5.314 5.314 0 0 1-4.932-5.298 5.314 5.314 0 0 1 5.311-5.311 5.314 5.314 0 0 1 5.307 5.113l8.773 8.773a3.322 3.322 0 0 1 0 4.696l-.895.895a3.322 3.322 0 0 1-4.696 0l-8.868-8.868Z\" style=\"fill:#fff\"/>`;\nconst laserPointerCursorIconSVG = `<path stroke=\"#1b1b1f\" fill=\"#fff\" d=\"m7.868 11.113 7.773 7.774a2.359 2.359 0 0 0 1.667.691 2.368 2.368 0 0 0 2.357-2.358c0-.625-.248-1.225-.69-1.667L11.201 7.78 9.558 9.469l-1.69 1.643v.001Zm10.273 3.606-3.333 3.333m-3.25-6.583 2 2m-7-7 3 3M3.664 3.625l1 1M2.529 6.922l1.407-.144m5.735-2.932-1.118.866M4.285 9.823l.758-1.194m1.863-6.207-.13 1.408\"/>`;\n\nconst laserPointerCursorDataURL_lightMode = `data:${\n  MIME_TYPES.svg\n},${encodeURIComponent(\n  `${laserPointerCursorSVG_tag}${laserPointerCursorIconSVG}</svg>`,\n)}`;\nconst laserPointerCursorDataURL_darkMode = `data:${\n  MIME_TYPES.svg\n},${encodeURIComponent(\n  `${laserPointerCursorSVG_tag}${laserPointerCursorBackgroundSVG}${laserPointerCursorIconSVG}</svg>`,\n)}`;\n\nexport const resetCursor = (interactiveCanvas: HTMLCanvasElement | null) => {\n  if (interactiveCanvas) {\n    interactiveCanvas.style.cursor = \"\";\n  }\n};\n\nexport const setCursor = (\n  interactiveCanvas: HTMLCanvasElement | null,\n  cursor: string,\n) => {\n  if (interactiveCanvas) {\n    interactiveCanvas.style.cursor = cursor;\n  }\n};\n\nlet eraserCanvasCache: any;\nlet previewDataURL: string;\nexport const setEraserCursor = (\n  interactiveCanvas: HTMLCanvasElement | null,\n  theme: AppState[\"theme\"],\n) => {\n  const cursorImageSizePx = 20;\n\n  const drawCanvas = () => {\n    const isDarkTheme = theme === THEME.DARK;\n    eraserCanvasCache = document.createElement(\"canvas\");\n    eraserCanvasCache.theme = theme;\n    eraserCanvasCache.height = cursorImageSizePx;\n    eraserCanvasCache.width = cursorImageSizePx;\n    const context = eraserCanvasCache.getContext(\"2d\")!;\n    context.lineWidth = 1;\n    context.beginPath();\n    context.arc(\n      eraserCanvasCache.width / 2,\n      eraserCanvasCache.height / 2,\n      5,\n      0,\n      2 * Math.PI,\n    );\n    context.fillStyle = isDarkTheme ? OpenColor.black : OpenColor.white;\n    context.fill();\n    context.strokeStyle = isDarkTheme ? OpenColor.white : OpenColor.black;\n    context.stroke();\n    previewDataURL = eraserCanvasCache.toDataURL(MIME_TYPES.svg) as DataURL;\n  };\n  if (!eraserCanvasCache || eraserCanvasCache.theme !== theme) {\n    drawCanvas();\n  }\n\n  setCursor(\n    interactiveCanvas,\n    `url(${previewDataURL}) ${cursorImageSizePx / 2} ${\n      cursorImageSizePx / 2\n    }, auto`,\n  );\n};\n\nexport const setCursorForShape = (\n  interactiveCanvas: HTMLCanvasElement | null,\n  appState: Pick<AppState, \"activeTool\" | \"theme\">,\n) => {\n  if (!interactiveCanvas) {\n    return;\n  }\n  if (appState.activeTool.type === \"selection\") {\n    resetCursor(interactiveCanvas);\n  } else if (isHandToolActive(appState)) {\n    interactiveCanvas.style.cursor = CURSOR_TYPE.GRAB;\n  } else if (isEraserActive(appState)) {\n    setEraserCursor(interactiveCanvas, appState.theme);\n    // do nothing if image tool is selected which suggests there's\n    // a image-preview set as the cursor\n    // Ignore custom type as well and let host decide\n  } else if (appState.activeTool.type === \"laser\") {\n    const url =\n      appState.theme === THEME.LIGHT\n        ? laserPointerCursorDataURL_lightMode\n        : laserPointerCursorDataURL_darkMode;\n    interactiveCanvas.style.cursor = `url(${url}), auto`;\n  } else if (![\"image\", \"custom\"].includes(appState.activeTool.type)) {\n    interactiveCanvas.style.cursor = CURSOR_TYPE.CROSSHAIR;\n  } else if (appState.activeTool.type !== \"image\") {\n    interactiveCanvas.style.cursor = CURSOR_TYPE.AUTO;\n  }\n};\n",
    "import type { AppState, NormalizedZoomValue } from \"../types\";\n\nexport const getStateForZoom = (\n  {\n    viewportX,\n    viewportY,\n    nextZoom,\n  }: {\n    viewportX: number;\n    viewportY: number;\n    nextZoom: NormalizedZoomValue;\n  },\n  appState: AppState,\n) => {\n  const appLayerX = viewportX - appState.offsetLeft;\n  const appLayerY = viewportY - appState.offsetTop;\n\n  const currentZoom = appState.zoom.value;\n\n  // get original scroll position without zoom\n  const baseScrollX = appState.scrollX + (appLayerX - appLayerX / currentZoom);\n  const baseScrollY = appState.scrollY + (appLayerY - appLayerY / currentZoom);\n\n  // get scroll offsets for target zoom level\n  const zoomOffsetScrollX = -(appLayerX - appLayerX / nextZoom);\n  const zoomOffsetScrollY = -(appLayerY - appLayerY / nextZoom);\n\n  return {\n    scrollX: baseScrollX + zoomOffsetScrollX,\n    scrollY: baseScrollY + zoomOffsetScrollY,\n    zoom: {\n      value: nextZoom,\n    },\n  };\n};\n",
    "import { updateActiveTool } from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { setCursorForShape } from \"../cursor\";\n\nimport { register } from \"./register\";\n\nexport const actionSetEmbeddableAsActiveTool = register({\n  name: \"setEmbeddableAsActiveTool\",\n  trackEvent: { category: \"toolbar\" },\n  target: \"Tool\",\n  label: \"toolBar.embeddable\",\n  perform: (elements, appState, _, app) => {\n    const nextActiveTool = updateActiveTool(appState, {\n      type: \"embeddable\",\n    });\n\n    setCursorForShape(app.canvas, {\n      ...appState,\n      activeTool: nextActiveTool,\n    });\n\n    return {\n      elements,\n      appState: {\n        ...appState,\n        activeTool: updateActiveTool(appState, {\n          type: \"embeddable\",\n        }),\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n});\n",
    "import { pointFrom } from \"@excalidraw/math\";\n\nimport {\n  maybeBindLinearElement,\n  bindOrUnbindLinearElement,\n  isBindingEnabled,\n} from \"@excalidraw/element/binding\";\nimport { isValidPolygon, LinearElementEditor } from \"@excalidraw/element\";\n\nimport {\n  isBindingElement,\n  isFreeDrawElement,\n  isLinearElement,\n  isLineElement,\n} from \"@excalidraw/element\";\n\nimport {\n  KEYS,\n  arrayToMap,\n  tupleToCoors,\n  updateActiveTool,\n} from \"@excalidraw/common\";\nimport { isPathALoop } from \"@excalidraw/element\";\n\nimport { isInvisiblySmallElement } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { LocalPoint } from \"@excalidraw/math\";\nimport type {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n} from \"@excalidraw/element/types\";\n\nimport { t } from \"../i18n\";\nimport { resetCursor } from \"../cursor\";\nimport { done } from \"../components/icons\";\nimport { ToolButton } from \"../components/ToolButton\";\n\nimport { register } from \"./register\";\n\nimport type { AppState } from \"../types\";\n\nexport const actionFinalize = register({\n  name: \"finalize\",\n  label: \"\",\n  trackEvent: false,\n  perform: (elements, appState, data, app) => {\n    const { interactiveCanvas, focusContainer, scene } = app;\n    const { event, sceneCoords } =\n      (data as {\n        event?: PointerEvent;\n        sceneCoords?: { x: number; y: number };\n      }) ?? {};\n    const elementsMap = scene.getNonDeletedElementsMap();\n\n    if (event && appState.selectedLinearElement) {\n      const linearElementEditor = LinearElementEditor.handlePointerUp(\n        event,\n        appState.selectedLinearElement,\n        appState,\n        app.scene,\n      );\n\n      const { startBindingElement, endBindingElement } = linearElementEditor;\n      const element = app.scene.getElement(linearElementEditor.elementId);\n      if (isBindingElement(element)) {\n        bindOrUnbindLinearElement(\n          element,\n          startBindingElement,\n          endBindingElement,\n          app.scene,\n        );\n      }\n\n      if (linearElementEditor !== appState.selectedLinearElement) {\n        let newElements = elements;\n        if (element && isInvisiblySmallElement(element)) {\n          // TODO: #7348 in theory this gets recorded by the store, so the invisible elements could be restored by the undo/redo, which might be not what we would want\n          newElements = newElements.filter((el) => el.id !== element!.id);\n        }\n        return {\n          elements: newElements,\n          appState: {\n            selectedLinearElement: {\n              ...linearElementEditor,\n              selectedPointsIndices: null,\n            },\n            suggestedBindings: [],\n          },\n          captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n        };\n      }\n    }\n\n    if (appState.editingLinearElement) {\n      const { elementId, startBindingElement, endBindingElement } =\n        appState.editingLinearElement;\n      const element = LinearElementEditor.getElement(elementId, elementsMap);\n\n      if (element) {\n        if (isBindingElement(element)) {\n          bindOrUnbindLinearElement(\n            element,\n            startBindingElement,\n            endBindingElement,\n            scene,\n          );\n        }\n        if (isLineElement(element) && !isValidPolygon(element.points)) {\n          scene.mutateElement(element, {\n            polygon: false,\n          });\n        }\n\n        return {\n          elements:\n            element.points.length < 2 || isInvisiblySmallElement(element)\n              ? elements.filter((el) => el.id !== element.id)\n              : undefined,\n          appState: {\n            ...appState,\n            cursorButton: \"up\",\n            editingLinearElement: null,\n          },\n          captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n        };\n      }\n    }\n\n    let newElements = elements;\n\n    if (window.document.activeElement instanceof HTMLElement) {\n      focusContainer();\n    }\n\n    let element: NonDeleted<ExcalidrawElement> | null = null;\n    if (appState.multiElement) {\n      element = appState.multiElement;\n    } else if (\n      appState.newElement?.type === \"freedraw\" ||\n      isBindingElement(appState.newElement)\n    ) {\n      element = appState.newElement;\n    } else if (Object.keys(appState.selectedElementIds).length === 1) {\n      const candidate = elementsMap.get(\n        Object.keys(appState.selectedElementIds)[0],\n      ) as NonDeleted<ExcalidrawLinearElement> | undefined;\n      if (candidate) {\n        element = candidate;\n      }\n    }\n\n    if (element) {\n      // pen and mouse have hover\n      if (\n        appState.multiElement &&\n        element.type !== \"freedraw\" &&\n        appState.lastPointerDownWith !== \"touch\"\n      ) {\n        const { points, lastCommittedPoint } = element;\n        if (\n          !lastCommittedPoint ||\n          points[points.length - 1] !== lastCommittedPoint\n        ) {\n          scene.mutateElement(element, {\n            points: element.points.slice(0, -1),\n          });\n        }\n      }\n\n      if (element && isInvisiblySmallElement(element)) {\n        // TODO: #7348 in theory this gets recorded by the store, so the invisible elements could be restored by the undo/redo, which might be not what we would want\n        newElements = newElements.filter((el) => el.id !== element!.id);\n      }\n\n      if (isLinearElement(element) || isFreeDrawElement(element)) {\n        // If the multi point line closes the loop,\n        // set the last point to first point.\n        // This ensures that loop remains closed at different scales.\n        const isLoop = isPathALoop(element.points, appState.zoom.value);\n\n        if (isLoop && (isLineElement(element) || isFreeDrawElement(element))) {\n          const linePoints = element.points;\n          const firstPoint = linePoints[0];\n          const points: LocalPoint[] = linePoints.map((p, index) =>\n            index === linePoints.length - 1\n              ? pointFrom(firstPoint[0], firstPoint[1])\n              : p,\n          );\n          if (isLineElement(element)) {\n            scene.mutateElement(element, {\n              points,\n              polygon: true,\n            });\n          } else {\n            scene.mutateElement(element, {\n              points,\n            });\n          }\n        }\n\n        if (isLineElement(element) && !isValidPolygon(element.points)) {\n          scene.mutateElement(element, {\n            polygon: false,\n          });\n        }\n\n        if (\n          isBindingElement(element) &&\n          !isLoop &&\n          element.points.length > 1 &&\n          isBindingEnabled(appState)\n        ) {\n          const coords =\n            sceneCoords ??\n            tupleToCoors(\n              LinearElementEditor.getPointAtIndexGlobalCoordinates(\n                element,\n                -1,\n                arrayToMap(elements),\n              ),\n            );\n\n          maybeBindLinearElement(element, appState, coords, scene);\n        }\n      }\n    }\n\n    if (\n      (!appState.activeTool.locked &&\n        appState.activeTool.type !== \"freedraw\") ||\n      !element\n    ) {\n      resetCursor(interactiveCanvas);\n    }\n\n    let activeTool: AppState[\"activeTool\"];\n    if (appState.activeTool.type === \"eraser\") {\n      activeTool = updateActiveTool(appState, {\n        ...(appState.activeTool.lastActiveTool || {\n          type: \"selection\",\n        }),\n        lastActiveToolBeforeEraser: null,\n      });\n    } else {\n      activeTool = updateActiveTool(appState, {\n        type: \"selection\",\n      });\n    }\n\n    return {\n      elements: newElements,\n      appState: {\n        ...appState,\n        cursorButton: \"up\",\n        activeTool:\n          (appState.activeTool.locked ||\n            appState.activeTool.type === \"freedraw\") &&\n          element\n            ? appState.activeTool\n            : activeTool,\n        activeEmbeddable: null,\n        newElement: null,\n        selectionElement: null,\n        multiElement: null,\n        editingTextElement: null,\n        startBoundElement: null,\n        suggestedBindings: [],\n        selectedElementIds:\n          element &&\n          !appState.activeTool.locked &&\n          appState.activeTool.type !== \"freedraw\"\n            ? {\n                ...appState.selectedElementIds,\n                [element.id]: true,\n              }\n            : appState.selectedElementIds,\n        // To select the linear element when user has finished mutipoint editing\n        selectedLinearElement:\n          element && isLinearElement(element)\n            ? new LinearElementEditor(element, arrayToMap(newElements))\n            : appState.selectedLinearElement,\n      },\n      // TODO: #7348 we should not capture everything, but if we don't, it leads to incosistencies -> revisit\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event, appState) =>\n    (event.key === KEYS.ESCAPE &&\n      (appState.editingLinearElement !== null ||\n        (!appState.newElement && appState.multiElement === null))) ||\n    ((event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) &&\n      appState.multiElement !== null),\n  PanelComponent: ({ appState, updateData, data }) => (\n    <ToolButton\n      type=\"button\"\n      icon={done}\n      title={t(\"buttons.done\")}\n      aria-label={t(\"buttons.done\")}\n      onClick={updateData}\n      visible={appState.multiElement != null}\n      size={data?.size || \"medium\"}\n      style={{ pointerEvents: \"all\" }}\n    />\n  ),\n});\n",
    "import {\n  KEYS,\n  DEFAULT_EXPORT_PADDING,\n  EXPORT_SCALES,\n  THEME,\n} from \"@excalidraw/common\";\n\nimport { getNonDeletedElements } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { Theme } from \"@excalidraw/element/types\";\n\nimport { useDevice } from \"../components/App\";\nimport { CheckboxItem } from \"../components/CheckboxItem\";\nimport { DarkModeToggle } from \"../components/DarkModeToggle\";\nimport { ProjectName } from \"../components/ProjectName\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { Tooltip } from \"../components/Tooltip\";\nimport { ExportIcon, questionCircle, saveAs } from \"../components/icons\";\nimport { loadFromJSON, saveAsJSON } from \"../data\";\nimport { isImageFileHandle } from \"../data/blob\";\nimport { nativeFileSystemSupported } from \"../data/filesystem\";\nimport { resaveAsImageWithScene } from \"../data/resave\";\n\nimport { t } from \"../i18n\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { getExportSize } from \"../scene/export\";\n\nimport \"../components/ToolIcon.scss\";\n\nimport { register } from \"./register\";\n\nexport const actionChangeProjectName = register({\n  name: \"changeProjectName\",\n  label: \"labels.fileTitle\",\n  trackEvent: false,\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, name: value },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ appState, updateData, appProps, data, app }) => (\n    <ProjectName\n      label={t(\"labels.fileTitle\")}\n      value={app.getName()}\n      onChange={(name: string) => updateData(name)}\n      ignoreFocus={data?.ignoreFocus ?? false}\n    />\n  ),\n});\n\nexport const actionChangeExportScale = register({\n  name: \"changeExportScale\",\n  label: \"imageExportDialog.scale\",\n  trackEvent: { category: \"export\", action: \"scale\" },\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportScale: value },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ elements: allElements, appState, updateData }) => {\n    const elements = getNonDeletedElements(allElements);\n    const exportSelected = isSomeElementSelected(elements, appState);\n    const exportedElements = exportSelected\n      ? getSelectedElements(elements, appState)\n      : elements;\n\n    return (\n      <>\n        {EXPORT_SCALES.map((s) => {\n          const [width, height] = getExportSize(\n            exportedElements,\n            DEFAULT_EXPORT_PADDING,\n            s,\n          );\n\n          const scaleButtonTitle = `${t(\n            \"imageExportDialog.label.scale\",\n          )} ${s}x (${width}x${height})`;\n\n          return (\n            <ToolButton\n              key={s}\n              size=\"small\"\n              type=\"radio\"\n              icon={`${s}x`}\n              name=\"export-canvas-scale\"\n              title={scaleButtonTitle}\n              aria-label={scaleButtonTitle}\n              id=\"export-canvas-scale\"\n              checked={s === appState.exportScale}\n              onChange={() => updateData(s)}\n            />\n          );\n        })}\n      </>\n    );\n  },\n});\n\nexport const actionChangeExportBackground = register({\n  name: \"changeExportBackground\",\n  label: \"imageExportDialog.label.withBackground\",\n  trackEvent: { category: \"export\", action: \"toggleBackground\" },\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportBackground: value },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <CheckboxItem\n      checked={appState.exportBackground}\n      onChange={(checked) => updateData(checked)}\n    >\n      {t(\"imageExportDialog.label.withBackground\")}\n    </CheckboxItem>\n  ),\n});\n\nexport const actionChangeExportEmbedScene = register({\n  name: \"changeExportEmbedScene\",\n  label: \"imageExportDialog.tooltip.embedScene\",\n  trackEvent: { category: \"export\", action: \"embedScene\" },\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportEmbedScene: value },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <CheckboxItem\n      checked={appState.exportEmbedScene}\n      onChange={(checked) => updateData(checked)}\n    >\n      {t(\"imageExportDialog.label.embedScene\")}\n      <Tooltip label={t(\"imageExportDialog.tooltip.embedScene\")} long={true}>\n        <div className=\"excalidraw-tooltip-icon\">{questionCircle}</div>\n      </Tooltip>\n    </CheckboxItem>\n  ),\n});\n\nexport const actionSaveToActiveFile = register({\n  name: \"saveToActiveFile\",\n  label: \"buttons.save\",\n  icon: ExportIcon,\n  trackEvent: { category: \"export\" },\n  predicate: (elements, appState, props, app) => {\n    return (\n      !!app.props.UIOptions.canvasActions.saveToActiveFile &&\n      !!appState.fileHandle &&\n      !appState.viewModeEnabled\n    );\n  },\n  perform: async (elements, appState, value, app) => {\n    const fileHandleExists = !!appState.fileHandle;\n\n    try {\n      const { fileHandle } = isImageFileHandle(appState.fileHandle)\n        ? await resaveAsImageWithScene(\n            elements,\n            appState,\n            app.files,\n            app.getName(),\n          )\n        : await saveAsJSON(elements, appState, app.files, app.getName());\n\n      return {\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n        appState: {\n          ...appState,\n          fileHandle,\n          toast: fileHandleExists\n            ? {\n                message: fileHandle?.name\n                  ? t(\"toast.fileSavedToFilename\").replace(\n                      \"{filename}\",\n                      `\"${fileHandle.name}\"`,\n                    )\n                  : t(\"toast.fileSaved\"),\n              }\n            : null,\n        },\n      };\n    } catch (error: any) {\n      if (error?.name !== \"AbortError\") {\n        console.error(error);\n      } else {\n        console.warn(error);\n      }\n      return { captureUpdate: CaptureUpdateAction.EVENTUALLY };\n    }\n  },\n  keyTest: (event) =>\n    event.key === KEYS.S && event[KEYS.CTRL_OR_CMD] && !event.shiftKey,\n});\n\nexport const actionSaveFileToDisk = register({\n  name: \"saveFileToDisk\",\n  label: \"exportDialog.disk_title\",\n  icon: ExportIcon,\n  viewMode: true,\n  trackEvent: { category: \"export\" },\n  perform: async (elements, appState, value, app) => {\n    try {\n      const { fileHandle } = await saveAsJSON(\n        elements,\n        {\n          ...appState,\n          fileHandle: null,\n        },\n        app.files,\n        app.getName(),\n      );\n      return {\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n        appState: {\n          ...appState,\n          openDialog: null,\n          fileHandle,\n          toast: { message: t(\"toast.fileSaved\") },\n        },\n      };\n    } catch (error: any) {\n      if (error?.name !== \"AbortError\") {\n        console.error(error);\n      } else {\n        console.warn(error);\n      }\n      return { captureUpdate: CaptureUpdateAction.EVENTUALLY };\n    }\n  },\n  keyTest: (event) =>\n    event.key === KEYS.S && event.shiftKey && event[KEYS.CTRL_OR_CMD],\n  PanelComponent: ({ updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={saveAs}\n      title={t(\"buttons.saveAs\")}\n      aria-label={t(\"buttons.saveAs\")}\n      showAriaLabel={useDevice().editor.isMobile}\n      hidden={!nativeFileSystemSupported}\n      onClick={() => updateData(null)}\n      data-testid=\"save-as-button\"\n    />\n  ),\n});\n\nexport const actionLoadScene = register({\n  name: \"loadScene\",\n  label: \"buttons.load\",\n  trackEvent: { category: \"export\" },\n  predicate: (elements, appState, props, app) => {\n    return (\n      !!app.props.UIOptions.canvasActions.loadScene && !appState.viewModeEnabled\n    );\n  },\n  perform: async (elements, appState, _, app) => {\n    try {\n      const {\n        elements: loadedElements,\n        appState: loadedAppState,\n        files,\n      } = await loadFromJSON(appState, elements);\n      return {\n        elements: loadedElements,\n        appState: loadedAppState,\n        files,\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    } catch (error: any) {\n      if (error?.name === \"AbortError\") {\n        console.warn(error);\n        return false;\n      }\n      return {\n        elements,\n        appState: { ...appState, errorMessage: error.message },\n        files: app.files,\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    }\n  },\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.O,\n});\n\nexport const actionExportWithDarkMode = register({\n  name: \"exportWithDarkMode\",\n  label: \"imageExportDialog.label.darkMode\",\n  trackEvent: { category: \"export\", action: \"toggleTheme\" },\n  perform: (_elements, appState, value) => {\n    return {\n      appState: { ...appState, exportWithDarkMode: value },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ appState, updateData }) => (\n    <div\n      style={{\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        marginTop: \"-45px\",\n        marginBottom: \"10px\",\n      }}\n    >\n      <DarkModeToggle\n        value={appState.exportWithDarkMode ? THEME.DARK : THEME.LIGHT}\n        onChange={(theme: Theme) => {\n          updateData(theme === THEME.DARK);\n        }}\n        title={t(\"imageExportDialog.label.darkMode\")}\n      />\n    </div>\n  ),\n});\n",
    "import clsx from \"clsx\";\nimport React from \"react\";\n\nimport { checkIcon } from \"./icons\";\n\nimport \"./CheckboxItem.scss\";\n\nexport const CheckboxItem: React.FC<{\n  checked: boolean;\n  onChange: (checked: boolean, event: React.MouseEvent) => void;\n  className?: string;\n  children?: React.ReactNode;\n}> = ({ children, checked, onChange, className }) => {\n  return (\n    <div\n      className={clsx(\"Checkbox\", className, { \"is-checked\": checked })}\n      onClick={(event) => {\n        onChange(!checked, event);\n        (\n          (event.currentTarget as HTMLDivElement).querySelector(\n            \".Checkbox-box\",\n          ) as HTMLButtonElement\n        ).focus();\n      }}\n    >\n      <button\n        type=\"button\"\n        className=\"Checkbox-box\"\n        role=\"checkbox\"\n        aria-checked={checked}\n      >\n        {checkIcon}\n      </button>\n      <div className=\"Checkbox-label\">{children}</div>\n    </div>\n  );\n};\n",
    "import { THEME } from \"@excalidraw/common\";\n\nimport type { Theme } from \"@excalidraw/element/types\";\n\nimport { t } from \"../i18n\";\n\nimport { ToolButton } from \"./ToolButton\";\n\nimport \"./ToolIcon.scss\";\n\n// We chose to use only explicit toggle and not a third option for system value,\n// but this could be added in the future.\nexport const DarkModeToggle = (props: {\n  value: Theme;\n  onChange: (value: Theme) => void;\n  title?: string;\n}) => {\n  const title =\n    props.title ||\n    (props.value === THEME.DARK\n      ? t(\"buttons.lightMode\")\n      : t(\"buttons.darkMode\"));\n\n  return (\n    <ToolButton\n      type=\"icon\"\n      icon={props.value === THEME.LIGHT ? ICONS.MOON : ICONS.SUN}\n      title={title}\n      aria-label={title}\n      onClick={() =>\n        props.onChange(props.value === THEME.DARK ? THEME.LIGHT : THEME.DARK)\n      }\n      data-testid=\"toggle-dark-mode\"\n    />\n  );\n};\n\nconst ICONS = {\n  SUN: (\n    <svg width=\"512\" height=\"512\" className=\"rtl-mirror\" viewBox=\"0 0 512 512\">\n      <path\n        fill=\"currentColor\"\n        d=\"M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z\"\n      ></path>\n    </svg>\n  ),\n  MOON: (\n    <svg width=\"512\" height=\"512\" className=\"rtl-mirror\" viewBox=\"0 0 512 512\">\n      <path\n        fill=\"currentColor\"\n        d=\"M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z\"\n      ></path>\n    </svg>\n  ),\n};\n",
    "import React, { useState } from \"react\";\n\nimport { focusNearestParent, KEYS } from \"@excalidraw/common\";\n\nimport { useExcalidrawContainer } from \"./App\";\n\nimport \"./TextInput.scss\";\nimport \"./ProjectName.scss\";\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n  label: string;\n  ignoreFocus?: boolean;\n};\n\nexport const ProjectName = (props: Props) => {\n  const { id } = useExcalidrawContainer();\n  const [fileName, setFileName] = useState<string>(props.value);\n\n  const handleBlur = (event: any) => {\n    if (!props.ignoreFocus) {\n      focusNearestParent(event.target);\n    }\n    const value = event.target.value;\n    if (value !== props.value) {\n      props.onChange(value);\n    }\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\n    if (event.key === KEYS.ENTER) {\n      event.preventDefault();\n      if (event.nativeEvent.isComposing || event.keyCode === 229) {\n        return;\n      }\n      event.currentTarget.blur();\n    }\n  };\n\n  return (\n    <div className=\"ProjectName\">\n      <label className=\"ProjectName-label\" htmlFor=\"filename\">\n        {`${props.label}:`}\n      </label>\n      <input\n        type=\"text\"\n        className=\"TextInput\"\n        onBlur={handleBlur}\n        onKeyDown={handleKeyDown}\n        id={`${id}-filename`}\n        value={fileName}\n        onChange={(event) => setFileName(event.target.value)}\n      />\n    </div>\n  );\n};\n",
    "import {\n  DEFAULT_EXPORT_PADDING,\n  DEFAULT_FILENAME,\n  IMAGE_MIME_TYPES,\n  isFirefox,\n  MIME_TYPES,\n  cloneJSON,\n  SVG_DOCUMENT_PREAMBLE,\n} from \"@excalidraw/common\";\n\nimport { getNonDeletedElements } from \"@excalidraw/element\";\n\nimport { isFrameLikeElement } from \"@excalidraw/element\";\n\nimport { getElementsOverlappingFrame } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawFrameLikeElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport {\n  copyBlobToClipboardAsPng,\n  copyTextToSystemClipboard,\n} from \"../clipboard\";\n\nimport { t } from \"../i18n\";\nimport { getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { exportToCanvas, exportToSvg } from \"../scene/export\";\n\nimport { canvasToBlob } from \"./blob\";\nimport { fileSave } from \"./filesystem\";\nimport { serializeAsJSON } from \"./json\";\n\nimport type { FileSystemHandle } from \"./filesystem\";\n\nimport type { ExportType } from \"../scene/types\";\nimport type { AppState, BinaryFiles } from \"../types\";\n\nexport { loadFromBlob } from \"./blob\";\nexport { loadFromJSON, saveAsJSON } from \"./json\";\n\nexport type ExportedElements = readonly NonDeletedExcalidrawElement[] & {\n  _brand: \"exportedElements\";\n};\n\nexport const prepareElementsForExport = (\n  elements: readonly ExcalidrawElement[],\n  { selectedElementIds }: Pick<AppState, \"selectedElementIds\">,\n  exportSelectionOnly: boolean,\n) => {\n  elements = getNonDeletedElements(elements);\n\n  const isExportingSelection =\n    exportSelectionOnly &&\n    isSomeElementSelected(elements, { selectedElementIds });\n\n  let exportingFrame: ExcalidrawFrameLikeElement | null = null;\n  let exportedElements = isExportingSelection\n    ? getSelectedElements(\n        elements,\n        { selectedElementIds },\n        {\n          includeBoundTextElement: true,\n        },\n      )\n    : elements;\n\n  if (isExportingSelection) {\n    if (\n      exportedElements.length === 1 &&\n      isFrameLikeElement(exportedElements[0])\n    ) {\n      exportingFrame = exportedElements[0];\n      exportedElements = getElementsOverlappingFrame(elements, exportingFrame);\n    } else if (exportedElements.length > 1) {\n      exportedElements = getSelectedElements(\n        elements,\n        { selectedElementIds },\n        {\n          includeBoundTextElement: true,\n          includeElementsInFrames: true,\n        },\n      );\n    }\n  }\n\n  return {\n    exportingFrame,\n    exportedElements: cloneJSON(exportedElements) as ExportedElements,\n  };\n};\n\nexport const exportCanvas = async (\n  type: Omit<ExportType, \"backend\">,\n  elements: ExportedElements,\n  appState: AppState,\n  files: BinaryFiles,\n  {\n    exportBackground,\n    exportPadding = DEFAULT_EXPORT_PADDING,\n    viewBackgroundColor,\n    name = appState.name || DEFAULT_FILENAME,\n    fileHandle = null,\n    exportingFrame = null,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n    /** filename, if applicable */\n    name?: string;\n    fileHandle?: FileSystemHandle | null;\n    exportingFrame: ExcalidrawFrameLikeElement | null;\n  },\n) => {\n  if (elements.length === 0) {\n    throw new Error(t(\"alerts.cannotExportEmptyCanvas\"));\n  }\n  if (type === \"svg\" || type === \"clipboard-svg\") {\n    const svgPromise = exportToSvg(\n      elements,\n      {\n        exportBackground,\n        exportWithDarkMode: appState.exportWithDarkMode,\n        viewBackgroundColor,\n        exportPadding,\n        exportScale: appState.exportScale,\n        exportEmbedScene: appState.exportEmbedScene && type === \"svg\",\n      },\n      files,\n      { exportingFrame },\n    );\n\n    if (type === \"svg\") {\n      return fileSave(\n        svgPromise.then((svg) => {\n          // adding SVG preamble so that older software parse the SVG file\n          // properly\n          return new Blob([SVG_DOCUMENT_PREAMBLE + svg.outerHTML], {\n            type: MIME_TYPES.svg,\n          });\n        }),\n        {\n          description: \"Export to SVG\",\n          name,\n          extension: appState.exportEmbedScene ? \"excalidraw.svg\" : \"svg\",\n          mimeTypes: [IMAGE_MIME_TYPES.svg],\n          fileHandle,\n        },\n      );\n    } else if (type === \"clipboard-svg\") {\n      const svg = await svgPromise.then((svg) => svg.outerHTML);\n      try {\n        await copyTextToSystemClipboard(svg);\n      } catch (e) {\n        throw new Error(t(\"errors.copyToSystemClipboardFailed\"));\n      }\n      return;\n    }\n  }\n\n  const tempCanvas = exportToCanvas(elements, appState, files, {\n    exportBackground,\n    viewBackgroundColor,\n    exportPadding,\n    exportingFrame,\n  });\n\n  if (type === \"png\") {\n    let blob = canvasToBlob(tempCanvas);\n\n    if (appState.exportEmbedScene) {\n      blob = blob.then((blob) =>\n        import(\"./image\").then(({ encodePngMetadata }) =>\n          encodePngMetadata({\n            blob,\n            metadata: serializeAsJSON(elements, appState, files, \"local\"),\n          }),\n        ),\n      );\n    }\n\n    return fileSave(blob, {\n      description: \"Export to PNG\",\n      name,\n      extension: appState.exportEmbedScene ? \"excalidraw.png\" : \"png\",\n      mimeTypes: [IMAGE_MIME_TYPES.png],\n      fileHandle,\n    });\n  } else if (type === \"clipboard\") {\n    try {\n      const blob = canvasToBlob(tempCanvas);\n      await copyBlobToClipboardAsPng(blob);\n    } catch (error: any) {\n      console.warn(error);\n      if (error.name === \"CANVAS_POSSIBLY_TOO_BIG\") {\n        throw new Error(t(\"canvasError.canvasTooBig\"));\n      }\n      // TypeError *probably* suggests ClipboardItem not defined, which\n      // people on Firefox can enable through a flag, so let's tell them.\n      if (isFirefox && error.name === \"TypeError\") {\n        throw new Error(\n          `${t(\"alerts.couldNotCopyToClipboard\")}\\n\\n${t(\n            \"hints.firefox_clipboard_write\",\n          )}`,\n        );\n      } else {\n        throw new Error(t(\"alerts.couldNotCopyToClipboard\"));\n      }\n    }\n  } else {\n    // shouldn't happen\n    throw new Error(\"Unsupported export type\");\n  }\n};\n",
    "import {\n  ALLOWED_PASTE_MIME_TYPES,\n  EXPORT_DATA_TYPES,\n  MIME_TYPES,\n  arrayToMap,\n  isMemberOf,\n  isPromiseLike,\n} from \"@excalidraw/common\";\n\nimport { mutateElement } from \"@excalidraw/element\";\nimport { deepCopyElement } from \"@excalidraw/element\";\nimport {\n  isFrameLikeElement,\n  isInitializedImageElement,\n} from \"@excalidraw/element\";\n\nimport { getContainingFrame } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport { ExcalidrawError } from \"./errors\";\nimport { createFile, isSupportedImageFileType } from \"./data/blob\";\nimport { tryParseSpreadsheet, VALID_SPREADSHEET } from \"./charts\";\n\nimport type { Spreadsheet } from \"./charts\";\n\nimport type { BinaryFiles } from \"./types\";\n\ntype ElementsClipboard = {\n  type: typeof EXPORT_DATA_TYPES.excalidrawClipboard;\n  elements: readonly NonDeletedExcalidrawElement[];\n  files: BinaryFiles | undefined;\n};\n\nexport type PastedMixedContent = { type: \"text\" | \"imageUrl\"; value: string }[];\n\nexport interface ClipboardData {\n  spreadsheet?: Spreadsheet;\n  elements?: readonly ExcalidrawElement[];\n  files?: BinaryFiles;\n  text?: string;\n  mixedContent?: PastedMixedContent;\n  errorMessage?: string;\n  programmaticAPI?: boolean;\n}\n\ntype AllowedPasteMimeTypes = typeof ALLOWED_PASTE_MIME_TYPES[number];\n\ntype ParsedClipboardEventTextData =\n  | { type: \"text\"; value: string }\n  | { type: \"mixedContent\"; value: PastedMixedContent };\n\nexport const probablySupportsClipboardReadText =\n  \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardWriteText =\n  \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardBlob =\n  \"clipboard\" in navigator &&\n  \"write\" in navigator.clipboard &&\n  \"ClipboardItem\" in window &&\n  \"toBlob\" in HTMLCanvasElement.prototype;\n\nconst clipboardContainsElements = (\n  contents: any,\n): contents is { elements: ExcalidrawElement[]; files?: BinaryFiles } => {\n  if (\n    [\n      EXPORT_DATA_TYPES.excalidraw,\n      EXPORT_DATA_TYPES.excalidrawClipboard,\n      EXPORT_DATA_TYPES.excalidrawClipboardWithAPI,\n    ].includes(contents?.type) &&\n    Array.isArray(contents.elements)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport const createPasteEvent = ({\n  types,\n  files,\n}: {\n  types?: { [key in AllowedPasteMimeTypes]?: string | File };\n  files?: File[];\n}) => {\n  if (!types && !files) {\n    console.warn(\"createPasteEvent: no types or files provided\");\n  }\n\n  const event = new ClipboardEvent(\"paste\", {\n    clipboardData: new DataTransfer(),\n  });\n\n  if (types) {\n    for (const [type, value] of Object.entries(types)) {\n      if (typeof value !== \"string\") {\n        files = files || [];\n        files.push(value);\n        continue;\n      }\n      try {\n        event.clipboardData?.setData(type, value);\n        if (event.clipboardData?.getData(type) !== value) {\n          throw new Error(`Failed to set \"${type}\" as clipboardData item`);\n        }\n      } catch (error: any) {\n        throw new Error(error.message);\n      }\n    }\n  }\n\n  if (files) {\n    let idx = -1;\n    for (const file of files) {\n      idx++;\n      try {\n        event.clipboardData?.items.add(file);\n        if (event.clipboardData?.files[idx] !== file) {\n          throw new Error(\n            `Failed to set file \"${file.name}\" as clipboardData item`,\n          );\n        }\n      } catch (error: any) {\n        throw new Error(error.message);\n      }\n    }\n  }\n\n  return event;\n};\n\nexport const serializeAsClipboardJSON = ({\n  elements,\n  files,\n}: {\n  elements: readonly NonDeletedExcalidrawElement[];\n  files: BinaryFiles | null;\n}) => {\n  const elementsMap = arrayToMap(elements);\n  const framesToCopy = new Set(\n    elements.filter((element) => isFrameLikeElement(element)),\n  );\n  let foundFile = false;\n\n  const _files = elements.reduce((acc, element) => {\n    if (isInitializedImageElement(element)) {\n      foundFile = true;\n      if (files && files[element.fileId]) {\n        acc[element.fileId] = files[element.fileId];\n      }\n    }\n    return acc;\n  }, {} as BinaryFiles);\n\n  if (foundFile && !files) {\n    console.warn(\n      \"copyToClipboard: attempting to file element(s) without providing associated `files` object.\",\n    );\n  }\n\n  // select bound text elements when copying\n  const contents: ElementsClipboard = {\n    type: EXPORT_DATA_TYPES.excalidrawClipboard,\n    elements: elements.map((element) => {\n      if (\n        getContainingFrame(element, elementsMap) &&\n        !framesToCopy.has(getContainingFrame(element, elementsMap)!)\n      ) {\n        const copiedElement = deepCopyElement(element);\n        mutateElement(copiedElement, elementsMap, {\n          frameId: null,\n        });\n        return copiedElement;\n      }\n\n      return element;\n    }),\n    files: files ? _files : undefined,\n  };\n\n  return JSON.stringify(contents);\n};\n\nexport const copyToClipboard = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  files: BinaryFiles | null,\n  /** supply if available to make the operation more certain to succeed */\n  clipboardEvent?: ClipboardEvent | null,\n) => {\n  await copyTextToSystemClipboard(\n    serializeAsClipboardJSON({ elements, files }),\n    clipboardEvent,\n  );\n};\n\nconst parsePotentialSpreadsheet = (\n  text: string,\n): { spreadsheet: Spreadsheet } | { errorMessage: string } | null => {\n  const result = tryParseSpreadsheet(text);\n  if (result.type === VALID_SPREADSHEET) {\n    return { spreadsheet: result.spreadsheet };\n  }\n  return null;\n};\n\n/** internal, specific to parsing paste events. Do not reuse. */\nfunction parseHTMLTree(el: ChildNode) {\n  let result: PastedMixedContent = [];\n  for (const node of el.childNodes) {\n    if (node.nodeType === 3) {\n      const text = node.textContent?.trim();\n      if (text) {\n        result.push({ type: \"text\", value: text });\n      }\n    } else if (node instanceof HTMLImageElement) {\n      const url = node.getAttribute(\"src\");\n      if (url && url.startsWith(\"http\")) {\n        result.push({ type: \"imageUrl\", value: url });\n      }\n    } else {\n      result = result.concat(parseHTMLTree(node));\n    }\n  }\n  return result;\n}\n\nconst maybeParseHTMLPaste = (\n  event: ClipboardEvent,\n): { type: \"mixedContent\"; value: PastedMixedContent } | null => {\n  const html = event.clipboardData?.getData(MIME_TYPES.html);\n\n  if (!html) {\n    return null;\n  }\n\n  try {\n    const doc = new DOMParser().parseFromString(html, MIME_TYPES.html);\n\n    const content = parseHTMLTree(doc.body);\n\n    if (content.length) {\n      return { type: \"mixedContent\", value: content };\n    }\n  } catch (error: any) {\n    console.error(`error in parseHTMLFromPaste: ${error.message}`);\n  }\n\n  return null;\n};\n\n/**\n * Reads OS clipboard programmatically. May not work on all browsers.\n * Will prompt user for permission if not granted.\n */\nexport const readSystemClipboard = async () => {\n  const types: { [key in AllowedPasteMimeTypes]?: string | File } = {};\n\n  let clipboardItems: ClipboardItems;\n\n  try {\n    clipboardItems = await navigator.clipboard?.read();\n  } catch (error: any) {\n    try {\n      if (navigator.clipboard?.readText) {\n        console.warn(\n          `navigator.clipboard.readText() failed (${error.message}). Failling back to navigator.clipboard.read()`,\n        );\n        const readText = await navigator.clipboard?.readText();\n        if (readText) {\n          return { [MIME_TYPES.text]: readText };\n        }\n      }\n    } catch (error: any) {\n      // @ts-ignore\n      if (navigator.clipboard?.read) {\n        console.warn(\n          `navigator.clipboard.readText() failed (${error.message}). Failling back to navigator.clipboard.read()`,\n        );\n      } else {\n        if (error.name === \"DataError\") {\n          console.warn(\n            `navigator.clipboard.read() error, clipboard is probably empty: ${error.message}`,\n          );\n          return types;\n        }\n\n        throw error;\n      }\n    }\n    throw error;\n  }\n\n  for (const item of clipboardItems) {\n    for (const type of item.types) {\n      if (!isMemberOf(ALLOWED_PASTE_MIME_TYPES, type)) {\n        continue;\n      }\n      try {\n        if (type === MIME_TYPES.text || type === MIME_TYPES.html) {\n          types[type] = await (await item.getType(type)).text();\n        } else if (isSupportedImageFileType(type)) {\n          const imageBlob = await item.getType(type);\n          const file = createFile(imageBlob, type, undefined);\n          types[type] = file;\n        } else {\n          throw new ExcalidrawError(`Unsupported clipboard type: ${type}`);\n        }\n      } catch (error: any) {\n        console.warn(\n          error instanceof ExcalidrawError\n            ? error.message\n            : `Cannot retrieve ${type} from clipboardItem: ${error.message}`,\n        );\n      }\n    }\n  }\n\n  if (Object.keys(types).length === 0) {\n    console.warn(\"No clipboard data found from clipboard.read().\");\n    return types;\n  }\n\n  return types;\n};\n\n/**\n * Parses \"paste\" ClipboardEvent.\n */\nconst parseClipboardEventTextData = async (\n  event: ClipboardEvent,\n  isPlainPaste = false,\n): Promise<ParsedClipboardEventTextData> => {\n  try {\n    const mixedContent = !isPlainPaste && event && maybeParseHTMLPaste(event);\n\n    if (mixedContent) {\n      if (mixedContent.value.every((item) => item.type === \"text\")) {\n        return {\n          type: \"text\",\n          value:\n            event.clipboardData?.getData(MIME_TYPES.text) ||\n            mixedContent.value\n              .map((item) => item.value)\n              .join(\"\\n\")\n              .trim(),\n        };\n      }\n\n      return mixedContent;\n    }\n\n    const text = event.clipboardData?.getData(MIME_TYPES.text);\n\n    return { type: \"text\", value: (text || \"\").trim() };\n  } catch {\n    return { type: \"text\", value: \"\" };\n  }\n};\n\n/**\n * Attempts to parse clipboard event.\n */\nexport const parseClipboard = async (\n  event: ClipboardEvent,\n  isPlainPaste = false,\n): Promise<ClipboardData> => {\n  const parsedEventData = await parseClipboardEventTextData(\n    event,\n    isPlainPaste,\n  );\n\n  if (parsedEventData.type === \"mixedContent\") {\n    return {\n      mixedContent: parsedEventData.value,\n    };\n  }\n\n  try {\n    // if system clipboard contains spreadsheet, use it even though it's\n    // technically possible it's staler than in-app clipboard\n    const spreadsheetResult =\n      !isPlainPaste && parsePotentialSpreadsheet(parsedEventData.value);\n\n    if (spreadsheetResult) {\n      return spreadsheetResult;\n    }\n  } catch (error: any) {\n    console.error(error);\n  }\n\n  try {\n    const systemClipboardData = JSON.parse(parsedEventData.value);\n    const programmaticAPI =\n      systemClipboardData.type === EXPORT_DATA_TYPES.excalidrawClipboardWithAPI;\n    if (clipboardContainsElements(systemClipboardData)) {\n      return {\n        elements: systemClipboardData.elements,\n        files: systemClipboardData.files,\n        text: isPlainPaste\n          ? JSON.stringify(systemClipboardData.elements, null, 2)\n          : undefined,\n        programmaticAPI,\n      };\n    }\n  } catch {}\n\n  return { text: parsedEventData.value };\n};\n\nexport const copyBlobToClipboardAsPng = async (blob: Blob | Promise<Blob>) => {\n  try {\n    // in Safari so far we need to construct the ClipboardItem synchronously\n    // (i.e. in the same tick) otherwise browser will complain for lack of\n    // user intent. Using a Promise ClipboardItem constructor solves this.\n    // https://bugs.webkit.org/show_bug.cgi?id=222262\n    //\n    // Note that Firefox (and potentially others) seems to support Promise\n    // ClipboardItem constructor, but throws on an unrelated MIME type error.\n    // So we need to await this and fallback to awaiting the blob if applicable.\n    await navigator.clipboard.write([\n      new window.ClipboardItem({\n        [MIME_TYPES.png]: blob,\n      }),\n    ]);\n  } catch (error: any) {\n    // if we're using a Promise ClipboardItem, let's try constructing\n    // with resolution value instead\n    if (isPromiseLike(blob)) {\n      await navigator.clipboard.write([\n        new window.ClipboardItem({\n          [MIME_TYPES.png]: await blob,\n        }),\n      ]);\n    } else {\n      throw error;\n    }\n  }\n};\n\nexport const copyTextToSystemClipboard = async (\n  text: string | null,\n  clipboardEvent?: ClipboardEvent | null,\n) => {\n  // (1) first try using Async Clipboard API\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      // not focused\n      await navigator.clipboard.writeText(text || \"\");\n      return;\n    } catch (error: any) {\n      console.error(error);\n    }\n  }\n\n  // (2) if fails and we have access to ClipboardEvent, use plain old setData()\n  try {\n    if (clipboardEvent) {\n      clipboardEvent.clipboardData?.setData(MIME_TYPES.text, text || \"\");\n      if (clipboardEvent.clipboardData?.getData(MIME_TYPES.text) !== text) {\n        throw new Error(\"Failed to setData on clipboardEvent\");\n      }\n      return;\n    }\n  } catch (error: any) {\n    console.error(error);\n  }\n\n  // (3) if that fails, use document.execCommand\n  if (!copyTextViaExecCommand(text)) {\n    throw new Error(\"Error copying to clipboard.\");\n  }\n};\n\n// adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\nconst copyTextViaExecCommand = (text: string | null) => {\n  // execCommand doesn't allow copying empty strings, so if we're\n  // clearing clipboard using this API, we must copy at least an empty char\n  if (!text) {\n    text = \" \";\n  }\n\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const textarea = document.createElement(\"textarea\");\n\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`;\n  // Prevent zooming on iOS\n  textarea.style.fontSize = \"12pt\";\n\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n\n  document.body.appendChild(textarea);\n\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n\n    success = document.execCommand(\"copy\");\n  } catch (error: any) {\n    console.error(error);\n  }\n\n  textarea.remove();\n\n  return success;\n};\n",
    "import { pointFrom } from \"@excalidraw/math\";\n\nimport {\n  COLOR_PALETTE,\n  DEFAULT_CHART_COLOR_INDEX,\n  getAllColorsSpecificShade,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  VERTICAL_ALIGN,\n  randomId,\n  isDevEnv,\n} from \"@excalidraw/common\";\n\nimport {\n  newTextElement,\n  newLinearElement,\n  newElement,\n} from \"@excalidraw/element\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nexport type ChartElements = readonly NonDeletedExcalidrawElement[];\n\nconst BAR_WIDTH = 32;\nconst BAR_GAP = 12;\nconst BAR_HEIGHT = 256;\nconst GRID_OPACITY = 50;\n\nexport interface Spreadsheet {\n  title: string | null;\n  labels: string[] | null;\n  values: number[];\n}\n\nexport const NOT_SPREADSHEET = \"NOT_SPREADSHEET\";\nexport const VALID_SPREADSHEET = \"VALID_SPREADSHEET\";\n\ntype ParseSpreadsheetResult =\n  | { type: typeof NOT_SPREADSHEET; reason: string }\n  | { type: typeof VALID_SPREADSHEET; spreadsheet: Spreadsheet };\n\n/**\n * @private exported for testing\n */\nexport const tryParseNumber = (s: string): number | null => {\n  const match = /^([-+]?)[$€£¥₩]?([-+]?)([\\d.,]+)[%]?$/.exec(s);\n  if (!match) {\n    return null;\n  }\n  return parseFloat(`${(match[1] || match[2]) + match[3]}`.replace(/,/g, \"\"));\n};\n\nconst isNumericColumn = (lines: string[][], columnIndex: number) =>\n  lines.slice(1).every((line) => tryParseNumber(line[columnIndex]) !== null);\n\n/**\n * @private exported for testing\n */\nexport const tryParseCells = (cells: string[][]): ParseSpreadsheetResult => {\n  const numCols = cells[0].length;\n\n  if (numCols > 2) {\n    return { type: NOT_SPREADSHEET, reason: \"More than 2 columns\" };\n  }\n\n  if (numCols === 1) {\n    if (!isNumericColumn(cells, 0)) {\n      return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n    }\n\n    const hasHeader = tryParseNumber(cells[0][0]) === null;\n    const values = (hasHeader ? cells.slice(1) : cells).map((line) =>\n      tryParseNumber(line[0]),\n    );\n\n    if (values.length < 2) {\n      return { type: NOT_SPREADSHEET, reason: \"Less than two rows\" };\n    }\n\n    return {\n      type: VALID_SPREADSHEET,\n      spreadsheet: {\n        title: hasHeader ? cells[0][0] : null,\n        labels: null,\n        values: values as number[],\n      },\n    };\n  }\n\n  const labelColumnNumeric = isNumericColumn(cells, 0);\n  const valueColumnNumeric = isNumericColumn(cells, 1);\n\n  if (!labelColumnNumeric && !valueColumnNumeric) {\n    return { type: NOT_SPREADSHEET, reason: \"Value is not numeric\" };\n  }\n\n  const [labelColumnIndex, valueColumnIndex] = valueColumnNumeric\n    ? [0, 1]\n    : [1, 0];\n  const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;\n  const rows = hasHeader ? cells.slice(1) : cells;\n\n  if (rows.length < 2) {\n    return { type: NOT_SPREADSHEET, reason: \"Less than 2 rows\" };\n  }\n\n  return {\n    type: VALID_SPREADSHEET,\n    spreadsheet: {\n      title: hasHeader ? cells[0][valueColumnIndex] : null,\n      labels: rows.map((row) => row[labelColumnIndex]),\n      values: rows.map((row) => tryParseNumber(row[valueColumnIndex])!),\n    },\n  };\n};\n\nconst transposeCells = (cells: string[][]) => {\n  const nextCells: string[][] = [];\n  for (let col = 0; col < cells[0].length; col++) {\n    const nextCellRow: string[] = [];\n    for (let row = 0; row < cells.length; row++) {\n      nextCellRow.push(cells[row][col]);\n    }\n    nextCells.push(nextCellRow);\n  }\n  return nextCells;\n};\n\nexport const tryParseSpreadsheet = (text: string): ParseSpreadsheetResult => {\n  // Copy/paste from excel, spreadsheets, tsv, csv.\n  // For now we only accept 2 columns with an optional header\n\n  // Check for tab separated values\n  let lines = text\n    .trim()\n    .split(\"\\n\")\n    .map((line) => line.trim().split(\"\\t\"));\n\n  // Check for comma separated files\n  if (lines.length && lines[0].length !== 2) {\n    lines = text\n      .trim()\n      .split(\"\\n\")\n      .map((line) => line.trim().split(\",\"));\n  }\n\n  if (lines.length === 0) {\n    return { type: NOT_SPREADSHEET, reason: \"No values\" };\n  }\n\n  const numColsFirstLine = lines[0].length;\n  const isSpreadsheet = lines.every((line) => line.length === numColsFirstLine);\n\n  if (!isSpreadsheet) {\n    return {\n      type: NOT_SPREADSHEET,\n      reason: \"All rows don't have same number of columns\",\n    };\n  }\n\n  const result = tryParseCells(lines);\n  if (result.type !== VALID_SPREADSHEET) {\n    const transposedResults = tryParseCells(transposeCells(lines));\n    if (transposedResults.type === VALID_SPREADSHEET) {\n      return transposedResults;\n    }\n  }\n  return result;\n};\n\nconst bgColors = getAllColorsSpecificShade(DEFAULT_CHART_COLOR_INDEX);\n\n// Put all the common properties here so when the whole chart is selected\n// the properties dialog shows the correct selected values\nconst commonProps = {\n  fillStyle: \"hachure\",\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontSize: DEFAULT_FONT_SIZE,\n  opacity: 100,\n  roughness: 1,\n  strokeColor: COLOR_PALETTE.black,\n  roundness: null,\n  strokeStyle: \"solid\",\n  strokeWidth: 1,\n  verticalAlign: VERTICAL_ALIGN.MIDDLE,\n  locked: false,\n} as const;\n\nconst getChartDimensions = (spreadsheet: Spreadsheet) => {\n  const chartWidth =\n    (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;\n  const chartHeight = BAR_HEIGHT + BAR_GAP * 2;\n  return { chartWidth, chartHeight };\n};\n\nconst chartXLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  return (\n    spreadsheet.labels?.map((label, index) => {\n      return newTextElement({\n        groupIds: [groupId],\n        backgroundColor,\n        ...commonProps,\n        text: label.length > 8 ? `${label.slice(0, 5)}...` : label,\n        x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,\n        y: y + BAR_GAP / 2,\n        width: BAR_WIDTH,\n        angle: 5.87 as Radians,\n        fontSize: 16,\n        textAlign: \"center\",\n        verticalAlign: \"top\",\n      });\n    }) || []\n  );\n};\n\nconst chartYLabels = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const minYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_GAP,\n    text: \"0\",\n    textAlign: \"right\",\n  });\n\n  const maxYLabel = newTextElement({\n    groupIds: [groupId],\n    backgroundColor,\n    ...commonProps,\n    x: x - BAR_GAP,\n    y: y - BAR_HEIGHT - minYLabel.height / 2,\n    text: Math.max(...spreadsheet.values).toLocaleString(),\n    textAlign: \"right\",\n  });\n\n  return [minYLabel, maxYLabel];\n};\n\nconst chartLines = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);\n  const xLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    width: chartWidth,\n    points: [pointFrom(0, 0), pointFrom(chartWidth, 0)],\n  });\n\n  const yLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y,\n    height: chartHeight,\n    points: [pointFrom(0, 0), pointFrom(0, -chartHeight)],\n  });\n\n  const maxLine = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x,\n    y: y - BAR_HEIGHT - BAR_GAP,\n    strokeStyle: \"dotted\",\n    width: chartWidth,\n    opacity: GRID_OPACITY,\n    points: [pointFrom(0, 0), pointFrom(chartWidth, 0)],\n  });\n\n  return [xLine, yLine, maxLine];\n};\n\n// For the maths behind it https://excalidraw.com/#json=6320864370884608,O_5xfD-Agh32tytHpRJx1g\nconst chartBaseElements = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n  groupId: string,\n  backgroundColor: string,\n  debug?: boolean,\n): ChartElements => {\n  const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);\n\n  const title = spreadsheet.title\n    ? newTextElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        text: spreadsheet.title,\n        x: x + chartWidth / 2,\n        y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,\n        roundness: null,\n        textAlign: \"center\",\n      })\n    : null;\n\n  const debugRect = debug\n    ? newElement({\n        backgroundColor,\n        groupIds: [groupId],\n        ...commonProps,\n        type: \"rectangle\",\n        x,\n        y: y - chartHeight,\n        width: chartWidth,\n        height: chartHeight,\n        strokeColor: COLOR_PALETTE.black,\n        fillStyle: \"solid\",\n        opacity: 6,\n      })\n    : null;\n\n  return [\n    ...(debugRect ? [debugRect] : []),\n    ...(title ? [title] : []),\n    ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor),\n    ...chartLines(spreadsheet, x, y, groupId, backgroundColor),\n  ];\n};\n\nconst chartTypeBar = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  const bars = spreadsheet.values.map((value, index) => {\n    const barHeight = (value / max) * BAR_HEIGHT;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"rectangle\",\n      x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,\n      y: y - barHeight - BAR_GAP,\n      width: BAR_WIDTH,\n      height: barHeight,\n    });\n  });\n\n  return [\n    ...bars,\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      isDevEnv(),\n    ),\n  ];\n};\n\nconst chartTypeLine = (\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  const max = Math.max(...spreadsheet.values);\n  const groupId = randomId();\n  const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];\n\n  let index = 0;\n  const points = [];\n  for (const value of spreadsheet.values) {\n    const cx = index * (BAR_WIDTH + BAR_GAP);\n    const cy = -(value / max) * BAR_HEIGHT;\n    points.push([cx, cy]);\n    index++;\n  }\n\n  const maxX = Math.max(...points.map((element) => element[0]));\n  const maxY = Math.max(...points.map((element) => element[1]));\n  const minX = Math.min(...points.map((element) => element[0]));\n  const minY = Math.min(...points.map((element) => element[1]));\n\n  const line = newLinearElement({\n    backgroundColor,\n    groupIds: [groupId],\n    ...commonProps,\n    type: \"line\",\n    x: x + BAR_GAP + BAR_WIDTH / 2,\n    y: y - BAR_GAP,\n    height: maxY - minY,\n    width: maxX - minX,\n    strokeWidth: 2,\n    points: points as any,\n  });\n\n  const dots = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;\n    return newElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      fillStyle: \"solid\",\n      strokeWidth: 2,\n      type: \"ellipse\",\n      x: x + cx + BAR_WIDTH / 2,\n      y: y + cy - BAR_GAP * 2,\n      width: BAR_GAP,\n      height: BAR_GAP,\n    });\n  });\n\n  const lines = spreadsheet.values.map((value, index) => {\n    const cx = index * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;\n    const cy = (value / max) * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;\n    return newLinearElement({\n      backgroundColor,\n      groupIds: [groupId],\n      ...commonProps,\n      type: \"line\",\n      x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,\n      y: y - cy,\n      height: cy,\n      strokeStyle: \"dotted\",\n      opacity: GRID_OPACITY,\n      points: [pointFrom(0, 0), pointFrom(0, cy)],\n    });\n  });\n\n  return [\n    ...chartBaseElements(\n      spreadsheet,\n      x,\n      y,\n      groupId,\n      backgroundColor,\n      isDevEnv(),\n    ),\n    line,\n    ...lines,\n    ...dots,\n  ];\n};\n\nexport const renderSpreadsheet = (\n  chartType: string,\n  spreadsheet: Spreadsheet,\n  x: number,\n  y: number,\n): ChartElements => {\n  if (chartType === \"line\") {\n    return chartTypeLine(spreadsheet, x, y);\n  }\n  return chartTypeBar(spreadsheet, x, y);\n};\n",
    "import type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { getFileHandleType, isImageFileHandleType } from \"./blob\";\n\nimport { exportCanvas, prepareElementsForExport } from \".\";\n\nimport type { AppState, BinaryFiles } from \"../types\";\n\nexport const resaveAsImageWithScene = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  files: BinaryFiles,\n  name: string,\n) => {\n  const { exportBackground, viewBackgroundColor, fileHandle } = appState;\n\n  const fileHandleType = getFileHandleType(fileHandle);\n\n  if (!fileHandle || !isImageFileHandleType(fileHandleType)) {\n    throw new Error(\n      \"fileHandle should exist and should be of type svg or png when resaving\",\n    );\n  }\n  appState = {\n    ...appState,\n    exportEmbedScene: true,\n  };\n\n  const { exportedElements, exportingFrame } = prepareElementsForExport(\n    elements,\n    appState,\n    false,\n  );\n\n  await exportCanvas(fileHandleType, exportedElements, appState, files, {\n    exportBackground,\n    viewBackgroundColor,\n    name,\n    fileHandle,\n    exportingFrame,\n  });\n\n  return { fileHandle };\n};\n",
    "import {\n  DEFAULT_FONT_SIZE,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n  CODES,\n  KEYS,\n  getLineHeight,\n} from \"@excalidraw/common\";\n\nimport { newElementWith } from \"@excalidraw/element\";\n\nimport {\n  hasBoundTextElement,\n  canApplyRoundnessTypeToElement,\n  getDefaultRoundnessTypeForElement,\n  isFrameLikeElement,\n  isArrowElement,\n  isExcalidrawElement,\n  isTextElement,\n} from \"@excalidraw/element\";\n\nimport {\n  getBoundTextElement,\n  redrawTextBoundingBox,\n} from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ExcalidrawTextElement } from \"@excalidraw/element/types\";\n\nimport { paintIcon } from \"../components/icons\";\n\nimport { t } from \"../i18n\";\nimport { getSelectedElements } from \"../scene\";\n\nimport { register } from \"./register\";\n\n// `copiedStyles` is exported only for tests.\nexport let copiedStyles: string = \"{}\";\n\nexport const actionCopyStyles = register({\n  name: \"copyStyles\",\n  label: \"labels.copyStyles\",\n  icon: paintIcon,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, formData, app) => {\n    const elementsCopied = [];\n    const element = elements.find((el) => appState.selectedElementIds[el.id]);\n    elementsCopied.push(element);\n    if (element && hasBoundTextElement(element)) {\n      const boundTextElement = getBoundTextElement(\n        element,\n        app.scene.getNonDeletedElementsMap(),\n      );\n      elementsCopied.push(boundTextElement);\n    }\n    if (element) {\n      copiedStyles = JSON.stringify(elementsCopied);\n    }\n    return {\n      appState: {\n        ...appState,\n        toast: { message: t(\"toast.copyStyles\") },\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.C,\n});\n\nexport const actionPasteStyles = register({\n  name: \"pasteStyles\",\n  label: \"labels.pasteStyles\",\n  icon: paintIcon,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, formData, app) => {\n    const elementsCopied = JSON.parse(copiedStyles);\n    const pastedElement = elementsCopied[0];\n    const boundTextElement = elementsCopied[1];\n    if (!isExcalidrawElement(pastedElement)) {\n      return { elements, captureUpdate: CaptureUpdateAction.EVENTUALLY };\n    }\n\n    const selectedElements = getSelectedElements(elements, appState, {\n      includeBoundTextElement: true,\n    });\n    const selectedElementIds = selectedElements.map((element) => element.id);\n    return {\n      elements: elements.map((element) => {\n        if (selectedElementIds.includes(element.id)) {\n          let elementStylesToCopyFrom = pastedElement;\n          if (isTextElement(element) && element.containerId) {\n            elementStylesToCopyFrom = boundTextElement;\n          }\n          if (!elementStylesToCopyFrom) {\n            return element;\n          }\n          let newElement = newElementWith(element, {\n            backgroundColor: elementStylesToCopyFrom?.backgroundColor,\n            strokeWidth: elementStylesToCopyFrom?.strokeWidth,\n            strokeColor: elementStylesToCopyFrom?.strokeColor,\n            strokeStyle: elementStylesToCopyFrom?.strokeStyle,\n            fillStyle: elementStylesToCopyFrom?.fillStyle,\n            opacity: elementStylesToCopyFrom?.opacity,\n            roughness: elementStylesToCopyFrom?.roughness,\n            roundness: elementStylesToCopyFrom.roundness\n              ? canApplyRoundnessTypeToElement(\n                  elementStylesToCopyFrom.roundness.type,\n                  element,\n                )\n                ? elementStylesToCopyFrom.roundness\n                : getDefaultRoundnessTypeForElement(element)\n              : null,\n          });\n\n          if (isTextElement(newElement)) {\n            const fontSize =\n              (elementStylesToCopyFrom as ExcalidrawTextElement).fontSize ||\n              DEFAULT_FONT_SIZE;\n            const fontFamily =\n              (elementStylesToCopyFrom as ExcalidrawTextElement).fontFamily ||\n              DEFAULT_FONT_FAMILY;\n            newElement = newElementWith(newElement, {\n              fontSize,\n              fontFamily,\n              textAlign:\n                (elementStylesToCopyFrom as ExcalidrawTextElement).textAlign ||\n                DEFAULT_TEXT_ALIGN,\n              lineHeight:\n                (elementStylesToCopyFrom as ExcalidrawTextElement).lineHeight ||\n                getLineHeight(fontFamily),\n            });\n            let container = null;\n            if (newElement.containerId) {\n              container =\n                selectedElements.find(\n                  (element) =>\n                    isTextElement(newElement) &&\n                    element.id === newElement.containerId,\n                ) || null;\n            }\n\n            redrawTextBoundingBox(newElement, container, app.scene);\n          }\n\n          if (\n            newElement.type === \"arrow\" &&\n            isArrowElement(elementStylesToCopyFrom)\n          ) {\n            newElement = newElementWith(newElement, {\n              startArrowhead: elementStylesToCopyFrom.startArrowhead,\n              endArrowhead: elementStylesToCopyFrom.endArrowhead,\n            });\n          }\n\n          if (isFrameLikeElement(element)) {\n            newElement = newElementWith(newElement, {\n              roundness: null,\n              backgroundColor: \"transparent\",\n            });\n          }\n\n          return newElement;\n        }\n        return element;\n      }),\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V,\n});\n",
    "import { KEYS } from \"@excalidraw/common\";\n\nimport { getNonDeletedElements } from \"@excalidraw/element\";\n\nimport { showSelectedShapeActions } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { ToolButton } from \"../components/ToolButton\";\nimport { HamburgerMenuIcon, HelpIconThin, palette } from \"../components/icons\";\nimport { t } from \"../i18n\";\n\nimport { register } from \"./register\";\n\nexport const actionToggleCanvasMenu = register({\n  name: \"toggleCanvasMenu\",\n  label: \"buttons.menu\",\n  trackEvent: { category: \"menu\" },\n  perform: (_, appState) => ({\n    appState: {\n      ...appState,\n      openMenu: appState.openMenu === \"canvas\" ? null : \"canvas\",\n    },\n    captureUpdate: CaptureUpdateAction.EVENTUALLY,\n  }),\n  PanelComponent: ({ appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      icon={HamburgerMenuIcon}\n      aria-label={t(\"buttons.menu\")}\n      onClick={updateData}\n      selected={appState.openMenu === \"canvas\"}\n    />\n  ),\n});\n\nexport const actionToggleEditMenu = register({\n  name: \"toggleEditMenu\",\n  label: \"buttons.edit\",\n  trackEvent: { category: \"menu\" },\n  perform: (_elements, appState) => ({\n    appState: {\n      ...appState,\n      openMenu: appState.openMenu === \"shape\" ? null : \"shape\",\n    },\n    captureUpdate: CaptureUpdateAction.EVENTUALLY,\n  }),\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      visible={showSelectedShapeActions(\n        appState,\n        getNonDeletedElements(elements),\n      )}\n      type=\"button\"\n      icon={palette}\n      aria-label={t(\"buttons.edit\")}\n      onClick={updateData}\n      selected={appState.openMenu === \"shape\"}\n    />\n  ),\n});\n\nexport const actionShortcuts = register({\n  name: \"toggleShortcuts\",\n  label: \"welcomeScreen.defaults.helpHint\",\n  icon: HelpIconThin,\n  viewMode: true,\n  trackEvent: { category: \"menu\", action: \"toggleHelpDialog\" },\n  perform: (_elements, appState, _, { focusContainer }) => {\n    if (appState.openDialog?.name === \"help\") {\n      focusContainer();\n    }\n    return {\n      appState: {\n        ...appState,\n        openDialog:\n          appState.openDialog?.name === \"help\"\n            ? null\n            : {\n                name: \"help\",\n              },\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  keyTest: (event) => event.key === KEYS.QUESTION_MARK,\n});\n",
    "import { getNonDeletedElements } from \"@excalidraw/element\";\n\nimport { newElementWith } from \"@excalidraw/element\";\n\nimport { isBoundToContainer } from \"@excalidraw/element\";\n\nimport {\n  frameAndChildrenSelectedTogether,\n  getElementsInResizingFrame,\n  getFrameLikeElements,\n  getRootElements,\n  groupByFrameLikes,\n  removeElementsFromFrame,\n  replaceAllElementsInFrame,\n} from \"@excalidraw/element\";\n\nimport { KEYS, randomId, arrayToMap, getShortcutKey } from \"@excalidraw/common\";\n\nimport {\n  getSelectedGroupIds,\n  selectGroup,\n  selectGroupsForSelectedElements,\n  getElementsInGroup,\n  addToGroup,\n  removeFromSelectedGroups,\n  isElementInGroup,\n} from \"@excalidraw/element\";\n\nimport { syncMovedIndices } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  OrderedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport { ToolButton } from \"../components/ToolButton\";\nimport { UngroupIcon, GroupIcon } from \"../components/icons\";\n\nimport { t } from \"../i18n\";\n\nimport { isSomeElementSelected } from \"../scene\";\n\nimport { register } from \"./register\";\n\nimport type { AppClassProperties, AppState } from \"../types\";\n\nconst allElementsInSameGroup = (elements: readonly ExcalidrawElement[]) => {\n  if (elements.length >= 2) {\n    const groupIds = elements[0].groupIds;\n    for (const groupId of groupIds) {\n      if (\n        elements.reduce(\n          (acc, element) => acc && isElementInGroup(element, groupId),\n          true,\n        )\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nconst enableActionGroup = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  app: AppClassProperties,\n) => {\n  const selectedElements = app.scene.getSelectedElements({\n    selectedElementIds: appState.selectedElementIds,\n    includeBoundTextElement: true,\n  });\n\n  return (\n    selectedElements.length >= 2 &&\n    !allElementsInSameGroup(selectedElements) &&\n    !frameAndChildrenSelectedTogether(selectedElements)\n  );\n};\n\nexport const actionGroup = register({\n  name: \"group\",\n  label: \"labels.group\",\n  icon: (appState) => <GroupIcon theme={appState.theme} />,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = getRootElements(\n      app.scene.getSelectedElements({\n        selectedElementIds: appState.selectedElementIds,\n        includeBoundTextElement: true,\n      }),\n    );\n    if (selectedElements.length < 2) {\n      // nothing to group\n      return {\n        appState,\n        elements,\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    }\n    // if everything is already grouped into 1 group, there is nothing to do\n    const selectedGroupIds = getSelectedGroupIds(appState);\n    if (selectedGroupIds.length === 1) {\n      const selectedGroupId = selectedGroupIds[0];\n      const elementIdsInGroup = new Set(\n        getElementsInGroup(elements, selectedGroupId).map(\n          (element) => element.id,\n        ),\n      );\n      const selectedElementIds = new Set(\n        selectedElements.map((element) => element.id),\n      );\n      const combinedSet = new Set([\n        ...Array.from(elementIdsInGroup),\n        ...Array.from(selectedElementIds),\n      ]);\n      if (combinedSet.size === elementIdsInGroup.size) {\n        // no incremental ids in the selected ids\n        return {\n          appState,\n          elements,\n          captureUpdate: CaptureUpdateAction.EVENTUALLY,\n        };\n      }\n    }\n\n    let nextElements = [...elements];\n\n    // this includes the case where we are grouping elements inside a frame\n    // and elements outside that frame\n    const groupingElementsFromDifferentFrames =\n      new Set(selectedElements.map((element) => element.frameId)).size > 1;\n    // when it happens, we want to remove elements that are in the frame\n    // and are going to be grouped from the frame (mouthful, I know)\n    if (groupingElementsFromDifferentFrames) {\n      const frameElementsMap = groupByFrameLikes(selectedElements);\n\n      frameElementsMap.forEach((elementsInFrame, frameId) => {\n        removeElementsFromFrame(\n          elementsInFrame,\n          app.scene.getNonDeletedElementsMap(),\n        );\n      });\n    }\n\n    const newGroupId = randomId();\n    const selectElementIds = arrayToMap(selectedElements);\n\n    nextElements = nextElements.map((element) => {\n      if (!selectElementIds.get(element.id)) {\n        return element;\n      }\n      return newElementWith(element, {\n        groupIds: addToGroup(\n          element.groupIds,\n          newGroupId,\n          appState.editingGroupId,\n        ),\n      });\n    });\n    // keep the z order within the group the same, but move them\n    // to the z order of the highest element in the layer stack\n    const elementsInGroup = getElementsInGroup(nextElements, newGroupId);\n    const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];\n    const lastGroupElementIndex = nextElements.lastIndexOf(\n      lastElementInGroup as OrderedExcalidrawElement,\n    );\n    const elementsAfterGroup = nextElements.slice(lastGroupElementIndex + 1);\n    const elementsBeforeGroup = nextElements\n      .slice(0, lastGroupElementIndex)\n      .filter(\n        (updatedElement) => !isElementInGroup(updatedElement, newGroupId),\n      );\n    const reorderedElements = syncMovedIndices(\n      [...elementsBeforeGroup, ...elementsInGroup, ...elementsAfterGroup],\n      arrayToMap(elementsInGroup),\n    );\n\n    return {\n      appState: {\n        ...appState,\n        ...selectGroup(\n          newGroupId,\n          { ...appState, selectedGroupIds: {} },\n          getNonDeletedElements(nextElements),\n        ),\n      },\n      elements: reorderedElements,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  predicate: (elements, appState, _, app) =>\n    enableActionGroup(elements, appState, app),\n  keyTest: (event) =>\n    !event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.key === KEYS.G,\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <ToolButton\n      hidden={!enableActionGroup(elements, appState, app)}\n      type=\"button\"\n      icon={<GroupIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.group\")} — ${getShortcutKey(\"CtrlOrCmd+G\")}`}\n      aria-label={t(\"labels.group\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    ></ToolButton>\n  ),\n});\n\nexport const actionUngroup = register({\n  name: \"ungroup\",\n  label: \"labels.ungroup\",\n  icon: (appState) => <UngroupIcon theme={appState.theme} />,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, _, app) => {\n    const groupIds = getSelectedGroupIds(appState);\n    const elementsMap = arrayToMap(elements);\n\n    if (groupIds.length === 0) {\n      return {\n        appState,\n        elements,\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    }\n\n    let nextElements = [...elements];\n\n    const boundTextElementIds: ExcalidrawTextElement[\"id\"][] = [];\n    nextElements = nextElements.map((element) => {\n      if (isBoundToContainer(element)) {\n        boundTextElementIds.push(element.id);\n      }\n      const nextGroupIds = removeFromSelectedGroups(\n        element.groupIds,\n        appState.selectedGroupIds,\n      );\n      if (nextGroupIds.length === element.groupIds.length) {\n        return element;\n      }\n      return newElementWith(element, {\n        groupIds: nextGroupIds,\n      });\n    });\n\n    const updateAppState = selectGroupsForSelectedElements(\n      appState,\n      getNonDeletedElements(nextElements),\n      appState,\n      null,\n    );\n\n    const selectedElements = app.scene.getSelectedElements(appState);\n\n    const selectedElementFrameIds = new Set(\n      selectedElements\n        .filter((element) => element.frameId)\n        .map((element) => element.frameId!),\n    );\n\n    const targetFrames = getFrameLikeElements(elements).filter((frame) =>\n      selectedElementFrameIds.has(frame.id),\n    );\n\n    targetFrames.forEach((frame) => {\n      if (frame) {\n        nextElements = replaceAllElementsInFrame(\n          nextElements,\n          getElementsInResizingFrame(\n            nextElements,\n            frame,\n            appState,\n            elementsMap,\n          ),\n          frame,\n          app,\n        );\n      }\n    });\n\n    // remove binded text elements from selection\n    updateAppState.selectedElementIds = Object.entries(\n      updateAppState.selectedElementIds,\n    ).reduce(\n      (acc: { [key: ExcalidrawElement[\"id\"]]: true }, [id, selected]) => {\n        if (selected && !boundTextElementIds.includes(id)) {\n          acc[id] = true;\n        }\n        return acc;\n      },\n      {},\n    );\n\n    return {\n      appState: { ...appState, ...updateAppState },\n      elements: nextElements,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    event.shiftKey &&\n    event[KEYS.CTRL_OR_CMD] &&\n    event.key === KEYS.G.toUpperCase(),\n  predicate: (elements, appState) => getSelectedGroupIds(appState).length > 0,\n\n  PanelComponent: ({ elements, appState, updateData }) => (\n    <ToolButton\n      type=\"button\"\n      hidden={getSelectedGroupIds(appState).length === 0}\n      icon={<UngroupIcon theme={appState.theme} />}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.ungroup\")} — ${getShortcutKey(\"CtrlOrCmd+Shift+G\")}`}\n      aria-label={t(\"labels.ungroup\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    ></ToolButton>\n  ),\n});\n",
    "import clsx from \"clsx\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { getClientColor } from \"../clients\";\nimport { Avatar } from \"../components/Avatar\";\nimport {\n  eyeIcon,\n  microphoneIcon,\n  microphoneMutedIcon,\n} from \"../components/icons\";\nimport { t } from \"../i18n\";\n\nimport { register } from \"./register\";\n\nimport type { GoToCollaboratorComponentProps } from \"../components/UserList\";\nimport type { Collaborator } from \"../types\";\n\nexport const actionGoToCollaborator = register({\n  name: \"goToCollaborator\",\n  label: \"Go to a collaborator\",\n  viewMode: true,\n  trackEvent: { category: \"collab\" },\n  perform: (_elements, appState, collaborator: Collaborator) => {\n    if (\n      !collaborator.socketId ||\n      appState.userToFollow?.socketId === collaborator.socketId ||\n      collaborator.isCurrentUser\n    ) {\n      return {\n        appState: {\n          ...appState,\n          userToFollow: null,\n        },\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    }\n\n    return {\n      appState: {\n        ...appState,\n        userToFollow: {\n          socketId: collaborator.socketId,\n          username: collaborator.username || \"\",\n        },\n        // Close mobile menu\n        openMenu: appState.openMenu === \"canvas\" ? null : appState.openMenu,\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  PanelComponent: ({ updateData, data, appState }) => {\n    const { socketId, collaborator, withName, isBeingFollowed } =\n      data as GoToCollaboratorComponentProps;\n\n    const background = getClientColor(socketId, collaborator);\n\n    const statusClassNames = clsx({\n      \"is-followed\": isBeingFollowed,\n      \"is-current-user\": collaborator.isCurrentUser === true,\n      \"is-speaking\": collaborator.isSpeaking,\n      \"is-in-call\": collaborator.isInCall,\n      \"is-muted\": collaborator.isMuted,\n    });\n\n    const statusIconJSX = collaborator.isInCall ? (\n      collaborator.isSpeaking ? (\n        <div\n          className=\"UserList__collaborator-status-icon-speaking-indicator\"\n          title={t(\"userList.hint.isSpeaking\")}\n        >\n          <div />\n          <div />\n          <div />\n        </div>\n      ) : collaborator.isMuted ? (\n        <div\n          className=\"UserList__collaborator-status-icon-microphone-muted\"\n          title={t(\"userList.hint.micMuted\")}\n        >\n          {microphoneMutedIcon}\n        </div>\n      ) : (\n        <div title={t(\"userList.hint.inCall\")}>{microphoneIcon}</div>\n      )\n    ) : null;\n\n    return withName ? (\n      <div\n        className={`dropdown-menu-item dropdown-menu-item-base UserList__collaborator ${statusClassNames}`}\n        style={{ [`--avatar-size` as any]: \"1.5rem\" }}\n        onClick={() => updateData<Collaborator>(collaborator)}\n      >\n        <Avatar\n          color={background}\n          onClick={() => {}}\n          name={collaborator.username || \"\"}\n          src={collaborator.avatarUrl}\n          className={statusClassNames}\n        />\n        <div className=\"UserList__collaborator-name\">\n          {collaborator.username}\n        </div>\n        <div className=\"UserList__collaborator-status-icons\" aria-hidden>\n          {isBeingFollowed && (\n            <div\n              className=\"UserList__collaborator-status-icon-is-followed\"\n              title={t(\"userList.hint.followStatus\")}\n            >\n              {eyeIcon}\n            </div>\n          )}\n          {statusIconJSX}\n        </div>\n      </div>\n    ) : (\n      <div\n        className={`UserList__collaborator UserList__collaborator--avatar-only ${statusClassNames}`}\n      >\n        <Avatar\n          color={background}\n          onClick={() => {\n            updateData(collaborator);\n          }}\n          name={collaborator.username || \"\"}\n          src={collaborator.avatarUrl}\n          className={statusClassNames}\n        />\n        {statusIconJSX && (\n          <div className=\"UserList__collaborator-status-icon\">\n            {statusIconJSX}\n          </div>\n        )}\n      </div>\n    );\n  },\n});\n",
    "import {\n  COLOR_CHARCOAL_BLACK,\n  COLOR_VOICE_CALL,\n  COLOR_WHITE,\n  THEME,\n  UserIdleState,\n} from \"@excalidraw/common\";\n\nimport { roundRect } from \"./renderer/roundRect\";\n\nimport type { InteractiveCanvasRenderConfig } from \"./scene/types\";\nimport type {\n  Collaborator,\n  InteractiveCanvasAppState,\n  SocketId,\n} from \"./types\";\n\nfunction hashToInteger(id: string) {\n  let hash = 0;\n  if (id.length === 0) {\n    return hash;\n  }\n  for (let i = 0; i < id.length; i++) {\n    const char = id.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n  }\n  return hash;\n}\n\nexport const getClientColor = (\n  socketId: SocketId,\n  collaborator: Collaborator | undefined,\n) => {\n  // to get more even distribution in case `id` is not uniformly distributed to\n  // begin with, we hash it\n  const hash = Math.abs(hashToInteger(collaborator?.id || socketId));\n  // we want to get a multiple of 10 number in the range of 0-360 (in other\n  // words a hue value of step size 10). There are 37 such values including 0.\n  const hue = (hash % 37) * 10;\n  const saturation = 100;\n  const lightness = 83;\n\n  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;\n};\n\n/**\n * returns first char, capitalized\n */\nexport const getNameInitial = (name?: string | null) => {\n  // first char can be a surrogate pair, hence using codePointAt\n  const firstCodePoint = name?.trim()?.codePointAt(0);\n  return (\n    firstCodePoint ? String.fromCodePoint(firstCodePoint) : \"?\"\n  ).toUpperCase();\n};\n\nexport const renderRemoteCursors = ({\n  context,\n  renderConfig,\n  appState,\n  normalizedWidth,\n  normalizedHeight,\n}: {\n  context: CanvasRenderingContext2D;\n  renderConfig: InteractiveCanvasRenderConfig;\n  appState: InteractiveCanvasAppState;\n  normalizedWidth: number;\n  normalizedHeight: number;\n}) => {\n  // Paint remote pointers\n  for (const [socketId, pointer] of renderConfig.remotePointerViewportCoords) {\n    let { x, y } = pointer;\n\n    const collaborator = appState.collaborators.get(socketId);\n\n    x -= appState.offsetLeft;\n    y -= appState.offsetTop;\n\n    const width = 11;\n    const height = 14;\n\n    const isOutOfBounds =\n      x < 0 ||\n      x > normalizedWidth - width ||\n      y < 0 ||\n      y > normalizedHeight - height;\n\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedHeight - height);\n\n    const background = getClientColor(socketId, collaborator);\n\n    context.save();\n    context.strokeStyle = background;\n    context.fillStyle = background;\n\n    const userState = renderConfig.remotePointerUserStates.get(socketId);\n    const isInactive =\n      isOutOfBounds ||\n      userState === UserIdleState.IDLE ||\n      userState === UserIdleState.AWAY;\n\n    if (isInactive) {\n      context.globalAlpha = 0.3;\n    }\n\n    if (renderConfig.remotePointerButton.get(socketId) === \"down\") {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = background;\n      context.stroke();\n      context.closePath();\n    }\n\n    // TODO remove the dark theme color after we stop inverting canvas colors\n    const IS_SPEAKING_COLOR =\n      appState.theme === THEME.DARK ? \"#2f6330\" : COLOR_VOICE_CALL;\n\n    const isSpeaking = collaborator?.isSpeaking;\n\n    if (isSpeaking) {\n      // cursor outline for currently speaking user\n      context.fillStyle = IS_SPEAKING_COLOR;\n      context.strokeStyle = IS_SPEAKING_COLOR;\n      context.lineWidth = 10;\n      context.lineJoin = \"round\";\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + 0, y + 14);\n      context.lineTo(x + 4, y + 9);\n      context.lineTo(x + 11, y + 8);\n      context.closePath();\n      context.stroke();\n      context.fill();\n    }\n\n    // Background (white outline) for arrow\n    context.fillStyle = COLOR_WHITE;\n    context.strokeStyle = COLOR_WHITE;\n    context.lineWidth = 6;\n    context.lineJoin = \"round\";\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 0, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 11, y + 8);\n    context.closePath();\n    context.stroke();\n    context.fill();\n\n    // Arrow\n    context.fillStyle = background;\n    context.strokeStyle = background;\n    context.lineWidth = 2;\n    context.lineJoin = \"round\";\n    context.beginPath();\n    if (isInactive) {\n      context.moveTo(x - 1, y - 1);\n      context.lineTo(x - 1, y + 15);\n      context.lineTo(x + 5, y + 10);\n      context.lineTo(x + 12, y + 9);\n      context.closePath();\n      context.fill();\n    } else {\n      context.moveTo(x, y);\n      context.lineTo(x + 0, y + 14);\n      context.lineTo(x + 4, y + 9);\n      context.lineTo(x + 11, y + 8);\n      context.closePath();\n      context.fill();\n      context.stroke();\n    }\n\n    const username = renderConfig.remotePointerUsernames.get(socketId) || \"\";\n\n    if (!isOutOfBounds && username) {\n      context.font = \"600 12px sans-serif\"; // font has to be set before context.measureText()\n\n      const offsetX = (isSpeaking ? x + 0 : x) + width / 2;\n      const offsetY = (isSpeaking ? y + 0 : y) + height + 2;\n      const paddingHorizontal = 5;\n      const paddingVertical = 3;\n      const measure = context.measureText(username);\n      const measureHeight =\n        measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;\n      const finalHeight = Math.max(measureHeight, 12);\n\n      const boxX = offsetX - 1;\n      const boxY = offsetY - 1;\n      const boxWidth = measure.width + 2 + paddingHorizontal * 2 + 2;\n      const boxHeight = finalHeight + 2 + paddingVertical * 2 + 2;\n      if (context.roundRect) {\n        context.beginPath();\n        context.roundRect(boxX, boxY, boxWidth, boxHeight, 8);\n        context.fillStyle = background;\n        context.fill();\n        context.strokeStyle = COLOR_WHITE;\n        context.stroke();\n\n        if (isSpeaking) {\n          context.beginPath();\n          context.roundRect(boxX - 2, boxY - 2, boxWidth + 4, boxHeight + 4, 8);\n          context.strokeStyle = IS_SPEAKING_COLOR;\n          context.stroke();\n        }\n      } else {\n        roundRect(context, boxX, boxY, boxWidth, boxHeight, 8, COLOR_WHITE);\n      }\n      context.fillStyle = COLOR_CHARCOAL_BLACK;\n\n      context.fillText(\n        username,\n        offsetX + paddingHorizontal + 1,\n        offsetY +\n          paddingVertical +\n          measure.actualBoundingBoxAscent +\n          Math.floor((finalHeight - measureHeight) / 2) +\n          2,\n      );\n\n      // draw three vertical bars signalling someone is speaking\n      if (isSpeaking) {\n        context.fillStyle = IS_SPEAKING_COLOR;\n        const barheight = 8;\n        const margin = 8;\n        const gap = 5;\n        context.fillRect(\n          boxX + boxWidth + margin,\n          boxY + (boxHeight / 2 - barheight / 2),\n          2,\n          barheight,\n        );\n        context.fillRect(\n          boxX + boxWidth + margin + gap,\n          boxY + (boxHeight / 2 - (barheight * 2) / 2),\n          2,\n          barheight * 2,\n        );\n        context.fillRect(\n          boxX + boxWidth + margin + gap * 2,\n          boxY + (boxHeight / 2 - barheight / 2),\n          2,\n          barheight,\n        );\n      }\n    }\n\n    context.restore();\n    context.closePath();\n  }\n};\n",
    "/**\n * https://stackoverflow.com/a/3368118\n * Draws a rounded rectangle using the current state of the canvas.\n * @param {CanvasRenderingContext2D} context\n * @param {Number} x The top left x coordinate\n * @param {Number} y The top left y coordinate\n * @param {Number} width The width of the rectangle\n * @param {Number} height The height of the rectangle\n * @param {Number} radius The corner radius\n */\nexport const roundRect = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  radius: number,\n  strokeColor?: string,\n) => {\n  context.beginPath();\n  context.moveTo(x + radius, y);\n  context.lineTo(x + width - radius, y);\n  context.quadraticCurveTo(x + width, y, x + width, y + radius);\n  context.lineTo(x + width, y + height - radius);\n  context.quadraticCurveTo(\n    x + width,\n    y + height,\n    x + width - radius,\n    y + height,\n  );\n  context.lineTo(x + radius, y + height);\n  context.quadraticCurveTo(x, y + height, x, y + height - radius);\n  context.lineTo(x, y + radius);\n  context.quadraticCurveTo(x, y, x + radius, y);\n  context.closePath();\n  context.fill();\n  if (strokeColor) {\n    context.strokeStyle = strokeColor;\n  }\n  context.stroke();\n};\n",
    "import clsx from \"clsx\";\nimport React, { useState } from \"react\";\n\nimport { getNameInitial } from \"../clients\";\n\nimport \"./Avatar.scss\";\n\ntype AvatarProps = {\n  onClick: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;\n  color: string;\n  name: string;\n  src?: string;\n  className?: string;\n};\n\nexport const Avatar = ({\n  color,\n  onClick,\n  name,\n  src,\n  className,\n}: AvatarProps) => {\n  const shortName = getNameInitial(name);\n  const [error, setError] = useState(false);\n  const loadImg = !error && src;\n  const style = loadImg ? undefined : { background: color };\n  return (\n    <div className={clsx(\"Avatar\", className)} style={style} onClick={onClick}>\n      {loadImg ? (\n        <img\n          className=\"Avatar-img\"\n          src={src}\n          alt={shortName}\n          referrerPolicy=\"no-referrer\"\n          onError={() => setError(true)}\n        />\n      ) : (\n        shortName\n      )}\n    </div>\n  );\n};\n",
    "import { LIBRARY_DISABLED_TYPES, randomId } from \"@excalidraw/common\";\nimport { deepCopyElement } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { t } from \"../i18n\";\n\nimport { register } from \"./register\";\n\nexport const actionAddToLibrary = register({\n  name: \"addToLibrary\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    });\n\n    for (const type of LIBRARY_DISABLED_TYPES) {\n      if (selectedElements.some((element) => element.type === type)) {\n        return {\n          captureUpdate: CaptureUpdateAction.EVENTUALLY,\n          appState: {\n            ...appState,\n            errorMessage: t(`errors.libraryElementTypeError.${type}`),\n          },\n        };\n      }\n    }\n\n    return app.library\n      .getLatestLibrary()\n      .then((items) => {\n        return app.library.setLibrary([\n          {\n            id: randomId(),\n            status: \"unpublished\",\n            elements: selectedElements.map(deepCopyElement),\n            created: Date.now(),\n          },\n          ...items,\n        ]);\n      })\n      .then(() => {\n        return {\n          captureUpdate: CaptureUpdateAction.EVENTUALLY,\n          appState: {\n            ...appState,\n            toast: { message: t(\"toast.addedToLibrary\") },\n          },\n        };\n      })\n      .catch((error) => {\n        return {\n          captureUpdate: CaptureUpdateAction.EVENTUALLY,\n          appState: {\n            ...appState,\n            errorMessage: error.message,\n          },\n        };\n      });\n  },\n  label: \"labels.addToLibrary\",\n});\n",
    "import { getNonDeletedElements } from \"@excalidraw/element\";\n\nimport { isFrameLikeElement } from \"@excalidraw/element\";\n\nimport { updateFrameMembershipOfSelectedElements } from \"@excalidraw/element\";\n\nimport { KEYS, arrayToMap, getShortcutKey } from \"@excalidraw/common\";\n\nimport { alignElements } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { Alignment } from \"@excalidraw/element\";\n\nimport { ToolButton } from \"../components/ToolButton\";\nimport {\n  AlignBottomIcon,\n  AlignLeftIcon,\n  AlignRightIcon,\n  AlignTopIcon,\n  CenterHorizontallyIcon,\n  CenterVerticallyIcon,\n} from \"../components/icons\";\n\nimport { t } from \"../i18n\";\n\nimport { isSomeElementSelected } from \"../scene\";\n\nimport { register } from \"./register\";\n\nimport type { AppClassProperties, AppState, UIAppState } from \"../types\";\n\nexport const alignActionsPredicate = (\n  appState: UIAppState,\n  app: AppClassProperties,\n) => {\n  const selectedElements = app.scene.getSelectedElements(appState);\n  return (\n    selectedElements.length > 1 &&\n    // TODO enable aligning frames when implemented properly\n    !selectedElements.some((el) => isFrameLikeElement(el))\n  );\n};\n\nconst alignSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  app: AppClassProperties,\n  alignment: Alignment,\n) => {\n  const selectedElements = app.scene.getSelectedElements(appState);\n\n  const updatedElements = alignElements(selectedElements, alignment, app.scene);\n\n  const updatedElementsMap = arrayToMap(updatedElements);\n\n  return updateFrameMembershipOfSelectedElements(\n    elements.map((element) => updatedElementsMap.get(element.id) || element),\n    appState,\n    app,\n  );\n};\n\nexport const actionAlignTop = register({\n  name: \"alignTop\",\n  label: \"labels.alignTop\",\n  icon: AlignTopIcon,\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, appProps, app) =>\n    alignActionsPredicate(appState, app),\n  perform: (elements, appState, _, app) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, app, {\n        position: \"start\",\n        axis: \"y\",\n      }),\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_UP,\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <ToolButton\n      hidden={!alignActionsPredicate(appState, app)}\n      type=\"button\"\n      icon={AlignTopIcon}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignTop\")} — ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Up\",\n      )}`}\n      aria-label={t(\"labels.alignTop\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignBottom = register({\n  name: \"alignBottom\",\n  label: \"labels.alignBottom\",\n  icon: AlignBottomIcon,\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, appProps, app) =>\n    alignActionsPredicate(appState, app),\n  perform: (elements, appState, _, app) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, app, {\n        position: \"end\",\n        axis: \"y\",\n      }),\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_DOWN,\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <ToolButton\n      hidden={!alignActionsPredicate(appState, app)}\n      type=\"button\"\n      icon={AlignBottomIcon}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignBottom\")} — ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Down\",\n      )}`}\n      aria-label={t(\"labels.alignBottom\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignLeft = register({\n  name: \"alignLeft\",\n  label: \"labels.alignLeft\",\n  icon: AlignLeftIcon,\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, appProps, app) =>\n    alignActionsPredicate(appState, app),\n  perform: (elements, appState, _, app) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, app, {\n        position: \"start\",\n        axis: \"x\",\n      }),\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_LEFT,\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <ToolButton\n      hidden={!alignActionsPredicate(appState, app)}\n      type=\"button\"\n      icon={AlignLeftIcon}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignLeft\")} — ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Left\",\n      )}`}\n      aria-label={t(\"labels.alignLeft\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignRight = register({\n  name: \"alignRight\",\n  label: \"labels.alignRight\",\n  icon: AlignRightIcon,\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, appProps, app) =>\n    alignActionsPredicate(appState, app),\n  perform: (elements, appState, _, app) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, app, {\n        position: \"end\",\n        axis: \"x\",\n      }),\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_RIGHT,\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <ToolButton\n      hidden={!alignActionsPredicate(appState, app)}\n      type=\"button\"\n      icon={AlignRightIcon}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.alignRight\")} — ${getShortcutKey(\n        \"CtrlOrCmd+Shift+Right\",\n      )}`}\n      aria-label={t(\"labels.alignRight\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignVerticallyCentered = register({\n  name: \"alignVerticallyCentered\",\n  label: \"labels.centerVertically\",\n  icon: CenterVerticallyIcon,\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, appProps, app) =>\n    alignActionsPredicate(appState, app),\n  perform: (elements, appState, _, app) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, app, {\n        position: \"center\",\n        axis: \"y\",\n      }),\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <ToolButton\n      hidden={!alignActionsPredicate(appState, app)}\n      type=\"button\"\n      icon={CenterVerticallyIcon}\n      onClick={() => updateData(null)}\n      title={t(\"labels.centerVertically\")}\n      aria-label={t(\"labels.centerVertically\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const actionAlignHorizontallyCentered = register({\n  name: \"alignHorizontallyCentered\",\n  label: \"labels.centerHorizontally\",\n  icon: CenterHorizontallyIcon,\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, appProps, app) =>\n    alignActionsPredicate(appState, app),\n  perform: (elements, appState, _, app) => {\n    return {\n      appState,\n      elements: alignSelectedElements(elements, appState, app, {\n        position: \"center\",\n        axis: \"x\",\n      }),\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <ToolButton\n      hidden={!alignActionsPredicate(appState, app)}\n      type=\"button\"\n      icon={CenterHorizontallyIcon}\n      onClick={() => updateData(null)}\n      title={t(\"labels.centerHorizontally\")}\n      aria-label={t(\"labels.centerHorizontally\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n",
    "import { getNonDeletedElements } from \"@excalidraw/element\";\n\nimport { isFrameLikeElement } from \"@excalidraw/element\";\n\nimport { CODES, KEYS, arrayToMap, getShortcutKey } from \"@excalidraw/common\";\n\nimport { updateFrameMembershipOfSelectedElements } from \"@excalidraw/element\";\n\nimport { distributeElements } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { Distribution } from \"@excalidraw/element\";\n\nimport { ToolButton } from \"../components/ToolButton\";\nimport {\n  DistributeHorizontallyIcon,\n  DistributeVerticallyIcon,\n} from \"../components/icons\";\n\nimport { t } from \"../i18n\";\n\nimport { isSomeElementSelected } from \"../scene\";\n\nimport { register } from \"./register\";\n\nimport type { AppClassProperties, AppState } from \"../types\";\n\nconst enableActionGroup = (appState: AppState, app: AppClassProperties) => {\n  const selectedElements = app.scene.getSelectedElements(appState);\n  return (\n    selectedElements.length > 1 &&\n    // TODO enable distributing frames when implemented properly\n    !selectedElements.some((el) => isFrameLikeElement(el))\n  );\n};\n\nconst distributeSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  appState: Readonly<AppState>,\n  app: AppClassProperties,\n  distribution: Distribution,\n) => {\n  const selectedElements = app.scene.getSelectedElements(appState);\n\n  const updatedElements = distributeElements(\n    selectedElements,\n    app.scene.getNonDeletedElementsMap(),\n    distribution,\n  );\n\n  const updatedElementsMap = arrayToMap(updatedElements);\n\n  return updateFrameMembershipOfSelectedElements(\n    elements.map((element) => updatedElementsMap.get(element.id) || element),\n    appState,\n    app,\n  );\n};\n\nexport const distributeHorizontally = register({\n  name: \"distributeHorizontally\",\n  label: \"labels.distributeHorizontally\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, _, app) => {\n    return {\n      appState,\n      elements: distributeSelectedElements(elements, appState, app, {\n        space: \"between\",\n        axis: \"x\",\n      }),\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.H,\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <ToolButton\n      hidden={!enableActionGroup(appState, app)}\n      type=\"button\"\n      icon={DistributeHorizontallyIcon}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.distributeHorizontally\")} — ${getShortcutKey(\n        \"Alt+H\",\n      )}`}\n      aria-label={t(\"labels.distributeHorizontally\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n\nexport const distributeVertically = register({\n  name: \"distributeVertically\",\n  label: \"labels.distributeVertically\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, _, app) => {\n    return {\n      appState,\n      elements: distributeSelectedElements(elements, appState, app, {\n        space: \"between\",\n        axis: \"y\",\n      }),\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V,\n  PanelComponent: ({ elements, appState, updateData, app }) => (\n    <ToolButton\n      hidden={!enableActionGroup(appState, app)}\n      type=\"button\"\n      icon={DistributeVerticallyIcon}\n      onClick={() => updateData(null)}\n      title={`${t(\"labels.distributeVertically\")} — ${getShortcutKey(\"Alt+V\")}`}\n      aria-label={t(\"labels.distributeVertically\")}\n      visible={isSomeElementSelected(getNonDeletedElements(elements), appState)}\n    />\n  ),\n});\n",
    "import { getNonDeletedElements } from \"@excalidraw/element\";\nimport {\n  bindOrUnbindLinearElements,\n  isBindingEnabled,\n} from \"@excalidraw/element\";\nimport { getCommonBoundingBox } from \"@excalidraw/element\";\nimport { newElementWith } from \"@excalidraw/element\";\nimport { deepCopyElement } from \"@excalidraw/element\";\nimport { resizeMultipleElements } from \"@excalidraw/element\";\nimport {\n  isArrowElement,\n  isElbowArrow,\n  isLinearElement,\n} from \"@excalidraw/element\";\nimport { updateFrameMembershipOfSelectedElements } from \"@excalidraw/element\";\nimport { CODES, KEYS, arrayToMap } from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawArrowElement,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawElement,\n  NonDeleted,\n  NonDeletedSceneElementsMap,\n} from \"@excalidraw/element/types\";\n\nimport { getSelectedElements } from \"../scene\";\n\nimport { flipHorizontal, flipVertical } from \"../components/icons\";\n\nimport { register } from \"./register\";\n\nimport type { AppClassProperties, AppState } from \"../types\";\n\nexport const actionFlipHorizontal = register({\n  name: \"flipHorizontal\",\n  label: \"labels.flipHorizontal\",\n  icon: flipHorizontal,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, _, app) => {\n    return {\n      elements: updateFrameMembershipOfSelectedElements(\n        flipSelectedElements(\n          elements,\n          app.scene.getNonDeletedElementsMap(),\n          appState,\n          \"horizontal\",\n          app,\n        ),\n        appState,\n        app,\n      ),\n      appState,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) => event.shiftKey && event.code === CODES.H,\n});\n\nexport const actionFlipVertical = register({\n  name: \"flipVertical\",\n  label: \"labels.flipVertical\",\n  icon: flipVertical,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, _, app) => {\n    return {\n      elements: updateFrameMembershipOfSelectedElements(\n        flipSelectedElements(\n          elements,\n          app.scene.getNonDeletedElementsMap(),\n          appState,\n          \"vertical\",\n          app,\n        ),\n        appState,\n        app,\n      ),\n      appState,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event) =>\n    event.shiftKey && event.code === CODES.V && !event[KEYS.CTRL_OR_CMD],\n});\n\nconst flipSelectedElements = (\n  elements: readonly ExcalidrawElement[],\n  elementsMap: NonDeletedSceneElementsMap,\n  appState: Readonly<AppState>,\n  flipDirection: \"horizontal\" | \"vertical\",\n  app: AppClassProperties,\n) => {\n  const selectedElements = getSelectedElements(\n    getNonDeletedElements(elements),\n    appState,\n    {\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    },\n  );\n\n  const updatedElements = flipElements(\n    selectedElements,\n    elementsMap,\n    appState,\n    flipDirection,\n    app,\n  );\n\n  const updatedElementsMap = arrayToMap(updatedElements);\n\n  return elements.map(\n    (element) => updatedElementsMap.get(element.id) || element,\n  );\n};\n\nconst flipElements = (\n  selectedElements: NonDeleted<ExcalidrawElement>[],\n  elementsMap: NonDeletedSceneElementsMap,\n  appState: AppState,\n  flipDirection: \"horizontal\" | \"vertical\",\n  app: AppClassProperties,\n): ExcalidrawElement[] => {\n  if (\n    selectedElements.every(\n      (element) =>\n        isArrowElement(element) && (element.startBinding || element.endBinding),\n    )\n  ) {\n    return selectedElements.map((element) => {\n      const _element = element as ExcalidrawArrowElement;\n      return newElementWith(_element, {\n        startArrowhead: _element.endArrowhead,\n        endArrowhead: _element.startArrowhead,\n      });\n    });\n  }\n\n  const { midX, midY } = getCommonBoundingBox(selectedElements);\n\n  resizeMultipleElements(\n    selectedElements,\n    elementsMap,\n    \"nw\",\n    app.scene,\n    new Map(\n      Array.from(elementsMap.values()).map((element) => [\n        element.id,\n        deepCopyElement(element),\n      ]),\n    ),\n    {\n      flipByX: flipDirection === \"horizontal\",\n      flipByY: flipDirection === \"vertical\",\n      shouldResizeFromCenter: true,\n      shouldMaintainAspectRatio: true,\n    },\n  );\n\n  bindOrUnbindLinearElements(\n    selectedElements.filter(isLinearElement),\n    isBindingEnabled(appState),\n    [],\n    app.scene,\n    appState.zoom,\n  );\n\n  // ---------------------------------------------------------------------------\n  // flipping arrow elements (and potentially other) makes the selection group\n  // \"move\" across the canvas because of how arrows can bump against the \"wall\"\n  // of the selection, so we need to center the group back to the original\n  // position so that repeated flips don't accumulate the offset\n\n  const { elbowArrows, otherElements } = selectedElements.reduce(\n    (\n      acc: {\n        elbowArrows: ExcalidrawElbowArrowElement[];\n        otherElements: ExcalidrawElement[];\n      },\n      element,\n    ) =>\n      isElbowArrow(element)\n        ? { ...acc, elbowArrows: acc.elbowArrows.concat(element) }\n        : { ...acc, otherElements: acc.otherElements.concat(element) },\n    { elbowArrows: [], otherElements: [] },\n  );\n\n  const { midX: newMidX, midY: newMidY } =\n    getCommonBoundingBox(selectedElements);\n  const [diffX, diffY] = [midX - newMidX, midY - newMidY];\n  otherElements.forEach((element) =>\n    app.scene.mutateElement(element, {\n      x: element.x + diffX,\n      y: element.y + diffY,\n    }),\n  );\n  elbowArrows.forEach((element) =>\n    app.scene.mutateElement(element, {\n      x: element.x + diffX,\n      y: element.y + diffY,\n    }),\n  );\n  // ---------------------------------------------------------------------------\n\n  return selectedElements;\n};\n",
    "import { isTextElement } from \"@excalidraw/element\";\nimport { getTextFromElements } from \"@excalidraw/element\";\n\nimport { CODES, KEYS, isFirefox } from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport {\n  copyTextToSystemClipboard,\n  copyToClipboard,\n  createPasteEvent,\n  probablySupportsClipboardBlob,\n  probablySupportsClipboardWriteText,\n  readSystemClipboard,\n} from \"../clipboard\";\nimport { DuplicateIcon, cutIcon, pngIcon, svgIcon } from \"../components/icons\";\nimport { exportCanvas, prepareElementsForExport } from \"../data/index\";\nimport { t } from \"../i18n\";\n\nimport { actionDeleteSelected } from \"./actionDeleteSelected\";\nimport { register } from \"./register\";\n\nexport const actionCopy = register({\n  name: \"copy\",\n  label: \"labels.copy\",\n  icon: DuplicateIcon,\n  trackEvent: { category: \"element\" },\n  perform: async (elements, appState, event: ClipboardEvent | null, app) => {\n    const elementsToCopy = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    });\n\n    try {\n      await copyToClipboard(elementsToCopy, app.files, event);\n    } catch (error: any) {\n      return {\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n        appState: {\n          ...appState,\n          errorMessage: error.message,\n        },\n      };\n    }\n\n    return {\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  // don't supply a shortcut since we handle this conditionally via onCopy event\n  keyTest: undefined,\n});\n\nexport const actionPaste = register({\n  name: \"paste\",\n  label: \"labels.paste\",\n  trackEvent: { category: \"element\" },\n  perform: async (elements, appState, data, app) => {\n    let types;\n    try {\n      types = await readSystemClipboard();\n    } catch (error: any) {\n      if (error.name === \"AbortError\" || error.name === \"NotAllowedError\") {\n        // user probably aborted the action. Though not 100% sure, it's best\n        // to not annoy them with an error message.\n        return false;\n      }\n\n      console.error(`actionPaste ${error.name}: ${error.message}`);\n\n      if (isFirefox) {\n        return {\n          captureUpdate: CaptureUpdateAction.EVENTUALLY,\n          appState: {\n            ...appState,\n            errorMessage: t(\"hints.firefox_clipboard_write\"),\n          },\n        };\n      }\n\n      return {\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n        appState: {\n          ...appState,\n          errorMessage: t(\"errors.asyncPasteFailedOnRead\"),\n        },\n      };\n    }\n\n    try {\n      app.pasteFromClipboard(createPasteEvent({ types }));\n    } catch (error: any) {\n      console.error(error);\n      return {\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n        appState: {\n          ...appState,\n          errorMessage: t(\"errors.asyncPasteFailedOnParse\"),\n        },\n      };\n    }\n\n    return {\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  // don't supply a shortcut since we handle this conditionally via onCopy event\n  keyTest: undefined,\n});\n\nexport const actionCut = register({\n  name: \"cut\",\n  label: \"labels.cut\",\n  icon: cutIcon,\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, event: ClipboardEvent | null, app) => {\n    actionCopy.perform(elements, appState, event, app);\n    return actionDeleteSelected.perform(elements, appState, null, app);\n  },\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.X,\n});\n\nexport const actionCopyAsSvg = register({\n  name: \"copyAsSvg\",\n  label: \"labels.copyAsSvg\",\n  icon: svgIcon,\n  trackEvent: { category: \"element\" },\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    }\n\n    const { exportedElements, exportingFrame } = prepareElementsForExport(\n      elements,\n      appState,\n      true,\n    );\n\n    try {\n      await exportCanvas(\n        \"clipboard-svg\",\n        exportedElements,\n        appState,\n        app.files,\n        {\n          ...appState,\n          exportingFrame,\n          name: app.getName(),\n        },\n      );\n\n      const selectedElements = app.scene.getSelectedElements({\n        selectedElementIds: appState.selectedElementIds,\n        includeBoundTextElement: true,\n        includeElementsInFrames: true,\n      });\n\n      return {\n        appState: {\n          toast: {\n            message: t(\"toast.copyToClipboardAsSvg\", {\n              exportSelection: selectedElements.length\n                ? t(\"toast.selection\")\n                : t(\"toast.canvas\"),\n              exportColorScheme: appState.exportWithDarkMode\n                ? t(\"buttons.darkMode\")\n                : t(\"buttons.lightMode\"),\n            }),\n          },\n        },\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    } catch (error: any) {\n      console.error(error);\n      return {\n        appState: {\n          errorMessage: error.message,\n        },\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    }\n  },\n  predicate: (elements) => {\n    return probablySupportsClipboardWriteText && elements.length > 0;\n  },\n  keywords: [\"svg\", \"clipboard\", \"copy\"],\n});\n\nexport const actionCopyAsPng = register({\n  name: \"copyAsPng\",\n  label: \"labels.copyAsPng\",\n  icon: pngIcon,\n  trackEvent: { category: \"element\" },\n  perform: async (elements, appState, _data, app) => {\n    if (!app.canvas) {\n      return {\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    }\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    });\n\n    const { exportedElements, exportingFrame } = prepareElementsForExport(\n      elements,\n      appState,\n      true,\n    );\n    try {\n      await exportCanvas(\"clipboard\", exportedElements, appState, app.files, {\n        ...appState,\n        exportingFrame,\n        name: app.getName(),\n      });\n      return {\n        appState: {\n          ...appState,\n          toast: {\n            message: t(\"toast.copyToClipboardAsPng\", {\n              exportSelection: selectedElements.length\n                ? t(\"toast.selection\")\n                : t(\"toast.canvas\"),\n              exportColorScheme: appState.exportWithDarkMode\n                ? t(\"buttons.darkMode\")\n                : t(\"buttons.lightMode\"),\n            }),\n          },\n        },\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    } catch (error: any) {\n      console.error(error);\n      return {\n        appState: {\n          ...appState,\n          errorMessage: error.message,\n        },\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    }\n  },\n  predicate: (elements) => {\n    return probablySupportsClipboardBlob && elements.length > 0;\n  },\n  keyTest: (event) => event.code === CODES.C && event.altKey && event.shiftKey,\n  keywords: [\"png\", \"clipboard\", \"copy\"],\n});\n\nexport const copyText = register({\n  name: \"copyText\",\n  label: \"labels.copyText\",\n  trackEvent: { category: \"element\" },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n    });\n\n    try {\n      copyTextToSystemClipboard(getTextFromElements(selectedElements));\n    } catch (e) {\n      throw new Error(t(\"errors.copyToSystemClipboardFailed\"));\n    }\n    return {\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  predicate: (elements, appState, _, app) => {\n    return (\n      probablySupportsClipboardWriteText &&\n      app.scene\n        .getSelectedElements({\n          selectedElementIds: appState.selectedElementIds,\n          includeBoundTextElement: true,\n        })\n        .some(isTextElement)\n    );\n  },\n  keywords: [\"text\", \"clipboard\", \"copy\"],\n});\n",
    "import { CODES, KEYS } from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { gridIcon } from \"../components/icons\";\n\nimport { register } from \"./register\";\n\nimport type { AppState } from \"../types\";\n\nexport const actionToggleGridMode = register({\n  name: \"gridMode\",\n  icon: gridIcon,\n  keywords: [\"snap\"],\n  label: \"labels.toggleGrid\",\n  viewMode: true,\n  trackEvent: {\n    category: \"canvas\",\n    predicate: (appState) => appState.gridModeEnabled,\n  },\n  perform(elements, appState) {\n    return {\n      appState: {\n        ...appState,\n        gridModeEnabled: !this.checked!(appState),\n        objectsSnapModeEnabled: false,\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  checked: (appState: AppState) => appState.gridModeEnabled,\n  predicate: (element, appState, props) => {\n    return props.gridModeEnabled === undefined;\n  },\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE,\n});\n",
    "import { CODES, KEYS } from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { coffeeIcon } from \"../components/icons\";\n\nimport { register } from \"./register\";\n\nexport const actionToggleZenMode = register({\n  name: \"zenMode\",\n  label: \"buttons.zenMode\",\n  icon: coffeeIcon,\n  viewMode: true,\n  trackEvent: {\n    category: \"canvas\",\n    predicate: (appState) => !appState.zenModeEnabled,\n  },\n  perform(elements, appState) {\n    return {\n      appState: {\n        ...appState,\n        zenModeEnabled: !this.checked!(appState),\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  checked: (appState) => appState.zenModeEnabled,\n  predicate: (elements, appState, appProps) => {\n    return typeof appProps.zenModeEnabled === \"undefined\";\n  },\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z,\n});\n",
    "import { CODES, KEYS } from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { magnetIcon } from \"../components/icons\";\n\nimport { register } from \"./register\";\n\nexport const actionToggleObjectsSnapMode = register({\n  name: \"objectsSnapMode\",\n  label: \"buttons.objectsSnapMode\",\n  icon: magnetIcon,\n  viewMode: false,\n  trackEvent: {\n    category: \"canvas\",\n    predicate: (appState) => !appState.objectsSnapModeEnabled,\n  },\n  perform(elements, appState) {\n    return {\n      appState: {\n        ...appState,\n        objectsSnapModeEnabled: !this.checked!(appState),\n        gridModeEnabled: false,\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  checked: (appState) => appState.objectsSnapModeEnabled,\n  predicate: (elements, appState, appProps) => {\n    return typeof appProps.objectsSnapModeEnabled === \"undefined\";\n  },\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.S,\n});\n",
    "import { CODES, KEYS } from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { abacusIcon } from \"../components/icons\";\n\nimport { register } from \"./register\";\n\nexport const actionToggleStats = register({\n  name: \"stats\",\n  label: \"stats.fullTitle\",\n  icon: abacusIcon,\n  viewMode: true,\n  trackEvent: { category: \"menu\" },\n  keywords: [\"edit\", \"attributes\", \"customize\"],\n  perform(elements, appState) {\n    return {\n      appState: {\n        ...appState,\n        stats: { ...appState.stats, open: !this.checked!(appState) },\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  checked: (appState) => appState.stats.open,\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.SLASH,\n});\n",
    "import {\n  BOUND_TEXT_PADDING,\n  ROUNDNESS,\n  TEXT_ALIGN,\n  VERTICAL_ALIGN,\n  arrayToMap,\n  getFontString,\n} from \"@excalidraw/common\";\nimport {\n  getOriginalContainerHeightFromCache,\n  resetOriginalContainerCache,\n  updateOriginalContainerCache,\n} from \"@excalidraw/element\";\n\nimport {\n  computeBoundTextPosition,\n  computeContainerDimensionForBoundText,\n  getBoundTextElement,\n  redrawTextBoundingBox,\n} from \"@excalidraw/element\";\n\nimport {\n  hasBoundTextElement,\n  isArrowElement,\n  isTextBindableContainer,\n  isTextElement,\n  isUsingAdaptiveRadius,\n} from \"@excalidraw/element\";\n\nimport { measureText } from \"@excalidraw/element\";\n\nimport { syncMovedIndices } from \"@excalidraw/element\";\n\nimport { newElement } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextContainer,\n  ExcalidrawTextElement,\n} from \"@excalidraw/element/types\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport { register } from \"./register\";\n\nimport type { AppState } from \"../types\";\n\nexport const actionUnbindText = register({\n  name: \"unbindText\",\n  label: \"labels.unbindText\",\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n\n    return selectedElements.some((element) => hasBoundTextElement(element));\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n    selectedElements.forEach((element) => {\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n      if (boundTextElement) {\n        const { width, height } = measureText(\n          boundTextElement.originalText,\n          getFontString(boundTextElement),\n          boundTextElement.lineHeight,\n        );\n        const originalContainerHeight = getOriginalContainerHeightFromCache(\n          element.id,\n        );\n        resetOriginalContainerCache(element.id);\n        const { x, y } = computeBoundTextPosition(\n          element,\n          boundTextElement,\n          elementsMap,\n        );\n        app.scene.mutateElement(boundTextElement as ExcalidrawTextElement, {\n          containerId: null,\n          width,\n          height,\n          text: boundTextElement.originalText,\n          x,\n          y,\n        });\n        app.scene.mutateElement(element, {\n          boundElements: element.boundElements?.filter(\n            (ele) => ele.id !== boundTextElement.id,\n          ),\n          height: originalContainerHeight\n            ? originalContainerHeight\n            : element.height,\n        });\n      }\n    });\n    return {\n      elements,\n      appState,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n});\n\nexport const actionBindText = register({\n  name: \"bindText\",\n  label: \"labels.bindText\",\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n\n    if (selectedElements.length === 2) {\n      const textElement =\n        isTextElement(selectedElements[0]) ||\n        isTextElement(selectedElements[1]);\n\n      let bindingContainer;\n      if (isTextBindableContainer(selectedElements[0])) {\n        bindingContainer = selectedElements[0];\n      } else if (isTextBindableContainer(selectedElements[1])) {\n        bindingContainer = selectedElements[1];\n      }\n      if (\n        textElement &&\n        bindingContainer &&\n        getBoundTextElement(\n          bindingContainer,\n          app.scene.getNonDeletedElementsMap(),\n        ) === null\n      ) {\n        return true;\n      }\n    }\n    return false;\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n\n    let textElement: ExcalidrawTextElement;\n    let container: ExcalidrawTextContainer;\n\n    if (\n      isTextElement(selectedElements[0]) &&\n      isTextBindableContainer(selectedElements[1])\n    ) {\n      textElement = selectedElements[0];\n      container = selectedElements[1];\n    } else {\n      textElement = selectedElements[1] as ExcalidrawTextElement;\n      container = selectedElements[0] as ExcalidrawTextContainer;\n    }\n    app.scene.mutateElement(textElement, {\n      containerId: container.id,\n      verticalAlign: VERTICAL_ALIGN.MIDDLE,\n      textAlign: TEXT_ALIGN.CENTER,\n      autoResize: true,\n      angle: (isArrowElement(container) ? 0 : container?.angle ?? 0) as Radians,\n    });\n    app.scene.mutateElement(container, {\n      boundElements: (container.boundElements || []).concat({\n        type: \"text\",\n        id: textElement.id,\n      }),\n    });\n    const originalContainerHeight = container.height;\n    redrawTextBoundingBox(textElement, container, app.scene);\n    // overwritting the cache with original container height so\n    // it can be restored when unbind\n    updateOriginalContainerCache(container.id, originalContainerHeight);\n\n    return {\n      elements: pushTextAboveContainer(elements, container, textElement),\n      appState: { ...appState, selectedElementIds: { [container.id]: true } },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n});\n\nconst pushTextAboveContainer = (\n  elements: readonly ExcalidrawElement[],\n  container: ExcalidrawElement,\n  textElement: ExcalidrawTextElement,\n) => {\n  const updatedElements = elements.slice();\n  const textElementIndex = updatedElements.findIndex(\n    (ele) => ele.id === textElement.id,\n  );\n  updatedElements.splice(textElementIndex, 1);\n\n  const containerIndex = updatedElements.findIndex(\n    (ele) => ele.id === container.id,\n  );\n  updatedElements.splice(containerIndex + 1, 0, textElement);\n  syncMovedIndices(updatedElements, arrayToMap([container, textElement]));\n\n  return updatedElements;\n};\n\nconst pushContainerBelowText = (\n  elements: readonly ExcalidrawElement[],\n  container: ExcalidrawElement,\n  textElement: ExcalidrawTextElement,\n) => {\n  const updatedElements = elements.slice();\n  const containerIndex = updatedElements.findIndex(\n    (ele) => ele.id === container.id,\n  );\n  updatedElements.splice(containerIndex, 1);\n\n  const textElementIndex = updatedElements.findIndex(\n    (ele) => ele.id === textElement.id,\n  );\n  updatedElements.splice(textElementIndex, 0, container);\n  syncMovedIndices(updatedElements, arrayToMap([container, textElement]));\n\n  return updatedElements;\n};\n\nexport const actionWrapTextInContainer = register({\n  name: \"wrapTextInContainer\",\n  label: \"labels.createContainerFromText\",\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    const someTextElements = selectedElements.some((el) => isTextElement(el));\n    return selectedElements.length > 0 && someTextElements;\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    let updatedElements: readonly ExcalidrawElement[] = elements.slice();\n    const containerIds: Mutable<AppState[\"selectedElementIds\"]> = {};\n\n    for (const textElement of selectedElements) {\n      if (isTextElement(textElement)) {\n        const container = newElement({\n          type: \"rectangle\",\n          backgroundColor: appState.currentItemBackgroundColor,\n          boundElements: [\n            ...(textElement.boundElements || []),\n            { id: textElement.id, type: \"text\" },\n          ],\n          angle: textElement.angle,\n          fillStyle: appState.currentItemFillStyle,\n          strokeColor: appState.currentItemStrokeColor,\n          roughness: appState.currentItemRoughness,\n          strokeWidth: appState.currentItemStrokeWidth,\n          strokeStyle: appState.currentItemStrokeStyle,\n          roundness:\n            appState.currentItemRoundness === \"round\"\n              ? {\n                  type: isUsingAdaptiveRadius(\"rectangle\")\n                    ? ROUNDNESS.ADAPTIVE_RADIUS\n                    : ROUNDNESS.PROPORTIONAL_RADIUS,\n                }\n              : null,\n          opacity: 100,\n          locked: false,\n          x: textElement.x - BOUND_TEXT_PADDING,\n          y: textElement.y - BOUND_TEXT_PADDING,\n          width: computeContainerDimensionForBoundText(\n            textElement.width,\n            \"rectangle\",\n          ),\n          height: computeContainerDimensionForBoundText(\n            textElement.height,\n            \"rectangle\",\n          ),\n          groupIds: textElement.groupIds,\n          frameId: textElement.frameId,\n        });\n\n        // update bindings\n        if (textElement.boundElements?.length) {\n          const linearElementIds = textElement.boundElements\n            .filter((ele) => ele.type === \"arrow\")\n            .map((el) => el.id);\n          const linearElements = updatedElements.filter((ele) =>\n            linearElementIds.includes(ele.id),\n          ) as ExcalidrawLinearElement[];\n          linearElements.forEach((ele) => {\n            let startBinding = ele.startBinding;\n            let endBinding = ele.endBinding;\n\n            if (startBinding?.elementId === textElement.id) {\n              startBinding = {\n                ...startBinding,\n                elementId: container.id,\n              };\n            }\n\n            if (endBinding?.elementId === textElement.id) {\n              endBinding = { ...endBinding, elementId: container.id };\n            }\n\n            if (startBinding || endBinding) {\n              app.scene.mutateElement(ele, {\n                startBinding,\n                endBinding,\n              });\n            }\n          });\n        }\n\n        app.scene.mutateElement(textElement, {\n          containerId: container.id,\n          verticalAlign: VERTICAL_ALIGN.MIDDLE,\n          boundElements: null,\n          textAlign: TEXT_ALIGN.CENTER,\n          autoResize: true,\n        });\n\n        redrawTextBoundingBox(textElement, container, app.scene);\n\n        updatedElements = pushContainerBelowText(\n          [...updatedElements, container],\n          container,\n          textElement,\n        );\n\n        containerIds[container.id] = true;\n      }\n    }\n\n    return {\n      elements: updatedElements,\n      appState: {\n        ...appState,\n        selectedElementIds: containerIds,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n});\n",
    "import { isEmbeddableElement } from \"@excalidraw/element\";\n\nimport { KEYS, getShortcutKey } from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { ToolButton } from \"../components/ToolButton\";\nimport { getContextMenuLabel } from \"../components/hyperlink/Hyperlink\";\nimport { LinkIcon } from \"../components/icons\";\nimport { t } from \"../i18n\";\n\nimport { getSelectedElements } from \"../scene\";\n\nimport { register } from \"./register\";\n\nexport const actionLink = register({\n  name: \"hyperlink\",\n  label: (elements, appState) => getContextMenuLabel(elements, appState),\n  icon: LinkIcon,\n  perform: (elements, appState) => {\n    if (appState.showHyperlinkPopup === \"editor\") {\n      return false;\n    }\n\n    return {\n      elements,\n      appState: {\n        ...appState,\n        showHyperlinkPopup: \"editor\",\n        openMenu: null,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  trackEvent: { category: \"hyperlink\", action: \"click\" },\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.K,\n  predicate: (elements, appState) => {\n    const selectedElements = getSelectedElements(elements, appState);\n    return selectedElements.length === 1;\n  },\n  PanelComponent: ({ elements, appState, updateData }) => {\n    const selectedElements = getSelectedElements(elements, appState);\n\n    return (\n      <ToolButton\n        type=\"button\"\n        icon={LinkIcon}\n        aria-label={t(getContextMenuLabel(elements, appState))}\n        title={`${\n          isEmbeddableElement(elements[0])\n            ? t(\"labels.link.labelEmbed\")\n            : t(\"labels.link.label\")\n        } - ${getShortcutKey(\"CtrlOrCmd+K\")}`}\n        onClick={() => updateData(null)}\n        selected={selectedElements.length === 1 && !!selectedElements[0].link}\n      />\n    );\n  },\n});\n",
    "import { pointFrom, type GlobalPoint } from \"@excalidraw/math\";\nimport clsx from \"clsx\";\nimport {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from \"react\";\n\nimport { EVENT, HYPERLINK_TOOLTIP_DELAY, KEYS } from \"@excalidraw/common\";\n\nimport { getElementAbsoluteCoords } from \"@excalidraw/element\";\n\nimport { hitElementBoundingBox } from \"@excalidraw/element\";\n\nimport { isElementLink } from \"@excalidraw/element\";\n\nimport { getEmbedLink, embeddableURLValidator } from \"@excalidraw/element\";\n\nimport {\n  sceneCoordsToViewportCoords,\n  viewportCoordsToSceneCoords,\n  wrapEvent,\n  isLocalLink,\n  normalizeLink,\n} from \"@excalidraw/common\";\n\nimport { isEmbeddableElement } from \"@excalidraw/element\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawEmbeddableElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport { trackEvent } from \"../../analytics\";\nimport { getTooltipDiv, updateTooltipPosition } from \"../../components/Tooltip\";\n\nimport { t } from \"../../i18n\";\n\nimport { useAppProps, useDevice, useExcalidrawAppState } from \"../App\";\nimport { ToolButton } from \"../ToolButton\";\nimport { FreedrawIcon, TrashIcon, elementLinkIcon } from \"../icons\";\nimport { getSelectedElements } from \"../../scene\";\n\nimport { getLinkHandleFromCoords } from \"./helpers\";\n\nimport \"./Hyperlink.scss\";\n\nimport type { AppState, ExcalidrawProps, UIAppState } from \"../../types\";\n\nconst POPUP_WIDTH = 380;\nconst POPUP_HEIGHT = 42;\nconst POPUP_PADDING = 5;\nconst SPACE_BOTTOM = 85;\nconst AUTO_HIDE_TIMEOUT = 500;\n\nlet IS_HYPERLINK_TOOLTIP_VISIBLE = false;\n\nconst embeddableLinkCache = new Map<\n  ExcalidrawEmbeddableElement[\"id\"],\n  string\n>();\n\nexport const Hyperlink = ({\n  element,\n  scene,\n  setAppState,\n  onLinkOpen,\n  setToast,\n  updateEmbedValidationStatus,\n}: {\n  element: NonDeletedExcalidrawElement;\n  scene: Scene;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  onLinkOpen: ExcalidrawProps[\"onLinkOpen\"];\n  setToast: (\n    toast: { message: string; closable?: boolean; duration?: number } | null,\n  ) => void;\n  updateEmbedValidationStatus: (\n    element: ExcalidrawEmbeddableElement,\n    status: boolean,\n  ) => void;\n}) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const appState = useExcalidrawAppState();\n  const appProps = useAppProps();\n  const device = useDevice();\n\n  const linkVal = element.link || \"\";\n\n  const [inputVal, setInputVal] = useState(linkVal);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const isEditing = appState.showHyperlinkPopup === \"editor\";\n\n  const handleSubmit = useCallback(() => {\n    if (!inputRef.current) {\n      return;\n    }\n\n    const link = normalizeLink(inputRef.current.value) || null;\n\n    if (!element.link && link) {\n      trackEvent(\"hyperlink\", \"create\");\n    }\n\n    if (isEmbeddableElement(element)) {\n      if (appState.activeEmbeddable?.element === element) {\n        setAppState({ activeEmbeddable: null });\n      }\n      if (!link) {\n        scene.mutateElement(element, {\n          link: null,\n        });\n        updateEmbedValidationStatus(element, false);\n        return;\n      }\n\n      if (!embeddableURLValidator(link, appProps.validateEmbeddable)) {\n        if (link) {\n          setToast({ message: t(\"toast.unableToEmbed\"), closable: true });\n        }\n        element.link && embeddableLinkCache.set(element.id, element.link);\n        scene.mutateElement(element, {\n          link,\n        });\n        updateEmbedValidationStatus(element, false);\n      } else {\n        const { width, height } = element;\n        const embedLink = getEmbedLink(link);\n        if (embedLink?.error instanceof URIError) {\n          setToast({\n            message: t(\"toast.unrecognizedLinkFormat\"),\n            closable: true,\n          });\n        }\n        const ar = embedLink\n          ? embedLink.intrinsicSize.w / embedLink.intrinsicSize.h\n          : 1;\n        const hasLinkChanged =\n          embeddableLinkCache.get(element.id) !== element.link;\n        scene.mutateElement(element, {\n          ...(hasLinkChanged\n            ? {\n                width:\n                  embedLink?.type === \"video\"\n                    ? width > height\n                      ? width\n                      : height * ar\n                    : width,\n                height:\n                  embedLink?.type === \"video\"\n                    ? width > height\n                      ? width / ar\n                      : height\n                    : height,\n              }\n            : {}),\n          link,\n        });\n        updateEmbedValidationStatus(element, true);\n        if (embeddableLinkCache.has(element.id)) {\n          embeddableLinkCache.delete(element.id);\n        }\n      }\n    } else {\n      scene.mutateElement(element, { link });\n    }\n  }, [\n    element,\n    scene,\n    setToast,\n    appProps.validateEmbeddable,\n    appState.activeEmbeddable,\n    setAppState,\n    updateEmbedValidationStatus,\n  ]);\n\n  useLayoutEffect(() => {\n    return () => {\n      handleSubmit();\n    };\n  }, [handleSubmit]);\n\n  useEffect(() => {\n    if (\n      isEditing &&\n      inputRef?.current &&\n      !(device.viewport.isMobile || device.isTouchScreen)\n    ) {\n      inputRef.current.select();\n    }\n  }, [isEditing, device.viewport.isMobile, device.isTouchScreen]);\n\n  useEffect(() => {\n    let timeoutId: number | null = null;\n\n    const handlePointerMove = (event: PointerEvent) => {\n      if (isEditing) {\n        return;\n      }\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      const shouldHide = shouldHideLinkPopup(\n        element,\n        elementsMap,\n        appState,\n        pointFrom(event.clientX, event.clientY),\n      ) as boolean;\n      if (shouldHide) {\n        timeoutId = window.setTimeout(() => {\n          setAppState({ showHyperlinkPopup: false });\n        }, AUTO_HIDE_TIMEOUT);\n      }\n    };\n    window.addEventListener(EVENT.POINTER_MOVE, handlePointerMove, false);\n    return () => {\n      window.removeEventListener(EVENT.POINTER_MOVE, handlePointerMove, false);\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  }, [appState, element, isEditing, setAppState, elementsMap]);\n\n  const handleRemove = useCallback(() => {\n    trackEvent(\"hyperlink\", \"delete\");\n    scene.mutateElement(element, { link: null });\n    setAppState({ showHyperlinkPopup: false });\n  }, [setAppState, element, scene]);\n\n  const onEdit = () => {\n    trackEvent(\"hyperlink\", \"edit\", \"popup-ui\");\n    setAppState({ showHyperlinkPopup: \"editor\" });\n  };\n  const { x, y } = getCoordsForPopover(element, appState, elementsMap);\n  if (\n    appState.contextMenu ||\n    appState.selectedElementsAreBeingDragged ||\n    appState.resizingElement ||\n    appState.isRotating ||\n    appState.openMenu ||\n    appState.viewModeEnabled\n  ) {\n    return null;\n  }\n\n  return (\n    <div\n      className=\"excalidraw-hyperlinkContainer\"\n      style={{\n        top: `${y}px`,\n        left: `${x}px`,\n        width: POPUP_WIDTH,\n        padding: POPUP_PADDING,\n      }}\n    >\n      {isEditing ? (\n        <input\n          className={clsx(\"excalidraw-hyperlinkContainer-input\")}\n          placeholder={t(\"labels.link.hint\")}\n          ref={inputRef}\n          value={inputVal}\n          onChange={(event) => setInputVal(event.target.value)}\n          autoFocus\n          onKeyDown={(event) => {\n            event.stopPropagation();\n            // prevent cmd/ctrl+k shortcut when editing link\n            if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.K) {\n              event.preventDefault();\n            }\n            if (event.key === KEYS.ENTER || event.key === KEYS.ESCAPE) {\n              handleSubmit();\n              setAppState({ showHyperlinkPopup: \"info\" });\n            }\n          }}\n        />\n      ) : element.link ? (\n        <a\n          href={normalizeLink(element.link || \"\")}\n          className=\"excalidraw-hyperlinkContainer-link\"\n          target={isLocalLink(element.link) ? \"_self\" : \"_blank\"}\n          onClick={(event) => {\n            if (element.link && onLinkOpen) {\n              const customEvent = wrapEvent(\n                EVENT.EXCALIDRAW_LINK,\n                event.nativeEvent,\n              );\n              onLinkOpen(\n                {\n                  ...element,\n                  link: normalizeLink(element.link),\n                },\n                customEvent,\n              );\n              if (customEvent.defaultPrevented) {\n                event.preventDefault();\n              }\n            }\n          }}\n          rel=\"noopener noreferrer\"\n        >\n          {element.link}\n        </a>\n      ) : (\n        <div className=\"excalidraw-hyperlinkContainer-link\">\n          {t(\"labels.link.empty\")}\n        </div>\n      )}\n      <div className=\"excalidraw-hyperlinkContainer__buttons\">\n        {!isEditing && (\n          <ToolButton\n            type=\"button\"\n            title={t(\"buttons.edit\")}\n            aria-label={t(\"buttons.edit\")}\n            label={t(\"buttons.edit\")}\n            onClick={onEdit}\n            className=\"excalidraw-hyperlinkContainer--edit\"\n            icon={FreedrawIcon}\n          />\n        )}\n        <ToolButton\n          type=\"button\"\n          title={t(\"labels.linkToElement\")}\n          aria-label={t(\"labels.linkToElement\")}\n          label={t(\"labels.linkToElement\")}\n          onClick={() => {\n            setAppState({\n              openDialog: {\n                name: \"elementLinkSelector\",\n                sourceElementId: element.id,\n              },\n            });\n          }}\n          icon={elementLinkIcon}\n        />\n        {linkVal && !isEmbeddableElement(element) && (\n          <ToolButton\n            type=\"button\"\n            title={t(\"buttons.remove\")}\n            aria-label={t(\"buttons.remove\")}\n            label={t(\"buttons.remove\")}\n            onClick={handleRemove}\n            className=\"excalidraw-hyperlinkContainer--remove\"\n            icon={TrashIcon}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nconst getCoordsForPopover = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);\n  const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n    { sceneX: x1 + element.width / 2, sceneY: y1 },\n    appState,\n  );\n  const x = viewportX - appState.offsetLeft - POPUP_WIDTH / 2;\n  const y = viewportY - appState.offsetTop - SPACE_BOTTOM;\n  return { x, y };\n};\n\nexport const getContextMenuLabel = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: UIAppState,\n) => {\n  const selectedElements = getSelectedElements(elements, appState);\n  const label = isEmbeddableElement(selectedElements[0])\n    ? \"labels.link.editEmbed\"\n    : selectedElements[0]?.link\n    ? \"labels.link.edit\"\n    : \"labels.link.create\";\n  return label;\n};\n\nlet HYPERLINK_TOOLTIP_TIMEOUT_ID: number | null = null;\nexport const showHyperlinkTooltip = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {\n    clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);\n  }\n  HYPERLINK_TOOLTIP_TIMEOUT_ID = window.setTimeout(\n    () => renderTooltip(element, appState, elementsMap),\n    HYPERLINK_TOOLTIP_DELAY,\n  );\n};\n\nconst renderTooltip = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  if (!element.link) {\n    return;\n  }\n\n  const tooltipDiv = getTooltipDiv();\n\n  tooltipDiv.classList.add(\"excalidraw-tooltip--visible\");\n  tooltipDiv.style.maxWidth = \"20rem\";\n  tooltipDiv.textContent = isElementLink(element.link)\n    ? t(\"labels.link.goToElement\")\n    : element.link;\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n\n  const [linkX, linkY, linkWidth, linkHeight] = getLinkHandleFromCoords(\n    [x1, y1, x2, y2],\n    element.angle,\n    appState,\n  );\n\n  const linkViewportCoords = sceneCoordsToViewportCoords(\n    { sceneX: linkX, sceneY: linkY },\n    appState,\n  );\n\n  updateTooltipPosition(\n    tooltipDiv,\n    {\n      left: linkViewportCoords.x,\n      top: linkViewportCoords.y,\n      width: linkWidth,\n      height: linkHeight,\n    },\n    \"top\",\n  );\n  trackEvent(\"hyperlink\", \"tooltip\", \"link-icon\");\n\n  IS_HYPERLINK_TOOLTIP_VISIBLE = true;\n};\nexport const hideHyperlinkToolip = () => {\n  if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {\n    clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);\n  }\n  if (IS_HYPERLINK_TOOLTIP_VISIBLE) {\n    IS_HYPERLINK_TOOLTIP_VISIBLE = false;\n    getTooltipDiv().classList.remove(\"excalidraw-tooltip--visible\");\n  }\n};\n\nconst shouldHideLinkPopup = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: ElementsMap,\n  appState: AppState,\n  [clientX, clientY]: GlobalPoint,\n): Boolean => {\n  const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(\n    { clientX, clientY },\n    appState,\n  );\n\n  const threshold = 15 / appState.zoom.value;\n  // hitbox to prevent hiding when hovered in element bounding box\n  if (hitElementBoundingBox(pointFrom(sceneX, sceneY), element, elementsMap)) {\n    return false;\n  }\n  const [x1, y1, x2] = getElementAbsoluteCoords(element, elementsMap);\n  // hit box to prevent hiding when hovered in the vertical area between element and popover\n  if (\n    sceneX >= x1 &&\n    sceneX <= x2 &&\n    sceneY >= y1 - SPACE_BOTTOM &&\n    sceneY <= y1\n  ) {\n    return false;\n  }\n  // hit box to prevent hiding when hovered around popover within threshold\n  const { x: popoverX, y: popoverY } = getCoordsForPopover(\n    element,\n    appState,\n    elementsMap,\n  );\n\n  if (\n    clientX >= popoverX - threshold &&\n    clientX <= popoverX + POPUP_WIDTH + POPUP_PADDING * 2 + threshold &&\n    clientY >= popoverY - threshold &&\n    clientY <= popoverY + threshold + POPUP_PADDING * 2 + POPUP_HEIGHT\n  ) {\n    return false;\n  }\n  return true;\n};\n",
    "import { KEYS, arrayToMap, randomId } from \"@excalidraw/common\";\n\nimport {\n  elementsAreInSameGroup,\n  newElementWith,\n  selectGroupsFromGivenElements,\n} from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { LockedIcon, UnlockedIcon } from \"../components/icons\";\n\nimport { getSelectedElements } from \"../scene\";\n\nimport { register } from \"./register\";\n\nimport type { AppState } from \"../types\";\n\nconst shouldLock = (elements: readonly ExcalidrawElement[]) =>\n  elements.every((el) => !el.locked);\n\nexport const actionToggleElementLock = register({\n  name: \"toggleElementLock\",\n  label: (elements, appState, app) => {\n    const selected = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: false,\n    });\n\n    return shouldLock(selected)\n      ? \"labels.elementLock.lock\"\n      : \"labels.elementLock.unlock\";\n  },\n  icon: (appState, elements) => {\n    const selectedElements = getSelectedElements(elements, appState);\n    return shouldLock(selectedElements) ? LockedIcon : UnlockedIcon;\n  },\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    return (\n      selectedElements.length > 0 &&\n      !selectedElements.some((element) => element.locked && element.frameId)\n    );\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    });\n\n    if (!selectedElements.length) {\n      return false;\n    }\n\n    const nextLockState = shouldLock(selectedElements);\n    const selectedElementsMap = arrayToMap(selectedElements);\n\n    const isAGroup =\n      selectedElements.length > 1 && elementsAreInSameGroup(selectedElements);\n    const isASingleUnit = selectedElements.length === 1 || isAGroup;\n    const newGroupId = isASingleUnit ? null : randomId();\n\n    let nextLockedMultiSelections = { ...appState.lockedMultiSelections };\n\n    if (nextLockState) {\n      nextLockedMultiSelections = {\n        ...appState.lockedMultiSelections,\n        ...(newGroupId ? { [newGroupId]: true } : {}),\n      };\n    } else if (isAGroup) {\n      const groupId = selectedElements[0].groupIds.at(-1)!;\n      delete nextLockedMultiSelections[groupId];\n    }\n\n    const nextElements = elements.map((element) => {\n      if (!selectedElementsMap.has(element.id)) {\n        return element;\n      }\n\n      let nextGroupIds = element.groupIds;\n\n      // if locking together, add to group\n      // if unlocking, remove the temporary group\n      if (nextLockState) {\n        if (newGroupId) {\n          nextGroupIds = [...nextGroupIds, newGroupId];\n        }\n      } else {\n        nextGroupIds = nextGroupIds.filter(\n          (groupId) => !appState.lockedMultiSelections[groupId],\n        );\n      }\n\n      return newElementWith(element, {\n        locked: nextLockState,\n        // do not recreate the array unncessarily\n        groupIds:\n          nextGroupIds.length !== element.groupIds.length\n            ? nextGroupIds\n            : element.groupIds,\n      });\n    });\n\n    const nextElementsMap = arrayToMap(nextElements);\n    const nextSelectedElementIds: AppState[\"selectedElementIds\"] = nextLockState\n      ? {}\n      : Object.fromEntries(selectedElements.map((el) => [el.id, true]));\n    const unlockedSelectedElements = selectedElements.map(\n      (el) => nextElementsMap.get(el.id) || el,\n    );\n    const nextSelectedGroupIds = nextLockState\n      ? {}\n      : selectGroupsFromGivenElements(unlockedSelectedElements, appState);\n\n    const activeLockedId = nextLockState\n      ? newGroupId\n        ? newGroupId\n        : isAGroup\n        ? selectedElements[0].groupIds.at(-1)!\n        : selectedElements[0].id\n      : null;\n\n    return {\n      elements: nextElements,\n\n      appState: {\n        ...appState,\n        selectedElementIds: nextSelectedElementIds,\n        selectedGroupIds: nextSelectedGroupIds,\n        selectedLinearElement: nextLockState\n          ? null\n          : appState.selectedLinearElement,\n        lockedMultiSelections: nextLockedMultiSelections,\n        activeLockedId,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  keyTest: (event, appState, elements, app) => {\n    return (\n      event.key.toLocaleLowerCase() === KEYS.L &&\n      event[KEYS.CTRL_OR_CMD] &&\n      event.shiftKey &&\n      app.scene.getSelectedElements({\n        selectedElementIds: appState.selectedElementIds,\n        includeBoundTextElement: false,\n      }).length > 0\n    );\n  },\n});\n\nexport const actionUnlockAllElements = register({\n  name: \"unlockAllElements\",\n  trackEvent: { category: \"canvas\" },\n  viewMode: false,\n  icon: UnlockedIcon,\n  predicate: (elements, appState) => {\n    const selectedElements = getSelectedElements(elements, appState);\n    return (\n      selectedElements.length === 0 &&\n      elements.some((element) => element.locked)\n    );\n  },\n  perform: (elements, appState) => {\n    const lockedElements = elements.filter((el) => el.locked);\n\n    const nextElements = elements.map((element) => {\n      if (element.locked) {\n        // remove the temporary groupId if it exists\n        const nextGroupIds = element.groupIds.filter(\n          (gid) => !appState.lockedMultiSelections[gid],\n        );\n\n        return newElementWith(element, {\n          locked: false,\n          groupIds:\n            // do not recreate the array unncessarily\n            element.groupIds.length !== nextGroupIds.length\n              ? nextGroupIds\n              : element.groupIds,\n        });\n      }\n      return element;\n    });\n\n    const nextElementsMap = arrayToMap(nextElements);\n\n    const unlockedElements = lockedElements.map(\n      (el) => nextElementsMap.get(el.id) || el,\n    );\n\n    return {\n      elements: nextElements,\n      appState: {\n        ...appState,\n        selectedElementIds: Object.fromEntries(\n          lockedElements.map((el) => [el.id, true]),\n        ),\n        selectedGroupIds: selectGroupsFromGivenElements(\n          unlockedElements,\n          appState,\n        ),\n        lockedMultiSelections: {},\n        activeLockedId: null,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  label: \"labels.elementLock.unlockAll\",\n});\n",
    "import { LinearElementEditor } from \"@excalidraw/element\";\nimport {\n  isElbowArrow,\n  isLinearElement,\n  isLineElement,\n} from \"@excalidraw/element\";\nimport { arrayToMap } from \"@excalidraw/common\";\n\nimport {\n  toggleLinePolygonState,\n  CaptureUpdateAction,\n} from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawLinearElement,\n  ExcalidrawLineElement,\n} from \"@excalidraw/element/types\";\n\nimport { DEFAULT_CATEGORIES } from \"../components/CommandPalette/CommandPalette\";\nimport { ToolButton } from \"../components/ToolButton\";\nimport { lineEditorIcon, polygonIcon } from \"../components/icons\";\nimport { t } from \"../i18n\";\n\nimport { ButtonIcon } from \"../components/ButtonIcon\";\n\nimport { newElementWith } from \"../../element/src/mutateElement\";\n\nimport { register } from \"./register\";\n\nexport const actionToggleLinearEditor = register({\n  name: \"toggleLinearEditor\",\n  category: DEFAULT_CATEGORIES.elements,\n  label: (elements, appState, app) => {\n    const selectedElement = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n    })[0] as ExcalidrawLinearElement | undefined;\n\n    return selectedElement?.type === \"arrow\"\n      ? \"labels.lineEditor.editArrow\"\n      : \"labels.lineEditor.edit\";\n  },\n  keywords: [\"line\"],\n  trackEvent: {\n    category: \"element\",\n  },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    if (\n      !appState.editingLinearElement &&\n      selectedElements.length === 1 &&\n      isLinearElement(selectedElements[0]) &&\n      !isElbowArrow(selectedElements[0])\n    ) {\n      return true;\n    }\n    return false;\n  },\n  perform(elements, appState, _, app) {\n    const selectedElement = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n    })[0] as ExcalidrawLinearElement;\n\n    const editingLinearElement =\n      appState.editingLinearElement?.elementId === selectedElement.id\n        ? null\n        : new LinearElementEditor(selectedElement, arrayToMap(elements));\n    return {\n      appState: {\n        ...appState,\n        editingLinearElement,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ appState, updateData, app }) => {\n    const selectedElement = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n    })[0] as ExcalidrawLinearElement;\n\n    const label = t(\n      selectedElement.type === \"arrow\"\n        ? \"labels.lineEditor.editArrow\"\n        : \"labels.lineEditor.edit\",\n    );\n    return (\n      <ToolButton\n        type=\"button\"\n        icon={lineEditorIcon}\n        title={label}\n        aria-label={label}\n        onClick={() => updateData(null)}\n      />\n    );\n  },\n});\n\nexport const actionTogglePolygon = register({\n  name: \"togglePolygon\",\n  category: DEFAULT_CATEGORIES.elements,\n  icon: polygonIcon,\n  keywords: [\"loop\"],\n  label: (elements, appState, app) => {\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n    });\n\n    const allPolygons = !selectedElements.some(\n      (element) => !isLineElement(element) || !element.polygon,\n    );\n\n    return allPolygons\n      ? \"labels.polygon.breakPolygon\"\n      : \"labels.polygon.convertToPolygon\";\n  },\n  trackEvent: {\n    category: \"element\",\n  },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n    });\n\n    return (\n      selectedElements.length > 0 &&\n      selectedElements.every(\n        (element) => isLineElement(element) && element.points.length >= 4,\n      )\n    );\n  },\n  perform(elements, appState, _, app) {\n    const selectedElements = app.scene.getSelectedElements(appState);\n\n    if (selectedElements.some((element) => !isLineElement(element))) {\n      return false;\n    }\n\n    const targetElements = selectedElements as ExcalidrawLineElement[];\n\n    // if one element not a polygon, convert all to polygon\n    const nextPolygonState = targetElements.some((element) => !element.polygon);\n\n    const targetElementsMap = arrayToMap(targetElements);\n\n    return {\n      elements: elements.map((element) => {\n        if (!targetElementsMap.has(element.id) || !isLineElement(element)) {\n          return element;\n        }\n\n        return newElementWith(element, {\n          backgroundColor: nextPolygonState\n            ? element.backgroundColor\n            : \"transparent\",\n          ...toggleLinePolygonState(element, nextPolygonState),\n        });\n      }),\n      appState,\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  PanelComponent: ({ appState, updateData, app }) => {\n    const selectedElements = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n    });\n\n    if (\n      selectedElements.length === 0 ||\n      selectedElements.some(\n        (element) =>\n          !isLineElement(element) ||\n          // only show polygon button if every selected element is already\n          // a polygon, effectively showing this button only to allow for\n          // disabling the polygon state\n          !element.polygon ||\n          element.points.length < 3,\n      )\n    ) {\n      return null;\n    }\n\n    const allPolygon = selectedElements.every(\n      (element) => isLineElement(element) && element.polygon,\n    );\n\n    const label = t(\n      allPolygon\n        ? \"labels.polygon.breakPolygon\"\n        : \"labels.polygon.convertToPolygon\",\n    );\n\n    return (\n      <ButtonIcon\n        icon={polygonIcon}\n        title={label}\n        aria-label={label}\n        active={allPolygon}\n        onClick={() => updateData(null)}\n        style={{ marginLeft: \"auto\" }}\n      />\n    );\n  },\n});\n",
    "import clsx from \"clsx\";\nimport fuzzy from \"fuzzy\";\nimport { useEffect, useRef, useState } from \"react\";\n\nimport {\n  DEFAULT_SIDEBAR,\n  EVENT,\n  KEYS,\n  capitalizeString,\n  getShortcutKey,\n  isWritableElement,\n} from \"@excalidraw/common\";\n\nimport { actionToggleShapeSwitch } from \"excalidraw-custom/actions/actionToggleShapeSwitch\";\n\nimport type { MarkRequired } from \"@excalidraw/common/utility-types\";\n\nimport {\n  actionClearCanvas,\n  actionLink,\n  actionToggleSearchMenu,\n} from \"../../actions\";\nimport {\n  actionCopyElementLink,\n  actionLinkToElement,\n} from \"../../actions/actionElementLink\";\nimport { getShortcutFromShortcutName } from \"../../actions/shortcuts\";\nimport { trackEvent } from \"../../analytics\";\nimport { useUIAppState } from \"../../context/ui-appState\";\nimport { deburr } from \"../../deburr\";\nimport { atom, useAtom, editorJotaiStore } from \"../../editor-jotai\";\nimport { t } from \"../../i18n\";\nimport {\n  useApp,\n  useAppProps,\n  useExcalidrawActionManager,\n  useExcalidrawSetAppState,\n} from \"../App\";\nimport { Dialog } from \"../Dialog\";\nimport { InlineIcon } from \"../InlineIcon\";\nimport { TextField } from \"../TextField\";\nimport { getSelectedElements } from \"../../scene\";\nimport {\n  LockedIcon,\n  UnlockedIcon,\n  clockIcon,\n  searchIcon,\n  boltIcon,\n  bucketFillIcon,\n  ExportImageIcon,\n  mermaidLogoIcon,\n  brainIconThin,\n  LibraryIcon,\n} from \"../icons\";\n\nimport { SHAPES } from \"../shapes\";\nimport { canChangeBackgroundColor, canChangeStrokeColor } from \"../Actions\";\nimport { useStableCallback } from \"../../hooks/useStableCallback\";\nimport { activeConfirmDialogAtom } from \"../ActiveConfirmDialog\";\nimport { useStable } from \"../../hooks/useStable\";\n\nimport * as defaultItems from \"./defaultCommandPaletteItems\";\n\nimport \"./CommandPalette.scss\";\n\nimport type { CommandPaletteItem } from \"./types\";\nimport type { AppProps, AppState, UIAppState } from \"../../types\";\nimport type { ShortcutName } from \"../../actions/shortcuts\";\nimport type { TranslationKeys } from \"../../i18n\";\nimport type { Action } from \"../../actions/types\";\n\nconst lastUsedPaletteItem = atom<CommandPaletteItem | null>(null);\n\nexport const DEFAULT_CATEGORIES = {\n  app: \"App\",\n  export: \"Export\",\n  tools: \"Tools\",\n  editor: \"Editor\",\n  elements: \"Elements\",\n  links: \"Links\",\n};\n\nconst getCategoryOrder = (category: string) => {\n  switch (category) {\n    case DEFAULT_CATEGORIES.app:\n      return 1;\n    case DEFAULT_CATEGORIES.export:\n      return 2;\n    case DEFAULT_CATEGORIES.editor:\n      return 3;\n    case DEFAULT_CATEGORIES.tools:\n      return 4;\n    case DEFAULT_CATEGORIES.elements:\n      return 5;\n    case DEFAULT_CATEGORIES.links:\n      return 6;\n    default:\n      return 10;\n  }\n};\n\nconst CommandShortcutHint = ({\n  shortcut,\n  className,\n  children,\n}: {\n  shortcut: string;\n  className?: string;\n  children?: React.ReactNode;\n}) => {\n  const shortcuts = shortcut.replace(\"++\", \"+$\").split(\"+\");\n\n  return (\n    <div className={clsx(\"shortcut\", className)}>\n      {shortcuts.map((item, idx) => {\n        return (\n          <div className=\"shortcut-wrapper\" key={item}>\n            <div className=\"shortcut-key\">{item === \"$\" ? \"+\" : item}</div>\n          </div>\n        );\n      })}\n      <div className=\"shortcut-desc\">{children}</div>\n    </div>\n  );\n};\n\nconst isCommandPaletteToggleShortcut = (event: KeyboardEvent) => {\n  return (\n    !event.altKey &&\n    event[KEYS.CTRL_OR_CMD] &&\n    ((event.shiftKey && event.key.toLowerCase() === KEYS.P) ||\n      event.key === KEYS.SLASH)\n  );\n};\n\ntype CommandPaletteProps = {\n  customCommandPaletteItems?: CommandPaletteItem[];\n};\n\nexport const CommandPalette = Object.assign(\n  (props: CommandPaletteProps) => {\n    const uiAppState = useUIAppState();\n    const setAppState = useExcalidrawSetAppState();\n\n    useEffect(() => {\n      const commandPaletteShortcut = (event: KeyboardEvent) => {\n        if (isCommandPaletteToggleShortcut(event)) {\n          event.preventDefault();\n          event.stopPropagation();\n          setAppState((appState) => {\n            const nextState =\n              appState.openDialog?.name === \"commandPalette\"\n                ? null\n                : ({ name: \"commandPalette\" } as const);\n\n            if (nextState) {\n              trackEvent(\"command_palette\", \"open\", \"shortcut\");\n            }\n\n            return {\n              openDialog: nextState,\n            };\n          });\n        }\n      };\n      window.addEventListener(EVENT.KEYDOWN, commandPaletteShortcut, {\n        capture: true,\n      });\n      return () =>\n        window.removeEventListener(EVENT.KEYDOWN, commandPaletteShortcut, {\n          capture: true,\n        });\n    }, [setAppState]);\n\n    if (uiAppState.openDialog?.name !== \"commandPalette\") {\n      return null;\n    }\n\n    return <CommandPaletteInner {...props} />;\n  },\n  {\n    defaultItems,\n  },\n);\n\nfunction CommandPaletteInner({\n  customCommandPaletteItems,\n}: CommandPaletteProps) {\n  const app = useApp();\n  const uiAppState = useUIAppState();\n  const setAppState = useExcalidrawSetAppState();\n  const appProps = useAppProps();\n  const actionManager = useExcalidrawActionManager();\n\n  const [lastUsed, setLastUsed] = useAtom(lastUsedPaletteItem);\n  const [allCommands, setAllCommands] = useState<\n    MarkRequired<CommandPaletteItem, \"haystack\" | \"order\">[] | null\n  >(null);\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const stableDeps = useStable({\n    uiAppState,\n    customCommandPaletteItems,\n    appProps,\n  });\n\n  useEffect(() => {\n    // these props change often and we don't want them to re-run the effect\n    // which would renew `allCommands`, cascading down and resetting state.\n    //\n    // This means that the commands won't update on appState/appProps changes\n    // while the command palette is open\n    const { uiAppState, customCommandPaletteItems, appProps } = stableDeps;\n\n    const getActionLabel = (action: Action) => {\n      let label = \"\";\n      if (action.label) {\n        if (typeof action.label === \"function\") {\n          label = t(\n            action.label(\n              app.scene.getNonDeletedElements(),\n              uiAppState as AppState,\n              app,\n            ) as unknown as TranslationKeys,\n          );\n        } else {\n          label = t(action.label as unknown as TranslationKeys);\n        }\n      }\n      return label;\n    };\n\n    const getActionIcon = (action: Action) => {\n      if (typeof action.icon === \"function\") {\n        return action.icon(uiAppState, app.scene.getNonDeletedElements());\n      }\n      return action.icon;\n    };\n\n    let commandsFromActions: CommandPaletteItem[] = [];\n\n    const actionToCommand = (\n      action: Action,\n      category: string,\n      transformer?: (\n        command: CommandPaletteItem,\n        action: Action,\n      ) => CommandPaletteItem,\n    ): CommandPaletteItem => {\n      const command: CommandPaletteItem = {\n        label: getActionLabel(action),\n        icon: getActionIcon(action),\n        category,\n        shortcut: getShortcutFromShortcutName(action.name as ShortcutName),\n        keywords: action.keywords,\n        predicate: action.predicate,\n        viewMode: action.viewMode,\n        perform: () => {\n          actionManager.executeAction(action, \"commandPalette\");\n        },\n      };\n\n      return transformer ? transformer(command, action) : command;\n    };\n\n    if (uiAppState && app.scene && actionManager) {\n      const elementsCommands: CommandPaletteItem[] = [\n        actionManager.actions.group,\n        actionManager.actions.ungroup,\n        actionManager.actions.cut,\n        actionManager.actions.copy,\n        actionManager.actions.deleteSelectedElements,\n        actionManager.actions.wrapSelectionInFrame,\n        actionManager.actions.copyStyles,\n        actionManager.actions.pasteStyles,\n        actionManager.actions.bringToFront,\n        actionManager.actions.bringForward,\n        actionManager.actions.sendBackward,\n        actionManager.actions.sendToBack,\n        actionManager.actions.alignTop,\n        actionManager.actions.alignBottom,\n        actionManager.actions.alignLeft,\n        actionManager.actions.alignRight,\n        actionManager.actions.alignVerticallyCentered,\n        actionManager.actions.alignHorizontallyCentered,\n        actionManager.actions.duplicateSelection,\n        actionManager.actions.flipHorizontal,\n        actionManager.actions.flipVertical,\n        actionManager.actions.zoomToFitSelection,\n        actionManager.actions.zoomToFitSelectionInViewport,\n        actionManager.actions.increaseFontSize,\n        actionManager.actions.decreaseFontSize,\n        actionManager.actions.toggleLinearEditor,\n        actionManager.actions.cropEditor,\n        actionManager.actions.togglePolygon,\n        actionLink,\n        actionCopyElementLink,\n        actionLinkToElement,\n      ].map((action: Action) =>\n        actionToCommand(\n          action,\n          DEFAULT_CATEGORIES.elements,\n          (command, action) => ({\n            ...command,\n            predicate: action.predicate\n              ? action.predicate\n              : (elements, appState, appProps, app) => {\n                  const selectedElements = getSelectedElements(\n                    elements,\n                    appState,\n                  );\n                  return selectedElements.length > 0;\n                },\n          }),\n        ),\n      );\n      const toolCommands: CommandPaletteItem[] = [\n        actionManager.actions.toggleHandTool,\n        actionManager.actions.setFrameAsActiveTool,\n        actionManager.actions.toggleLassoTool,\n      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.tools));\n\n      const editorCommands: CommandPaletteItem[] = [\n        actionManager.actions.undo,\n        actionManager.actions.redo,\n        actionManager.actions.zoomIn,\n        actionManager.actions.zoomOut,\n        actionManager.actions.resetZoom,\n        actionManager.actions.zoomToFit,\n        actionManager.actions.zenMode,\n        actionManager.actions.viewMode,\n        actionManager.actions.gridMode,\n        actionManager.actions.objectsSnapMode,\n        actionManager.actions.toggleShortcuts,\n        actionManager.actions.selectAll,\n        actionManager.actions.toggleElementLock,\n        actionManager.actions.unlockAllElements,\n        actionManager.actions.stats,\n      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.editor));\n\n      const exportCommands: CommandPaletteItem[] = [\n        actionManager.actions.saveToActiveFile,\n        actionManager.actions.saveFileToDisk,\n        actionManager.actions.copyAsPng,\n        actionManager.actions.copyAsSvg,\n      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.export));\n\n      commandsFromActions = [\n        ...elementsCommands,\n        ...editorCommands,\n        {\n          label: getActionLabel(actionClearCanvas),\n          icon: getActionIcon(actionClearCanvas),\n          shortcut: getShortcutFromShortcutName(\n            actionClearCanvas.name as ShortcutName,\n          ),\n          category: DEFAULT_CATEGORIES.editor,\n          keywords: [\"delete\", \"destroy\"],\n          viewMode: false,\n          perform: () => {\n            editorJotaiStore.set(activeConfirmDialogAtom, \"clearCanvas\");\n          },\n        },\n        {\n          label: t(\"buttons.exportImage\"),\n          category: DEFAULT_CATEGORIES.export,\n          icon: ExportImageIcon,\n          shortcut: getShortcutFromShortcutName(\"imageExport\"),\n          keywords: [\n            \"export\",\n            \"image\",\n            \"png\",\n            \"jpeg\",\n            \"svg\",\n            \"clipboard\",\n            \"picture\",\n          ],\n          perform: () => {\n            setAppState({ openDialog: { name: \"imageExport\" } });\n          },\n        },\n        ...exportCommands,\n      ];\n\n      const additionalCommands: CommandPaletteItem[] = [\n        {\n          label: t(\"toolBar.library\"),\n          category: DEFAULT_CATEGORIES.app,\n          icon: LibraryIcon,\n          viewMode: false,\n          perform: () => {\n            if (uiAppState.openSidebar) {\n              setAppState({\n                openSidebar: null,\n              });\n            } else {\n              setAppState({\n                openSidebar: {\n                  name: DEFAULT_SIDEBAR.name,\n                  tab: DEFAULT_SIDEBAR.defaultTab,\n                },\n              });\n            }\n          },\n        },\n        {\n          label: t(\"search.title\"),\n          category: DEFAULT_CATEGORIES.app,\n          icon: searchIcon,\n          viewMode: true,\n          perform: () => {\n            actionManager.executeAction(actionToggleSearchMenu);\n          },\n        },\n        {\n          label: t(\"labels.shapeSwitch\"),\n          category: DEFAULT_CATEGORIES.elements,\n          icon: boltIcon,\n          perform: () => {\n            actionManager.executeAction(actionToggleShapeSwitch);\n          },\n        },\n        {\n          label: t(\"labels.changeStroke\"),\n          keywords: [\"color\", \"outline\"],\n          category: DEFAULT_CATEGORIES.elements,\n          icon: bucketFillIcon,\n          viewMode: false,\n          predicate: (elements, appState) => {\n            const selectedElements = getSelectedElements(elements, appState);\n            return (\n              selectedElements.length > 0 &&\n              canChangeStrokeColor(appState, selectedElements)\n            );\n          },\n          perform: () => {\n            setAppState((prevState) => ({\n              openMenu: prevState.openMenu === \"shape\" ? null : \"shape\",\n              openPopup: \"elementStroke\",\n            }));\n          },\n        },\n        {\n          label: t(\"labels.changeBackground\"),\n          keywords: [\"color\", \"fill\"],\n          icon: bucketFillIcon,\n          category: DEFAULT_CATEGORIES.elements,\n          viewMode: false,\n          predicate: (elements, appState) => {\n            const selectedElements = getSelectedElements(elements, appState);\n            return (\n              selectedElements.length > 0 &&\n              canChangeBackgroundColor(appState, selectedElements)\n            );\n          },\n          perform: () => {\n            setAppState((prevState) => ({\n              openMenu: prevState.openMenu === \"shape\" ? null : \"shape\",\n              openPopup: \"elementBackground\",\n            }));\n          },\n        },\n        {\n          label: t(\"labels.canvasBackground\"),\n          keywords: [\"color\"],\n          icon: bucketFillIcon,\n          category: DEFAULT_CATEGORIES.editor,\n          viewMode: false,\n          perform: () => {\n            setAppState((prevState) => ({\n              openMenu: prevState.openMenu === \"canvas\" ? null : \"canvas\",\n              openPopup: \"canvasBackground\",\n            }));\n          },\n        },\n        ...SHAPES.reduce((acc: CommandPaletteItem[], shape) => {\n          const { value, icon, key, numericKey } = shape;\n\n          if (\n            appProps.UIOptions.tools?.[\n              value as Extract<\n                typeof value,\n                keyof AppProps[\"UIOptions\"][\"tools\"]\n              >\n            ] === false\n          ) {\n            return acc;\n          }\n\n          const letter =\n            key && capitalizeString(typeof key === \"string\" ? key : key[0]);\n          const shortcut = letter || numericKey;\n\n          const command: CommandPaletteItem = {\n            label: t(`toolBar.${value}`),\n            category: DEFAULT_CATEGORIES.tools,\n            shortcut,\n            icon,\n            keywords: [\"toolbar\"],\n            viewMode: false,\n            perform: ({ event }) => {\n              if (value === \"image\") {\n                app.setActiveTool({\n                  type: value,\n                });\n              } else {\n                app.setActiveTool({ type: value });\n              }\n            },\n          };\n\n          acc.push(command);\n\n          return acc;\n        }, []),\n        ...toolCommands,\n        {\n          label: t(\"toolBar.lock\"),\n          category: DEFAULT_CATEGORIES.tools,\n          icon: uiAppState.activeTool.locked ? LockedIcon : UnlockedIcon,\n          shortcut: KEYS.Q.toLocaleUpperCase(),\n          viewMode: false,\n          perform: () => {\n            app.toggleLock();\n          },\n        },\n        {\n          label: `${t(\"labels.textToDiagram\")}...`,\n          category: DEFAULT_CATEGORIES.tools,\n          icon: brainIconThin,\n          viewMode: false,\n          predicate: appProps.aiEnabled,\n          perform: () => {\n            setAppState((state) => ({\n              ...state,\n              openDialog: {\n                name: \"ttd\",\n                tab: \"text-to-diagram\",\n              },\n            }));\n          },\n        },\n        {\n          label: `${t(\"toolBar.mermaidToExcalidraw\")}...`,\n          category: DEFAULT_CATEGORIES.tools,\n          icon: mermaidLogoIcon,\n          viewMode: false,\n          predicate: appProps.aiEnabled,\n          perform: () => {\n            setAppState((state) => ({\n              ...state,\n              openDialog: {\n                name: \"ttd\",\n                tab: \"mermaid\",\n              },\n            }));\n          },\n        },\n        // {\n        //   label: `${t(\"toolBar.magicframe\")}...`,\n        //   category: DEFAULT_CATEGORIES.tools,\n        //   icon: MagicIconThin,\n        //   viewMode: false,\n        //   predicate: appProps.aiEnabled,\n        //   perform: () => {\n        //     app.onMagicframeToolSelect();\n        //   },\n        // },\n      ];\n\n      const allCommands = [\n        ...commandsFromActions,\n        ...additionalCommands,\n        ...(customCommandPaletteItems || []),\n      ].map((command) => {\n        return {\n          ...command,\n          icon: command.icon || boltIcon,\n          order: command.order ?? getCategoryOrder(command.category),\n          haystack: `${deburr(command.label.toLocaleLowerCase())} ${\n            command.keywords?.join(\" \") || \"\"\n          }`,\n        };\n      });\n\n      setAllCommands(allCommands);\n      setLastUsed(\n        allCommands.find((command) => command.label === lastUsed?.label) ??\n          null,\n      );\n    }\n  }, [\n    stableDeps,\n    app,\n    actionManager,\n    setAllCommands,\n    lastUsed?.label,\n    setLastUsed,\n    setAppState,\n  ]);\n\n  const [commandSearch, setCommandSearch] = useState(\"\");\n  const [currentCommand, setCurrentCommand] =\n    useState<CommandPaletteItem | null>(null);\n  const [commandsByCategory, setCommandsByCategory] = useState<\n    Record<string, CommandPaletteItem[]>\n  >({});\n\n  const closeCommandPalette = (cb?: () => void) => {\n    setAppState(\n      {\n        openDialog: null,\n      },\n      cb,\n    );\n    setCommandSearch(\"\");\n  };\n\n  const executeCommand = (\n    command: CommandPaletteItem,\n    event: React.MouseEvent | React.KeyboardEvent | KeyboardEvent,\n  ) => {\n    if (uiAppState.openDialog?.name === \"commandPalette\") {\n      event.stopPropagation();\n      event.preventDefault();\n      document.body.classList.add(\"excalidraw-animations-disabled\");\n      closeCommandPalette(() => {\n        command.perform({ actionManager, event });\n        setLastUsed(command);\n\n        requestAnimationFrame(() => {\n          document.body.classList.remove(\"excalidraw-animations-disabled\");\n        });\n      });\n    }\n  };\n\n  const isCommandAvailable = useStableCallback(\n    (command: CommandPaletteItem) => {\n      if (command.viewMode === false && uiAppState.viewModeEnabled) {\n        return false;\n      }\n\n      return typeof command.predicate === \"function\"\n        ? command.predicate(\n            app.scene.getNonDeletedElements(),\n            uiAppState as AppState,\n            appProps,\n            app,\n          )\n        : command.predicate === undefined || command.predicate;\n    },\n  );\n\n  const handleKeyDown = useStableCallback((event: KeyboardEvent) => {\n    const ignoreAlphanumerics =\n      isWritableElement(event.target) ||\n      isCommandPaletteToggleShortcut(event) ||\n      event.key === KEYS.ESCAPE;\n\n    if (\n      ignoreAlphanumerics &&\n      event.key !== KEYS.ARROW_UP &&\n      event.key !== KEYS.ARROW_DOWN &&\n      event.key !== KEYS.ENTER\n    ) {\n      return;\n    }\n\n    const matchingCommands = Object.values(commandsByCategory).flat();\n    const shouldConsiderLastUsed =\n      lastUsed && !commandSearch && isCommandAvailable(lastUsed);\n\n    if (event.key === KEYS.ARROW_UP) {\n      event.preventDefault();\n      const index = matchingCommands.findIndex(\n        (item) => item.label === currentCommand?.label,\n      );\n\n      if (shouldConsiderLastUsed) {\n        if (index === 0) {\n          setCurrentCommand(lastUsed);\n          return;\n        }\n\n        if (currentCommand === lastUsed) {\n          const nextItem = matchingCommands[matchingCommands.length - 1];\n          if (nextItem) {\n            setCurrentCommand(nextItem);\n          }\n          return;\n        }\n      }\n\n      let nextIndex;\n\n      if (index === -1) {\n        nextIndex = matchingCommands.length - 1;\n      } else {\n        nextIndex =\n          index === 0\n            ? matchingCommands.length - 1\n            : (index - 1) % matchingCommands.length;\n      }\n\n      const nextItem = matchingCommands[nextIndex];\n      if (nextItem) {\n        setCurrentCommand(nextItem);\n      }\n\n      return;\n    }\n\n    if (event.key === KEYS.ARROW_DOWN) {\n      event.preventDefault();\n      const index = matchingCommands.findIndex(\n        (item) => item.label === currentCommand?.label,\n      );\n\n      if (shouldConsiderLastUsed) {\n        if (!currentCommand || index === matchingCommands.length - 1) {\n          setCurrentCommand(lastUsed);\n          return;\n        }\n\n        if (currentCommand === lastUsed) {\n          const nextItem = matchingCommands[0];\n          if (nextItem) {\n            setCurrentCommand(nextItem);\n          }\n          return;\n        }\n      }\n\n      const nextIndex = (index + 1) % matchingCommands.length;\n      const nextItem = matchingCommands[nextIndex];\n      if (nextItem) {\n        setCurrentCommand(nextItem);\n      }\n\n      return;\n    }\n\n    if (event.key === KEYS.ENTER) {\n      if (currentCommand) {\n        setTimeout(() => {\n          executeCommand(currentCommand, event);\n        });\n      }\n    }\n\n    if (ignoreAlphanumerics) {\n      return;\n    }\n\n    // prevent regular editor shortcuts\n    event.stopPropagation();\n\n    // if alphanumeric keypress and we're not inside the input, focus it\n    if (/^[a-zA-Z0-9]$/.test(event.key)) {\n      inputRef?.current?.focus();\n      return;\n    }\n\n    event.preventDefault();\n  });\n\n  useEffect(() => {\n    window.addEventListener(EVENT.KEYDOWN, handleKeyDown, {\n      capture: true,\n    });\n    return () =>\n      window.removeEventListener(EVENT.KEYDOWN, handleKeyDown, {\n        capture: true,\n      });\n  }, [handleKeyDown]);\n\n  useEffect(() => {\n    if (!allCommands) {\n      return;\n    }\n\n    const getNextCommandsByCategory = (commands: CommandPaletteItem[]) => {\n      const nextCommandsByCategory: Record<string, CommandPaletteItem[]> = {};\n      for (const command of commands) {\n        if (nextCommandsByCategory[command.category]) {\n          nextCommandsByCategory[command.category].push(command);\n        } else {\n          nextCommandsByCategory[command.category] = [command];\n        }\n      }\n\n      return nextCommandsByCategory;\n    };\n\n    let matchingCommands = allCommands\n      .filter(isCommandAvailable)\n      .sort((a, b) => a.order - b.order);\n\n    const showLastUsed =\n      !commandSearch && lastUsed && isCommandAvailable(lastUsed);\n\n    if (!commandSearch) {\n      setCommandsByCategory(\n        getNextCommandsByCategory(\n          showLastUsed\n            ? matchingCommands.filter(\n                (command) => command.label !== lastUsed?.label,\n              )\n            : matchingCommands,\n        ),\n      );\n      setCurrentCommand(showLastUsed ? lastUsed : matchingCommands[0] || null);\n      return;\n    }\n\n    const _query = deburr(\n      commandSearch.toLocaleLowerCase().replace(/[<>_| -]/g, \"\"),\n    );\n    matchingCommands = fuzzy\n      .filter(_query, matchingCommands, {\n        extract: (command) => command.haystack,\n      })\n      .sort((a, b) => b.score - a.score)\n      .map((item) => item.original);\n\n    setCommandsByCategory(getNextCommandsByCategory(matchingCommands));\n    setCurrentCommand(matchingCommands[0] ?? null);\n  }, [commandSearch, allCommands, isCommandAvailable, lastUsed]);\n\n  return (\n    <Dialog\n      onCloseRequest={() => closeCommandPalette()}\n      closeOnClickOutside\n      title={false}\n      size={720}\n      autofocus\n      className=\"command-palette-dialog\"\n    >\n      <TextField\n        value={commandSearch}\n        placeholder={t(\"commandPalette.search.placeholder\")}\n        onChange={(value) => {\n          setCommandSearch(value);\n        }}\n        selectOnRender\n        ref={inputRef}\n      />\n\n      {!app.device.viewport.isMobile && (\n        <div className=\"shortcuts-wrapper\">\n          <CommandShortcutHint shortcut=\"↑↓\">\n            {t(\"commandPalette.shortcuts.select\")}\n          </CommandShortcutHint>\n          <CommandShortcutHint shortcut=\"↵\">\n            {t(\"commandPalette.shortcuts.confirm\")}\n          </CommandShortcutHint>\n          <CommandShortcutHint shortcut={getShortcutKey(\"Esc\")}>\n            {t(\"commandPalette.shortcuts.close\")}\n          </CommandShortcutHint>\n        </div>\n      )}\n\n      <div className=\"commands\">\n        {lastUsed && !commandSearch && (\n          <div className=\"command-category\">\n            <div className=\"command-category-title\">\n              {t(\"commandPalette.recents\")}\n              <div\n                className=\"icon\"\n                style={{\n                  marginLeft: \"6px\",\n                }}\n              >\n                {clockIcon}\n              </div>\n            </div>\n            <CommandItem\n              command={lastUsed}\n              isSelected={lastUsed.label === currentCommand?.label}\n              onClick={(event) => executeCommand(lastUsed, event)}\n              disabled={!isCommandAvailable(lastUsed)}\n              onMouseMove={() => setCurrentCommand(lastUsed)}\n              showShortcut={!app.device.viewport.isMobile}\n              appState={uiAppState}\n            />\n          </div>\n        )}\n\n        {Object.keys(commandsByCategory).length > 0 ? (\n          Object.keys(commandsByCategory).map((category, idx) => {\n            return (\n              <div className=\"command-category\" key={category}>\n                <div className=\"command-category-title\">{category}</div>\n                {commandsByCategory[category].map((command) => (\n                  <CommandItem\n                    key={command.label}\n                    command={command}\n                    isSelected={command.label === currentCommand?.label}\n                    onClick={(event) => executeCommand(command, event)}\n                    onMouseMove={() => setCurrentCommand(command)}\n                    showShortcut={!app.device.viewport.isMobile}\n                    appState={uiAppState}\n                  />\n                ))}\n              </div>\n            );\n          })\n        ) : allCommands ? (\n          <div className=\"no-match\">\n            <div className=\"icon\">{searchIcon}</div>{\" \"}\n            {t(\"commandPalette.search.noMatch\")}\n          </div>\n        ) : null}\n      </div>\n    </Dialog>\n  );\n}\n\nconst CommandItem = ({\n  command,\n  isSelected,\n  disabled,\n  onMouseMove,\n  onClick,\n  showShortcut,\n  appState,\n}: {\n  command: CommandPaletteItem;\n  isSelected: boolean;\n  disabled?: boolean;\n  onMouseMove: () => void;\n  onClick: (event: React.MouseEvent) => void;\n  showShortcut: boolean;\n  appState: UIAppState;\n}) => {\n  const noop = () => {};\n\n  return (\n    <div\n      className={clsx(\"command-item\", {\n        \"item-selected\": isSelected,\n        \"item-disabled\": disabled,\n      })}\n      ref={(ref) => {\n        if (isSelected && !disabled) {\n          ref?.scrollIntoView?.({\n            block: \"nearest\",\n          });\n        }\n      }}\n      onClick={disabled ? noop : onClick}\n      onMouseMove={disabled ? noop : onMouseMove}\n      title={disabled ? t(\"commandPalette.itemNotAvailable\") : \"\"}\n    >\n      <div className=\"name\">\n        {command.icon && (\n          <InlineIcon\n            icon={\n              typeof command.icon === \"function\"\n                ? command.icon(appState)\n                : command.icon\n            }\n          />\n        )}\n        {command.label}\n      </div>\n      {showShortcut && command.shortcut && (\n        <CommandShortcutHint shortcut={command.shortcut} />\n      )}\n    </div>\n  );\n};\n",
    "import { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport {\n  getConversionTypeFromElements,\n  convertElementTypePopupAtom,\n} from \"../components/ConvertElementTypePopup\";\nimport { editorJotaiStore } from \"../editor-jotai\";\n\nimport { register } from \"./register\";\n\nexport const actionToggleShapeSwitch = register({\n  name: \"toggleShapeSwitch\",\n  label: \"labels.shapeSwitch\",\n  icon: () => null,\n  viewMode: true,\n  trackEvent: {\n    category: \"shape_switch\",\n    action: \"toggle\",\n  },\n  keywords: [\"change\", \"switch\", \"swap\"],\n  perform(elements, appState, _, app) {\n    editorJotaiStore.set(convertElementTypePopupAtom, {\n      type: \"panel\",\n    });\n\n    return {\n      captureUpdate: CaptureUpdateAction.NEVER,\n    };\n  },\n  checked: (appState) => appState.gridModeEnabled,\n  predicate: (elements, appState, props) =>\n    getConversionTypeFromElements(elements as ExcalidrawElement[]) !== null,\n});\n",
    "import { type ReactNode, useEffect, useMemo, useRef, useState } from \"react\";\n\nimport {\n  getLinearElementSubType,\n  updateElbowArrowPoints,\n} from \"@excalidraw/element\";\n\nimport { pointFrom, pointRotateRads, type LocalPoint } from \"@excalidraw/math\";\n\nimport {\n  hasBoundTextElement,\n  isArrowBoundToElement,\n  isArrowElement,\n  isElbowArrow,\n  isLinearElement,\n  isUsingAdaptiveRadius,\n} from \"@excalidraw/element\";\n\nimport {\n  getCommonBoundingBox,\n  getElementAbsoluteCoords,\n} from \"@excalidraw/element\";\n\nimport {\n  getBoundTextElement,\n  getBoundTextMaxHeight,\n  getBoundTextMaxWidth,\n  redrawTextBoundingBox,\n} from \"@excalidraw/element\";\n\nimport { wrapText } from \"@excalidraw/element\";\n\nimport {\n  assertNever,\n  CLASSES,\n  getFontString,\n  isProdEnv,\n  mapFind,\n  reduceToCommonValue,\n  updateActiveTool,\n} from \"@excalidraw/common\";\n\nimport { measureText } from \"@excalidraw/element\";\n\nimport { LinearElementEditor } from \"@excalidraw/element\";\n\nimport {\n  newArrowElement,\n  newElement,\n  newLinearElement,\n} from \"@excalidraw/element\";\n\nimport { ShapeCache } from \"@excalidraw/element\";\n\nimport { updateBindings } from \"@excalidraw/element\";\n\nimport type {\n  ConvertibleGenericTypes,\n  ConvertibleLinearTypes,\n  ConvertibleTypes,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawSelectionElement,\n  ExcalidrawTextContainer,\n  ExcalidrawTextElementWithContainer,\n  FixedSegment,\n} from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport {\n  bumpVersion,\n  mutateElement,\n  ROUNDNESS,\n  sceneCoordsToViewportCoords,\n} from \"..\";\nimport { trackEvent } from \"../analytics\";\nimport { atom } from \"../editor-jotai\";\n\nimport \"./ConvertElementTypePopup.scss\";\nimport { ToolButton } from \"./ToolButton\";\nimport {\n  DiamondIcon,\n  elbowArrowIcon,\n  EllipseIcon,\n  LineIcon,\n  RectangleIcon,\n  roundArrowIcon,\n  sharpArrowIcon,\n} from \"./icons\";\n\nimport type App from \"./App\";\n\nimport type { AppClassProperties } from \"../types\";\n\nconst GAP_HORIZONTAL = 8;\nconst GAP_VERTICAL = 10;\n\ntype ExcalidrawConvertibleElement =\n  | ExcalidrawRectangleElement\n  | ExcalidrawDiamondElement\n  | ExcalidrawEllipseElement\n  | ExcalidrawLinearElement;\n\n// indicates order of switching\nconst GENERIC_TYPES = [\"rectangle\", \"diamond\", \"ellipse\"] as const;\n// indicates order of switching\nconst LINEAR_TYPES = [\n  \"line\",\n  \"sharpArrow\",\n  \"curvedArrow\",\n  \"elbowArrow\",\n] as const;\n\nconst CONVERTIBLE_GENERIC_TYPES: ReadonlySet<ConvertibleGenericTypes> = new Set(\n  GENERIC_TYPES,\n);\n\nconst CONVERTIBLE_LINEAR_TYPES: ReadonlySet<ConvertibleLinearTypes> = new Set(\n  LINEAR_TYPES,\n);\n\nconst isConvertibleGenericType = (\n  elementType: string,\n): elementType is ConvertibleGenericTypes =>\n  CONVERTIBLE_GENERIC_TYPES.has(elementType as ConvertibleGenericTypes);\n\nconst isConvertibleLinearType = (\n  elementType: string,\n): elementType is ConvertibleLinearTypes =>\n  elementType === \"arrow\" ||\n  CONVERTIBLE_LINEAR_TYPES.has(elementType as ConvertibleLinearTypes);\n\nexport const convertElementTypePopupAtom = atom<{\n  type: \"panel\";\n} | null>(null);\n\ntype CacheKey = string & { _brand: \"CacheKey\" };\n\nconst FONT_SIZE_CONVERSION_CACHE = new Map<\n  ExcalidrawElement[\"id\"],\n  {\n    fontSize: number;\n  }\n>();\n\nconst LINEAR_ELEMENT_CONVERSION_CACHE = new Map<\n  CacheKey,\n  ExcalidrawLinearElement\n>();\n\nconst ConvertElementTypePopup = ({ app }: { app: App }) => {\n  const selectedElements = app.scene.getSelectedElements(app.state);\n  const elementsCategoryRef = useRef<ConversionType>(null);\n\n  // close shape switch panel if selecting different \"types\" of elements\n  useEffect(() => {\n    if (selectedElements.length === 0) {\n      app.updateEditorAtom(convertElementTypePopupAtom, null);\n      return;\n    }\n\n    const conversionType = getConversionTypeFromElements(selectedElements);\n\n    if (conversionType && !elementsCategoryRef.current) {\n      elementsCategoryRef.current = conversionType;\n    } else if (\n      (elementsCategoryRef.current && !conversionType) ||\n      (elementsCategoryRef.current &&\n        conversionType !== elementsCategoryRef.current)\n    ) {\n      app.updateEditorAtom(convertElementTypePopupAtom, null);\n      elementsCategoryRef.current = null;\n    }\n  }, [selectedElements, app]);\n\n  useEffect(() => {\n    return () => {\n      FONT_SIZE_CONVERSION_CACHE.clear();\n      LINEAR_ELEMENT_CONVERSION_CACHE.clear();\n    };\n  }, []);\n\n  return <Panel app={app} elements={selectedElements} />;\n};\n\nconst Panel = ({\n  app,\n  elements,\n}: {\n  app: App;\n  elements: ExcalidrawElement[];\n}) => {\n  const conversionType = getConversionTypeFromElements(elements);\n\n  const genericElements = useMemo(() => {\n    return conversionType === \"generic\"\n      ? filterGenericConvetibleElements(elements)\n      : [];\n  }, [conversionType, elements]);\n  const linearElements = useMemo(() => {\n    return conversionType === \"linear\"\n      ? filterLinearConvertibleElements(elements)\n      : [];\n  }, [conversionType, elements]);\n\n  const sameType =\n    conversionType === \"generic\"\n      ? genericElements.every(\n          (element) => element.type === genericElements[0].type,\n        )\n      : conversionType === \"linear\"\n      ? linearElements.every(\n          (element) =>\n            getLinearElementSubType(element) ===\n            getLinearElementSubType(linearElements[0]),\n        )\n      : false;\n\n  const [panelPosition, setPanelPosition] = useState({ x: 0, y: 0 });\n  const positionRef = useRef(\"\");\n  const panelRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const elements = [...genericElements, ...linearElements].sort((a, b) =>\n      a.id.localeCompare(b.id),\n    );\n    const newPositionRef = `\n      ${app.state.scrollX}${app.state.scrollY}${app.state.offsetTop}${\n      app.state.offsetLeft\n    }${app.state.zoom.value}${elements.map((el) => el.id).join(\",\")}`;\n\n    if (newPositionRef === positionRef.current) {\n      return;\n    }\n\n    positionRef.current = newPositionRef;\n\n    let bottomLeft;\n\n    if (elements.length === 1) {\n      const [x1, , , y2, cx, cy] = getElementAbsoluteCoords(\n        elements[0],\n        app.scene.getNonDeletedElementsMap(),\n      );\n      bottomLeft = pointRotateRads(\n        pointFrom(x1, y2),\n        pointFrom(cx, cy),\n        elements[0].angle,\n      );\n    } else {\n      const { minX, maxY } = getCommonBoundingBox(elements);\n      bottomLeft = pointFrom(minX, maxY);\n    }\n\n    const { x, y } = sceneCoordsToViewportCoords(\n      { sceneX: bottomLeft[0], sceneY: bottomLeft[1] },\n      app.state,\n    );\n\n    setPanelPosition({ x, y });\n  }, [genericElements, linearElements, app.scene, app.state]);\n\n  useEffect(() => {\n    for (const linearElement of linearElements) {\n      const cacheKey = toCacheKey(\n        linearElement.id,\n        getConvertibleType(linearElement),\n      );\n      if (!LINEAR_ELEMENT_CONVERSION_CACHE.has(cacheKey)) {\n        LINEAR_ELEMENT_CONVERSION_CACHE.set(cacheKey, linearElement);\n      }\n    }\n  }, [linearElements]);\n\n  useEffect(() => {\n    for (const element of genericElements) {\n      if (!FONT_SIZE_CONVERSION_CACHE.has(element.id)) {\n        const boundText = getBoundTextElement(\n          element,\n          app.scene.getNonDeletedElementsMap(),\n        );\n        if (boundText) {\n          FONT_SIZE_CONVERSION_CACHE.set(element.id, {\n            fontSize: boundText.fontSize,\n          });\n        }\n      }\n    }\n  }, [genericElements, app.scene]);\n\n  const SHAPES: [string, ReactNode][] =\n    conversionType === \"linear\"\n      ? [\n          [\"line\", LineIcon],\n          [\"sharpArrow\", sharpArrowIcon],\n          [\"curvedArrow\", roundArrowIcon],\n          [\"elbowArrow\", elbowArrowIcon],\n        ]\n      : conversionType === \"generic\"\n      ? [\n          [\"rectangle\", RectangleIcon],\n          [\"diamond\", DiamondIcon],\n          [\"ellipse\", EllipseIcon],\n        ]\n      : [];\n\n  return (\n    <div\n      ref={panelRef}\n      tabIndex={-1}\n      style={{\n        position: \"absolute\",\n        top: `${\n          panelPosition.y +\n          (GAP_VERTICAL + 8) * app.state.zoom.value -\n          app.state.offsetTop\n        }px`,\n        left: `${panelPosition.x - app.state.offsetLeft - GAP_HORIZONTAL}px`,\n        zIndex: 2,\n      }}\n      className={CLASSES.CONVERT_ELEMENT_TYPE_POPUP}\n    >\n      {SHAPES.map(([type, icon]) => {\n        const isSelected =\n          sameType &&\n          ((conversionType === \"generic\" && genericElements[0].type === type) ||\n            (conversionType === \"linear\" &&\n              getLinearElementSubType(linearElements[0]) === type));\n\n        return (\n          <ToolButton\n            className=\"Shape\"\n            key={`${elements[0].id}${elements[0].version}_${type}`}\n            type=\"radio\"\n            icon={icon}\n            checked={isSelected}\n            name=\"convertElementType-option\"\n            title={type}\n            keyBindingLabel={\"\"}\n            aria-label={type}\n            data-testid={`toolbar-${type}`}\n            onChange={() => {\n              if (app.state.activeTool.type !== type) {\n                trackEvent(\"convertElementType\", type, \"ui\");\n              }\n              convertElementTypes(app, {\n                conversionType,\n                nextType: type as\n                  | ConvertibleGenericTypes\n                  | ConvertibleLinearTypes,\n              });\n              panelRef.current?.focus();\n            }}\n          />\n        );\n      })}\n    </div>\n  );\n};\n\nexport const adjustBoundTextSize = (\n  container: ExcalidrawTextContainer,\n  boundText: ExcalidrawTextElementWithContainer,\n  scene: Scene,\n) => {\n  const maxWidth = getBoundTextMaxWidth(container, boundText);\n  const maxHeight = getBoundTextMaxHeight(container, boundText);\n\n  const wrappedText = wrapText(\n    boundText.text,\n    getFontString(boundText),\n    maxWidth,\n  );\n\n  let metrics = measureText(\n    wrappedText,\n    getFontString(boundText),\n    boundText.lineHeight,\n  );\n\n  let nextFontSize = boundText.fontSize;\n  while (\n    (metrics.width > maxWidth || metrics.height > maxHeight) &&\n    nextFontSize > 0\n  ) {\n    nextFontSize -= 1;\n    const _updatedTextElement = {\n      ...boundText,\n      fontSize: nextFontSize,\n    };\n    metrics = measureText(\n      boundText.text,\n      getFontString(_updatedTextElement),\n      boundText.lineHeight,\n    );\n  }\n\n  mutateElement(boundText, scene.getNonDeletedElementsMap(), {\n    fontSize: nextFontSize,\n    width: metrics.width,\n    height: metrics.height,\n  });\n\n  redrawTextBoundingBox(boundText, container, scene);\n};\n\ntype ConversionType = \"generic\" | \"linear\" | null;\n\nexport const convertElementTypes = (\n  app: App,\n  {\n    conversionType,\n    nextType,\n    direction = \"right\",\n  }: {\n    conversionType: ConversionType;\n    nextType?: ConvertibleTypes;\n    direction?: \"left\" | \"right\";\n  },\n): boolean => {\n  if (!conversionType) {\n    return false;\n  }\n\n  const selectedElements = app.scene.getSelectedElements(app.state);\n\n  const selectedElementIds = selectedElements.reduce(\n    (acc, element) => ({ ...acc, [element.id]: true }),\n    {},\n  );\n\n  const advancement = direction === \"right\" ? 1 : -1;\n\n  if (conversionType === \"generic\") {\n    const convertibleGenericElements =\n      filterGenericConvetibleElements(selectedElements);\n\n    const sameType = convertibleGenericElements.every(\n      (element) => element.type === convertibleGenericElements[0].type,\n    );\n\n    const index = sameType\n      ? GENERIC_TYPES.indexOf(convertibleGenericElements[0].type)\n      : -1;\n\n    nextType =\n      nextType ??\n      GENERIC_TYPES[\n        (index + GENERIC_TYPES.length + advancement) % GENERIC_TYPES.length\n      ];\n\n    if (nextType && isConvertibleGenericType(nextType)) {\n      const convertedElements: Record<string, ExcalidrawElement> = {};\n\n      for (const element of convertibleGenericElements) {\n        const convertedElement = convertElementType(element, nextType, app);\n        convertedElements[convertedElement.id] = convertedElement;\n      }\n\n      const nextElements = [];\n\n      for (const element of app.scene.getElementsIncludingDeleted()) {\n        if (convertedElements[element.id]) {\n          nextElements.push(convertedElements[element.id]);\n        } else {\n          nextElements.push(element);\n        }\n      }\n\n      app.scene.replaceAllElements(nextElements);\n\n      for (const element of Object.values(convertedElements)) {\n        const boundText = getBoundTextElement(\n          element,\n          app.scene.getNonDeletedElementsMap(),\n        );\n        if (boundText) {\n          if (FONT_SIZE_CONVERSION_CACHE.get(element.id)) {\n            mutateElement(boundText, app.scene.getNonDeletedElementsMap(), {\n              fontSize:\n                FONT_SIZE_CONVERSION_CACHE.get(element.id)?.fontSize ??\n                boundText.fontSize,\n            });\n          }\n\n          adjustBoundTextSize(\n            element as ExcalidrawTextContainer,\n            boundText,\n            app.scene,\n          );\n        }\n      }\n\n      app.setState((prevState) => {\n        return {\n          selectedElementIds,\n          activeTool: updateActiveTool(prevState, {\n            type: \"selection\",\n          }),\n        };\n      });\n    }\n  }\n\n  if (conversionType === \"linear\") {\n    const convertibleLinearElements = filterLinearConvertibleElements(\n      selectedElements,\n    ) as ExcalidrawLinearElement[];\n\n    if (!nextType) {\n      const commonSubType = reduceToCommonValue(\n        convertibleLinearElements,\n        getLinearElementSubType,\n      );\n\n      const index = commonSubType ? LINEAR_TYPES.indexOf(commonSubType) : -1;\n      nextType =\n        LINEAR_TYPES[\n          (index + LINEAR_TYPES.length + advancement) % LINEAR_TYPES.length\n        ];\n    }\n\n    if (isConvertibleLinearType(nextType)) {\n      const convertedElements: ExcalidrawElement[] = [];\n\n      const nextElementsMap: Map<ExcalidrawElement[\"id\"], ExcalidrawElement> =\n        app.scene.getElementsMapIncludingDeleted();\n\n      for (const element of convertibleLinearElements) {\n        const cachedElement = LINEAR_ELEMENT_CONVERSION_CACHE.get(\n          toCacheKey(element.id, nextType),\n        );\n\n        // if switching to the original subType or a subType we've already\n        // converted to, reuse the cached element to get the original properties\n        // (needed for simple->elbow->simple conversions or between line\n        // and arrows)\n        if (\n          cachedElement &&\n          getLinearElementSubType(cachedElement) === nextType\n        ) {\n          nextElementsMap.set(cachedElement.id, cachedElement);\n          convertedElements.push(cachedElement);\n        } else {\n          const converted = convertElementType(element, nextType, app);\n          nextElementsMap.set(converted.id, converted);\n          convertedElements.push(converted);\n        }\n      }\n\n      app.scene.replaceAllElements(nextElementsMap);\n\n      // post normalization\n      for (const element of convertedElements) {\n        if (isLinearElement(element)) {\n          if (isElbowArrow(element)) {\n            const nextPoints = convertLineToElbow(element);\n            if (nextPoints.length < 2) {\n              // skip if not enough points to form valid segments\n              continue;\n            }\n            const fixedSegments: FixedSegment[] = [];\n            for (let i = 1; i < nextPoints.length - 2; i++) {\n              fixedSegments.push({\n                start: nextPoints[i],\n                end: nextPoints[i + 1],\n                index: i + 1,\n              });\n            }\n            const updates = updateElbowArrowPoints(\n              element,\n              app.scene.getNonDeletedElementsMap(),\n              {\n                points: nextPoints,\n                fixedSegments,\n              },\n            );\n            mutateElement(element, app.scene.getNonDeletedElementsMap(), {\n              ...updates,\n              endArrowhead: \"arrow\",\n            });\n          } else {\n            // if we're converting to non-elbow linear element, check if\n            // we've already cached one of these linear elements so we can\n            // reuse the points (case: curved->elbow->line and similar)\n\n            const similarCachedLinearElement = mapFind(\n              [\"line\", \"sharpArrow\", \"curvedArrow\"] as const,\n              (type) =>\n                LINEAR_ELEMENT_CONVERSION_CACHE.get(\n                  toCacheKey(element.id, type),\n                ),\n            );\n\n            if (similarCachedLinearElement) {\n              const points = similarCachedLinearElement.points;\n              app.scene.mutateElement(element, {\n                points,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    const convertedSelectedLinearElements = filterLinearConvertibleElements(\n      app.scene.getSelectedElements(app.state),\n    );\n\n    app.setState((prevState) => ({\n      selectedElementIds,\n      selectedLinearElement:\n        convertedSelectedLinearElements.length === 1\n          ? new LinearElementEditor(\n              convertedSelectedLinearElements[0],\n              app.scene.getNonDeletedElementsMap(),\n            )\n          : null,\n      activeTool: updateActiveTool(prevState, {\n        type: \"selection\",\n      }),\n    }));\n  }\n\n  return true;\n};\n\nexport const getConversionTypeFromElements = (\n  elements: ExcalidrawElement[],\n): ConversionType => {\n  if (elements.length === 0) {\n    return null;\n  }\n\n  let canBeLinear = false;\n  for (const element of elements) {\n    if (isConvertibleGenericType(element.type)) {\n      // generic type conversion have preference\n      return \"generic\";\n    }\n    if (isEligibleLinearElement(element)) {\n      canBeLinear = true;\n    }\n  }\n\n  if (canBeLinear) {\n    return \"linear\";\n  }\n\n  return null;\n};\n\nconst isEligibleLinearElement = (element: ExcalidrawElement) => {\n  return (\n    isLinearElement(element) &&\n    (!isArrowElement(element) ||\n      (!isArrowBoundToElement(element) && !hasBoundTextElement(element)))\n  );\n};\n\nconst toCacheKey = (\n  elementId: ExcalidrawElement[\"id\"],\n  convertitleType: ConvertibleTypes,\n) => {\n  return `${elementId}:${convertitleType}` as CacheKey;\n};\n\nconst filterGenericConvetibleElements = (elements: ExcalidrawElement[]) =>\n  elements.filter((element) => isConvertibleGenericType(element.type)) as Array<\n    | ExcalidrawRectangleElement\n    | ExcalidrawDiamondElement\n    | ExcalidrawEllipseElement\n  >;\n\nconst filterLinearConvertibleElements = (elements: ExcalidrawElement[]) =>\n  elements.filter((element) =>\n    isEligibleLinearElement(element),\n  ) as ExcalidrawLinearElement[];\n\nconst THRESHOLD = 20;\nconst isVert = (a: LocalPoint, b: LocalPoint) => a[0] === b[0];\nconst isHorz = (a: LocalPoint, b: LocalPoint) => a[1] === b[1];\nconst dist = (a: LocalPoint, b: LocalPoint) =>\n  isVert(a, b) ? Math.abs(a[1] - b[1]) : Math.abs(a[0] - b[0]);\n\nconst convertLineToElbow = (line: ExcalidrawLinearElement): LocalPoint[] => {\n  // 1. build an *orthogonal* route, snapping offsets < SNAP\n  const ortho: LocalPoint[] = [line.points[0]];\n  const src = sanitizePoints(line.points);\n\n  for (let i = 1; i < src.length; ++i) {\n    const start = ortho[ortho.length - 1];\n    const end = [...src[i]] as LocalPoint; // clone\n\n    // snap tiny offsets onto the current axis\n    if (Math.abs(end[0] - start[0]) < THRESHOLD) {\n      end[0] = start[0];\n    } else if (Math.abs(end[1] - start[1]) < THRESHOLD) {\n      end[1] = start[1];\n    }\n\n    // straight or needs a 90 ° bend?\n    if (isVert(start, end) || isHorz(start, end)) {\n      ortho.push(end);\n    } else {\n      ortho.push(pointFrom<LocalPoint>(start[0], end[1]));\n      ortho.push(end);\n    }\n  }\n\n  // 2. drop obviously colinear middle points\n  const trimmed: LocalPoint[] = [ortho[0]];\n  for (let i = 1; i < ortho.length - 1; ++i) {\n    if (\n      !(\n        (isVert(ortho[i - 1], ortho[i]) && isVert(ortho[i], ortho[i + 1])) ||\n        (isHorz(ortho[i - 1], ortho[i]) && isHorz(ortho[i], ortho[i + 1]))\n      )\n    ) {\n      trimmed.push(ortho[i]);\n    }\n  }\n  trimmed.push(ortho[ortho.length - 1]);\n\n  // 3. collapse micro “jogs” (V-H-V / H-V-H whose short leg < SNAP)\n  const clean: LocalPoint[] = [trimmed[0]];\n  for (let i = 1; i < trimmed.length - 1; ++i) {\n    const a = clean[clean.length - 1];\n    const b = trimmed[i];\n    const c = trimmed[i + 1];\n\n    const v1 = isVert(a, b);\n    const v2 = isVert(b, c);\n    if (v1 !== v2) {\n      const d1 = dist(a, b);\n      const d2 = dist(b, c);\n\n      if (d1 < THRESHOLD || d2 < THRESHOLD) {\n        // pick the shorter leg to remove\n        if (d2 < d1) {\n          // … absorb leg 2 – pull *c* onto axis of *a-b*\n          if (v1) {\n            c[0] = a[0];\n          } else {\n            c[1] = a[1];\n          }\n        } else {\n          // … absorb leg 1 – slide the whole first leg onto *b-c* axis\n          // eslint-disable-next-line no-lonely-if\n          if (v2) {\n            for (\n              let k = clean.length - 1;\n              k >= 0 && clean[k][0] === a[0];\n              --k\n            ) {\n              clean[k][0] = b[0];\n            }\n          } else {\n            for (\n              let k = clean.length - 1;\n              k >= 0 && clean[k][1] === a[1];\n              --k\n            ) {\n              clean[k][1] = b[1];\n            }\n          }\n        }\n        // *b* is gone, don’t add it\n        continue;\n      }\n    }\n    clean.push(b);\n  }\n  clean.push(trimmed[trimmed.length - 1]);\n  return clean;\n};\n\nconst sanitizePoints = (points: readonly LocalPoint[]): LocalPoint[] => {\n  if (points.length === 0) {\n    return [];\n  }\n\n  const sanitized: LocalPoint[] = [points[0]];\n\n  for (let i = 1; i < points.length; i++) {\n    const [x1, y1] = sanitized[sanitized.length - 1];\n    const [x2, y2] = points[i];\n\n    if (x1 !== x2 || y1 !== y2) {\n      sanitized.push(points[i]);\n    }\n  }\n\n  return sanitized;\n};\n\n/**\n * Converts an element to a new type, adding or removing properties as needed\n * so that the element object is always valid.\n *\n * Valid conversions at this point:\n * - switching between generic elements\n *   e.g. rectangle -> diamond\n * - switching between linear elements\n *   e.g. elbow arrow -> line\n */\nconst convertElementType = <\n  TElement extends Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n>(\n  element: TElement,\n  targetType: ConvertibleTypes,\n  app: AppClassProperties,\n): ExcalidrawElement => {\n  if (!isValidConversion(element.type, targetType)) {\n    if (!isProdEnv()) {\n      throw Error(`Invalid conversion from ${element.type} to ${targetType}.`);\n    }\n    return element;\n  }\n\n  if (element.type === targetType) {\n    return element;\n  }\n\n  ShapeCache.delete(element);\n\n  if (isConvertibleGenericType(targetType)) {\n    const nextElement = bumpVersion(\n      newElement({\n        ...element,\n        type: targetType,\n        roundness:\n          targetType === \"diamond\" && element.roundness\n            ? {\n                type: isUsingAdaptiveRadius(targetType)\n                  ? ROUNDNESS.ADAPTIVE_RADIUS\n                  : ROUNDNESS.PROPORTIONAL_RADIUS,\n              }\n            : element.roundness,\n      }),\n    ) as typeof element;\n\n    updateBindings(nextElement, app.scene);\n\n    return nextElement;\n  }\n\n  if (isConvertibleLinearType(targetType)) {\n    switch (targetType) {\n      case \"line\": {\n        return bumpVersion(\n          newLinearElement({\n            ...element,\n            type: \"line\",\n          }),\n        );\n      }\n      case \"sharpArrow\": {\n        return bumpVersion(\n          newArrowElement({\n            ...element,\n            type: \"arrow\",\n            elbowed: false,\n            roundness: null,\n            startArrowhead: app.state.currentItemStartArrowhead,\n            endArrowhead: app.state.currentItemEndArrowhead,\n          }),\n        );\n      }\n      case \"curvedArrow\": {\n        return bumpVersion(\n          newArrowElement({\n            ...element,\n            type: \"arrow\",\n            elbowed: false,\n            roundness: {\n              type: ROUNDNESS.PROPORTIONAL_RADIUS,\n            },\n            startArrowhead: app.state.currentItemStartArrowhead,\n            endArrowhead: app.state.currentItemEndArrowhead,\n          }),\n        );\n      }\n      case \"elbowArrow\": {\n        return bumpVersion(\n          newArrowElement({\n            ...element,\n            type: \"arrow\",\n            elbowed: true,\n            fixedSegments: null,\n            roundness: null,\n          }),\n        );\n      }\n    }\n  }\n\n  assertNever(targetType, `unhandled conversion type: ${targetType}`);\n\n  return element;\n};\n\nconst isValidConversion = (\n  startType: string,\n  targetType: ConvertibleTypes,\n): startType is ConvertibleTypes => {\n  if (\n    isConvertibleGenericType(startType) &&\n    isConvertibleGenericType(targetType)\n  ) {\n    return true;\n  }\n\n  if (\n    isConvertibleLinearType(startType) &&\n    isConvertibleLinearType(targetType)\n  ) {\n    return true;\n  }\n\n  // NOTE: add more conversions when needed\n\n  return false;\n};\n\nconst getConvertibleType = (\n  element: ExcalidrawConvertibleElement,\n): ConvertibleTypes => {\n  if (isLinearElement(element)) {\n    return getLinearElementSubType(element);\n  }\n  return element.type;\n};\n\nexport default ConvertElementTypePopup;\n",
    "import {\n  canCreateLinkFromElements,\n  defaultGetElementLinkFromSelection,\n  getLinkIdAndTypeFromSelection,\n} from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { copyTextToSystemClipboard } from \"../clipboard\";\nimport { copyIcon, elementLinkIcon } from \"../components/icons\";\nimport { t } from \"../i18n\";\nimport { getSelectedElements } from \"../scene\";\n\nimport { register } from \"./register\";\n\nexport const actionCopyElementLink = register({\n  name: \"copyElementLink\",\n  label: \"labels.copyElementLink\",\n  icon: copyIcon,\n  trackEvent: { category: \"element\" },\n  perform: async (elements, appState, _, app) => {\n    const selectedElements = getSelectedElements(elements, appState);\n\n    try {\n      if (window.location) {\n        const idAndType = getLinkIdAndTypeFromSelection(\n          selectedElements,\n          appState,\n        );\n\n        if (idAndType) {\n          await copyTextToSystemClipboard(\n            app.props.generateLinkForSelection\n              ? app.props.generateLinkForSelection(idAndType.id, idAndType.type)\n              : defaultGetElementLinkFromSelection(\n                  idAndType.id,\n                  idAndType.type,\n                ),\n          );\n\n          return {\n            appState: {\n              toast: {\n                message: t(\"toast.elementLinkCopied\"),\n                closable: true,\n              },\n            },\n            captureUpdate: CaptureUpdateAction.EVENTUALLY,\n          };\n        }\n        return {\n          appState,\n          elements,\n          app,\n          captureUpdate: CaptureUpdateAction.EVENTUALLY,\n        };\n      }\n    } catch (error: any) {\n      console.error(error);\n    }\n\n    return {\n      appState,\n      elements,\n      app,\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  predicate: (elements, appState) =>\n    canCreateLinkFromElements(getSelectedElements(elements, appState)),\n});\n\nexport const actionLinkToElement = register({\n  name: \"linkToElement\",\n  label: \"labels.linkToElement\",\n  icon: elementLinkIcon,\n  perform: (elements, appState, _, app) => {\n    const selectedElements = getSelectedElements(elements, appState);\n\n    if (\n      selectedElements.length !== 1 ||\n      !canCreateLinkFromElements(selectedElements)\n    ) {\n      return {\n        elements,\n        appState,\n        app,\n        captureUpdate: CaptureUpdateAction.EVENTUALLY,\n      };\n    }\n\n    return {\n      appState: {\n        ...appState,\n        openDialog: {\n          name: \"elementLinkSelector\",\n          sourceElementId: getSelectedElements(elements, appState)[0].id,\n        },\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  predicate: (elements, appState, appProps, app) => {\n    const selectedElements = getSelectedElements(elements, appState);\n\n    return (\n      appState.openDialog?.name !== \"elementLinkSelector\" &&\n      selectedElements.length === 1 &&\n      canCreateLinkFromElements(selectedElements)\n    );\n  },\n  trackEvent: false,\n});\n",
    "import { isDarwin, getShortcutKey } from \"@excalidraw/common\";\n\nimport type { SubtypeOf } from \"@excalidraw/common/utility-types\";\n\nimport { t } from \"../i18n\";\n\nimport type { ActionName } from \"./types\";\n\nexport type ShortcutName =\n  | SubtypeOf<\n      ActionName,\n      | \"toggleTheme\"\n      | \"loadScene\"\n      | \"clearCanvas\"\n      | \"cut\"\n      | \"copy\"\n      | \"paste\"\n      | \"copyStyles\"\n      | \"pasteStyles\"\n      | \"selectAll\"\n      | \"deleteSelectedElements\"\n      | \"duplicateSelection\"\n      | \"sendBackward\"\n      | \"bringForward\"\n      | \"sendToBack\"\n      | \"bringToFront\"\n      | \"copyAsPng\"\n      | \"group\"\n      | \"ungroup\"\n      | \"gridMode\"\n      | \"zenMode\"\n      | \"objectsSnapMode\"\n      | \"stats\"\n      | \"addToLibrary\"\n      | \"viewMode\"\n      | \"flipHorizontal\"\n      | \"flipVertical\"\n      | \"hyperlink\"\n      | \"toggleElementLock\"\n      | \"resetZoom\"\n      | \"zoomOut\"\n      | \"zoomIn\"\n      | \"zoomToFit\"\n      | \"zoomToFitSelectionInViewport\"\n      | \"zoomToFitSelection\"\n      | \"toggleEraserTool\"\n      | \"toggleHandTool\"\n      | \"setFrameAsActiveTool\"\n      | \"saveFileToDisk\"\n      | \"saveToActiveFile\"\n      | \"toggleShortcuts\"\n      | \"wrapSelectionInFrame\"\n    >\n  | \"saveScene\"\n  | \"imageExport\"\n  | \"commandPalette\"\n  | \"searchMenu\";\n\nconst shortcutMap: Record<ShortcutName, string[]> = {\n  toggleTheme: [getShortcutKey(\"Shift+Alt+D\")],\n  saveScene: [getShortcutKey(\"CtrlOrCmd+S\")],\n  loadScene: [getShortcutKey(\"CtrlOrCmd+O\")],\n  clearCanvas: [getShortcutKey(\"CtrlOrCmd+Delete\")],\n  imageExport: [getShortcutKey(\"CtrlOrCmd+Shift+E\")],\n  commandPalette: [\n    getShortcutKey(\"CtrlOrCmd+/\"),\n    getShortcutKey(\"CtrlOrCmd+Shift+P\"),\n  ],\n  cut: [getShortcutKey(\"CtrlOrCmd+X\")],\n  copy: [getShortcutKey(\"CtrlOrCmd+C\")],\n  paste: [getShortcutKey(\"CtrlOrCmd+V\")],\n  copyStyles: [getShortcutKey(\"CtrlOrCmd+Alt+C\")],\n  pasteStyles: [getShortcutKey(\"CtrlOrCmd+Alt+V\")],\n  selectAll: [getShortcutKey(\"CtrlOrCmd+A\")],\n  deleteSelectedElements: [getShortcutKey(\"Delete\")],\n  duplicateSelection: [\n    getShortcutKey(\"CtrlOrCmd+D\"),\n    getShortcutKey(`Alt+${t(\"helpDialog.drag\")}`),\n  ],\n  sendBackward: [getShortcutKey(\"CtrlOrCmd+[\")],\n  bringForward: [getShortcutKey(\"CtrlOrCmd+]\")],\n  sendToBack: [\n    isDarwin\n      ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n      : getShortcutKey(\"CtrlOrCmd+Shift+[\"),\n  ],\n  bringToFront: [\n    isDarwin\n      ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n      : getShortcutKey(\"CtrlOrCmd+Shift+]\"),\n  ],\n  copyAsPng: [getShortcutKey(\"Shift+Alt+C\")],\n  group: [getShortcutKey(\"CtrlOrCmd+G\")],\n  ungroup: [getShortcutKey(\"CtrlOrCmd+Shift+G\")],\n  gridMode: [getShortcutKey(\"CtrlOrCmd+'\")],\n  zenMode: [getShortcutKey(\"Alt+Z\")],\n  objectsSnapMode: [getShortcutKey(\"Alt+S\")],\n  stats: [getShortcutKey(\"Alt+/\")],\n  addToLibrary: [],\n  flipHorizontal: [getShortcutKey(\"Shift+H\")],\n  flipVertical: [getShortcutKey(\"Shift+V\")],\n  viewMode: [getShortcutKey(\"Alt+R\")],\n  hyperlink: [getShortcutKey(\"CtrlOrCmd+K\")],\n  toggleElementLock: [getShortcutKey(\"CtrlOrCmd+Shift+L\")],\n  resetZoom: [getShortcutKey(\"CtrlOrCmd+0\")],\n  zoomOut: [getShortcutKey(\"CtrlOrCmd+-\")],\n  zoomIn: [getShortcutKey(\"CtrlOrCmd++\")],\n  zoomToFitSelection: [getShortcutKey(\"Shift+3\")],\n  zoomToFit: [getShortcutKey(\"Shift+1\")],\n  zoomToFitSelectionInViewport: [getShortcutKey(\"Shift+2\")],\n  toggleEraserTool: [getShortcutKey(\"E\")],\n  toggleHandTool: [getShortcutKey(\"H\")],\n  setFrameAsActiveTool: [getShortcutKey(\"F\")],\n  saveFileToDisk: [getShortcutKey(\"CtrlOrCmd+S\")],\n  saveToActiveFile: [getShortcutKey(\"CtrlOrCmd+S\")],\n  toggleShortcuts: [getShortcutKey(\"?\")],\n  searchMenu: [getShortcutKey(\"CtrlOrCmd+F\")],\n  wrapSelectionInFrame: [],\n};\n\nexport const getShortcutFromShortcutName = (name: ShortcutName, idx = 0) => {\n  const shortcuts = shortcutMap[name];\n  // if multiple shortcuts available, take the first one\n  return shortcuts && shortcuts.length > 0\n    ? shortcuts[idx] || shortcuts[0]\n    : \"\";\n};\n",
    "// taken from lodash (MIT)\n// https://github.com/lodash/lodash/blob/67389a8c78975d97505fa15aa79bec6397749807/lodash.js#L14180\n\nconst rsComboMarksRange = \"\\\\u0300-\\\\u036f\";\nconst reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\";\nconst rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\";\nconst rsComboRange =\n  rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;\nconst rsCombo = `[${rsComboRange}]`;\n\nconst reComboMark = RegExp(rsCombo, \"g\");\n\nconst reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n// NOTE below letter replacements are modified from lodash to always convert\n// to single-letter form by phonetic similarity to keep indexing identical.\n// Doing this is only useful for search highlighting, and only insofar\n// we use a library that can highlight the original source string using\n// the matching indices. As such, we'll likely need to write our own highlighter\n// anyway. Ultimately, we'll want to write our own matcher altogether\n// so we don't have to do any deburring, which will be the most correct\n// solution.\n//\n// prettier-ignore\nconst deburredLetters = {\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    // normaly Ae/ae\n    '\\xc6': 'E', '\\xe6': 'e',\n    // normally Th/th\n    '\\xde': 'T', '\\xfe': 't',\n    // normally ss\n    '\\xdf': 's',\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    // normally IJ/ij\n    '\\u0132': 'I', '\\u0133': 'i',\n    // normally OE/oe\n    '\\u0152': 'E', '\\u0153': 'e',\n    // normally \"'n\"\n    '\\u0149': \"n\",\n    '\\u017f': 's'\n  };\n\nexport const deburr = (str: string) => {\n  return str\n    .replace(reLatin, (key: string) => {\n      return deburredLetters[key as keyof typeof deburredLetters] || key;\n    })\n    .replace(reComboMark, \"\");\n};\n",
    "import clsx from \"clsx\";\nimport React, { useEffect, useState } from \"react\";\n\nimport { KEYS, queryFocusableElements } from \"@excalidraw/common\";\n\nimport { useSetAtom } from \"../editor-jotai\";\nimport { useCallbackRefState } from \"../hooks/useCallbackRefState\";\nimport { t } from \"../i18n\";\n\nimport {\n  useExcalidrawContainer,\n  useDevice,\n  useExcalidrawSetAppState,\n} from \"./App\";\nimport { Island } from \"./Island\";\nimport { isLibraryMenuOpenAtom } from \"./LibraryMenu\";\nimport { Modal } from \"./Modal\";\nimport { CloseIcon } from \"./icons\";\n\nimport \"./Dialog.scss\";\n\nexport type DialogSize = number | \"small\" | \"regular\" | \"wide\" | undefined;\n\nexport interface DialogProps {\n  children: React.ReactNode;\n  className?: string;\n  size?: DialogSize;\n  onCloseRequest(): void;\n  title: React.ReactNode | false;\n  autofocus?: boolean;\n  closeOnClickOutside?: boolean;\n}\n\nfunction getDialogSize(size: DialogSize): number {\n  if (size && typeof size === \"number\") {\n    return size;\n  }\n\n  switch (size) {\n    case \"small\":\n      return 550;\n    case \"wide\":\n      return 1024;\n    case \"regular\":\n    default:\n      return 800;\n  }\n}\n\nexport const Dialog = (props: DialogProps) => {\n  const [islandNode, setIslandNode] = useCallbackRefState<HTMLDivElement>();\n  const [lastActiveElement] = useState(document.activeElement);\n  const { id } = useExcalidrawContainer();\n  const isFullscreen = useDevice().viewport.isMobile;\n\n  useEffect(() => {\n    if (!islandNode) {\n      return;\n    }\n\n    const focusableElements = queryFocusableElements(islandNode);\n\n    setTimeout(() => {\n      if (focusableElements.length > 0 && props.autofocus !== false) {\n        // If there's an element other than close, focus it.\n        (focusableElements[1] || focusableElements[0]).focus();\n      }\n    });\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === KEYS.TAB) {\n        const focusableElements = queryFocusableElements(islandNode);\n        const { activeElement } = document;\n        const currentIndex = focusableElements.findIndex(\n          (element) => element === activeElement,\n        );\n\n        if (currentIndex === 0 && event.shiftKey) {\n          focusableElements[focusableElements.length - 1].focus();\n          event.preventDefault();\n        } else if (\n          currentIndex === focusableElements.length - 1 &&\n          !event.shiftKey\n        ) {\n          focusableElements[0].focus();\n          event.preventDefault();\n        }\n      }\n    };\n\n    islandNode.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => islandNode.removeEventListener(\"keydown\", handleKeyDown);\n  }, [islandNode, props.autofocus]);\n\n  const setAppState = useExcalidrawSetAppState();\n  const setIsLibraryMenuOpen = useSetAtom(isLibraryMenuOpenAtom);\n\n  const onClose = () => {\n    setAppState({ openMenu: null });\n    setIsLibraryMenuOpen(false);\n    (lastActiveElement as HTMLElement).focus();\n    props.onCloseRequest();\n  };\n\n  return (\n    <Modal\n      className={clsx(\"Dialog\", props.className, {\n        \"Dialog--fullscreen\": isFullscreen,\n      })}\n      labelledBy=\"dialog-title\"\n      maxWidth={getDialogSize(props.size)}\n      onCloseRequest={onClose}\n      closeOnClickOutside={props.closeOnClickOutside}\n    >\n      <Island ref={setIslandNode}>\n        {props.title && (\n          <h2 id={`${id}-dialog-title`} className=\"Dialog__title\">\n            <span className=\"Dialog__titleContent\">{props.title}</span>\n          </h2>\n        )}\n        {isFullscreen && (\n          <button\n            className=\"Dialog__close\"\n            onClick={onClose}\n            title={t(\"buttons.close\")}\n            aria-label={t(\"buttons.close\")}\n            type=\"button\"\n          >\n            {CloseIcon}\n          </button>\n        )}\n        <div className=\"Dialog__content\">{props.children}</div>\n      </Island>\n    </Modal>\n  );\n};\n",
    "import { useCallback, useState } from \"react\";\n\nexport const useCallbackRefState = <T>() => {\n  const [refValue, setRefValue] = useState<T | null>(null);\n  const refCallback = useCallback((value: T | null) => setRefValue(value), []);\n  return [refValue, refCallback] as const;\n};\n",
    "import React, {\n  useState,\n  useCallback,\n  useMemo,\n  useEffect,\n  memo,\n  useRef,\n} from \"react\";\n\nimport {\n  LIBRARY_DISABLED_TYPES,\n  randomId,\n  isShallowEqual,\n} from \"@excalidraw/common\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport { trackEvent } from \"../analytics\";\nimport { useUIAppState } from \"../context/ui-appState\";\nimport {\n  distributeLibraryItemsOnSquareGrid,\n  libraryItemsAtom,\n} from \"../data/library\";\nimport { atom, useAtom } from \"../editor-jotai\";\nimport { t } from \"../i18n\";\n\nimport { getSelectedElements } from \"../scene\";\n\nimport {\n  useApp,\n  useAppProps,\n  useExcalidrawElements,\n  useExcalidrawSetAppState,\n} from \"./App\";\nimport { LibraryMenuControlButtons } from \"./LibraryMenuControlButtons\";\nimport LibraryMenuItems from \"./LibraryMenuItems\";\nimport Spinner from \"./Spinner\";\n\nimport \"./LibraryMenu.scss\";\n\nimport type {\n  LibraryItems,\n  LibraryItem,\n  ExcalidrawProps,\n  UIAppState,\n  AppClassProperties,\n} from \"../types\";\nimport type Library from \"../data/library\";\n\nexport const isLibraryMenuOpenAtom = atom(false);\n\nconst LibraryMenuWrapper = ({ children }: { children: React.ReactNode }) => {\n  return <div className=\"layer-ui__library\">{children}</div>;\n};\n\nconst LibraryMenuContent = memo(\n  ({\n    onInsertLibraryItems,\n    pendingElements,\n    onAddToLibrary,\n    setAppState,\n    libraryReturnUrl,\n    library,\n    id,\n    theme,\n    selectedItems,\n    onSelectItems,\n  }: {\n    pendingElements: LibraryItem[\"elements\"];\n    onInsertLibraryItems: (libraryItems: LibraryItems) => void;\n    onAddToLibrary: () => void;\n    setAppState: React.Component<any, UIAppState>[\"setState\"];\n    libraryReturnUrl: ExcalidrawProps[\"libraryReturnUrl\"];\n    library: Library;\n    id: string;\n    theme: UIAppState[\"theme\"];\n    selectedItems: LibraryItem[\"id\"][];\n    onSelectItems: (id: LibraryItem[\"id\"][]) => void;\n  }) => {\n    const [libraryItemsData] = useAtom(libraryItemsAtom);\n\n    const _onAddToLibrary = useCallback(\n      (elements: LibraryItem[\"elements\"]) => {\n        const addToLibrary = async (\n          processedElements: LibraryItem[\"elements\"],\n          libraryItems: LibraryItems,\n        ) => {\n          trackEvent(\"element\", \"addToLibrary\", \"ui\");\n          for (const type of LIBRARY_DISABLED_TYPES) {\n            if (processedElements.some((element) => element.type === type)) {\n              return setAppState({\n                errorMessage: t(`errors.libraryElementTypeError.${type}`),\n              });\n            }\n          }\n          const nextItems: LibraryItems = [\n            {\n              status: \"unpublished\",\n              elements: processedElements,\n              id: randomId(),\n              created: Date.now(),\n            },\n            ...libraryItems,\n          ];\n          onAddToLibrary();\n          library.setLibrary(nextItems).catch(() => {\n            setAppState({ errorMessage: t(\"alerts.errorAddingToLibrary\") });\n          });\n        };\n        addToLibrary(elements, libraryItemsData.libraryItems);\n      },\n      [onAddToLibrary, library, setAppState, libraryItemsData.libraryItems],\n    );\n\n    const libraryItems = useMemo(\n      () => libraryItemsData.libraryItems,\n      [libraryItemsData],\n    );\n\n    if (\n      libraryItemsData.status === \"loading\" &&\n      !libraryItemsData.isInitialized\n    ) {\n      return (\n        <LibraryMenuWrapper>\n          <div className=\"layer-ui__library-message\">\n            <div>\n              <Spinner size=\"2em\" />\n              <span>{t(\"labels.libraryLoadingMessage\")}</span>\n            </div>\n          </div>\n        </LibraryMenuWrapper>\n      );\n    }\n\n    const showBtn =\n      libraryItemsData.libraryItems.length > 0 || pendingElements.length > 0;\n\n    return (\n      <LibraryMenuWrapper>\n        <LibraryMenuItems\n          isLoading={libraryItemsData.status === \"loading\"}\n          libraryItems={libraryItems}\n          onAddToLibrary={_onAddToLibrary}\n          onInsertLibraryItems={onInsertLibraryItems}\n          pendingElements={pendingElements}\n          id={id}\n          libraryReturnUrl={libraryReturnUrl}\n          theme={theme}\n          onSelectItems={onSelectItems}\n          selectedItems={selectedItems}\n        />\n        {showBtn && (\n          <LibraryMenuControlButtons\n            className=\"library-menu-control-buttons--at-bottom\"\n            style={{ padding: \"16px 12px 0 12px\" }}\n            id={id}\n            libraryReturnUrl={libraryReturnUrl}\n            theme={theme}\n          />\n        )}\n      </LibraryMenuWrapper>\n    );\n  },\n);\n\nconst getPendingElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selectedElementIds: UIAppState[\"selectedElementIds\"],\n) => ({\n  elements,\n  pending: getSelectedElements(\n    elements,\n    { selectedElementIds },\n    {\n      includeBoundTextElement: true,\n      includeElementsInFrames: true,\n    },\n  ),\n  selectedElementIds,\n});\n\nconst usePendingElementsMemo = (\n  appState: UIAppState,\n  app: AppClassProperties,\n) => {\n  const elements = useExcalidrawElements();\n  const [state, setState] = useState(() =>\n    getPendingElements(elements, appState.selectedElementIds),\n  );\n\n  const selectedElementVersions = useRef(\n    new Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"version\"]>(),\n  );\n\n  useEffect(() => {\n    for (const element of state.pending) {\n      selectedElementVersions.current.set(element.id, element.version);\n    }\n  }, [state.pending]);\n\n  useEffect(() => {\n    if (\n      // Only update once pointer is released.\n      // Reading directly from app.state to make it clear it's not reactive\n      // (hence, there's potential for stale state)\n      app.state.cursorButton === \"up\" &&\n      app.state.activeTool.type === \"selection\"\n    ) {\n      setState((prev) => {\n        // if selectedElementIds changed, we don't have to compare versions\n        // ---------------------------------------------------------------------\n        if (\n          !isShallowEqual(prev.selectedElementIds, appState.selectedElementIds)\n        ) {\n          selectedElementVersions.current.clear();\n          return getPendingElements(elements, appState.selectedElementIds);\n        }\n        // otherwise we need to check whether selected elements changed\n        // ---------------------------------------------------------------------\n        const elementsMap = app.scene.getNonDeletedElementsMap();\n        for (const id of Object.keys(appState.selectedElementIds)) {\n          const currVersion = elementsMap.get(id)?.version;\n          if (\n            currVersion &&\n            currVersion !== selectedElementVersions.current.get(id)\n          ) {\n            // we can't update the selectedElementVersions in here\n            // because of double render in StrictMode which would overwrite\n            // the state in the second pass with the old `prev` state.\n            // Thus, we update versions in a separate effect. May create\n            // a race condition since current effect is not fully reactive.\n            return getPendingElements(elements, appState.selectedElementIds);\n          }\n        }\n        // nothing changed\n        // ---------------------------------------------------------------------\n        return prev;\n      });\n    }\n  }, [\n    app,\n    app.state.cursorButton,\n    app.state.activeTool.type,\n    appState.selectedElementIds,\n    elements,\n  ]);\n\n  return state.pending;\n};\n\n/**\n * This component is meant to be rendered inside <Sidebar.Tab/> inside our\n * <DefaultSidebar/> or host apps Sidebar components.\n */\nexport const LibraryMenu = memo(() => {\n  const app = useApp();\n  const { onInsertElements } = app;\n  const appProps = useAppProps();\n  const appState = useUIAppState();\n  const setAppState = useExcalidrawSetAppState();\n  const [selectedItems, setSelectedItems] = useState<LibraryItem[\"id\"][]>([]);\n  const memoizedLibrary = useMemo(() => app.library, [app.library]);\n  const pendingElements = usePendingElementsMemo(appState, app);\n\n  const onInsertLibraryItems = useCallback(\n    (libraryItems: LibraryItems) => {\n      onInsertElements(distributeLibraryItemsOnSquareGrid(libraryItems));\n    },\n    [onInsertElements],\n  );\n\n  const deselectItems = useCallback(() => {\n    setAppState({\n      selectedElementIds: {},\n      selectedGroupIds: {},\n      activeEmbeddable: null,\n    });\n  }, [setAppState]);\n\n  return (\n    <LibraryMenuContent\n      pendingElements={pendingElements}\n      onInsertLibraryItems={onInsertLibraryItems}\n      onAddToLibrary={deselectItems}\n      setAppState={setAppState}\n      libraryReturnUrl={appProps.libraryReturnUrl}\n      library={memoizedLibrary}\n      id={app.id}\n      theme={appState.theme}\n      selectedItems={selectedItems}\n      onSelectItems={setSelectedItems}\n    />\n  );\n});\n",
    "import { useEffect, useRef } from \"react\";\n\nimport {\n  URL_HASH_KEYS,\n  URL_QUERY_KEYS,\n  APP_NAME,\n  EVENT,\n  DEFAULT_SIDEBAR,\n  LIBRARY_SIDEBAR_TAB,\n  arrayToMap,\n  cloneJSON,\n  preventUnload,\n  promiseTry,\n  resolvablePromise,\n  toValidURL,\n  Queue,\n  Emitter,\n} from \"@excalidraw/common\";\n\nimport { hashElementsVersion, hashString } from \"@excalidraw/element\";\n\nimport { getCommonBoundingBox } from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { MaybePromise } from \"@excalidraw/common/utility-types\";\n\nimport { atom, editorJotaiStore } from \"../editor-jotai\";\n\nimport { AbortError } from \"../errors\";\nimport { libraryItemSvgsCache } from \"../hooks/useLibraryItemSvg\";\nimport { t } from \"../i18n\";\n\nimport { loadLibraryFromBlob } from \"./blob\";\nimport { restoreLibraryItems } from \"./restore\";\n\nimport type App from \"../components/App\";\n\nimport type {\n  LibraryItems,\n  LibraryItem,\n  ExcalidrawImperativeAPI,\n  LibraryItemsSource,\n  LibraryItems_anyVersion,\n} from \"../types\";\n\n/**\n * format: hostname or hostname/pathname\n *\n * Both hostname and pathname are matched partially,\n * hostname from the end, pathname from the start, with subdomain/path\n * boundaries\n **/\nconst ALLOWED_LIBRARY_URLS = [\n  \"excalidraw.com\",\n  // when installing from github PRs\n  \"raw.githubusercontent.com/excalidraw/excalidraw-libraries\",\n];\n\ntype LibraryUpdate = {\n  /** deleted library items since last onLibraryChange event */\n  deletedItems: Map<LibraryItem[\"id\"], LibraryItem>;\n  /** newly added items in the library */\n  addedItems: Map<LibraryItem[\"id\"], LibraryItem>;\n};\n\n// an object so that we can later add more properties to it without breaking,\n// such as schema version\nexport type LibraryPersistedData = { libraryItems: LibraryItems };\n\nconst onLibraryUpdateEmitter = new Emitter<\n  [update: LibraryUpdate, libraryItems: LibraryItems]\n>();\n\nexport type LibraryAdatapterSource = \"load\" | \"save\";\n\nexport interface LibraryPersistenceAdapter {\n  /**\n   * Should load data that were previously saved into the database using the\n   * `save` method. Should throw if saving fails.\n   *\n   * Will be used internally in multiple places, such as during save to\n   * in order to reconcile changes with latest store data.\n   */\n  load(metadata: {\n    /**\n     * Indicates whether we're loading data for save purposes, or reading\n     * purposes, in which case host app can implement more aggressive caching.\n     */\n    source: LibraryAdatapterSource;\n  }): MaybePromise<{ libraryItems: LibraryItems_anyVersion } | null>;\n  /** Should persist to the database as is (do no change the data structure). */\n  save(libraryData: LibraryPersistedData): MaybePromise<void>;\n}\n\nexport interface LibraryMigrationAdapter {\n  /**\n   * loads data from legacy data source. Returns `null` if no data is\n   * to be migrated.\n   */\n  load(): MaybePromise<{ libraryItems: LibraryItems_anyVersion } | null>;\n\n  /** clears entire storage afterwards */\n  clear(): MaybePromise<void>;\n}\n\nexport const libraryItemsAtom = atom<{\n  status: \"loading\" | \"loaded\";\n  /** indicates whether library is initialized with library items (has gone\n   * through at least one update). Used in UI. Specific to this atom only. */\n  isInitialized: boolean;\n  libraryItems: LibraryItems;\n}>({ status: \"loaded\", isInitialized: false, libraryItems: [] });\n\nconst cloneLibraryItems = (libraryItems: LibraryItems): LibraryItems =>\n  cloneJSON(libraryItems);\n\n/**\n * checks if library item does not exist already in current library\n */\nconst isUniqueItem = (\n  existingLibraryItems: LibraryItems,\n  targetLibraryItem: LibraryItem,\n) => {\n  return !existingLibraryItems.find((libraryItem) => {\n    if (libraryItem.elements.length !== targetLibraryItem.elements.length) {\n      return false;\n    }\n\n    // detect z-index difference by checking the excalidraw elements\n    // are in order\n    return libraryItem.elements.every((libItemExcalidrawItem, idx) => {\n      return (\n        libItemExcalidrawItem.id === targetLibraryItem.elements[idx].id &&\n        libItemExcalidrawItem.versionNonce ===\n          targetLibraryItem.elements[idx].versionNonce\n      );\n    });\n  });\n};\n\n/** Merges otherItems into localItems. Unique items in otherItems array are\n    sorted first. */\nexport const mergeLibraryItems = (\n  localItems: LibraryItems,\n  otherItems: LibraryItems,\n): LibraryItems => {\n  const newItems = [];\n  for (const item of otherItems) {\n    if (isUniqueItem(localItems, item)) {\n      newItems.push(item);\n    }\n  }\n\n  return [...newItems, ...localItems];\n};\n\n/**\n * Returns { deletedItems, addedItems } maps of all added and deleted items\n * since last onLibraryChange event.\n *\n * Host apps are recommended to diff with the latest state they have.\n */\nconst createLibraryUpdate = (\n  prevLibraryItems: LibraryItems,\n  nextLibraryItems: LibraryItems,\n): LibraryUpdate => {\n  const nextItemsMap = arrayToMap(nextLibraryItems);\n\n  const update: LibraryUpdate = {\n    deletedItems: new Map<LibraryItem[\"id\"], LibraryItem>(),\n    addedItems: new Map<LibraryItem[\"id\"], LibraryItem>(),\n  };\n\n  for (const item of prevLibraryItems) {\n    if (!nextItemsMap.has(item.id)) {\n      update.deletedItems.set(item.id, item);\n    }\n  }\n\n  const prevItemsMap = arrayToMap(prevLibraryItems);\n\n  for (const item of nextLibraryItems) {\n    if (!prevItemsMap.has(item.id)) {\n      update.addedItems.set(item.id, item);\n    }\n  }\n\n  return update;\n};\n\nclass Library {\n  /** latest libraryItems */\n  private currLibraryItems: LibraryItems = [];\n  /** snapshot of library items since last onLibraryChange call */\n  private prevLibraryItems = cloneLibraryItems(this.currLibraryItems);\n\n  private app: App;\n\n  constructor(app: App) {\n    this.app = app;\n  }\n\n  private updateQueue: Promise<LibraryItems>[] = [];\n\n  private getLastUpdateTask = (): Promise<LibraryItems> | undefined => {\n    return this.updateQueue[this.updateQueue.length - 1];\n  };\n\n  private notifyListeners = () => {\n    if (this.updateQueue.length > 0) {\n      editorJotaiStore.set(libraryItemsAtom, (s) => ({\n        status: \"loading\",\n        libraryItems: this.currLibraryItems,\n        isInitialized: s.isInitialized,\n      }));\n    } else {\n      editorJotaiStore.set(libraryItemsAtom, {\n        status: \"loaded\",\n        libraryItems: this.currLibraryItems,\n        isInitialized: true,\n      });\n      try {\n        const prevLibraryItems = this.prevLibraryItems;\n        this.prevLibraryItems = cloneLibraryItems(this.currLibraryItems);\n\n        const nextLibraryItems = cloneLibraryItems(this.currLibraryItems);\n\n        this.app.props.onLibraryChange?.(nextLibraryItems);\n\n        // for internal use in `useHandleLibrary` hook\n        onLibraryUpdateEmitter.trigger(\n          createLibraryUpdate(prevLibraryItems, nextLibraryItems),\n          nextLibraryItems,\n        );\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  };\n\n  /** call on excalidraw instance unmount */\n  destroy = () => {\n    this.updateQueue = [];\n    this.currLibraryItems = [];\n    editorJotaiStore.set(libraryItemSvgsCache, new Map());\n    // TODO uncomment after/if we make jotai store scoped to each excal instance\n    // jotaiStore.set(libraryItemsAtom, {\n    //   status: \"loading\",\n    //   isInitialized: false,\n    //   libraryItems: [],\n    // });\n  };\n\n  resetLibrary = () => {\n    return this.setLibrary([]);\n  };\n\n  /**\n   * @returns latest cloned libraryItems. Awaits all in-progress updates first.\n   */\n  getLatestLibrary = (): Promise<LibraryItems> => {\n    return new Promise(async (resolve) => {\n      try {\n        const libraryItems = await (this.getLastUpdateTask() ||\n          this.currLibraryItems);\n        if (this.updateQueue.length > 0) {\n          resolve(this.getLatestLibrary());\n        } else {\n          resolve(cloneLibraryItems(libraryItems));\n        }\n      } catch (error) {\n        return resolve(this.currLibraryItems);\n      }\n    });\n  };\n\n  // NOTE this is a high-level public API (exposed on ExcalidrawAPI) with\n  // a slight overhead (always restoring library items). For internal use\n  // where merging isn't needed, use `library.setLibrary()` directly.\n  updateLibrary = async ({\n    libraryItems,\n    prompt = false,\n    merge = false,\n    openLibraryMenu = false,\n    defaultStatus = \"unpublished\",\n  }: {\n    libraryItems: LibraryItemsSource;\n    merge?: boolean;\n    prompt?: boolean;\n    openLibraryMenu?: boolean;\n    defaultStatus?: \"unpublished\" | \"published\";\n  }): Promise<LibraryItems> => {\n    if (openLibraryMenu) {\n      this.app.setState({\n        openSidebar: { name: DEFAULT_SIDEBAR.name, tab: LIBRARY_SIDEBAR_TAB },\n      });\n    }\n\n    return this.setLibrary(() => {\n      return new Promise<LibraryItems>(async (resolve, reject) => {\n        try {\n          const source = await (typeof libraryItems === \"function\" &&\n          !(libraryItems instanceof Blob)\n            ? libraryItems(this.currLibraryItems)\n            : libraryItems);\n\n          let nextItems;\n\n          if (source instanceof Blob) {\n            nextItems = await loadLibraryFromBlob(source, defaultStatus);\n          } else {\n            nextItems = restoreLibraryItems(source, defaultStatus);\n          }\n          if (\n            !prompt ||\n            window.confirm(\n              t(\"alerts.confirmAddLibrary\", {\n                numShapes: nextItems.length,\n              }),\n            )\n          ) {\n            if (prompt) {\n              // focus container if we've prompted. We focus conditionally\n              // lest `props.autoFocus` is disabled (in which case we should\n              // focus only on user action such as prompt confirm)\n              this.app.focusContainer();\n            }\n\n            if (merge) {\n              resolve(mergeLibraryItems(this.currLibraryItems, nextItems));\n            } else {\n              resolve(nextItems);\n            }\n          } else {\n            reject(new AbortError());\n          }\n        } catch (error: any) {\n          reject(error);\n        }\n      });\n    });\n  };\n\n  setLibrary = (\n    /**\n     * LibraryItems that will replace current items. Can be a function which\n     * will be invoked after all previous tasks are resolved\n     * (this is the prefered way to update the library to avoid race conditions,\n     * but you'll want to manually merge the library items in the callback\n     *  - which is what we're doing in Library.importLibrary()).\n     *\n     * If supplied promise is rejected with AbortError, we swallow it and\n     * do not update the library.\n     */\n    libraryItems:\n      | LibraryItems\n      | Promise<LibraryItems>\n      | ((\n          latestLibraryItems: LibraryItems,\n        ) => LibraryItems | Promise<LibraryItems>),\n  ): Promise<LibraryItems> => {\n    const task = new Promise<LibraryItems>(async (resolve, reject) => {\n      try {\n        await this.getLastUpdateTask();\n\n        if (typeof libraryItems === \"function\") {\n          libraryItems = libraryItems(this.currLibraryItems);\n        }\n\n        this.currLibraryItems = cloneLibraryItems(await libraryItems);\n\n        resolve(this.currLibraryItems);\n      } catch (error: any) {\n        reject(error);\n      }\n    })\n      .catch((error) => {\n        if (error.name === \"AbortError\") {\n          console.warn(\"Library update aborted by user\");\n          return this.currLibraryItems;\n        }\n        throw error;\n      })\n      .finally(() => {\n        this.updateQueue = this.updateQueue.filter((_task) => _task !== task);\n        this.notifyListeners();\n      });\n\n    this.updateQueue.push(task);\n    this.notifyListeners();\n\n    return task;\n  };\n}\n\nexport default Library;\n\nexport const distributeLibraryItemsOnSquareGrid = (\n  libraryItems: LibraryItems,\n) => {\n  const PADDING = 50;\n  const ITEMS_PER_ROW = Math.ceil(Math.sqrt(libraryItems.length));\n\n  const resElements: ExcalidrawElement[] = [];\n\n  const getMaxHeightPerRow = (row: number) => {\n    const maxHeight = libraryItems\n      .slice(row * ITEMS_PER_ROW, row * ITEMS_PER_ROW + ITEMS_PER_ROW)\n      .reduce((acc, item) => {\n        const { height } = getCommonBoundingBox(item.elements);\n        return Math.max(acc, height);\n      }, 0);\n    return maxHeight;\n  };\n\n  const getMaxWidthPerCol = (targetCol: number) => {\n    let index = 0;\n    let currCol = 0;\n    let maxWidth = 0;\n    for (const item of libraryItems) {\n      if (index % ITEMS_PER_ROW === 0) {\n        currCol = 0;\n      }\n      if (currCol === targetCol) {\n        const { width } = getCommonBoundingBox(item.elements);\n        maxWidth = Math.max(maxWidth, width);\n      }\n      index++;\n      currCol++;\n    }\n    return maxWidth;\n  };\n\n  let colOffsetX = 0;\n  let rowOffsetY = 0;\n\n  let maxHeightCurrRow = 0;\n  let maxWidthCurrCol = 0;\n\n  let index = 0;\n  let col = 0;\n  let row = 0;\n\n  for (const item of libraryItems) {\n    if (index && index % ITEMS_PER_ROW === 0) {\n      rowOffsetY += maxHeightCurrRow + PADDING;\n      colOffsetX = 0;\n      col = 0;\n      row++;\n    }\n\n    if (col === 0) {\n      maxHeightCurrRow = getMaxHeightPerRow(row);\n    }\n    maxWidthCurrCol = getMaxWidthPerCol(col);\n\n    const { minX, minY, width, height } = getCommonBoundingBox(item.elements);\n    const offsetCenterX = (maxWidthCurrCol - width) / 2;\n    const offsetCenterY = (maxHeightCurrRow - height) / 2;\n    resElements.push(\n      // eslint-disable-next-line no-loop-func\n      ...item.elements.map((element) => ({\n        ...element,\n        x:\n          element.x +\n          // offset for column\n          colOffsetX +\n          // offset to center in given square grid\n          offsetCenterX -\n          // subtract minX so that given item starts at 0 coord\n          minX,\n        y:\n          element.y +\n          // offset for row\n          rowOffsetY +\n          // offset to center in given square grid\n          offsetCenterY -\n          // subtract minY so that given item starts at 0 coord\n          minY,\n      })),\n    );\n    colOffsetX += maxWidthCurrCol + PADDING;\n    index++;\n    col++;\n  }\n\n  return resElements;\n};\n\nexport const validateLibraryUrl = (\n  libraryUrl: string,\n  /**\n   * @returns `true` if the URL is valid, throws otherwise.\n   */\n  validator:\n    | ((libraryUrl: string) => boolean)\n    | string[] = ALLOWED_LIBRARY_URLS,\n): true => {\n  if (\n    typeof validator === \"function\"\n      ? validator(libraryUrl)\n      : validator.some((allowedUrlDef) => {\n          const allowedUrl = new URL(\n            `https://${allowedUrlDef.replace(/^https?:\\/\\//, \"\")}`,\n          );\n\n          const { hostname, pathname } = new URL(libraryUrl);\n\n          return (\n            new RegExp(`(^|\\\\.)${allowedUrl.hostname}$`).test(hostname) &&\n            new RegExp(\n              `^${allowedUrl.pathname.replace(/\\/+$/, \"\")}(/+|$)`,\n            ).test(pathname)\n          );\n        })\n  ) {\n    return true;\n  }\n\n  throw new Error(`Invalid or disallowed library URL: \"${libraryUrl}\"`);\n};\n\nexport const parseLibraryTokensFromUrl = () => {\n  const libraryUrl =\n    // current\n    new URLSearchParams(window.location.hash.slice(1)).get(\n      URL_HASH_KEYS.addLibrary,\n    ) ||\n    // legacy, kept for compat reasons\n    new URLSearchParams(window.location.search).get(URL_QUERY_KEYS.addLibrary);\n  const idToken = libraryUrl\n    ? new URLSearchParams(window.location.hash.slice(1)).get(\"token\")\n    : null;\n\n  return libraryUrl ? { libraryUrl, idToken } : null;\n};\n\nclass AdapterTransaction {\n  static queue = new Queue();\n\n  static async getLibraryItems(\n    adapter: LibraryPersistenceAdapter,\n    source: LibraryAdatapterSource,\n    _queue = true,\n  ): Promise<LibraryItems> {\n    const task = () =>\n      new Promise<LibraryItems>(async (resolve, reject) => {\n        try {\n          const data = await adapter.load({ source });\n          resolve(restoreLibraryItems(data?.libraryItems || [], \"published\"));\n        } catch (error: any) {\n          reject(error);\n        }\n      });\n\n    if (_queue) {\n      return AdapterTransaction.queue.push(task);\n    }\n\n    return task();\n  }\n\n  static run = async <T>(\n    adapter: LibraryPersistenceAdapter,\n    fn: (transaction: AdapterTransaction) => Promise<T>,\n  ) => {\n    const transaction = new AdapterTransaction(adapter);\n    return AdapterTransaction.queue.push(() => fn(transaction));\n  };\n\n  // ------------------\n\n  private adapter: LibraryPersistenceAdapter;\n\n  constructor(adapter: LibraryPersistenceAdapter) {\n    this.adapter = adapter;\n  }\n\n  getLibraryItems(source: LibraryAdatapterSource) {\n    return AdapterTransaction.getLibraryItems(this.adapter, source, false);\n  }\n}\n\nlet lastSavedLibraryItemsHash = 0;\nlet librarySaveCounter = 0;\n\nexport const getLibraryItemsHash = (items: LibraryItems) => {\n  return hashString(\n    items\n      .map((item) => {\n        return `${item.id}:${hashElementsVersion(item.elements)}`;\n      })\n      .sort()\n      .join(),\n  );\n};\n\nconst persistLibraryUpdate = async (\n  adapter: LibraryPersistenceAdapter,\n  update: LibraryUpdate,\n): Promise<LibraryItems> => {\n  try {\n    librarySaveCounter++;\n\n    return await AdapterTransaction.run(adapter, async (transaction) => {\n      const nextLibraryItemsMap = arrayToMap(\n        await transaction.getLibraryItems(\"save\"),\n      );\n\n      for (const [id] of update.deletedItems) {\n        nextLibraryItemsMap.delete(id);\n      }\n\n      const addedItems: LibraryItem[] = [];\n\n      // we want to merge current library items with the ones stored in the\n      // DB so that we don't lose any elements that for some reason aren't\n      // in the current editor library, which could happen when:\n      //\n      // 1. we haven't received an update deleting some elements\n      //    (in which case it's still better to keep them in the DB lest\n      //     it was due to a different reason)\n      // 2. we keep a single DB for all active editors, but the editors'\n      //    libraries aren't synced or there's a race conditions during\n      //    syncing\n      // 3. some other race condition, e.g. during init where emit updates\n      //    for partial updates (e.g. you install a 3rd party library and\n      //    init from DB only after — we emit events for both updates)\n      for (const [id, item] of update.addedItems) {\n        if (nextLibraryItemsMap.has(id)) {\n          // replace item with latest version\n          // TODO we could prefer the newer item instead\n          nextLibraryItemsMap.set(id, item);\n        } else {\n          // we want to prepend the new items with the ones that are already\n          // in DB to preserve the ordering we do in editor (newly added\n          // items are added to the beginning)\n          addedItems.push(item);\n        }\n      }\n\n      const nextLibraryItems = addedItems.concat(\n        Array.from(nextLibraryItemsMap.values()),\n      );\n\n      const version = getLibraryItemsHash(nextLibraryItems);\n\n      if (version !== lastSavedLibraryItemsHash) {\n        await adapter.save({ libraryItems: nextLibraryItems });\n      }\n\n      lastSavedLibraryItemsHash = version;\n\n      return nextLibraryItems;\n    });\n  } finally {\n    librarySaveCounter--;\n  }\n};\n\nexport const useHandleLibrary = (\n  opts: {\n    excalidrawAPI: ExcalidrawImperativeAPI | null;\n    /**\n     * Return `true` if the library install url should be allowed.\n     * If not supplied, only the excalidraw.com base domain is allowed.\n     */\n    validateLibraryUrl?: (libraryUrl: string) => boolean;\n  } & (\n    | {\n        /** @deprecated we recommend using `opts.adapter` instead */\n        getInitialLibraryItems?: () => MaybePromise<LibraryItemsSource>;\n      }\n    | {\n        adapter: LibraryPersistenceAdapter;\n        /**\n         * Adapter that takes care of loading data from legacy data store.\n         * Supply this if you want to migrate data on initial load from legacy\n         * data store.\n         *\n         * Can be a different LibraryPersistenceAdapter.\n         */\n        migrationAdapter?: LibraryMigrationAdapter;\n      }\n  ),\n) => {\n  const { excalidrawAPI } = opts;\n\n  const optsRef = useRef(opts);\n  optsRef.current = opts;\n\n  const isLibraryLoadedRef = useRef(false);\n\n  useEffect(() => {\n    if (!excalidrawAPI) {\n      return;\n    }\n\n    // reset on editor remount (excalidrawAPI changed)\n    isLibraryLoadedRef.current = false;\n\n    const importLibraryFromURL = async ({\n      libraryUrl,\n      idToken,\n    }: {\n      libraryUrl: string;\n      idToken: string | null;\n    }) => {\n      const libraryPromise = new Promise<Blob>(async (resolve, reject) => {\n        try {\n          libraryUrl = decodeURIComponent(libraryUrl);\n\n          libraryUrl = toValidURL(libraryUrl);\n\n          validateLibraryUrl(libraryUrl, optsRef.current.validateLibraryUrl);\n\n          const request = await fetch(libraryUrl);\n          const blob = await request.blob();\n          resolve(blob);\n        } catch (error: any) {\n          reject(error);\n        }\n      });\n\n      const shouldPrompt = idToken !== excalidrawAPI.id;\n\n      // wait for the tab to be focused before continuing in case we'll prompt\n      // for confirmation\n      await (shouldPrompt && document.hidden\n        ? new Promise<void>((resolve) => {\n            window.addEventListener(\"focus\", () => resolve(), {\n              once: true,\n            });\n          })\n        : null);\n\n      try {\n        await excalidrawAPI.updateLibrary({\n          libraryItems: libraryPromise,\n          prompt: shouldPrompt,\n          merge: true,\n          defaultStatus: \"published\",\n          openLibraryMenu: true,\n        });\n      } catch (error: any) {\n        excalidrawAPI.updateScene({\n          appState: {\n            errorMessage: error.message,\n          },\n        });\n        throw error;\n      } finally {\n        if (window.location.hash.includes(URL_HASH_KEYS.addLibrary)) {\n          const hash = new URLSearchParams(window.location.hash.slice(1));\n          hash.delete(URL_HASH_KEYS.addLibrary);\n          window.history.replaceState({}, APP_NAME, `#${hash.toString()}`);\n        } else if (window.location.search.includes(URL_QUERY_KEYS.addLibrary)) {\n          const query = new URLSearchParams(window.location.search);\n          query.delete(URL_QUERY_KEYS.addLibrary);\n          window.history.replaceState({}, APP_NAME, `?${query.toString()}`);\n        }\n      }\n    };\n    const onHashChange = (event: HashChangeEvent) => {\n      event.preventDefault();\n      const libraryUrlTokens = parseLibraryTokensFromUrl();\n      if (libraryUrlTokens) {\n        event.stopImmediatePropagation();\n        // If hash changed and it contains library url, import it and replace\n        // the url to its previous state (important in case of collaboration\n        // and similar).\n        // Using history API won't trigger another hashchange.\n        window.history.replaceState({}, \"\", event.oldURL);\n\n        importLibraryFromURL(libraryUrlTokens);\n      }\n    };\n\n    // -------------------------------------------------------------------------\n    // ---------------------------------- init ---------------------------------\n    // -------------------------------------------------------------------------\n\n    const libraryUrlTokens = parseLibraryTokensFromUrl();\n\n    if (libraryUrlTokens) {\n      importLibraryFromURL(libraryUrlTokens);\n    }\n\n    // ------ (A) init load (legacy) -------------------------------------------\n    if (\n      \"getInitialLibraryItems\" in optsRef.current &&\n      optsRef.current.getInitialLibraryItems\n    ) {\n      console.warn(\n        \"useHandleLibrar `opts.getInitialLibraryItems` is deprecated. Use `opts.adapter` instead.\",\n      );\n\n      Promise.resolve(optsRef.current.getInitialLibraryItems())\n        .then((libraryItems) => {\n          excalidrawAPI.updateLibrary({\n            libraryItems,\n            // merge with current library items because we may have already\n            // populated it (e.g. by installing 3rd party library which can\n            // happen before the DB data is loaded)\n            merge: true,\n          });\n        })\n        .catch((error: any) => {\n          console.error(\n            `UseHandeLibrary getInitialLibraryItems failed: ${error?.message}`,\n          );\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // --------------------------------------------------------- init load -----\n    // -------------------------------------------------------------------------\n\n    // ------ (B) data source adapter ------------------------------------------\n\n    if (\"adapter\" in optsRef.current && optsRef.current.adapter) {\n      const adapter = optsRef.current.adapter;\n      const migrationAdapter = optsRef.current.migrationAdapter;\n\n      const initDataPromise = resolvablePromise<LibraryItems | null>();\n\n      // migrate from old data source if needed\n      // (note, if `migrate` function is defined, we always migrate even\n      //  if the data has already been migrated. In that case it'll be a no-op,\n      //  though with several unnecessary steps — we will still load latest\n      //  DB data during the `persistLibraryChange()` step)\n      // -----------------------------------------------------------------------\n      if (migrationAdapter) {\n        initDataPromise.resolve(\n          promiseTry(migrationAdapter.load)\n            .then(async (libraryData) => {\n              let restoredData: LibraryItems | null = null;\n              try {\n                // if no library data to migrate, assume no migration needed\n                // and skip persisting to new data store, as well as well\n                // clearing the old store via `migrationAdapter.clear()`\n                if (!libraryData) {\n                  return AdapterTransaction.getLibraryItems(adapter, \"load\");\n                }\n\n                restoredData = restoreLibraryItems(\n                  libraryData.libraryItems || [],\n                  \"published\",\n                );\n\n                // we don't queue this operation because it's running inside\n                // a promise that's running inside Library update queue itself\n                const nextItems = await persistLibraryUpdate(\n                  adapter,\n                  createLibraryUpdate([], restoredData),\n                );\n                try {\n                  await migrationAdapter.clear();\n                } catch (error: any) {\n                  console.error(\n                    `couldn't delete legacy library data: ${error.message}`,\n                  );\n                }\n                // migration suceeded, load migrated data\n                return nextItems;\n              } catch (error: any) {\n                console.error(\n                  `couldn't migrate legacy library data: ${error.message}`,\n                );\n                // migration failed, load data from previous store, if any\n                return restoredData;\n              }\n            })\n            // errors caught during `migrationAdapter.load()`\n            .catch((error: any) => {\n              console.error(`error during library migration: ${error.message}`);\n              // as a default, load latest library from current data source\n              return AdapterTransaction.getLibraryItems(adapter, \"load\");\n            }),\n        );\n      } else {\n        initDataPromise.resolve(\n          promiseTry(AdapterTransaction.getLibraryItems, adapter, \"load\"),\n        );\n      }\n\n      // load initial (or migrated) library\n      excalidrawAPI\n        .updateLibrary({\n          libraryItems: initDataPromise.then((libraryItems) => {\n            const _libraryItems = libraryItems || [];\n            lastSavedLibraryItemsHash = getLibraryItemsHash(_libraryItems);\n            return _libraryItems;\n          }),\n          // merge with current library items because we may have already\n          // populated it (e.g. by installing 3rd party library which can\n          // happen before the DB data is loaded)\n          merge: true,\n        })\n        .finally(() => {\n          isLibraryLoadedRef.current = true;\n        });\n    }\n    // ---------------------------------------------- data source datapter -----\n\n    window.addEventListener(EVENT.HASHCHANGE, onHashChange);\n    return () => {\n      window.removeEventListener(EVENT.HASHCHANGE, onHashChange);\n    };\n  }, [\n    // important this useEffect only depends on excalidrawAPI so it only reruns\n    // on editor remounts (the excalidrawAPI changes)\n    excalidrawAPI,\n  ]);\n\n  // This effect is run without excalidrawAPI dependency so that host apps\n  // can run this hook outside of an active editor instance and the library\n  // update queue/loop survives editor remounts\n  //\n  // This effect is still only meant to be run if host apps supply an persitence\n  // adapter. If we don't have access to it, it the update listener doesn't\n  // do anything.\n  useEffect(\n    () => {\n      // on update, merge with current library items and persist\n      // -----------------------------------------------------------------------\n      const unsubOnLibraryUpdate = onLibraryUpdateEmitter.on(\n        async (update, nextLibraryItems) => {\n          const isLoaded = isLibraryLoadedRef.current;\n          // we want to operate with the latest adapter, but we don't want this\n          // effect to rerun on every adapter change in case host apps' adapter\n          // isn't stable\n          const adapter =\n            (\"adapter\" in optsRef.current && optsRef.current.adapter) || null;\n          try {\n            if (adapter) {\n              if (\n                // if nextLibraryItems hash identical to previously saved hash,\n                // exit early, even if actual upstream state ends up being\n                // different (e.g. has more data than we have locally), as it'd\n                // be low-impact scenario.\n                lastSavedLibraryItemsHash !==\n                getLibraryItemsHash(nextLibraryItems)\n              ) {\n                await persistLibraryUpdate(adapter, update);\n              }\n            }\n          } catch (error: any) {\n            console.error(\n              `couldn't persist library update: ${error.message}`,\n              update,\n            );\n\n            // currently we only show error if an editor is loaded\n            if (isLoaded && optsRef.current.excalidrawAPI) {\n              optsRef.current.excalidrawAPI.updateScene({\n                appState: {\n                  errorMessage: t(\"errors.saveLibraryError\"),\n                },\n              });\n            }\n          }\n        },\n      );\n\n      const onUnload = (event: Event) => {\n        if (librarySaveCounter) {\n          preventUnload(event);\n        }\n      };\n\n      window.addEventListener(EVENT.BEFORE_UNLOAD, onUnload);\n\n      return () => {\n        window.removeEventListener(EVENT.BEFORE_UNLOAD, onUnload);\n        unsubOnLibraryUpdate();\n        lastSavedLibraryItemsHash = 0;\n        librarySaveCounter = 0;\n      };\n    },\n    [\n      // this effect must not have any deps so it doesn't rerun\n    ],\n  );\n};\n",
    "import { MIME_TYPES } from \"@excalidraw/common\";\nimport { getDefaultAppState } from \"excalidraw-custom/appState\";\nimport {\n  copyBlobToClipboardAsPng,\n  copyTextToSystemClipboard,\n  copyToClipboard,\n} from \"excalidraw-custom/clipboard\";\nimport { encodePngMetadata } from \"excalidraw-custom/data/image\";\nimport { serializeAsJSON } from \"excalidraw-custom/data/json\";\nimport { restore } from \"excalidraw-custom/data/restore\";\nimport {\n  exportToCanvas as _exportToCanvas,\n  exportToSvg as _exportToSvg,\n} from \"excalidraw-custom/scene/export\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawFrameLikeElement,\n  NonDeleted,\n} from \"@excalidraw/element/types\";\nimport type { AppState, BinaryFiles } from \"excalidraw-custom/types\";\n\nexport { MIME_TYPES };\n\ntype ExportOpts = {\n  elements: readonly NonDeleted<ExcalidrawElement>[];\n  appState?: Partial<Omit<AppState, \"offsetTop\" | \"offsetLeft\">>;\n  files: BinaryFiles | null;\n  maxWidthOrHeight?: number;\n  exportingFrame?: ExcalidrawFrameLikeElement | null;\n  getDimensions?: (\n    width: number,\n    height: number,\n  ) => { width: number; height: number; scale?: number };\n};\n\nexport const exportToCanvas = ({\n  elements,\n  appState,\n  files,\n  maxWidthOrHeight,\n  getDimensions,\n  exportPadding,\n  exportingFrame,\n}: ExportOpts & {\n  exportPadding?: number;\n}) => {\n  const { elements: restoredElements, appState: restoredAppState } = restore(\n    { elements, appState },\n    null,\n    null,\n  );\n  const { exportBackground, viewBackgroundColor } = restoredAppState;\n  return _exportToCanvas(\n    restoredElements,\n    { ...restoredAppState, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 },\n    files || {},\n    { exportBackground, exportPadding, viewBackgroundColor, exportingFrame },\n    (width: number, height: number) => {\n      const canvas = document.createElement(\"canvas\");\n\n      if (maxWidthOrHeight) {\n        if (typeof getDimensions === \"function\") {\n          console.warn(\n            \"`getDimensions()` is ignored when `maxWidthOrHeight` is supplied.\",\n          );\n        }\n\n        const max = Math.max(width, height);\n\n        // if content is less then maxWidthOrHeight, fallback on supplied scale\n        const scale =\n          maxWidthOrHeight < max\n            ? maxWidthOrHeight / max\n            : appState?.exportScale ?? 1;\n\n        canvas.width = width * scale;\n        canvas.height = height * scale;\n\n        return {\n          canvas,\n          scale,\n        };\n      }\n\n      const ret = getDimensions?.(width, height) || { width, height };\n\n      canvas.width = ret.width;\n      canvas.height = ret.height;\n\n      return {\n        canvas,\n        scale: ret.scale ?? 1,\n      };\n    },\n  );\n};\n\nexport const exportToBlob = async (\n  opts: ExportOpts & {\n    mimeType?: string;\n    quality?: number;\n    exportPadding?: number;\n  },\n): Promise<Blob> => {\n  let { mimeType = MIME_TYPES.png, quality } = opts;\n\n  if (mimeType === MIME_TYPES.png && typeof quality === \"number\") {\n    console.warn(`\"quality\" will be ignored for \"${MIME_TYPES.png}\" mimeType`);\n  }\n\n  // typo in MIME type (should be \"jpeg\")\n  if (mimeType === \"image/jpg\") {\n    mimeType = MIME_TYPES.jpg;\n  }\n\n  if (mimeType === MIME_TYPES.jpg && !opts.appState?.exportBackground) {\n    console.warn(\n      `Defaulting \"exportBackground\" to \"true\" for \"${MIME_TYPES.jpg}\" mimeType`,\n    );\n    opts = {\n      ...opts,\n      appState: { ...opts.appState, exportBackground: true },\n    };\n  }\n\n  const canvas = await exportToCanvas(opts);\n\n  quality = quality ? quality : /image\\/jpe?g/.test(mimeType) ? 0.92 : 0.8;\n\n  return new Promise((resolve, reject) => {\n    canvas.toBlob(\n      async (blob) => {\n        if (!blob) {\n          return reject(new Error(\"couldn't export to blob\"));\n        }\n        if (\n          blob &&\n          mimeType === MIME_TYPES.png &&\n          opts.appState?.exportEmbedScene\n        ) {\n          blob = await encodePngMetadata({\n            blob,\n            metadata: serializeAsJSON(\n              // NOTE as long as we're using the Scene hack, we need to ensure\n              // we pass the original, uncloned elements when serializing\n              // so that we keep ids stable\n              opts.elements,\n              opts.appState,\n              opts.files || {},\n              \"local\",\n            ),\n          });\n        }\n        resolve(blob);\n      },\n      mimeType,\n      quality,\n    );\n  });\n};\n\nexport const exportToSvg = async ({\n  elements,\n  appState = getDefaultAppState(),\n  files = {},\n  exportPadding,\n  renderEmbeddables,\n  exportingFrame,\n  skipInliningFonts,\n  reuseImages,\n}: Omit<ExportOpts, \"getDimensions\"> & {\n  exportPadding?: number;\n  renderEmbeddables?: boolean;\n  skipInliningFonts?: true;\n  reuseImages?: boolean;\n}): Promise<SVGSVGElement> => {\n  const { elements: restoredElements, appState: restoredAppState } = restore(\n    { elements, appState },\n    null,\n    null,\n  );\n\n  const exportAppState = {\n    ...restoredAppState,\n    exportPadding,\n  };\n\n  return _exportToSvg(restoredElements, exportAppState, files, {\n    exportingFrame,\n    renderEmbeddables,\n    skipInliningFonts,\n    reuseImages,\n  });\n};\n\nexport const exportToClipboard = async (\n  opts: ExportOpts & {\n    mimeType?: string;\n    quality?: number;\n    type: \"png\" | \"svg\" | \"json\";\n  },\n) => {\n  if (opts.type === \"svg\") {\n    const svg = await exportToSvg(opts);\n    await copyTextToSystemClipboard(svg.outerHTML);\n  } else if (opts.type === \"png\") {\n    await copyBlobToClipboardAsPng(exportToBlob(opts));\n  } else if (opts.type === \"json\") {\n    await copyToClipboard(opts.elements, opts.files);\n  } else {\n    throw new Error(\"Invalid export type\");\n  }\n};\n",
    "import { exportToSvg } from \"@excalidraw/utils/export\";\nimport { useEffect, useState } from \"react\";\n\nimport { COLOR_PALETTE } from \"@excalidraw/common\";\n\nimport { atom, useAtom } from \"../editor-jotai\";\n\nimport type { LibraryItem } from \"../types\";\n\nexport type SvgCache = Map<LibraryItem[\"id\"], SVGSVGElement>;\n\nexport const libraryItemSvgsCache = atom<SvgCache>(new Map());\n\nconst exportLibraryItemToSvg = async (elements: LibraryItem[\"elements\"]) => {\n  return await exportToSvg({\n    elements,\n    appState: {\n      exportBackground: false,\n      viewBackgroundColor: COLOR_PALETTE.white,\n    },\n    files: null,\n    renderEmbeddables: false,\n    skipInliningFonts: true,\n  });\n};\n\nexport const useLibraryItemSvg = (\n  id: LibraryItem[\"id\"] | null,\n  elements: LibraryItem[\"elements\"] | undefined,\n  svgCache: SvgCache,\n): SVGSVGElement | undefined => {\n  const [svg, setSvg] = useState<SVGSVGElement>();\n\n  useEffect(() => {\n    if (elements) {\n      if (id) {\n        // Try to load cached svg\n        const cachedSvg = svgCache.get(id);\n\n        if (cachedSvg) {\n          setSvg(cachedSvg);\n        } else {\n          // When there is no svg in cache export it and save to cache\n          (async () => {\n            const exportedSvg = await exportLibraryItemToSvg(elements);\n            // TODO: should likely be removed for custom fonts\n            exportedSvg.querySelector(\".style-fonts\")?.remove();\n\n            if (exportedSvg) {\n              svgCache.set(id, exportedSvg);\n              setSvg(exportedSvg);\n            }\n          })();\n        }\n      } else {\n        // When we have no id (usualy selected items from canvas) just export the svg\n        (async () => {\n          const exportedSvg = await exportLibraryItemToSvg(elements);\n          setSvg(exportedSvg);\n        })();\n      }\n    }\n  }, [id, elements, svgCache, setSvg]);\n\n  return svg;\n};\n\nexport const useLibraryCache = () => {\n  const [svgCache] = useAtom(libraryItemSvgsCache);\n\n  const clearLibraryCache = () => svgCache.clear();\n\n  const deleteItemsFromLibraryCache = (items: LibraryItem[\"id\"][]) => {\n    items.forEach((item) => svgCache.delete(item));\n  };\n\n  return {\n    clearLibraryCache,\n    deleteItemsFromLibraryCache,\n    svgCache,\n  };\n};\n",
    "import clsx from \"clsx\";\n\nimport LibraryMenuBrowseButton from \"./LibraryMenuBrowseButton\";\n\nimport type { ExcalidrawProps, UIAppState } from \"../types\";\n\nexport const LibraryMenuControlButtons = ({\n  libraryReturnUrl,\n  theme,\n  id,\n  style,\n  children,\n  className,\n}: {\n  libraryReturnUrl: ExcalidrawProps[\"libraryReturnUrl\"];\n  theme: UIAppState[\"theme\"];\n  id: string;\n  style: React.CSSProperties;\n  children?: React.ReactNode;\n  className?: string;\n}) => {\n  return (\n    <div\n      className={clsx(\"library-menu-control-buttons\", className)}\n      style={style}\n    >\n      <LibraryMenuBrowseButton\n        id={id}\n        libraryReturnUrl={libraryReturnUrl}\n        theme={theme}\n      />\n      {children}\n    </div>\n  );\n};\n",
    "import { VERSIONS } from \"@excalidraw/common\";\n\nimport { t } from \"../i18n\";\n\nimport type { ExcalidrawProps, UIAppState } from \"../types\";\n\nconst LibraryMenuBrowseButton = ({\n  theme,\n  id,\n  libraryReturnUrl,\n}: {\n  libraryReturnUrl: ExcalidrawProps[\"libraryReturnUrl\"];\n  theme: UIAppState[\"theme\"];\n  id: string;\n}) => {\n  const referrer =\n    libraryReturnUrl || window.location.origin + window.location.pathname;\n  return (\n    <a\n      className=\"library-menu-browse-button\"\n      href={`${import.meta.env.VITE_APP_LIBRARY_URL}?target=${\n        window.name || \"_blank\"\n      }&referrer=${referrer}&useHash=true&token=${id}&theme=${theme}&version=${\n        VERSIONS.excalidrawLibrary\n      }`}\n      target=\"_excalidraw_libraries\"\n    >\n      {t(\"labels.libraries\")}\n    </a>\n  );\n};\n\nexport default LibraryMenuBrowseButton;\n",
    "import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\nimport { MIME_TYPES, arrayToMap } from \"@excalidraw/common\";\n\nimport { duplicateElements } from \"@excalidraw/element\";\n\nimport { serializeLibraryAsJSON } from \"../data/json\";\nimport { useLibraryCache } from \"../hooks/useLibraryItemSvg\";\nimport { useScrollPosition } from \"../hooks/useScrollPosition\";\nimport { t } from \"../i18n\";\n\nimport { LibraryMenuControlButtons } from \"./LibraryMenuControlButtons\";\nimport { LibraryDropdownMenu } from \"./LibraryMenuHeaderContent\";\nimport {\n  LibraryMenuSection,\n  LibraryMenuSectionGrid,\n} from \"./LibraryMenuSection\";\n\nimport Spinner from \"./Spinner\";\nimport Stack from \"./Stack\";\n\nimport \"./LibraryMenuItems.scss\";\n\nimport type {\n  ExcalidrawProps,\n  LibraryItem,\n  LibraryItems,\n  UIAppState,\n} from \"../types\";\n\n// using an odd number of items per batch so the rendering creates an irregular\n// pattern which looks more organic\nconst ITEMS_RENDERED_PER_BATCH = 17;\n// when render outputs cached we can render many more items per batch to\n// speed it up\nconst CACHED_ITEMS_RENDERED_PER_BATCH = 64;\n\nexport default function LibraryMenuItems({\n  isLoading,\n  libraryItems,\n  onAddToLibrary,\n  onInsertLibraryItems,\n  pendingElements,\n  theme,\n  id,\n  libraryReturnUrl,\n  onSelectItems,\n  selectedItems,\n}: {\n  isLoading: boolean;\n  libraryItems: LibraryItems;\n  pendingElements: LibraryItem[\"elements\"];\n  onInsertLibraryItems: (libraryItems: LibraryItems) => void;\n  onAddToLibrary: (elements: LibraryItem[\"elements\"]) => void;\n  libraryReturnUrl: ExcalidrawProps[\"libraryReturnUrl\"];\n  theme: UIAppState[\"theme\"];\n  id: string;\n  selectedItems: LibraryItem[\"id\"][];\n  onSelectItems: (id: LibraryItem[\"id\"][]) => void;\n}) {\n  const libraryContainerRef = useRef<HTMLDivElement>(null);\n  const scrollPosition = useScrollPosition<HTMLDivElement>(libraryContainerRef);\n\n  // This effect has to be called only on first render, therefore  `scrollPosition` isn't in the dependency array\n  useEffect(() => {\n    if (scrollPosition > 0) {\n      libraryContainerRef.current?.scrollTo(0, scrollPosition);\n    }\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const { svgCache } = useLibraryCache();\n  const unpublishedItems = useMemo(\n    () => libraryItems.filter((item) => item.status !== \"published\"),\n    [libraryItems],\n  );\n\n  const publishedItems = useMemo(\n    () => libraryItems.filter((item) => item.status === \"published\"),\n    [libraryItems],\n  );\n\n  const showBtn = !libraryItems.length && !pendingElements.length;\n\n  const isLibraryEmpty =\n    !pendingElements.length &&\n    !unpublishedItems.length &&\n    !publishedItems.length;\n\n  const [lastSelectedItem, setLastSelectedItem] = useState<\n    LibraryItem[\"id\"] | null\n  >(null);\n\n  const onItemSelectToggle = useCallback(\n    (id: LibraryItem[\"id\"], event: React.MouseEvent) => {\n      const shouldSelect = !selectedItems.includes(id);\n\n      const orderedItems = [...unpublishedItems, ...publishedItems];\n\n      if (shouldSelect) {\n        if (event.shiftKey && lastSelectedItem) {\n          const rangeStart = orderedItems.findIndex(\n            (item) => item.id === lastSelectedItem,\n          );\n          const rangeEnd = orderedItems.findIndex((item) => item.id === id);\n\n          if (rangeStart === -1 || rangeEnd === -1) {\n            onSelectItems([...selectedItems, id]);\n            return;\n          }\n\n          const selectedItemsMap = arrayToMap(selectedItems);\n          const nextSelectedIds = orderedItems.reduce(\n            (acc: LibraryItem[\"id\"][], item, idx) => {\n              if (\n                (idx >= rangeStart && idx <= rangeEnd) ||\n                selectedItemsMap.has(item.id)\n              ) {\n                acc.push(item.id);\n              }\n              return acc;\n            },\n            [],\n          );\n\n          onSelectItems(nextSelectedIds);\n        } else {\n          onSelectItems([...selectedItems, id]);\n        }\n        setLastSelectedItem(id);\n      } else {\n        setLastSelectedItem(null);\n        onSelectItems(selectedItems.filter((_id) => _id !== id));\n      }\n    },\n    [\n      lastSelectedItem,\n      onSelectItems,\n      publishedItems,\n      selectedItems,\n      unpublishedItems,\n    ],\n  );\n\n  const getInsertedElements = useCallback(\n    (id: string) => {\n      let targetElements;\n      if (selectedItems.includes(id)) {\n        targetElements = libraryItems.filter((item) =>\n          selectedItems.includes(item.id),\n        );\n      } else {\n        targetElements = libraryItems.filter((item) => item.id === id);\n      }\n      return targetElements.map((item) => {\n        return {\n          ...item,\n          // duplicate each library item before inserting on canvas to confine\n          // ids and bindings to each library item. See #6465\n          elements: duplicateElements({\n            type: \"everything\",\n            elements: item.elements,\n            randomizeSeed: true,\n          }).duplicatedElements,\n        };\n      });\n    },\n    [libraryItems, selectedItems],\n  );\n\n  const onItemDrag = useCallback(\n    (id: LibraryItem[\"id\"], event: React.DragEvent) => {\n      event.dataTransfer.setData(\n        MIME_TYPES.excalidrawlib,\n        serializeLibraryAsJSON(getInsertedElements(id)),\n      );\n    },\n    [getInsertedElements],\n  );\n\n  const isItemSelected = useCallback(\n    (id: LibraryItem[\"id\"] | null) => {\n      if (!id) {\n        return false;\n      }\n\n      return selectedItems.includes(id);\n    },\n    [selectedItems],\n  );\n\n  const onAddToLibraryClick = useCallback(() => {\n    onAddToLibrary(pendingElements);\n  }, [pendingElements, onAddToLibrary]);\n\n  const onItemClick = useCallback(\n    (id: LibraryItem[\"id\"] | null) => {\n      if (id) {\n        onInsertLibraryItems(getInsertedElements(id));\n      }\n    },\n    [getInsertedElements, onInsertLibraryItems],\n  );\n\n  const itemsRenderedPerBatch =\n    svgCache.size >= libraryItems.length\n      ? CACHED_ITEMS_RENDERED_PER_BATCH\n      : ITEMS_RENDERED_PER_BATCH;\n\n  return (\n    <div\n      className=\"library-menu-items-container\"\n      style={\n        pendingElements.length ||\n        unpublishedItems.length ||\n        publishedItems.length\n          ? { justifyContent: \"flex-start\" }\n          : { borderBottom: 0 }\n      }\n    >\n      {!isLibraryEmpty && (\n        <LibraryDropdownMenu\n          selectedItems={selectedItems}\n          onSelectItems={onSelectItems}\n          className=\"library-menu-dropdown-container--in-heading\"\n        />\n      )}\n      <Stack.Col\n        className=\"library-menu-items-container__items\"\n        align=\"start\"\n        gap={1}\n        style={{\n          flex: publishedItems.length > 0 ? 1 : \"0 1 auto\",\n          marginBottom: 0,\n        }}\n        ref={libraryContainerRef}\n      >\n        <>\n          {!isLibraryEmpty && (\n            <div className=\"library-menu-items-container__header\">\n              {t(\"labels.personalLib\")}\n            </div>\n          )}\n          {isLoading && (\n            <div\n              style={{\n                position: \"absolute\",\n                top: \"var(--container-padding-y)\",\n                right: \"var(--container-padding-x)\",\n                transform: \"translateY(50%)\",\n              }}\n            >\n              <Spinner />\n            </div>\n          )}\n          {!pendingElements.length && !unpublishedItems.length ? (\n            <div className=\"library-menu-items__no-items\">\n              <div className=\"library-menu-items__no-items__label\">\n                {t(\"library.noItems\")}\n              </div>\n              <div className=\"library-menu-items__no-items__hint\">\n                {publishedItems.length > 0\n                  ? t(\"library.hint_emptyPrivateLibrary\")\n                  : t(\"library.hint_emptyLibrary\")}\n              </div>\n            </div>\n          ) : (\n            <LibraryMenuSectionGrid>\n              {pendingElements.length > 0 && (\n                <LibraryMenuSection\n                  itemsRenderedPerBatch={itemsRenderedPerBatch}\n                  items={[{ id: null, elements: pendingElements }]}\n                  onItemSelectToggle={onItemSelectToggle}\n                  onItemDrag={onItemDrag}\n                  onClick={onAddToLibraryClick}\n                  isItemSelected={isItemSelected}\n                  svgCache={svgCache}\n                />\n              )}\n              <LibraryMenuSection\n                itemsRenderedPerBatch={itemsRenderedPerBatch}\n                items={unpublishedItems}\n                onItemSelectToggle={onItemSelectToggle}\n                onItemDrag={onItemDrag}\n                onClick={onItemClick}\n                isItemSelected={isItemSelected}\n                svgCache={svgCache}\n              />\n            </LibraryMenuSectionGrid>\n          )}\n        </>\n\n        <>\n          {(publishedItems.length > 0 ||\n            pendingElements.length > 0 ||\n            unpublishedItems.length > 0) && (\n            <div className=\"library-menu-items-container__header library-menu-items-container__header--excal\">\n              {t(\"labels.excalidrawLib\")}\n            </div>\n          )}\n          {publishedItems.length > 0 ? (\n            <LibraryMenuSectionGrid>\n              <LibraryMenuSection\n                itemsRenderedPerBatch={itemsRenderedPerBatch}\n                items={publishedItems}\n                onItemSelectToggle={onItemSelectToggle}\n                onItemDrag={onItemDrag}\n                onClick={onItemClick}\n                isItemSelected={isItemSelected}\n                svgCache={svgCache}\n              />\n            </LibraryMenuSectionGrid>\n          ) : unpublishedItems.length > 0 ? (\n            <div\n              style={{\n                margin: \"1rem 0\",\n                display: \"flex\",\n                flexDirection: \"column\",\n                alignItems: \"center\",\n                justifyContent: \"center\",\n                width: \"100%\",\n                fontSize: \".9rem\",\n              }}\n            >\n              {t(\"library.noItems\")}\n            </div>\n          ) : null}\n        </>\n\n        {showBtn && (\n          <LibraryMenuControlButtons\n            style={{ padding: \"16px 0\", width: \"100%\" }}\n            id={id}\n            libraryReturnUrl={libraryReturnUrl}\n            theme={theme}\n          >\n            <LibraryDropdownMenu\n              selectedItems={selectedItems}\n              onSelectItems={onSelectItems}\n            />\n          </LibraryMenuControlButtons>\n        )}\n      </Stack.Col>\n    </div>\n  );\n}\n",
    "import throttle from \"lodash.throttle\";\nimport { useEffect } from \"react\";\n\nimport { atom, useAtom } from \"../editor-jotai\";\n\nconst scrollPositionAtom = atom<number>(0);\n\nexport const useScrollPosition = <T extends HTMLElement>(\n  elementRef: React.RefObject<T | null>,\n) => {\n  const [scrollPosition, setScrollPosition] = useAtom(scrollPositionAtom);\n\n  useEffect(() => {\n    const { current: element } = elementRef;\n    if (!element) {\n      return;\n    }\n\n    const handleScroll = throttle(() => {\n      const { scrollTop } = element;\n      setScrollPosition(scrollTop);\n    }, 200);\n\n    element.addEventListener(\"scroll\", handleScroll);\n\n    return () => {\n      handleScroll.cancel();\n      element.removeEventListener(\"scroll\", handleScroll);\n    };\n  }, [elementRef, setScrollPosition]);\n\n  return scrollPosition;\n};\n",
    "import clsx from \"clsx\";\nimport { useCallback, useState } from \"react\";\n\nimport { muteFSAbortError } from \"@excalidraw/common\";\n\nimport { useUIAppState } from \"../context/ui-appState\";\nimport { fileOpen } from \"../data/filesystem\";\nimport { saveLibraryAsJSON } from \"../data/json\";\nimport { libraryItemsAtom } from \"../data/library\";\nimport { useAtom } from \"../editor-jotai\";\nimport { useLibraryCache } from \"../hooks/useLibraryItemSvg\";\nimport { t } from \"../i18n\";\n\nimport { useApp, useExcalidrawSetAppState } from \"./App\";\nimport ConfirmDialog from \"./ConfirmDialog\";\nimport { Dialog } from \"./Dialog\";\nimport { isLibraryMenuOpenAtom } from \"./LibraryMenu\";\nimport PublishLibrary from \"./PublishLibrary\";\nimport { ToolButton } from \"./ToolButton\";\nimport Trans from \"./Trans\";\nimport DropdownMenu from \"./dropdownMenu/DropdownMenu\";\nimport {\n  DotsIcon,\n  ExportIcon,\n  LoadIcon,\n  publishIcon,\n  TrashIcon,\n} from \"./icons\";\n\nimport type Library from \"../data/library\";\nimport type { LibraryItem, LibraryItems, UIAppState } from \"../types\";\n\nconst getSelectedItems = (\n  libraryItems: LibraryItems,\n  selectedItems: LibraryItem[\"id\"][],\n) => libraryItems.filter((item) => selectedItems.includes(item.id));\n\nexport const LibraryDropdownMenuButton: React.FC<{\n  setAppState: React.Component<any, UIAppState>[\"setState\"];\n  selectedItems: LibraryItem[\"id\"][];\n  library: Library;\n  onRemoveFromLibrary: () => void;\n  resetLibrary: () => void;\n  onSelectItems: (items: LibraryItem[\"id\"][]) => void;\n  appState: UIAppState;\n  className?: string;\n}> = ({\n  setAppState,\n  selectedItems,\n  library,\n  onRemoveFromLibrary,\n  resetLibrary,\n  onSelectItems,\n  appState,\n  className,\n}) => {\n  const [libraryItemsData] = useAtom(libraryItemsAtom);\n  const [isLibraryMenuOpen, setIsLibraryMenuOpen] = useAtom(\n    isLibraryMenuOpenAtom,\n  );\n\n  const renderRemoveLibAlert = () => {\n    const content = selectedItems.length\n      ? t(\"alerts.removeItemsFromsLibrary\", { count: selectedItems.length })\n      : t(\"alerts.resetLibrary\");\n    const title = selectedItems.length\n      ? t(\"confirmDialog.removeItemsFromLib\")\n      : t(\"confirmDialog.resetLibrary\");\n    return (\n      <ConfirmDialog\n        onConfirm={() => {\n          if (selectedItems.length) {\n            onRemoveFromLibrary();\n          } else {\n            resetLibrary();\n          }\n          setShowRemoveLibAlert(false);\n        }}\n        onCancel={() => {\n          setShowRemoveLibAlert(false);\n        }}\n        title={title}\n      >\n        <p>{content}</p>\n      </ConfirmDialog>\n    );\n  };\n\n  const [showRemoveLibAlert, setShowRemoveLibAlert] = useState(false);\n\n  const itemsSelected = !!selectedItems.length;\n  const items = itemsSelected\n    ? libraryItemsData.libraryItems.filter((item) =>\n        selectedItems.includes(item.id),\n      )\n    : libraryItemsData.libraryItems;\n  const resetLabel = itemsSelected\n    ? t(\"buttons.remove\")\n    : t(\"buttons.resetLibrary\");\n\n  const [showPublishLibraryDialog, setShowPublishLibraryDialog] =\n    useState(false);\n  const [publishLibSuccess, setPublishLibSuccess] = useState<null | {\n    url: string;\n    authorName: string;\n  }>(null);\n  const renderPublishSuccess = useCallback(() => {\n    return (\n      <Dialog\n        onCloseRequest={() => setPublishLibSuccess(null)}\n        title={t(\"publishSuccessDialog.title\")}\n        className=\"publish-library-success\"\n        size=\"small\"\n      >\n        <p>\n          <Trans\n            i18nKey=\"publishSuccessDialog.content\"\n            authorName={publishLibSuccess!.authorName}\n            link={(el) => (\n              <a\n                href={publishLibSuccess?.url}\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n              >\n                {el}\n              </a>\n            )}\n          />\n        </p>\n        <ToolButton\n          type=\"button\"\n          title={t(\"buttons.close\")}\n          aria-label={t(\"buttons.close\")}\n          label={t(\"buttons.close\")}\n          onClick={() => setPublishLibSuccess(null)}\n          data-testid=\"publish-library-success-close\"\n          className=\"publish-library-success-close\"\n        />\n      </Dialog>\n    );\n  }, [setPublishLibSuccess, publishLibSuccess]);\n\n  const onPublishLibSuccess = (\n    data: { url: string; authorName: string },\n    libraryItems: LibraryItems,\n  ) => {\n    setShowPublishLibraryDialog(false);\n    setPublishLibSuccess({ url: data.url, authorName: data.authorName });\n    const nextLibItems = libraryItems.slice();\n    nextLibItems.forEach((libItem) => {\n      if (selectedItems.includes(libItem.id)) {\n        libItem.status = \"published\";\n      }\n    });\n    library.setLibrary(nextLibItems);\n  };\n\n  const onLibraryImport = async () => {\n    try {\n      await library.updateLibrary({\n        libraryItems: fileOpen({\n          description: \"Excalidraw library files\",\n          // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442\n          // gets resolved. Else, iOS users cannot open `.excalidraw` files.\n          /*\n            extensions: [\".json\", \".excalidrawlib\"],\n            */\n        }),\n        merge: true,\n        openLibraryMenu: true,\n      });\n    } catch (error: any) {\n      if (error?.name === \"AbortError\") {\n        console.warn(error);\n        return;\n      }\n      setAppState({ errorMessage: t(\"errors.importLibraryError\") });\n    }\n  };\n\n  const onLibraryExport = async () => {\n    const libraryItems = itemsSelected\n      ? items\n      : await library.getLatestLibrary();\n    saveLibraryAsJSON(libraryItems)\n      .catch(muteFSAbortError)\n      .catch((error) => {\n        setAppState({ errorMessage: error.message });\n      });\n  };\n\n  const renderLibraryMenu = () => {\n    return (\n      <DropdownMenu open={isLibraryMenuOpen}>\n        <DropdownMenu.Trigger\n          onToggle={() => setIsLibraryMenuOpen(!isLibraryMenuOpen)}\n        >\n          {DotsIcon}\n        </DropdownMenu.Trigger>\n        <DropdownMenu.Content\n          onClickOutside={() => setIsLibraryMenuOpen(false)}\n          onSelect={() => setIsLibraryMenuOpen(false)}\n          className=\"library-menu\"\n        >\n          {!itemsSelected && (\n            <DropdownMenu.Item\n              onSelect={onLibraryImport}\n              icon={LoadIcon}\n              data-testid=\"lib-dropdown--load\"\n            >\n              {t(\"buttons.load\")}\n            </DropdownMenu.Item>\n          )}\n          {!!items.length && (\n            <DropdownMenu.Item\n              onSelect={onLibraryExport}\n              icon={ExportIcon}\n              data-testid=\"lib-dropdown--export\"\n            >\n              {t(\"buttons.export\")}\n            </DropdownMenu.Item>\n          )}\n          {!!items.length && (\n            <DropdownMenu.Item\n              onSelect={() => setShowRemoveLibAlert(true)}\n              icon={TrashIcon}\n            >\n              {resetLabel}\n            </DropdownMenu.Item>\n          )}\n          {itemsSelected && (\n            <DropdownMenu.Item\n              icon={publishIcon}\n              onSelect={() => setShowPublishLibraryDialog(true)}\n              data-testid=\"lib-dropdown--remove\"\n            >\n              {t(\"buttons.publishLibrary\")}\n            </DropdownMenu.Item>\n          )}\n        </DropdownMenu.Content>\n      </DropdownMenu>\n    );\n  };\n\n  return (\n    <div className={clsx(\"library-menu-dropdown-container\", className)}>\n      {renderLibraryMenu()}\n      {selectedItems.length > 0 && (\n        <div className=\"library-actions-counter\">{selectedItems.length}</div>\n      )}\n      {showRemoveLibAlert && renderRemoveLibAlert()}\n      {showPublishLibraryDialog && (\n        <PublishLibrary\n          onClose={() => setShowPublishLibraryDialog(false)}\n          libraryItems={getSelectedItems(\n            libraryItemsData.libraryItems,\n            selectedItems,\n          )}\n          appState={appState}\n          onSuccess={(data) =>\n            onPublishLibSuccess(data, libraryItemsData.libraryItems)\n          }\n          onError={(error) => window.alert(error)}\n          updateItemsInStorage={() =>\n            library.setLibrary(libraryItemsData.libraryItems)\n          }\n          onRemove={(id: string) =>\n            onSelectItems(selectedItems.filter((_id) => _id !== id))\n          }\n        />\n      )}\n      {publishLibSuccess && renderPublishSuccess()}\n    </div>\n  );\n};\n\nexport const LibraryDropdownMenu = ({\n  selectedItems,\n  onSelectItems,\n  className,\n}: {\n  selectedItems: LibraryItem[\"id\"][];\n  onSelectItems: (id: LibraryItem[\"id\"][]) => void;\n  className?: string;\n}) => {\n  const { library } = useApp();\n  const { clearLibraryCache, deleteItemsFromLibraryCache } = useLibraryCache();\n  const appState = useUIAppState();\n  const setAppState = useExcalidrawSetAppState();\n\n  const [libraryItemsData] = useAtom(libraryItemsAtom);\n\n  const removeFromLibrary = async (libraryItems: LibraryItems) => {\n    const nextItems = libraryItems.filter(\n      (item) => !selectedItems.includes(item.id),\n    );\n    library.setLibrary(nextItems).catch(() => {\n      setAppState({ errorMessage: t(\"alerts.errorRemovingFromLibrary\") });\n    });\n\n    deleteItemsFromLibraryCache(selectedItems);\n\n    onSelectItems([]);\n  };\n\n  const resetLibrary = () => {\n    library.resetLibrary();\n    clearLibraryCache();\n  };\n\n  return (\n    <LibraryDropdownMenuButton\n      appState={appState}\n      setAppState={setAppState}\n      selectedItems={selectedItems}\n      onSelectItems={onSelectItems}\n      library={library}\n      onRemoveFromLibrary={() =>\n        removeFromLibrary(libraryItemsData.libraryItems)\n      }\n      resetLibrary={resetLibrary}\n      className={className}\n    />\n  );\n};\n",
    "import { flushSync } from \"react-dom\";\n\nimport { useSetAtom } from \"../editor-jotai\";\nimport { t } from \"../i18n\";\n\nimport { Dialog } from \"./Dialog\";\nimport DialogActionButton from \"./DialogActionButton\";\nimport { isLibraryMenuOpenAtom } from \"./LibraryMenu\";\nimport { useExcalidrawContainer, useExcalidrawSetAppState } from \"./App\";\n\nimport \"./ConfirmDialog.scss\";\n\nimport type { DialogProps } from \"./Dialog\";\n\ninterface Props extends Omit<DialogProps, \"onCloseRequest\"> {\n  onConfirm: () => void;\n  onCancel: () => void;\n  confirmText?: string;\n  cancelText?: string;\n}\nconst ConfirmDialog = (props: Props) => {\n  const {\n    onConfirm,\n    onCancel,\n    children,\n    confirmText = t(\"buttons.confirm\"),\n    cancelText = t(\"buttons.cancel\"),\n    className = \"\",\n    ...rest\n  } = props;\n  const setAppState = useExcalidrawSetAppState();\n  const setIsLibraryMenuOpen = useSetAtom(isLibraryMenuOpenAtom);\n  const { container } = useExcalidrawContainer();\n\n  return (\n    <Dialog\n      onCloseRequest={onCancel}\n      size=\"small\"\n      {...rest}\n      className={`confirm-dialog ${className}`}\n    >\n      {children}\n      <div className=\"confirm-dialog-buttons\">\n        <DialogActionButton\n          label={cancelText}\n          onClick={() => {\n            setAppState({ openMenu: null });\n            setIsLibraryMenuOpen(false);\n            // flush any pending updates synchronously,\n            // otherwise it could lead to crash in some chromium versions (131.0.6778.86),\n            // when `.focus` is invoked with container in some intermediate state\n            // (container seems mounted in DOM, but focus still causes a crash)\n            flushSync(() => {\n              onCancel();\n            });\n\n            container?.focus();\n          }}\n        />\n        <DialogActionButton\n          label={confirmText}\n          onClick={() => {\n            setAppState({ openMenu: null });\n            setIsLibraryMenuOpen(false);\n            // flush any pending updates synchronously,\n            // otherwise it leads to crash in some chromium versions (131.0.6778.86),\n            // when `.focus` is invoked with container in some intermediate state\n            // (container seems mounted in DOM, but focus still causes a crash)\n            flushSync(() => {\n              onConfirm();\n            });\n\n            container?.focus();\n          }}\n          actionType=\"danger\"\n        />\n      </div>\n    </Dialog>\n  );\n};\nexport default ConfirmDialog;\n",
    "import clsx from \"clsx\";\n\nimport Spinner from \"./Spinner\";\n\nimport \"./DialogActionButton.scss\";\n\nimport type { ReactNode } from \"react\";\n\ninterface DialogActionButtonProps {\n  label: string;\n  children?: ReactNode;\n  actionType?: \"primary\" | \"danger\";\n  isLoading?: boolean;\n}\n\nconst DialogActionButton = ({\n  label,\n  onClick,\n  className,\n  children,\n  actionType,\n  type = \"button\",\n  isLoading,\n  ...rest\n}: DialogActionButtonProps & React.ButtonHTMLAttributes<HTMLButtonElement>) => {\n  const cs = actionType ? `Dialog__action-button--${actionType}` : \"\";\n\n  return (\n    <button\n      className={clsx(\"Dialog__action-button\", cs, className)}\n      type={type}\n      aria-label={label}\n      onClick={onClick}\n      {...rest}\n    >\n      {children && (\n        <div style={isLoading ? { visibility: \"hidden\" } : {}}>{children}</div>\n      )}\n      <div style={isLoading ? { visibility: \"hidden\" } : {}}>{label}</div>\n      {isLoading && (\n        <div style={{ position: \"absolute\", inset: 0 }}>\n          <Spinner />\n        </div>\n      )}\n    </button>\n  );\n};\n\nexport default DialogActionButton;\n",
    "import { exportToCanvas, exportToSvg } from \"@excalidraw/utils/export\";\nimport OpenColor from \"open-color\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\nimport {\n  EDITOR_LS_KEYS,\n  EXPORT_DATA_TYPES,\n  MIME_TYPES,\n  VERSIONS,\n  chunk,\n  getExportSource,\n} from \"@excalidraw/common\";\n\nimport { EditorLocalStorage } from \"../data/EditorLocalStorage\";\nimport { canvasToBlob, resizeImageFile } from \"../data/blob\";\nimport { t } from \"../i18n\";\n\nimport { Dialog } from \"./Dialog\";\nimport DialogActionButton from \"./DialogActionButton\";\nimport { ToolButton } from \"./ToolButton\";\nimport Trans from \"./Trans\";\nimport { CloseIcon } from \"./icons\";\n\nimport \"./PublishLibrary.scss\";\n\nimport type { ReactNode } from \"react\";\nimport type { ExportedLibraryData } from \"../data/types\";\nimport type { LibraryItems, LibraryItem, UIAppState } from \"../types\";\n\ninterface PublishLibraryDataParams {\n  authorName: string;\n  githubHandle: string;\n  name: string;\n  description: string;\n  twitterHandle: string;\n  website: string;\n}\n\nconst generatePreviewImage = async (libraryItems: LibraryItems) => {\n  const MAX_ITEMS_PER_ROW = 6;\n  const BOX_SIZE = 128;\n  const BOX_PADDING = Math.round(BOX_SIZE / 16);\n  const BORDER_WIDTH = Math.max(Math.round(BOX_SIZE / 64), 2);\n\n  const rows = chunk(libraryItems, MAX_ITEMS_PER_ROW);\n\n  const canvas = document.createElement(\"canvas\");\n\n  canvas.width =\n    rows[0].length * BOX_SIZE +\n    (rows[0].length + 1) * (BOX_PADDING * 2) -\n    BOX_PADDING * 2;\n  canvas.height =\n    rows.length * BOX_SIZE +\n    (rows.length + 1) * (BOX_PADDING * 2) -\n    BOX_PADDING * 2;\n\n  const ctx = canvas.getContext(\"2d\")!;\n\n  ctx.fillStyle = OpenColor.white;\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  // draw items\n  // ---------------------------------------------------------------------------\n  for (const [index, item] of libraryItems.entries()) {\n    const itemCanvas = await exportToCanvas({\n      elements: item.elements,\n      files: null,\n      maxWidthOrHeight: BOX_SIZE,\n    });\n\n    const { width, height } = itemCanvas;\n\n    // draw item\n    // -------------------------------------------------------------------------\n    const rowOffset =\n      Math.floor(index / MAX_ITEMS_PER_ROW) * (BOX_SIZE + BOX_PADDING * 2);\n    const colOffset =\n      (index % MAX_ITEMS_PER_ROW) * (BOX_SIZE + BOX_PADDING * 2);\n\n    ctx.drawImage(\n      itemCanvas,\n      colOffset + (BOX_SIZE - width) / 2 + BOX_PADDING,\n      rowOffset + (BOX_SIZE - height) / 2 + BOX_PADDING,\n    );\n\n    // draw item border\n    // -------------------------------------------------------------------------\n    ctx.lineWidth = BORDER_WIDTH;\n    ctx.strokeStyle = OpenColor.gray[4];\n    ctx.strokeRect(\n      colOffset + BOX_PADDING / 2,\n      rowOffset + BOX_PADDING / 2,\n      BOX_SIZE + BOX_PADDING,\n      BOX_SIZE + BOX_PADDING,\n    );\n  }\n\n  return await resizeImageFile(\n    new File([await canvasToBlob(canvas)], \"preview\", { type: MIME_TYPES.png }),\n    {\n      outputType: MIME_TYPES.jpg,\n      maxWidthOrHeight: 5000,\n    },\n  );\n};\n\nconst SingleLibraryItem = ({\n  libItem,\n  appState,\n  index,\n  onChange,\n  onRemove,\n}: {\n  libItem: LibraryItem;\n  appState: UIAppState;\n  index: number;\n  onChange: (val: string, index: number) => void;\n  onRemove: (id: string) => void;\n}) => {\n  const svgRef = useRef<HTMLDivElement | null>(null);\n  const inputRef = useRef<HTMLInputElement | null>(null);\n\n  useEffect(() => {\n    const node = svgRef.current;\n    if (!node) {\n      return;\n    }\n    (async () => {\n      const svg = await exportToSvg({\n        elements: libItem.elements,\n        appState: {\n          ...appState,\n          viewBackgroundColor: OpenColor.white,\n          exportBackground: true,\n        },\n        files: null,\n        skipInliningFonts: true,\n      });\n      node.innerHTML = svg.outerHTML;\n    })();\n  }, [libItem.elements, appState]);\n\n  return (\n    <div className=\"single-library-item\">\n      {libItem.status === \"published\" && (\n        <span className=\"single-library-item-status\">\n          {t(\"labels.statusPublished\")}\n        </span>\n      )}\n      <div ref={svgRef} className=\"single-library-item__svg\" />\n      <ToolButton\n        aria-label={t(\"buttons.remove\")}\n        type=\"button\"\n        icon={CloseIcon}\n        className=\"single-library-item--remove\"\n        onClick={onRemove.bind(null, libItem.id)}\n        title={t(\"buttons.remove\")}\n      />\n      <div\n        style={{\n          display: \"flex\",\n          margin: \"0.8rem 0\",\n          width: \"100%\",\n          fontSize: \"14px\",\n          fontWeight: 500,\n          flexDirection: \"column\",\n        }}\n      >\n        <label\n          style={{\n            display: \"flex\",\n            justifyContent: \"space-between\",\n            flexDirection: \"column\",\n          }}\n        >\n          <div style={{ padding: \"0.5em 0\" }}>\n            <span style={{ fontWeight: 500, color: OpenColor.gray[6] }}>\n              {t(\"publishDialog.itemName\")}\n            </span>\n            <span aria-hidden=\"true\" className=\"required\">\n              *\n            </span>\n          </div>\n          <input\n            type=\"text\"\n            ref={inputRef}\n            style={{ width: \"80%\", padding: \"0.2rem\" }}\n            defaultValue={libItem.name}\n            placeholder=\"Item name\"\n            onChange={(event) => {\n              onChange(event.target.value, index);\n            }}\n          />\n        </label>\n        <span className=\"error\">{libItem.error}</span>\n      </div>\n    </div>\n  );\n};\n\nconst PublishLibrary = ({\n  onClose,\n  libraryItems,\n  appState,\n  onSuccess,\n  onError,\n  updateItemsInStorage,\n  onRemove,\n}: {\n  onClose: () => void;\n  libraryItems: LibraryItems;\n  appState: UIAppState;\n  onSuccess: (data: {\n    url: string;\n    authorName: string;\n    items: LibraryItems;\n  }) => void;\n\n  onError: (error: Error) => void;\n  updateItemsInStorage: (items: LibraryItems) => void;\n  onRemove: (id: string) => void;\n}) => {\n  const [libraryData, setLibraryData] = useState<PublishLibraryDataParams>({\n    authorName: \"\",\n    githubHandle: \"\",\n    name: \"\",\n    description: \"\",\n    twitterHandle: \"\",\n    website: \"\",\n  });\n\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  useEffect(() => {\n    const data = EditorLocalStorage.get<PublishLibraryDataParams>(\n      EDITOR_LS_KEYS.PUBLISH_LIBRARY,\n    );\n    if (data) {\n      setLibraryData(data);\n    }\n  }, []);\n\n  const [clonedLibItems, setClonedLibItems] = useState<LibraryItems>(\n    libraryItems.slice(),\n  );\n\n  useEffect(() => {\n    setClonedLibItems(libraryItems.slice());\n  }, [libraryItems]);\n\n  const onInputChange = (event: any) => {\n    setLibraryData({\n      ...libraryData,\n      [event.target.name]: event.target.value,\n    });\n  };\n\n  const onSubmit = async (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    setIsSubmitting(true);\n    const erroredLibItems: LibraryItem[] = [];\n    let isError = false;\n    clonedLibItems.forEach((libItem) => {\n      let error = \"\";\n      if (!libItem.name) {\n        error = t(\"publishDialog.errors.required\");\n        isError = true;\n      }\n      erroredLibItems.push({ ...libItem, error });\n    });\n\n    if (isError) {\n      setClonedLibItems(erroredLibItems);\n      setIsSubmitting(false);\n      return;\n    }\n\n    const previewImage = await generatePreviewImage(clonedLibItems);\n\n    const libContent: ExportedLibraryData = {\n      type: EXPORT_DATA_TYPES.excalidrawLibrary,\n      version: VERSIONS.excalidrawLibrary,\n      source: getExportSource(),\n      libraryItems: clonedLibItems,\n    };\n    const content = JSON.stringify(libContent, null, 2);\n    const lib = new Blob([content], { type: \"application/json\" });\n\n    const formData = new FormData();\n    formData.append(\"excalidrawLib\", lib);\n    formData.append(\"previewImage\", previewImage);\n    formData.append(\"previewImageType\", previewImage.type);\n    formData.append(\"title\", libraryData.name);\n    formData.append(\"authorName\", libraryData.authorName);\n    formData.append(\"githubHandle\", libraryData.githubHandle);\n    formData.append(\"name\", libraryData.name);\n    formData.append(\"description\", libraryData.description);\n    formData.append(\"twitterHandle\", libraryData.twitterHandle);\n    formData.append(\"website\", libraryData.website);\n\n    fetch(`${import.meta.env.VITE_APP_LIBRARY_BACKEND}/submit`, {\n      method: \"post\",\n      body: formData,\n    })\n      .then(\n        (response) => {\n          if (response.ok) {\n            return response.json().then(({ url }) => {\n              // flush data from local storage\n              EditorLocalStorage.delete(EDITOR_LS_KEYS.PUBLISH_LIBRARY);\n              onSuccess({\n                url,\n                authorName: libraryData.authorName,\n                items: clonedLibItems,\n              });\n            });\n          }\n          return response\n            .json()\n            .catch(() => {\n              throw new Error(response.statusText || \"something went wrong\");\n            })\n            .then((error) => {\n              throw new Error(\n                error.message || response.statusText || \"something went wrong\",\n              );\n            });\n        },\n        (err) => {\n          console.error(err);\n          onError(err);\n          setIsSubmitting(false);\n        },\n      )\n      .catch((err) => {\n        console.error(err);\n        onError(err);\n        setIsSubmitting(false);\n      });\n  };\n\n  const renderLibraryItems = () => {\n    const items: ReactNode[] = [];\n    clonedLibItems.forEach((libItem, index) => {\n      items.push(\n        <div className=\"single-library-item-wrapper\" key={index}>\n          <SingleLibraryItem\n            libItem={libItem}\n            appState={appState}\n            index={index}\n            onChange={(val, index) => {\n              const items = clonedLibItems.slice();\n              items[index].name = val;\n              setClonedLibItems(items);\n            }}\n            onRemove={onRemove}\n          />\n        </div>,\n      );\n    });\n    return <div className=\"selected-library-items\">{items}</div>;\n  };\n\n  const onDialogClose = useCallback(() => {\n    updateItemsInStorage(clonedLibItems);\n    EditorLocalStorage.set(EDITOR_LS_KEYS.PUBLISH_LIBRARY, libraryData);\n    onClose();\n  }, [clonedLibItems, onClose, updateItemsInStorage, libraryData]);\n\n  const shouldRenderForm = !!libraryItems.length;\n\n  const containsPublishedItems = libraryItems.some(\n    (item) => item.status === \"published\",\n  );\n\n  return (\n    <Dialog\n      onCloseRequest={onDialogClose}\n      title={t(\"publishDialog.title\")}\n      className=\"publish-library\"\n    >\n      {shouldRenderForm ? (\n        <form onSubmit={onSubmit}>\n          <div className=\"publish-library-note\">\n            <Trans\n              i18nKey=\"publishDialog.noteDescription\"\n              link={(el) => (\n                <a\n                  href=\"https://libraries.excalidraw.com\"\n                  target=\"_blank\"\n                  rel=\"noopener\"\n                >\n                  {el}\n                </a>\n              )}\n            />\n          </div>\n          <span className=\"publish-library-note\">\n            <Trans\n              i18nKey=\"publishDialog.noteGuidelines\"\n              link={(el) => (\n                <a\n                  href=\"https://github.com/excalidraw/excalidraw-libraries#guidelines\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                >\n                  {el}\n                </a>\n              )}\n            />\n          </span>\n\n          <div className=\"publish-library-note\">\n            {t(\"publishDialog.noteItems\")}\n          </div>\n          {containsPublishedItems && (\n            <span className=\"publish-library-note publish-library-warning\">\n              {t(\"publishDialog.republishWarning\")}\n            </span>\n          )}\n          {renderLibraryItems()}\n          <div className=\"publish-library__fields\">\n            <label>\n              <div>\n                <span>{t(\"publishDialog.libraryName\")}</span>\n                <span aria-hidden=\"true\" className=\"required\">\n                  *\n                </span>\n              </div>\n              <input\n                type=\"text\"\n                name=\"name\"\n                required\n                value={libraryData.name}\n                onChange={onInputChange}\n                placeholder={t(\"publishDialog.placeholder.libraryName\")}\n              />\n            </label>\n            <label style={{ alignItems: \"flex-start\" }}>\n              <div>\n                <span>{t(\"publishDialog.libraryDesc\")}</span>\n                <span aria-hidden=\"true\" className=\"required\">\n                  *\n                </span>\n              </div>\n              <textarea\n                name=\"description\"\n                rows={4}\n                required\n                value={libraryData.description}\n                onChange={onInputChange}\n                placeholder={t(\"publishDialog.placeholder.libraryDesc\")}\n              />\n            </label>\n            <label>\n              <div>\n                <span>{t(\"publishDialog.authorName\")}</span>\n                <span aria-hidden=\"true\" className=\"required\">\n                  *\n                </span>\n              </div>\n              <input\n                type=\"text\"\n                name=\"authorName\"\n                required\n                value={libraryData.authorName}\n                onChange={onInputChange}\n                placeholder={t(\"publishDialog.placeholder.authorName\")}\n              />\n            </label>\n            <label>\n              <span>{t(\"publishDialog.githubUsername\")}</span>\n              <input\n                type=\"text\"\n                name=\"githubHandle\"\n                value={libraryData.githubHandle}\n                onChange={onInputChange}\n                placeholder={t(\"publishDialog.placeholder.githubHandle\")}\n              />\n            </label>\n            <label>\n              <span>{t(\"publishDialog.twitterUsername\")}</span>\n              <input\n                type=\"text\"\n                name=\"twitterHandle\"\n                value={libraryData.twitterHandle}\n                onChange={onInputChange}\n                placeholder={t(\"publishDialog.placeholder.twitterHandle\")}\n              />\n            </label>\n            <label>\n              <span>{t(\"publishDialog.website\")}</span>\n              <input\n                type=\"text\"\n                name=\"website\"\n                pattern=\"https?://.+\"\n                title={t(\"publishDialog.errors.website\")}\n                value={libraryData.website}\n                onChange={onInputChange}\n                placeholder={t(\"publishDialog.placeholder.website\")}\n              />\n            </label>\n            <span className=\"publish-library-note\">\n              <Trans\n                i18nKey=\"publishDialog.noteLicense\"\n                link={(el) => (\n                  <a\n                    href=\"https://github.com/excalidraw/excalidraw-libraries/blob/main/LICENSE\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                  >\n                    {el}\n                  </a>\n                )}\n              />\n            </span>\n          </div>\n          <div className=\"publish-library__buttons\">\n            <DialogActionButton\n              label={t(\"buttons.cancel\")}\n              onClick={onDialogClose}\n              data-testid=\"cancel-clear-canvas-button\"\n            />\n            <DialogActionButton\n              type=\"submit\"\n              label={t(\"buttons.submit\")}\n              actionType=\"primary\"\n              isLoading={isSubmitting}\n            />\n          </div>\n        </form>\n      ) : (\n        <p style={{ padding: \"1em\", textAlign: \"center\", fontWeight: 500 }}>\n          {t(\"publishDialog.atleastOneLibItem\")}\n        </p>\n      )}\n    </Dialog>\n  );\n};\n\nexport default PublishLibrary;\n",
    "import type { EDITOR_LS_KEYS } from \"@excalidraw/common\";\n\nimport type { JSONValue } from \"../types\";\n\nexport class EditorLocalStorage {\n  static has(key: typeof EDITOR_LS_KEYS[keyof typeof EDITOR_LS_KEYS]) {\n    try {\n      return !!window.localStorage.getItem(key);\n    } catch (error: any) {\n      console.warn(`localStorage.getItem error: ${error.message}`);\n      return false;\n    }\n  }\n\n  static get<T extends JSONValue>(\n    key: typeof EDITOR_LS_KEYS[keyof typeof EDITOR_LS_KEYS],\n  ) {\n    try {\n      const value = window.localStorage.getItem(key);\n      if (value) {\n        return JSON.parse(value) as T;\n      }\n      return null;\n    } catch (error: any) {\n      console.warn(`localStorage.getItem error: ${error.message}`);\n      return null;\n    }\n  }\n\n  static set = (\n    key: typeof EDITOR_LS_KEYS[keyof typeof EDITOR_LS_KEYS],\n    value: JSONValue,\n  ) => {\n    try {\n      window.localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error: any) {\n      console.warn(`localStorage.setItem error: ${error.message}`);\n      return false;\n    }\n  };\n\n  static delete = (\n    name: typeof EDITOR_LS_KEYS[keyof typeof EDITOR_LS_KEYS],\n  ) => {\n    try {\n      window.localStorage.removeItem(name);\n    } catch (error: any) {\n      console.warn(`localStorage.removeItem error: ${error.message}`);\n    }\n  };\n}\n",
    "import React from \"react\";\n\nimport { useI18n } from \"../i18n\";\n\nimport type { TranslationKeys } from \"../i18n\";\n\n// Used for splitting i18nKey into tokens in Trans component\n// Example:\n// \"Please <link>click {{location}}</link> to continue.\".split(SPLIT_REGEX).filter(Boolean)\n// produces\n// [\"Please \", \"<link>\", \"click \", \"{{location}}\", \"</link>\", \" to continue.\"]\nconst SPLIT_REGEX = /({{[\\w-]+}})|(<[\\w-]+>)|(<\\/[\\w-]+>)/g;\n// Used for extracting \"location\" from \"{{location}}\"\nconst KEY_REGEXP = /{{([\\w-]+)}}/;\n// Used for extracting \"link\" from \"<link>\"\nconst TAG_START_REGEXP = /<([\\w-]+)>/;\n// Used for extracting \"link\" from \"</link>\"\nconst TAG_END_REGEXP = /<\\/([\\w-]+)>/;\n\nconst getTransChildren = (\n  format: string,\n  props: {\n    [key: string]: React.ReactNode | ((el: React.ReactNode) => React.ReactNode);\n  },\n): React.ReactNode[] => {\n  const stack: { name: string; children: React.ReactNode[] }[] = [\n    {\n      name: \"\",\n      children: [],\n    },\n  ];\n\n  format\n    .split(SPLIT_REGEX)\n    .filter(Boolean)\n    .forEach((match) => {\n      const tagStartMatch = match.match(TAG_START_REGEXP);\n      const tagEndMatch = match.match(TAG_END_REGEXP);\n      const keyMatch = match.match(KEY_REGEXP);\n\n      if (tagStartMatch !== null) {\n        // The match is <tag>. Set the tag name as the name if it's one of the\n        // props, e.g. for \"Please <link>click the button</link> to continue\"\n        // tagStartMatch[1] = \"link\" and props contain \"link\" then it will be\n        // pushed to stack.\n        const name = tagStartMatch[1];\n        if (props.hasOwnProperty(name)) {\n          stack.push({\n            name,\n            children: [],\n          });\n        } else {\n          console.warn(\n            `Trans: missed to pass in prop ${name} for interpolating ${format}`,\n          );\n        }\n      } else if (tagEndMatch !== null) {\n        // If tag end match is found, this means we need to replace the content with\n        // its actual value in prop e.g. format = \"Please <link>click the\n        // button</link> to continue\", tagEndMatch is for \"</link>\", stack last item name =\n        // \"link\" and props.link = (el) => <a\n        // href=\"https://example.com\">{el}</a> then its prop value will be\n        // pushed to \"link\"'s children so on DOM when rendering it's rendered as\n        // <a href=\"https://example.com\">click the button</a>\n        const name = tagEndMatch[1];\n        if (name === stack[stack.length - 1].name) {\n          const item = stack.pop()!;\n          const itemChildren = React.createElement(\n            React.Fragment,\n            {},\n            ...item.children,\n          );\n          const fn = props[item.name];\n          if (typeof fn === \"function\") {\n            stack[stack.length - 1].children.push(fn(itemChildren));\n          }\n        } else {\n          console.warn(\n            `Trans: unexpected end tag ${match} for interpolating ${format}`,\n          );\n        }\n      } else if (keyMatch !== null) {\n        // The match is for {{key}}. Check if the key is present in props and set\n        // the prop value as children of last stack item e.g. format = \"Hello\n        // {{name}}\", key = \"name\" and props.name = \"Excalidraw\" then its prop\n        // value will be pushed to \"name\"'s children so it's rendered on DOM as\n        // \"Hello Excalidraw\"\n        const name = keyMatch[1];\n        if (props.hasOwnProperty(name)) {\n          stack[stack.length - 1].children.push(props[name] as React.ReactNode);\n        } else {\n          console.warn(\n            `Trans: key ${name} not in props for interpolating ${format}`,\n          );\n        }\n      } else {\n        // If none of cases match means we just need to push the string\n        // to stack eg - \"Hello {{name}} Whats up?\" \"Hello\", \"Whats up\" will be pushed\n        stack[stack.length - 1].children.push(match);\n      }\n    });\n\n  if (stack.length !== 1) {\n    console.warn(`Trans: stack not empty for interpolating ${format}`);\n  }\n\n  return stack[0].children;\n};\n\n/*\nTrans component is used for translating JSX.\n\n```json\n{\n  \"example1\": \"Hello {{audience}}\",\n  \"example2\": \"Please <link>click the button</link> to continue.\",\n  \"example3\": \"Please <link>click {{location}}</link> to continue.\",\n  \"example4\": \"Please <link>click <bold>{{location}}</bold></link> to continue.\",\n}\n```\n\n```jsx\n<Trans i18nKey=\"example1\" audience=\"world\" />\n\n<Trans\n  i18nKey=\"example2\"\n  connectLink={(el) => <a href=\"https://example.com\">{el}</a>}\n/>\n\n<Trans\n  i18nKey=\"example3\"\n  connectLink={(el) => <a href=\"https://example.com\">{el}</a>}\n  location=\"the button\"\n/>\n\n<Trans\n  i18nKey=\"example4\"\n  connectLink={(el) => <a href=\"https://example.com\">{el}</a>}\n  location=\"the button\"\n  bold={(el) => <strong>{el}</strong>}\n/>\n```\n\nOutput:\n\n```html\nHello world\nPlease <a href=\"https://example.com\">click the button</a> to continue.\nPlease <a href=\"https://example.com\">click the button</a> to continue.\nPlease <a href=\"https://example.com\">click <strong>the button</strong></a> to continue.\n```\n*/\nconst Trans = ({\n  i18nKey,\n  children,\n  ...props\n}: {\n  i18nKey: TranslationKeys;\n  [key: string]: React.ReactNode | ((el: React.ReactNode) => React.ReactNode);\n}) => {\n  const { t } = useI18n();\n\n  // This is needed to avoid unique key error in list which gets rendered from getTransChildren\n  return React.createElement(\n    React.Fragment,\n    {},\n    ...getTransChildren(t(i18nKey), props),\n  );\n};\n\nexport default Trans;\n",
    "import clsx from \"clsx\";\nimport React, { useEffect, useRef } from \"react\";\n\nimport { EVENT, KEYS } from \"@excalidraw/common\";\n\nimport { useOutsideClick } from \"../../hooks/useOutsideClick\";\nimport { useStable } from \"../../hooks/useStable\";\nimport { useDevice } from \"../App\";\nimport { Island } from \"../Island\";\nimport Stack from \"../Stack\";\n\nimport { DropdownMenuContentPropsContext } from \"./common\";\n\nconst MenuContent = ({\n  children,\n  onClickOutside,\n  className = \"\",\n  onSelect,\n  style,\n}: {\n  children?: React.ReactNode;\n  onClickOutside?: () => void;\n  className?: string;\n  /**\n   * Called when any menu item is selected (clicked on).\n   */\n  onSelect?: (event: Event) => void;\n  style?: React.CSSProperties;\n}) => {\n  const device = useDevice();\n  const menuRef = useRef<HTMLDivElement>(null);\n\n  const callbacksRef = useStable({ onClickOutside });\n\n  useOutsideClick(menuRef, () => {\n    callbacksRef.onClickOutside?.();\n  });\n\n  useEffect(() => {\n    const onKeyDown = (event: KeyboardEvent) => {\n      if (event.key === KEYS.ESCAPE) {\n        event.stopImmediatePropagation();\n        callbacksRef.onClickOutside?.();\n      }\n    };\n\n    const option = {\n      // so that we can stop propagation of the event before it reaches\n      // event handlers that were bound before this one\n      capture: true,\n    };\n\n    document.addEventListener(EVENT.KEYDOWN, onKeyDown, option);\n    return () => {\n      document.removeEventListener(EVENT.KEYDOWN, onKeyDown, option);\n    };\n  }, [callbacksRef]);\n\n  const classNames = clsx(`dropdown-menu ${className}`, {\n    \"dropdown-menu--mobile\": device.editor.isMobile,\n  }).trim();\n\n  return (\n    <DropdownMenuContentPropsContext.Provider value={{ onSelect }}>\n      <div\n        ref={menuRef}\n        className={classNames}\n        style={style}\n        data-testid=\"dropdown-menu\"\n      >\n        {/* the zIndex ensures this menu has higher stacking order,\n    see https://github.com/excalidraw/excalidraw/pull/1445 */}\n        {device.editor.isMobile ? (\n          <Stack.Col className=\"dropdown-menu-container\">{children}</Stack.Col>\n        ) : (\n          <Island\n            className=\"dropdown-menu-container\"\n            padding={2}\n            style={{ zIndex: 2 }}\n          >\n            {children}\n          </Island>\n        )}\n      </div>\n    </DropdownMenuContentPropsContext.Provider>\n  );\n};\nMenuContent.displayName = \"DropdownMenuContent\";\n\nexport default MenuContent;\n",
    "import React, { forwardRef } from \"react\";\nimport clsx from \"clsx\";\n\nimport \"./Stack.scss\";\n\ntype StackProps = {\n  children: React.ReactNode;\n  gap?: number;\n  align?: \"start\" | \"center\" | \"end\" | \"baseline\";\n  justifyContent?: \"center\" | \"space-around\" | \"space-between\";\n  className?: string | boolean;\n  style?: React.CSSProperties;\n};\n\nconst RowStack = forwardRef(\n  (\n    { children, gap, align, justifyContent, className, style }: StackProps,\n    ref: React.ForwardedRef<HTMLDivElement>,\n  ) => {\n    return (\n      <div\n        className={clsx(\"Stack Stack_horizontal\", className)}\n        style={{\n          \"--gap\": gap,\n          alignItems: align,\n          justifyContent,\n          ...style,\n        }}\n        ref={ref}\n      >\n        {children}\n      </div>\n    );\n  },\n);\n\nconst ColStack = forwardRef(\n  (\n    { children, gap, align, justifyContent, className, style }: StackProps,\n    ref: React.ForwardedRef<HTMLDivElement>,\n  ) => {\n    return (\n      <div\n        className={clsx(\"Stack Stack_vertical\", className)}\n        style={{\n          \"--gap\": gap,\n          justifyItems: align,\n          justifyContent,\n          ...style,\n        }}\n        ref={ref}\n      >\n        {children}\n      </div>\n    );\n  },\n);\n\nexport default {\n  Row: RowStack,\n  Col: ColStack,\n};\n",
    "import React from \"react\";\n\nconst DropdownMenuItemCustom = ({\n  children,\n  className = \"\",\n  selected,\n  ...rest\n}: {\n  children: React.ReactNode;\n  className?: string;\n  selected?: boolean;\n} & React.HTMLAttributes<HTMLDivElement>) => {\n  return (\n    <div\n      {...rest}\n      className={`dropdown-menu-item-base dropdown-menu-item-custom ${className} ${\n        selected ? `dropdown-menu-item--selected` : ``\n      }`.trim()}\n    >\n      {children}\n    </div>\n  );\n};\n\nexport default DropdownMenuItemCustom;\n",
    "import React from \"react\";\n\nimport MenuItemContent from \"./DropdownMenuItemContent\";\nimport {\n  getDropdownMenuItemClassName,\n  useHandleDropdownMenuItemClick,\n} from \"./common\";\n\nimport type { JSX } from \"react\";\n\nconst DropdownMenuItemLink = ({\n  icon,\n  shortcut,\n  href,\n  children,\n  onSelect,\n  className = \"\",\n  selected,\n  rel = \"noopener\",\n  ...rest\n}: {\n  href: string;\n  icon?: JSX.Element;\n  children: React.ReactNode;\n  shortcut?: string;\n  className?: string;\n  selected?: boolean;\n  onSelect?: (event: Event) => void;\n  rel?: string;\n} & React.AnchorHTMLAttributes<HTMLAnchorElement>) => {\n  const handleClick = useHandleDropdownMenuItemClick(rest.onClick, onSelect);\n\n  return (\n    // eslint-disable-next-line react/jsx-no-target-blank\n    <a\n      {...rest}\n      href={href}\n      target=\"_blank\"\n      rel={rel || \"noopener\"}\n      className={getDropdownMenuItemClassName(className, selected)}\n      title={rest.title ?? rest[\"aria-label\"]}\n      onClick={handleClick}\n    >\n      <MenuItemContent icon={icon} shortcut={shortcut}>\n        {children}\n      </MenuItemContent>\n    </a>\n  );\n};\n\nexport default DropdownMenuItemLink;\nDropdownMenuItemLink.displayName = \"DropdownMenuItemLink\";\n",
    "import React from \"react\";\n\nconst MenuSeparator = () => (\n  <div\n    style={{\n      height: \"1px\",\n      backgroundColor: \"var(--default-border-color)\",\n      margin: \".5rem 0\",\n    }}\n  />\n);\n\nexport default MenuSeparator;\nMenuSeparator.displayName = \"DropdownMenuSeparator\";\n",
    "import clsx from \"clsx\";\n\nimport { useDevice } from \"../App\";\n\nconst MenuTrigger = ({\n  className = \"\",\n  children,\n  onToggle,\n  title,\n  ...rest\n}: {\n  className?: string;\n  children: React.ReactNode;\n  onToggle: () => void;\n  title?: string;\n} & Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, \"onSelect\">) => {\n  const device = useDevice();\n  const classNames = clsx(\n    `dropdown-menu-button ${className}`,\n    \"zen-mode-transition\",\n    {\n      \"dropdown-menu-button--mobile\": device.editor.isMobile,\n    },\n  ).trim();\n  return (\n    <button\n      data-prevent-outside-click\n      className={classNames}\n      onClick={onToggle}\n      type=\"button\"\n      data-testid=\"dropdown-menu-button\"\n      title={title}\n      {...rest}\n    >\n      {children}\n    </button>\n  );\n};\n\nexport default MenuTrigger;\nMenuTrigger.displayName = \"DropdownMenuTrigger\";\n",
    "import React from \"react\";\n\nexport const getMenuTriggerComponent = (children: React.ReactNode) => {\n  const comp = React.Children.toArray(children).find(\n    (child) =>\n      React.isValidElement(child) &&\n      typeof child.type !== \"string\" &&\n      //@ts-ignore\n      child?.type.displayName &&\n      //@ts-ignore\n      child.type.displayName === \"DropdownMenuTrigger\",\n  );\n  if (!comp) {\n    return null;\n  }\n  //@ts-ignore\n  return comp;\n};\n\nexport const getMenuContentComponent = (children: React.ReactNode) => {\n  const comp = React.Children.toArray(children).find(\n    (child) =>\n      React.isValidElement(child) &&\n      typeof child.type !== \"string\" &&\n      //@ts-ignore\n      child?.type.displayName &&\n      //@ts-ignore\n      child.type.displayName === \"DropdownMenuContent\",\n  );\n  if (!comp) {\n    return null;\n  }\n  //@ts-ignore\n  return comp;\n};\n",
    "import React from \"react\";\n\nimport DropdownMenuContent from \"./DropdownMenuContent\";\nimport DropdownMenuGroup from \"./DropdownMenuGroup\";\nimport DropdownMenuItem from \"./DropdownMenuItem\";\nimport DropdownMenuItemCustom from \"./DropdownMenuItemCustom\";\nimport DropdownMenuItemLink from \"./DropdownMenuItemLink\";\nimport MenuSeparator from \"./DropdownMenuSeparator\";\nimport DropdownMenuTrigger from \"./DropdownMenuTrigger\";\nimport {\n  getMenuContentComponent,\n  getMenuTriggerComponent,\n} from \"./dropdownMenuUtils\";\n\nimport \"./DropdownMenu.scss\";\n\nconst DropdownMenu = ({\n  children,\n  open,\n}: {\n  children?: React.ReactNode;\n  open: boolean;\n}) => {\n  const MenuTriggerComp = getMenuTriggerComponent(children);\n  const MenuContentComp = getMenuContentComponent(children);\n  return (\n    <>\n      {MenuTriggerComp}\n      {open && MenuContentComp}\n    </>\n  );\n};\n\nDropdownMenu.Trigger = DropdownMenuTrigger;\nDropdownMenu.Content = DropdownMenuContent;\nDropdownMenu.Item = DropdownMenuItem;\nDropdownMenu.ItemLink = DropdownMenuItemLink;\nDropdownMenu.ItemCustom = DropdownMenuItemCustom;\nDropdownMenu.Group = DropdownMenuGroup;\nDropdownMenu.Separator = MenuSeparator;\n\nexport default DropdownMenu;\n\nDropdownMenu.displayName = \"DropdownMenu\";\n",
    "import React, { memo, useEffect, useState } from \"react\";\n\nimport type { ExcalidrawElement, NonDeleted } from \"@excalidraw/element/types\";\n\nimport { useTransition } from \"../hooks/useTransition\";\n\nimport { EmptyLibraryUnit, LibraryUnit } from \"./LibraryUnit\";\n\nimport type { SvgCache } from \"../hooks/useLibraryItemSvg\";\nimport type { LibraryItem } from \"../types\";\nimport type { ReactNode } from \"react\";\n\ntype LibraryOrPendingItem = (\n  | LibraryItem\n  | /* pending library item */ {\n      id: null;\n      elements: readonly NonDeleted<ExcalidrawElement>[];\n    }\n)[];\n\ninterface Props {\n  items: LibraryOrPendingItem;\n  onClick: (id: LibraryItem[\"id\"] | null) => void;\n  onItemSelectToggle: (id: LibraryItem[\"id\"], event: React.MouseEvent) => void;\n  onItemDrag: (id: LibraryItem[\"id\"], event: React.DragEvent) => void;\n  isItemSelected: (id: LibraryItem[\"id\"] | null) => boolean;\n  svgCache: SvgCache;\n  itemsRenderedPerBatch: number;\n}\n\nexport const LibraryMenuSectionGrid = ({\n  children,\n}: {\n  children: ReactNode;\n}) => {\n  return <div className=\"library-menu-items-container__grid\">{children}</div>;\n};\n\nexport const LibraryMenuSection = memo(\n  ({\n    items,\n    onItemSelectToggle,\n    onItemDrag,\n    isItemSelected,\n    onClick,\n    svgCache,\n    itemsRenderedPerBatch,\n  }: Props) => {\n    const [, startTransition] = useTransition();\n    const [index, setIndex] = useState(0);\n\n    useEffect(() => {\n      if (index < items.length) {\n        startTransition(() => {\n          setIndex(index + itemsRenderedPerBatch);\n        });\n      }\n    }, [index, items.length, startTransition, itemsRenderedPerBatch]);\n\n    return (\n      <>\n        {items.map((item, i) => {\n          return i < index ? (\n            <LibraryUnit\n              elements={item?.elements}\n              isPending={!item?.id && !!item?.elements}\n              onClick={onClick}\n              svgCache={svgCache}\n              id={item?.id}\n              selected={isItemSelected(item.id)}\n              onToggle={onItemSelectToggle}\n              onDrag={onItemDrag}\n              key={item?.id ?? i}\n            />\n          ) : (\n            <EmptyLibraryUnit key={i} />\n          );\n        })}\n      </>\n    );\n  },\n);\n",
    "import React, { useCallback } from \"react\";\n\n/** noop polyfill for v17. Subset of API available */\nfunction useTransitionPolyfill() {\n  const startTransition = useCallback((callback: () => void) => callback(), []);\n  return [false, startTransition] as const;\n}\n\nexport const useTransition = React.useTransition || useTransitionPolyfill;\n",
    "import clsx from \"clsx\";\nimport { memo, useEffect, useRef, useState } from \"react\";\n\nimport { useLibraryItemSvg } from \"../hooks/useLibraryItemSvg\";\n\nimport { useDevice } from \"./App\";\nimport { CheckboxItem } from \"./CheckboxItem\";\nimport { PlusIcon } from \"./icons\";\n\nimport \"./LibraryUnit.scss\";\n\nimport type { LibraryItem } from \"../types\";\nimport type { SvgCache } from \"../hooks/useLibraryItemSvg\";\n\nexport const LibraryUnit = memo(\n  ({\n    id,\n    elements,\n    isPending,\n    onClick,\n    selected,\n    onToggle,\n    onDrag,\n    svgCache,\n  }: {\n    id: LibraryItem[\"id\"] | /** for pending item */ null;\n    elements?: LibraryItem[\"elements\"];\n    isPending?: boolean;\n    onClick: (id: LibraryItem[\"id\"] | null) => void;\n    selected: boolean;\n    onToggle: (id: string, event: React.MouseEvent) => void;\n    onDrag: (id: string, event: React.DragEvent) => void;\n    svgCache: SvgCache;\n  }) => {\n    const ref = useRef<HTMLDivElement | null>(null);\n    const svg = useLibraryItemSvg(id, elements, svgCache);\n\n    useEffect(() => {\n      const node = ref.current;\n\n      if (!node) {\n        return;\n      }\n\n      if (svg) {\n        node.innerHTML = svg.outerHTML;\n      }\n\n      return () => {\n        node.innerHTML = \"\";\n      };\n    }, [svg]);\n\n    const [isHovered, setIsHovered] = useState(false);\n    const isMobile = useDevice().editor.isMobile;\n    const adder = isPending && (\n      <div className=\"library-unit__adder\">{PlusIcon}</div>\n    );\n\n    return (\n      <div\n        className={clsx(\"library-unit\", {\n          \"library-unit__active\": elements,\n          \"library-unit--hover\": elements && isHovered,\n          \"library-unit--selected\": selected,\n          \"library-unit--skeleton\": !svg,\n        })}\n        onMouseEnter={() => setIsHovered(true)}\n        onMouseLeave={() => setIsHovered(false)}\n      >\n        <div\n          className={clsx(\"library-unit__dragger\", {\n            \"library-unit__pulse\": !!isPending,\n          })}\n          ref={ref}\n          draggable={!!elements}\n          onClick={\n            !!elements || !!isPending\n              ? (event) => {\n                  if (id && event.shiftKey) {\n                    onToggle(id, event);\n                  } else {\n                    onClick(id);\n                  }\n                }\n              : undefined\n          }\n          onDragStart={(event) => {\n            if (!id) {\n              event.preventDefault();\n              return;\n            }\n            setIsHovered(false);\n            onDrag(id, event);\n          }}\n        />\n        {adder}\n        {id && elements && (isHovered || isMobile || selected) && (\n          <CheckboxItem\n            checked={selected}\n            onChange={(checked, event) => onToggle(id, event)}\n            className=\"library-unit__checkbox\"\n          />\n        )}\n      </div>\n    );\n  },\n);\n\nexport const EmptyLibraryUnit = () => (\n  <div className=\"library-unit library-unit--skeleton\" />\n);\n",
    "import clsx from \"clsx\";\nimport { useRef } from \"react\";\nimport { createPortal } from \"react-dom\";\n\nimport { KEYS } from \"@excalidraw/common\";\n\nimport { useCreatePortalContainer } from \"../hooks/useCreatePortalContainer\";\n\nimport \"./Modal.scss\";\n\nimport type { AppState } from \"../types\";\n\nexport const Modal: React.FC<{\n  className?: string;\n  children: React.ReactNode;\n  maxWidth?: number;\n  onCloseRequest(): void;\n  labelledBy: string;\n  theme?: AppState[\"theme\"];\n  closeOnClickOutside?: boolean;\n}> = (props) => {\n  const { closeOnClickOutside = true } = props;\n  const modalRoot = useCreatePortalContainer({\n    className: \"excalidraw-modal-container\",\n  });\n\n  const animationsDisabledRef = useRef(\n    document.body.classList.contains(\"excalidraw-animations-disabled\"),\n  );\n\n  if (!modalRoot) {\n    return null;\n  }\n\n  const handleKeydown = (event: React.KeyboardEvent) => {\n    if (event.key === KEYS.ESCAPE) {\n      event.nativeEvent.stopImmediatePropagation();\n      event.stopPropagation();\n      props.onCloseRequest();\n    }\n  };\n\n  return createPortal(\n    <div\n      className={clsx(\"Modal\", props.className, {\n        \"animations-disabled\": animationsDisabledRef.current,\n      })}\n      role=\"dialog\"\n      aria-modal=\"true\"\n      onKeyDown={handleKeydown}\n      aria-labelledby={props.labelledBy}\n      data-prevent-outside-click\n    >\n      <div\n        className=\"Modal__background\"\n        onClick={closeOnClickOutside ? props.onCloseRequest : undefined}\n      />\n      <div\n        className=\"Modal__content\"\n        style={{ \"--max-width\": `${props.maxWidth}px` }}\n        tabIndex={0}\n      >\n        {props.children}\n      </div>\n    </div>,\n    modalRoot,\n  );\n};\n",
    "import clsx from \"clsx\";\nimport {\n  forwardRef,\n  useRef,\n  useImperativeHandle,\n  useLayoutEffect,\n  useState,\n} from \"react\";\n\nimport { Button } from \"./Button\";\nimport { eyeIcon, eyeClosedIcon } from \"./icons\";\n\nimport \"./TextField.scss\";\n\nimport type { KeyboardEvent } from \"react\";\n\ntype TextFieldProps = {\n  onChange?: (value: string) => void;\n  onClick?: () => void;\n  onKeyDown?: (event: KeyboardEvent<HTMLInputElement>) => void;\n\n  readonly?: boolean;\n  fullWidth?: boolean;\n  selectOnRender?: boolean;\n\n  icon?: React.ReactNode;\n  label?: string;\n  className?: string;\n  placeholder?: string;\n  isRedacted?: boolean;\n} & ({ value: string } | { defaultValue: string });\n\nexport const TextField = forwardRef<HTMLInputElement, TextFieldProps>(\n  (\n    {\n      onChange,\n      label,\n      fullWidth,\n      placeholder,\n      readonly,\n      selectOnRender,\n      onKeyDown,\n      isRedacted = false,\n      icon,\n      className,\n      ...rest\n    },\n    ref,\n  ) => {\n    const innerRef = useRef<HTMLInputElement | null>(null);\n\n    useImperativeHandle(ref, () => innerRef.current!);\n\n    useLayoutEffect(() => {\n      if (selectOnRender) {\n        // focusing first is needed because vitest/jsdom\n        innerRef.current?.focus();\n        innerRef.current?.select();\n      }\n    }, [selectOnRender]);\n\n    const [isTemporarilyUnredacted, setIsTemporarilyUnredacted] =\n      useState<boolean>(false);\n\n    return (\n      <div\n        className={clsx(\"ExcTextField\", className, {\n          \"ExcTextField--fullWidth\": fullWidth,\n          \"ExcTextField--hasIcon\": !!icon,\n        })}\n        onClick={() => {\n          innerRef.current?.focus();\n        }}\n      >\n        {icon}\n        {label && <div className=\"ExcTextField__label\">{label}</div>}\n        <div\n          className={clsx(\"ExcTextField__input\", {\n            \"ExcTextField__input--readonly\": readonly,\n          })}\n        >\n          <input\n            className={clsx({\n              \"is-redacted\":\n                \"value\" in rest &&\n                rest.value &&\n                isRedacted &&\n                !isTemporarilyUnredacted,\n            })}\n            readOnly={readonly}\n            value={\"value\" in rest ? rest.value : undefined}\n            defaultValue={\n              \"defaultValue\" in rest ? rest.defaultValue : undefined\n            }\n            placeholder={placeholder}\n            ref={innerRef}\n            onChange={(event) => onChange?.(event.target.value)}\n            onKeyDown={onKeyDown}\n          />\n          {isRedacted && (\n            <Button\n              onSelect={() =>\n                setIsTemporarilyUnredacted(!isTemporarilyUnredacted)\n              }\n              style={{ border: 0, userSelect: \"none\" }}\n            >\n              {isTemporarilyUnredacted ? eyeClosedIcon : eyeIcon}\n            </Button>\n          )}\n        </div>\n      </div>\n    );\n  },\n);\n",
    "import clsx from \"clsx\";\nimport React from \"react\";\n\nimport { composeEventHandlers } from \"@excalidraw/common\";\n\nimport \"./Button.scss\";\n\ninterface ButtonProps\n  extends React.DetailedHTMLProps<\n    React.ButtonHTMLAttributes<HTMLButtonElement>,\n    HTMLButtonElement\n  > {\n  type?: \"button\" | \"submit\" | \"reset\";\n  onSelect: () => any;\n  /** whether button is in active state */\n  selected?: boolean;\n  children: React.ReactNode;\n  className?: string;\n}\n\n/**\n * A generic button component that follows Excalidraw's design system.\n * Style can be customised using `className` or `style` prop.\n * Accepts all props that a regular `button` element accepts.\n */\nexport const Button = ({\n  type = \"button\",\n  onSelect,\n  selected,\n  children,\n  className = \"\",\n  ...rest\n}: ButtonProps) => {\n  return (\n    <button\n      onClick={composeEventHandlers(rest.onClick, (event) => {\n        onSelect();\n      })}\n      type={type}\n      className={clsx(\"excalidraw-button\", className, { selected })}\n      {...rest}\n    >\n      {children}\n    </button>\n  );\n};\n",
    "import { KEYS } from \"@excalidraw/common\";\n\nimport {\n  SelectionIcon,\n  RectangleIcon,\n  DiamondIcon,\n  EllipseIcon,\n  ArrowIcon,\n  LineIcon,\n  FreedrawIcon,\n  TextIcon,\n  ImageIcon,\n  EraserIcon,\n} from \"./icons\";\n\nexport const SHAPES = [\n  {\n    icon: SelectionIcon,\n    value: \"selection\",\n    key: KEYS.V,\n    numericKey: KEYS[\"1\"],\n    fillable: true,\n  },\n  {\n    icon: RectangleIcon,\n    value: \"rectangle\",\n    key: KEYS.R,\n    numericKey: KEYS[\"2\"],\n    fillable: true,\n  },\n  {\n    icon: DiamondIcon,\n    value: \"diamond\",\n    key: KEYS.D,\n    numericKey: KEYS[\"3\"],\n    fillable: true,\n  },\n  {\n    icon: EllipseIcon,\n    value: \"ellipse\",\n    key: KEYS.O,\n    numericKey: KEYS[\"4\"],\n    fillable: true,\n  },\n  {\n    icon: ArrowIcon,\n    value: \"arrow\",\n    key: KEYS.A,\n    numericKey: KEYS[\"5\"],\n    fillable: true,\n  },\n  {\n    icon: LineIcon,\n    value: \"line\",\n    key: KEYS.L,\n    numericKey: KEYS[\"6\"],\n    fillable: true,\n  },\n  {\n    icon: FreedrawIcon,\n    value: \"freedraw\",\n    key: [KEYS.P, KEYS.X],\n    numericKey: KEYS[\"7\"],\n    fillable: false,\n  },\n  {\n    icon: TextIcon,\n    value: \"text\",\n    key: KEYS.T,\n    numericKey: KEYS[\"8\"],\n    fillable: false,\n  },\n  {\n    icon: ImageIcon,\n    value: \"image\",\n    key: null,\n    numericKey: KEYS[\"9\"],\n    fillable: false,\n  },\n  {\n    icon: EraserIcon,\n    value: \"eraser\",\n    key: KEYS.E,\n    numericKey: KEYS[\"0\"],\n    fillable: false,\n  },\n] as const;\n\nexport const findShapeByKey = (key: string) => {\n  const shape = SHAPES.find((shape, index) => {\n    return (\n      (shape.numericKey != null && key === shape.numericKey.toString()) ||\n      (shape.key &&\n        (typeof shape.key === \"string\"\n          ? shape.key === key\n          : (shape.key as readonly string[]).includes(key)))\n    );\n  });\n  return shape?.value || null;\n};\n",
    "import clsx from \"clsx\";\nimport { useState } from \"react\";\n\nimport {\n  CLASSES,\n  KEYS,\n  capitalizeString,\n  isTransparent,\n} from \"@excalidraw/common\";\n\nimport {\n  shouldAllowVerticalAlign,\n  suppportsHorizontalAlign,\n} from \"@excalidraw/element\";\n\nimport {\n  hasBoundTextElement,\n  isElbowArrow,\n  isImageElement,\n  isLinearElement,\n  isTextElement,\n} from \"@excalidraw/element\";\n\nimport { hasStrokeColor, toolIsArrow } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawElementType,\n  NonDeletedElementsMap,\n  NonDeletedSceneElementsMap,\n} from \"@excalidraw/element/types\";\n\nimport { actionToggleZenMode } from \"../actions\";\n\nimport { alignActionsPredicate } from \"../actions/actionAlign\";\nimport { trackEvent } from \"../analytics\";\nimport { useTunnels } from \"../context/tunnels\";\n\nimport { t } from \"../i18n\";\nimport {\n  canChangeRoundness,\n  canHaveArrowheads,\n  getTargetElements,\n  hasBackground,\n  hasStrokeStyle,\n  hasStrokeWidth,\n} from \"../scene\";\n\nimport { SHAPES } from \"./shapes\";\n\nimport \"./Actions.scss\";\n\nimport { useDevice } from \"./App\";\nimport Stack from \"./Stack\";\nimport { ToolButton } from \"./ToolButton\";\nimport { Tooltip } from \"./Tooltip\";\nimport DropdownMenu from \"./dropdownMenu/DropdownMenu\";\nimport {\n  EmbedIcon,\n  extraToolsIcon,\n  frameToolIcon,\n  mermaidLogoIcon,\n  laserPointerToolIcon,\n  MagicIcon,\n  LassoIcon,\n} from \"./icons\";\n\nimport type { AppClassProperties, AppProps, UIAppState, Zoom } from \"../types\";\nimport type { ActionManager } from \"../actions/manager\";\n\nexport const canChangeStrokeColor = (\n  appState: UIAppState,\n  targetElements: ExcalidrawElement[],\n) => {\n  let commonSelectedType: ExcalidrawElementType | null =\n    targetElements[0]?.type || null;\n\n  for (const element of targetElements) {\n    if (element.type !== commonSelectedType) {\n      commonSelectedType = null;\n      break;\n    }\n  }\n\n  return (\n    (hasStrokeColor(appState.activeTool.type) &&\n      commonSelectedType !== \"image\" &&\n      commonSelectedType !== \"frame\" &&\n      commonSelectedType !== \"magicframe\") ||\n    targetElements.some((element) => hasStrokeColor(element.type))\n  );\n};\n\nexport const canChangeBackgroundColor = (\n  appState: UIAppState,\n  targetElements: ExcalidrawElement[],\n) => {\n  return (\n    hasBackground(appState.activeTool.type) ||\n    targetElements.some((element) => hasBackground(element.type))\n  );\n};\n\nexport const SelectedShapeActions = ({\n  appState,\n  elementsMap,\n  renderAction,\n  app,\n}: {\n  appState: UIAppState;\n  elementsMap: NonDeletedElementsMap | NonDeletedSceneElementsMap;\n  renderAction: ActionManager[\"renderAction\"];\n  app: AppClassProperties;\n}) => {\n  const targetElements = getTargetElements(elementsMap, appState);\n\n  let isSingleElementBoundContainer = false;\n  if (\n    targetElements.length === 2 &&\n    (hasBoundTextElement(targetElements[0]) ||\n      hasBoundTextElement(targetElements[1]))\n  ) {\n    isSingleElementBoundContainer = true;\n  }\n  const isEditingTextOrNewElement = Boolean(\n    appState.editingTextElement || appState.newElement,\n  );\n  const device = useDevice();\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const showFillIcons =\n    (hasBackground(appState.activeTool.type) &&\n      !isTransparent(appState.currentItemBackgroundColor)) ||\n    targetElements.some(\n      (element) =>\n        hasBackground(element.type) && !isTransparent(element.backgroundColor),\n    );\n\n  const showLinkIcon =\n    targetElements.length === 1 || isSingleElementBoundContainer;\n\n  const showLineEditorAction =\n    !appState.editingLinearElement &&\n    targetElements.length === 1 &&\n    isLinearElement(targetElements[0]) &&\n    !isElbowArrow(targetElements[0]);\n\n  const showCropEditorAction =\n    !appState.croppingElementId &&\n    targetElements.length === 1 &&\n    isImageElement(targetElements[0]);\n\n  const showAlignActions =\n    !isSingleElementBoundContainer && alignActionsPredicate(appState, app);\n\n  return (\n    <div className=\"selected-shape-actions\">\n      <div>\n        {canChangeStrokeColor(appState, targetElements) &&\n          renderAction(\"changeStrokeColor\")}\n      </div>\n      {canChangeBackgroundColor(appState, targetElements) && (\n        <div>{renderAction(\"changeBackgroundColor\")}</div>\n      )}\n      {showFillIcons && renderAction(\"changeFillStyle\")}\n\n      {(hasStrokeWidth(appState.activeTool.type) ||\n        targetElements.some((element) => hasStrokeWidth(element.type))) &&\n        renderAction(\"changeStrokeWidth\")}\n\n      {(appState.activeTool.type === \"freedraw\" ||\n        targetElements.some((element) => element.type === \"freedraw\")) &&\n        renderAction(\"changeStrokeShape\")}\n\n      {(hasStrokeStyle(appState.activeTool.type) ||\n        targetElements.some((element) => hasStrokeStyle(element.type))) && (\n        <>\n          {renderAction(\"changeStrokeStyle\")}\n          {renderAction(\"changeSloppiness\")}\n        </>\n      )}\n\n      {(canChangeRoundness(appState.activeTool.type) ||\n        targetElements.some((element) => canChangeRoundness(element.type))) && (\n        <>{renderAction(\"changeRoundness\")}</>\n      )}\n\n      {(toolIsArrow(appState.activeTool.type) ||\n        targetElements.some((element) => toolIsArrow(element.type))) && (\n        <>{renderAction(\"changeArrowType\")}</>\n      )}\n\n      {(appState.activeTool.type === \"text\" ||\n        targetElements.some(isTextElement)) && (\n        <>\n          {renderAction(\"changeFontFamily\")}\n          {renderAction(\"changeFontSize\")}\n          {(appState.activeTool.type === \"text\" ||\n            suppportsHorizontalAlign(targetElements, elementsMap)) &&\n            renderAction(\"changeTextAlign\")}\n        </>\n      )}\n\n      {shouldAllowVerticalAlign(targetElements, elementsMap) &&\n        renderAction(\"changeVerticalAlign\")}\n      {(canHaveArrowheads(appState.activeTool.type) ||\n        targetElements.some((element) => canHaveArrowheads(element.type))) && (\n        <>{renderAction(\"changeArrowhead\")}</>\n      )}\n\n      {renderAction(\"changeOpacity\")}\n\n      <fieldset>\n        <legend>{t(\"labels.layers\")}</legend>\n        <div className=\"buttonList\">\n          {renderAction(\"sendToBack\")}\n          {renderAction(\"sendBackward\")}\n          {renderAction(\"bringForward\")}\n          {renderAction(\"bringToFront\")}\n        </div>\n      </fieldset>\n\n      {showAlignActions && !isSingleElementBoundContainer && (\n        <fieldset>\n          <legend>{t(\"labels.align\")}</legend>\n          <div className=\"buttonList\">\n            {\n              // swap this order for RTL so the button positions always match their action\n              // (i.e. the leftmost button aligns left)\n            }\n            {isRTL ? (\n              <>\n                {renderAction(\"alignRight\")}\n                {renderAction(\"alignHorizontallyCentered\")}\n                {renderAction(\"alignLeft\")}\n              </>\n            ) : (\n              <>\n                {renderAction(\"alignLeft\")}\n                {renderAction(\"alignHorizontallyCentered\")}\n                {renderAction(\"alignRight\")}\n              </>\n            )}\n            {targetElements.length > 2 &&\n              renderAction(\"distributeHorizontally\")}\n            {/* breaks the row ˇˇ */}\n            <div style={{ flexBasis: \"100%\", height: 0 }} />\n            <div\n              style={{\n                display: \"flex\",\n                flexWrap: \"wrap\",\n                gap: \".5rem\",\n                marginTop: \"-0.5rem\",\n              }}\n            >\n              {renderAction(\"alignTop\")}\n              {renderAction(\"alignVerticallyCentered\")}\n              {renderAction(\"alignBottom\")}\n              {targetElements.length > 2 &&\n                renderAction(\"distributeVertically\")}\n            </div>\n          </div>\n        </fieldset>\n      )}\n      {!isEditingTextOrNewElement && targetElements.length > 0 && (\n        <fieldset>\n          <legend>{t(\"labels.actions\")}</legend>\n          <div className=\"buttonList\">\n            {!device.editor.isMobile && renderAction(\"duplicateSelection\")}\n            {!device.editor.isMobile && renderAction(\"deleteSelectedElements\")}\n            {renderAction(\"group\")}\n            {renderAction(\"ungroup\")}\n            {showLinkIcon && renderAction(\"hyperlink\")}\n            {showCropEditorAction && renderAction(\"cropEditor\")}\n            {showLineEditorAction && renderAction(\"toggleLinearEditor\")}\n          </div>\n        </fieldset>\n      )}\n    </div>\n  );\n};\n\nexport const ShapesSwitcher = ({\n  activeTool,\n  appState,\n  app,\n  UIOptions,\n}: {\n  activeTool: UIAppState[\"activeTool\"];\n  appState: UIAppState;\n  app: AppClassProperties;\n  UIOptions: AppProps[\"UIOptions\"];\n}) => {\n  const [isExtraToolsMenuOpen, setIsExtraToolsMenuOpen] = useState(false);\n\n  const frameToolSelected = activeTool.type === \"frame\";\n  const laserToolSelected = activeTool.type === \"laser\";\n  const lassoToolSelected = activeTool.type === \"lasso\";\n\n  const embeddableToolSelected = activeTool.type === \"embeddable\";\n\n  const { TTDDialogTriggerTunnel } = useTunnels();\n\n  return (\n    <>\n      {SHAPES.map(({ value, icon, key, numericKey, fillable }, index) => {\n        if (\n          UIOptions.tools?.[\n            value as Extract<typeof value, keyof AppProps[\"UIOptions\"][\"tools\"]>\n          ] === false\n        ) {\n          return null;\n        }\n\n        const label = t(`toolBar.${value}`);\n        const letter =\n          key && capitalizeString(typeof key === \"string\" ? key : key[0]);\n        const shortcut = letter\n          ? `${letter} ${t(\"helpDialog.or\")} ${numericKey}`\n          : `${numericKey}`;\n\n        return (\n          <ToolButton\n            className={clsx(\"Shape\", { fillable })}\n            key={value}\n            type=\"radio\"\n            icon={icon}\n            checked={activeTool.type === value}\n            name=\"editor-current-shape\"\n            title={`${capitalizeString(label)} — ${shortcut}`}\n            keyBindingLabel={numericKey || letter}\n            aria-label={capitalizeString(label)}\n            aria-keyshortcuts={shortcut}\n            data-testid={`toolbar-${value}`}\n            onPointerDown={({ pointerType }) => {\n              if (!appState.penDetected && pointerType === \"pen\") {\n                app.togglePenMode(true);\n              }\n\n              if (value === \"selection\") {\n                if (appState.activeTool.type === \"selection\") {\n                  app.setActiveTool({ type: \"lasso\" });\n                } else {\n                  app.setActiveTool({ type: \"selection\" });\n                }\n              }\n            }}\n            onChange={({ pointerType }) => {\n              if (appState.activeTool.type !== value) {\n                trackEvent(\"toolbar\", value, \"ui\");\n              }\n              if (value === \"image\") {\n                app.setActiveTool({\n                  type: value,\n                });\n              } else {\n                app.setActiveTool({ type: value });\n              }\n            }}\n          />\n        );\n      })}\n      <div className=\"App-toolbar__divider\" />\n\n      <DropdownMenu open={isExtraToolsMenuOpen}>\n        <DropdownMenu.Trigger\n          className={clsx(\"App-toolbar__extra-tools-trigger\", {\n            \"App-toolbar__extra-tools-trigger--selected\":\n              frameToolSelected ||\n              embeddableToolSelected ||\n              lassoToolSelected ||\n              // in collab we're already highlighting the laser button\n              // outside toolbar, so let's not highlight extra-tools button\n              // on top of it\n              (laserToolSelected && !app.props.isCollaborating),\n          })}\n          onToggle={() => setIsExtraToolsMenuOpen(!isExtraToolsMenuOpen)}\n          title={t(\"toolBar.extraTools\")}\n        >\n          {frameToolSelected\n            ? frameToolIcon\n            : embeddableToolSelected\n            ? EmbedIcon\n            : laserToolSelected && !app.props.isCollaborating\n            ? laserPointerToolIcon\n            : lassoToolSelected\n            ? LassoIcon\n            : extraToolsIcon}\n        </DropdownMenu.Trigger>\n        <DropdownMenu.Content\n          onClickOutside={() => setIsExtraToolsMenuOpen(false)}\n          onSelect={() => setIsExtraToolsMenuOpen(false)}\n          className=\"App-toolbar__extra-tools-dropdown\"\n        >\n          <DropdownMenu.Item\n            onSelect={() => app.setActiveTool({ type: \"frame\" })}\n            icon={frameToolIcon}\n            shortcut={KEYS.F.toLocaleUpperCase()}\n            data-testid=\"toolbar-frame\"\n            selected={frameToolSelected}\n          >\n            {t(\"toolBar.frame\")}\n          </DropdownMenu.Item>\n          <DropdownMenu.Item\n            onSelect={() => app.setActiveTool({ type: \"embeddable\" })}\n            icon={EmbedIcon}\n            data-testid=\"toolbar-embeddable\"\n            selected={embeddableToolSelected}\n          >\n            {t(\"toolBar.embeddable\")}\n          </DropdownMenu.Item>\n          <DropdownMenu.Item\n            onSelect={() => app.setActiveTool({ type: \"laser\" })}\n            icon={laserPointerToolIcon}\n            data-testid=\"toolbar-laser\"\n            selected={laserToolSelected}\n            shortcut={KEYS.K.toLocaleUpperCase()}\n          >\n            {t(\"toolBar.laser\")}\n          </DropdownMenu.Item>\n          <DropdownMenu.Item\n            onSelect={() => app.setActiveTool({ type: \"lasso\" })}\n            icon={LassoIcon}\n            data-testid=\"toolbar-lasso\"\n            selected={lassoToolSelected}\n          >\n            {t(\"toolBar.lasso\")}\n          </DropdownMenu.Item>\n          <div style={{ margin: \"6px 0\", fontSize: 14, fontWeight: 600 }}>\n            Generate\n          </div>\n          {app.props.aiEnabled !== false && <TTDDialogTriggerTunnel.Out />}\n          <DropdownMenu.Item\n            onSelect={() => app.setOpenDialog({ name: \"ttd\", tab: \"mermaid\" })}\n            icon={mermaidLogoIcon}\n            data-testid=\"toolbar-embeddable\"\n          >\n            {t(\"toolBar.mermaidToExcalidraw\")}\n          </DropdownMenu.Item>\n          {app.props.aiEnabled !== false && app.plugins.diagramToCode && (\n            <>\n              <DropdownMenu.Item\n                onSelect={() => app.onMagicframeToolSelect()}\n                icon={MagicIcon}\n                data-testid=\"toolbar-magicframe\"\n              >\n                {t(\"toolBar.magicframe\")}\n                <DropdownMenu.Item.Badge>AI</DropdownMenu.Item.Badge>\n              </DropdownMenu.Item>\n            </>\n          )}\n        </DropdownMenu.Content>\n      </DropdownMenu>\n    </>\n  );\n};\n\nexport const ZoomActions = ({\n  renderAction,\n  zoom,\n}: {\n  renderAction: ActionManager[\"renderAction\"];\n  zoom: Zoom;\n}) => (\n  <Stack.Col gap={1} className={CLASSES.ZOOM_ACTIONS}>\n    <Stack.Row align=\"center\">\n      {renderAction(\"zoomOut\")}\n      {renderAction(\"resetZoom\")}\n      {renderAction(\"zoomIn\")}\n    </Stack.Row>\n  </Stack.Col>\n);\n\nexport const UndoRedoActions = ({\n  renderAction,\n  className,\n}: {\n  renderAction: ActionManager[\"renderAction\"];\n  className?: string;\n}) => (\n  <div className={`undo-redo-buttons ${className}`}>\n    <div className=\"undo-button-container\">\n      <Tooltip label={t(\"buttons.undo\")}>{renderAction(\"undo\")}</Tooltip>\n    </div>\n    <div className=\"redo-button-container\">\n      <Tooltip label={t(\"buttons.redo\")}> {renderAction(\"redo\")}</Tooltip>\n    </div>\n  </div>\n);\n\nexport const ExitZenModeAction = ({\n  actionManager,\n  showExitZenModeBtn,\n}: {\n  actionManager: ActionManager;\n  showExitZenModeBtn: boolean;\n}) => (\n  <button\n    type=\"button\"\n    className={clsx(\"disable-zen-mode\", {\n      \"disable-zen-mode--visible\": showExitZenModeBtn,\n    })}\n    onClick={() => actionManager.executeAction(actionToggleZenMode)}\n  >\n    {t(\"buttons.exitZenMode\")}\n  </button>\n);\n\nexport const FinalizeAction = ({\n  renderAction,\n  className,\n}: {\n  renderAction: ActionManager[\"renderAction\"];\n  className?: string;\n}) => (\n  <div className={`finalize-button ${className}`}>\n    {renderAction(\"finalize\", { size: \"small\" })}\n  </div>\n);\n",
    "import { createIsolation } from \"jotai-scope\";\nimport React from \"react\";\nimport tunnel from \"tunnel-rat\";\n\nexport type Tunnel = ReturnType<typeof tunnel>;\n\ntype TunnelsContextValue = {\n  MainMenuTunnel: Tunnel;\n  WelcomeScreenMenuHintTunnel: Tunnel;\n  WelcomeScreenToolbarHintTunnel: Tunnel;\n  WelcomeScreenHelpHintTunnel: Tunnel;\n  WelcomeScreenCenterTunnel: Tunnel;\n  FooterCenterTunnel: Tunnel;\n  DefaultSidebarTriggerTunnel: Tunnel;\n  DefaultSidebarTabTriggersTunnel: Tunnel;\n  OverwriteConfirmDialogTunnel: Tunnel;\n  TTDDialogTriggerTunnel: Tunnel;\n  // this can be removed once we create jotai stores per each editor\n  // instance\n  tunnelsJotai: ReturnType<typeof createIsolation>;\n};\n\nexport const TunnelsContext = React.createContext<TunnelsContextValue>(null!);\n\nexport const useTunnels = () => React.useContext(TunnelsContext);\n\nconst tunnelsJotai = createIsolation();\n\nexport const useInitializeTunnels = () => {\n  return React.useMemo((): TunnelsContextValue => {\n    return {\n      MainMenuTunnel: tunnel(),\n      WelcomeScreenMenuHintTunnel: tunnel(),\n      WelcomeScreenToolbarHintTunnel: tunnel(),\n      WelcomeScreenHelpHintTunnel: tunnel(),\n      WelcomeScreenCenterTunnel: tunnel(),\n      FooterCenterTunnel: tunnel(),\n      DefaultSidebarTriggerTunnel: tunnel(),\n      DefaultSidebarTabTriggersTunnel: tunnel(),\n      OverwriteConfirmDialogTunnel: tunnel(),\n      TTDDialogTriggerTunnel: tunnel(),\n      tunnelsJotai,\n    };\n  }, []);\n};\n",
    "import { useRef } from \"react\";\n\n/**\n * Returns a stable function of the same type.\n */\nexport const useStableCallback = <T extends (...args: any[]) => any>(\n  userFn: T,\n) => {\n  const stableRef = useRef<{ userFn: T; stableFn?: T }>({ userFn });\n  stableRef.current.userFn = userFn;\n\n  if (!stableRef.current.stableFn) {\n    stableRef.current.stableFn = ((...args: any[]) =>\n      stableRef.current.userFn(...args)) as T;\n  }\n\n  return stableRef.current.stableFn as T;\n};\n",
    "import { actionClearCanvas } from \"../actions\";\nimport { atom, useAtom } from \"../editor-jotai\";\nimport { t } from \"../i18n\";\n\nimport { useExcalidrawActionManager } from \"./App\";\nimport ConfirmDialog from \"./ConfirmDialog\";\n\nexport const activeConfirmDialogAtom = atom<\"clearCanvas\" | null>(null);\n\nexport const ActiveConfirmDialog = () => {\n  const [activeConfirmDialog, setActiveConfirmDialog] = useAtom(\n    activeConfirmDialogAtom,\n  );\n  const actionManager = useExcalidrawActionManager();\n\n  if (!activeConfirmDialog) {\n    return null;\n  }\n\n  if (activeConfirmDialog === \"clearCanvas\") {\n    return (\n      <ConfirmDialog\n        onConfirm={() => {\n          actionManager.executeAction(actionClearCanvas);\n          setActiveConfirmDialog(null);\n        }}\n        onCancel={() => setActiveConfirmDialog(null)}\n        title={t(\"clearCanvasDialog.title\")}\n      >\n        <p className=\"clear-canvas__content\"> {t(\"alerts.clearReset\")}</p>\n      </ConfirmDialog>\n    );\n  }\n\n  return null;\n};\n",
    "import { actionToggleTheme } from \"../../actions\";\n\nimport type { CommandPaletteItem } from \"./types\";\n\nexport const toggleTheme: CommandPaletteItem = {\n  ...actionToggleTheme,\n  category: \"App\",\n  label: \"Toggle theme\",\n  perform: ({ actionManager }) => {\n    actionManager.executeAction(actionToggleTheme, \"commandPalette\");\n  },\n};\n",
    "import {\n  getSizeFromPoints,\n  randomInteger,\n  getUpdatedTimestamp,\n} from \"@excalidraw/common\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport { ShapeCache } from \"./shape\";\n\nimport { updateElbowArrowPoints } from \"./elbowArrow\";\n\nimport { isElbowArrow } from \"./typeChecks\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawElement,\n  NonDeletedSceneElementsMap,\n} from \"./types\";\n\nexport type ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"updated\"\n>;\n\n/**\n * This function tracks updates of text elements for the purposes for collaboration.\n * The version is used to compare updates when more than one user is working in\n * the same drawing.\n *\n * WARNING: this won't trigger the component to update, so if you need to trigger component update,\n * use `scene.mutateElement` or `ExcalidrawImperativeAPI.mutateElement` instead.\n */\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  elementsMap: ElementsMap,\n  updates: ElementUpdate<TElement>,\n  options?: {\n    isDragging?: boolean;\n  },\n) => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points, fixedSegments, startBinding, endBinding, fileId } =\n    updates as any;\n\n  if (\n    isElbowArrow(element) &&\n    (Object.keys(updates).length === 0 || // normalization case\n      typeof points !== \"undefined\" || // repositioning\n      typeof fixedSegments !== \"undefined\" || // segment fixing\n      typeof startBinding !== \"undefined\" ||\n      typeof endBinding !== \"undefined\") // manual binding to element\n  ) {\n    updates = {\n      ...updates,\n      angle: 0 as Radians,\n      ...updateElbowArrowPoints(\n        {\n          ...element,\n          x: updates.x || element.x,\n          y: updates.y || element.y,\n        },\n        elementsMap as NonDeletedSceneElementsMap,\n        updates as ElementUpdate<ExcalidrawElbowArrowElement>,\n        options,\n      ),\n    };\n  } else if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update because its attrs could have changed\n        // (except for specific keys we handle below)\n        (typeof value !== \"object\" ||\n          value === null ||\n          key === \"groupIds\" ||\n          key === \"scale\")\n      ) {\n        continue;\n      }\n\n      if (key === \"scale\") {\n        const prevScale = (element as any)[key];\n        const nextScale = value;\n        if (prevScale[0] === nextScale[0] && prevScale[1] === nextScale[1]) {\n          continue;\n        }\n      } else if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let index = prevPoints.length;\n          while (--index) {\n            const prevPoint = prevPoints[index];\n            const nextPoint = nextPoints[index];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return element;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof fileId != \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    ShapeCache.delete(element);\n  }\n\n  element.version = updates.version ?? element.version + 1;\n  element.versionNonce = updates.versionNonce ?? randomInteger();\n  element.updated = getUpdatedTimestamp();\n\n  return element;\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n  /** pass `true` to always regenerate */\n  force = false,\n): TElement => {\n  let didChange = false;\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update because its attrs could have changed\n        (typeof value !== \"object\" || value === null)\n      ) {\n        continue;\n      }\n      didChange = true;\n    }\n  }\n\n  if (!didChange && !force) {\n    return element;\n  }\n\n  return {\n    ...element,\n    ...updates,\n    version: updates.version ?? element.version + 1,\n    versionNonce: updates.versionNonce ?? randomInteger(),\n    updated: getUpdatedTimestamp(),\n  };\n};\n\n/**\n * Mutates element, bumping `version`, `versionNonce`, and `updated`.\n *\n * NOTE: does not trigger re-render.\n */\nexport const bumpVersion = <T extends Mutable<ExcalidrawElement>>(\n  element: T,\n  version?: ExcalidrawElement[\"version\"],\n) => {\n  element.version = (version ?? element.version) + 1;\n  element.versionNonce = randomInteger();\n  element.updated = getUpdatedTimestamp();\n  return element;\n};\n",
    "import { simplify } from \"points-on-curve\";\n\nimport {\n  type GeometricShape,\n  getClosedCurveShape,\n  getCurveShape,\n  getEllipseShape,\n  getFreedrawShape,\n  getPolygonShape,\n} from \"@excalidraw/utils/shape\";\n\nimport {\n  pointFrom,\n  pointDistance,\n  type LocalPoint,\n  pointRotateRads,\n} from \"@excalidraw/math\";\nimport {\n  ROUGHNESS,\n  isTransparent,\n  assertNever,\n  COLOR_PALETTE,\n  LINE_POLYGON_POINT_MERGE_DISTANCE,\n} from \"@excalidraw/common\";\n\nimport { RoughGenerator } from \"roughjs/bin/generator\";\n\nimport type { GlobalPoint } from \"@excalidraw/math\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport type {\n  AppState,\n  EmbedsValidationStatus,\n} from \"excalidraw-custom/types\";\nimport type {\n  ElementShape,\n  ElementShapes,\n} from \"excalidraw-custom/scene/types\";\n\nimport { elementWithCanvasCache } from \"./renderElement\";\n\nimport {\n  canBecomePolygon,\n  isElbowArrow,\n  isEmbeddableElement,\n  isIframeElement,\n  isIframeLikeElement,\n  isLinearElement,\n} from \"./typeChecks\";\nimport { getCornerRadius, isPathALoop } from \"./utils\";\nimport { headingForPointIsHorizontal } from \"./heading\";\n\nimport { canChangeRoundness } from \"./comparisons\";\nimport { generateFreeDrawShape } from \"./renderElement\";\nimport {\n  getArrowheadPoints,\n  getCenterForBounds,\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n} from \"./bounds\";\nimport { shouldTestInside } from \"./collision\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawSelectionElement,\n  ExcalidrawLinearElement,\n  Arrowhead,\n  ExcalidrawFreeDrawElement,\n  ElementsMap,\n  ExcalidrawLineElement,\n} from \"./types\";\n\nimport type { Drawable, Options } from \"roughjs/bin/core\";\nimport type { Point as RoughPoint } from \"roughjs/bin/geometry\";\n\nexport class ShapeCache {\n  private static rg = new RoughGenerator();\n  private static cache = new WeakMap<ExcalidrawElement, ElementShape>();\n\n  /**\n   * Retrieves shape from cache if available. Use this only if shape\n   * is optional and you have a fallback in case it's not cached.\n   */\n  public static get = <T extends ExcalidrawElement>(element: T) => {\n    return ShapeCache.cache.get(\n      element,\n    ) as T[\"type\"] extends keyof ElementShapes\n      ? ElementShapes[T[\"type\"]] | undefined\n      : ElementShape | undefined;\n  };\n\n  public static set = <T extends ExcalidrawElement>(\n    element: T,\n    shape: T[\"type\"] extends keyof ElementShapes\n      ? ElementShapes[T[\"type\"]]\n      : Drawable,\n  ) => ShapeCache.cache.set(element, shape);\n\n  public static delete = (element: ExcalidrawElement) =>\n    ShapeCache.cache.delete(element);\n\n  public static destroy = () => {\n    ShapeCache.cache = new WeakMap();\n  };\n\n  /**\n   * Generates & caches shape for element if not already cached, otherwise\n   * returns cached shape.\n   */\n  public static generateElementShape = <\n    T extends Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n  >(\n    element: T,\n    renderConfig: {\n      isExporting: boolean;\n      canvasBackgroundColor: AppState[\"viewBackgroundColor\"];\n      embedsValidationStatus: EmbedsValidationStatus;\n    } | null,\n  ) => {\n    // when exporting, always regenerated to guarantee the latest shape\n    const cachedShape = renderConfig?.isExporting\n      ? undefined\n      : ShapeCache.get(element);\n\n    // `null` indicates no rc shape applicable for this element type,\n    // but it's considered a valid cache value (= do not regenerate)\n    if (cachedShape !== undefined) {\n      return cachedShape;\n    }\n\n    elementWithCanvasCache.delete(element);\n\n    const shape = generateElementShape(\n      element,\n      ShapeCache.rg,\n      renderConfig || {\n        isExporting: false,\n        canvasBackgroundColor: COLOR_PALETTE.white,\n        embedsValidationStatus: null,\n      },\n    ) as T[\"type\"] extends keyof ElementShapes\n      ? ElementShapes[T[\"type\"]]\n      : Drawable | null;\n\n    ShapeCache.cache.set(element, shape);\n\n    return shape;\n  };\n}\n\nconst getDashArrayDashed = (strokeWidth: number) => [8, 8 + strokeWidth];\n\nconst getDashArrayDotted = (strokeWidth: number) => [1.5, 6 + strokeWidth];\n\nfunction adjustRoughness(element: ExcalidrawElement): number {\n  const roughness = element.roughness;\n\n  const maxSize = Math.max(element.width, element.height);\n  const minSize = Math.min(element.width, element.height);\n\n  // don't reduce roughness if\n  if (\n    // both sides relatively big\n    (minSize >= 20 && maxSize >= 50) ||\n    // is round & both sides above 15px\n    (minSize >= 15 &&\n      !!element.roundness &&\n      canChangeRoundness(element.type)) ||\n    // relatively long linear element\n    (isLinearElement(element) && maxSize >= 50)\n  ) {\n    return roughness;\n  }\n\n  return Math.min(roughness / (maxSize < 10 ? 3 : 2), 2.5);\n}\n\nexport const generateRoughOptions = (\n  element: ExcalidrawElement,\n  continuousPath = false,\n): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? getDashArrayDashed(element.strokeWidth)\n        : element.strokeStyle === \"dotted\"\n        ? getDashArrayDotted(element.strokeWidth)\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    // dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    // similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    // hachureGap because if not specified, roughjs uses strokeWidth to\n    // calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: adjustRoughness(element),\n    stroke: element.strokeColor,\n    preserveVertices:\n      continuousPath || element.roughness < ROUGHNESS.cartoonist,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill = isTransparent(element.backgroundColor)\n        ? undefined\n        : element.backgroundColor;\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\":\n    case \"freedraw\": {\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nconst modifyIframeLikeForRoughOptions = (\n  element: NonDeletedExcalidrawElement,\n  isExporting: boolean,\n  embedsValidationStatus: EmbedsValidationStatus | null,\n) => {\n  if (\n    isIframeLikeElement(element) &&\n    (isExporting ||\n      (isEmbeddableElement(element) &&\n        embedsValidationStatus?.get(element.id) !== true)) &&\n    isTransparent(element.backgroundColor) &&\n    isTransparent(element.strokeColor)\n  ) {\n    return {\n      ...element,\n      roughness: 0,\n      backgroundColor: \"#d3d3d3\",\n      fillStyle: \"solid\",\n    } as const;\n  } else if (isIframeElement(element)) {\n    return {\n      ...element,\n      strokeColor: isTransparent(element.strokeColor)\n        ? \"#000000\"\n        : element.strokeColor,\n      backgroundColor: isTransparent(element.backgroundColor)\n        ? \"#f4f4f6\"\n        : element.backgroundColor,\n    };\n  }\n  return element;\n};\n\nconst getArrowheadShapes = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n  generator: RoughGenerator,\n  options: Options,\n  canvasBackgroundColor: string,\n) => {\n  const arrowheadPoints = getArrowheadPoints(\n    element,\n    shape,\n    position,\n    arrowhead,\n  );\n\n  if (arrowheadPoints === null) {\n    return [];\n  }\n\n  const generateCrowfootOne = (\n    arrowheadPoints: number[] | null,\n    options: Options,\n  ) => {\n    if (arrowheadPoints === null) {\n      return [];\n    }\n\n    const [, , x3, y3, x4, y4] = arrowheadPoints;\n\n    return [generator.line(x3, y3, x4, y4, options)];\n  };\n\n  switch (arrowhead) {\n    case \"dot\":\n    case \"circle\":\n    case \"circle_outline\": {\n      const [x, y, diameter] = arrowheadPoints;\n\n      // always use solid stroke for arrowhead\n      delete options.strokeLineDash;\n\n      return [\n        generator.circle(x, y, diameter, {\n          ...options,\n          fill:\n            arrowhead === \"circle_outline\"\n              ? canvasBackgroundColor\n              : element.strokeColor,\n\n          fillStyle: \"solid\",\n          stroke: element.strokeColor,\n          roughness: Math.min(0.5, options.roughness || 0),\n        }),\n      ];\n    }\n    case \"triangle\":\n    case \"triangle_outline\": {\n      const [x, y, x2, y2, x3, y3] = arrowheadPoints;\n\n      // always use solid stroke for arrowhead\n      delete options.strokeLineDash;\n\n      return [\n        generator.polygon(\n          [\n            [x, y],\n            [x2, y2],\n            [x3, y3],\n            [x, y],\n          ],\n          {\n            ...options,\n            fill:\n              arrowhead === \"triangle_outline\"\n                ? canvasBackgroundColor\n                : element.strokeColor,\n            fillStyle: \"solid\",\n            roughness: Math.min(1, options.roughness || 0),\n          },\n        ),\n      ];\n    }\n    case \"diamond\":\n    case \"diamond_outline\": {\n      const [x, y, x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n      // always use solid stroke for arrowhead\n      delete options.strokeLineDash;\n\n      return [\n        generator.polygon(\n          [\n            [x, y],\n            [x2, y2],\n            [x3, y3],\n            [x4, y4],\n            [x, y],\n          ],\n          {\n            ...options,\n            fill:\n              arrowhead === \"diamond_outline\"\n                ? canvasBackgroundColor\n                : element.strokeColor,\n            fillStyle: \"solid\",\n            roughness: Math.min(1, options.roughness || 0),\n          },\n        ),\n      ];\n    }\n    case \"crowfoot_one\":\n      return generateCrowfootOne(arrowheadPoints, options);\n    case \"bar\":\n    case \"arrow\":\n    case \"crowfoot_many\":\n    case \"crowfoot_one_or_many\":\n    default: {\n      const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;\n\n      if (element.strokeStyle === \"dotted\") {\n        // for dotted arrows caps, reduce gap to make it more legible\n        const dash = getDashArrayDotted(element.strokeWidth - 1);\n        options.strokeLineDash = [dash[0], dash[1] - 1];\n      } else {\n        // for solid/dashed, keep solid arrow cap\n        delete options.strokeLineDash;\n      }\n      options.roughness = Math.min(1, options.roughness || 0);\n      return [\n        generator.line(x3, y3, x2, y2, options),\n        generator.line(x4, y4, x2, y2, options),\n        ...(arrowhead === \"crowfoot_one_or_many\"\n          ? generateCrowfootOne(\n              getArrowheadPoints(element, shape, position, \"crowfoot_one\"),\n              options,\n            )\n          : []),\n      ];\n    }\n  }\n};\n\nexport const generateLinearCollisionShape = (\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n) => {\n  const generator = new RoughGenerator();\n  const options: Options = {\n    seed: element.seed,\n    disableMultiStroke: true,\n    disableMultiStrokeFill: true,\n    roughness: 0,\n    preserveVertices: true,\n  };\n  const center = getCenterForBounds(\n    // Need a non-rotated center point\n    element.points.reduce(\n      (acc, point) => {\n        return [\n          Math.min(element.x + point[0], acc[0]),\n          Math.min(element.y + point[1], acc[1]),\n          Math.max(element.x + point[0], acc[2]),\n          Math.max(element.y + point[1], acc[3]),\n        ];\n      },\n      [Infinity, Infinity, -Infinity, -Infinity],\n    ),\n  );\n\n  switch (element.type) {\n    case \"line\":\n    case \"arrow\": {\n      // points array can be empty in the beginning, so it is important to add\n      // initial position to it\n      const points = element.points.length\n        ? element.points\n        : [pointFrom<LocalPoint>(0, 0)];\n\n      if (isElbowArrow(element)) {\n        return generator.path(generateElbowArrowShape(points, 16), options)\n          .sets[0].ops;\n      } else if (!element.roundness) {\n        return points.map((point, idx) => {\n          const p = pointRotateRads(\n            pointFrom<GlobalPoint>(element.x + point[0], element.y + point[1]),\n            center,\n            element.angle,\n          );\n\n          return {\n            op: idx === 0 ? \"move\" : \"lineTo\",\n            data: pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n          };\n        });\n      }\n\n      return generator\n        .curve(points as unknown as RoughPoint[], options)\n        .sets[0].ops.slice(0, element.points.length)\n        .map((op, i) => {\n          if (i === 0) {\n            const p = pointRotateRads<GlobalPoint>(\n              pointFrom<GlobalPoint>(\n                element.x + op.data[0],\n                element.y + op.data[1],\n              ),\n              center,\n              element.angle,\n            );\n\n            return {\n              op: \"move\",\n              data: pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n            };\n          }\n\n          return {\n            op: \"bcurveTo\",\n            data: [\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[0],\n                  element.y + op.data[1],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[2],\n                  element.y + op.data[3],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[4],\n                  element.y + op.data[5],\n                ),\n                center,\n                element.angle,\n              ),\n            ]\n              .map((p) =>\n                pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n              )\n              .flat(),\n          };\n        });\n    }\n    case \"freedraw\": {\n      if (element.points.length < 2) {\n        return [];\n      }\n\n      const simplifiedPoints = simplify(\n        element.points as Mutable<LocalPoint[]>,\n        0.75,\n      );\n\n      return generator\n        .curve(simplifiedPoints as [number, number][], options)\n        .sets[0].ops.slice(0, element.points.length)\n        .map((op, i) => {\n          if (i === 0) {\n            const p = pointRotateRads<GlobalPoint>(\n              pointFrom<GlobalPoint>(\n                element.x + op.data[0],\n                element.y + op.data[1],\n              ),\n              center,\n              element.angle,\n            );\n\n            return {\n              op: \"move\",\n              data: pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n            };\n          }\n\n          return {\n            op: \"bcurveTo\",\n            data: [\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[0],\n                  element.y + op.data[1],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[2],\n                  element.y + op.data[3],\n                ),\n                center,\n                element.angle,\n              ),\n              pointRotateRads(\n                pointFrom<GlobalPoint>(\n                  element.x + op.data[4],\n                  element.y + op.data[5],\n                ),\n                center,\n                element.angle,\n              ),\n            ]\n              .map((p) =>\n                pointFrom<LocalPoint>(p[0] - element.x, p[1] - element.y),\n              )\n              .flat(),\n          };\n        });\n    }\n  }\n};\n\n/**\n * Generates the roughjs shape for given element.\n *\n * Low-level. Use `ShapeCache.generateElementShape` instead.\n *\n * @private\n */\nconst generateElementShape = (\n  element: Exclude<NonDeletedExcalidrawElement, ExcalidrawSelectionElement>,\n  generator: RoughGenerator,\n  {\n    isExporting,\n    canvasBackgroundColor,\n    embedsValidationStatus,\n  }: {\n    isExporting: boolean;\n    canvasBackgroundColor: string;\n    embedsValidationStatus: EmbedsValidationStatus | null;\n  },\n): Drawable | Drawable[] | null => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\": {\n      let shape: ElementShapes[typeof element.type];\n      // this is for rendering the stroke/bg of the embeddable, especially\n      // when the src url is not set\n\n      if (element.roundness) {\n        const w = element.width;\n        const h = element.height;\n        const r = getCornerRadius(Math.min(w, h), element);\n        shape = generator.path(\n          `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${\n            h - r\n          } Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${\n            h - r\n          } L 0 ${r} Q 0 0, ${r} 0`,\n          generateRoughOptions(\n            modifyIframeLikeForRoughOptions(\n              element,\n              isExporting,\n              embedsValidationStatus,\n            ),\n            true,\n          ),\n        );\n      } else {\n        shape = generator.rectangle(\n          0,\n          0,\n          element.width,\n          element.height,\n          generateRoughOptions(\n            modifyIframeLikeForRoughOptions(\n              element,\n              isExporting,\n              embedsValidationStatus,\n            ),\n            false,\n          ),\n        );\n      }\n      return shape;\n    }\n    case \"diamond\": {\n      let shape: ElementShapes[typeof element.type];\n\n      const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] =\n        getDiamondPoints(element);\n      if (element.roundness) {\n        const verticalRadius = getCornerRadius(Math.abs(topX - leftX), element);\n\n        const horizontalRadius = getCornerRadius(\n          Math.abs(rightY - topY),\n          element,\n        );\n\n        shape = generator.path(\n          `M ${topX + verticalRadius} ${topY + horizontalRadius} L ${\n            rightX - verticalRadius\n          } ${rightY - horizontalRadius}\n            C ${rightX} ${rightY}, ${rightX} ${rightY}, ${\n            rightX - verticalRadius\n          } ${rightY + horizontalRadius}\n            L ${bottomX + verticalRadius} ${bottomY - horizontalRadius}\n            C ${bottomX} ${bottomY}, ${bottomX} ${bottomY}, ${\n            bottomX - verticalRadius\n          } ${bottomY - horizontalRadius}\n            L ${leftX + verticalRadius} ${leftY + horizontalRadius}\n            C ${leftX} ${leftY}, ${leftX} ${leftY}, ${leftX + verticalRadius} ${\n            leftY - horizontalRadius\n          }\n            L ${topX - verticalRadius} ${topY + horizontalRadius}\n            C ${topX} ${topY}, ${topX} ${topY}, ${topX + verticalRadius} ${\n            topY + horizontalRadius\n          }`,\n          generateRoughOptions(element, true),\n        );\n      } else {\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          generateRoughOptions(element),\n        );\n      }\n      return shape;\n    }\n    case \"ellipse\": {\n      const shape: ElementShapes[typeof element.type] = generator.ellipse(\n        element.width / 2,\n        element.height / 2,\n        element.width,\n        element.height,\n        generateRoughOptions(element),\n      );\n      return shape;\n    }\n    case \"line\":\n    case \"arrow\": {\n      let shape: ElementShapes[typeof element.type];\n      const options = generateRoughOptions(element);\n\n      // points array can be empty in the beginning, so it is important to add\n      // initial position to it\n      const points = element.points.length\n        ? element.points\n        : [pointFrom<LocalPoint>(0, 0)];\n\n      if (isElbowArrow(element)) {\n        // NOTE (mtolmacs): Temporary fix for extremely big arrow shapes\n        if (\n          !points.every(\n            (point) => Math.abs(point[0]) <= 1e6 && Math.abs(point[1]) <= 1e6,\n          )\n        ) {\n          console.error(\n            `Elbow arrow with extreme point positions detected. Arrow not rendered.`,\n            element.id,\n            JSON.stringify(points),\n          );\n          shape = [];\n        } else {\n          shape = [\n            generator.path(\n              generateElbowArrowShape(points, 16),\n              generateRoughOptions(element, true),\n            ),\n          ];\n        }\n      } else if (!element.roundness) {\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        if (options.fill) {\n          shape = [\n            generator.polygon(points as unknown as RoughPoint[], options),\n          ];\n        } else {\n          shape = [\n            generator.linearPath(points as unknown as RoughPoint[], options),\n          ];\n        }\n      } else {\n        shape = [generator.curve(points as unknown as RoughPoint[], options)];\n      }\n\n      // add lines only in arrow\n      if (element.type === \"arrow\") {\n        const { startArrowhead = null, endArrowhead = \"arrow\" } = element;\n\n        if (startArrowhead !== null) {\n          const shapes = getArrowheadShapes(\n            element,\n            shape,\n            \"start\",\n            startArrowhead,\n            generator,\n            options,\n            canvasBackgroundColor,\n          );\n          shape.push(...shapes);\n        }\n\n        if (endArrowhead !== null) {\n          if (endArrowhead === undefined) {\n            // Hey, we have an old arrow here!\n          }\n\n          const shapes = getArrowheadShapes(\n            element,\n            shape,\n            \"end\",\n            endArrowhead,\n            generator,\n            options,\n            canvasBackgroundColor,\n          );\n          shape.push(...shapes);\n        }\n      }\n      return shape;\n    }\n    case \"freedraw\": {\n      let shape: ElementShapes[typeof element.type];\n      generateFreeDrawShape(element);\n\n      if (isPathALoop(element.points)) {\n        // generate rough polygon to fill freedraw shape\n        const simplifiedPoints = simplify(\n          element.points as Mutable<LocalPoint[]>,\n          0.75,\n        );\n        shape = generator.curve(simplifiedPoints as [number, number][], {\n          ...generateRoughOptions(element),\n          stroke: \"none\",\n        });\n      } else {\n        shape = null;\n      }\n      return shape;\n    }\n    case \"frame\":\n    case \"magicframe\":\n    case \"text\":\n    case \"image\": {\n      const shape: ElementShapes[typeof element.type] = null;\n      // we return (and cache) `null` to make sure we don't regenerate\n      // `element.canvas` on rerenders\n      return shape;\n    }\n    default: {\n      assertNever(\n        element,\n        `generateElementShape(): Unimplemented type ${(element as any)?.type}`,\n      );\n      return null;\n    }\n  }\n};\n\nconst generateElbowArrowShape = (\n  points: readonly LocalPoint[],\n  radius: number,\n) => {\n  const subpoints = [] as [number, number][];\n  for (let i = 1; i < points.length - 1; i += 1) {\n    const prev = points[i - 1];\n    const next = points[i + 1];\n    const point = points[i];\n    const prevIsHorizontal = headingForPointIsHorizontal(point, prev);\n    const nextIsHorizontal = headingForPointIsHorizontal(next, point);\n    const corner = Math.min(\n      radius,\n      pointDistance(points[i], next) / 2,\n      pointDistance(points[i], prev) / 2,\n    );\n\n    if (prevIsHorizontal) {\n      if (prev[0] < point[0]) {\n        // LEFT\n        subpoints.push([points[i][0] - corner, points[i][1]]);\n      } else {\n        // RIGHT\n        subpoints.push([points[i][0] + corner, points[i][1]]);\n      }\n    } else if (prev[1] < point[1]) {\n      // UP\n      subpoints.push([points[i][0], points[i][1] - corner]);\n    } else {\n      subpoints.push([points[i][0], points[i][1] + corner]);\n    }\n\n    subpoints.push(points[i] as [number, number]);\n\n    if (nextIsHorizontal) {\n      if (next[0] < point[0]) {\n        // LEFT\n        subpoints.push([points[i][0] - corner, points[i][1]]);\n      } else {\n        // RIGHT\n        subpoints.push([points[i][0] + corner, points[i][1]]);\n      }\n    } else if (next[1] < point[1]) {\n      // UP\n      subpoints.push([points[i][0], points[i][1] - corner]);\n    } else {\n      // DOWN\n      subpoints.push([points[i][0], points[i][1] + corner]);\n    }\n  }\n\n  const d = [`M ${points[0][0]} ${points[0][1]}`];\n  for (let i = 0; i < subpoints.length; i += 3) {\n    d.push(`L ${subpoints[i][0]} ${subpoints[i][1]}`);\n    d.push(\n      `Q ${subpoints[i + 1][0]} ${subpoints[i + 1][1]}, ${\n        subpoints[i + 2][0]\n      } ${subpoints[i + 2][1]}`,\n    );\n  }\n  d.push(`L ${points[points.length - 1][0]} ${points[points.length - 1][1]}`);\n\n  return d.join(\" \");\n};\n\n/**\n * get the pure geometric shape of an excalidraw elementw\n * which is then used for hit detection\n */\nexport const getElementShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): GeometricShape<Point> => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"frame\":\n    case \"magicframe\":\n    case \"embeddable\":\n    case \"image\":\n    case \"iframe\":\n    case \"text\":\n    case \"selection\":\n      return getPolygonShape(element);\n    case \"arrow\":\n    case \"line\": {\n      const roughShape =\n        ShapeCache.get(element)?.[0] ??\n        ShapeCache.generateElementShape(element, null)[0];\n      const [, , , , cx, cy] = getElementAbsoluteCoords(element, elementsMap);\n\n      return shouldTestInside(element)\n        ? getClosedCurveShape<Point>(\n            element,\n            roughShape,\n            pointFrom<Point>(element.x, element.y),\n            element.angle,\n            pointFrom(cx, cy),\n          )\n        : getCurveShape<Point>(\n            roughShape,\n            pointFrom<Point>(element.x, element.y),\n            element.angle,\n            pointFrom(cx, cy),\n          );\n    }\n\n    case \"ellipse\":\n      return getEllipseShape(element);\n\n    case \"freedraw\": {\n      const [, , , , cx, cy] = getElementAbsoluteCoords(element, elementsMap);\n      return getFreedrawShape(\n        element,\n        pointFrom(cx, cy),\n        shouldTestInside(element),\n      );\n    }\n  }\n};\n\nexport const toggleLinePolygonState = (\n  element: ExcalidrawLineElement,\n  nextPolygonState: boolean,\n): {\n  polygon: ExcalidrawLineElement[\"polygon\"];\n  points: ExcalidrawLineElement[\"points\"];\n} | null => {\n  const updatedPoints = [...element.points];\n\n  if (nextPolygonState) {\n    if (!canBecomePolygon(element.points)) {\n      return null;\n    }\n\n    const firstPoint = updatedPoints[0];\n    const lastPoint = updatedPoints[updatedPoints.length - 1];\n\n    const distance = Math.hypot(\n      firstPoint[0] - lastPoint[0],\n      firstPoint[1] - lastPoint[1],\n    );\n\n    if (\n      distance > LINE_POLYGON_POINT_MERGE_DISTANCE ||\n      updatedPoints.length < 4\n    ) {\n      updatedPoints.push(pointFrom(firstPoint[0], firstPoint[1]));\n    } else {\n      updatedPoints[updatedPoints.length - 1] = pointFrom(\n        firstPoint[0],\n        firstPoint[1],\n      );\n    }\n  }\n\n  // TODO: satisfies ElementUpdate<ExcalidrawLineElement>\n  const ret = {\n    polygon: nextPolygonState,\n    points: updatedPoints,\n  };\n\n  return ret;\n};\n",
    "/**\n * this file defines pure geometric shapes\n *\n * for instance, a cubic bezier curve is specified by its four control points and\n * an ellipse is defined by its center, angle, semi major axis and semi minor axis\n * (but in semi-width and semi-height so it's more relevant to Excalidraw)\n *\n * the idea with pure shapes is so that we can provide collision and other geoemtric methods not depending on\n * the specifics of roughjs or elements in Excalidraw; instead, we can focus on the pure shapes themselves\n *\n * also included in this file are methods for converting an Excalidraw element or a Drawable from roughjs\n * to pure shapes\n */\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport { invariant } from \"@excalidraw/common\";\nimport {\n  curve,\n  lineSegment,\n  pointFrom,\n  pointDistance,\n  pointFromArray,\n  pointFromVector,\n  pointRotateRads,\n  polygon,\n  polygonFromPoints,\n  PRECISION,\n  segmentsIntersectAt,\n  vector,\n  vectorAdd,\n  vectorFromPoint,\n  vectorScale,\n  type GlobalPoint,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport { getElementAbsoluteCoords } from \"@excalidraw/element\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawBindableElement,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawEmbeddableElement,\n  ExcalidrawFrameLikeElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawIframeElement,\n  ExcalidrawImageElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectangleElement,\n  ExcalidrawSelectionElement,\n  ExcalidrawTextElement,\n} from \"@excalidraw/element/types\";\nimport type { Curve, LineSegment, Polygon, Radians } from \"@excalidraw/math\";\n\nimport type { Drawable, Op } from \"roughjs/bin/core\";\n\n// a polyline (made up term here) is a line consisting of other line segments\n// this corresponds to a straight line element in the editor but it could also\n// be used to model other elements\nexport type Polyline<Point extends GlobalPoint | LocalPoint> =\n  LineSegment<Point>[];\n\n// a polycurve is a curve consisting of ther curves, this corresponds to a complex\n// curve on the canvas\nexport type Polycurve<Point extends GlobalPoint | LocalPoint> = Curve<Point>[];\n\n// an ellipse is specified by its center, angle, and its major and minor axes\n// but for the sake of simplicity, we've used halfWidth and halfHeight instead\n// in replace of semi major and semi minor axes\nexport type Ellipse<Point extends GlobalPoint | LocalPoint> = {\n  center: Point;\n  angle: Radians;\n  halfWidth: number;\n  halfHeight: number;\n};\n\nexport type GeometricShape<Point extends GlobalPoint | LocalPoint> =\n  | {\n      type: \"line\";\n      data: LineSegment<Point>;\n    }\n  | {\n      type: \"polygon\";\n      data: Polygon<Point>;\n    }\n  | {\n      type: \"curve\";\n      data: Curve<Point>;\n    }\n  | {\n      type: \"ellipse\";\n      data: Ellipse<Point>;\n    }\n  | {\n      type: \"polyline\";\n      data: Polyline<Point>;\n    }\n  | {\n      type: \"polycurve\";\n      data: Polycurve<Point>;\n    };\n\ntype RectangularElement =\n  | ExcalidrawRectangleElement\n  | ExcalidrawDiamondElement\n  | ExcalidrawFrameLikeElement\n  | ExcalidrawEmbeddableElement\n  | ExcalidrawImageElement\n  | ExcalidrawIframeElement\n  | ExcalidrawTextElement\n  | ExcalidrawSelectionElement;\n\n// polygon\nexport const getPolygonShape = <Point extends GlobalPoint | LocalPoint>(\n  element: RectangularElement,\n): GeometricShape<Point> => {\n  const { angle, width, height, x, y } = element;\n\n  const cx = x + width / 2;\n  const cy = y + height / 2;\n\n  const center: Point = pointFrom(cx, cy);\n\n  let data: Polygon<Point>;\n\n  if (element.type === \"diamond\") {\n    data = polygon(\n      pointRotateRads(pointFrom(cx, y), center, angle),\n      pointRotateRads(pointFrom(x + width, cy), center, angle),\n      pointRotateRads(pointFrom(cx, y + height), center, angle),\n      pointRotateRads(pointFrom(x, cy), center, angle),\n    );\n  } else {\n    data = polygon(\n      pointRotateRads(pointFrom(x, y), center, angle),\n      pointRotateRads(pointFrom(x + width, y), center, angle),\n      pointRotateRads(pointFrom(x + width, y + height), center, angle),\n      pointRotateRads(pointFrom(x, y + height), center, angle),\n    );\n  }\n\n  return {\n    type: \"polygon\",\n    data,\n  };\n};\n\n// return the selection box for an element, possibly rotated as well\nexport const getSelectionBoxShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  padding = 10,\n) => {\n  let [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n    element,\n    elementsMap,\n    true,\n  );\n\n  x1 -= padding;\n  x2 += padding;\n  y1 -= padding;\n  y2 += padding;\n\n  //const angleInDegrees = angleToDegrees(element.angle);\n  const center = pointFrom(cx, cy);\n  const topLeft = pointRotateRads(pointFrom(x1, y1), center, element.angle);\n  const topRight = pointRotateRads(pointFrom(x2, y1), center, element.angle);\n  const bottomLeft = pointRotateRads(pointFrom(x1, y2), center, element.angle);\n  const bottomRight = pointRotateRads(pointFrom(x2, y2), center, element.angle);\n\n  return {\n    type: \"polygon\",\n    data: [topLeft, topRight, bottomRight, bottomLeft],\n  } as GeometricShape<Point>;\n};\n\n// ellipse\nexport const getEllipseShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawEllipseElement,\n): GeometricShape<Point> => {\n  const { width, height, angle, x, y } = element;\n\n  return {\n    type: \"ellipse\",\n    data: {\n      center: pointFrom(x + width / 2, y + height / 2),\n      angle,\n      halfWidth: width / 2,\n      halfHeight: height / 2,\n    },\n  };\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  // NOTE (mtolmacs): Temporary fix for extremely large elements\n  if (!shape) {\n    return [];\n  }\n\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\n// linear\nexport const getCurveShape = <Point extends GlobalPoint | LocalPoint>(\n  roughShape: Drawable,\n  startingPoint: Point = pointFrom(0, 0),\n  angleInRadian: Radians,\n  center: Point,\n): GeometricShape<Point> => {\n  const transform = (p: Point): Point =>\n    pointRotateRads(\n      pointFrom(p[0] + startingPoint[0], p[1] + startingPoint[1]),\n      center,\n      angleInRadian,\n    );\n\n  const ops = getCurvePathOps(roughShape);\n  const polycurve: Polycurve<Point> = [];\n  let p0 = pointFrom<Point>(0, 0);\n\n  for (const op of ops) {\n    if (op.op === \"move\") {\n      const p = pointFromArray<Point>(op.data);\n      invariant(p != null, \"Ops data is not a point\");\n      p0 = transform(p);\n    }\n    if (op.op === \"bcurveTo\") {\n      const p1 = transform(pointFrom<Point>(op.data[0], op.data[1]));\n      const p2 = transform(pointFrom<Point>(op.data[2], op.data[3]));\n      const p3 = transform(pointFrom<Point>(op.data[4], op.data[5]));\n      polycurve.push(curve<Point>(p0, p1, p2, p3));\n      p0 = p3;\n    }\n  }\n\n  return {\n    type: \"polycurve\",\n    data: polycurve,\n  };\n};\n\nconst polylineFromPoints = <Point extends GlobalPoint | LocalPoint>(\n  points: Point[],\n): Polyline<Point> => {\n  let previousPoint: Point = points[0];\n  const polyline: LineSegment<Point>[] = [];\n\n  for (let i = 1; i < points.length; i++) {\n    const nextPoint = points[i];\n    polyline.push(lineSegment<Point>(previousPoint, nextPoint));\n    previousPoint = nextPoint;\n  }\n\n  return polyline;\n};\n\nexport const getFreedrawShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawFreeDrawElement,\n  center: Point,\n  isClosed: boolean = false,\n): GeometricShape<Point> => {\n  const transform = (p: Point) =>\n    pointRotateRads(\n      pointFromVector(\n        vectorAdd(vectorFromPoint(p), vector(element.x, element.y)),\n      ),\n      center,\n      element.angle,\n    );\n\n  const polyline = polylineFromPoints(\n    element.points.map((p) => transform(p as Point)),\n  );\n\n  return (\n    isClosed\n      ? {\n          type: \"polygon\",\n          data: polygonFromPoints(polyline.flat()),\n        }\n      : {\n          type: \"polyline\",\n          data: polyline,\n        }\n  ) as GeometricShape<Point>;\n};\n\nexport const getClosedCurveShape = <Point extends GlobalPoint | LocalPoint>(\n  element: ExcalidrawLinearElement,\n  roughShape: Drawable,\n  startingPoint: Point = pointFrom<Point>(0, 0),\n  angleInRadian: Radians,\n  center: Point,\n): GeometricShape<Point> => {\n  const transform = (p: Point) =>\n    pointRotateRads(\n      pointFrom(p[0] + startingPoint[0], p[1] + startingPoint[1]),\n      center,\n      angleInRadian,\n    );\n\n  if (element.roundness === null) {\n    return {\n      type: \"polygon\",\n      data: polygonFromPoints(\n        element.points.map((p) => transform(p as Point)) as Point[],\n      ),\n    };\n  }\n\n  const ops = getCurvePathOps(roughShape);\n\n  const points: Point[] = [];\n  let odd = false;\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      odd = !odd;\n      if (odd) {\n        points.push(pointFrom(operation.data[0], operation.data[1]));\n      }\n    } else if (operation.op === \"bcurveTo\") {\n      if (odd) {\n        points.push(pointFrom(operation.data[0], operation.data[1]));\n        points.push(pointFrom(operation.data[2], operation.data[3]));\n        points.push(pointFrom(operation.data[4], operation.data[5]));\n      }\n    } else if (operation.op === \"lineTo\") {\n      if (odd) {\n        points.push(pointFrom(operation.data[0], operation.data[1]));\n      }\n    }\n  }\n\n  const polygonPoints = pointsOnBezierCurves(points, 10, 5).map((p) =>\n    transform(p as Point),\n  ) as Point[];\n\n  return {\n    type: \"polygon\",\n    data: polygonFromPoints<Point>(polygonPoints),\n  };\n};\n\n/**\n * Determine intersection of a rectangular shaped element and a\n * line segment.\n *\n * @param element The rectangular element to test against\n * @param segment The segment intersecting the element\n * @param gap Optional value to inflate the shape before testing\n * @returns An array of intersections\n */\n// TODO: Replace with final rounded rectangle code\nexport const segmentIntersectRectangleElement = <\n  Point extends LocalPoint | GlobalPoint,\n>(\n  element: ExcalidrawBindableElement,\n  segment: LineSegment<Point>,\n  gap: number = 0,\n): Point[] => {\n  const bounds = [\n    element.x - gap,\n    element.y - gap,\n    element.x + element.width + gap,\n    element.y + element.height + gap,\n  ];\n  const center = pointFrom(\n    (bounds[0] + bounds[2]) / 2,\n    (bounds[1] + bounds[3]) / 2,\n  );\n\n  return [\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[0], bounds[1]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[2], bounds[1]), center, element.angle),\n    ),\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[2], bounds[1]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[2], bounds[3]), center, element.angle),\n    ),\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[2], bounds[3]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[0], bounds[3]), center, element.angle),\n    ),\n    lineSegment(\n      pointRotateRads(pointFrom(bounds[0], bounds[3]), center, element.angle),\n      pointRotateRads(pointFrom(bounds[0], bounds[1]), center, element.angle),\n    ),\n  ]\n    .map((s) => segmentsIntersectAt(segment, s))\n    .filter((i): i is Point => !!i);\n};\n\nconst distanceToEllipse = <Point extends LocalPoint | GlobalPoint>(\n  p: Point,\n  ellipse: Ellipse<Point>,\n) => {\n  const { angle, halfWidth, halfHeight, center } = ellipse;\n  const a = halfWidth;\n  const b = halfHeight;\n  const translatedPoint = vectorAdd(\n    vectorFromPoint(p),\n    vectorScale(vectorFromPoint(center), -1),\n  );\n  const [rotatedPointX, rotatedPointY] = pointRotateRads(\n    pointFromVector(translatedPoint),\n    pointFrom(0, 0),\n    -angle as Radians,\n  );\n\n  const px = Math.abs(rotatedPointX);\n  const py = Math.abs(rotatedPointY);\n\n  let tx = 0.707;\n  let ty = 0.707;\n\n  for (let i = 0; i < 3; i++) {\n    const x = a * tx;\n    const y = b * ty;\n\n    const ex = ((a * a - b * b) * tx ** 3) / a;\n    const ey = ((b * b - a * a) * ty ** 3) / b;\n\n    const rx = x - ex;\n    const ry = y - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n\n    const r = Math.hypot(ry, rx);\n    const q = Math.hypot(qy, qx);\n\n    tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n    ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n    const t = Math.hypot(ty, tx);\n    tx /= t;\n    ty /= t;\n  }\n\n  const [minX, minY] = [\n    a * tx * Math.sign(rotatedPointX),\n    b * ty * Math.sign(rotatedPointY),\n  ];\n\n  return pointDistance(\n    pointFrom(rotatedPointX, rotatedPointY),\n    pointFrom(minX, minY),\n  );\n};\n\nexport const pointOnEllipse = <Point extends LocalPoint | GlobalPoint>(\n  point: Point,\n  ellipse: Ellipse<Point>,\n  threshold = PRECISION,\n) => {\n  return distanceToEllipse(point, ellipse) <= threshold;\n};\n\nexport const pointInEllipse = <Point extends LocalPoint | GlobalPoint>(\n  p: Point,\n  ellipse: Ellipse<Point>,\n) => {\n  const { center, angle, halfWidth, halfHeight } = ellipse;\n  const translatedPoint = vectorAdd(\n    vectorFromPoint(p),\n    vectorScale(vectorFromPoint(center), -1),\n  );\n  const [rotatedPointX, rotatedPointY] = pointRotateRads(\n    pointFromVector(translatedPoint),\n    pointFrom(0, 0),\n    -angle as Radians,\n  );\n\n  return (\n    (rotatedPointX / halfWidth) * (rotatedPointX / halfWidth) +\n      (rotatedPointY / halfHeight) * (rotatedPointY / halfHeight) <=\n    1\n  );\n};\n\nexport const ellipseAxes = <Point extends LocalPoint | GlobalPoint>(\n  ellipse: Ellipse<Point>,\n) => {\n  const widthGreaterThanHeight = ellipse.halfWidth > ellipse.halfHeight;\n\n  const majorAxis = widthGreaterThanHeight\n    ? ellipse.halfWidth * 2\n    : ellipse.halfHeight * 2;\n  const minorAxis = widthGreaterThanHeight\n    ? ellipse.halfHeight * 2\n    : ellipse.halfWidth * 2;\n\n  return {\n    majorAxis,\n    minorAxis,\n  };\n};\n\nexport const ellipseFocusToCenter = <Point extends LocalPoint | GlobalPoint>(\n  ellipse: Ellipse<Point>,\n) => {\n  const { majorAxis, minorAxis } = ellipseAxes(ellipse);\n\n  return Math.sqrt(majorAxis ** 2 - minorAxis ** 2);\n};\n\nexport const ellipseExtremes = <Point extends LocalPoint | GlobalPoint>(\n  ellipse: Ellipse<Point>,\n) => {\n  const { center, angle } = ellipse;\n  const { majorAxis, minorAxis } = ellipseAxes(ellipse);\n\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n\n  const sqSum = majorAxis ** 2 + minorAxis ** 2;\n  const sqDiff = (majorAxis ** 2 - minorAxis ** 2) * Math.cos(2 * angle);\n\n  const yMax = Math.sqrt((sqSum - sqDiff) / 2);\n  const xAtYMax =\n    (yMax * sqSum * sin * cos) /\n    (majorAxis ** 2 * sin ** 2 + minorAxis ** 2 * cos ** 2);\n\n  const xMax = Math.sqrt((sqSum + sqDiff) / 2);\n  const yAtXMax =\n    (xMax * sqSum * sin * cos) /\n    (majorAxis ** 2 * cos ** 2 + minorAxis ** 2 * sin ** 2);\n  const centerVector = vectorFromPoint(center);\n\n  return [\n    vectorAdd(vector(xAtYMax, yMax), centerVector),\n    vectorAdd(vectorScale(vector(xAtYMax, yMax), -1), centerVector),\n    vectorAdd(vector(xMax, yAtXMax), centerVector),\n    vectorAdd(vector(xMax, yAtXMax), centerVector),\n  ];\n};\n",
    "import rough from \"roughjs/bin/rough\";\nimport { getStroke } from \"perfect-freehand\";\n\nimport { isRightAngleRads } from \"@excalidraw/math\";\n\nimport {\n  BOUND_TEXT_PADDING,\n  DEFAULT_REDUCED_GLOBAL_ALPHA,\n  ELEMENT_READY_TO_ERASE_OPACITY,\n  FRAME_STYLE,\n  MIME_TYPES,\n  THEME,\n  distance,\n  getFontString,\n  isRTL,\n  getVerticalOffset,\n} from \"@excalidraw/common\";\n\nimport type {\n  AppState,\n  StaticCanvasAppState,\n  Zoom,\n  InteractiveCanvasAppState,\n  ElementsPendingErasure,\n  PendingExcalidrawElements,\n  NormalizedZoomValue,\n} from \"excalidraw-custom/types\";\n\nimport type {\n  StaticCanvasRenderConfig,\n  RenderableElementsMap,\n  InteractiveCanvasRenderConfig,\n} from \"excalidraw-custom/scene/types\";\n\nimport { getElementAbsoluteCoords } from \"./bounds\";\nimport { getUncroppedImageElement } from \"./cropElement\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport {\n  getBoundTextElement,\n  getContainerCoords,\n  getContainerElement,\n  getBoundTextMaxHeight,\n  getBoundTextMaxWidth,\n} from \"./textElement\";\nimport { getLineHeightInPx } from \"./textMeasurements\";\nimport {\n  isTextElement,\n  isLinearElement,\n  isFreeDrawElement,\n  isInitializedImageElement,\n  isArrowElement,\n  hasBoundTextElement,\n  isMagicFrameElement,\n  isImageElement,\n} from \"./typeChecks\";\nimport { getContainingFrame } from \"./frame\";\nimport { getCornerRadius } from \"./utils\";\n\nimport { ShapeCache } from \"./shape\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawFrameLikeElement,\n  NonDeletedSceneElementsMap,\n  ElementsMap,\n} from \"./types\";\n\nimport type { StrokeOptions } from \"perfect-freehand\";\nimport type { RoughCanvas } from \"roughjs/bin/canvas\";\n\n// using a stronger invert (100% vs our regular 93%) and saturate\n// as a temp hack to make images in dark theme look closer to original\n// color scheme (it's still not quite there and the colors look slightly\n// desatured, alas...)\nexport const IMAGE_INVERT_FILTER =\n  \"invert(100%) hue-rotate(180deg) saturate(1.25)\";\n\nconst isPendingImageElement = (\n  element: ExcalidrawElement,\n  renderConfig: StaticCanvasRenderConfig,\n) =>\n  isInitializedImageElement(element) &&\n  !renderConfig.imageCache.has(element.fileId);\n\nconst shouldResetImageFilter = (\n  element: ExcalidrawElement,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n) => {\n  return (\n    appState.theme === THEME.DARK &&\n    isInitializedImageElement(element) &&\n    !isPendingImageElement(element, renderConfig) &&\n    renderConfig.imageCache.get(element.fileId)?.mimeType !== MIME_TYPES.svg\n  );\n};\n\nconst getCanvasPadding = (element: ExcalidrawElement) => {\n  switch (element.type) {\n    case \"freedraw\":\n      return element.strokeWidth * 12;\n    case \"text\":\n      return element.fontSize / 2;\n    default:\n      return 20;\n  }\n};\n\nexport const getRenderOpacity = (\n  element: ExcalidrawElement,\n  containingFrame: ExcalidrawFrameLikeElement | null,\n  elementsPendingErasure: ElementsPendingErasure,\n  pendingNodes: Readonly<PendingExcalidrawElements> | null,\n  globalAlpha: number = 1,\n) => {\n  // multiplying frame opacity with element opacity to combine them\n  // (e.g. frame 50% and element 50% opacity should result in 25% opacity)\n  let opacity =\n    (((containingFrame?.opacity ?? 100) * element.opacity) / 10000) *\n    globalAlpha;\n\n  // if pending erasure, multiply again to combine further\n  // (so that erasing always results in lower opacity than original)\n  if (\n    elementsPendingErasure.has(element.id) ||\n    (pendingNodes && pendingNodes.some((node) => node.id === element.id)) ||\n    (containingFrame && elementsPendingErasure.has(containingFrame.id))\n  ) {\n    opacity *= ELEMENT_READY_TO_ERASE_OPACITY / 100;\n  }\n\n  return opacity;\n};\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  theme: AppState[\"theme\"];\n  scale: number;\n  angle: number;\n  zoomValue: AppState[\"zoom\"][\"value\"];\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n  boundTextElementVersion: number | null;\n  imageCrop: ExcalidrawImageElement[\"crop\"] | null;\n  containingFrameOpacity: number;\n  boundTextCanvas: HTMLCanvasElement;\n}\n\nconst cappedElementCanvasSize = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: ElementsMap,\n  zoom: Zoom,\n): {\n  width: number;\n  height: number;\n  scale: number;\n} => {\n  // these limits are ballpark, they depend on specific browsers and device.\n  // We've chosen lower limits to be safe. We might want to change these limits\n  // based on browser/device type, if we get reports of low quality rendering\n  // on zoom.\n  //\n  // ~ safari mobile canvas area limit\n  const AREA_LIMIT = 16777216;\n  // ~ safari width/height limit based on developer.mozilla.org.\n  const WIDTH_HEIGHT_LIMIT = 32767;\n\n  const padding = getCanvasPadding(element);\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n  const elementWidth =\n    isLinearElement(element) || isFreeDrawElement(element)\n      ? distance(x1, x2)\n      : element.width;\n  const elementHeight =\n    isLinearElement(element) || isFreeDrawElement(element)\n      ? distance(y1, y2)\n      : element.height;\n\n  let width = elementWidth * window.devicePixelRatio + padding * 2;\n  let height = elementHeight * window.devicePixelRatio + padding * 2;\n\n  let scale: number = zoom.value;\n\n  // rescale to ensure width and height is within limits\n  if (\n    width * scale > WIDTH_HEIGHT_LIMIT ||\n    height * scale > WIDTH_HEIGHT_LIMIT\n  ) {\n    scale = Math.min(WIDTH_HEIGHT_LIMIT / width, WIDTH_HEIGHT_LIMIT / height);\n  }\n\n  // rescale to ensure canvas area is within limits\n  if (width * height * scale * scale > AREA_LIMIT) {\n    scale = Math.sqrt(AREA_LIMIT / (width * height));\n  }\n\n  width = Math.floor(width * scale);\n  height = Math.floor(height * scale);\n\n  return { width, height, scale };\n};\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom: Zoom,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n): ExcalidrawElementWithCanvas | null => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n  const padding = getCanvasPadding(element);\n\n  const { width, height, scale } = cappedElementCanvasSize(\n    element,\n    elementsMap,\n    zoom,\n  );\n\n  if (!width || !height) {\n    return null;\n  }\n\n  canvas.width = width;\n  canvas.height = height;\n\n  let canvasOffsetX = -100;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);\n\n    canvasOffsetX =\n      element.x > x1\n        ? distance(element.x, x1) * window.devicePixelRatio * scale\n        : 0;\n\n    canvasOffsetY =\n      element.y > y1\n        ? distance(element.y, y1) * window.devicePixelRatio * scale\n        : 0;\n\n    context.translate(canvasOffsetX, canvasOffsetY);\n  }\n\n  context.save();\n  context.translate(padding * scale, padding * scale);\n  context.scale(\n    window.devicePixelRatio * scale,\n    window.devicePixelRatio * scale,\n  );\n\n  const rc = rough.canvas(canvas);\n\n  // in dark theme, revert the image color filter\n  if (shouldResetImageFilter(element, renderConfig, appState)) {\n    context.filter = IMAGE_INVERT_FILTER;\n  }\n\n  drawElementOnCanvas(element, rc, context, renderConfig, appState);\n\n  context.restore();\n\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n  const boundTextCanvas = document.createElement(\"canvas\");\n  const boundTextCanvasContext = boundTextCanvas.getContext(\"2d\")!;\n\n  if (isArrowElement(element) && boundTextElement) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    // Take max dimensions of arrow canvas so that when canvas is rotated\n    // the arrow doesn't get clipped\n    const maxDim = Math.max(distance(x1, x2), distance(y1, y2));\n    boundTextCanvas.width =\n      maxDim * window.devicePixelRatio * scale + padding * scale * 10;\n    boundTextCanvas.height =\n      maxDim * window.devicePixelRatio * scale + padding * scale * 10;\n    boundTextCanvasContext.translate(\n      boundTextCanvas.width / 2,\n      boundTextCanvas.height / 2,\n    );\n    boundTextCanvasContext.rotate(element.angle);\n    boundTextCanvasContext.drawImage(\n      canvas!,\n      -canvas.width / 2,\n      -canvas.height / 2,\n      canvas.width,\n      canvas.height,\n    );\n\n    const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(\n      boundTextElement,\n      elementsMap,\n    );\n\n    boundTextCanvasContext.rotate(-element.angle);\n    const offsetX = (boundTextCanvas.width - canvas!.width) / 2;\n    const offsetY = (boundTextCanvas.height - canvas!.height) / 2;\n    const shiftX =\n      boundTextCanvas.width / 2 -\n      (boundTextCx - x1) * window.devicePixelRatio * scale -\n      offsetX -\n      padding * scale;\n\n    const shiftY =\n      boundTextCanvas.height / 2 -\n      (boundTextCy - y1) * window.devicePixelRatio * scale -\n      offsetY -\n      padding * scale;\n    boundTextCanvasContext.translate(-shiftX, -shiftY);\n    // Clear the bound text area\n    boundTextCanvasContext.clearRect(\n      -(boundTextElement.width / 2 + BOUND_TEXT_PADDING) *\n        window.devicePixelRatio *\n        scale,\n      -(boundTextElement.height / 2 + BOUND_TEXT_PADDING) *\n        window.devicePixelRatio *\n        scale,\n      (boundTextElement.width + BOUND_TEXT_PADDING * 2) *\n        window.devicePixelRatio *\n        scale,\n      (boundTextElement.height + BOUND_TEXT_PADDING * 2) *\n        window.devicePixelRatio *\n        scale,\n    );\n  }\n\n  return {\n    element,\n    canvas,\n    theme: appState.theme,\n    scale,\n    zoomValue: zoom.value,\n    canvasOffsetX,\n    canvasOffsetY,\n    boundTextElementVersion:\n      getBoundTextElement(element, elementsMap)?.version || null,\n    containingFrameOpacity:\n      getContainingFrame(element, elementsMap)?.opacity || 100,\n    boundTextCanvas,\n    angle: element.angle,\n    imageCrop: isImageElement(element) ? element.crop : null,\n  };\n};\n\nexport const DEFAULT_LINK_SIZE = 14;\n\nconst IMAGE_PLACEHOLDER_IMG =\n  typeof document !== \"undefined\"\n    ? document.createElement(\"img\")\n    : ({ src: \"\" } as HTMLImageElement); // mock image element outside of browser\n\nIMAGE_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(\n  `<svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"image\" class=\"svg-inline--fa fa-image fa-w-16\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path fill=\"#888\" d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z\"></path></svg>`,\n)}`;\n\nconst IMAGE_ERROR_PLACEHOLDER_IMG =\n  typeof document !== \"undefined\"\n    ? document.createElement(\"img\")\n    : ({ src: \"\" } as HTMLImageElement); // mock image element outside of browser\n\nIMAGE_ERROR_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(\n  `<svg viewBox=\"0 0 668 668\" xmlns=\"http://www.w3.org/2000/svg\" xml:space=\"preserve\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2\"><path d=\"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.81709 0 0 .81709 124.825 145.825)\"/><path d=\"M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z\" style=\"fill:#888;fill-rule:nonzero\" transform=\"matrix(.30366 0 0 .30366 506.822 60.065)\"/></svg>`,\n)}`;\n\nconst drawImagePlaceholder = (\n  element: ExcalidrawImageElement,\n  context: CanvasRenderingContext2D,\n) => {\n  context.fillStyle = \"#E7E7E7\";\n  context.fillRect(0, 0, element.width, element.height);\n\n  const imageMinWidthOrHeight = Math.min(element.width, element.height);\n\n  const size = Math.min(\n    imageMinWidthOrHeight,\n    Math.min(imageMinWidthOrHeight * 0.4, 100),\n  );\n\n  context.drawImage(\n    element.status === \"error\"\n      ? IMAGE_ERROR_PLACEHOLDER_IMG\n      : IMAGE_PLACEHOLDER_IMG,\n    element.width / 2 - size / 2,\n    element.height / 2 - size / 2,\n    size,\n    size,\n  );\n};\n\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n) => {\n  switch (element.type) {\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"diamond\":\n    case \"ellipse\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n      rc.draw(ShapeCache.get(element)!);\n      break;\n    }\n    case \"arrow\":\n    case \"line\": {\n      context.lineJoin = \"round\";\n      context.lineCap = \"round\";\n\n      ShapeCache.get(element)!.forEach((shape) => {\n        rc.draw(shape);\n      });\n      break;\n    }\n    case \"freedraw\": {\n      // Draw directly to canvas\n      context.save();\n      context.fillStyle = element.strokeColor;\n\n      const path = getFreeDrawPath2D(element) as Path2D;\n      const fillShape = ShapeCache.get(element);\n\n      if (fillShape) {\n        rc.draw(fillShape);\n      }\n\n      context.fillStyle = element.strokeColor;\n      context.fill(path);\n\n      context.restore();\n      break;\n    }\n    case \"image\": {\n      const img = isInitializedImageElement(element)\n        ? renderConfig.imageCache.get(element.fileId)?.image\n        : undefined;\n      if (img != null && !(img instanceof Promise)) {\n        if (element.roundness && context.roundRect) {\n          context.beginPath();\n          context.roundRect(\n            0,\n            0,\n            element.width,\n            element.height,\n            getCornerRadius(Math.min(element.width, element.height), element),\n          );\n          context.clip();\n        }\n\n        const { x, y, width, height } = element.crop\n          ? element.crop\n          : {\n              x: 0,\n              y: 0,\n              width: img.naturalWidth,\n              height: img.naturalHeight,\n            };\n\n        context.drawImage(\n          img,\n          x,\n          y,\n          width,\n          height,\n          0 /* hardcoded for the selection box*/,\n          0,\n          element.width,\n          element.height,\n        );\n      } else {\n        drawImagePlaceholder(element, context);\n      }\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          // to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        context.save();\n        context.font = getFontString(element);\n        context.fillStyle = element.strokeColor;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n\n        const lineHeightPx = getLineHeightInPx(\n          element.fontSize,\n          element.lineHeight,\n        );\n\n        const verticalOffset = getVerticalOffset(\n          element.fontFamily,\n          element.fontSize,\n          lineHeightPx,\n        );\n\n        for (let index = 0; index < lines.length; index++) {\n          context.fillText(\n            lines[index],\n            horizontalOffset,\n            index * lineHeightPx + verticalOffset,\n          );\n        }\n        context.restore();\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n\nexport const elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: NonDeletedSceneElementsMap,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n) => {\n  const zoom: Zoom = renderConfig\n    ? appState.zoom\n    : {\n        value: 1 as NormalizedZoomValue,\n      };\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.zoomValue !== zoom.value &&\n    !appState?.shouldCacheIgnoreZoom;\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n  const boundTextElementVersion = boundTextElement?.version || null;\n  const imageCrop = isImageElement(element) ? element.crop : null;\n\n  const containingFrameOpacity =\n    getContainingFrame(element, elementsMap)?.opacity || 100;\n\n  if (\n    !prevElementWithCanvas ||\n    shouldRegenerateBecauseZoom ||\n    prevElementWithCanvas.theme !== appState.theme ||\n    prevElementWithCanvas.boundTextElementVersion !== boundTextElementVersion ||\n    prevElementWithCanvas.imageCrop !== imageCrop ||\n    prevElementWithCanvas.containingFrameOpacity !== containingFrameOpacity ||\n    // since we rotate the canvas when copying from cached canvas, we don't\n    // regenerate the cached canvas. But we need to in case of labels which are\n    // cached alongside the arrow, and we want the labels to remain unrotated\n    // with respect to the arrow.\n    (isArrowElement(element) &&\n      boundTextElement &&\n      element.angle !== prevElementWithCanvas.angle)\n  ) {\n    const elementWithCanvas = generateElementCanvas(\n      element,\n      elementsMap,\n      zoom,\n      renderConfig,\n      appState,\n    );\n\n    if (!elementWithCanvas) {\n      return null;\n    }\n\n    elementWithCanvasCache.set(element, elementWithCanvas);\n\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n  allElementsMap: NonDeletedSceneElementsMap,\n) => {\n  const element = elementWithCanvas.element;\n  const padding = getCanvasPadding(element);\n  const zoom = elementWithCanvas.scale;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, allElementsMap);\n  const cx = ((x1 + x2) / 2 + appState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + appState.scrollY) * window.devicePixelRatio;\n\n  context.save();\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n\n  const boundTextElement = getBoundTextElement(element, allElementsMap);\n\n  if (isArrowElement(element) && boundTextElement) {\n    const offsetX =\n      (elementWithCanvas.boundTextCanvas.width -\n        elementWithCanvas.canvas!.width) /\n      2;\n    const offsetY =\n      (elementWithCanvas.boundTextCanvas.height -\n        elementWithCanvas.canvas!.height) /\n      2;\n    context.translate(cx, cy);\n    context.drawImage(\n      elementWithCanvas.boundTextCanvas,\n      (-(x2 - x1) / 2) * window.devicePixelRatio - offsetX / zoom - padding,\n      (-(y2 - y1) / 2) * window.devicePixelRatio - offsetY / zoom - padding,\n      elementWithCanvas.boundTextCanvas.width / zoom,\n      elementWithCanvas.boundTextCanvas.height / zoom,\n    );\n  } else {\n    // we translate context to element center so that rotation and scale\n    // originates from the element center\n    context.translate(cx, cy);\n\n    context.rotate(element.angle);\n\n    if (\n      \"scale\" in elementWithCanvas.element &&\n      !isPendingImageElement(element, renderConfig)\n    ) {\n      context.scale(\n        elementWithCanvas.element.scale[0],\n        elementWithCanvas.element.scale[1],\n      );\n    }\n\n    // revert afterwards we don't have account for it during drawing\n    context.translate(-cx, -cy);\n\n    context.drawImage(\n      elementWithCanvas.canvas!,\n      (x1 + appState.scrollX) * window.devicePixelRatio -\n        (padding * elementWithCanvas.scale) / elementWithCanvas.scale,\n      (y1 + appState.scrollY) * window.devicePixelRatio -\n        (padding * elementWithCanvas.scale) / elementWithCanvas.scale,\n      elementWithCanvas.canvas!.width / elementWithCanvas.scale,\n      elementWithCanvas.canvas!.height / elementWithCanvas.scale,\n    );\n\n    if (\n      import.meta.env.VITE_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX ===\n        \"true\" &&\n      hasBoundTextElement(element)\n    ) {\n      const textElement = getBoundTextElement(\n        element,\n        allElementsMap,\n      ) as ExcalidrawTextElementWithContainer;\n      const coords = getContainerCoords(element);\n      context.strokeStyle = \"#c92a2a\";\n      context.lineWidth = 3;\n      context.strokeRect(\n        (coords.x + appState.scrollX) * window.devicePixelRatio,\n        (coords.y + appState.scrollY) * window.devicePixelRatio,\n        getBoundTextMaxWidth(element, textElement) * window.devicePixelRatio,\n        getBoundTextMaxHeight(element, textElement) * window.devicePixelRatio,\n      );\n    }\n  }\n  context.restore();\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderSelectionElement = (\n  element: NonDeletedExcalidrawElement,\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  selectionColor: InteractiveCanvasRenderConfig[\"selectionColor\"],\n) => {\n  context.save();\n  context.translate(element.x + appState.scrollX, element.y + appState.scrollY);\n  context.fillStyle = \"rgba(0, 0, 200, 0.04)\";\n\n  // render from 0.5px offset  to get 1px wide line\n  // https://stackoverflow.com/questions/7530593/html5-canvas-and-line-width/7531540#7531540\n  // TODO can be be improved by offseting to the negative when user selects\n  // from right to left\n  const offset = 0.5 / appState.zoom.value;\n\n  context.fillRect(offset, offset, element.width, element.height);\n  context.lineWidth = 1 / appState.zoom.value;\n  context.strokeStyle = selectionColor;\n  context.strokeRect(offset, offset, element.width, element.height);\n\n  context.restore();\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  elementsMap: RenderableElementsMap,\n  allElementsMap: NonDeletedSceneElementsMap,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderConfig: StaticCanvasRenderConfig,\n  appState: StaticCanvasAppState,\n) => {\n  const reduceAlphaForSelection =\n    appState.openDialog?.name === \"elementLinkSelector\" &&\n    !appState.selectedElementIds[element.id] &&\n    !appState.hoveredElementIds[element.id];\n\n  context.globalAlpha = getRenderOpacity(\n    element,\n    getContainingFrame(element, elementsMap),\n    renderConfig.elementsPendingErasure,\n    renderConfig.pendingFlowchartNodes,\n    reduceAlphaForSelection ? DEFAULT_REDUCED_GLOBAL_ALPHA : 1,\n  );\n\n  switch (element.type) {\n    case \"magicframe\":\n    case \"frame\": {\n      if (appState.frameRendering.enabled && appState.frameRendering.outline) {\n        context.save();\n        context.translate(\n          element.x + appState.scrollX,\n          element.y + appState.scrollY,\n        );\n        context.fillStyle = \"rgba(0, 0, 200, 0.04)\";\n\n        context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;\n        context.strokeStyle = FRAME_STYLE.strokeColor;\n\n        // TODO change later to only affect AI frames\n        if (isMagicFrameElement(element)) {\n          context.strokeStyle =\n            appState.theme === THEME.LIGHT ? \"#7affd7\" : \"#1d8264\";\n        }\n\n        if (FRAME_STYLE.radius && context.roundRect) {\n          context.beginPath();\n          context.roundRect(\n            0,\n            0,\n            element.width,\n            element.height,\n            FRAME_STYLE.radius / appState.zoom.value,\n          );\n          context.stroke();\n          context.closePath();\n        } else {\n          context.strokeRect(0, 0, element.width, element.height);\n        }\n\n        context.restore();\n      }\n      break;\n    }\n    case \"freedraw\": {\n      // TODO investigate if we can do this in situ. Right now we need to call\n      // beforehand because math helpers (such as getElementAbsoluteCoords)\n      // rely on existing shapes\n      ShapeCache.generateElementShape(element, null);\n\n      if (renderConfig.isExporting) {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n        const cx = (x1 + x2) / 2 + appState.scrollX;\n        const cy = (y1 + y2) / 2 + appState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.save();\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context, renderConfig, appState);\n        context.restore();\n      } else {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          allElementsMap,\n          renderConfig,\n          appState,\n        );\n        if (!elementWithCanvas) {\n          return;\n        }\n\n        drawElementFromCanvas(\n          elementWithCanvas,\n          context,\n          renderConfig,\n          appState,\n          allElementsMap,\n        );\n      }\n\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"image\":\n    case \"text\":\n    case \"iframe\":\n    case \"embeddable\": {\n      // TODO investigate if we can do this in situ. Right now we need to call\n      // beforehand because math helpers (such as getElementAbsoluteCoords)\n      // rely on existing shapes\n      ShapeCache.generateElementShape(element, renderConfig);\n      if (renderConfig.isExporting) {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n        const cx = (x1 + x2) / 2 + appState.scrollX;\n        const cy = (y1 + y2) / 2 + appState.scrollY;\n        let shiftX = (x2 - x1) / 2 - (element.x - x1);\n        let shiftY = (y2 - y1) / 2 - (element.y - y1);\n        if (isTextElement(element)) {\n          const container = getContainerElement(element, elementsMap);\n          if (isArrowElement(container)) {\n            const boundTextCoords =\n              LinearElementEditor.getBoundTextElementPosition(\n                container,\n                element as ExcalidrawTextElementWithContainer,\n                elementsMap,\n              );\n            shiftX = (x2 - x1) / 2 - (boundTextCoords.x - x1);\n            shiftY = (y2 - y1) / 2 - (boundTextCoords.y - y1);\n          }\n        }\n        context.save();\n        context.translate(cx, cy);\n\n        if (shouldResetImageFilter(element, renderConfig, appState)) {\n          context.filter = \"none\";\n        }\n        const boundTextElement = getBoundTextElement(element, elementsMap);\n\n        if (isArrowElement(element) && boundTextElement) {\n          const tempCanvas = document.createElement(\"canvas\");\n\n          const tempCanvasContext = tempCanvas.getContext(\"2d\")!;\n\n          // Take max dimensions of arrow canvas so that when canvas is rotated\n          // the arrow doesn't get clipped\n          const maxDim = Math.max(distance(x1, x2), distance(y1, y2));\n          const padding = getCanvasPadding(element);\n          tempCanvas.width =\n            maxDim * appState.exportScale + padding * 10 * appState.exportScale;\n          tempCanvas.height =\n            maxDim * appState.exportScale + padding * 10 * appState.exportScale;\n\n          tempCanvasContext.translate(\n            tempCanvas.width / 2,\n            tempCanvas.height / 2,\n          );\n          tempCanvasContext.scale(appState.exportScale, appState.exportScale);\n\n          // Shift the canvas to left most point of the arrow\n          shiftX = element.width / 2 - (element.x - x1);\n          shiftY = element.height / 2 - (element.y - y1);\n\n          tempCanvasContext.rotate(element.angle);\n          const tempRc = rough.canvas(tempCanvas);\n\n          tempCanvasContext.translate(-shiftX, -shiftY);\n\n          drawElementOnCanvas(\n            element,\n            tempRc,\n            tempCanvasContext,\n            renderConfig,\n            appState,\n          );\n\n          tempCanvasContext.translate(shiftX, shiftY);\n\n          tempCanvasContext.rotate(-element.angle);\n\n          // Shift the canvas to center of bound text\n          const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(\n            boundTextElement,\n            elementsMap,\n          );\n          const boundTextShiftX = (x1 + x2) / 2 - boundTextCx;\n          const boundTextShiftY = (y1 + y2) / 2 - boundTextCy;\n          tempCanvasContext.translate(-boundTextShiftX, -boundTextShiftY);\n\n          // Clear the bound text area\n          tempCanvasContext.clearRect(\n            -boundTextElement.width / 2,\n            -boundTextElement.height / 2,\n            boundTextElement.width,\n            boundTextElement.height,\n          );\n          context.scale(1 / appState.exportScale, 1 / appState.exportScale);\n          context.drawImage(\n            tempCanvas,\n            -tempCanvas.width / 2,\n            -tempCanvas.height / 2,\n            tempCanvas.width,\n            tempCanvas.height,\n          );\n        } else {\n          context.rotate(element.angle);\n\n          if (element.type === \"image\") {\n            // note: scale must be applied *after* rotating\n            context.scale(element.scale[0], element.scale[1]);\n          }\n\n          context.translate(-shiftX, -shiftY);\n          drawElementOnCanvas(element, rc, context, renderConfig, appState);\n        }\n\n        context.restore();\n        // not exporting → optimized rendering (cache & render from element\n        // canvases)\n      } else {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          allElementsMap,\n          renderConfig,\n          appState,\n        );\n\n        if (!elementWithCanvas) {\n          return;\n        }\n\n        const currentImageSmoothingStatus = context.imageSmoothingEnabled;\n\n        if (\n          // do not disable smoothing during zoom as blurry shapes look better\n          // on low resolution (while still zooming in) than sharp ones\n          !appState?.shouldCacheIgnoreZoom &&\n          // angle is 0 -> always disable smoothing\n          (!element.angle ||\n            // or check if angle is a right angle in which case we can still\n            // disable smoothing without adversely affecting the result\n            // We need less-than comparison because of FP artihmetic\n            isRightAngleRads(element.angle))\n        ) {\n          // Disabling smoothing makes output much sharper, especially for\n          // text. Unless for non-right angles, where the aliasing is really\n          // terrible on Chromium.\n          //\n          // Note that `context.imageSmoothingQuality=\"high\"` has almost\n          // zero effect.\n          //\n          context.imageSmoothingEnabled = false;\n        }\n\n        if (\n          element.id === appState.croppingElementId &&\n          isImageElement(elementWithCanvas.element) &&\n          elementWithCanvas.element.crop !== null\n        ) {\n          context.save();\n          context.globalAlpha = 0.1;\n\n          const uncroppedElementCanvas = generateElementCanvas(\n            getUncroppedImageElement(elementWithCanvas.element, elementsMap),\n            allElementsMap,\n            appState.zoom,\n            renderConfig,\n            appState,\n          );\n\n          if (uncroppedElementCanvas) {\n            drawElementFromCanvas(\n              uncroppedElementCanvas,\n              context,\n              renderConfig,\n              appState,\n              allElementsMap,\n            );\n          }\n\n          context.restore();\n        }\n\n        drawElementFromCanvas(\n          elementWithCanvas,\n          context,\n          renderConfig,\n          appState,\n          allElementsMap,\n        );\n\n        // reset\n        context.imageSmoothingEnabled = currentImageSmoothingStatus;\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n\n  context.globalAlpha = 1;\n};\n\nexport const pathsCache = new WeakMap<ExcalidrawFreeDrawElement, Path2D>([]);\n\nexport function generateFreeDrawShape(element: ExcalidrawFreeDrawElement) {\n  const svgPathData = getFreeDrawSvgPath(element);\n  const path = new Path2D(svgPathData);\n  pathsCache.set(element, path);\n  return path;\n}\n\nexport function getFreeDrawPath2D(element: ExcalidrawFreeDrawElement) {\n  return pathsCache.get(element);\n}\n\nexport function getFreeDrawSvgPath(element: ExcalidrawFreeDrawElement) {\n  // If input points are empty (should they ever be?) return a dot\n  const inputPoints = element.simulatePressure\n    ? element.points\n    : element.points.length\n    ? element.points.map(([x, y], i) => [x, y, element.pressures[i]])\n    : [[0, 0, 0.5]];\n\n  // Consider changing the options for simulated pressure vs real pressure\n  const options: StrokeOptions = {\n    simulatePressure: element.simulatePressure,\n    size: element.strokeWidth * 4.25,\n    thinning: 0.6,\n    smoothing: 0.5,\n    streamline: 0.5,\n    easing: (t) => Math.sin((t * Math.PI) / 2), // https://easings.net/#easeOutSine\n    last: !!element.lastCommittedPoint, // LastCommittedPoint is added on pointerup\n  };\n\n  return getSvgPathFromStroke(getStroke(inputPoints as number[][], options));\n}\n\nfunction med(A: number[], B: number[]) {\n  return [(A[0] + B[0]) / 2, (A[1] + B[1]) / 2];\n}\n\n// Trim SVG path data so number are each two decimal points. This\n// improves SVG exports, and prevents rendering errors on points\n// with long decimals.\nconst TO_FIXED_PRECISION = /(\\s?[A-Z]?,?-?[0-9]*\\.[0-9]{0,2})(([0-9]|e|-)*)/g;\n\nfunction getSvgPathFromStroke(points: number[][]): string {\n  if (!points.length) {\n    return \"\";\n  }\n\n  const max = points.length - 1;\n\n  return points\n    .reduce(\n      (acc, point, i, arr) => {\n        if (i === max) {\n          acc.push(point, med(point, arr[0]), \"L\", arr[0], \"Z\");\n        } else {\n          acc.push(point, med(point, arr[i + 1]));\n        }\n        return acc;\n      },\n      [\"M\", points[0], \"Q\"],\n    )\n    .join(\" \")\n    .replace(TO_FIXED_PRECISION, \"$1\");\n}\n",
    "import rough from \"roughjs/bin/rough\";\n\nimport {\n  arrayToMap,\n  invariant,\n  rescalePoints,\n  sizeOf,\n} from \"@excalidraw/common\";\n\nimport {\n  degreesToRadians,\n  lineSegment,\n  pointDistance,\n  pointFrom,\n  pointFromArray,\n  pointRotateRads,\n} from \"@excalidraw/math\";\n\nimport { getCurvePathOps } from \"@excalidraw/utils/shape\";\n\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport type {\n  Curve,\n  Degrees,\n  GlobalPoint,\n  LineSegment,\n  LocalPoint,\n  Radians,\n} from \"@excalidraw/math\";\n\nimport type { AppState } from \"excalidraw-custom/types\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport { generateRoughOptions } from \"./shape\";\nimport { ShapeCache } from \"./shape\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\nimport {\n  isArrowElement,\n  isBoundToContainer,\n  isFreeDrawElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport { getElementShape } from \"./shape\";\n\nimport {\n  deconstructDiamondElement,\n  deconstructRectanguloidElement,\n} from \"./utils\";\n\nimport type { Drawable, Op } from \"roughjs/bin/core\";\nimport type { Point as RoughPoint } from \"roughjs/bin/geometry\";\nimport type {\n  Arrowhead,\n  ElementsMap,\n  ElementsMapOrArray,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n  ExcalidrawTextElementWithContainer,\n  NonDeleted,\n} from \"./types\";\n\nexport type RectangleBox = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  angle: number;\n};\n\ntype MaybeQuadraticSolution = [number | null, number | null] | false;\n\n/**\n * x and y position of top left corner, x and y position of bottom right corner\n */\nexport type Bounds = readonly [\n  minX: number,\n  minY: number,\n  maxX: number,\n  maxY: number,\n];\n\nexport type SceneBounds = readonly [\n  sceneX: number,\n  sceneY: number,\n  sceneX2: number,\n  sceneY2: number,\n];\n\nexport class ElementBounds {\n  private static boundsCache = new WeakMap<\n    ExcalidrawElement,\n    {\n      bounds: Bounds;\n      version: ExcalidrawElement[\"version\"];\n    }\n  >();\n  private static nonRotatedBoundsCache = new WeakMap<\n    ExcalidrawElement,\n    {\n      bounds: Bounds;\n      version: ExcalidrawElement[\"version\"];\n    }\n  >();\n\n  static getBounds(\n    element: ExcalidrawElement,\n    elementsMap: ElementsMap,\n    nonRotated: boolean = false,\n  ) {\n    const cachedBounds =\n      nonRotated && element.angle !== 0\n        ? ElementBounds.nonRotatedBoundsCache.get(element)\n        : ElementBounds.boundsCache.get(element);\n\n    if (\n      cachedBounds?.version &&\n      cachedBounds.version === element.version &&\n      // we don't invalidate cache when we update containers and not labels,\n      // which is causing problems down the line. Fix TBA.\n      !isBoundToContainer(element)\n    ) {\n      return cachedBounds.bounds;\n    }\n\n    if (nonRotated && element.angle !== 0) {\n      const nonRotatedBounds = ElementBounds.calculateBounds(\n        {\n          ...element,\n          angle: 0 as Radians,\n        },\n        elementsMap,\n      );\n      ElementBounds.nonRotatedBoundsCache.set(element, {\n        version: element.version,\n        bounds: nonRotatedBounds,\n      });\n\n      return nonRotatedBounds;\n    }\n\n    const bounds = ElementBounds.calculateBounds(element, elementsMap);\n\n    ElementBounds.boundsCache.set(element, {\n      version: element.version,\n      bounds,\n    });\n\n    return bounds;\n  }\n\n  private static calculateBounds(\n    element: ExcalidrawElement,\n    elementsMap: ElementsMap,\n  ): Bounds {\n    let bounds: Bounds;\n\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n      element,\n      elementsMap,\n    );\n    if (isFreeDrawElement(element)) {\n      const [minX, minY, maxX, maxY] = getBoundsFromPoints(\n        element.points.map(([x, y]) =>\n          pointRotateRads(\n            pointFrom(x, y),\n            pointFrom(cx - element.x, cy - element.y),\n            element.angle,\n          ),\n        ),\n      );\n\n      return [\n        minX + element.x,\n        minY + element.y,\n        maxX + element.x,\n        maxY + element.y,\n      ];\n    } else if (isLinearElement(element)) {\n      bounds = getLinearElementRotatedBounds(element, cx, cy, elementsMap);\n    } else if (element.type === \"diamond\") {\n      const [x11, y11] = pointRotateRads(\n        pointFrom(cx, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x12, y12] = pointRotateRads(\n        pointFrom(cx, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x22, y22] = pointRotateRads(\n        pointFrom(x1, cy),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x21, y21] = pointRotateRads(\n        pointFrom(x2, cy),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    } else if (element.type === \"ellipse\") {\n      const w = (x2 - x1) / 2;\n      const h = (y2 - y1) / 2;\n      const cos = Math.cos(element.angle);\n      const sin = Math.sin(element.angle);\n      const ww = Math.hypot(w * cos, h * sin);\n      const hh = Math.hypot(h * cos, w * sin);\n      bounds = [cx - ww, cy - hh, cx + ww, cy + hh];\n    } else {\n      const [x11, y11] = pointRotateRads(\n        pointFrom(x1, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x12, y12] = pointRotateRads(\n        pointFrom(x1, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x22, y22] = pointRotateRads(\n        pointFrom(x2, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const [x21, y21] = pointRotateRads(\n        pointFrom(x2, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const minX = Math.min(x11, x12, x22, x21);\n      const minY = Math.min(y11, y12, y22, y21);\n      const maxX = Math.max(x11, x12, x22, x21);\n      const maxY = Math.max(y11, y12, y22, y21);\n      bounds = [minX, minY, maxX, maxY];\n    }\n\n    return bounds;\n  }\n}\n\n// Scene -> Scene coords, but in x1,x2,y1,y2 format.\n//\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  includeBoundText: boolean = false,\n): [number, number, number, number, number, number] => {\n  if (isFreeDrawElement(element)) {\n    return getFreeDrawElementAbsoluteCoords(element);\n  } else if (isLinearElement(element)) {\n    return LinearElementEditor.getElementAbsoluteCoords(\n      element,\n      elementsMap,\n      includeBoundText,\n    );\n  } else if (isTextElement(element)) {\n    const container = elementsMap\n      ? getContainerElement(element, elementsMap)\n      : null;\n    if (isArrowElement(container)) {\n      const { x, y } = LinearElementEditor.getBoundTextElementPosition(\n        container,\n        element as ExcalidrawTextElementWithContainer,\n        elementsMap,\n      );\n      return [\n        x,\n        y,\n        x + element.width,\n        y + element.height,\n        x + element.width / 2,\n        y + element.height / 2,\n      ];\n    }\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n    element.x + element.width / 2,\n    element.y + element.height / 2,\n  ];\n};\n\n/*\n * for a given element, `getElementLineSegments` returns line segments\n * that can be used for visual collision detection (useful for frames)\n * as opposed to bounding box collision detection\n */\n/**\n * Given an element, return the line segments that make up the element.\n *\n * Uses helpers from /math\n */\nexport const getElementLineSegments = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): LineSegment<GlobalPoint>[] => {\n  const shape = getElementShape(element, elementsMap);\n  const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n    element,\n    elementsMap,\n  );\n  const center = pointFrom<GlobalPoint>(cx, cy);\n\n  if (shape.type === \"polycurve\") {\n    const curves = shape.data;\n    const points = curves\n      .map((curve) => pointsOnBezierCurves(curve, 10))\n      .flat();\n    let i = 0;\n    const segments: LineSegment<GlobalPoint>[] = [];\n    while (i < points.length - 1) {\n      segments.push(\n        lineSegment(\n          pointFrom(points[i][0], points[i][1]),\n          pointFrom(points[i + 1][0], points[i + 1][1]),\n        ),\n      );\n      i++;\n    }\n\n    return segments;\n  } else if (shape.type === \"polyline\") {\n    return shape.data as LineSegment<GlobalPoint>[];\n  } else if (_isRectanguloidElement(element)) {\n    const [sides, corners] = deconstructRectanguloidElement(element);\n    const cornerSegments: LineSegment<GlobalPoint>[] = corners\n      .map((corner) => getSegmentsOnCurve(corner, center, element.angle))\n      .flat();\n    const rotatedSides = getRotatedSides(sides, center, element.angle);\n    return [...rotatedSides, ...cornerSegments];\n  } else if (element.type === \"diamond\") {\n    const [sides, corners] = deconstructDiamondElement(element);\n    const cornerSegments = corners\n      .map((corner) => getSegmentsOnCurve(corner, center, element.angle))\n      .flat();\n    const rotatedSides = getRotatedSides(sides, center, element.angle);\n\n    return [...rotatedSides, ...cornerSegments];\n  } else if (shape.type === \"polygon\") {\n    if (isTextElement(element)) {\n      const container = getContainerElement(element, elementsMap);\n      if (container && isLinearElement(container)) {\n        const segments: LineSegment<GlobalPoint>[] = [\n          lineSegment(pointFrom(x1, y1), pointFrom(x2, y1)),\n          lineSegment(pointFrom(x2, y1), pointFrom(x2, y2)),\n          lineSegment(pointFrom(x2, y2), pointFrom(x1, y2)),\n          lineSegment(pointFrom(x1, y2), pointFrom(x1, y1)),\n        ];\n        return segments;\n      }\n    }\n\n    const points = shape.data as GlobalPoint[];\n    const segments: LineSegment<GlobalPoint>[] = [];\n    for (let i = 0; i < points.length - 1; i++) {\n      segments.push(lineSegment(points[i], points[i + 1]));\n    }\n    return segments;\n  } else if (shape.type === \"ellipse\") {\n    return getSegmentsOnEllipse(element as ExcalidrawEllipseElement);\n  }\n\n  const [nw, ne, sw, se, , , w, e] = (\n    [\n      [x1, y1],\n      [x2, y1],\n      [x1, y2],\n      [x2, y2],\n      [cx, y1],\n      [cx, y2],\n      [x1, cy],\n      [x2, cy],\n    ] as GlobalPoint[]\n  ).map((point) => pointRotateRads(point, center, element.angle));\n\n  return [\n    lineSegment(nw, ne),\n    lineSegment(sw, se),\n    lineSegment(nw, sw),\n    lineSegment(ne, se),\n    lineSegment(nw, e),\n    lineSegment(sw, e),\n    lineSegment(ne, w),\n    lineSegment(se, w),\n  ];\n};\n\nconst _isRectanguloidElement = (\n  element: ExcalidrawElement,\n): element is ExcalidrawRectanguloidElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"image\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      (element.type === \"text\" && !element.containerId))\n  );\n};\n\nconst getRotatedSides = (\n  sides: LineSegment<GlobalPoint>[],\n  center: GlobalPoint,\n  angle: Radians,\n) => {\n  return sides.map((side) => {\n    return lineSegment(\n      pointRotateRads<GlobalPoint>(side[0], center, angle),\n      pointRotateRads<GlobalPoint>(side[1], center, angle),\n    );\n  });\n};\n\nconst getSegmentsOnCurve = (\n  curve: Curve<GlobalPoint>,\n  center: GlobalPoint,\n  angle: Radians,\n): LineSegment<GlobalPoint>[] => {\n  const points = pointsOnBezierCurves(curve, 10);\n  let i = 0;\n  const segments: LineSegment<GlobalPoint>[] = [];\n  while (i < points.length - 1) {\n    segments.push(\n      lineSegment(\n        pointRotateRads<GlobalPoint>(\n          pointFrom(points[i][0], points[i][1]),\n          center,\n          angle,\n        ),\n        pointRotateRads<GlobalPoint>(\n          pointFrom(points[i + 1][0], points[i + 1][1]),\n          center,\n          angle,\n        ),\n      ),\n    );\n    i++;\n  }\n\n  return segments;\n};\n\nconst getSegmentsOnEllipse = (\n  ellipse: ExcalidrawEllipseElement,\n): LineSegment<GlobalPoint>[] => {\n  const center = pointFrom<GlobalPoint>(\n    ellipse.x + ellipse.width / 2,\n    ellipse.y + ellipse.height / 2,\n  );\n\n  const a = ellipse.width / 2;\n  const b = ellipse.height / 2;\n\n  const segments: LineSegment<GlobalPoint>[] = [];\n  const points: GlobalPoint[] = [];\n  const n = 90;\n  const deltaT = (Math.PI * 2) / n;\n\n  for (let i = 0; i < n; i++) {\n    const t = i * deltaT;\n    const x = center[0] + a * Math.cos(t);\n    const y = center[1] + b * Math.sin(t);\n    points.push(pointRotateRads(pointFrom(x, y), center, ellipse.angle));\n  }\n\n  for (let i = 0; i < points.length - 1; i++) {\n    segments.push(lineSegment(points[i], points[i + 1]));\n  }\n\n  segments.push(lineSegment(points[points.length - 1], points[0]));\n  return segments;\n};\n\n/**\n * Scene -> Scene coords, but in x1,x2,y1,y2 format.\n *\n * Rectangle here means any rectangular frame, not an excalidraw element.\n */\nexport const getRectangleBoxAbsoluteCoords = (boxSceneCoords: RectangleBox) => {\n  return [\n    boxSceneCoords.x,\n    boxSceneCoords.y,\n    boxSceneCoords.x + boxSceneCoords.width,\n    boxSceneCoords.y + boxSceneCoords.height,\n    boxSceneCoords.x + boxSceneCoords.width / 2,\n    boxSceneCoords.y + boxSceneCoords.height / 2,\n  ];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = 0;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\n// reference: https://eliot-jones.com/2019/12/cubic-bezier-curve-bounding-boxes\nconst getBezierValueForT = (\n  t: number,\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n) => {\n  const oneMinusT = 1 - t;\n  return (\n    Math.pow(oneMinusT, 3) * p0 +\n    3 * Math.pow(oneMinusT, 2) * t * p1 +\n    3 * oneMinusT * Math.pow(t, 2) * p2 +\n    Math.pow(t, 3) * p3\n  );\n};\n\nconst solveQuadratic = (\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n): MaybeQuadraticSolution => {\n  const i = p1 - p0;\n  const j = p2 - p1;\n  const k = p3 - p2;\n\n  const a = 3 * i - 6 * j + 3 * k;\n  const b = 6 * j - 6 * i;\n  const c = 3 * i;\n\n  const sqrtPart = b * b - 4 * a * c;\n  const hasSolution = sqrtPart >= 0;\n\n  if (!hasSolution) {\n    return false;\n  }\n\n  let s1 = null;\n  let s2 = null;\n\n  let t1 = Infinity;\n  let t2 = Infinity;\n\n  if (a === 0) {\n    t1 = t2 = -c / b;\n  } else {\n    t1 = (-b + Math.sqrt(sqrtPart)) / (2 * a);\n    t2 = (-b - Math.sqrt(sqrtPart)) / (2 * a);\n  }\n\n  if (t1 >= 0 && t1 <= 1) {\n    s1 = getBezierValueForT(t1, p0, p1, p2, p3);\n  }\n\n  if (t2 >= 0 && t2 <= 1) {\n    s2 = getBezierValueForT(t2, p0, p1, p2, p3);\n  }\n\n  return [s1, s2];\n};\n\nexport const getCubicBezierCurveBound = (\n  p0: GlobalPoint,\n  p1: GlobalPoint,\n  p2: GlobalPoint,\n  p3: GlobalPoint,\n): Bounds => {\n  const solX = solveQuadratic(p0[0], p1[0], p2[0], p3[0]);\n  const solY = solveQuadratic(p0[1], p1[1], p2[1], p3[1]);\n\n  let minX = Math.min(p0[0], p3[0]);\n  let maxX = Math.max(p0[0], p3[0]);\n\n  if (solX) {\n    const xs = solX.filter((x) => x !== null) as number[];\n    minX = Math.min(minX, ...xs);\n    maxX = Math.max(maxX, ...xs);\n  }\n\n  let minY = Math.min(p0[1], p3[1]);\n  let maxY = Math.max(p0[1], p3[1]);\n  if (solY) {\n    const ys = solY.filter((y) => y !== null) as number[];\n    minY = Math.min(minY, ...ys);\n    maxY = Math.max(maxY, ...ys);\n  }\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (p: GlobalPoint) => GlobalPoint,\n): Bounds => {\n  let currentP: GlobalPoint = pointFrom(0, 0);\n\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        const p: GlobalPoint | undefined = pointFromArray(data);\n        invariant(p != null, \"Op data is not a point\");\n        currentP = p;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        const _p1 = pointFrom<GlobalPoint>(data[0], data[1]);\n        const _p2 = pointFrom<GlobalPoint>(data[2], data[3]);\n        const _p3 = pointFrom<GlobalPoint>(data[4], data[5]);\n\n        const p1 = transformXY ? transformXY(_p1) : _p1;\n        const p2 = transformXY ? transformXY(_p2) : _p2;\n        const p3 = transformXY ? transformXY(_p3) : _p3;\n\n        const p0 = transformXY ? transformXY(currentP) : currentP;\n        currentP = _p3;\n\n        const [minX, minY, maxX, maxY] = getCubicBezierCurveBound(\n          p0,\n          p1,\n          p2,\n          p3,\n        );\n\n        limits.minX = Math.min(limits.minX, minX);\n        limits.minY = Math.min(limits.minY, minY);\n\n        limits.maxX = Math.max(limits.maxX, maxX);\n        limits.maxY = Math.max(limits.maxY, maxY);\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getBoundsFromPoints = (\n  points: ExcalidrawFreeDrawElement[\"points\"],\n): Bounds => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const [x, y] of points) {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getFreeDrawElementAbsoluteCoords = (\n  element: ExcalidrawFreeDrawElement,\n): [number, number, number, number, number, number] => {\n  const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);\n  const x1 = minX + element.x;\n  const y1 = minY + element.y;\n  const x2 = maxX + element.x;\n  const y2 = maxY + element.y;\n  return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];\n};\n\n/** @returns number in pixels */\nexport const getArrowheadSize = (arrowhead: Arrowhead): number => {\n  switch (arrowhead) {\n    case \"arrow\":\n      return 25;\n    case \"diamond\":\n    case \"diamond_outline\":\n      return 12;\n    case \"crowfoot_many\":\n    case \"crowfoot_one\":\n    case \"crowfoot_one_or_many\":\n      return 20;\n    default:\n      return 15;\n  }\n};\n\n/** @returns number in degrees */\nexport const getArrowheadAngle = (arrowhead: Arrowhead): Degrees => {\n  switch (arrowhead) {\n    case \"bar\":\n      return 90 as Degrees;\n    case \"arrow\":\n      return 20 as Degrees;\n    default:\n      return 25 as Degrees;\n  }\n};\n\nexport const getArrowheadPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n  position: \"start\" | \"end\",\n  arrowhead: Arrowhead,\n) => {\n  if (shape.length < 1) {\n    return null;\n  }\n\n  const ops = getCurvePathOps(shape[0]);\n  if (ops.length < 1) {\n    return null;\n  }\n\n  // The index of the bCurve operation to examine.\n  const index = position === \"start\" ? 1 : ops.length - 1;\n\n  const data = ops[index].data;\n\n  invariant(data.length === 6, \"Op data length is not 6\");\n\n  const p3 = pointFrom(data[4], data[5]);\n  const p2 = pointFrom(data[2], data[3]);\n  const p1 = pointFrom(data[0], data[1]);\n\n  // We need to find p0 of the bezier curve.\n  // It is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation.\n  const prevOp = ops[index - 1];\n  let p0 = pointFrom(0, 0);\n  if (prevOp.op === \"move\") {\n    const p = pointFromArray(prevOp.data);\n    invariant(p != null, \"Op data is not a point\");\n    p0 = p;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = pointFrom(prevOp.data[4], prevOp.data[5]);\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // Ee know the last point of the arrow (or the first, if start arrowhead).\n  const [x2, y2] = position === \"start\" ? p0 : p3;\n\n  // By using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point.\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases.\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // Find the normalized direction vector based on the\n  // previously calculated points.\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = getArrowheadSize(arrowhead);\n\n  let length = 0;\n\n  {\n    // Length for -> arrows is based on the length of the last section\n    const [cx, cy] =\n      position === \"end\"\n        ? element.points[element.points.length - 1]\n        : element.points[0];\n    const [px, py] =\n      element.points.length > 1\n        ? position === \"end\"\n          ? element.points[element.points.length - 2]\n          : element.points[1]\n        : [0, 0];\n\n    length = Math.hypot(cx - px, cy - py);\n  }\n\n  // Scale down the arrowhead until we hit a certain size so that it doesn't look weird.\n  // This value is selected by minimizing a minimum size with the last segment of the arrowhead\n  const lengthMultiplier =\n    arrowhead === \"diamond\" || arrowhead === \"diamond_outline\" ? 0.25 : 0.5;\n  const minSize = Math.min(size, length * lengthMultiplier);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  if (\n    arrowhead === \"dot\" ||\n    arrowhead === \"circle\" ||\n    arrowhead === \"circle_outline\"\n  ) {\n    const diameter = Math.hypot(ys - y2, xs - x2) + element.strokeWidth - 2;\n    return [x2, y2, diameter];\n  }\n\n  const angle = getArrowheadAngle(arrowhead);\n\n  if (arrowhead === \"crowfoot_many\" || arrowhead === \"crowfoot_one_or_many\") {\n    // swap (xs, ys) with (x2, y2)\n    const [x3, y3] = pointRotateRads(\n      pointFrom(x2, y2),\n      pointFrom(xs, ys),\n      degreesToRadians(-angle as Degrees),\n    );\n    const [x4, y4] = pointRotateRads(\n      pointFrom(x2, y2),\n      pointFrom(xs, ys),\n      degreesToRadians(angle),\n    );\n    return [xs, ys, x3, y3, x4, y4];\n  }\n\n  // Return points\n  const [x3, y3] = pointRotateRads(\n    pointFrom(xs, ys),\n    pointFrom(x2, y2),\n    ((-angle * Math.PI) / 180) as Radians,\n  );\n  const [x4, y4] = pointRotateRads(\n    pointFrom(xs, ys),\n    pointFrom(x2, y2),\n    degreesToRadians(angle),\n  );\n\n  if (arrowhead === \"diamond\" || arrowhead === \"diamond_outline\") {\n    // point opposite to the arrowhead point\n    let ox;\n    let oy;\n\n    if (position === \"start\") {\n      const [px, py] = element.points.length > 1 ? element.points[1] : [0, 0];\n\n      [ox, oy] = pointRotateRads(\n        pointFrom(x2 + minSize * 2, y2),\n        pointFrom(x2, y2),\n        Math.atan2(py - y2, px - x2) as Radians,\n      );\n    } else {\n      const [px, py] =\n        element.points.length > 1\n          ? element.points[element.points.length - 2]\n          : [0, 0];\n\n      [ox, oy] = pointRotateRads(\n        pointFrom(x2 - minSize * 2, y2),\n        pointFrom(x2, y2),\n        Math.atan2(y2 - py, x2 - px) as Radians,\n      );\n    }\n\n    return [x2, y2, x3, y3, ox, oy, x4, y4];\n  }\n\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst generateLinearElementShape = (\n  element: ExcalidrawLinearElement,\n): Drawable => {\n  const generator = rough.generator();\n  const options = generateRoughOptions(element);\n\n  const method = (() => {\n    if (element.roundness) {\n      return \"curve\";\n    }\n    if (options.fill) {\n      return \"polygon\";\n    }\n    return \"linearPath\";\n  })();\n\n  return generator[method](\n    element.points as Mutable<LocalPoint>[] as RoughPoint[],\n    options,\n  );\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n  elementsMap: ElementsMap,\n): Bounds => {\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n\n  if (element.points.length < 2) {\n    const [pointX, pointY] = element.points[0];\n    const [x, y] = pointRotateRads(\n      pointFrom(element.x + pointX, element.y + pointY),\n      pointFrom(cx, cy),\n      element.angle,\n    );\n\n    let coords: Bounds = [x, y, x, y];\n    if (boundTextElement) {\n      const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(\n        element,\n        elementsMap,\n        [x, y, x, y],\n        boundTextElement,\n      );\n      coords = [\n        coordsWithBoundText[0],\n        coordsWithBoundText[1],\n        coordsWithBoundText[2],\n        coordsWithBoundText[3],\n      ];\n    }\n    return coords;\n  }\n\n  // first element is always the curve\n  const cachedShape = ShapeCache.get(element)?.[0];\n  const shape = cachedShape ?? generateLinearElementShape(element);\n  const ops = getCurvePathOps(shape);\n  const transformXY = ([x, y]: GlobalPoint) =>\n    pointRotateRads<GlobalPoint>(\n      pointFrom(element.x + x, element.y + y),\n      pointFrom(cx, cy),\n      element.angle,\n    );\n  const res = getMinMaxXYFromCurvePathOps(ops, transformXY);\n  let coords: Bounds = [res[0], res[1], res[2], res[3]];\n  if (boundTextElement) {\n    const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(\n      element,\n      elementsMap,\n      coords,\n      boundTextElement,\n    );\n    coords = [\n      coordsWithBoundText[0],\n      coordsWithBoundText[1],\n      coordsWithBoundText[2],\n      coordsWithBoundText[3],\n    ];\n  }\n  return coords;\n};\n\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  nonRotated: boolean = false,\n): Bounds => {\n  return ElementBounds.getBounds(element, elementsMap, nonRotated);\n};\n\nexport const getCommonBounds = (\n  elements: ElementsMapOrArray,\n  elementsMap?: ElementsMap,\n): Bounds => {\n  if (!sizeOf(elements)) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  const _elementsMap = elementsMap || arrayToMap(elements);\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element, _elementsMap);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getDraggedElementsBounds = (\n  elements: ExcalidrawElement[],\n  dragOffset: { x: number; y: number },\n) => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return [\n    minX + dragOffset.x,\n    minY + dragOffset.y,\n    maxX + dragOffset.x,\n    maxY + dragOffset.y,\n  ];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n  normalizePoints: boolean,\n): Bounds => {\n  if (!(isLinearElement(element) || isFreeDrawElement(element))) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points, normalizePoints),\n    normalizePoints,\n  );\n\n  let bounds: Bounds;\n\n  if (isFreeDrawElement(element)) {\n    // Free Draw\n    bounds = getBoundsFromPoints(points);\n  } else {\n    // Line\n    const gen = rough.generator();\n    const curve = !element.roundness\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n\n    const ops = getCurvePathOps(curve);\n    bounds = getMinMaxXYFromCurvePathOps(ops);\n  }\n\n  const [minX, minY, maxX, maxY] = bounds;\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n): Bounds => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve =\n    element.roundness == null\n      ? gen.linearPath(\n          points as [number, number][],\n          generateRoughOptions(element),\n        )\n      : gen.curve(points as [number, number][], generateRoughOptions(element));\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): Bounds => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n  const elementsMap = arrayToMap(elements);\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);\n    const distance = pointDistance(\n      pointFrom((x1 + x2) / 2, (y1 + y2) / 2),\n      pointFrom(from.x, from.y),\n    );\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement, elementsMap);\n};\n\nexport interface BoundingBox {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n  midX: number;\n  midY: number;\n  width: number;\n  height: number;\n}\n\nexport const getCommonBoundingBox = (\n  elements: ExcalidrawElement[] | readonly NonDeleted<ExcalidrawElement>[],\n): BoundingBox => {\n  const [minX, minY, maxX, maxY] = getCommonBounds(elements);\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n    midX: (minX + maxX) / 2,\n    midY: (minY + maxY) / 2,\n  };\n};\n\n/**\n * returns scene coords of user's editor viewport (visible canvas area) bounds\n */\nexport const getVisibleSceneBounds = ({\n  scrollX,\n  scrollY,\n  width,\n  height,\n  zoom,\n}: AppState): SceneBounds => {\n  return [\n    -scrollX,\n    -scrollY,\n    -scrollX + width / zoom.value,\n    -scrollY + height / zoom.value,\n  ];\n};\n\nexport const getCenterForBounds = (bounds: Bounds): GlobalPoint =>\n  pointFrom(\n    bounds[0] + (bounds[2] - bounds[0]) / 2,\n    bounds[1] + (bounds[3] - bounds[1]) / 2,\n  );\n\n/**\n * Get the axis-aligned bounding box for a given element\n */\nexport const aabbForElement = (\n  element: Readonly<ExcalidrawElement>,\n  elementsMap: ElementsMap,\n  offset?: [number, number, number, number],\n) => {\n  const bbox = {\n    minX: element.x,\n    minY: element.y,\n    maxX: element.x + element.width,\n    maxY: element.y + element.height,\n    midX: element.x + element.width / 2,\n    midY: element.y + element.height / 2,\n  };\n\n  const center = elementCenterPoint(element, elementsMap);\n  const [topLeftX, topLeftY] = pointRotateRads(\n    pointFrom(bbox.minX, bbox.minY),\n    center,\n    element.angle,\n  );\n  const [topRightX, topRightY] = pointRotateRads(\n    pointFrom(bbox.maxX, bbox.minY),\n    center,\n    element.angle,\n  );\n  const [bottomRightX, bottomRightY] = pointRotateRads(\n    pointFrom(bbox.maxX, bbox.maxY),\n    center,\n    element.angle,\n  );\n  const [bottomLeftX, bottomLeftY] = pointRotateRads(\n    pointFrom(bbox.minX, bbox.maxY),\n    center,\n    element.angle,\n  );\n\n  const bounds = [\n    Math.min(topLeftX, topRightX, bottomRightX, bottomLeftX),\n    Math.min(topLeftY, topRightY, bottomRightY, bottomLeftY),\n    Math.max(topLeftX, topRightX, bottomRightX, bottomLeftX),\n    Math.max(topLeftY, topRightY, bottomRightY, bottomLeftY),\n  ] as Bounds;\n\n  if (offset) {\n    const [topOffset, rightOffset, downOffset, leftOffset] = offset;\n    return [\n      bounds[0] - leftOffset,\n      bounds[1] - topOffset,\n      bounds[2] + rightOffset,\n      bounds[3] + downOffset,\n    ] as Bounds;\n  }\n\n  return bounds;\n};\n\nexport const pointInsideBounds = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  bounds: Bounds,\n): boolean =>\n  p[0] > bounds[0] && p[0] < bounds[2] && p[1] > bounds[1] && p[1] < bounds[3];\n\nexport const doBoundsIntersect = (\n  bounds1: Bounds | null,\n  bounds2: Bounds | null,\n): boolean => {\n  if (bounds1 == null || bounds2 == null) {\n    return false;\n  }\n\n  const [minX1, minY1, maxX1, maxY1] = bounds1;\n  const [minX2, minY2, maxX2, maxY2] = bounds2;\n\n  return minX1 < maxX2 && maxX1 > minX2 && minY1 < maxY2 && maxY1 > minY2;\n};\n\nexport const elementCenterPoint = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  xOffset: number = 0,\n  yOffset: number = 0,\n) => {\n  const [x, y] = getCenterForBounds(getElementBounds(element, elementsMap));\n\n  return pointFrom<GlobalPoint>(x + xOffset, y + yOffset);\n};\n",
    "import {\n  pointCenter,\n  pointFrom,\n  pointRotateRads,\n  pointsEqual,\n  type GlobalPoint,\n  type LocalPoint,\n  pointDistance,\n  vectorFromPoint,\n  curveLength,\n  curvePointAtLength,\n} from \"@excalidraw/math\";\n\nimport { getCurvePathOps } from \"@excalidraw/utils/shape\";\n\nimport {\n  DRAGGING_THRESHOLD,\n  KEYS,\n  shouldRotateWithDiscreteAngle,\n  getGridPoint,\n  invariant,\n  tupleToCoors,\n  viewportCoordsToSceneCoords,\n} from \"@excalidraw/common\";\n\nimport {\n  deconstructLinearOrFreeDrawElement,\n  isPathALoop,\n  type Store,\n} from \"@excalidraw/element\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type {\n  AppState,\n  PointerCoords,\n  InteractiveCanvasAppState,\n  AppClassProperties,\n  NullableGridSize,\n  Zoom,\n} from \"excalidraw-custom/types\";\n\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport {\n  bindOrUnbindLinearElement,\n  getHoveredElementForBinding,\n  isBindingEnabled,\n  maybeSuggestBindingsForLinearElementAtCoords,\n} from \"./binding\";\nimport {\n  getElementAbsoluteCoords,\n  getElementPointsCoords,\n  getMinMaxXYFromCurvePathOps,\n} from \"./bounds\";\n\nimport { headingIsHorizontal, vectorToHeading } from \"./heading\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\nimport {\n  isBindingElement,\n  isElbowArrow,\n  isFixedPointBinding,\n} from \"./typeChecks\";\n\nimport { ShapeCache, toggleLinePolygonState } from \"./shape\";\n\nimport { getLockedLinearCursorAlignSize } from \"./sizeHelpers\";\n\nimport { isLineElement } from \"./typeChecks\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { Bounds } from \"./bounds\";\nimport type {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n  PointBinding,\n  ExcalidrawBindableElement,\n  ExcalidrawTextElementWithContainer,\n  ElementsMap,\n  NonDeletedSceneElementsMap,\n  FixedPointBinding,\n  FixedSegment,\n  ExcalidrawElbowArrowElement,\n  PointsPositionUpdates,\n} from \"./types\";\n\n/**\n * Normalizes line points so that the start point is at [0,0]. This is\n * expected in various parts of the codebase.\n *\n * Also returns the offsets - [0,0] if no normalization needed.\n *\n * @private\n */\nconst getNormalizedPoints = ({\n  points,\n}: {\n  points: ExcalidrawLinearElement[\"points\"];\n}): {\n  points: LocalPoint[];\n  offsetX: number;\n  offsetY: number;\n} => {\n  const offsetX = points[0][0];\n  const offsetY = points[0][1];\n\n  return {\n    points: points.map((p) => {\n      return pointFrom(p[0] - offsetX, p[1] - offsetY);\n    }),\n    offsetX,\n    offsetY,\n  };\n};\n\nexport class LinearElementEditor {\n  public readonly elementId: ExcalidrawElement[\"id\"] & {\n    _brand: \"excalidrawLinearElementId\";\n  };\n  /** indices */\n  public readonly selectedPointsIndices: readonly number[] | null;\n\n  public readonly pointerDownState: Readonly<{\n    prevSelectedPointsIndices: readonly number[] | null;\n    /** index */\n    lastClickedPoint: number;\n    lastClickedIsEndPoint: boolean;\n    origin: Readonly<{ x: number; y: number }> | null;\n    segmentMidpoint: {\n      value: GlobalPoint | null;\n      index: number | null;\n      added: boolean;\n    };\n  }>;\n\n  /** whether you're dragging a point */\n  public readonly isDragging: boolean;\n  public readonly lastUncommittedPoint: LocalPoint | null;\n  public readonly pointerOffset: Readonly<{ x: number; y: number }>;\n  public readonly startBindingElement:\n    | ExcalidrawBindableElement\n    | null\n    | \"keep\";\n  public readonly endBindingElement: ExcalidrawBindableElement | null | \"keep\";\n  public readonly hoverPointIndex: number;\n  public readonly segmentMidPointHoveredCoords: GlobalPoint | null;\n  public readonly elbowed: boolean;\n  public readonly customLineAngle: number | null;\n\n  constructor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n  ) {\n    this.elementId = element.id as string & {\n      _brand: \"excalidrawLinearElementId\";\n    };\n    if (!pointsEqual(element.points[0], pointFrom(0, 0))) {\n      console.error(\"Linear element is not normalized\", Error().stack);\n      mutateElement(\n        element,\n        elementsMap,\n        LinearElementEditor.getNormalizeElementPointsAndCoords(element),\n      );\n    }\n    this.selectedPointsIndices = null;\n    this.lastUncommittedPoint = null;\n    this.isDragging = false;\n    this.pointerOffset = { x: 0, y: 0 };\n    this.startBindingElement = \"keep\";\n    this.endBindingElement = \"keep\";\n    this.pointerDownState = {\n      prevSelectedPointsIndices: null,\n      lastClickedPoint: -1,\n      lastClickedIsEndPoint: false,\n      origin: null,\n\n      segmentMidpoint: {\n        value: null,\n        index: null,\n        added: false,\n      },\n    };\n    this.hoverPointIndex = -1;\n    this.segmentMidPointHoveredCoords = null;\n    this.elbowed = isElbowArrow(element) && element.elbowed;\n    this.customLineAngle = null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 10;\n  /**\n   * @param id the `elementId` from the instance of this class (so that we can\n   *  statically guarantee this method returns an ExcalidrawLinearElement)\n   */\n  static getElement<T extends ExcalidrawLinearElement>(\n    id: InstanceType<typeof LinearElementEditor>[\"elementId\"],\n    elementsMap: ElementsMap,\n  ): T | null {\n    const element = elementsMap.get(id);\n    if (element) {\n      return element as NonDeleted<T>;\n    }\n    return null;\n  }\n\n  static handleBoxSelection(\n    event: PointerEvent,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    elementsMap: NonDeletedSceneElementsMap,\n  ) {\n    if (!appState.editingLinearElement || !appState.selectionElement) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    const { selectedPointsIndices, elementId } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return false;\n    }\n\n    const [selectionX1, selectionY1, selectionX2, selectionY2] =\n      getElementAbsoluteCoords(appState.selectionElement, elementsMap);\n\n    const pointsSceneCoords = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n\n    const nextSelectedPoints = pointsSceneCoords\n      .reduce((acc: number[], point, index) => {\n        if (\n          (point[0] >= selectionX1 &&\n            point[0] <= selectionX2 &&\n            point[1] >= selectionY1 &&\n            point[1] <= selectionY2) ||\n          (event.shiftKey && selectedPointsIndices?.includes(index))\n        ) {\n          acc.push(index);\n        }\n\n        return acc;\n      }, [])\n      .filter((index) => {\n        if (\n          isElbowArrow(element) &&\n          index !== 0 &&\n          index !== element.points.length - 1\n        ) {\n          return false;\n        }\n        return true;\n      });\n\n    setState({\n      editingLinearElement: {\n        ...editingLinearElement,\n        selectedPointsIndices: nextSelectedPoints.length\n          ? nextSelectedPoints\n          : null,\n      },\n    });\n  }\n\n  /**\n   * @returns whether point was dragged\n   */\n  static handlePointDragging(\n    event: PointerEvent,\n    app: AppClassProperties,\n    scenePointerX: number,\n    scenePointerY: number,\n    linearElementEditor: LinearElementEditor,\n  ): Pick<AppState, keyof AppState> | null {\n    if (!linearElementEditor) {\n      return null;\n    }\n    const { elementId } = linearElementEditor;\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    let customLineAngle = linearElementEditor.customLineAngle;\n    if (!element) {\n      return null;\n    }\n\n    if (\n      isElbowArrow(element) &&\n      !linearElementEditor.pointerDownState.lastClickedIsEndPoint &&\n      linearElementEditor.pointerDownState.lastClickedPoint !== 0\n    ) {\n      return null;\n    }\n\n    const selectedPointsIndices = isElbowArrow(element)\n      ? [\n          !!linearElementEditor.selectedPointsIndices?.includes(0)\n            ? 0\n            : undefined,\n          !!linearElementEditor.selectedPointsIndices?.find((idx) => idx > 0)\n            ? element.points.length - 1\n            : undefined,\n        ].filter((idx): idx is number => idx !== undefined)\n      : linearElementEditor.selectedPointsIndices;\n    const lastClickedPoint = isElbowArrow(element)\n      ? linearElementEditor.pointerDownState.lastClickedPoint > 0\n        ? element.points.length - 1\n        : 0\n      : linearElementEditor.pointerDownState.lastClickedPoint;\n\n    // point that's being dragged (out of all selected points)\n    const draggingPoint = element.points[lastClickedPoint];\n\n    if (selectedPointsIndices && draggingPoint) {\n      if (\n        shouldRotateWithDiscreteAngle(event) &&\n        selectedPointsIndices.length === 1 &&\n        element.points.length > 1\n      ) {\n        const selectedIndex = selectedPointsIndices[0];\n        const referencePoint =\n          element.points[selectedIndex === 0 ? 1 : selectedIndex - 1];\n        customLineAngle =\n          linearElementEditor.customLineAngle ??\n          Math.atan2(\n            element.points[selectedIndex][1] - referencePoint[1],\n            element.points[selectedIndex][0] - referencePoint[0],\n          );\n\n        const [width, height] = LinearElementEditor._getShiftLockedDelta(\n          element,\n          elementsMap,\n          referencePoint,\n          pointFrom(scenePointerX, scenePointerY),\n          event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n          customLineAngle,\n        );\n\n        LinearElementEditor.movePoints(\n          element,\n          app.scene,\n          new Map([\n            [\n              selectedIndex,\n              {\n                point: pointFrom(\n                  width + referencePoint[0],\n                  height + referencePoint[1],\n                ),\n                isDragging: selectedIndex === lastClickedPoint,\n              },\n            ],\n          ]),\n        );\n      } else {\n        const newDraggingPointPosition = LinearElementEditor.createPointAt(\n          element,\n          elementsMap,\n          scenePointerX - linearElementEditor.pointerOffset.x,\n          scenePointerY - linearElementEditor.pointerOffset.y,\n          event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n        );\n\n        const deltaX = newDraggingPointPosition[0] - draggingPoint[0];\n        const deltaY = newDraggingPointPosition[1] - draggingPoint[1];\n\n        LinearElementEditor.movePoints(\n          element,\n          app.scene,\n          new Map(\n            selectedPointsIndices.map((pointIndex) => {\n              const newPointPosition: LocalPoint =\n                pointIndex === lastClickedPoint\n                  ? LinearElementEditor.createPointAt(\n                      element,\n                      elementsMap,\n                      scenePointerX - linearElementEditor.pointerOffset.x,\n                      scenePointerY - linearElementEditor.pointerOffset.y,\n                      event[KEYS.CTRL_OR_CMD]\n                        ? null\n                        : app.getEffectiveGridSize(),\n                    )\n                  : pointFrom(\n                      element.points[pointIndex][0] + deltaX,\n                      element.points[pointIndex][1] + deltaY,\n                    );\n              return [\n                pointIndex,\n                {\n                  point: newPointPosition,\n                  isDragging: pointIndex === lastClickedPoint,\n                },\n              ];\n            }),\n          ),\n        );\n      }\n\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n      if (boundTextElement) {\n        handleBindTextResize(element, app.scene, false);\n      }\n\n      // suggest bindings for first and last point if selected\n      let suggestedBindings: ExcalidrawBindableElement[] = [];\n      if (isBindingElement(element, false)) {\n        const firstSelectedIndex = selectedPointsIndices[0] === 0;\n        const lastSelectedIndex =\n          selectedPointsIndices[selectedPointsIndices.length - 1] ===\n          element.points.length - 1;\n        const coords: { x: number; y: number }[] = [];\n\n        if (!firstSelectedIndex !== !lastSelectedIndex) {\n          coords.push({ x: scenePointerX, y: scenePointerY });\n        } else {\n          if (firstSelectedIndex) {\n            coords.push(\n              tupleToCoors(\n                LinearElementEditor.getPointGlobalCoordinates(\n                  element,\n                  element.points[0],\n                  elementsMap,\n                ),\n              ),\n            );\n          }\n\n          if (lastSelectedIndex) {\n            coords.push(\n              tupleToCoors(\n                LinearElementEditor.getPointGlobalCoordinates(\n                  element,\n                  element.points[\n                    selectedPointsIndices[selectedPointsIndices.length - 1]\n                  ],\n                  elementsMap,\n                ),\n              ),\n            );\n          }\n        }\n\n        if (coords.length) {\n          suggestedBindings = maybeSuggestBindingsForLinearElementAtCoords(\n            element,\n            coords,\n            app.scene,\n            app.state.zoom,\n          );\n        }\n      }\n\n      const newLinearElementEditor = {\n        ...linearElementEditor,\n        selectedPointsIndices,\n        segmentMidPointHoveredCoords:\n          lastClickedPoint !== 0 &&\n          lastClickedPoint !== element.points.length - 1\n            ? this.getPointGlobalCoordinates(\n                element,\n                draggingPoint,\n                elementsMap,\n              )\n            : null,\n        hoverPointIndex:\n          lastClickedPoint === 0 ||\n          lastClickedPoint === element.points.length - 1\n            ? lastClickedPoint\n            : -1,\n        isDragging: true,\n        customLineAngle,\n      };\n\n      return {\n        ...app.state,\n        editingLinearElement: app.state.editingLinearElement\n          ? newLinearElementEditor\n          : null,\n        selectedLinearElement: newLinearElementEditor,\n        suggestedBindings,\n      };\n    }\n\n    return null;\n  }\n\n  static handlePointerUp(\n    event: PointerEvent,\n    editingLinearElement: LinearElementEditor,\n    appState: AppState,\n    scene: Scene,\n  ): LinearElementEditor {\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const elements = scene.getNonDeletedElements();\n    const pointerCoords = viewportCoordsToSceneCoords(event, appState);\n\n    const { elementId, selectedPointsIndices, isDragging, pointerDownState } =\n      editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const bindings: Mutable<\n      Partial<\n        Pick<\n          InstanceType<typeof LinearElementEditor>,\n          \"startBindingElement\" | \"endBindingElement\"\n        >\n      >\n    > = {};\n\n    if (isDragging && selectedPointsIndices) {\n      for (const selectedPoint of selectedPointsIndices) {\n        if (\n          selectedPoint === 0 ||\n          selectedPoint === element.points.length - 1\n        ) {\n          if (isPathALoop(element.points, appState.zoom.value)) {\n            if (isLineElement(element)) {\n              scene.mutateElement(\n                element,\n                {\n                  ...toggleLinePolygonState(element, true),\n                },\n                {\n                  informMutation: false,\n                  isDragging: false,\n                },\n              );\n            }\n            LinearElementEditor.movePoints(\n              element,\n              scene,\n              new Map([\n                [\n                  selectedPoint,\n                  {\n                    point:\n                      selectedPoint === 0\n                        ? element.points[element.points.length - 1]\n                        : element.points[0],\n                  },\n                ],\n              ]),\n            );\n          }\n\n          const bindingElement = isBindingEnabled(appState)\n            ? getHoveredElementForBinding(\n                (selectedPointsIndices?.length ?? 0) > 1\n                  ? tupleToCoors(\n                      LinearElementEditor.getPointAtIndexGlobalCoordinates(\n                        element,\n                        selectedPoint!,\n                        elementsMap,\n                      ),\n                    )\n                  : pointerCoords,\n                elements,\n                elementsMap,\n                appState.zoom,\n                isElbowArrow(element),\n                isElbowArrow(element),\n              )\n            : null;\n\n          bindings[\n            selectedPoint === 0 ? \"startBindingElement\" : \"endBindingElement\"\n          ] = bindingElement;\n        }\n      }\n    }\n\n    return {\n      ...editingLinearElement,\n      ...bindings,\n      segmentMidPointHoveredCoords: null,\n      hoverPointIndex: -1,\n      // if clicking without previously dragging a point(s), and not holding\n      // shift, deselect all points except the one clicked. If holding shift,\n      // toggle the point.\n      selectedPointsIndices:\n        isDragging || event.shiftKey\n          ? !isDragging &&\n            event.shiftKey &&\n            pointerDownState.prevSelectedPointsIndices?.includes(\n              pointerDownState.lastClickedPoint,\n            )\n            ? selectedPointsIndices &&\n              selectedPointsIndices.filter(\n                (pointIndex) =>\n                  pointIndex !== pointerDownState.lastClickedPoint,\n              )\n            : selectedPointsIndices\n          : selectedPointsIndices?.includes(pointerDownState.lastClickedPoint)\n          ? [pointerDownState.lastClickedPoint]\n          : selectedPointsIndices,\n      isDragging: false,\n      pointerOffset: { x: 0, y: 0 },\n      customLineAngle: null,\n    };\n  }\n\n  static getEditorMidPoints = (\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    appState: InteractiveCanvasAppState,\n  ): (GlobalPoint | null)[] => {\n    const boundText = getBoundTextElement(element, elementsMap);\n\n    // Since its not needed outside editor unless 2 pointer lines or bound text\n    if (\n      !isElbowArrow(element) &&\n      !appState.editingLinearElement &&\n      element.points.length > 2 &&\n      !boundText\n    ) {\n      return [];\n    }\n\n    const points = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n\n    let index = 0;\n    const midpoints: (GlobalPoint | null)[] = [];\n    while (index < points.length - 1) {\n      if (\n        LinearElementEditor.isSegmentTooShort(\n          element,\n          element.points[index],\n          element.points[index + 1],\n          index,\n          appState.zoom,\n        )\n      ) {\n        midpoints.push(null);\n        index++;\n        continue;\n      }\n      const segmentMidPoint = LinearElementEditor.getSegmentMidPoint(\n        element,\n        index + 1,\n      );\n      midpoints.push(segmentMidPoint);\n      index++;\n    }\n\n    return midpoints;\n  };\n\n  static getSegmentMidpointHitCoords = (\n    linearElementEditor: LinearElementEditor,\n    scenePointer: { x: number; y: number },\n    appState: AppState,\n    elementsMap: ElementsMap,\n  ): GlobalPoint | null => {\n    const { elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return null;\n    }\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      elementsMap,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    if (!isElbowArrow(element) && clickedPointIndex >= 0) {\n      return null;\n    }\n    const points = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n    if (\n      points.length >= 3 &&\n      !appState.editingLinearElement &&\n      !isElbowArrow(element)\n    ) {\n      return null;\n    }\n\n    const threshold =\n      (LinearElementEditor.POINT_HANDLE_SIZE + 1) / appState.zoom.value;\n\n    const existingSegmentMidpointHitCoords =\n      linearElementEditor.segmentMidPointHoveredCoords;\n    if (existingSegmentMidpointHitCoords) {\n      const distance = pointDistance(\n        pointFrom(\n          existingSegmentMidpointHitCoords[0],\n          existingSegmentMidpointHitCoords[1],\n        ),\n        pointFrom(scenePointer.x, scenePointer.y),\n      );\n      if (distance <= threshold) {\n        return existingSegmentMidpointHitCoords;\n      }\n    }\n    let index = 0;\n    const midPoints = LinearElementEditor.getEditorMidPoints(\n      element,\n      elementsMap,\n      appState,\n    );\n\n    while (index < midPoints.length) {\n      if (midPoints[index] !== null) {\n        const distance = pointDistance(\n          midPoints[index]!,\n          pointFrom(scenePointer.x, scenePointer.y),\n        );\n        if (distance <= threshold) {\n          return midPoints[index];\n        }\n      }\n\n      index++;\n    }\n    return null;\n  };\n\n  static isSegmentTooShort<P extends GlobalPoint | LocalPoint>(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    startPoint: P,\n    endPoint: P,\n    index: number,\n    zoom: Zoom,\n  ) {\n    if (isElbowArrow(element)) {\n      if (index >= 0 && index < element.points.length) {\n        return (\n          pointDistance(startPoint, endPoint) * zoom.value <\n          LinearElementEditor.POINT_HANDLE_SIZE / 2\n        );\n      }\n\n      return false;\n    }\n\n    let distance = pointDistance(startPoint, endPoint);\n    if (element.points.length > 2 && element.roundness) {\n      const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n\n      invariant(\n        lines.length === 0 && curves.length > 0,\n        \"Only linears built out of curves are supported\",\n      );\n      invariant(\n        lines.length + curves.length >= index,\n        \"Invalid segment index while calculating mid point\",\n      );\n\n      distance = curveLength<GlobalPoint>(curves[index]);\n    }\n\n    return distance * zoom.value < LinearElementEditor.POINT_HANDLE_SIZE * 4;\n  }\n\n  static getSegmentMidPoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    index: number,\n  ): GlobalPoint {\n    if (isElbowArrow(element)) {\n      invariant(\n        element.points.length >= index,\n        \"Invalid segment index while calculating elbow arrow mid point\",\n      );\n\n      const p = pointCenter(element.points[index - 1], element.points[index]);\n\n      return pointFrom<GlobalPoint>(element.x + p[0], element.y + p[1]);\n    }\n\n    const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n\n    invariant(\n      (lines.length === 0 && curves.length > 0) ||\n        (lines.length > 0 && curves.length === 0),\n      \"Only linears built out of either segments or curves are supported\",\n    );\n    invariant(\n      lines.length + curves.length >= index,\n      \"Invalid segment index while calculating mid point\",\n    );\n\n    if (lines.length) {\n      const segment = lines[index - 1];\n      return pointCenter(segment[0], segment[1]);\n    }\n\n    if (curves.length) {\n      const segment = curves[index - 1];\n      return curvePointAtLength(segment, 0.5);\n    }\n\n    invariant(false, \"Invalid segment type while calculating mid point\");\n  }\n\n  static getSegmentMidPointIndex(\n    linearElementEditor: LinearElementEditor,\n    appState: AppState,\n    midPoint: GlobalPoint,\n    elementsMap: ElementsMap,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n      elementsMap,\n    );\n    if (!element) {\n      return -1;\n    }\n    const midPoints = LinearElementEditor.getEditorMidPoints(\n      element,\n      elementsMap,\n      appState,\n    );\n    let index = 0;\n    while (index < midPoints.length) {\n      if (LinearElementEditor.arePointsEqual(midPoint, midPoints[index])) {\n        return index + 1;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLElement>,\n    app: AppClassProperties,\n    store: Store,\n    scenePointer: { x: number; y: number },\n    linearElementEditor: LinearElementEditor,\n    scene: Scene,\n  ): {\n    didAddPoint: boolean;\n    hitElement: NonDeleted<ExcalidrawElement> | null;\n    linearElementEditor: LinearElementEditor | null;\n  } {\n    const appState = app.state;\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const elements = scene.getNonDeletedElements();\n\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n      linearElementEditor: null,\n    };\n\n    if (!linearElementEditor) {\n      return ret;\n    }\n\n    const { elementId } = linearElementEditor;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n\n    if (!element) {\n      return ret;\n    }\n    const segmentMidpoint = LinearElementEditor.getSegmentMidpointHitCoords(\n      linearElementEditor,\n      scenePointer,\n      appState,\n      elementsMap,\n    );\n    let segmentMidpointIndex = null;\n    if (segmentMidpoint) {\n      segmentMidpointIndex = LinearElementEditor.getSegmentMidPointIndex(\n        linearElementEditor,\n        appState,\n        segmentMidpoint,\n        elementsMap,\n      );\n    } else if (event.altKey && appState.editingLinearElement) {\n      if (linearElementEditor.lastUncommittedPoint == null) {\n        scene.mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              elementsMap,\n              scenePointer.x,\n              scenePointer.y,\n              event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n            ),\n          ],\n        });\n        ret.didAddPoint = true;\n      }\n      store.scheduleCapture();\n      ret.linearElementEditor = {\n        ...linearElementEditor,\n        pointerDownState: {\n          prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n          lastClickedPoint: -1,\n          lastClickedIsEndPoint: false,\n          origin: { x: scenePointer.x, y: scenePointer.y },\n          segmentMidpoint: {\n            value: segmentMidpoint,\n            index: segmentMidpointIndex,\n            added: false,\n          },\n        },\n        selectedPointsIndices: [element.points.length - 1],\n        lastUncommittedPoint: null,\n        endBindingElement: getHoveredElementForBinding(\n          scenePointer,\n          elements,\n          elementsMap,\n          app.state.zoom,\n          linearElementEditor.elbowed,\n        ),\n      };\n\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      elementsMap,\n      appState.zoom,\n      scenePointer.x,\n      scenePointer.y,\n    );\n    // if we clicked on a point, set the element as hitElement otherwise\n    // it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex >= 0 || segmentMidpoint) {\n      ret.hitElement = element;\n    } else {\n      // You might be wandering why we are storing the binding elements on\n      // LinearElementEditor and passing them in, instead of calculating them\n      // from the end points of the `linearElement` - this is to allow disabling\n      // binding (which needs to happen at the point the user finishes moving\n      // the point).\n      const { startBindingElement, endBindingElement } = linearElementEditor;\n      if (isBindingEnabled(appState) && isBindingElement(element)) {\n        bindOrUnbindLinearElement(\n          element,\n          startBindingElement,\n          endBindingElement,\n          scene,\n        );\n      }\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const targetPoint =\n      clickedPointIndex > -1 &&\n      pointRotateRads(\n        pointFrom(\n          element.x + element.points[clickedPointIndex][0],\n          element.y + element.points[clickedPointIndex][1],\n        ),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n\n    const nextSelectedPointsIndices =\n      clickedPointIndex > -1 || event.shiftKey\n        ? event.shiftKey ||\n          linearElementEditor.selectedPointsIndices?.includes(clickedPointIndex)\n          ? normalizeSelectedPoints([\n              ...(linearElementEditor.selectedPointsIndices || []),\n              clickedPointIndex,\n            ])\n          : [clickedPointIndex]\n        : null;\n    ret.linearElementEditor = {\n      ...linearElementEditor,\n      pointerDownState: {\n        prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,\n        lastClickedPoint: clickedPointIndex,\n        lastClickedIsEndPoint: clickedPointIndex === element.points.length - 1,\n        origin: { x: scenePointer.x, y: scenePointer.y },\n        segmentMidpoint: {\n          value: segmentMidpoint,\n          index: segmentMidpointIndex,\n          added: false,\n        },\n      },\n      selectedPointsIndices: nextSelectedPointsIndices,\n      pointerOffset: targetPoint\n        ? {\n            x: scenePointer.x - targetPoint[0],\n            y: scenePointer.y - targetPoint[1],\n          }\n        : { x: 0, y: 0 },\n    };\n\n    return ret;\n  }\n\n  static arePointsEqual<Point extends LocalPoint | GlobalPoint>(\n    point1: Point | null,\n    point2: Point | null,\n  ) {\n    if (!point1 && !point2) {\n      return true;\n    }\n    if (!point1 || !point2) {\n      return false;\n    }\n    return pointsEqual(point1, point2);\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    app: AppClassProperties,\n  ): LinearElementEditor | null {\n    const appState = app.state;\n    if (!appState.editingLinearElement) {\n      return null;\n    }\n    const { elementId, lastUncommittedPoint } = appState.editingLinearElement;\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n    if (!element) {\n      return appState.editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.deletePoints(element, app, [points.length - 1]);\n      }\n      return {\n        ...appState.editingLinearElement,\n        lastUncommittedPoint: null,\n      };\n    }\n\n    let newPoint: LocalPoint;\n\n    if (shouldRotateWithDiscreteAngle(event) && points.length >= 2) {\n      const lastCommittedPoint = points[points.length - 2];\n\n      const [width, height] = LinearElementEditor._getShiftLockedDelta(\n        element,\n        elementsMap,\n        lastCommittedPoint,\n        pointFrom(scenePointerX, scenePointerY),\n        event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize(),\n      );\n\n      newPoint = pointFrom(\n        width + lastCommittedPoint[0],\n        height + lastCommittedPoint[1],\n      );\n    } else {\n      newPoint = LinearElementEditor.createPointAt(\n        element,\n        elementsMap,\n        scenePointerX - appState.editingLinearElement.pointerOffset.x,\n        scenePointerY - appState.editingLinearElement.pointerOffset.y,\n        event[KEYS.CTRL_OR_CMD] || isElbowArrow(element)\n          ? null\n          : app.getEffectiveGridSize(),\n      );\n    }\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoints(\n        element,\n        app.scene,\n        new Map([\n          [\n            element.points.length - 1,\n            {\n              point: newPoint,\n            },\n          ],\n        ]),\n      );\n    } else {\n      LinearElementEditor.addPoints(element, app.scene, [newPoint]);\n    }\n    return {\n      ...appState.editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  /** scene coords */\n  static getPointGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    p: LocalPoint,\n    elementsMap: ElementsMap,\n  ): GlobalPoint {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n\n    const { x, y } = element;\n    return pointRotateRads(\n      pointFrom(x + p[0], y + p[1]),\n      pointFrom(cx, cy),\n      element.angle,\n    );\n  }\n\n  /** scene coords */\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n  ): GlobalPoint[] {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((p) => {\n      const { x, y } = element;\n      return pointRotateRads(\n        pointFrom(x + p[0], y + p[1]),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n    });\n  }\n\n  static getPointAtIndexGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n\n    indexMaybeFromEnd: number, // -1 for last element\n    elementsMap: ElementsMap,\n  ): GlobalPoint {\n    const index =\n      indexMaybeFromEnd < 0\n        ? element.points.length + indexMaybeFromEnd\n        : indexMaybeFromEnd;\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const p = element.points[index];\n    const { x, y } = element;\n\n    return p\n      ? pointRotateRads(\n          pointFrom(x + p[0], y + p[1]),\n          pointFrom(cx, cy),\n          element.angle,\n        )\n      : pointRotateRads(pointFrom(x, y), pointFrom(cx, cy), element.angle);\n  }\n\n  static pointFromAbsoluteCoords(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    absoluteCoords: GlobalPoint,\n    elementsMap: ElementsMap,\n  ): LocalPoint {\n    if (isElbowArrow(element)) {\n      // No rotation for elbow arrows\n      return pointFrom(\n        absoluteCoords[0] - element.x,\n        absoluteCoords[1] - element.y,\n      );\n    }\n\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [x, y] = pointRotateRads(\n      pointFrom(absoluteCoords[0], absoluteCoords[1]),\n      pointFrom(cx, cy),\n      -element.angle as Radians,\n    );\n    return pointFrom(x - element.x, y - element.y);\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    // points on the left, thus should take precedence when clicking, if they\n    // overlap\n    while (--idx > -1) {\n      const p = pointHandles[idx];\n      if (\n        pointDistance(pointFrom(x, y), pointFrom(p[0], p[1])) * zoom.value <\n        // +1px to account for outline stroke\n        LinearElementEditor.POINT_HANDLE_SIZE + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    scenePointerX: number,\n    scenePointerY: number,\n    gridSize: NullableGridSize,\n  ): LocalPoint {\n    const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = pointRotateRads(\n      pointFrom(pointerOnGrid[0], pointerOnGrid[1]),\n      pointFrom(cx, cy),\n      -element.angle as Radians,\n    );\n\n    return pointFrom(rotatedX - element.x, rotatedY - element.y);\n  }\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   * expected in various parts of the codebase.\n   *\n   * Also returns normalized x and y coords to account for the normalization\n   * of the points.\n   */\n  static getNormalizeElementPointsAndCoords(element: ExcalidrawLinearElement) {\n    const { points, offsetX, offsetY } = getNormalizedPoints(element);\n\n    return {\n      points,\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    };\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n  static duplicateSelectedPoints(appState: AppState, scene: Scene): AppState {\n    invariant(\n      appState.editingLinearElement,\n      \"Not currently editing a linear element\",\n    );\n\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const { selectedPointsIndices, elementId } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId, elementsMap);\n\n    invariant(\n      element,\n      \"The linear element does not exist in the provided Scene\",\n    );\n    invariant(\n      selectedPointsIndices != null,\n      \"There are no selected points to duplicate\",\n    );\n\n    const { points } = element;\n\n    const nextSelectedIndices: number[] = [];\n\n    let pointAddedToEnd = false;\n    let indexCursor = -1;\n    const nextPoints = points.reduce((acc: LocalPoint[], p, index) => {\n      ++indexCursor;\n      acc.push(p);\n\n      const isSelected = selectedPointsIndices.includes(index);\n      if (isSelected) {\n        const nextPoint = points[index + 1];\n\n        if (!nextPoint) {\n          pointAddedToEnd = true;\n        }\n        acc.push(\n          nextPoint\n            ? pointFrom((p[0] + nextPoint[0]) / 2, (p[1] + nextPoint[1]) / 2)\n            : pointFrom(p[0], p[1]),\n        );\n\n        nextSelectedIndices.push(indexCursor + 1);\n        ++indexCursor;\n      }\n\n      return acc;\n    }, []);\n\n    scene.mutateElement(element, { points: nextPoints });\n\n    // temp hack to ensure the line doesn't move when adding point to the end,\n    // potentially expanding the bounding box\n    if (pointAddedToEnd) {\n      const lastPoint = element.points[element.points.length - 1];\n      LinearElementEditor.movePoints(\n        element,\n        scene,\n        new Map([\n          [\n            element.points.length - 1,\n            { point: pointFrom(lastPoint[0] + 30, lastPoint[1] + 30) },\n          ],\n        ]),\n      );\n    }\n\n    return {\n      ...appState,\n      editingLinearElement: {\n        ...appState.editingLinearElement,\n        selectedPointsIndices: nextSelectedIndices,\n      },\n    };\n  }\n\n  static deletePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    app: AppClassProperties,\n    pointIndices: readonly number[],\n  ) {\n    const isUncommittedPoint =\n      app.state.editingLinearElement?.lastUncommittedPoint ===\n      element.points[element.points.length - 1];\n\n    const nextPoints = element.points.filter((_, idx) => {\n      return !pointIndices.includes(idx);\n    });\n\n    const isPolygon = isLineElement(element) && element.polygon;\n\n    // keep polygon intact if deleting start/end point or uncommitted point\n    if (\n      isPolygon &&\n      (isUncommittedPoint ||\n        pointIndices.includes(0) ||\n        pointIndices.includes(element.points.length - 1))\n    ) {\n      nextPoints[0] = pointFrom(\n        nextPoints[nextPoints.length - 1][0],\n        nextPoints[nextPoints.length - 1][1],\n      );\n    }\n\n    const {\n      points: normalizedPoints,\n      offsetX,\n      offsetY,\n    } = getNormalizedPoints({ points: nextPoints });\n\n    LinearElementEditor._updatePoints(\n      element,\n      app.scene,\n      normalizedPoints,\n      offsetX,\n      offsetY,\n    );\n  }\n\n  static addPoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scene: Scene,\n    addedPoints: LocalPoint[],\n  ) {\n    const nextPoints = [...element.points, ...addedPoints];\n\n    if (isLineElement(element) && element.polygon) {\n      nextPoints[0] = pointFrom(\n        nextPoints[nextPoints.length - 1][0],\n        nextPoints[nextPoints.length - 1][1],\n      );\n    }\n\n    const {\n      points: normalizedPoints,\n      offsetX,\n      offsetY,\n    } = getNormalizedPoints({ points: nextPoints });\n\n    LinearElementEditor._updatePoints(\n      element,\n      scene,\n      normalizedPoints,\n      offsetX,\n      offsetY,\n    );\n  }\n\n  static movePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scene: Scene,\n    pointUpdates: PointsPositionUpdates,\n    otherUpdates?: {\n      startBinding?: PointBinding | null;\n      endBinding?: PointBinding | null;\n    },\n  ) {\n    const { points } = element;\n\n    // if polygon, move start and end points together\n    if (isLineElement(element) && element.polygon) {\n      const firstPointUpdate = pointUpdates.get(0);\n      const lastPointUpdate = pointUpdates.get(points.length - 1);\n\n      if (firstPointUpdate) {\n        pointUpdates.set(points.length - 1, {\n          point: pointFrom(\n            firstPointUpdate.point[0],\n            firstPointUpdate.point[1],\n          ),\n          isDragging: firstPointUpdate.isDragging,\n        });\n      } else if (lastPointUpdate) {\n        pointUpdates.set(0, {\n          point: pointFrom(lastPointUpdate.point[0], lastPointUpdate.point[1]),\n          isDragging: lastPointUpdate.isDragging,\n        });\n      }\n    }\n\n    // in case we're moving start point, instead of modifying its position\n    // which would break the invariant of it being at [0,0], we move\n    // all the other points in the opposite direction by delta to\n    // offset it. We do the same with actual element.x/y position, so\n    // this hacks are completely transparent to the user.\n\n    const updatedOriginPoint =\n      pointUpdates.get(0)?.point ?? pointFrom<LocalPoint>(0, 0);\n\n    const [offsetX, offsetY] = updatedOriginPoint;\n\n    const nextPoints = isElbowArrow(element)\n      ? [\n          pointUpdates.get(0)?.point ?? points[0],\n          pointUpdates.get(points.length - 1)?.point ??\n            points[points.length - 1],\n        ]\n      : points.map((p, idx) => {\n          const current = pointUpdates.get(idx)?.point ?? p;\n\n          return pointFrom<LocalPoint>(\n            current[0] - offsetX,\n            current[1] - offsetY,\n          );\n        });\n\n    LinearElementEditor._updatePoints(\n      element,\n      scene,\n      nextPoints,\n      offsetX,\n      offsetY,\n      otherUpdates,\n      {\n        isDragging: Array.from(pointUpdates.values()).some((t) => t.isDragging),\n      },\n    );\n  }\n\n  static shouldAddMidpoint(\n    linearElementEditor: LinearElementEditor,\n    pointerCoords: PointerCoords,\n    appState: AppState,\n    elementsMap: ElementsMap,\n  ) {\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n      elementsMap,\n    );\n\n    // Elbow arrows don't allow midpoints\n    if (element && isElbowArrow(element)) {\n      return false;\n    }\n\n    if (!element) {\n      return false;\n    }\n\n    const { segmentMidpoint } = linearElementEditor.pointerDownState;\n\n    if (\n      segmentMidpoint.added ||\n      segmentMidpoint.value === null ||\n      segmentMidpoint.index === null ||\n      linearElementEditor.pointerDownState.origin === null\n    ) {\n      return false;\n    }\n\n    const origin = linearElementEditor.pointerDownState.origin!;\n    const dist = pointDistance(\n      pointFrom(origin.x, origin.y),\n      pointFrom(pointerCoords.x, pointerCoords.y),\n    );\n    if (\n      !appState.editingLinearElement &&\n      dist < DRAGGING_THRESHOLD / appState.zoom.value\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  static addMidpoint(\n    linearElementEditor: LinearElementEditor,\n    pointerCoords: PointerCoords,\n    app: AppClassProperties,\n    snapToGrid: boolean,\n    scene: Scene,\n  ) {\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(\n      linearElementEditor.elementId,\n      elementsMap,\n    );\n    if (!element) {\n      return;\n    }\n    const { segmentMidpoint } = linearElementEditor.pointerDownState;\n    const ret: {\n      pointerDownState: LinearElementEditor[\"pointerDownState\"];\n      selectedPointsIndices: LinearElementEditor[\"selectedPointsIndices\"];\n    } = {\n      pointerDownState: linearElementEditor.pointerDownState,\n      selectedPointsIndices: linearElementEditor.selectedPointsIndices,\n    };\n\n    const midpoint = LinearElementEditor.createPointAt(\n      element,\n      elementsMap,\n      pointerCoords.x,\n      pointerCoords.y,\n      snapToGrid && !isElbowArrow(element) ? app.getEffectiveGridSize() : null,\n    );\n    const points = [\n      ...element.points.slice(0, segmentMidpoint.index!),\n      midpoint,\n      ...element.points.slice(segmentMidpoint.index!),\n    ];\n\n    scene.mutateElement(element, { points });\n\n    ret.pointerDownState = {\n      ...linearElementEditor.pointerDownState,\n      segmentMidpoint: {\n        ...linearElementEditor.pointerDownState.segmentMidpoint,\n        added: true,\n      },\n      lastClickedPoint: segmentMidpoint.index!,\n    };\n    ret.selectedPointsIndices = [segmentMidpoint.index!];\n    return ret;\n  }\n\n  private static _updatePoints(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scene: Scene,\n    nextPoints: readonly LocalPoint[],\n    offsetX: number,\n    offsetY: number,\n    otherUpdates?: {\n      startBinding?: PointBinding | null;\n      endBinding?: PointBinding | null;\n    },\n    options?: {\n      isDragging?: boolean;\n      zoom?: AppState[\"zoom\"];\n      sceneElementsMap?: NonDeletedSceneElementsMap;\n    },\n  ) {\n    if (isElbowArrow(element)) {\n      const updates: {\n        startBinding?: FixedPointBinding | null;\n        endBinding?: FixedPointBinding | null;\n        points?: LocalPoint[];\n      } = {};\n      if (otherUpdates?.startBinding !== undefined) {\n        updates.startBinding =\n          otherUpdates.startBinding !== null &&\n          isFixedPointBinding(otherUpdates.startBinding)\n            ? otherUpdates.startBinding\n            : null;\n      }\n      if (otherUpdates?.endBinding !== undefined) {\n        updates.endBinding =\n          otherUpdates.endBinding !== null &&\n          isFixedPointBinding(otherUpdates.endBinding)\n            ? otherUpdates.endBinding\n            : null;\n      }\n\n      updates.points = Array.from(nextPoints);\n\n      scene.mutateElement(element, updates, {\n        informMutation: true,\n        isDragging: options?.isDragging ?? false,\n      });\n    } else {\n      // TODO do we need to get precise coords here just to calc centers?\n      const nextCoords = getElementPointsCoords(element, nextPoints);\n      const prevCoords = getElementPointsCoords(element, element.points);\n      const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n      const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n      const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n      const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n      const dX = prevCenterX - nextCenterX;\n      const dY = prevCenterY - nextCenterY;\n      const rotatedOffset = pointRotateRads(\n        pointFrom(offsetX, offsetY),\n        pointFrom(dX, dY),\n        element.angle,\n      );\n      scene.mutateElement(element, {\n        ...otherUpdates,\n        points: nextPoints,\n        x: element.x + rotatedOffset[0],\n        y: element.y + rotatedOffset[1],\n      });\n    }\n  }\n\n  private static _getShiftLockedDelta(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    elementsMap: ElementsMap,\n    referencePoint: LocalPoint,\n    scenePointer: GlobalPoint,\n    gridSize: NullableGridSize,\n    customLineAngle?: number,\n  ) {\n    const referencePointCoords = LinearElementEditor.getPointGlobalCoordinates(\n      element,\n      referencePoint,\n      elementsMap,\n    );\n\n    if (isElbowArrow(element)) {\n      return [\n        scenePointer[0] - referencePointCoords[0],\n        scenePointer[1] - referencePointCoords[1],\n      ];\n    }\n\n    const [gridX, gridY] = getGridPoint(\n      scenePointer[0],\n      scenePointer[1],\n      gridSize,\n    );\n\n    const { width, height } = getLockedLinearCursorAlignSize(\n      referencePointCoords[0],\n      referencePointCoords[1],\n      gridX,\n      gridY,\n      customLineAngle,\n    );\n\n    return pointRotateRads(\n      pointFrom(width, height),\n      pointFrom(0, 0),\n      -element.angle as Radians,\n    );\n  }\n\n  static getBoundTextElementPosition = (\n    element: ExcalidrawLinearElement,\n    boundTextElement: ExcalidrawTextElementWithContainer,\n    elementsMap: ElementsMap,\n  ): { x: number; y: number } => {\n    const points = LinearElementEditor.getPointsGlobalCoordinates(\n      element,\n      elementsMap,\n    );\n    if (points.length < 2) {\n      mutateElement(boundTextElement, elementsMap, { isDeleted: true });\n    }\n    let x = 0;\n    let y = 0;\n    if (element.points.length % 2 === 1) {\n      const index = Math.floor(element.points.length / 2);\n      const midPoint = LinearElementEditor.getPointGlobalCoordinates(\n        element,\n        element.points[index],\n        elementsMap,\n      );\n      x = midPoint[0] - boundTextElement.width / 2;\n      y = midPoint[1] - boundTextElement.height / 2;\n    } else {\n      const index = element.points.length / 2 - 1;\n      const midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(\n        element,\n        index + 1,\n      );\n\n      x = midSegmentMidpoint[0] - boundTextElement.width / 2;\n      y = midSegmentMidpoint[1] - boundTextElement.height / 2;\n    }\n    return { x, y };\n  };\n\n  static getMinMaxXYWithBoundText = (\n    element: ExcalidrawLinearElement,\n    elementsMap: ElementsMap,\n    elementBounds: Bounds,\n    boundTextElement: ExcalidrawTextElementWithContainer,\n  ): [number, number, number, number, number, number] => {\n    let [x1, y1, x2, y2] = elementBounds;\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const { x: boundTextX1, y: boundTextY1 } =\n      LinearElementEditor.getBoundTextElementPosition(\n        element,\n        boundTextElement,\n        elementsMap,\n      );\n    const boundTextX2 = boundTextX1 + boundTextElement.width;\n    const boundTextY2 = boundTextY1 + boundTextElement.height;\n    const centerPoint = pointFrom(cx, cy);\n\n    const topLeftRotatedPoint = pointRotateRads(\n      pointFrom(x1, y1),\n      centerPoint,\n      element.angle,\n    );\n    const topRightRotatedPoint = pointRotateRads(\n      pointFrom(x2, y1),\n      centerPoint,\n      element.angle,\n    );\n\n    const counterRotateBoundTextTopLeft = pointRotateRads(\n      pointFrom(boundTextX1, boundTextY1),\n      centerPoint,\n      -element.angle as Radians,\n    );\n    const counterRotateBoundTextTopRight = pointRotateRads(\n      pointFrom(boundTextX2, boundTextY1),\n      centerPoint,\n      -element.angle as Radians,\n    );\n    const counterRotateBoundTextBottomLeft = pointRotateRads(\n      pointFrom(boundTextX1, boundTextY2),\n      centerPoint,\n      -element.angle as Radians,\n    );\n    const counterRotateBoundTextBottomRight = pointRotateRads(\n      pointFrom(boundTextX2, boundTextY2),\n      centerPoint,\n      -element.angle as Radians,\n    );\n\n    if (\n      topLeftRotatedPoint[0] < topRightRotatedPoint[0] &&\n      topLeftRotatedPoint[1] >= topRightRotatedPoint[1]\n    ) {\n      x1 = Math.min(x1, counterRotateBoundTextBottomLeft[0]);\n      x2 = Math.max(\n        x2,\n        Math.max(\n          counterRotateBoundTextTopRight[0],\n          counterRotateBoundTextBottomRight[0],\n        ),\n      );\n      y1 = Math.min(y1, counterRotateBoundTextTopLeft[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextBottomRight[1]);\n    } else if (\n      topLeftRotatedPoint[0] >= topRightRotatedPoint[0] &&\n      topLeftRotatedPoint[1] > topRightRotatedPoint[1]\n    ) {\n      x1 = Math.min(x1, counterRotateBoundTextBottomRight[0]);\n      x2 = Math.max(\n        x2,\n        Math.max(\n          counterRotateBoundTextTopLeft[0],\n          counterRotateBoundTextTopRight[0],\n        ),\n      );\n      y1 = Math.min(y1, counterRotateBoundTextBottomLeft[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextTopRight[1]);\n    } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0]) {\n      x1 = Math.min(x1, counterRotateBoundTextTopRight[0]);\n      x2 = Math.max(x2, counterRotateBoundTextBottomLeft[0]);\n      y1 = Math.min(y1, counterRotateBoundTextBottomRight[1]);\n\n      y2 = Math.max(y2, counterRotateBoundTextTopLeft[1]);\n    } else if (topLeftRotatedPoint[1] <= topRightRotatedPoint[1]) {\n      x1 = Math.min(\n        x1,\n        Math.min(\n          counterRotateBoundTextTopRight[0],\n          counterRotateBoundTextTopLeft[0],\n        ),\n      );\n\n      x2 = Math.max(x2, counterRotateBoundTextBottomRight[0]);\n      y1 = Math.min(y1, counterRotateBoundTextTopRight[1]);\n      y2 = Math.max(y2, counterRotateBoundTextBottomLeft[1]);\n    }\n\n    return [x1, y1, x2, y2, cx, cy];\n  };\n\n  static getElementAbsoluteCoords = (\n    element: ExcalidrawLinearElement,\n    elementsMap: ElementsMap,\n    includeBoundText: boolean = false,\n  ): [number, number, number, number, number, number] => {\n    let coords: [number, number, number, number, number, number];\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    if (element.points.length < 2 || !ShapeCache.get(element)) {\n      // XXX this is just a poor estimate and not very useful\n      const { minX, minY, maxX, maxY } = element.points.reduce(\n        (limits, [x, y]) => {\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          return limits;\n        },\n        { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n      );\n      x1 = minX + element.x;\n      y1 = minY + element.y;\n      x2 = maxX + element.x;\n      y2 = maxY + element.y;\n    } else {\n      const shape = ShapeCache.generateElementShape(element, null);\n\n      // first element is always the curve\n      const ops = getCurvePathOps(shape[0]);\n\n      const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n      x1 = minX + element.x;\n      y1 = minY + element.y;\n      x2 = maxX + element.x;\n      y2 = maxY + element.y;\n    }\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    coords = [x1, y1, x2, y2, cx, cy];\n\n    if (!includeBoundText) {\n      return coords;\n    }\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n    if (boundTextElement) {\n      coords = LinearElementEditor.getMinMaxXYWithBoundText(\n        element,\n        elementsMap,\n        [x1, y1, x2, y2],\n        boundTextElement,\n      );\n    }\n\n    return coords;\n  };\n\n  static moveFixedSegment(\n    linearElement: LinearElementEditor,\n    index: number,\n    x: number,\n    y: number,\n    scene: Scene,\n  ): LinearElementEditor {\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const element = LinearElementEditor.getElement(\n      linearElement.elementId,\n      elementsMap,\n    );\n\n    if (!element || !isElbowArrow(element)) {\n      return linearElement;\n    }\n\n    if (index && index > 0 && index < element.points.length) {\n      const isHorizontal = headingIsHorizontal(\n        vectorToHeading(\n          vectorFromPoint(element.points[index], element.points[index - 1]),\n        ),\n      );\n\n      const fixedSegments = (element.fixedSegments ?? []).reduce(\n        (segments, s) => {\n          segments[s.index] = s;\n          return segments;\n        },\n        {} as Record<number, FixedSegment>,\n      );\n      fixedSegments[index] = {\n        index,\n        start: pointFrom<LocalPoint>(\n          !isHorizontal ? x - element.x : element.points[index - 1][0],\n          isHorizontal ? y - element.y : element.points[index - 1][1],\n        ),\n        end: pointFrom<LocalPoint>(\n          !isHorizontal ? x - element.x : element.points[index][0],\n          isHorizontal ? y - element.y : element.points[index][1],\n        ),\n      };\n      const nextFixedSegments = Object.values(fixedSegments).sort(\n        (a, b) => a.index - b.index,\n      );\n\n      const offset = nextFixedSegments\n        .map((segment) => segment.index)\n        .reduce((count, idx) => (idx < index ? count + 1 : count), 0);\n\n      scene.mutateElement(element, {\n        fixedSegments: nextFixedSegments,\n      });\n\n      const point = pointFrom<GlobalPoint>(\n        element.x +\n          (element.fixedSegments![offset].start[0] +\n            element.fixedSegments![offset].end[0]) /\n            2,\n        element.y +\n          (element.fixedSegments![offset].start[1] +\n            element.fixedSegments![offset].end[1]) /\n            2,\n      );\n\n      return {\n        ...linearElement,\n        segmentMidPointHoveredCoords: point,\n        pointerDownState: {\n          ...linearElement.pointerDownState,\n          segmentMidpoint: {\n            added: false,\n            index: element.fixedSegments![offset].index,\n            value: point,\n          },\n        },\n      };\n    }\n\n    return linearElement;\n  }\n\n  static deleteFixedSegment(\n    element: ExcalidrawElbowArrowElement,\n    scene: Scene,\n    index: number,\n  ): void {\n    scene.mutateElement(element, {\n      fixedSegments: element.fixedSegments?.filter(\n        (segment) => segment.index !== index,\n      ),\n    });\n  }\n}\n\nconst normalizeSelectedPoints = (\n  points: (number | null)[],\n): number[] | null => {\n  let nextPoints = [\n    ...new Set(points.filter((p) => p !== null && p !== -1)),\n  ] as number[];\n  nextPoints = nextPoints.sort((a, b) => a - b);\n  return nextPoints.length ? nextPoints : null;\n};\n",
    "import {\n  KEYS,\n  arrayToMap,\n  isBindingFallthroughEnabled,\n  tupleToCoors,\n  invariant,\n  isDevEnv,\n  isTestEnv,\n} from \"@excalidraw/common\";\n\nimport {\n  lineSegment,\n  pointFrom,\n  pointRotateRads,\n  type GlobalPoint,\n  vectorFromPoint,\n  pointDistanceSq,\n  clamp,\n  pointDistance,\n  pointFromVector,\n  vectorScale,\n  vectorNormalize,\n  vectorCross,\n  pointsEqual,\n  lineSegmentIntersectionPoints,\n  PRECISION,\n} from \"@excalidraw/math\";\n\nimport type { LocalPoint, Radians } from \"@excalidraw/math\";\n\nimport type { AppState } from \"excalidraw-custom/types\";\n\nimport type { MapEntry, Mutable } from \"@excalidraw/common/utility-types\";\n\nimport {\n  doBoundsIntersect,\n  getCenterForBounds,\n  getElementBounds,\n} from \"./bounds\";\nimport { intersectElementWithLineSegment } from \"./collision\";\nimport { distanceToElement } from \"./distance\";\nimport {\n  headingForPointFromElement,\n  headingIsHorizontal,\n  vectorToHeading,\n  type Heading,\n} from \"./heading\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getBoundTextElement, handleBindTextResize } from \"./textElement\";\nimport {\n  isArrowElement,\n  isBindableElement,\n  isBoundToContainer,\n  isElbowArrow,\n  isFixedPointBinding,\n  isFrameLikeElement,\n  isLinearElement,\n  isRectanguloidElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport { aabbForElement, elementCenterPoint } from \"./bounds\";\nimport { updateElbowArrowPoints } from \"./elbowArrow\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { Bounds } from \"./bounds\";\nimport type { ElementUpdate } from \"./mutateElement\";\nimport type {\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  NonDeleted,\n  ExcalidrawLinearElement,\n  PointBinding,\n  NonDeletedExcalidrawElement,\n  ElementsMap,\n  NonDeletedSceneElementsMap,\n  ExcalidrawTextElement,\n  ExcalidrawArrowElement,\n  ExcalidrawElbowArrowElement,\n  FixedPoint,\n  FixedPointBinding,\n  PointsPositionUpdates,\n} from \"./types\";\n\nexport type SuggestedBinding =\n  | NonDeleted<ExcalidrawBindableElement>\n  | SuggestedPointBinding;\n\nexport type SuggestedPointBinding = [\n  NonDeleted<ExcalidrawLinearElement>,\n  \"start\" | \"end\" | \"both\",\n  NonDeleted<ExcalidrawBindableElement>,\n];\n\nexport const shouldEnableBindingForPointerEvent = (\n  event: React.PointerEvent<HTMLElement>,\n) => {\n  return !event[KEYS.CTRL_OR_CMD];\n};\n\nexport const isBindingEnabled = (appState: AppState): boolean => {\n  return appState.isBindingEnabled;\n};\n\nexport const FIXED_BINDING_DISTANCE = 5;\nexport const BINDING_HIGHLIGHT_THICKNESS = 10;\n\nconst getNonDeletedElements = (\n  scene: Scene,\n  ids: readonly ExcalidrawElement[\"id\"][],\n): NonDeleted<ExcalidrawElement>[] => {\n  const result: NonDeleted<ExcalidrawElement>[] = [];\n  ids.forEach((id) => {\n    const element = scene.getNonDeletedElement(id);\n    if (element != null) {\n      result.push(element);\n    }\n  });\n  return result;\n};\n\nexport const bindOrUnbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  endBindingElement: ExcalidrawBindableElement | null | \"keep\",\n  scene: Scene,\n): void => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  const unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]> = new Set();\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    startBindingElement,\n    endBindingElement,\n    \"start\",\n    boundToElementIds,\n    unboundFromElementIds,\n    scene,\n    elementsMap,\n  );\n  bindOrUnbindLinearElementEdge(\n    linearElement,\n    endBindingElement,\n    startBindingElement,\n    \"end\",\n    boundToElementIds,\n    unboundFromElementIds,\n    scene,\n    elementsMap,\n  );\n\n  const onlyUnbound = Array.from(unboundFromElementIds).filter(\n    (id) => !boundToElementIds.has(id),\n  );\n\n  getNonDeletedElements(scene, onlyUnbound).forEach((element) => {\n    scene.mutateElement(element, {\n      boundElements: element.boundElements?.filter(\n        (element) =>\n          element.type !== \"arrow\" || element.id !== linearElement.id,\n      ),\n    });\n  });\n};\n\nconst bindOrUnbindLinearElementEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement | null | \"keep\",\n  otherEdgeBindableElement: ExcalidrawBindableElement | null | \"keep\",\n  startOrEnd: \"start\" | \"end\",\n  // Is mutated\n  boundToElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  // Is mutated\n  unboundFromElementIds: Set<ExcalidrawBindableElement[\"id\"]>,\n  scene: Scene,\n  elementsMap: ElementsMap,\n): void => {\n  // \"keep\" is for method chaining convenience, a \"no-op\", so just bail out\n  if (bindableElement === \"keep\") {\n    return;\n  }\n\n  // null means break the bind, so nothing to consider here\n  if (bindableElement === null) {\n    const unbound = unbindLinearElement(linearElement, startOrEnd, scene);\n    if (unbound != null) {\n      unboundFromElementIds.add(unbound);\n    }\n    return;\n  }\n\n  // While complext arrows can do anything, simple arrow with both ends trying\n  // to bind to the same bindable should not be allowed, start binding takes\n  // precedence\n  if (isLinearElementSimple(linearElement)) {\n    if (\n      otherEdgeBindableElement == null ||\n      (otherEdgeBindableElement === \"keep\"\n        ? // TODO: Refactor - Needlessly complex\n          !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n            linearElement,\n            bindableElement,\n            startOrEnd,\n          )\n        : startOrEnd === \"start\" ||\n          otherEdgeBindableElement.id !== bindableElement.id)\n    ) {\n      bindLinearElement(linearElement, bindableElement, startOrEnd, scene);\n      boundToElementIds.add(bindableElement.id);\n    }\n  } else {\n    bindLinearElement(linearElement, bindableElement, startOrEnd, scene);\n    boundToElementIds.add(bindableElement.id);\n  }\n};\n\nconst getOriginalBindingsIfStillCloseToArrowEnds = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom?: AppState[\"zoom\"],\n): (NonDeleted<ExcalidrawElement> | null)[] =>\n  ([\"start\", \"end\"] as const).map((edge) => {\n    const coors = getLinearElementEdgeCoors(linearElement, edge, elementsMap);\n    const elementId =\n      edge === \"start\"\n        ? linearElement.startBinding?.elementId\n        : linearElement.endBinding?.elementId;\n    if (elementId) {\n      const element = elementsMap.get(elementId);\n      if (\n        isBindableElement(element) &&\n        bindingBorderTest(element, coors, elementsMap, zoom)\n      ) {\n        return element;\n      }\n    }\n\n    return null;\n  });\n\nconst getBindingStrategyForDraggingArrowEndpoints = (\n  selectedElement: NonDeleted<ExcalidrawLinearElement>,\n  isBindingEnabled: boolean,\n  draggingPoints: readonly number[],\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly NonDeletedExcalidrawElement[],\n  zoom?: AppState[\"zoom\"],\n): (NonDeleted<ExcalidrawBindableElement> | null | \"keep\")[] => {\n  const startIdx = 0;\n  const endIdx = selectedElement.points.length - 1;\n  const startDragged = draggingPoints.findIndex((i) => i === startIdx) > -1;\n  const endDragged = draggingPoints.findIndex((i) => i === endIdx) > -1;\n  const start = startDragged\n    ? isBindingEnabled\n      ? getEligibleElementForBindingElement(\n          selectedElement,\n          \"start\",\n          elementsMap,\n          elements,\n          zoom,\n        )\n      : null // If binding is disabled and start is dragged, break all binds\n    : \"keep\";\n  const end = endDragged\n    ? isBindingEnabled\n      ? getEligibleElementForBindingElement(\n          selectedElement,\n          \"end\",\n          elementsMap,\n          elements,\n          zoom,\n        )\n      : null // If binding is disabled and end is dragged, break all binds\n    : \"keep\";\n\n  return [start, end];\n};\n\nconst getBindingStrategyForDraggingArrowOrJoints = (\n  selectedElement: NonDeleted<ExcalidrawLinearElement>,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly NonDeletedExcalidrawElement[],\n  isBindingEnabled: boolean,\n  zoom?: AppState[\"zoom\"],\n): (NonDeleted<ExcalidrawBindableElement> | null | \"keep\")[] => {\n  // Elbow arrows don't bind when dragged as a whole\n  if (isElbowArrow(selectedElement)) {\n    return [\"keep\", \"keep\"];\n  }\n\n  const [startIsClose, endIsClose] = getOriginalBindingsIfStillCloseToArrowEnds(\n    selectedElement,\n    elementsMap,\n    zoom,\n  );\n  const start = startIsClose\n    ? isBindingEnabled\n      ? getEligibleElementForBindingElement(\n          selectedElement,\n          \"start\",\n          elementsMap,\n          elements,\n          zoom,\n        )\n      : null\n    : null;\n  const end = endIsClose\n    ? isBindingEnabled\n      ? getEligibleElementForBindingElement(\n          selectedElement,\n          \"end\",\n          elementsMap,\n          elements,\n          zoom,\n        )\n      : null\n    : null;\n\n  return [start, end];\n};\n\nexport const bindOrUnbindLinearElements = (\n  selectedElements: NonDeleted<ExcalidrawLinearElement>[],\n  isBindingEnabled: boolean,\n  draggingPoints: readonly number[] | null,\n  scene: Scene,\n  zoom?: AppState[\"zoom\"],\n): void => {\n  selectedElements.forEach((selectedElement) => {\n    const [start, end] = draggingPoints?.length\n      ? // The arrow edge points are dragged (i.e. start, end)\n        getBindingStrategyForDraggingArrowEndpoints(\n          selectedElement,\n          isBindingEnabled,\n          draggingPoints ?? [],\n          scene.getNonDeletedElementsMap(),\n          scene.getNonDeletedElements(),\n          zoom,\n        )\n      : // The arrow itself (the shaft) or the inner joins are dragged\n        getBindingStrategyForDraggingArrowOrJoints(\n          selectedElement,\n          scene.getNonDeletedElementsMap(),\n          scene.getNonDeletedElements(),\n          isBindingEnabled,\n          zoom,\n        );\n\n    bindOrUnbindLinearElement(selectedElement, start, end, scene);\n  });\n};\n\nexport const getSuggestedBindingsForArrows = (\n  selectedElements: NonDeleted<ExcalidrawElement>[],\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom: AppState[\"zoom\"],\n): SuggestedBinding[] => {\n  // HOT PATH: Bail out if selected elements list is too large\n  if (selectedElements.length > 50) {\n    return [];\n  }\n\n  return (\n    selectedElements\n      .filter(isLinearElement)\n      .flatMap((element) =>\n        getOriginalBindingsIfStillCloseToArrowEnds(element, elementsMap, zoom),\n      )\n      .filter(\n        (element): element is NonDeleted<ExcalidrawBindableElement> =>\n          element !== null,\n      )\n      // Filter out bind candidates which are in the\n      // same selection / group with the arrow\n      //\n      // TODO: Is it worth turning the list into a set to avoid dupes?\n      .filter(\n        (element) =>\n          selectedElements.filter((selected) => selected.id === element?.id)\n            .length === 0,\n      )\n  );\n};\n\nexport const maybeSuggestBindingsForLinearElementAtCoords = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  /** scene coords */\n  pointerCoords: {\n    x: number;\n    y: number;\n  }[],\n  scene: Scene,\n  zoom: AppState[\"zoom\"],\n  // During line creation the start binding hasn't been written yet\n  // into `linearElement`\n  oppositeBindingBoundElement?: ExcalidrawBindableElement | null,\n): ExcalidrawBindableElement[] =>\n  Array.from(\n    pointerCoords.reduce(\n      (acc: Set<NonDeleted<ExcalidrawBindableElement>>, coords) => {\n        const hoveredBindableElement = getHoveredElementForBinding(\n          coords,\n          scene.getNonDeletedElements(),\n          scene.getNonDeletedElementsMap(),\n          zoom,\n          isElbowArrow(linearElement),\n          isElbowArrow(linearElement),\n        );\n\n        if (\n          hoveredBindableElement != null &&\n          !isLinearElementSimpleAndAlreadyBound(\n            linearElement,\n            oppositeBindingBoundElement?.id,\n            hoveredBindableElement,\n          )\n        ) {\n          acc.add(hoveredBindableElement);\n        }\n\n        return acc;\n      },\n      new Set() as Set<NonDeleted<ExcalidrawBindableElement>>,\n    ),\n  );\n\nexport const maybeBindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  appState: AppState,\n  pointerCoords: { x: number; y: number },\n  scene: Scene,\n): void => {\n  const elements = scene.getNonDeletedElements();\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  if (appState.startBoundElement != null) {\n    bindLinearElement(\n      linearElement,\n      appState.startBoundElement,\n      \"start\",\n      scene,\n    );\n  }\n\n  const hoveredElement = getHoveredElementForBinding(\n    pointerCoords,\n    elements,\n    elementsMap,\n    appState.zoom,\n    isElbowArrow(linearElement),\n    isElbowArrow(linearElement),\n  );\n\n  if (hoveredElement !== null) {\n    if (\n      !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(\n        linearElement,\n        hoveredElement,\n        \"end\",\n      )\n    ) {\n      bindLinearElement(linearElement, hoveredElement, \"end\", scene);\n    }\n  }\n};\n\nconst normalizePointBinding = (\n  binding: { focus: number; gap: number },\n  hoveredElement: ExcalidrawBindableElement,\n) => ({\n  ...binding,\n  gap: Math.min(\n    binding.gap,\n    maxBindingGap(hoveredElement, hoveredElement.width, hoveredElement.height),\n  ),\n});\n\nexport const bindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  scene: Scene,\n): void => {\n  if (!isArrowElement(linearElement)) {\n    return;\n  }\n\n  let binding: PointBinding | FixedPointBinding = {\n    elementId: hoveredElement.id,\n    ...normalizePointBinding(\n      calculateFocusAndGap(\n        linearElement,\n        hoveredElement,\n        startOrEnd,\n        scene.getNonDeletedElementsMap(),\n      ),\n      hoveredElement,\n    ),\n  };\n\n  if (isElbowArrow(linearElement)) {\n    binding = {\n      ...binding,\n      ...calculateFixedPointForElbowArrowBinding(\n        linearElement,\n        hoveredElement,\n        startOrEnd,\n        scene.getNonDeletedElementsMap(),\n      ),\n    };\n  }\n\n  scene.mutateElement(linearElement, {\n    [startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\"]: binding,\n  });\n\n  const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);\n  if (!boundElementsMap.has(linearElement.id)) {\n    scene.mutateElement(hoveredElement, {\n      boundElements: (hoveredElement.boundElements || []).concat({\n        id: linearElement.id,\n        type: \"arrow\",\n      }),\n    });\n  }\n};\n\n// Don't bind both ends of a simple segment\nconst isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n): boolean => {\n  const otherBinding =\n    linearElement[startOrEnd === \"start\" ? \"endBinding\" : \"startBinding\"];\n  return isLinearElementSimpleAndAlreadyBound(\n    linearElement,\n    otherBinding?.elementId,\n    bindableElement,\n  );\n};\n\nexport const isLinearElementSimpleAndAlreadyBound = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  alreadyBoundToId: ExcalidrawBindableElement[\"id\"] | undefined,\n  bindableElement: ExcalidrawBindableElement,\n): boolean => {\n  return (\n    alreadyBoundToId === bindableElement.id &&\n    isLinearElementSimple(linearElement)\n  );\n};\n\nconst isLinearElementSimple = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n): boolean => linearElement.points.length < 3 && !isElbowArrow(linearElement);\n\nconst unbindLinearElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  scene: Scene,\n): ExcalidrawBindableElement[\"id\"] | null => {\n  const field = startOrEnd === \"start\" ? \"startBinding\" : \"endBinding\";\n  const binding = linearElement[field];\n  if (binding == null) {\n    return null;\n  }\n  scene.mutateElement(linearElement, { [field]: null });\n  return binding.elementId;\n};\n\nexport const getHoveredElementForBinding = (\n  pointerCoords: {\n    x: number;\n    y: number;\n  },\n  elements: readonly NonDeletedExcalidrawElement[],\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom?: AppState[\"zoom\"],\n  fullShape?: boolean,\n  considerAllElements?: boolean,\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  if (considerAllElements) {\n    let cullRest = false;\n    const candidateElements = getAllElementsAtPositionForBinding(\n      elements,\n      (element) =>\n        isBindableElement(element, false) &&\n        bindingBorderTest(\n          element,\n          pointerCoords,\n          elementsMap,\n          zoom,\n          (fullShape ||\n            !isBindingFallthroughEnabled(\n              element as ExcalidrawBindableElement,\n            )) &&\n            // disable fullshape snapping for frame elements so we\n            // can bind to frame children\n            !isFrameLikeElement(element),\n        ),\n    ).filter((element) => {\n      if (cullRest) {\n        return false;\n      }\n\n      if (!isBindingFallthroughEnabled(element as ExcalidrawBindableElement)) {\n        cullRest = true;\n      }\n\n      return true;\n    }) as NonDeleted<ExcalidrawBindableElement>[] | null;\n\n    // Return early if there are no candidates or just one candidate\n    if (!candidateElements || candidateElements.length === 0) {\n      return null;\n    }\n\n    if (candidateElements.length === 1) {\n      return candidateElements[0] as NonDeleted<ExcalidrawBindableElement>;\n    }\n\n    // Prefer the shape with the border being tested (if any)\n    const borderTestElements = candidateElements.filter((element) =>\n      bindingBorderTest(element, pointerCoords, elementsMap, zoom, false),\n    );\n    if (borderTestElements.length === 1) {\n      return borderTestElements[0];\n    }\n\n    // Prefer smaller shapes\n    return candidateElements\n      .sort(\n        (a, b) => b.width ** 2 + b.height ** 2 - (a.width ** 2 + a.height ** 2),\n      )\n      .pop() as NonDeleted<ExcalidrawBindableElement>;\n  }\n\n  const hoveredElement = getElementAtPositionForBinding(\n    elements,\n    (element) =>\n      isBindableElement(element, false) &&\n      bindingBorderTest(\n        element,\n        pointerCoords,\n        elementsMap,\n        zoom,\n        // disable fullshape snapping for frame elements so we\n        // can bind to frame children\n        (fullShape || !isBindingFallthroughEnabled(element)) &&\n          !isFrameLikeElement(element),\n      ),\n  );\n\n  return hoveredElement as NonDeleted<ExcalidrawBindableElement> | null;\n};\n\nconst getElementAtPositionForBinding = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  let hitElement = null;\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n    if (isAtPositionFn(element)) {\n      hitElement = element;\n      break;\n    }\n  }\n\n  return hitElement;\n};\n\nconst getAllElementsAtPositionForBinding = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  isAtPositionFn: (element: NonDeletedExcalidrawElement) => boolean,\n) => {\n  const elementsAtPosition: NonDeletedExcalidrawElement[] = [];\n  // We need to to hit testing from front (end of the array) to back (beginning of the array)\n  // because array is ordered from lower z-index to highest and we want element z-index\n  // with higher z-index\n  for (let index = elements.length - 1; index >= 0; --index) {\n    const element = elements[index];\n    if (element.isDeleted) {\n      continue;\n    }\n\n    if (isAtPositionFn(element)) {\n      elementsAtPosition.push(element);\n    }\n  }\n\n  return elementsAtPosition;\n};\n\nconst calculateFocusAndGap = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: NonDeletedSceneElementsMap,\n): { focus: number; gap: number } => {\n  const direction = startOrEnd === \"start\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n  const adjacentPointIndex = edgePointIndex - direction;\n\n  const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    edgePointIndex,\n    elementsMap,\n  );\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n    elementsMap,\n  );\n\n  return {\n    focus: determineFocusDistance(\n      hoveredElement,\n      elementsMap,\n      adjacentPoint,\n      edgePoint,\n    ),\n    gap: Math.max(1, distanceToElement(hoveredElement, elementsMap, edgePoint)),\n  };\n};\n\n// Supports translating, rotating and scaling `changedElement` with bound\n// linear elements.\nexport const updateBoundElements = (\n  changedElement: NonDeletedExcalidrawElement,\n  scene: Scene,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n    changedElements?: Map<string, ExcalidrawElement>;\n  },\n) => {\n  if (!isBindableElement(changedElement)) {\n    return;\n  }\n\n  const { newSize, simultaneouslyUpdated } = options ?? {};\n  const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(\n    simultaneouslyUpdated,\n  );\n\n  let elementsMap: ElementsMap = scene.getNonDeletedElementsMap();\n  if (options?.changedElements) {\n    elementsMap = new Map(elementsMap) as typeof elementsMap;\n    options.changedElements.forEach((element) => {\n      elementsMap.set(element.id, element);\n    });\n  }\n\n  boundElementsVisitor(elementsMap, changedElement, (element) => {\n    if (!isLinearElement(element) || element.isDeleted) {\n      return;\n    }\n\n    // In case the boundElements are stale\n    if (!doesNeedUpdate(element, changedElement)) {\n      return;\n    }\n\n    // Check for intersections before updating bound elements incase connected elements overlap\n    const startBindingElement = element.startBinding\n      ? elementsMap.get(element.startBinding.elementId)\n      : null;\n    const endBindingElement = element.endBinding\n      ? elementsMap.get(element.endBinding.elementId)\n      : null;\n\n    let startBounds: Bounds | null = null;\n    let endBounds: Bounds | null = null;\n    if (startBindingElement && endBindingElement) {\n      startBounds = getElementBounds(startBindingElement, elementsMap);\n      endBounds = getElementBounds(endBindingElement, elementsMap);\n    }\n\n    const bindings = {\n      startBinding: maybeCalculateNewGapWhenScaling(\n        changedElement,\n        element.startBinding,\n        newSize,\n      ),\n      endBinding: maybeCalculateNewGapWhenScaling(\n        changedElement,\n        element.endBinding,\n        newSize,\n      ),\n    };\n\n    // `linearElement` is being moved/scaled already, just update the binding\n    if (simultaneouslyUpdatedElementIds.has(element.id)) {\n      scene.mutateElement(element, bindings);\n      return;\n    }\n\n    const updates = bindableElementsVisitor(\n      elementsMap,\n      element,\n      (bindableElement, bindingProp) => {\n        if (\n          bindableElement &&\n          isBindableElement(bindableElement) &&\n          (bindingProp === \"startBinding\" || bindingProp === \"endBinding\") &&\n          (changedElement.id === element[bindingProp]?.elementId ||\n            (changedElement.id ===\n              element[\n                bindingProp === \"startBinding\" ? \"endBinding\" : \"startBinding\"\n              ]?.elementId &&\n              !doBoundsIntersect(startBounds, endBounds)))\n        ) {\n          const point = updateBoundPoint(\n            element,\n            bindingProp,\n            bindings[bindingProp],\n            bindableElement,\n            elementsMap,\n          );\n\n          if (point) {\n            return [\n              bindingProp === \"startBinding\" ? 0 : element.points.length - 1,\n              { point },\n            ] as MapEntry<PointsPositionUpdates>;\n          }\n        }\n\n        return null;\n      },\n    ).filter(\n      (update): update is MapEntry<PointsPositionUpdates> => update !== null,\n    );\n\n    LinearElementEditor.movePoints(element, scene, new Map(updates), {\n      ...(changedElement.id === element.startBinding?.elementId\n        ? { startBinding: bindings.startBinding }\n        : {}),\n      ...(changedElement.id === element.endBinding?.elementId\n        ? { endBinding: bindings.endBinding }\n        : {}),\n    });\n\n    const boundText = getBoundTextElement(element, elementsMap);\n    if (boundText && !boundText.isDeleted) {\n      handleBindTextResize(element, scene, false);\n    }\n  });\n};\n\nexport const updateBindings = (\n  latestElement: ExcalidrawElement,\n  scene: Scene,\n  options?: {\n    simultaneouslyUpdated?: readonly ExcalidrawElement[];\n    newSize?: { width: number; height: number };\n    zoom?: AppState[\"zoom\"];\n  },\n) => {\n  if (isLinearElement(latestElement)) {\n    bindOrUnbindLinearElements([latestElement], true, [], scene, options?.zoom);\n  } else {\n    updateBoundElements(latestElement, scene, {\n      ...options,\n      changedElements: new Map([[latestElement.id, latestElement]]),\n    });\n  }\n};\n\nconst doesNeedUpdate = (\n  boundElement: NonDeleted<ExcalidrawLinearElement>,\n  changedElement: ExcalidrawBindableElement,\n) => {\n  return (\n    boundElement.startBinding?.elementId === changedElement.id ||\n    boundElement.endBinding?.elementId === changedElement.id\n  );\n};\n\nconst getSimultaneouslyUpdatedElementIds = (\n  simultaneouslyUpdated: readonly ExcalidrawElement[] | undefined,\n): Set<ExcalidrawElement[\"id\"]> => {\n  return new Set((simultaneouslyUpdated || []).map((element) => element.id));\n};\n\nexport const getHeadingForElbowArrowSnap = (\n  p: Readonly<GlobalPoint>,\n  otherPoint: Readonly<GlobalPoint>,\n  bindableElement: ExcalidrawBindableElement | undefined | null,\n  aabb: Bounds | undefined | null,\n  origPoint: GlobalPoint,\n  elementsMap: ElementsMap,\n  zoom?: AppState[\"zoom\"],\n): Heading => {\n  const otherPointHeading = vectorToHeading(vectorFromPoint(otherPoint, p));\n\n  if (!bindableElement || !aabb) {\n    return otherPointHeading;\n  }\n\n  const distance = getDistanceForBinding(\n    origPoint,\n    bindableElement,\n    elementsMap,\n    zoom,\n  );\n\n  if (!distance) {\n    return vectorToHeading(\n      vectorFromPoint(p, elementCenterPoint(bindableElement, elementsMap)),\n    );\n  }\n\n  return headingForPointFromElement(bindableElement, aabb, p);\n};\n\nconst getDistanceForBinding = (\n  point: Readonly<GlobalPoint>,\n  bindableElement: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  zoom?: AppState[\"zoom\"],\n) => {\n  const distance = distanceToElement(bindableElement, elementsMap, point);\n  const bindDistance = maxBindingGap(\n    bindableElement,\n    bindableElement.width,\n    bindableElement.height,\n    zoom,\n  );\n\n  return distance > bindDistance ? null : distance;\n};\n\nexport const bindPointToSnapToElementOutline = (\n  arrow: ExcalidrawElbowArrowElement,\n  bindableElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: ElementsMap,\n): GlobalPoint => {\n  if (isDevEnv() || isTestEnv()) {\n    invariant(arrow.points.length > 1, \"Arrow should have at least 2 points\");\n  }\n\n  const aabb = aabbForElement(bindableElement, elementsMap);\n  const localP =\n    arrow.points[startOrEnd === \"start\" ? 0 : arrow.points.length - 1];\n  const globalP = pointFrom<GlobalPoint>(\n    arrow.x + localP[0],\n    arrow.y + localP[1],\n  );\n  const edgePoint = isRectanguloidElement(bindableElement)\n    ? avoidRectangularCorner(bindableElement, elementsMap, globalP)\n    : globalP;\n  const elbowed = isElbowArrow(arrow);\n  const center = getCenterForBounds(aabb);\n  const adjacentPointIdx = startOrEnd === \"start\" ? 1 : arrow.points.length - 2;\n  const adjacentPoint = pointRotateRads(\n    pointFrom<GlobalPoint>(\n      arrow.x + arrow.points[adjacentPointIdx][0],\n      arrow.y + arrow.points[adjacentPointIdx][1],\n    ),\n    center,\n    arrow.angle ?? 0,\n  );\n\n  let intersection: GlobalPoint | null = null;\n  if (elbowed) {\n    const isHorizontal = headingIsHorizontal(\n      headingForPointFromElement(bindableElement, aabb, globalP),\n    );\n    const snapPoint = snapToMid(bindableElement, elementsMap, edgePoint);\n    const otherPoint = pointFrom<GlobalPoint>(\n      isHorizontal ? center[0] : snapPoint[0],\n      !isHorizontal ? center[1] : snapPoint[1],\n    );\n    const intersector = lineSegment(\n      otherPoint,\n      pointFromVector(\n        vectorScale(\n          vectorNormalize(vectorFromPoint(snapPoint, otherPoint)),\n          Math.max(bindableElement.width, bindableElement.height) * 2,\n        ),\n        otherPoint,\n      ),\n    );\n    intersection = intersectElementWithLineSegment(\n      bindableElement,\n      elementsMap,\n      intersector,\n      FIXED_BINDING_DISTANCE,\n    ).sort(pointDistanceSq)[0];\n  } else {\n    intersection = intersectElementWithLineSegment(\n      bindableElement,\n      elementsMap,\n      lineSegment(\n        adjacentPoint,\n        pointFromVector(\n          vectorScale(\n            vectorNormalize(vectorFromPoint(edgePoint, adjacentPoint)),\n            pointDistance(edgePoint, adjacentPoint) +\n              Math.max(bindableElement.width, bindableElement.height) * 2,\n          ),\n          adjacentPoint,\n        ),\n      ),\n      FIXED_BINDING_DISTANCE,\n    ).sort(\n      (g, h) =>\n        pointDistanceSq(g, adjacentPoint) - pointDistanceSq(h, adjacentPoint),\n    )[0];\n  }\n\n  if (\n    !intersection ||\n    // Too close to determine vector from intersection to edgePoint\n    pointDistanceSq(edgePoint, intersection) < PRECISION\n  ) {\n    return edgePoint;\n  }\n\n  return elbowed ? intersection : edgePoint;\n};\n\nexport const avoidRectangularCorner = (\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): GlobalPoint => {\n  const center = elementCenterPoint(element, elementsMap);\n  const nonRotatedPoint = pointRotateRads(p, center, -element.angle as Radians);\n\n  if (nonRotatedPoint[0] < element.x && nonRotatedPoint[1] < element.y) {\n    // Top left\n    if (nonRotatedPoint[1] - element.y > -FIXED_BINDING_DISTANCE) {\n      return pointRotateRads<GlobalPoint>(\n        pointFrom(element.x - FIXED_BINDING_DISTANCE, element.y),\n        center,\n        element.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(element.x, element.y - FIXED_BINDING_DISTANCE),\n      center,\n      element.angle,\n    );\n  } else if (\n    nonRotatedPoint[0] < element.x &&\n    nonRotatedPoint[1] > element.y + element.height\n  ) {\n    // Bottom left\n    if (nonRotatedPoint[0] - element.x > -FIXED_BINDING_DISTANCE) {\n      return pointRotateRads(\n        pointFrom(\n          element.x,\n          element.y + element.height + FIXED_BINDING_DISTANCE,\n        ),\n        center,\n        element.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(element.x - FIXED_BINDING_DISTANCE, element.y + element.height),\n      center,\n      element.angle,\n    );\n  } else if (\n    nonRotatedPoint[0] > element.x + element.width &&\n    nonRotatedPoint[1] > element.y + element.height\n  ) {\n    // Bottom right\n    if (\n      nonRotatedPoint[0] - element.x <\n      element.width + FIXED_BINDING_DISTANCE\n    ) {\n      return pointRotateRads(\n        pointFrom(\n          element.x + element.width,\n          element.y + element.height + FIXED_BINDING_DISTANCE,\n        ),\n        center,\n        element.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(\n        element.x + element.width + FIXED_BINDING_DISTANCE,\n        element.y + element.height,\n      ),\n      center,\n      element.angle,\n    );\n  } else if (\n    nonRotatedPoint[0] > element.x + element.width &&\n    nonRotatedPoint[1] < element.y\n  ) {\n    // Top right\n    if (\n      nonRotatedPoint[0] - element.x <\n      element.width + FIXED_BINDING_DISTANCE\n    ) {\n      return pointRotateRads(\n        pointFrom(\n          element.x + element.width,\n          element.y - FIXED_BINDING_DISTANCE,\n        ),\n        center,\n        element.angle,\n      );\n    }\n    return pointRotateRads(\n      pointFrom(element.x + element.width + FIXED_BINDING_DISTANCE, element.y),\n      center,\n      element.angle,\n    );\n  }\n\n  return p;\n};\n\nexport const snapToMid = (\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n  tolerance: number = 0.05,\n): GlobalPoint => {\n  const { x, y, width, height, angle } = element;\n  const center = elementCenterPoint(element, elementsMap, -0.1, -0.1);\n  const nonRotated = pointRotateRads(p, center, -angle as Radians);\n\n  // snap-to-center point is adaptive to element size, but we don't want to go\n  // above and below certain px distance\n  const verticalThreshold = clamp(tolerance * height, 5, 80);\n  const horizontalThreshold = clamp(tolerance * width, 5, 80);\n\n  if (\n    nonRotated[0] <= x + width / 2 &&\n    nonRotated[1] > center[1] - verticalThreshold &&\n    nonRotated[1] < center[1] + verticalThreshold\n  ) {\n    // LEFT\n    return pointRotateRads<GlobalPoint>(\n      pointFrom(x - FIXED_BINDING_DISTANCE, center[1]),\n      center,\n      angle,\n    );\n  } else if (\n    nonRotated[1] <= y + height / 2 &&\n    nonRotated[0] > center[0] - horizontalThreshold &&\n    nonRotated[0] < center[0] + horizontalThreshold\n  ) {\n    // TOP\n    return pointRotateRads(\n      pointFrom(center[0], y - FIXED_BINDING_DISTANCE),\n      center,\n      angle,\n    );\n  } else if (\n    nonRotated[0] >= x + width / 2 &&\n    nonRotated[1] > center[1] - verticalThreshold &&\n    nonRotated[1] < center[1] + verticalThreshold\n  ) {\n    // RIGHT\n    return pointRotateRads(\n      pointFrom(x + width + FIXED_BINDING_DISTANCE, center[1]),\n      center,\n      angle,\n    );\n  } else if (\n    nonRotated[1] >= y + height / 2 &&\n    nonRotated[0] > center[0] - horizontalThreshold &&\n    nonRotated[0] < center[0] + horizontalThreshold\n  ) {\n    // DOWN\n    return pointRotateRads(\n      pointFrom(center[0], y + height + FIXED_BINDING_DISTANCE),\n      center,\n      angle,\n    );\n  } else if (element.type === \"diamond\") {\n    const distance = FIXED_BINDING_DISTANCE;\n    const topLeft = pointFrom<GlobalPoint>(\n      x + width / 4 - distance,\n      y + height / 4 - distance,\n    );\n    const topRight = pointFrom<GlobalPoint>(\n      x + (3 * width) / 4 + distance,\n      y + height / 4 - distance,\n    );\n    const bottomLeft = pointFrom<GlobalPoint>(\n      x + width / 4 - distance,\n      y + (3 * height) / 4 + distance,\n    );\n    const bottomRight = pointFrom<GlobalPoint>(\n      x + (3 * width) / 4 + distance,\n      y + (3 * height) / 4 + distance,\n    );\n\n    if (\n      pointDistance(topLeft, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(topLeft, center, angle);\n    }\n    if (\n      pointDistance(topRight, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(topRight, center, angle);\n    }\n    if (\n      pointDistance(bottomLeft, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(bottomLeft, center, angle);\n    }\n    if (\n      pointDistance(bottomRight, nonRotated) <\n      Math.max(horizontalThreshold, verticalThreshold)\n    ) {\n      return pointRotateRads(bottomRight, center, angle);\n    }\n  }\n\n  return p;\n};\n\nconst updateBoundPoint = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"startBinding\" | \"endBinding\",\n  binding: PointBinding | null | undefined,\n  bindableElement: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n): LocalPoint | null => {\n  if (\n    binding == null ||\n    // We only need to update the other end if this is a 2 point line element\n    (binding.elementId !== bindableElement.id &&\n      linearElement.points.length > 2)\n  ) {\n    return null;\n  }\n\n  const direction = startOrEnd === \"startBinding\" ? -1 : 1;\n  const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;\n\n  if (isElbowArrow(linearElement) && isFixedPointBinding(binding)) {\n    const fixedPoint =\n      normalizeFixedPoint(binding.fixedPoint) ??\n      calculateFixedPointForElbowArrowBinding(\n        linearElement,\n        bindableElement,\n        startOrEnd === \"startBinding\" ? \"start\" : \"end\",\n        elementsMap,\n      ).fixedPoint;\n    const globalMidPoint = elementCenterPoint(bindableElement, elementsMap);\n    const global = pointFrom<GlobalPoint>(\n      bindableElement.x + fixedPoint[0] * bindableElement.width,\n      bindableElement.y + fixedPoint[1] * bindableElement.height,\n    );\n    const rotatedGlobal = pointRotateRads(\n      global,\n      globalMidPoint,\n      bindableElement.angle,\n    );\n\n    return LinearElementEditor.pointFromAbsoluteCoords(\n      linearElement,\n      rotatedGlobal,\n      elementsMap,\n    );\n  }\n\n  const adjacentPointIndex = edgePointIndex - direction;\n  const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    linearElement,\n    adjacentPointIndex,\n    elementsMap,\n  );\n  const focusPointAbsolute = determineFocusPoint(\n    bindableElement,\n    elementsMap,\n    binding.focus,\n    adjacentPoint,\n  );\n\n  let newEdgePoint: GlobalPoint;\n\n  // The linear element was not originally pointing inside the bound shape,\n  // we can point directly at the focus point\n  if (binding.gap === 0) {\n    newEdgePoint = focusPointAbsolute;\n  } else {\n    const edgePointAbsolute =\n      LinearElementEditor.getPointAtIndexGlobalCoordinates(\n        linearElement,\n        edgePointIndex,\n        elementsMap,\n      );\n\n    const center = elementCenterPoint(bindableElement, elementsMap);\n    const interceptorLength =\n      pointDistance(adjacentPoint, edgePointAbsolute) +\n      pointDistance(adjacentPoint, center) +\n      Math.max(bindableElement.width, bindableElement.height) * 2;\n    const intersections = [\n      ...intersectElementWithLineSegment(\n        bindableElement,\n        elementsMap,\n        lineSegment<GlobalPoint>(\n          adjacentPoint,\n          pointFromVector(\n            vectorScale(\n              vectorNormalize(\n                vectorFromPoint(focusPointAbsolute, adjacentPoint),\n              ),\n              interceptorLength,\n            ),\n            adjacentPoint,\n          ),\n        ),\n        binding.gap,\n      ).sort(\n        (g, h) =>\n          pointDistanceSq(g, adjacentPoint) - pointDistanceSq(h, adjacentPoint),\n      ),\n      // Fallback when arrow doesn't point to the shape\n      pointFromVector(\n        vectorScale(\n          vectorNormalize(vectorFromPoint(focusPointAbsolute, adjacentPoint)),\n          pointDistance(adjacentPoint, edgePointAbsolute),\n        ),\n        adjacentPoint,\n      ),\n    ];\n\n    if (intersections.length > 1) {\n      // The adjacent point is outside the shape (+ gap)\n      newEdgePoint = intersections[0];\n    } else if (intersections.length === 1) {\n      // The adjacent point is inside the shape (+ gap)\n      newEdgePoint = focusPointAbsolute;\n    } else {\n      // Shouldn't happend, but just in case\n      newEdgePoint = edgePointAbsolute;\n    }\n  }\n\n  return LinearElementEditor.pointFromAbsoluteCoords(\n    linearElement,\n    newEdgePoint,\n    elementsMap,\n  );\n};\n\nexport const calculateFixedPointForElbowArrowBinding = (\n  linearElement: NonDeleted<ExcalidrawElbowArrowElement>,\n  hoveredElement: ExcalidrawBindableElement,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: ElementsMap,\n): { fixedPoint: FixedPoint } => {\n  const bounds = [\n    hoveredElement.x,\n    hoveredElement.y,\n    hoveredElement.x + hoveredElement.width,\n    hoveredElement.y + hoveredElement.height,\n  ] as Bounds;\n  const snappedPoint = bindPointToSnapToElementOutline(\n    linearElement,\n    hoveredElement,\n    startOrEnd,\n    elementsMap,\n  );\n  const globalMidPoint = pointFrom(\n    bounds[0] + (bounds[2] - bounds[0]) / 2,\n    bounds[1] + (bounds[3] - bounds[1]) / 2,\n  );\n  const nonRotatedSnappedGlobalPoint = pointRotateRads(\n    snappedPoint,\n    globalMidPoint,\n    -hoveredElement.angle as Radians,\n  );\n\n  return {\n    fixedPoint: normalizeFixedPoint([\n      (nonRotatedSnappedGlobalPoint[0] - hoveredElement.x) /\n        hoveredElement.width,\n      (nonRotatedSnappedGlobalPoint[1] - hoveredElement.y) /\n        hoveredElement.height,\n    ]),\n  };\n};\n\nconst maybeCalculateNewGapWhenScaling = (\n  changedElement: ExcalidrawBindableElement,\n  currentBinding: PointBinding | null | undefined,\n  newSize: { width: number; height: number } | undefined,\n): PointBinding | null | undefined => {\n  if (currentBinding == null || newSize == null) {\n    return currentBinding;\n  }\n  const { width: newWidth, height: newHeight } = newSize;\n  const { width, height } = changedElement;\n  const newGap = Math.max(\n    1,\n    Math.min(\n      maxBindingGap(changedElement, newWidth, newHeight),\n      currentBinding.gap *\n        (newWidth < newHeight ? newWidth / width : newHeight / height),\n    ),\n  );\n\n  return { ...currentBinding, gap: newGap };\n};\n\nconst getEligibleElementForBindingElement = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly NonDeletedExcalidrawElement[],\n  zoom?: AppState[\"zoom\"],\n): NonDeleted<ExcalidrawBindableElement> | null => {\n  return getHoveredElementForBinding(\n    getLinearElementEdgeCoors(linearElement, startOrEnd, elementsMap),\n    elements,\n    elementsMap,\n    zoom,\n    isElbowArrow(linearElement),\n    isElbowArrow(linearElement),\n  );\n};\n\nconst getLinearElementEdgeCoors = (\n  linearElement: NonDeleted<ExcalidrawLinearElement>,\n  startOrEnd: \"start\" | \"end\",\n  elementsMap: NonDeletedSceneElementsMap,\n): { x: number; y: number } => {\n  const index = startOrEnd === \"start\" ? 0 : -1;\n  return tupleToCoors(\n    LinearElementEditor.getPointAtIndexGlobalCoordinates(\n      linearElement,\n      index,\n      elementsMap,\n    ),\n  );\n};\n\nexport const fixDuplicatedBindingsAfterDuplication = (\n  duplicatedElements: ExcalidrawElement[],\n  origIdToDuplicateId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n  duplicateElementsMap: NonDeletedSceneElementsMap,\n) => {\n  for (const duplicateElement of duplicatedElements) {\n    if (\"boundElements\" in duplicateElement && duplicateElement.boundElements) {\n      Object.assign(duplicateElement, {\n        boundElements: duplicateElement.boundElements.reduce(\n          (\n            acc: Mutable<NonNullable<ExcalidrawElement[\"boundElements\"]>>,\n            binding,\n          ) => {\n            const newBindingId = origIdToDuplicateId.get(binding.id);\n            if (newBindingId) {\n              acc.push({ ...binding, id: newBindingId });\n            }\n            return acc;\n          },\n          [],\n        ),\n      });\n    }\n\n    if (\"containerId\" in duplicateElement && duplicateElement.containerId) {\n      Object.assign(duplicateElement, {\n        containerId:\n          origIdToDuplicateId.get(duplicateElement.containerId) ?? null,\n      });\n    }\n\n    if (\"endBinding\" in duplicateElement && duplicateElement.endBinding) {\n      const newEndBindingId = origIdToDuplicateId.get(\n        duplicateElement.endBinding.elementId,\n      );\n      Object.assign(duplicateElement, {\n        endBinding: newEndBindingId\n          ? {\n              ...duplicateElement.endBinding,\n              elementId: newEndBindingId,\n            }\n          : null,\n      });\n    }\n    if (\"startBinding\" in duplicateElement && duplicateElement.startBinding) {\n      const newEndBindingId = origIdToDuplicateId.get(\n        duplicateElement.startBinding.elementId,\n      );\n      Object.assign(duplicateElement, {\n        startBinding: newEndBindingId\n          ? {\n              ...duplicateElement.startBinding,\n              elementId: newEndBindingId,\n            }\n          : null,\n      });\n    }\n\n    if (isElbowArrow(duplicateElement)) {\n      Object.assign(\n        duplicateElement,\n        updateElbowArrowPoints(duplicateElement, duplicateElementsMap, {\n          points: [\n            duplicateElement.points[0],\n            duplicateElement.points[duplicateElement.points.length - 1],\n          ],\n        }),\n      );\n    }\n  }\n};\n\nexport const fixBindingsAfterDeletion = (\n  sceneElements: readonly ExcalidrawElement[],\n  deletedElements: readonly ExcalidrawElement[],\n): void => {\n  const elements = arrayToMap(sceneElements);\n\n  for (const element of deletedElements) {\n    BoundElement.unbindAffected(elements, element, (element, updates) =>\n      mutateElement(element, elements, updates),\n    );\n    BindableElement.unbindAffected(elements, element, (element, updates) =>\n      mutateElement(element, elements, updates),\n    );\n  }\n};\n\nconst newBoundElements = (\n  boundElements: ExcalidrawElement[\"boundElements\"],\n  idsToRemove: Set<ExcalidrawElement[\"id\"]>,\n  elementsToAdd: Array<ExcalidrawElement> = [],\n) => {\n  if (!boundElements) {\n    return null;\n  }\n\n  const nextBoundElements = boundElements.filter(\n    (boundElement) => !idsToRemove.has(boundElement.id),\n  );\n\n  nextBoundElements.push(\n    ...elementsToAdd.map(\n      (x) =>\n        ({ id: x.id, type: x.type } as\n          | ExcalidrawArrowElement\n          | ExcalidrawTextElement),\n    ),\n  );\n\n  return nextBoundElements;\n};\n\nexport const bindingBorderTest = (\n  element: NonDeleted<ExcalidrawBindableElement>,\n  { x, y }: { x: number; y: number },\n  elementsMap: NonDeletedSceneElementsMap,\n  zoom?: AppState[\"zoom\"],\n  fullShape?: boolean,\n): boolean => {\n  const p = pointFrom<GlobalPoint>(x, y);\n  const threshold = maxBindingGap(element, element.width, element.height, zoom);\n  const shouldTestInside =\n    // disable fullshape snapping for frame elements so we\n    // can bind to frame children\n    (fullShape || !isBindingFallthroughEnabled(element)) &&\n    !isFrameLikeElement(element);\n\n  // PERF: Run a cheap test to see if the binding element\n  // is even close to the element\n  const bounds = [\n    x - threshold,\n    y - threshold,\n    x + threshold,\n    y + threshold,\n  ] as Bounds;\n  const elementBounds = getElementBounds(element, elementsMap);\n  if (!doBoundsIntersect(bounds, elementBounds)) {\n    return false;\n  }\n\n  // Do the intersection test against the element since it's close enough\n  const intersections = intersectElementWithLineSegment(\n    element,\n    elementsMap,\n    lineSegment(elementCenterPoint(element, elementsMap), p),\n  );\n  const distance = distanceToElement(element, elementsMap, p);\n\n  return shouldTestInside\n    ? intersections.length === 0 || distance <= threshold\n    : intersections.length > 0 && distance <= threshold;\n};\n\nexport const maxBindingGap = (\n  element: ExcalidrawElement,\n  elementWidth: number,\n  elementHeight: number,\n  zoom?: AppState[\"zoom\"],\n): number => {\n  const zoomValue = zoom?.value && zoom.value < 1 ? zoom.value : 1;\n\n  // Aligns diamonds with rectangles\n  const shapeRatio = element.type === \"diamond\" ? 1 / Math.sqrt(2) : 1;\n  const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);\n\n  return Math.max(\n    16,\n    // bigger bindable boundary for bigger elements\n    Math.min(0.25 * smallerDimension, 32),\n    // keep in sync with the zoomed highlight\n    BINDING_HIGHLIGHT_THICKNESS / zoomValue + FIXED_BINDING_DISTANCE,\n  );\n};\n\n// The focus distance is the oriented ratio between the size of\n// the `element` and the \"focus image\" of the element on which\n// all focus points lie, so it's a number between -1 and 1.\n// The line going through `a` and `b` is a tangent to the \"focus image\"\n// of the element.\nconst determineFocusDistance = (\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  // Point on the line, in absolute coordinates\n  a: GlobalPoint,\n  // Another point on the line, in absolute coordinates (closer to element)\n  b: GlobalPoint,\n): number => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  if (pointsEqual(a, b)) {\n    return 0;\n  }\n\n  const rotatedA = pointRotateRads(a, center, -element.angle as Radians);\n  const rotatedB = pointRotateRads(b, center, -element.angle as Radians);\n  const sign =\n    Math.sign(\n      vectorCross(\n        vectorFromPoint(rotatedB, a),\n        vectorFromPoint(rotatedB, center),\n      ),\n    ) * -1;\n  const rotatedInterceptor = lineSegment(\n    rotatedB,\n    pointFromVector(\n      vectorScale(\n        vectorNormalize(vectorFromPoint(rotatedB, rotatedA)),\n        Math.max(element.width * 2, element.height * 2),\n      ),\n      rotatedB,\n    ),\n  );\n  const axes =\n    element.type === \"diamond\"\n      ? [\n          lineSegment(\n            pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n            pointFrom<GlobalPoint>(\n              element.x + element.width / 2,\n              element.y + element.height,\n            ),\n          ),\n          lineSegment(\n            pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n            pointFrom<GlobalPoint>(\n              element.x + element.width,\n              element.y + element.height / 2,\n            ),\n          ),\n        ]\n      : [\n          lineSegment(\n            pointFrom<GlobalPoint>(element.x, element.y),\n            pointFrom<GlobalPoint>(\n              element.x + element.width,\n              element.y + element.height,\n            ),\n          ),\n          lineSegment(\n            pointFrom<GlobalPoint>(element.x + element.width, element.y),\n            pointFrom<GlobalPoint>(element.x, element.y + element.height),\n          ),\n        ];\n  const interceptees =\n    element.type === \"diamond\"\n      ? [\n          lineSegment(\n            pointFrom<GlobalPoint>(\n              element.x + element.width / 2,\n              element.y - element.height,\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + element.width / 2,\n              element.y + element.height * 2,\n            ),\n          ),\n          lineSegment(\n            pointFrom<GlobalPoint>(\n              element.x - element.width,\n              element.y + element.height / 2,\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + element.width * 2,\n              element.y + element.height / 2,\n            ),\n          ),\n        ]\n      : [\n          lineSegment(\n            pointFrom<GlobalPoint>(\n              element.x - element.width,\n              element.y - element.height,\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + element.width * 2,\n              element.y + element.height * 2,\n            ),\n          ),\n          lineSegment(\n            pointFrom<GlobalPoint>(\n              element.x + element.width * 2,\n              element.y - element.height,\n            ),\n            pointFrom<GlobalPoint>(\n              element.x - element.width,\n              element.y + element.height * 2,\n            ),\n          ),\n        ];\n\n  const ordered = [\n    lineSegmentIntersectionPoints(rotatedInterceptor, interceptees[0]),\n    lineSegmentIntersectionPoints(rotatedInterceptor, interceptees[1]),\n  ]\n    .filter((p): p is GlobalPoint => p !== null)\n    .sort((g, h) => pointDistanceSq(g, b) - pointDistanceSq(h, b))\n    .map(\n      (p, idx): number =>\n        (sign * pointDistance(center, p)) /\n        (element.type === \"diamond\"\n          ? pointDistance(axes[idx][0], axes[idx][1]) / 2\n          : Math.sqrt(element.width ** 2 + element.height ** 2) / 2),\n    )\n    .sort((g, h) => Math.abs(g) - Math.abs(h));\n\n  const signedDistanceRatio = ordered[0] ?? 0;\n\n  return signedDistanceRatio;\n};\n\nconst determineFocusPoint = (\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  // The oriented, relative distance from the center of `element` of the\n  // returned focusPoint\n  focus: number,\n  adjacentPoint: GlobalPoint,\n): GlobalPoint => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  if (focus === 0) {\n    return center;\n  }\n\n  const candidates = (\n    element.type === \"diamond\"\n      ? [\n          pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n          pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n          pointFrom<GlobalPoint>(\n            element.x + element.width,\n            element.y + element.height / 2,\n          ),\n          pointFrom<GlobalPoint>(\n            element.x + element.width / 2,\n            element.y + element.height,\n          ),\n        ]\n      : [\n          pointFrom<GlobalPoint>(element.x, element.y),\n          pointFrom<GlobalPoint>(element.x + element.width, element.y),\n          pointFrom<GlobalPoint>(\n            element.x + element.width,\n            element.y + element.height,\n          ),\n          pointFrom<GlobalPoint>(element.x, element.y + element.height),\n        ]\n  )\n    .map((p) =>\n      pointFromVector(\n        vectorScale(vectorFromPoint(p, center), Math.abs(focus)),\n        center,\n      ),\n    )\n    .map((p) => pointRotateRads(p, center, element.angle as Radians));\n\n  const selected = [\n    vectorCross(\n      vectorFromPoint(adjacentPoint, candidates[0]),\n      vectorFromPoint(candidates[1], candidates[0]),\n    ) > 0 && // TOP\n      (focus > 0\n        ? vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[1]),\n            vectorFromPoint(candidates[2], candidates[1]),\n          ) < 0\n        : vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[3]),\n            vectorFromPoint(candidates[0], candidates[3]),\n          ) < 0),\n    vectorCross(\n      vectorFromPoint(adjacentPoint, candidates[1]),\n      vectorFromPoint(candidates[2], candidates[1]),\n    ) > 0 && // RIGHT\n      (focus > 0\n        ? vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[2]),\n            vectorFromPoint(candidates[3], candidates[2]),\n          ) < 0\n        : vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[0]),\n            vectorFromPoint(candidates[1], candidates[0]),\n          ) < 0),\n    vectorCross(\n      vectorFromPoint(adjacentPoint, candidates[2]),\n      vectorFromPoint(candidates[3], candidates[2]),\n    ) > 0 && // BOTTOM\n      (focus > 0\n        ? vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[3]),\n            vectorFromPoint(candidates[0], candidates[3]),\n          ) < 0\n        : vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[1]),\n            vectorFromPoint(candidates[2], candidates[1]),\n          ) < 0),\n    vectorCross(\n      vectorFromPoint(adjacentPoint, candidates[3]),\n      vectorFromPoint(candidates[0], candidates[3]),\n    ) > 0 && // LEFT\n      (focus > 0\n        ? vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[0]),\n            vectorFromPoint(candidates[1], candidates[0]),\n          ) < 0\n        : vectorCross(\n            vectorFromPoint(adjacentPoint, candidates[2]),\n            vectorFromPoint(candidates[3], candidates[2]),\n          ) < 0),\n  ];\n\n  const focusPoint = selected[0]\n    ? focus > 0\n      ? candidates[1]\n      : candidates[0]\n    : selected[1]\n    ? focus > 0\n      ? candidates[2]\n      : candidates[1]\n    : selected[2]\n    ? focus > 0\n      ? candidates[3]\n      : candidates[2]\n    : focus > 0\n    ? candidates[0]\n    : candidates[3];\n\n  return focusPoint;\n};\n\nexport const bindingProperties: Set<BindableProp | BindingProp> = new Set([\n  \"boundElements\",\n  \"frameId\",\n  \"containerId\",\n  \"startBinding\",\n  \"endBinding\",\n]);\n\nexport type BindableProp = \"boundElements\";\n\nexport type BindingProp =\n  | \"frameId\"\n  | \"containerId\"\n  | \"startBinding\"\n  | \"endBinding\";\n\ntype BoundElementsVisitingFunc = (\n  boundElement: ExcalidrawElement | undefined,\n  bindingProp: BindableProp,\n  bindingId: string,\n) => void;\n\ntype BindableElementVisitingFunc<T> = (\n  bindableElement: ExcalidrawElement | undefined,\n  bindingProp: BindingProp,\n  bindingId: string,\n) => T;\n\n/**\n * Tries to visit each bound element (does not have to be found).\n */\nconst boundElementsVisitor = (\n  elements: ElementsMap,\n  element: ExcalidrawElement,\n  visit: BoundElementsVisitingFunc,\n) => {\n  if (isBindableElement(element)) {\n    // create new instance so that possible mutations won't play a role in visiting order\n    const boundElements = element.boundElements?.slice() ?? [];\n\n    // last added text should be the one we keep (~previous are duplicates)\n    boundElements.forEach(({ id }) => {\n      visit(elements.get(id), \"boundElements\", id);\n    });\n  }\n};\n\n/**\n * Tries to visit each bindable element (does not have to be found).\n */\nconst bindableElementsVisitor = <T>(\n  elements: ElementsMap,\n  element: ExcalidrawElement,\n  visit: BindableElementVisitingFunc<T>,\n): T[] => {\n  const result: T[] = [];\n\n  if (element.frameId) {\n    const id = element.frameId;\n    result.push(visit(elements.get(id), \"frameId\", id));\n  }\n\n  if (isBoundToContainer(element)) {\n    const id = element.containerId;\n    result.push(visit(elements.get(id), \"containerId\", id));\n  }\n\n  if (isArrowElement(element)) {\n    if (element.startBinding) {\n      const id = element.startBinding.elementId;\n      result.push(visit(elements.get(id), \"startBinding\", id));\n    }\n\n    if (element.endBinding) {\n      const id = element.endBinding.elementId;\n      result.push(visit(elements.get(id), \"endBinding\", id));\n    }\n  }\n\n  return result;\n};\n\n/**\n * Bound element containing bindings to `frameId`, `containerId`, `startBinding` or `endBinding`.\n */\nexport class BoundElement {\n  /**\n   * Unbind the affected non deleted bindable elements (removing element from `boundElements`).\n   * - iterates non deleted bindable elements (`containerId` | `startBinding.elementId` | `endBinding.elementId`) of the current element\n   * - prepares updates to unbind each bindable element's `boundElements` from the current element\n   */\n  public static unbindAffected(\n    elements: ElementsMap,\n    boundElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) {\n    if (!boundElement) {\n      return;\n    }\n\n    bindableElementsVisitor(elements, boundElement, (bindableElement) => {\n      // bindable element is deleted, this is fine\n      if (!bindableElement || bindableElement.isDeleted) {\n        return;\n      }\n\n      boundElementsVisitor(\n        elements,\n        bindableElement,\n        (_, __, boundElementId) => {\n          if (boundElementId === boundElement.id) {\n            updateElementWith(bindableElement, {\n              boundElements: newBoundElements(\n                bindableElement.boundElements,\n                new Set([boundElementId]),\n              ),\n            });\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Rebind the next affected non deleted bindable elements (adding element to `boundElements`).\n   * - iterates non deleted bindable elements (`containerId` | `startBinding.elementId` | `endBinding.elementId`) of the current element\n   * - prepares updates to rebind each bindable element's `boundElements` to the current element\n   *\n   * NOTE: rebind expects that affected elements were previously unbound with `BoundElement.unbindAffected`\n   */\n  public static rebindAffected = (\n    elements: ElementsMap,\n    boundElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) => {\n    // don't try to rebind element that is deleted\n    if (!boundElement || boundElement.isDeleted) {\n      return;\n    }\n\n    bindableElementsVisitor(\n      elements,\n      boundElement,\n      (bindableElement, bindingProp) => {\n        // unbind from bindable elements, as bindings from non deleted elements into deleted elements are incorrect\n        if (!bindableElement || bindableElement.isDeleted) {\n          updateElementWith(boundElement, { [bindingProp]: null });\n          return;\n        }\n\n        // frame bindings are unidirectional, there is nothing to rebind\n        if (bindingProp === \"frameId\") {\n          return;\n        }\n\n        if (\n          bindableElement.boundElements?.find((x) => x.id === boundElement.id)\n        ) {\n          return;\n        }\n\n        if (isArrowElement(boundElement)) {\n          // rebind if not found!\n          updateElementWith(bindableElement, {\n            boundElements: newBoundElements(\n              bindableElement.boundElements,\n              new Set(),\n              new Array(boundElement),\n            ),\n          });\n        }\n\n        if (isTextElement(boundElement)) {\n          if (!bindableElement.boundElements?.find((x) => x.type === \"text\")) {\n            // rebind only if there is no other text bound already\n            updateElementWith(bindableElement, {\n              boundElements: newBoundElements(\n                bindableElement.boundElements,\n                new Set(),\n                new Array(boundElement),\n              ),\n            });\n          } else {\n            // unbind otherwise\n            updateElementWith(boundElement, { [bindingProp]: null });\n          }\n        }\n      },\n    );\n  };\n}\n\n/**\n * Bindable element containing bindings to `boundElements`.\n */\nexport class BindableElement {\n  /**\n   * Unbind the affected non deleted bound elements (resetting `containerId`, `startBinding`, `endBinding` to `null`).\n   * - iterates through non deleted `boundElements` of the current element\n   * - prepares updates to unbind each bound element from the current element\n   */\n  public static unbindAffected(\n    elements: ElementsMap,\n    bindableElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) {\n    if (!bindableElement) {\n      return;\n    }\n\n    boundElementsVisitor(elements, bindableElement, (boundElement) => {\n      // bound element is deleted, this is fine\n      if (!boundElement || boundElement.isDeleted) {\n        return;\n      }\n\n      bindableElementsVisitor(\n        elements,\n        boundElement,\n        (_, bindingProp, bindableElementId) => {\n          // making sure there is an element to be unbound\n          if (bindableElementId === bindableElement.id) {\n            updateElementWith(boundElement, { [bindingProp]: null });\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Rebind the affected non deleted bound elements (for now setting only `containerId`, as we cannot rebind arrows atm).\n   * - iterates through non deleted `boundElements` of the current element\n   * - prepares updates to rebind each bound element to the current element or unbind it from `boundElements` in case of conflicts\n   *\n   * NOTE: rebind expects that affected elements were previously unbound with `BindaleElement.unbindAffected`\n   */\n  public static rebindAffected = (\n    elements: ElementsMap,\n    bindableElement: ExcalidrawElement | undefined,\n    updateElementWith: (\n      affected: ExcalidrawElement,\n      updates: ElementUpdate<ExcalidrawElement>,\n    ) => void,\n  ) => {\n    // don't try to rebind element that is deleted (i.e. updated as deleted)\n    if (!bindableElement || bindableElement.isDeleted) {\n      return;\n    }\n\n    boundElementsVisitor(\n      elements,\n      bindableElement,\n      (boundElement, _, boundElementId) => {\n        // unbind from bindable elements, as bindings from non deleted elements into deleted elements are incorrect\n        if (!boundElement || boundElement.isDeleted) {\n          updateElementWith(bindableElement, {\n            boundElements: newBoundElements(\n              bindableElement.boundElements,\n              new Set([boundElementId]),\n            ),\n          });\n          return;\n        }\n\n        if (isTextElement(boundElement)) {\n          const boundElements = bindableElement.boundElements?.slice() ?? [];\n          // check if this is the last element in the array, if not, there is an previously bound text which should be unbound\n          if (\n            boundElements.reverse().find((x) => x.type === \"text\")?.id ===\n            boundElement.id\n          ) {\n            if (boundElement.containerId !== bindableElement.id) {\n              // rebind if not bound already!\n              updateElementWith(boundElement, {\n                containerId: bindableElement.id,\n              } as ElementUpdate<ExcalidrawTextElement>);\n            }\n          } else {\n            if (boundElement.containerId !== null) {\n              // unbind if not unbound already\n              updateElementWith(boundElement, {\n                containerId: null,\n              } as ElementUpdate<ExcalidrawTextElement>);\n            }\n\n            // unbind from boundElements as the element got bound to some other element in the meantime\n            updateElementWith(bindableElement, {\n              boundElements: newBoundElements(\n                bindableElement.boundElements,\n                new Set([boundElement.id]),\n              ),\n            });\n          }\n        }\n      },\n    );\n  };\n}\n\nexport const getGlobalFixedPointForBindableElement = (\n  fixedPointRatio: [number, number],\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n): GlobalPoint => {\n  const [fixedX, fixedY] = normalizeFixedPoint(fixedPointRatio);\n\n  return pointRotateRads(\n    pointFrom(\n      element.x + element.width * fixedX,\n      element.y + element.height * fixedY,\n    ),\n    elementCenterPoint(element, elementsMap),\n    element.angle,\n  );\n};\n\nexport const getGlobalFixedPoints = (\n  arrow: ExcalidrawElbowArrowElement,\n  elementsMap: ElementsMap,\n): [GlobalPoint, GlobalPoint] => {\n  const startElement =\n    arrow.startBinding &&\n    (elementsMap.get(arrow.startBinding.elementId) as\n      | ExcalidrawBindableElement\n      | undefined);\n  const endElement =\n    arrow.endBinding &&\n    (elementsMap.get(arrow.endBinding.elementId) as\n      | ExcalidrawBindableElement\n      | undefined);\n  const startPoint =\n    startElement && arrow.startBinding\n      ? getGlobalFixedPointForBindableElement(\n          arrow.startBinding.fixedPoint,\n          startElement as ExcalidrawBindableElement,\n          elementsMap,\n        )\n      : pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[0][0],\n          arrow.y + arrow.points[0][1],\n        );\n  const endPoint =\n    endElement && arrow.endBinding\n      ? getGlobalFixedPointForBindableElement(\n          arrow.endBinding.fixedPoint,\n          endElement as ExcalidrawBindableElement,\n          elementsMap,\n        )\n      : pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[arrow.points.length - 1][0],\n          arrow.y + arrow.points[arrow.points.length - 1][1],\n        );\n\n  return [startPoint, endPoint];\n};\n\nexport const getArrowLocalFixedPoints = (\n  arrow: ExcalidrawElbowArrowElement,\n  elementsMap: ElementsMap,\n) => {\n  const [startPoint, endPoint] = getGlobalFixedPoints(arrow, elementsMap);\n\n  return [\n    LinearElementEditor.pointFromAbsoluteCoords(arrow, startPoint, elementsMap),\n    LinearElementEditor.pointFromAbsoluteCoords(arrow, endPoint, elementsMap),\n  ];\n};\n\nexport const normalizeFixedPoint = <T extends FixedPoint | null>(\n  fixedPoint: T,\n): T extends null ? null : FixedPoint => {\n  // Do not allow a precise 0.5 for fixed point ratio\n  // to avoid jumping arrow heading due to floating point imprecision\n  if (\n    fixedPoint &&\n    (Math.abs(fixedPoint[0] - 0.5) < 0.0001 ||\n      Math.abs(fixedPoint[1] - 0.5) < 0.0001)\n  ) {\n    return fixedPoint.map((ratio) =>\n      Math.abs(ratio - 0.5) < 0.0001 ? 0.5001 : ratio,\n    ) as T extends null ? null : FixedPoint;\n  }\n  return fixedPoint as any as T extends null ? null : FixedPoint;\n};\n",
    "import { isTransparent } from \"@excalidraw/common\";\nimport {\n  curveIntersectLineSegment,\n  isPointWithinBounds,\n  lineSegment,\n  lineSegmentIntersectionPoints,\n  pointFrom,\n  pointFromVector,\n  pointRotateRads,\n  pointsEqual,\n  vectorFromPoint,\n  vectorNormalize,\n  vectorScale,\n} from \"@excalidraw/math\";\n\nimport {\n  ellipse,\n  ellipseSegmentInterceptPoints,\n} from \"@excalidraw/math/ellipse\";\n\nimport type {\n  Curve,\n  GlobalPoint,\n  LineSegment,\n  Radians,\n} from \"@excalidraw/math\";\n\nimport type { FrameNameBounds } from \"excalidraw-custom/types\";\n\nimport { isPathALoop } from \"./utils\";\nimport {\n  type Bounds,\n  doBoundsIntersect,\n  elementCenterPoint,\n  getCenterForBounds,\n  getCubicBezierCurveBound,\n  getElementBounds,\n} from \"./bounds\";\nimport {\n  hasBoundTextElement,\n  isFreeDrawElement,\n  isIframeLikeElement,\n  isImageElement,\n  isLinearElement,\n  isTextElement,\n} from \"./typeChecks\";\nimport {\n  deconstructDiamondElement,\n  deconstructLinearOrFreeDrawElement,\n  deconstructRectanguloidElement,\n} from \"./utils\";\n\nimport { getBoundTextElement } from \"./textElement\";\n\nimport { LinearElementEditor } from \"./linearElementEditor\";\n\nimport { distanceToElement } from \"./distance\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n} from \"./types\";\n\nexport const shouldTestInside = (element: ExcalidrawElement) => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n\n  const isDraggableFromInside =\n    !isTransparent(element.backgroundColor) ||\n    hasBoundTextElement(element) ||\n    isIframeLikeElement(element) ||\n    isTextElement(element);\n\n  if (element.type === \"line\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n\n  if (element.type === \"freedraw\") {\n    return isDraggableFromInside && isPathALoop(element.points);\n  }\n\n  return isDraggableFromInside || isImageElement(element);\n};\n\nexport type HitTestArgs = {\n  point: GlobalPoint;\n  element: ExcalidrawElement;\n  threshold: number;\n  elementsMap: ElementsMap;\n  frameNameBound?: FrameNameBounds | null;\n};\n\nexport const hitElementItself = ({\n  point,\n  element,\n  threshold,\n  elementsMap,\n  frameNameBound = null,\n}: HitTestArgs) => {\n  // Hit test against a frame's name\n  const hitFrameName = frameNameBound\n    ? isPointWithinBounds(\n        pointFrom(frameNameBound.x - threshold, frameNameBound.y - threshold),\n        point,\n        pointFrom(\n          frameNameBound.x + frameNameBound.width + threshold,\n          frameNameBound.y + frameNameBound.height + threshold,\n        ),\n      )\n    : false;\n\n  // Hit test against the extended, rotated bounding box of the element first\n  const bounds = getElementBounds(element, elementsMap, true);\n  const hitBounds = isPointWithinBounds(\n    pointFrom(bounds[0] - threshold, bounds[1] - threshold),\n    pointRotateRads(\n      point,\n      getCenterForBounds(bounds),\n      -element.angle as Radians,\n    ),\n    pointFrom(bounds[2] + threshold, bounds[3] + threshold),\n  );\n\n  // PERF: Bail out early if the point is not even in the\n  // rotated bounding box or not hitting the frame name (saves 99%)\n  if (!hitBounds && !hitFrameName) {\n    return false;\n  }\n\n  // Do the precise (and relatively costly) hit test\n  const hitElement = shouldTestInside(element)\n    ? // Since `inShape` tests STRICTLY againt the insides of a shape\n      // we would need `onShape` as well to include the \"borders\"\n      isPointInElement(point, element, elementsMap) ||\n      isPointOnElementOutline(point, element, elementsMap, threshold)\n    : isPointOnElementOutline(point, element, elementsMap, threshold);\n\n  return hitElement || hitFrameName;\n};\n\nexport const hitElementBoundingBox = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  tolerance = 0,\n) => {\n  let [x1, y1, x2, y2] = getElementBounds(element, elementsMap);\n  x1 -= tolerance;\n  y1 -= tolerance;\n  x2 += tolerance;\n  y2 += tolerance;\n  return isPointWithinBounds(pointFrom(x1, y1), point, pointFrom(x2, y2));\n};\n\nexport const hitElementBoundingBoxOnly = (\n  hitArgs: HitTestArgs,\n  elementsMap: ElementsMap,\n) =>\n  !hitElementItself(hitArgs) &&\n  // bound text is considered part of the element (even if it's outside the bounding box)\n  !hitElementBoundText(hitArgs.point, hitArgs.element, elementsMap) &&\n  hitElementBoundingBox(hitArgs.point, hitArgs.element, elementsMap);\n\nexport const hitElementBoundText = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): boolean => {\n  const boundTextElementCandidate = getBoundTextElement(element, elementsMap);\n\n  if (!boundTextElementCandidate) {\n    return false;\n  }\n  const boundTextElement = isLinearElement(element)\n    ? {\n        ...boundTextElementCandidate,\n        // arrow's bound text accurate position is not stored in the element's property\n        // but rather calculated and returned from the following static method\n        ...LinearElementEditor.getBoundTextElementPosition(\n          element,\n          boundTextElementCandidate,\n          elementsMap,\n        ),\n      }\n    : boundTextElementCandidate;\n\n  return isPointInElement(point, boundTextElement, elementsMap);\n};\n\n/**\n * Intersect a line with an element for binding test\n *\n * @param element\n * @param line\n * @param offset\n * @returns\n */\nexport const intersectElementWithLineSegment = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  line: LineSegment<GlobalPoint>,\n  offset: number = 0,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  // First check if the line intersects the element's axis-aligned bounding box\n  // as it is much faster than checking intersection against the element's shape\n  const intersectorBounds = [\n    Math.min(line[0][0] - offset, line[1][0] - offset),\n    Math.min(line[0][1] - offset, line[1][1] - offset),\n    Math.max(line[0][0] + offset, line[1][0] + offset),\n    Math.max(line[0][1] + offset, line[1][1] + offset),\n  ] as Bounds;\n  const elementBounds = getElementBounds(element, elementsMap);\n\n  if (!doBoundsIntersect(intersectorBounds, elementBounds)) {\n    return [];\n  }\n\n  // Do the actual intersection test against the element's shape\n  switch (element.type) {\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"frame\":\n    case \"selection\":\n    case \"magicframe\":\n      return intersectRectanguloidWithLineSegment(\n        element,\n        elementsMap,\n        line,\n        offset,\n        onlyFirst,\n      );\n    case \"diamond\":\n      return intersectDiamondWithLineSegment(\n        element,\n        elementsMap,\n        line,\n        offset,\n        onlyFirst,\n      );\n    case \"ellipse\":\n      return intersectEllipseWithLineSegment(\n        element,\n        elementsMap,\n        line,\n        offset,\n      );\n    case \"line\":\n    case \"freedraw\":\n    case \"arrow\":\n      return intersectLinearOrFreeDrawWithLineSegment(element, line, onlyFirst);\n  }\n};\n\nconst curveIntersections = (\n  curves: Curve<GlobalPoint>[],\n  segment: LineSegment<GlobalPoint>,\n  intersections: GlobalPoint[],\n  center: GlobalPoint,\n  angle: Radians,\n  onlyFirst = false,\n) => {\n  for (const c of curves) {\n    // Optimize by doing a cheap bounding box check first\n    const b1 = getCubicBezierCurveBound(c[0], c[1], c[2], c[3]);\n    const b2 = [\n      Math.min(segment[0][0], segment[1][0]),\n      Math.min(segment[0][1], segment[1][1]),\n      Math.max(segment[0][0], segment[1][0]),\n      Math.max(segment[0][1], segment[1][1]),\n    ] as Bounds;\n\n    if (!doBoundsIntersect(b1, b2)) {\n      continue;\n    }\n\n    const hits = curveIntersectLineSegment(c, segment);\n\n    if (hits.length > 0) {\n      for (const j of hits) {\n        intersections.push(pointRotateRads(j, center, angle));\n      }\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  return intersections;\n};\n\nconst lineIntersections = (\n  lines: LineSegment<GlobalPoint>[],\n  segment: LineSegment<GlobalPoint>,\n  intersections: GlobalPoint[],\n  center: GlobalPoint,\n  angle: Radians,\n  onlyFirst = false,\n) => {\n  for (const l of lines) {\n    const intersection = lineSegmentIntersectionPoints(l, segment);\n    if (intersection) {\n      intersections.push(pointRotateRads(intersection, center, angle));\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  return intersections;\n};\n\nconst intersectLinearOrFreeDrawWithLineSegment = (\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n  segment: LineSegment<GlobalPoint>,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  // NOTE: This is the only one which return the decomposed elements\n  // rotated! This is due to taking advantage of roughjs definitions.\n  const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n  const intersections: GlobalPoint[] = [];\n\n  for (const l of lines) {\n    const intersection = lineSegmentIntersectionPoints(l, segment);\n    if (intersection) {\n      intersections.push(intersection);\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  for (const c of curves) {\n    // Optimize by doing a cheap bounding box check first\n    const b1 = getCubicBezierCurveBound(c[0], c[1], c[2], c[3]);\n    const b2 = [\n      Math.min(segment[0][0], segment[1][0]),\n      Math.min(segment[0][1], segment[1][1]),\n      Math.max(segment[0][0], segment[1][0]),\n      Math.max(segment[0][1], segment[1][1]),\n    ] as Bounds;\n\n    if (!doBoundsIntersect(b1, b2)) {\n      continue;\n    }\n\n    const hits = curveIntersectLineSegment(c, segment);\n\n    if (hits.length > 0) {\n      intersections.push(...hits);\n\n      if (onlyFirst) {\n        return intersections;\n      }\n    }\n  }\n\n  return intersections;\n};\n\nconst intersectRectanguloidWithLineSegment = (\n  element: ExcalidrawRectanguloidElement,\n  elementsMap: ElementsMap,\n  segment: LineSegment<GlobalPoint>,\n  offset: number = 0,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  const center = elementCenterPoint(element, elementsMap);\n  // To emulate a rotated rectangle we rotate the point in the inverse angle\n  // instead. It's all the same distance-wise.\n  const rotatedA = pointRotateRads<GlobalPoint>(\n    segment[0],\n    center,\n    -element.angle as Radians,\n  );\n  const rotatedB = pointRotateRads<GlobalPoint>(\n    segment[1],\n    center,\n    -element.angle as Radians,\n  );\n  const rotatedIntersector = lineSegment(rotatedA, rotatedB);\n\n  // Get the element's building components we can test against\n  const [sides, corners] = deconstructRectanguloidElement(element, offset);\n\n  const intersections: GlobalPoint[] = [];\n\n  lineIntersections(\n    sides,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  if (onlyFirst && intersections.length > 0) {\n    return intersections;\n  }\n\n  curveIntersections(\n    corners,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  return intersections;\n};\n\n/**\n *\n * @param element\n * @param a\n * @param b\n * @returns\n */\nconst intersectDiamondWithLineSegment = (\n  element: ExcalidrawDiamondElement,\n  elementsMap: ElementsMap,\n  l: LineSegment<GlobalPoint>,\n  offset: number = 0,\n  onlyFirst = false,\n): GlobalPoint[] => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  // Rotate the point to the inverse direction to simulate the rotated diamond\n  // points. It's all the same distance-wise.\n  const rotatedA = pointRotateRads(l[0], center, -element.angle as Radians);\n  const rotatedB = pointRotateRads(l[1], center, -element.angle as Radians);\n  const rotatedIntersector = lineSegment(rotatedA, rotatedB);\n\n  const [sides, corners] = deconstructDiamondElement(element, offset);\n  const intersections: GlobalPoint[] = [];\n\n  lineIntersections(\n    sides,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  if (onlyFirst && intersections.length > 0) {\n    return intersections;\n  }\n\n  curveIntersections(\n    corners,\n    rotatedIntersector,\n    intersections,\n    center,\n    element.angle,\n    onlyFirst,\n  );\n\n  return intersections;\n};\n\n/**\n *\n * @param element\n * @param a\n * @param b\n * @returns\n */\nconst intersectEllipseWithLineSegment = (\n  element: ExcalidrawEllipseElement,\n  elementsMap: ElementsMap,\n  l: LineSegment<GlobalPoint>,\n  offset: number = 0,\n): GlobalPoint[] => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  const rotatedA = pointRotateRads(l[0], center, -element.angle as Radians);\n  const rotatedB = pointRotateRads(l[1], center, -element.angle as Radians);\n\n  return ellipseSegmentInterceptPoints(\n    ellipse(center, element.width / 2 + offset, element.height / 2 + offset),\n    lineSegment(rotatedA, rotatedB),\n  ).map((p) => pointRotateRads(p, center, element.angle));\n};\n\n/**\n * Check if the given point is considered on the given shape's border\n *\n * @param point\n * @param element\n * @param tolerance\n * @returns\n */\nconst isPointOnElementOutline = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  tolerance = 1,\n) => distanceToElement(element, elementsMap, point) <= tolerance;\n\n/**\n * Check if the given point is considered inside the element's border\n *\n * @param point\n * @param element\n * @returns\n */\nexport const isPointInElement = (\n  point: GlobalPoint,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n) => {\n  if (\n    (isLinearElement(element) || isFreeDrawElement(element)) &&\n    !isPathALoop(element.points)\n  ) {\n    // There isn't any \"inside\" for a non-looping path\n    return false;\n  }\n\n  const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);\n\n  if (!isPointWithinBounds(pointFrom(x1, y1), point, pointFrom(x2, y2))) {\n    return false;\n  }\n\n  const center = pointFrom<GlobalPoint>((x1 + x2) / 2, (y1 + y2) / 2);\n  const otherPoint = pointFromVector(\n    vectorScale(\n      vectorNormalize(vectorFromPoint(point, center, 0.1)),\n      Math.max(element.width, element.height) * 2,\n    ),\n    center,\n  );\n  const intersector = lineSegment(point, otherPoint);\n  const intersections = intersectElementWithLineSegment(\n    element,\n    elementsMap,\n    intersector,\n  ).filter((p, pos, arr) => arr.findIndex((q) => pointsEqual(q, p)) === pos);\n\n  return intersections.length % 2 === 1;\n};\n",
    "import {\n  DEFAULT_ADAPTIVE_RADIUS,\n  DEFAULT_PROPORTIONAL_RADIUS,\n  LINE_CONFIRM_THRESHOLD,\n  ROUNDNESS,\n} from \"@excalidraw/common\";\n\nimport {\n  curve,\n  curveCatmullRomCubicApproxPoints,\n  curveOffsetPoints,\n  lineSegment,\n  pointDistance,\n  pointFrom,\n  pointFromArray,\n  rectangle,\n  type GlobalPoint,\n} from \"@excalidraw/math\";\n\nimport type { Curve, LineSegment, LocalPoint } from \"@excalidraw/math\";\n\nimport type { NormalizedZoomValue, Zoom } from \"excalidraw-custom/types\";\n\nimport { getDiamondPoints } from \"./bounds\";\n\nimport { generateLinearCollisionShape } from \"./shape\";\n\nimport type {\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n} from \"./types\";\n\ntype ElementShape = [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]];\n\nconst ElementShapesCache = new WeakMap<\n  ExcalidrawElement,\n  { version: ExcalidrawElement[\"version\"]; shapes: Map<number, ElementShape> }\n>();\n\nconst getElementShapesCacheEntry = <T extends ExcalidrawElement>(\n  element: T,\n  offset: number,\n): ElementShape | undefined => {\n  const record = ElementShapesCache.get(element);\n\n  if (!record) {\n    return undefined;\n  }\n\n  const { version, shapes } = record;\n\n  if (version !== element.version) {\n    ElementShapesCache.delete(element);\n    return undefined;\n  }\n\n  return shapes.get(offset);\n};\n\nconst setElementShapesCacheEntry = <T extends ExcalidrawElement>(\n  element: T,\n  shape: ElementShape,\n  offset: number,\n) => {\n  const record = ElementShapesCache.get(element);\n\n  if (!record) {\n    ElementShapesCache.set(element, {\n      version: element.version,\n      shapes: new Map([[offset, shape]]),\n    });\n\n    return;\n  }\n\n  const { version, shapes } = record;\n\n  if (version !== element.version) {\n    ElementShapesCache.set(element, {\n      version: element.version,\n      shapes: new Map([[offset, shape]]),\n    });\n\n    return;\n  }\n\n  shapes.set(offset, shape);\n};\n\n/**\n * Returns the **rotated** components of freedraw, line or arrow elements.\n *\n * @param element The linear element to deconstruct\n * @returns The rotated in components.\n */\nexport function deconstructLinearOrFreeDrawElement(\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n): [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]] {\n  const cachedShape = getElementShapesCacheEntry(element, 0);\n\n  if (cachedShape) {\n    return cachedShape;\n  }\n\n  const ops = generateLinearCollisionShape(element) as {\n    op: string;\n    data: number[];\n  }[];\n  const lines = [];\n  const curves = [];\n\n  for (let idx = 0; idx < ops.length; idx += 1) {\n    const op = ops[idx];\n    const prevPoint =\n      ops[idx - 1] && pointFromArray<LocalPoint>(ops[idx - 1].data.slice(-2));\n    switch (op.op) {\n      case \"move\":\n        continue;\n      case \"lineTo\":\n        if (!prevPoint) {\n          throw new Error(\"prevPoint is undefined\");\n        }\n\n        lines.push(\n          lineSegment<GlobalPoint>(\n            pointFrom<GlobalPoint>(\n              element.x + prevPoint[0],\n              element.y + prevPoint[1],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[0],\n              element.y + op.data[1],\n            ),\n          ),\n        );\n        continue;\n      case \"bcurveTo\":\n        if (!prevPoint) {\n          throw new Error(\"prevPoint is undefined\");\n        }\n\n        curves.push(\n          curve<GlobalPoint>(\n            pointFrom<GlobalPoint>(\n              element.x + prevPoint[0],\n              element.y + prevPoint[1],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[0],\n              element.y + op.data[1],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[2],\n              element.y + op.data[3],\n            ),\n            pointFrom<GlobalPoint>(\n              element.x + op.data[4],\n              element.y + op.data[5],\n            ),\n          ),\n        );\n        continue;\n      default: {\n        console.error(\"Unknown op type\", op.op);\n      }\n    }\n  }\n\n  const shape = [lines, curves] as ElementShape;\n  setElementShapesCacheEntry(element, shape, 0);\n\n  return shape;\n}\n\n/**\n * Get the building components of a rectanguloid element in the form of\n * line segments and curves **unrotated**.\n *\n * @param element Target rectanguloid element\n * @param offset Optional offset to expand the rectanguloid shape\n * @returns Tuple of **unrotated** line segments (0) and curves (1)\n */\nexport function deconstructRectanguloidElement(\n  element: ExcalidrawRectanguloidElement,\n  offset: number = 0,\n): [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]] {\n  const cachedShape = getElementShapesCacheEntry(element, offset);\n\n  if (cachedShape) {\n    return cachedShape;\n  }\n\n  let radius = getCornerRadius(\n    Math.min(element.width, element.height),\n    element,\n  );\n\n  if (radius === 0) {\n    radius = 0.01;\n  }\n\n  const r = rectangle(\n    pointFrom(element.x, element.y),\n    pointFrom(element.x + element.width, element.y + element.height),\n  );\n\n  const top = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[0][0] + radius, r[0][1]),\n    pointFrom<GlobalPoint>(r[1][0] - radius, r[0][1]),\n  );\n  const right = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[1][0], r[0][1] + radius),\n    pointFrom<GlobalPoint>(r[1][0], r[1][1] - radius),\n  );\n  const bottom = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[0][0] + radius, r[1][1]),\n    pointFrom<GlobalPoint>(r[1][0] - radius, r[1][1]),\n  );\n  const left = lineSegment<GlobalPoint>(\n    pointFrom<GlobalPoint>(r[0][0], r[1][1] - radius),\n    pointFrom<GlobalPoint>(r[0][0], r[0][1] + radius),\n  );\n\n  const baseCorners = [\n    curve(\n      left[1],\n      pointFrom<GlobalPoint>(\n        left[1][0] + (2 / 3) * (r[0][0] - left[1][0]),\n        left[1][1] + (2 / 3) * (r[0][1] - left[1][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        top[0][0] + (2 / 3) * (r[0][0] - top[0][0]),\n        top[0][1] + (2 / 3) * (r[0][1] - top[0][1]),\n      ),\n      top[0],\n    ), // TOP LEFT\n    curve(\n      top[1],\n      pointFrom<GlobalPoint>(\n        top[1][0] + (2 / 3) * (r[1][0] - top[1][0]),\n        top[1][1] + (2 / 3) * (r[0][1] - top[1][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        right[0][0] + (2 / 3) * (r[1][0] - right[0][0]),\n        right[0][1] + (2 / 3) * (r[0][1] - right[0][1]),\n      ),\n      right[0],\n    ), // TOP RIGHT\n    curve(\n      right[1],\n      pointFrom<GlobalPoint>(\n        right[1][0] + (2 / 3) * (r[1][0] - right[1][0]),\n        right[1][1] + (2 / 3) * (r[1][1] - right[1][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        bottom[1][0] + (2 / 3) * (r[1][0] - bottom[1][0]),\n        bottom[1][1] + (2 / 3) * (r[1][1] - bottom[1][1]),\n      ),\n      bottom[1],\n    ), // BOTTOM RIGHT\n    curve(\n      bottom[0],\n      pointFrom<GlobalPoint>(\n        bottom[0][0] + (2 / 3) * (r[0][0] - bottom[0][0]),\n        bottom[0][1] + (2 / 3) * (r[1][1] - bottom[0][1]),\n      ),\n      pointFrom<GlobalPoint>(\n        left[0][0] + (2 / 3) * (r[0][0] - left[0][0]),\n        left[0][1] + (2 / 3) * (r[1][1] - left[0][1]),\n      ),\n      left[0],\n    ), // BOTTOM LEFT\n  ];\n\n  const corners =\n    offset > 0\n      ? baseCorners.map(\n          (corner) =>\n            curveCatmullRomCubicApproxPoints(\n              curveOffsetPoints(corner, offset),\n            )!,\n        )\n      : [\n          [baseCorners[0]],\n          [baseCorners[1]],\n          [baseCorners[2]],\n          [baseCorners[3]],\n        ];\n\n  const sides = [\n    lineSegment<GlobalPoint>(\n      corners[0][corners[0].length - 1][3],\n      corners[1][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[1][corners[1].length - 1][3],\n      corners[2][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[2][corners[2].length - 1][3],\n      corners[3][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[3][corners[3].length - 1][3],\n      corners[0][0][0],\n    ),\n  ];\n  const shape = [sides, corners.flat()] as ElementShape;\n\n  setElementShapesCacheEntry(element, shape, offset);\n\n  return shape;\n}\n\n/**\n * Get the **unrotated** building components of a diamond element\n * in the form of line segments and curves as a tuple, in this order.\n *\n * @param element The element to deconstruct\n * @param offset An optional offset\n * @returns Tuple of line **unrotated** segments (0) and curves (1)\n */\nexport function deconstructDiamondElement(\n  element: ExcalidrawDiamondElement,\n  offset: number = 0,\n): [LineSegment<GlobalPoint>[], Curve<GlobalPoint>[]] {\n  const cachedShape = getElementShapesCacheEntry(element, offset);\n\n  if (cachedShape) {\n    return cachedShape;\n  }\n\n  const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] =\n    getDiamondPoints(element);\n  const verticalRadius = element.roundness\n    ? getCornerRadius(Math.abs(topX - leftX), element)\n    : (topX - leftX) * 0.01;\n  const horizontalRadius = element.roundness\n    ? getCornerRadius(Math.abs(rightY - topY), element)\n    : (rightY - topY) * 0.01;\n\n  const [top, right, bottom, left]: GlobalPoint[] = [\n    pointFrom(element.x + topX, element.y + topY),\n    pointFrom(element.x + rightX, element.y + rightY),\n    pointFrom(element.x + bottomX, element.y + bottomY),\n    pointFrom(element.x + leftX, element.y + leftY),\n  ];\n\n  const baseCorners = [\n    curve(\n      pointFrom<GlobalPoint>(\n        right[0] - verticalRadius,\n        right[1] - horizontalRadius,\n      ),\n      right,\n      right,\n      pointFrom<GlobalPoint>(\n        right[0] - verticalRadius,\n        right[1] + horizontalRadius,\n      ),\n    ), // RIGHT\n    curve(\n      pointFrom<GlobalPoint>(\n        bottom[0] + verticalRadius,\n        bottom[1] - horizontalRadius,\n      ),\n      bottom,\n      bottom,\n      pointFrom<GlobalPoint>(\n        bottom[0] - verticalRadius,\n        bottom[1] - horizontalRadius,\n      ),\n    ), // BOTTOM\n    curve(\n      pointFrom<GlobalPoint>(\n        left[0] + verticalRadius,\n        left[1] + horizontalRadius,\n      ),\n      left,\n      left,\n      pointFrom<GlobalPoint>(\n        left[0] + verticalRadius,\n        left[1] - horizontalRadius,\n      ),\n    ), // LEFT\n    curve(\n      pointFrom<GlobalPoint>(\n        top[0] - verticalRadius,\n        top[1] + horizontalRadius,\n      ),\n      top,\n      top,\n      pointFrom<GlobalPoint>(\n        top[0] + verticalRadius,\n        top[1] + horizontalRadius,\n      ),\n    ), // TOP\n  ];\n\n  const corners =\n    offset > 0\n      ? baseCorners.map(\n          (corner) =>\n            curveCatmullRomCubicApproxPoints(\n              curveOffsetPoints(corner, offset),\n            )!,\n        )\n      : [\n          [baseCorners[0]],\n          [baseCorners[1]],\n          [baseCorners[2]],\n          [baseCorners[3]],\n        ];\n\n  const sides = [\n    lineSegment<GlobalPoint>(\n      corners[0][corners[0].length - 1][3],\n      corners[1][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[1][corners[1].length - 1][3],\n      corners[2][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[2][corners[2].length - 1][3],\n      corners[3][0][0],\n    ),\n    lineSegment<GlobalPoint>(\n      corners[3][corners[3].length - 1][3],\n      corners[0][0][0],\n    ),\n  ];\n\n  const shape = [sides, corners.flat()] as ElementShape;\n\n  setElementShapesCacheEntry(element, shape, offset);\n\n  return shape;\n}\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n  /** supply if you want the loop detection to account for current zoom */\n  zoomValue: Zoom[\"value\"] = 1 as NormalizedZoomValue,\n): boolean => {\n  if (points.length >= 3) {\n    const [first, last] = [points[0], points[points.length - 1]];\n    const distance = pointDistance(first, last);\n\n    // Adjusting LINE_CONFIRM_THRESHOLD to current zoom so that when zoomed in\n    // really close we make the threshold smaller, and vice versa.\n    return distance <= LINE_CONFIRM_THRESHOLD / zoomValue;\n  }\n  return false;\n};\n\nexport const getCornerRadius = (x: number, element: ExcalidrawElement) => {\n  if (\n    element.roundness?.type === ROUNDNESS.PROPORTIONAL_RADIUS ||\n    element.roundness?.type === ROUNDNESS.LEGACY\n  ) {\n    return x * DEFAULT_PROPORTIONAL_RADIUS;\n  }\n\n  if (element.roundness?.type === ROUNDNESS.ADAPTIVE_RADIUS) {\n    const fixedRadiusSize = element.roundness?.value ?? DEFAULT_ADAPTIVE_RADIUS;\n\n    const CUTOFF_SIZE = fixedRadiusSize / DEFAULT_PROPORTIONAL_RADIUS;\n\n    if (x <= CUTOFF_SIZE) {\n      return x * DEFAULT_PROPORTIONAL_RADIUS;\n    }\n\n    return fixedRadiusSize;\n  }\n\n  return 0;\n};\n",
    "import { ROUNDNESS, assertNever } from \"@excalidraw/common\";\n\nimport { pointsEqual } from \"@excalidraw/math\";\n\nimport type { ElementOrToolType } from \"excalidraw-custom/types\";\n\nimport type { MarkNonNullable } from \"@excalidraw/common/utility-types\";\n\nimport type { Bounds } from \"./bounds\";\nimport type {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawEmbeddableElement,\n  ExcalidrawLinearElement,\n  ExcalidrawBindableElement,\n  ExcalidrawFreeDrawElement,\n  InitializedExcalidrawImageElement,\n  ExcalidrawImageElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawTextContainer,\n  ExcalidrawFrameElement,\n  RoundnessType,\n  ExcalidrawFrameLikeElement,\n  ExcalidrawElementType,\n  ExcalidrawIframeElement,\n  ExcalidrawIframeLikeElement,\n  ExcalidrawMagicFrameElement,\n  ExcalidrawArrowElement,\n  ExcalidrawElbowArrowElement,\n  ExcalidrawLineElement,\n  PointBinding,\n  FixedPointBinding,\n  ExcalidrawFlowchartNodeElement,\n  ExcalidrawLinearElementSubType,\n} from \"./types\";\n\nexport const isInitializedImageElement = (\n  element: ExcalidrawElement | null,\n): element is InitializedExcalidrawImageElement => {\n  return !!element && element.type === \"image\" && !!element.fileId;\n};\n\nexport const isImageElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawImageElement => {\n  return !!element && element.type === \"image\";\n};\n\nexport const isEmbeddableElement = (\n  element: ExcalidrawElement | null | undefined,\n): element is ExcalidrawEmbeddableElement => {\n  return !!element && element.type === \"embeddable\";\n};\n\nexport const isIframeElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawIframeElement => {\n  return !!element && element.type === \"iframe\";\n};\n\nexport const isIframeLikeElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawIframeLikeElement => {\n  return (\n    !!element && (element.type === \"iframe\" || element.type === \"embeddable\")\n  );\n};\n\nexport const isTextElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElement => {\n  return element != null && element.type === \"text\";\n};\n\nexport const isFrameElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawFrameElement => {\n  return element != null && element.type === \"frame\";\n};\n\nexport const isMagicFrameElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawMagicFrameElement => {\n  return element != null && element.type === \"magicframe\";\n};\n\nexport const isFrameLikeElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawFrameLikeElement => {\n  return (\n    element != null &&\n    (element.type === \"frame\" || element.type === \"magicframe\")\n  );\n};\n\nexport const isFreeDrawElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawFreeDrawElement => {\n  return element != null && isFreeDrawElementType(element.type);\n};\n\nexport const isFreeDrawElementType = (\n  elementType: ExcalidrawElementType,\n): boolean => {\n  return elementType === \"freedraw\";\n};\n\nexport const isLinearElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return element != null && isLinearElementType(element.type);\n};\n\nexport const isLineElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLineElement => {\n  return element != null && element.type === \"line\";\n};\n\nexport const isArrowElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawArrowElement => {\n  return element != null && element.type === \"arrow\";\n};\n\nexport const isElbowArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawElbowArrowElement => {\n  return isArrowElement(element) && element.elbowed;\n};\n\n/**\n * sharp or curved arrow, but not elbow\n */\nexport const isSimpleArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawArrowElement => {\n  return isArrowElement(element) && !element.elbowed;\n};\n\nexport const isSharpArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawArrowElement => {\n  return isArrowElement(element) && !element.elbowed && !element.roundness;\n};\n\nexport const isCurvedArrow = (\n  element?: ExcalidrawElement,\n): element is ExcalidrawArrowElement => {\n  return (\n    isArrowElement(element) && !element.elbowed && element.roundness !== null\n  );\n};\n\nexport const isLinearElementType = (\n  elementType: ElementOrToolType,\n): boolean => {\n  return (\n    elementType === \"arrow\" || elementType === \"line\" // || elementType === \"freedraw\"\n  );\n};\n\nexport const isBindingElement = (\n  element?: ExcalidrawElement | null,\n  includeLocked = true,\n): element is ExcalidrawLinearElement => {\n  return (\n    element != null &&\n    (!element.locked || includeLocked === true) &&\n    isBindingElementType(element.type)\n  );\n};\n\nexport const isBindingElementType = (\n  elementType: ElementOrToolType,\n): boolean => {\n  return elementType === \"arrow\";\n};\n\nexport const isBindableElement = (\n  element: ExcalidrawElement | null | undefined,\n  includeLocked = true,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (!element.locked || includeLocked === true) &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\" ||\n      element.type === \"image\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      (element.type === \"text\" && !element.containerId))\n  );\n};\n\nexport const isRectanguloidElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"image\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      (element.type === \"text\" && !element.containerId))\n  );\n};\n\n// TODO: Remove this when proper distance calculation is introduced\n// @see binding.ts:distanceToBindableElement()\nexport const isRectangularElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawBindableElement => {\n  return (\n    element != null &&\n    (element.type === \"rectangle\" ||\n      element.type === \"image\" ||\n      element.type === \"text\" ||\n      element.type === \"iframe\" ||\n      element.type === \"embeddable\" ||\n      element.type === \"frame\" ||\n      element.type === \"magicframe\" ||\n      element.type === \"freedraw\")\n  );\n};\n\nexport const isTextBindableContainer = (\n  element: ExcalidrawElement | null,\n  includeLocked = true,\n): element is ExcalidrawTextContainer => {\n  return (\n    element != null &&\n    (!element.locked || includeLocked === true) &&\n    (element.type === \"rectangle\" ||\n      element.type === \"diamond\" ||\n      element.type === \"ellipse\" ||\n      isArrowElement(element))\n  );\n};\n\nexport const isExcalidrawElement = (\n  element: any,\n): element is ExcalidrawElement => {\n  const type: ExcalidrawElementType | undefined = element?.type;\n  if (!type) {\n    return false;\n  }\n  switch (type) {\n    case \"text\":\n    case \"diamond\":\n    case \"rectangle\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"ellipse\":\n    case \"arrow\":\n    case \"freedraw\":\n    case \"line\":\n    case \"frame\":\n    case \"magicframe\":\n    case \"image\":\n    case \"selection\": {\n      return true;\n    }\n    default: {\n      assertNever(type, null);\n      return false;\n    }\n  }\n};\n\nexport const isFlowchartNodeElement = (\n  element: ExcalidrawElement,\n): element is ExcalidrawFlowchartNodeElement => {\n  return (\n    element.type === \"rectangle\" ||\n    element.type === \"ellipse\" ||\n    element.type === \"diamond\"\n  );\n};\n\nexport const hasBoundTextElement = (\n  element: ExcalidrawElement | null,\n): element is MarkNonNullable<ExcalidrawBindableElement, \"boundElements\"> => {\n  return (\n    isTextBindableContainer(element) &&\n    !!element.boundElements?.some(({ type }) => type === \"text\")\n  );\n};\n\nexport const isBoundToContainer = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElementWithContainer => {\n  return (\n    element !== null &&\n    \"containerId\" in element &&\n    element.containerId !== null &&\n    isTextElement(element)\n  );\n};\n\nexport const isArrowBoundToElement = (element: ExcalidrawArrowElement) => {\n  return !!element.startBinding || !!element.endBinding;\n};\n\nexport const isUsingAdaptiveRadius = (type: string) =>\n  type === \"rectangle\" ||\n  type === \"embeddable\" ||\n  type === \"iframe\" ||\n  type === \"image\";\n\nexport const isUsingProportionalRadius = (type: string) =>\n  type === \"line\" || type === \"arrow\" || type === \"diamond\";\n\nexport const canApplyRoundnessTypeToElement = (\n  roundnessType: RoundnessType,\n  element: ExcalidrawElement,\n) => {\n  if (\n    (roundnessType === ROUNDNESS.ADAPTIVE_RADIUS ||\n      // if legacy roundness, it can be applied to elements that currently\n      // use adaptive radius\n      roundnessType === ROUNDNESS.LEGACY) &&\n    isUsingAdaptiveRadius(element.type)\n  ) {\n    return true;\n  }\n  if (\n    roundnessType === ROUNDNESS.PROPORTIONAL_RADIUS &&\n    isUsingProportionalRadius(element.type)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const getDefaultRoundnessTypeForElement = (\n  element: ExcalidrawElement,\n) => {\n  if (isUsingProportionalRadius(element.type)) {\n    return {\n      type: ROUNDNESS.PROPORTIONAL_RADIUS,\n    };\n  }\n\n  if (isUsingAdaptiveRadius(element.type)) {\n    return {\n      type: ROUNDNESS.ADAPTIVE_RADIUS,\n    };\n  }\n\n  return null;\n};\n\nexport const isFixedPointBinding = (\n  binding: PointBinding | FixedPointBinding,\n): binding is FixedPointBinding => {\n  return (\n    Object.hasOwn(binding, \"fixedPoint\") &&\n    (binding as FixedPointBinding).fixedPoint != null\n  );\n};\n\n// TODO: Move this to @excalidraw/math\nexport const isBounds = (box: unknown): box is Bounds =>\n  Array.isArray(box) &&\n  box.length === 4 &&\n  typeof box[0] === \"number\" &&\n  typeof box[1] === \"number\" &&\n  typeof box[2] === \"number\" &&\n  typeof box[3] === \"number\";\n\nexport const getLinearElementSubType = (\n  element: ExcalidrawLinearElement,\n): ExcalidrawLinearElementSubType => {\n  if (isSharpArrow(element)) {\n    return \"sharpArrow\";\n  }\n  if (isCurvedArrow(element)) {\n    return \"curvedArrow\";\n  }\n  if (isElbowArrow(element)) {\n    return \"elbowArrow\";\n  }\n  return \"line\";\n};\n\n/**\n * Checks if current element points meet all the conditions for polygon=true\n * (this isn't a element type check, for that use isLineElement).\n *\n * If you want to check if points *can* be turned into a polygon, use\n *  canBecomePolygon(points).\n */\nexport const isValidPolygon = (\n  points: ExcalidrawLineElement[\"points\"],\n): boolean => {\n  return points.length > 3 && pointsEqual(points[0], points[points.length - 1]);\n};\n\nexport const canBecomePolygon = (\n  points: ExcalidrawLineElement[\"points\"],\n): boolean => {\n  return (\n    points.length > 3 ||\n    // 3-point polygons can't have all points in a single line\n    (points.length === 3 && !pointsEqual(points[0], points[points.length - 1]))\n  );\n};\n",
    "import {\n  ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO,\n  ARROW_LABEL_WIDTH_FRACTION,\n  BOUND_TEXT_PADDING,\n  DEFAULT_FONT_SIZE,\n  TEXT_ALIGN,\n  VERTICAL_ALIGN,\n  getFontString,\n  isProdEnv,\n  invariant,\n} from \"@excalidraw/common\";\n\nimport type { AppState } from \"excalidraw-custom/types\";\n\nimport type { ExtractSetType } from \"@excalidraw/common/utility-types\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport {\n  resetOriginalContainerCache,\n  updateOriginalContainerCache,\n} from \"./containerCache\";\nimport { LinearElementEditor } from \"./linearElementEditor\";\n\nimport { measureText } from \"./textMeasurements\";\nimport { wrapText } from \"./textWrapping\";\nimport {\n  isBoundToContainer,\n  isArrowElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport type { Scene } from \"./Scene\";\n\nimport type { MaybeTransformHandleType } from \"./transformHandles\";\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  ExcalidrawElementType,\n  ExcalidrawTextContainer,\n  ExcalidrawTextElement,\n  ExcalidrawTextElementWithContainer,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\nexport const redrawTextBoundingBox = (\n  textElement: ExcalidrawTextElement,\n  container: ExcalidrawElement | null,\n  scene: Scene,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  let maxWidth = undefined;\n\n  if (!isProdEnv()) {\n    invariant(\n      !container || !isArrowElement(container) || textElement.angle === 0,\n      \"text element angle must be 0 if bound to arrow container\",\n    );\n  }\n\n  const boundTextUpdates = {\n    x: textElement.x,\n    y: textElement.y,\n    text: textElement.text,\n    width: textElement.width,\n    height: textElement.height,\n    angle: (container\n      ? isArrowElement(container)\n        ? 0\n        : container.angle\n      : textElement.angle) as Radians,\n  };\n\n  boundTextUpdates.text = textElement.text;\n\n  if (container || !textElement.autoResize) {\n    maxWidth = container\n      ? getBoundTextMaxWidth(container, textElement)\n      : textElement.width;\n    boundTextUpdates.text = wrapText(\n      textElement.originalText,\n      getFontString(textElement),\n      maxWidth,\n    );\n  }\n\n  const metrics = measureText(\n    boundTextUpdates.text,\n    getFontString(textElement),\n    textElement.lineHeight,\n  );\n\n  // Note: only update width for unwrapped text and bound texts (which always have autoResize set to true)\n  if (textElement.autoResize) {\n    boundTextUpdates.width = metrics.width;\n  }\n  boundTextUpdates.height = metrics.height;\n\n  if (container) {\n    const maxContainerHeight = getBoundTextMaxHeight(\n      container,\n      textElement as ExcalidrawTextElementWithContainer,\n    );\n    const maxContainerWidth = getBoundTextMaxWidth(container, textElement);\n\n    if (!isArrowElement(container) && metrics.height > maxContainerHeight) {\n      const nextHeight = computeContainerDimensionForBoundText(\n        metrics.height,\n        container.type,\n      );\n      scene.mutateElement(container, { height: nextHeight });\n      updateOriginalContainerCache(container.id, nextHeight);\n    }\n\n    if (metrics.width > maxContainerWidth) {\n      const nextWidth = computeContainerDimensionForBoundText(\n        metrics.width,\n        container.type,\n      );\n      scene.mutateElement(container, { width: nextWidth });\n    }\n\n    const updatedTextElement = {\n      ...textElement,\n      ...boundTextUpdates,\n    } as ExcalidrawTextElementWithContainer;\n\n    const { x, y } = computeBoundTextPosition(\n      container,\n      updatedTextElement,\n      elementsMap,\n    );\n\n    boundTextUpdates.x = x;\n    boundTextUpdates.y = y;\n  }\n\n  scene.mutateElement(textElement, boundTextUpdates);\n};\n\nexport const handleBindTextResize = (\n  container: NonDeletedExcalidrawElement,\n  scene: Scene,\n  transformHandleType: MaybeTransformHandleType,\n  shouldMaintainAspectRatio = false,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const boundTextElementId = getBoundTextElementId(container);\n  if (!boundTextElementId) {\n    return;\n  }\n  resetOriginalContainerCache(container.id);\n  const textElement = getBoundTextElement(container, elementsMap);\n  if (textElement && textElement.text) {\n    if (!container) {\n      return;\n    }\n\n    let text = textElement.text;\n    let nextHeight = textElement.height;\n    let nextWidth = textElement.width;\n    const maxWidth = getBoundTextMaxWidth(container, textElement);\n    const maxHeight = getBoundTextMaxHeight(container, textElement);\n    let containerHeight = container.height;\n    if (\n      shouldMaintainAspectRatio ||\n      (transformHandleType !== \"n\" && transformHandleType !== \"s\")\n    ) {\n      if (text) {\n        text = wrapText(\n          textElement.originalText,\n          getFontString(textElement),\n          maxWidth,\n        );\n      }\n      const metrics = measureText(\n        text,\n        getFontString(textElement),\n        textElement.lineHeight,\n      );\n      nextHeight = metrics.height;\n      nextWidth = metrics.width;\n    }\n    // increase height in case text element height exceeds\n    if (nextHeight > maxHeight) {\n      containerHeight = computeContainerDimensionForBoundText(\n        nextHeight,\n        container.type,\n      );\n\n      const diff = containerHeight - container.height;\n      // fix the y coord when resizing from ne/nw/n\n      const updatedY =\n        !isArrowElement(container) &&\n        (transformHandleType === \"ne\" ||\n          transformHandleType === \"nw\" ||\n          transformHandleType === \"n\")\n          ? container.y - diff\n          : container.y;\n      scene.mutateElement(container, {\n        height: containerHeight,\n        y: updatedY,\n      });\n    }\n\n    scene.mutateElement(textElement, {\n      text,\n      width: nextWidth,\n      height: nextHeight,\n    });\n\n    if (!isArrowElement(container)) {\n      scene.mutateElement(\n        textElement,\n        computeBoundTextPosition(container, textElement, elementsMap),\n      );\n    }\n  }\n};\n\nexport const computeBoundTextPosition = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n  elementsMap: ElementsMap,\n) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(\n      container,\n      boundTextElement,\n      elementsMap,\n    );\n  }\n  const containerCoords = getContainerCoords(container);\n  const maxContainerHeight = getBoundTextMaxHeight(container, boundTextElement);\n  const maxContainerWidth = getBoundTextMaxWidth(container, boundTextElement);\n\n  let x;\n  let y;\n  if (boundTextElement.verticalAlign === VERTICAL_ALIGN.TOP) {\n    y = containerCoords.y;\n  } else if (boundTextElement.verticalAlign === VERTICAL_ALIGN.BOTTOM) {\n    y = containerCoords.y + (maxContainerHeight - boundTextElement.height);\n  } else {\n    y =\n      containerCoords.y +\n      (maxContainerHeight / 2 - boundTextElement.height / 2);\n  }\n  if (boundTextElement.textAlign === TEXT_ALIGN.LEFT) {\n    x = containerCoords.x;\n  } else if (boundTextElement.textAlign === TEXT_ALIGN.RIGHT) {\n    x = containerCoords.x + (maxContainerWidth - boundTextElement.width);\n  } else {\n    x =\n      containerCoords.x + (maxContainerWidth / 2 - boundTextElement.width / 2);\n  }\n  return { x, y };\n};\n\nexport const getBoundTextElementId = (container: ExcalidrawElement | null) => {\n  return container?.boundElements?.length\n    ? container?.boundElements?.find((ele) => ele.type === \"text\")?.id || null\n    : null;\n};\n\nexport const getBoundTextElement = (\n  element: ExcalidrawElement | null,\n  elementsMap: ElementsMap,\n) => {\n  if (!element) {\n    return null;\n  }\n  const boundTextElementId = getBoundTextElementId(element);\n\n  if (boundTextElementId) {\n    return (elementsMap.get(boundTextElementId) ||\n      null) as ExcalidrawTextElementWithContainer | null;\n  }\n  return null;\n};\n\nexport const getContainerElement = (\n  element: ExcalidrawTextElement | null,\n  elementsMap: ElementsMap,\n): ExcalidrawTextContainer | null => {\n  if (!element) {\n    return null;\n  }\n  if (element.containerId) {\n    return (elementsMap.get(element.containerId) ||\n      null) as ExcalidrawTextContainer | null;\n  }\n  return null;\n};\n\nexport const getContainerCenter = (\n  container: ExcalidrawElement,\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  if (!isArrowElement(container)) {\n    return {\n      x: container.x + container.width / 2,\n      y: container.y + container.height / 2,\n    };\n  }\n  const points = LinearElementEditor.getPointsGlobalCoordinates(\n    container,\n    elementsMap,\n  );\n  if (points.length % 2 === 1) {\n    const index = Math.floor(container.points.length / 2);\n    const midPoint = LinearElementEditor.getPointGlobalCoordinates(\n      container,\n      container.points[index],\n      elementsMap,\n    );\n    return { x: midPoint[0], y: midPoint[1] };\n  }\n  const index = container.points.length / 2 - 1;\n  let midSegmentMidpoint = LinearElementEditor.getEditorMidPoints(\n    container,\n    elementsMap,\n    appState,\n  )[index];\n  if (!midSegmentMidpoint) {\n    midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(\n      container,\n      index + 1,\n    );\n  }\n  return { x: midSegmentMidpoint[0], y: midSegmentMidpoint[1] };\n};\n\nexport const getContainerCoords = (container: NonDeletedExcalidrawElement) => {\n  let offsetX = BOUND_TEXT_PADDING;\n  let offsetY = BOUND_TEXT_PADDING;\n\n  if (container.type === \"ellipse\") {\n    // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6172\n    offsetX += (container.width / 2) * (1 - Math.sqrt(2) / 2);\n    offsetY += (container.height / 2) * (1 - Math.sqrt(2) / 2);\n  }\n  // The derivation of coordinates is explained in https://github.com/excalidraw/excalidraw/pull/6265\n  if (container.type === \"diamond\") {\n    offsetX += container.width / 4;\n    offsetY += container.height / 4;\n  }\n  return {\n    x: container.x + offsetX,\n    y: container.y + offsetY,\n  };\n};\n\nexport const getTextElementAngle = (\n  textElement: ExcalidrawTextElement,\n  container: ExcalidrawTextContainer | null,\n) => {\n  if (isArrowElement(container)) {\n    return 0;\n  }\n  if (!container) {\n    return textElement.angle;\n  }\n  return container.angle;\n};\n\nexport const getBoundTextElementPosition = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n  elementsMap: ElementsMap,\n) => {\n  if (isArrowElement(container)) {\n    return LinearElementEditor.getBoundTextElementPosition(\n      container,\n      boundTextElement,\n      elementsMap,\n    );\n  }\n};\n\nexport const shouldAllowVerticalAlign = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  elementsMap: ElementsMap,\n) => {\n  return selectedElements.some((element) => {\n    if (isBoundToContainer(element)) {\n      const container = getContainerElement(element, elementsMap);\n      if (isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  });\n};\n\nexport const suppportsHorizontalAlign = (\n  selectedElements: NonDeletedExcalidrawElement[],\n  elementsMap: ElementsMap,\n) => {\n  return selectedElements.some((element) => {\n    if (isBoundToContainer(element)) {\n      const container = getContainerElement(element, elementsMap);\n      if (isArrowElement(container)) {\n        return false;\n      }\n      return true;\n    }\n\n    return isTextElement(element);\n  });\n};\n\nconst VALID_CONTAINER_TYPES = new Set([\n  \"rectangle\",\n  \"ellipse\",\n  \"diamond\",\n  \"arrow\",\n]);\n\nexport const isValidTextContainer = (element: {\n  type: ExcalidrawElementType;\n}) => VALID_CONTAINER_TYPES.has(element.type);\n\nexport const computeContainerDimensionForBoundText = (\n  dimension: number,\n  containerType: ExtractSetType<typeof VALID_CONTAINER_TYPES>,\n) => {\n  dimension = Math.ceil(dimension);\n  const padding = BOUND_TEXT_PADDING * 2;\n\n  if (containerType === \"ellipse\") {\n    return Math.round(((dimension + padding) / Math.sqrt(2)) * 2);\n  }\n  if (containerType === \"arrow\") {\n    return dimension + padding * 8;\n  }\n  if (containerType === \"diamond\") {\n    return 2 * (dimension + padding);\n  }\n  return dimension + padding;\n};\n\nexport const getBoundTextMaxWidth = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElement | null,\n) => {\n  const { width } = container;\n  if (isArrowElement(container)) {\n    const minWidth =\n      (boundTextElement?.fontSize ?? DEFAULT_FONT_SIZE) *\n      ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO;\n    return Math.max(ARROW_LABEL_WIDTH_FRACTION * width, minWidth);\n  }\n  if (container.type === \"ellipse\") {\n    // The width of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.width / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse -https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round((width / 2) * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The width of the largest rectangle inscribed inside a rhombus is\n    // Math.round(width / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(width / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  return width - BOUND_TEXT_PADDING * 2;\n};\n\nexport const getBoundTextMaxHeight = (\n  container: ExcalidrawElement,\n  boundTextElement: ExcalidrawTextElementWithContainer,\n) => {\n  const { height } = container;\n  if (isArrowElement(container)) {\n    const containerHeight = height - BOUND_TEXT_PADDING * 8 * 2;\n    if (containerHeight <= 0) {\n      return boundTextElement.height;\n    }\n    return height;\n  }\n  if (container.type === \"ellipse\") {\n    // The height of the largest rectangle inscribed inside an ellipse is\n    // Math.round((ellipse.height / 2) * Math.sqrt(2)) which is derived from\n    // equation of an ellipse - https://github.com/excalidraw/excalidraw/pull/6172\n    return Math.round((height / 2) * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;\n  }\n  if (container.type === \"diamond\") {\n    // The height of the largest rectangle inscribed inside a rhombus is\n    // Math.round(height / 2) - https://github.com/excalidraw/excalidraw/pull/6265\n    return Math.round(height / 2) - BOUND_TEXT_PADDING * 2;\n  }\n  return height - BOUND_TEXT_PADDING * 2;\n};\n\n/** retrieves text from text elements and concatenates to a single string */\nexport const getTextFromElements = (\n  elements: readonly ExcalidrawElement[],\n  separator = \"\\n\\n\",\n) => {\n  const text = elements\n    .reduce((acc: string[], element) => {\n      if (isTextElement(element)) {\n        acc.push(element.text);\n      }\n      return acc;\n    }, [])\n    .join(separator);\n  return text;\n};\n",
    "import {\n  BOUND_TEXT_PADDING,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_FONT_FAMILY,\n  getFontString,\n  isTestEnv,\n  normalizeEOL,\n} from \"@excalidraw/common\";\n\nimport type { FontString, ExcalidrawTextElement } from \"./types\";\n\nexport const measureText = (\n  text: string,\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const _text = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    // lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const fontSize = parseFloat(font);\n  const height = getTextHeight(_text, fontSize, lineHeight);\n  const width = getTextWidth(_text, font);\n  return { width, height };\n};\n\nconst DUMMY_TEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toLocaleUpperCase();\n\n// FIXME rename to getApproxMinContainerWidth\nexport const getApproxMinLineWidth = (\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const maxCharWidth = getMaxCharWidth(font);\n  if (maxCharWidth === 0) {\n    return (\n      measureText(DUMMY_TEXT.split(\"\").join(\"\\n\"), font, lineHeight).width +\n      BOUND_TEXT_PADDING * 2\n    );\n  }\n  return maxCharWidth + BOUND_TEXT_PADDING * 2;\n};\n\nexport const getMinTextElementWidth = (\n  font: FontString,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return measureText(\"\", font, lineHeight).width + BOUND_TEXT_PADDING * 2;\n};\n\nexport const isMeasureTextSupported = () => {\n  const width = getTextWidth(\n    DUMMY_TEXT,\n    getFontString({\n      fontSize: DEFAULT_FONT_SIZE,\n      fontFamily: DEFAULT_FONT_FAMILY,\n    }),\n  );\n  return width > 0;\n};\n\nexport const normalizeText = (text: string) => {\n  return (\n    normalizeEOL(text)\n      // replace tabs with spaces so they render and measure correctly\n      .replace(/\\t/g, \"        \")\n  );\n};\n\nconst splitIntoLines = (text: string) => {\n  return normalizeText(text).split(\"\\n\");\n};\n\n/**\n * To get unitless line-height (if unknown) we can calculate it by dividing\n * height-per-line by fontSize.\n */\nexport const detectLineHeight = (textElement: ExcalidrawTextElement) => {\n  const lineCount = splitIntoLines(textElement.text).length;\n  return (textElement.height /\n    lineCount /\n    textElement.fontSize) as ExcalidrawTextElement[\"lineHeight\"];\n};\n\n/**\n * We calculate the line height from the font size and the unitless line height,\n * aligning with the W3C spec.\n */\nexport const getLineHeightInPx = (\n  fontSize: ExcalidrawTextElement[\"fontSize\"],\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return fontSize * lineHeight;\n};\n\n// FIXME rename to getApproxMinContainerHeight\nexport const getApproxMinLineHeight = (\n  fontSize: ExcalidrawTextElement[\"fontSize\"],\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  return getLineHeightInPx(fontSize, lineHeight) + BOUND_TEXT_PADDING * 2;\n};\n\nlet textMetricsProvider: TextMetricsProvider | undefined;\n\n/**\n * Set a custom text metrics provider.\n *\n * Useful for overriding the width calculation algorithm where canvas API is not available / desired.\n */\nexport const setCustomTextMetricsProvider = (provider: TextMetricsProvider) => {\n  textMetricsProvider = provider;\n};\n\nexport interface TextMetricsProvider {\n  getLineWidth(text: string, fontString: FontString): number;\n}\n\nclass CanvasTextMetricsProvider implements TextMetricsProvider {\n  private canvas: HTMLCanvasElement;\n\n  constructor() {\n    this.canvas = document.createElement(\"canvas\");\n  }\n\n  /**\n   * We need to use the advance width as that's the closest thing to the browser wrapping algo, hence using it for:\n   * - text wrapping\n   * - wysiwyg editor (+padding)\n   *\n   * > The advance width is the distance between the glyph's initial pen position and the next glyph's initial pen position.\n   */\n  public getLineWidth(text: string, fontString: FontString): number {\n    const context = this.canvas.getContext(\"2d\")!;\n    context.font = fontString;\n    const metrics = context.measureText(text);\n    const advanceWidth = metrics.width;\n\n    // since in test env the canvas measureText algo\n    // doesn't measure text and instead just returns number of\n    // characters hence we assume that each letteris 10px\n    if (isTestEnv()) {\n      return advanceWidth * 10;\n    }\n\n    return advanceWidth;\n  }\n}\n\nexport const getLineWidth = (text: string, font: FontString) => {\n  if (!textMetricsProvider) {\n    textMetricsProvider = new CanvasTextMetricsProvider();\n  }\n\n  return textMetricsProvider.getLineWidth(text, font);\n};\n\nexport const getTextWidth = (text: string, font: FontString) => {\n  const lines = splitIntoLines(text);\n  let width = 0;\n  lines.forEach((line) => {\n    width = Math.max(width, getLineWidth(line, font));\n  });\n\n  return width;\n};\n\nexport const getTextHeight = (\n  text: string,\n  fontSize: number,\n  lineHeight: ExcalidrawTextElement[\"lineHeight\"],\n) => {\n  const lineCount = splitIntoLines(text).length;\n  return getLineHeightInPx(fontSize, lineHeight) * lineCount;\n};\n\nexport const charWidth = (() => {\n  const cachedCharWidth: { [key: FontString]: Array<number> } = {};\n\n  const calculate = (char: string, font: FontString) => {\n    const unicode = char.charCodeAt(0);\n    if (!cachedCharWidth[font]) {\n      cachedCharWidth[font] = [];\n    }\n    if (!cachedCharWidth[font][unicode]) {\n      const width = getLineWidth(char, font);\n      cachedCharWidth[font][unicode] = width;\n    }\n\n    return cachedCharWidth[font][unicode];\n  };\n\n  const getCache = (font: FontString) => {\n    return cachedCharWidth[font];\n  };\n\n  const clearCache = (font: FontString) => {\n    cachedCharWidth[font] = [];\n  };\n\n  return {\n    calculate,\n    getCache,\n    clearCache,\n  };\n})();\n\nexport const getMinCharWidth = (font: FontString) => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter((val) => val !== undefined);\n\n  return Math.min(...cacheWithOutEmpty);\n};\n\nexport const getMaxCharWidth = (font: FontString) => {\n  const cache = charWidth.getCache(font);\n  if (!cache) {\n    return 0;\n  }\n  const cacheWithOutEmpty = cache.filter((val) => val !== undefined);\n  return Math.max(...cacheWithOutEmpty);\n};\n",
    "import { isDevEnv, isTestEnv } from \"@excalidraw/common\";\n\nimport { charWidth, getLineWidth } from \"./textMeasurements\";\n\nimport type { FontString } from \"./types\";\n\nlet cachedCjkRegex: RegExp | undefined;\nlet cachedLineBreakRegex: RegExp | undefined;\nlet cachedEmojiRegex: RegExp | undefined;\n\n/**\n * Test if a given text contains any CJK characters (including symbols, punctuation, etc,).\n */\nexport const containsCJK = (text: string) => {\n  if (!cachedCjkRegex) {\n    cachedCjkRegex = Regex.class(...Object.values(CJK));\n  }\n\n  return cachedCjkRegex.test(text);\n};\n\nconst getLineBreakRegex = () => {\n  if (!cachedLineBreakRegex) {\n    try {\n      cachedLineBreakRegex = getLineBreakRegexAdvanced();\n    } catch {\n      cachedLineBreakRegex = getLineBreakRegexSimple();\n    }\n  }\n\n  return cachedLineBreakRegex;\n};\n\nconst getEmojiRegex = () => {\n  if (!cachedEmojiRegex) {\n    cachedEmojiRegex = getEmojiRegexUnicode();\n  }\n\n  return cachedEmojiRegex;\n};\n\n/**\n * Common symbols used across different languages.\n */\nconst COMMON = {\n  /**\n   * Natural breaking points for any grammars.\n   *\n   * Hello world\n   *      ↑ BREAK ALWAYS \" \" → [\"Hello\", \" \", \"world\"]\n   * Hello-world\n   *       ↑ BREAK AFTER \"-\" → [\"Hello-\", \"world\"]\n   */\n  WHITESPACE: /\\s/u,\n  HYPHEN: /-/u,\n  /**\n   * Generally do not break, unless closed symbol is followed by an opening symbol.\n   *\n   * Also, western punctation is often used in modern Korean and expects to be treated\n   * similarly to the CJK opening and closing symbols.\n   *\n   * Hello(한글)→ [\"Hello\", \"(한\", \"글)\"]\n   *      ↑ BREAK BEFORE \"(\"\n   *          ↑ BREAK AFTER \")\"\n   */\n  OPENING: /<\\(\\[\\{/u,\n  CLOSING: />\\)\\]\\}.,:;!\\?…\\//u,\n};\n\n/**\n * Characters and symbols used in Chinese, Japanese and Korean.\n */\nconst CJK = {\n  /**\n   * Every CJK breaks before and after, unless it's paired with an opening or closing symbol.\n   *\n   * Does not include every possible char used in CJK texts, such as currency, parentheses or punctuation.\n   */\n  CHAR: /\\p{Script=Han}\\p{Script=Hiragana}\\p{Script=Katakana}\\p{Script=Hangul}｀＇＾〃〰〆＃＆＊＋－ー／＼＝｜￤〒￢￣/u,\n  /**\n   * Opening and closing CJK punctuation breaks before and after all such characters (in case of many),\n   * and creates pairs with neighboring characters.\n   *\n   * Hello た。→ [\"Hello\", \"た。\"]\n   *        ↑ DON'T BREAK \"た。\"\n   * * Hello「た」 World → [\"Hello\", \"「た」\", \"World\"]\n   *       ↑ DON'T BREAK \"「た\"\n   *        ↑ DON'T BREAK \"た\"\n   *      ↑ BREAK BEFORE \"「\"\n   *         ↑ BREAK AFTER \"」\"\n   */\n  // eslint-disable-next-line prettier/prettier\n  OPENING:/（［｛〈《｟｢「『【〖〔〘〚＜〝/u,\n  CLOSING: /）］｝〉》｠｣」』】〗〕〙〛＞。．，、〟‥？！：；・〜〞/u,\n  /**\n   * Currency symbols break before, not after\n   *\n   * Price￥100 → [\"Price\", \"￥100\"]\n   *      ↑ BREAK BEFORE \"￥\"\n   */\n  CURRENCY: /￥￦￡￠＄/u,\n};\n\nconst EMOJI = {\n  FLAG: /\\p{RI}\\p{RI}/u,\n  JOINER:\n    /(?:\\p{Emoji_Modifier}|\\uFE0F\\u20E3?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?/u,\n  ZWJ: /\\u200D/u,\n  ANY: /[\\p{Emoji}]/u,\n  MOST: /[\\p{Extended_Pictographic}\\p{Emoji_Presentation}]/u,\n};\n\n/**\n * Simple fallback for browsers (mainly Safari < 16.4) that don't support \"Lookbehind assertion\".\n *\n * Browser support as of 10/2024:\n * - 91% Lookbehind assertion https://caniuse.com/mdn-javascript_regular_expressions_lookbehind_assertion\n * - 94% Unicode character class escape https://caniuse.com/mdn-javascript_regular_expressions_unicode_character_class_escape\n *\n * Does not include advanced CJK breaking rules, but covers most of the core cases, especially for latin.\n */\nconst getLineBreakRegexSimple = () =>\n  Regex.or(\n    getEmojiRegex(),\n    Break.On(COMMON.HYPHEN, COMMON.WHITESPACE, CJK.CHAR),\n  );\n\n/**\n * Specifies the line breaking rules based for alphabetic-based languages,\n * Chinese, Japanese, Korean and Emojis.\n *\n * \"Hello-world\" → [\"Hello-\", \"world\"]\n * \"Hello 「世界。」🌎🗺\" → [\"Hello\", \" \", \"「世\", \"界。」\", \"🌎\", \"🗺\"]\n */\nconst getLineBreakRegexAdvanced = () =>\n  Regex.or(\n    // Unicode-defined regex for (multi-codepoint) Emojis\n    getEmojiRegex(),\n    // Rules for whitespace and hyphen\n    Break.Before(COMMON.WHITESPACE).Build(),\n    Break.After(COMMON.WHITESPACE, COMMON.HYPHEN).Build(),\n    // Rules for CJK (chars, symbols, currency)\n    Break.Before(CJK.CHAR, CJK.CURRENCY)\n      .NotPrecededBy(COMMON.OPENING, CJK.OPENING)\n      .Build(),\n    Break.After(CJK.CHAR)\n      .NotFollowedBy(COMMON.HYPHEN, COMMON.CLOSING, CJK.CLOSING)\n      .Build(),\n    // Rules for opening and closing punctuation\n    Break.BeforeMany(CJK.OPENING).NotPrecededBy(COMMON.OPENING).Build(),\n    Break.AfterMany(CJK.CLOSING).NotFollowedBy(COMMON.CLOSING).Build(),\n    Break.AfterMany(COMMON.CLOSING).FollowedBy(COMMON.OPENING).Build(),\n  );\n\n/**\n * Matches various emoji types.\n *\n * 1. basic emojis (😀, 🌍)\n * 2. flags (🇨🇿)\n * 3. multi-codepoint emojis:\n *    - skin tones (👍🏽)\n *    - variation selectors (☂️)\n *    - keycaps (1️⃣)\n *    - tag sequences (🏴󠁧󠁢󠁥󠁮󠁧󠁿)\n *    - emoji sequences (👨‍👩‍👧‍👦, 👩‍🚀, 🏳️‍🌈)\n *\n * Unicode points:\n * - \\uFE0F: presentation selector\n * - \\u20E3: enclosing keycap\n * - \\u200D: zero width joiner\n * - \\u{E0020}-\\u{E007E}: tags\n * - \\u{E007F}: cancel tag\n *\n * @see https://unicode.org/reports/tr51/#EBNF_and_Regex, with changes:\n * - replaced \\p{Emoji} with [\\p{Extended_Pictographic}\\p{Emoji_Presentation}], see more in `should tokenize emojis mixed with mixed text` test\n * - replaced \\p{Emod} with \\p{Emoji_Modifier} as some engines do not understand the abbreviation (i.e. https://devina.io/redos-checker)\n */\nconst getEmojiRegexUnicode = () =>\n  Regex.group(\n    Regex.or(\n      EMOJI.FLAG,\n      Regex.and(\n        EMOJI.MOST,\n        EMOJI.JOINER,\n        Regex.build(\n          `(?:${EMOJI.ZWJ.source}(?:${EMOJI.FLAG.source}|${EMOJI.ANY.source}${EMOJI.JOINER.source}))*`,\n        ),\n      ),\n    ),\n  );\n\n/**\n * Regex utilities for unicode character classes.\n */\nconst Regex = {\n  /**\n   * Builds a regex from a string.\n   */\n  build: (regex: string): RegExp => new RegExp(regex, \"u\"),\n  /**\n   * Joins regexes into a single string.\n   */\n  join: (...regexes: RegExp[]): string => regexes.map((x) => x.source).join(\"\"),\n  /**\n   * Joins regexes into a single regex as with \"and\" operator.\n   */\n  and: (...regexes: RegExp[]): RegExp => Regex.build(Regex.join(...regexes)),\n  /**\n   * Joins regexes into a single regex with \"or\" operator.\n   */\n  or: (...regexes: RegExp[]): RegExp =>\n    Regex.build(regexes.map((x) => x.source).join(\"|\")),\n  /**\n   * Puts regexes into a matching group.\n   */\n  group: (...regexes: RegExp[]): RegExp =>\n    Regex.build(`(${Regex.join(...regexes)})`),\n  /**\n   * Puts regexes into a character class.\n   */\n  class: (...regexes: RegExp[]): RegExp =>\n    Regex.build(`[${Regex.join(...regexes)}]`),\n};\n\n/**\n * Human-readable lookahead and lookbehind utilities for defining line break\n * opportunities between pairs of character classes.\n */\nconst Break = {\n  /**\n   * Break on the given class of characters.\n   */\n  On: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    return Regex.build(`([${joined}])`);\n  },\n  /**\n   * Break before the given class of characters.\n   */\n  Before: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?=[${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"FollowedBy\"\n    >;\n  },\n  /**\n   * Break after the given class of characters.\n   */\n  After: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<=[${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"PreceededBy\"\n    >;\n  },\n  /**\n   * Break before one or multiple characters of the same class.\n   */\n  BeforeMany: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<![${joined}])(?=[${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"FollowedBy\"\n    >;\n  },\n  /**\n   * Break after one or multiple character from the same class.\n   */\n  AfterMany: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<=[${joined}])(?![${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"PreceededBy\"\n    >;\n  },\n  /**\n   * Do not break before the given class of characters.\n   */\n  NotBefore: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?![${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"NotFollowedBy\"\n    >;\n  },\n  /**\n   * Do not break after the given class of characters.\n   */\n  NotAfter: (...regexes: RegExp[]) => {\n    const joined = Regex.join(...regexes);\n    const builder = () => Regex.build(`(?<![${joined}])`);\n    return Break.Chain(builder) as Omit<\n      ReturnType<typeof Break.Chain>,\n      \"NotPrecededBy\"\n    >;\n  },\n  Chain: (rootBuilder: () => RegExp) => ({\n    /**\n     * Build the root regex.\n     */\n    Build: rootBuilder,\n    /**\n     * Specify additional class of characters that should precede the root regex.\n     */\n    PreceededBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const preceeded = Break.After(...regexes).Build();\n      const builder = () => Regex.and(preceeded, root);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"PreceededBy\"\n      >;\n    },\n    /**\n     * Specify additional class of characters that should follow the root regex.\n     */\n    FollowedBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const followed = Break.Before(...regexes).Build();\n      const builder = () => Regex.and(root, followed);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"FollowedBy\"\n      >;\n    },\n    /**\n     * Specify additional class of characters that should not precede the root regex.\n     */\n    NotPrecededBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const notPreceeded = Break.NotAfter(...regexes).Build();\n      const builder = () => Regex.and(notPreceeded, root);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"NotPrecededBy\"\n      >;\n    },\n    /**\n     * Specify additional class of characters that should not follow the root regex.\n     */\n    NotFollowedBy: (...regexes: RegExp[]) => {\n      const root = rootBuilder();\n      const notFollowed = Break.NotBefore(...regexes).Build();\n      const builder = () => Regex.and(root, notFollowed);\n      return Break.Chain(builder) as Omit<\n        ReturnType<typeof Break.Chain>,\n        \"NotFollowedBy\"\n      >;\n    },\n  }),\n};\n\n/**\n * Breaks the line into the tokens based on the found line break opporutnities.\n */\nexport const parseTokens = (line: string) => {\n  const breakLineRegex = getLineBreakRegex();\n\n  // normalizing to single-codepoint composed chars due to canonical equivalence\n  // of multi-codepoint versions for chars like č, で (~ so that we don't break a line in between c and ˇ)\n  // filtering due to multi-codepoint chars like 👨‍👩‍👧‍👦, 👩🏽‍🦰\n  return line.normalize(\"NFC\").split(breakLineRegex).filter(Boolean);\n};\n\n/**\n * Wraps the original text into the lines based on the given width.\n */\nexport const wrapText = (\n  text: string,\n  font: FontString,\n  maxWidth: number,\n): string => {\n  // if maxWidth is not finite or NaN which can happen in case of bugs in\n  // computation, we need to make sure we don't continue as we'll end up\n  // in an infinite loop\n  if (!Number.isFinite(maxWidth) || maxWidth < 0) {\n    return text;\n  }\n\n  const lines: Array<string> = [];\n  const originalLines = text.split(\"\\n\");\n\n  for (const originalLine of originalLines) {\n    const currentLineWidth = getLineWidth(originalLine, font);\n\n    if (currentLineWidth <= maxWidth) {\n      lines.push(originalLine);\n      continue;\n    }\n\n    const wrappedLine = wrapLine(originalLine, font, maxWidth);\n    lines.push(...wrappedLine);\n  }\n\n  return lines.join(\"\\n\");\n};\n\n/**\n * Wraps the original line into the lines based on the given width.\n */\nconst wrapLine = (\n  line: string,\n  font: FontString,\n  maxWidth: number,\n): string[] => {\n  const lines: Array<string> = [];\n  const tokens = parseTokens(line);\n  const tokenIterator = tokens[Symbol.iterator]();\n\n  let currentLine = \"\";\n  let currentLineWidth = 0;\n\n  let iterator = tokenIterator.next();\n\n  while (!iterator.done) {\n    const token = iterator.value;\n    const testLine = currentLine + token;\n\n    // cache single codepoint whitespace, CJK or emoji width calc. as kerning should not apply here\n    const testLineWidth = isSingleCharacter(token)\n      ? currentLineWidth + charWidth.calculate(token, font)\n      : getLineWidth(testLine, font);\n\n    // build up the current line, skipping length check for possibly trailing whitespaces\n    if (/\\s/.test(token) || testLineWidth <= maxWidth) {\n      currentLine = testLine;\n      currentLineWidth = testLineWidth;\n      iterator = tokenIterator.next();\n      continue;\n    }\n\n    // current line is empty => just the token (word) is longer than `maxWidth` and needs to be wrapped\n    if (!currentLine) {\n      const wrappedWord = wrapWord(token, font, maxWidth);\n      const trailingLine = wrappedWord[wrappedWord.length - 1] ?? \"\";\n      const precedingLines = wrappedWord.slice(0, -1);\n\n      lines.push(...precedingLines);\n\n      // trailing line of the wrapped word might still be joined with next token/s\n      currentLine = trailingLine;\n      currentLineWidth = getLineWidth(trailingLine, font);\n      iterator = tokenIterator.next();\n    } else {\n      // push & reset, but don't iterate on the next token, as we didn't use it yet!\n      lines.push(currentLine.trimEnd());\n\n      // purposefully not iterating and not setting `currentLine` to `token`, so that we could use a simple !currentLine check above\n      currentLine = \"\";\n      currentLineWidth = 0;\n    }\n  }\n\n  // iterator done, push the trailing line if exists\n  if (currentLine) {\n    const trailingLine = trimLine(currentLine, font, maxWidth);\n    lines.push(trailingLine);\n  }\n\n  return lines;\n};\n\n/**\n * Wraps the word into the lines based on the given width.\n */\nconst wrapWord = (\n  word: string,\n  font: FontString,\n  maxWidth: number,\n): Array<string> => {\n  // multi-codepoint emojis are already broken apart and shouldn't be broken further\n  if (getEmojiRegex().test(word)) {\n    return [word];\n  }\n\n  satisfiesWordInvariant(word);\n\n  const lines: Array<string> = [];\n  const chars = Array.from(word);\n\n  let currentLine = \"\";\n  let currentLineWidth = 0;\n\n  for (const char of chars) {\n    const _charWidth = charWidth.calculate(char, font);\n    const testLineWidth = currentLineWidth + _charWidth;\n\n    if (testLineWidth <= maxWidth) {\n      currentLine = currentLine + char;\n      currentLineWidth = testLineWidth;\n      continue;\n    }\n\n    if (currentLine) {\n      lines.push(currentLine);\n    }\n\n    currentLine = char;\n    currentLineWidth = _charWidth;\n  }\n\n  if (currentLine) {\n    lines.push(currentLine);\n  }\n\n  return lines;\n};\n\n/**\n * Similarly to browsers, does not trim all trailing whitespaces, but only those exceeding the `maxWidth`.\n */\nconst trimLine = (line: string, font: FontString, maxWidth: number) => {\n  const shouldTrimWhitespaces = getLineWidth(line, font) > maxWidth;\n\n  if (!shouldTrimWhitespaces) {\n    return line;\n  }\n\n  // defensively default to `trimeEnd` in case the regex does not match\n  let [, trimmedLine, whitespaces] = line.match(/^(.+?)(\\s+)$/) ?? [\n    line,\n    line.trimEnd(),\n    \"\",\n  ];\n\n  let trimmedLineWidth = getLineWidth(trimmedLine, font);\n\n  for (const whitespace of Array.from(whitespaces)) {\n    const _charWidth = charWidth.calculate(whitespace, font);\n    const testLineWidth = trimmedLineWidth + _charWidth;\n\n    if (testLineWidth > maxWidth) {\n      break;\n    }\n\n    trimmedLine = trimmedLine + whitespace;\n    trimmedLineWidth = testLineWidth;\n  }\n\n  return trimmedLine;\n};\n\n/**\n * Check if the given string is a single character.\n *\n * Handles multi-byte chars (é, 中) and purposefully does not handle multi-codepoint char (👨‍👩‍👧‍👦, 👩🏽‍🦰).\n */\nconst isSingleCharacter = (maybeSingleCharacter: string) => {\n  return (\n    maybeSingleCharacter.codePointAt(0) !== undefined &&\n    maybeSingleCharacter.codePointAt(1) === undefined\n  );\n};\n\n/**\n * Invariant for the word wrapping algorithm.\n */\nconst satisfiesWordInvariant = (word: string) => {\n  if (isTestEnv() || isDevEnv()) {\n    if (/\\s/.test(word)) {\n      throw new Error(\"Word should not contain any whitespaces!\");\n    }\n  }\n};\n",
    "import {\n  curvePointDistance,\n  distanceToLineSegment,\n  pointRotateRads,\n} from \"@excalidraw/math\";\n\nimport { ellipse, ellipseDistanceFromPoint } from \"@excalidraw/math/ellipse\";\n\nimport type { GlobalPoint, Radians } from \"@excalidraw/math\";\n\nimport {\n  deconstructDiamondElement,\n  deconstructLinearOrFreeDrawElement,\n  deconstructRectanguloidElement,\n} from \"./utils\";\n\nimport { elementCenterPoint } from \"./bounds\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawDiamondElement,\n  ExcalidrawElement,\n  ExcalidrawEllipseElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawRectanguloidElement,\n} from \"./types\";\n\nexport const distanceToElement = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): number => {\n  switch (element.type) {\n    case \"selection\":\n    case \"rectangle\":\n    case \"image\":\n    case \"text\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"frame\":\n    case \"magicframe\":\n      return distanceToRectanguloidElement(element, elementsMap, p);\n    case \"diamond\":\n      return distanceToDiamondElement(element, elementsMap, p);\n    case \"ellipse\":\n      return distanceToEllipseElement(element, elementsMap, p);\n    case \"line\":\n    case \"arrow\":\n    case \"freedraw\":\n      return distanceToLinearOrFreeDraElement(element, p);\n  }\n};\n\n/**\n * Returns the distance of a point and the provided rectangular-shaped element,\n * accounting for roundness and rotation\n *\n * @param element The rectanguloid element\n * @param p The point to consider\n * @returns The eucledian distance to the outline of the rectanguloid element\n */\nconst distanceToRectanguloidElement = (\n  element: ExcalidrawRectanguloidElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n) => {\n  const center = elementCenterPoint(element, elementsMap);\n  // To emulate a rotated rectangle we rotate the point in the inverse angle\n  // instead. It's all the same distance-wise.\n  const rotatedPoint = pointRotateRads(p, center, -element.angle as Radians);\n\n  // Get the element's building components we can test against\n  const [sides, corners] = deconstructRectanguloidElement(element);\n\n  return Math.min(\n    ...sides.map((s) => distanceToLineSegment(rotatedPoint, s)),\n    ...corners\n      .map((a) => curvePointDistance(a, rotatedPoint))\n      .filter((d): d is number => d !== null),\n  );\n};\n\n/**\n * Returns the distance of a point and the provided diamond element, accounting\n * for roundness and rotation\n *\n * @param element The diamond element\n * @param p The point to consider\n * @returns The eucledian distance to the outline of the diamond\n */\nconst distanceToDiamondElement = (\n  element: ExcalidrawDiamondElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): number => {\n  const center = elementCenterPoint(element, elementsMap);\n\n  // Rotate the point to the inverse direction to simulate the rotated diamond\n  // points. It's all the same distance-wise.\n  const rotatedPoint = pointRotateRads(p, center, -element.angle as Radians);\n\n  const [sides, curves] = deconstructDiamondElement(element);\n\n  return Math.min(\n    ...sides.map((s) => distanceToLineSegment(rotatedPoint, s)),\n    ...curves\n      .map((a) => curvePointDistance(a, rotatedPoint))\n      .filter((d): d is number => d !== null),\n  );\n};\n\n/**\n * Returns the distance of a point and the provided ellipse element, accounting\n * for roundness and rotation\n *\n * @param element The ellipse element\n * @param p The point to consider\n * @returns The eucledian distance to the outline of the ellipse\n */\nconst distanceToEllipseElement = (\n  element: ExcalidrawEllipseElement,\n  elementsMap: ElementsMap,\n  p: GlobalPoint,\n): number => {\n  const center = elementCenterPoint(element, elementsMap);\n  return ellipseDistanceFromPoint(\n    // Instead of rotating the ellipse, rotate the point to the inverse angle\n    pointRotateRads(p, center, -element.angle as Radians),\n    ellipse(center, element.width / 2, element.height / 2),\n  );\n};\n\nconst distanceToLinearOrFreeDraElement = (\n  element: ExcalidrawLinearElement | ExcalidrawFreeDrawElement,\n  p: GlobalPoint,\n) => {\n  const [lines, curves] = deconstructLinearOrFreeDrawElement(element);\n  return Math.min(\n    ...lines.map((s) => distanceToLineSegment(p, s)),\n    ...curves.map((a) => curvePointDistance(a, p)),\n  );\n};\n",
    "import { invariant, isDevEnv, isTestEnv } from \"@excalidraw/common\";\n\nimport {\n  pointFrom,\n  pointFromVector,\n  pointRotateRads,\n  pointScaleFromOrigin,\n  pointsEqual,\n  triangleIncludesPoint,\n  vectorCross,\n  vectorFromPoint,\n  vectorScale,\n} from \"@excalidraw/math\";\n\nimport type {\n  LocalPoint,\n  GlobalPoint,\n  Triangle,\n  Vector,\n} from \"@excalidraw/math\";\n\nimport { getCenterForBounds, type Bounds } from \"./bounds\";\n\nimport type { ExcalidrawBindableElement } from \"./types\";\n\nexport const HEADING_RIGHT = [1, 0] as Heading;\nexport const HEADING_DOWN = [0, 1] as Heading;\nexport const HEADING_LEFT = [-1, 0] as Heading;\nexport const HEADING_UP = [0, -1] as Heading;\nexport type Heading = [1, 0] | [0, 1] | [-1, 0] | [0, -1];\n\nexport const vectorToHeading = (vec: Vector): Heading => {\n  const [x, y] = vec;\n  const absX = Math.abs(x);\n  const absY = Math.abs(y);\n  if (x > absY) {\n    return HEADING_RIGHT;\n  } else if (x <= -absY) {\n    return HEADING_LEFT;\n  } else if (y > absX) {\n    return HEADING_DOWN;\n  }\n  return HEADING_UP;\n};\n\nexport const headingForPoint = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  o: P,\n) => vectorToHeading(vectorFromPoint<P>(p, o));\n\nexport const headingForPointIsHorizontal = <P extends GlobalPoint | LocalPoint>(\n  p: P,\n  o: P,\n) => headingIsHorizontal(headingForPoint<P>(p, o));\n\nexport const compareHeading = (a: Heading, b: Heading) =>\n  a[0] === b[0] && a[1] === b[1];\n\nexport const headingIsHorizontal = (a: Heading) =>\n  compareHeading(a, HEADING_RIGHT) || compareHeading(a, HEADING_LEFT);\n\nexport const headingIsVertical = (a: Heading) => !headingIsHorizontal(a);\n\nconst headingForPointFromDiamondElement = (\n  element: Readonly<ExcalidrawBindableElement>,\n  aabb: Readonly<Bounds>,\n  point: Readonly<GlobalPoint>,\n): Heading => {\n  const midPoint = getCenterForBounds(aabb);\n\n  if (isDevEnv() || isTestEnv()) {\n    invariant(\n      element.width > 0 && element.height > 0,\n      \"Diamond element has no width or height\",\n    );\n    invariant(\n      !pointsEqual(midPoint, point),\n      \"The point is too close to the element mid point to determine heading\",\n    );\n  }\n\n  const SHRINK = 0.95; // Rounded elements tolerance\n  const top = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(element.x + element.width / 2, element.y),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n  const right = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(\n            element.x + element.width,\n            element.y + element.height / 2,\n          ),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n  const bottom = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(\n            element.x + element.width / 2,\n            element.y + element.height,\n          ),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n  const left = pointFromVector(\n    vectorScale(\n      vectorFromPoint(\n        pointRotateRads(\n          pointFrom<GlobalPoint>(element.x, element.y + element.height / 2),\n          midPoint,\n          element.angle,\n        ),\n        midPoint,\n      ),\n      SHRINK,\n    ),\n    midPoint,\n  );\n\n  // Corners\n  if (\n    vectorCross(vectorFromPoint(point, top), vectorFromPoint(top, right)) <=\n      0 &&\n    vectorCross(vectorFromPoint(point, top), vectorFromPoint(top, left)) > 0\n  ) {\n    return headingForPoint(top, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, right),\n      vectorFromPoint(right, bottom),\n    ) <= 0 &&\n    vectorCross(vectorFromPoint(point, right), vectorFromPoint(right, top)) > 0\n  ) {\n    return headingForPoint(right, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, bottom),\n      vectorFromPoint(bottom, left),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, bottom),\n      vectorFromPoint(bottom, right),\n    ) > 0\n  ) {\n    return headingForPoint(bottom, midPoint);\n  } else if (\n    vectorCross(vectorFromPoint(point, left), vectorFromPoint(left, top)) <=\n      0 &&\n    vectorCross(vectorFromPoint(point, left), vectorFromPoint(left, bottom)) > 0\n  ) {\n    return headingForPoint(left, midPoint);\n  }\n\n  // Sides\n  if (\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(top, midPoint),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(right, midPoint),\n    ) > 0\n  ) {\n    const p = element.width > element.height ? top : right;\n    return headingForPoint(p, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(right, midPoint),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(bottom, midPoint),\n    ) > 0\n  ) {\n    const p = element.width > element.height ? bottom : right;\n    return headingForPoint(p, midPoint);\n  } else if (\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(bottom, midPoint),\n    ) <= 0 &&\n    vectorCross(\n      vectorFromPoint(point, midPoint),\n      vectorFromPoint(left, midPoint),\n    ) > 0\n  ) {\n    const p = element.width > element.height ? bottom : left;\n    return headingForPoint(p, midPoint);\n  }\n\n  const p = element.width > element.height ? top : left;\n  return headingForPoint(p, midPoint);\n};\n\n// Gets the heading for the point by creating a bounding box around the rotated\n// close fitting bounding box, then creating 4 search cones around the center of\n// the external bbox.\nexport const headingForPointFromElement = <Point extends GlobalPoint>(\n  element: Readonly<ExcalidrawBindableElement>,\n  aabb: Readonly<Bounds>,\n  p: Readonly<Point>,\n): Heading => {\n  const SEARCH_CONE_MULTIPLIER = 2;\n\n  const midPoint = getCenterForBounds(aabb);\n\n  if (element.type === \"diamond\") {\n    return headingForPointFromDiamondElement(element, aabb, p);\n  }\n\n  const topLeft = pointScaleFromOrigin(\n    pointFrom(aabb[0], aabb[1]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n  const topRight = pointScaleFromOrigin(\n    pointFrom(aabb[2], aabb[1]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n  const bottomLeft = pointScaleFromOrigin(\n    pointFrom(aabb[0], aabb[3]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n  const bottomRight = pointScaleFromOrigin(\n    pointFrom(aabb[2], aabb[3]),\n    midPoint,\n    SEARCH_CONE_MULTIPLIER,\n  ) as Point;\n\n  return triangleIncludesPoint<Point>(\n    [topLeft, topRight, midPoint] as Triangle<Point>,\n    p,\n  )\n    ? HEADING_UP\n    : triangleIncludesPoint<Point>(\n        [topRight, bottomRight, midPoint] as Triangle<Point>,\n        p,\n      )\n    ? HEADING_RIGHT\n    : triangleIncludesPoint<Point>(\n        [bottomRight, bottomLeft, midPoint] as Triangle<Point>,\n        p,\n      )\n    ? HEADING_DOWN\n    : HEADING_LEFT;\n};\n\nexport const flipHeading = (h: Heading): Heading =>\n  [\n    h[0] === 0 ? 0 : h[0] > 0 ? -1 : 1,\n    h[1] === 0 ? 0 : h[1] > 0 ? -1 : 1,\n  ] as Heading;\n",
    "import {\n  clamp,\n  pointDistance,\n  pointFrom,\n  pointScaleFromOrigin,\n  pointsEqual,\n  pointTranslate,\n  vector,\n  vectorCross,\n  vectorFromPoint,\n  vectorScale,\n  type GlobalPoint,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport {\n  BinaryHeap,\n  invariant,\n  isAnyTrue,\n  tupleToCoors,\n  getSizeFromPoints,\n  isDevEnv,\n  arrayToMap,\n} from \"@excalidraw/common\";\n\nimport type { AppState } from \"excalidraw-custom/types\";\n\nimport {\n  bindPointToSnapToElementOutline,\n  FIXED_BINDING_DISTANCE,\n  getHeadingForElbowArrowSnap,\n  getGlobalFixedPointForBindableElement,\n  getHoveredElementForBinding,\n} from \"./binding\";\nimport { distanceToElement } from \"./distance\";\nimport {\n  compareHeading,\n  flipHeading,\n  HEADING_DOWN,\n  HEADING_LEFT,\n  HEADING_RIGHT,\n  HEADING_UP,\n  headingForPointIsHorizontal,\n  headingIsHorizontal,\n  vectorToHeading,\n  headingForPoint,\n} from \"./heading\";\nimport { type ElementUpdate } from \"./mutateElement\";\nimport { isBindableElement } from \"./typeChecks\";\nimport {\n  type ExcalidrawElbowArrowElement,\n  type NonDeletedSceneElementsMap,\n} from \"./types\";\n\nimport { aabbForElement, pointInsideBounds } from \"./bounds\";\n\nimport type { Bounds } from \"./bounds\";\nimport type { Heading } from \"./heading\";\nimport type {\n  Arrowhead,\n  ElementsMap,\n  ExcalidrawBindableElement,\n  FixedPointBinding,\n  FixedSegment,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\ntype GridAddress = [number, number] & { _brand: \"gridaddress\" };\n\ntype Node = {\n  f: number;\n  g: number;\n  h: number;\n  closed: boolean;\n  visited: boolean;\n  parent: Node | null;\n  pos: GlobalPoint;\n  addr: GridAddress;\n};\n\ntype Grid = {\n  row: number;\n  col: number;\n  data: (Node | null)[];\n};\n\ntype ElbowArrowState = {\n  x: number;\n  y: number;\n  startBinding: FixedPointBinding | null;\n  endBinding: FixedPointBinding | null;\n  startArrowhead: Arrowhead | null;\n  endArrowhead: Arrowhead | null;\n};\n\ntype ElbowArrowData = {\n  dynamicAABBs: Bounds[];\n  startDonglePosition: GlobalPoint | null;\n  startGlobalPoint: GlobalPoint;\n  startHeading: Heading;\n  endDonglePosition: GlobalPoint | null;\n  endGlobalPoint: GlobalPoint;\n  endHeading: Heading;\n  commonBounds: Bounds;\n  hoveredStartElement: ExcalidrawBindableElement | null;\n  hoveredEndElement: ExcalidrawBindableElement | null;\n};\n\nconst DEDUP_TRESHOLD = 1;\nexport const BASE_PADDING = 40;\n\nconst handleSegmentRenormalization = (\n  arrow: ExcalidrawElbowArrowElement,\n  elementsMap: NonDeletedSceneElementsMap,\n) => {\n  const nextFixedSegments: FixedSegment[] | null = arrow.fixedSegments\n    ? arrow.fixedSegments.slice()\n    : null;\n\n  if (nextFixedSegments) {\n    const _nextPoints: GlobalPoint[] = [];\n\n    arrow.points\n      .map((p) => pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]))\n      .forEach((p, i, points) => {\n        if (i < 2) {\n          return _nextPoints.push(p);\n        }\n\n        const currentSegmentIsHorizontal = headingForPoint(p, points[i - 1]);\n        const prevSegmentIsHorizontal = headingForPoint(\n          points[i - 1],\n          points[i - 2],\n        );\n\n        if (\n          // Check if previous two points are on the same line\n          compareHeading(currentSegmentIsHorizontal, prevSegmentIsHorizontal)\n        ) {\n          const prevSegmentIdx =\n            nextFixedSegments?.findIndex(\n              (segment) => segment.index === i - 1,\n            ) ?? -1;\n          const segmentIdx =\n            nextFixedSegments?.findIndex((segment) => segment.index === i) ??\n            -1;\n\n          // If the current segment is a fixed segment, update its start point\n          if (segmentIdx !== -1) {\n            nextFixedSegments[segmentIdx].start = pointFrom<LocalPoint>(\n              points[i - 2][0] - arrow.x,\n              points[i - 2][1] - arrow.y,\n            );\n          }\n\n          // Remove the fixed segment status from the previous segment if it is\n          // a fixed segment, because we are going to unify that segment with\n          // the current one\n          if (prevSegmentIdx !== -1) {\n            nextFixedSegments.splice(prevSegmentIdx, 1);\n          }\n\n          // Remove the duplicate point\n          _nextPoints.splice(-1, 1);\n\n          // Update fixed point indices\n          nextFixedSegments.forEach((segment) => {\n            if (segment.index > i - 1) {\n              segment.index -= 1;\n            }\n          });\n        }\n\n        return _nextPoints.push(p);\n      });\n\n    const nextPoints: GlobalPoint[] = [];\n\n    _nextPoints.forEach((p, i, points) => {\n      if (i < 3) {\n        return nextPoints.push(p);\n      }\n\n      if (\n        // Remove segments that are too short\n        pointDistance(points[i - 2], points[i - 1]) < DEDUP_TRESHOLD\n      ) {\n        const prevPrevSegmentIdx =\n          nextFixedSegments?.findIndex((segment) => segment.index === i - 2) ??\n          -1;\n        const prevSegmentIdx =\n          nextFixedSegments?.findIndex((segment) => segment.index === i - 1) ??\n          -1;\n\n        // Remove the previous fixed segment if it exists (i.e. the segment\n        // which will be removed due to being parallel or too short)\n        if (prevSegmentIdx !== -1) {\n          nextFixedSegments.splice(prevSegmentIdx, 1);\n        }\n\n        // Remove the fixed segment status from the segment 2 steps back\n        // if it is a fixed segment, because we are going to unify that\n        // segment with the current one\n        if (prevPrevSegmentIdx !== -1) {\n          nextFixedSegments.splice(prevPrevSegmentIdx, 1);\n        }\n\n        nextPoints.splice(-2, 2);\n\n        // Since we have to remove two segments, update any fixed segment\n        nextFixedSegments.forEach((segment) => {\n          if (segment.index > i - 2) {\n            segment.index -= 2;\n          }\n        });\n\n        // Remove aligned segment points\n        const isHorizontal = headingForPointIsHorizontal(p, points[i - 1]);\n\n        return nextPoints.push(\n          pointFrom<GlobalPoint>(\n            !isHorizontal ? points[i - 2][0] : p[0],\n            isHorizontal ? points[i - 2][1] : p[1],\n          ),\n        );\n      }\n\n      nextPoints.push(p);\n    });\n\n    const filteredNextFixedSegments = nextFixedSegments.filter(\n      (segment) =>\n        segment.index !== 1 && segment.index !== nextPoints.length - 1,\n    );\n    if (filteredNextFixedSegments.length === 0) {\n      return normalizeArrowElementUpdate(\n        getElbowArrowCornerPoints(\n          removeElbowArrowShortSegments(\n            routeElbowArrow(\n              arrow,\n              getElbowArrowData(\n                arrow,\n                elementsMap,\n                nextPoints.map((p) =>\n                  pointFrom<LocalPoint>(p[0] - arrow.x, p[1] - arrow.y),\n                ),\n              ),\n            ) ?? [],\n          ),\n        ),\n        filteredNextFixedSegments,\n        null,\n        null,\n      );\n    }\n\n    isDevEnv() &&\n      invariant(\n        validateElbowPoints(nextPoints),\n        \"Invalid elbow points with fixed segments\",\n      );\n\n    return normalizeArrowElementUpdate(\n      nextPoints,\n      filteredNextFixedSegments,\n      arrow.startIsSpecial,\n      arrow.endIsSpecial,\n    );\n  }\n\n  return {\n    x: arrow.x,\n    y: arrow.y,\n    points: arrow.points,\n    fixedSegments: arrow.fixedSegments,\n    startIsSpecial: arrow.startIsSpecial,\n    endIsSpecial: arrow.endIsSpecial,\n  };\n};\n\nconst handleSegmentRelease = (\n  arrow: ExcalidrawElbowArrowElement,\n  fixedSegments: readonly FixedSegment[],\n  elementsMap: NonDeletedSceneElementsMap,\n) => {\n  const newFixedSegmentIndices = fixedSegments.map((segment) => segment.index);\n  const oldFixedSegmentIndices =\n    arrow.fixedSegments?.map((segment) => segment.index) ?? [];\n  const deletedSegmentIdx = oldFixedSegmentIndices.findIndex(\n    (idx) => !newFixedSegmentIndices.includes(idx),\n  );\n\n  if (deletedSegmentIdx === -1 || !arrow.fixedSegments?.[deletedSegmentIdx]) {\n    return {\n      points: arrow.points,\n    };\n  }\n\n  const deletedIdx = arrow.fixedSegments[deletedSegmentIdx].index;\n\n  // Find prev and next fixed segments\n  const prevSegment = arrow.fixedSegments[deletedSegmentIdx - 1];\n  const nextSegment = arrow.fixedSegments[deletedSegmentIdx + 1];\n\n  // We need to render a sub-arrow path to restore deleted segments\n  const x = arrow.x + (prevSegment ? prevSegment.end[0] : 0);\n  const y = arrow.y + (prevSegment ? prevSegment.end[1] : 0);\n  const startBinding = prevSegment ? null : arrow.startBinding;\n  const endBinding = nextSegment ? null : arrow.endBinding;\n  const {\n    startHeading,\n    endHeading,\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    hoveredEndElement,\n    ...rest\n  } = getElbowArrowData(\n    {\n      x,\n      y,\n      startBinding,\n      endBinding,\n      startArrowhead: null,\n      endArrowhead: null,\n      points: arrow.points,\n    },\n    elementsMap,\n    [\n      pointFrom<LocalPoint>(0, 0),\n      pointFrom<LocalPoint>(\n        arrow.x +\n          (nextSegment?.start[0] ?? arrow.points[arrow.points.length - 1][0]) -\n          x,\n        arrow.y +\n          (nextSegment?.start[1] ?? arrow.points[arrow.points.length - 1][1]) -\n          y,\n      ),\n    ],\n    { isDragging: false },\n  );\n\n  const { points: restoredPoints } = normalizeArrowElementUpdate(\n    getElbowArrowCornerPoints(\n      removeElbowArrowShortSegments(\n        routeElbowArrow(arrow, {\n          startHeading,\n          endHeading,\n          startGlobalPoint,\n          endGlobalPoint,\n          hoveredStartElement,\n          hoveredEndElement,\n          ...rest,\n        }) ?? [],\n      ),\n    ),\n    fixedSegments,\n    null,\n    null,\n  );\n\n  const nextPoints: GlobalPoint[] = [];\n\n  // First part of the arrow are the old points\n  if (prevSegment) {\n    for (let i = 0; i < prevSegment.index; i++) {\n      nextPoints.push(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[i][0],\n          arrow.y + arrow.points[i][1],\n        ),\n      );\n    }\n  }\n\n  restoredPoints.forEach((p) => {\n    nextPoints.push(\n      pointFrom<GlobalPoint>(\n        arrow.x + (prevSegment ? prevSegment.end[0] : 0) + p[0],\n        arrow.y + (prevSegment ? prevSegment.end[1] : 0) + p[1],\n      ),\n    );\n  });\n\n  // Last part of the arrow are the old points too\n  if (nextSegment) {\n    for (let i = nextSegment.index; i < arrow.points.length; i++) {\n      nextPoints.push(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[i][0],\n          arrow.y + arrow.points[i][1],\n        ),\n      );\n    }\n  }\n\n  // Update nextFixedSegments\n  const originalSegmentCountDiff =\n    (nextSegment?.index ?? arrow.points.length) - (prevSegment?.index ?? 0) - 1;\n\n  const nextFixedSegments = fixedSegments.map((segment) => {\n    if (segment.index > deletedIdx) {\n      return {\n        ...segment,\n        index:\n          segment.index -\n          originalSegmentCountDiff +\n          (restoredPoints.length - 1),\n      };\n    }\n\n    return segment;\n  });\n\n  const simplifiedPoints = nextPoints.flatMap((p, i) => {\n    const prev = nextPoints[i - 1];\n    const next = nextPoints[i + 1];\n\n    if (prev && next) {\n      const prevHeading = headingForPoint(p, prev);\n      const nextHeading = headingForPoint(next, p);\n\n      if (compareHeading(prevHeading, nextHeading)) {\n        // Update subsequent fixed segment indices\n        nextFixedSegments.forEach((segment) => {\n          if (segment.index > i) {\n            segment.index -= 1;\n          }\n        });\n\n        return [];\n      } else if (compareHeading(prevHeading, flipHeading(nextHeading))) {\n        // Update subsequent fixed segment indices\n        nextFixedSegments.forEach((segment) => {\n          if (segment.index > i) {\n            segment.index += 1;\n          }\n        });\n\n        return [p, p];\n      }\n    }\n\n    return [p];\n  });\n\n  return normalizeArrowElementUpdate(\n    simplifiedPoints,\n    nextFixedSegments,\n    false,\n    false,\n  );\n};\n\n/**\n *\n */\nconst handleSegmentMove = (\n  arrow: ExcalidrawElbowArrowElement,\n  fixedSegments: readonly FixedSegment[],\n  startHeading: Heading,\n  endHeading: Heading,\n  hoveredStartElement: ExcalidrawBindableElement | null,\n  hoveredEndElement: ExcalidrawBindableElement | null,\n): ElementUpdate<ExcalidrawElbowArrowElement> => {\n  const activelyModifiedSegmentIdx = fixedSegments\n    .map((segment, i) => {\n      if (\n        arrow.fixedSegments == null ||\n        arrow.fixedSegments[i] === undefined ||\n        arrow.fixedSegments[i].index !== segment.index\n      ) {\n        return i;\n      }\n\n      return (segment.start[0] !== arrow.fixedSegments![i].start[0] &&\n        segment.end[0] !== arrow.fixedSegments![i].end[0]) !==\n        (segment.start[1] !== arrow.fixedSegments![i].start[1] &&\n          segment.end[1] !== arrow.fixedSegments![i].end[1])\n        ? i\n        : null;\n    })\n    .filter((idx) => idx !== null)\n    .shift();\n\n  if (activelyModifiedSegmentIdx == null) {\n    return { points: arrow.points };\n  }\n\n  const firstSegmentIdx =\n    arrow.fixedSegments?.findIndex((segment) => segment.index === 1) ?? -1;\n  const lastSegmentIdx =\n    arrow.fixedSegments?.findIndex(\n      (segment) => segment.index === arrow.points.length - 1,\n    ) ?? -1;\n\n  // Handle special case for first segment move\n  const segmentLength = pointDistance(\n    fixedSegments[activelyModifiedSegmentIdx].start,\n    fixedSegments[activelyModifiedSegmentIdx].end,\n  );\n  const segmentIsTooShort = segmentLength < BASE_PADDING + 5;\n  if (\n    firstSegmentIdx === -1 &&\n    fixedSegments[activelyModifiedSegmentIdx].index === 1 &&\n    hoveredStartElement\n  ) {\n    const startIsHorizontal = headingIsHorizontal(startHeading);\n    const startIsPositive = startIsHorizontal\n      ? compareHeading(startHeading, HEADING_RIGHT)\n      : compareHeading(startHeading, HEADING_DOWN);\n    const padding = startIsPositive\n      ? segmentIsTooShort\n        ? segmentLength / 2\n        : BASE_PADDING\n      : segmentIsTooShort\n      ? -segmentLength / 2\n      : -BASE_PADDING;\n    fixedSegments[activelyModifiedSegmentIdx].start = pointFrom<LocalPoint>(\n      fixedSegments[activelyModifiedSegmentIdx].start[0] +\n        (startIsHorizontal ? padding : 0),\n      fixedSegments[activelyModifiedSegmentIdx].start[1] +\n        (!startIsHorizontal ? padding : 0),\n    );\n  }\n\n  // Handle special case for last segment move\n  if (\n    lastSegmentIdx === -1 &&\n    fixedSegments[activelyModifiedSegmentIdx].index ===\n      arrow.points.length - 1 &&\n    hoveredEndElement\n  ) {\n    const endIsHorizontal = headingIsHorizontal(endHeading);\n    const endIsPositive = endIsHorizontal\n      ? compareHeading(endHeading, HEADING_RIGHT)\n      : compareHeading(endHeading, HEADING_DOWN);\n    const padding = endIsPositive\n      ? segmentIsTooShort\n        ? segmentLength / 2\n        : BASE_PADDING\n      : segmentIsTooShort\n      ? -segmentLength / 2\n      : -BASE_PADDING;\n    fixedSegments[activelyModifiedSegmentIdx].end = pointFrom<LocalPoint>(\n      fixedSegments[activelyModifiedSegmentIdx].end[0] +\n        (endIsHorizontal ? padding : 0),\n      fixedSegments[activelyModifiedSegmentIdx].end[1] +\n        (!endIsHorizontal ? padding : 0),\n    );\n  }\n\n  // Translate all fixed segments to global coordinates\n  const nextFixedSegments = fixedSegments.map((segment) => ({\n    ...segment,\n    start: pointFrom<GlobalPoint>(\n      arrow.x + segment.start[0],\n      arrow.y + segment.start[1],\n    ),\n    end: pointFrom<GlobalPoint>(\n      arrow.x + segment.end[0],\n      arrow.y + segment.end[1],\n    ),\n  }));\n\n  // For start, clone old arrow points\n  const newPoints: GlobalPoint[] = arrow.points.map((p, i) =>\n    pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]),\n  );\n\n  const startIdx = nextFixedSegments[activelyModifiedSegmentIdx].index - 1;\n  const endIdx = nextFixedSegments[activelyModifiedSegmentIdx].index;\n  const start = nextFixedSegments[activelyModifiedSegmentIdx].start;\n  const end = nextFixedSegments[activelyModifiedSegmentIdx].end;\n  const prevSegmentIsHorizontal =\n    newPoints[startIdx - 1] &&\n    !pointsEqual(newPoints[startIdx], newPoints[startIdx - 1])\n      ? headingForPointIsHorizontal(\n          newPoints[startIdx - 1],\n          newPoints[startIdx],\n        )\n      : undefined;\n  const nextSegmentIsHorizontal =\n    newPoints[endIdx + 1] &&\n    !pointsEqual(newPoints[endIdx], newPoints[endIdx + 1])\n      ? headingForPointIsHorizontal(newPoints[endIdx + 1], newPoints[endIdx])\n      : undefined;\n\n  // Override the segment points with the actively moved fixed segment\n  if (prevSegmentIsHorizontal !== undefined) {\n    const dir = prevSegmentIsHorizontal ? 1 : 0;\n    newPoints[startIdx - 1][dir] = start[dir];\n  }\n  newPoints[startIdx] = start;\n  newPoints[endIdx] = end;\n  if (nextSegmentIsHorizontal !== undefined) {\n    const dir = nextSegmentIsHorizontal ? 1 : 0;\n    newPoints[endIdx + 1][dir] = end[dir];\n  }\n\n  // Override neighboring fixedSegment start/end points, if any\n  const prevSegmentIdx = nextFixedSegments.findIndex(\n    (segment) => segment.index === startIdx,\n  );\n  if (prevSegmentIdx !== -1) {\n    // Align the next segment points with the moved segment\n    const dir = headingForPointIsHorizontal(\n      nextFixedSegments[prevSegmentIdx].end,\n      nextFixedSegments[prevSegmentIdx].start,\n    )\n      ? 1\n      : 0;\n    nextFixedSegments[prevSegmentIdx].start[dir] = start[dir];\n    nextFixedSegments[prevSegmentIdx].end = start;\n  }\n\n  const nextSegmentIdx = nextFixedSegments.findIndex(\n    (segment) => segment.index === endIdx + 1,\n  );\n  if (nextSegmentIdx !== -1) {\n    // Align the next segment points with the moved segment\n    const dir = headingForPointIsHorizontal(\n      nextFixedSegments[nextSegmentIdx].end,\n      nextFixedSegments[nextSegmentIdx].start,\n    )\n      ? 1\n      : 0;\n    nextFixedSegments[nextSegmentIdx].end[dir] = end[dir];\n    nextFixedSegments[nextSegmentIdx].start = end;\n  }\n\n  // First segment move needs an additional segment\n  if (firstSegmentIdx === -1 && startIdx === 0) {\n    const startIsHorizontal = hoveredStartElement\n      ? headingIsHorizontal(startHeading)\n      : headingForPointIsHorizontal(newPoints[1], newPoints[0]);\n    newPoints.unshift(\n      pointFrom<GlobalPoint>(\n        startIsHorizontal ? start[0] : arrow.x + arrow.points[0][0],\n        !startIsHorizontal ? start[1] : arrow.y + arrow.points[0][1],\n      ),\n    );\n\n    if (hoveredStartElement) {\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[0][0],\n          arrow.y + arrow.points[0][1],\n        ),\n      );\n    }\n\n    for (const segment of nextFixedSegments) {\n      segment.index += hoveredStartElement ? 2 : 1;\n    }\n  }\n\n  // Last segment move needs an additional segment\n  if (lastSegmentIdx === -1 && endIdx === arrow.points.length - 1) {\n    const endIsHorizontal = headingIsHorizontal(endHeading);\n    newPoints.push(\n      pointFrom<GlobalPoint>(\n        endIsHorizontal\n          ? end[0]\n          : arrow.x + arrow.points[arrow.points.length - 1][0],\n        !endIsHorizontal\n          ? end[1]\n          : arrow.y + arrow.points[arrow.points.length - 1][1],\n      ),\n    );\n    if (hoveredEndElement) {\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[arrow.points.length - 1][0],\n          arrow.y + arrow.points[arrow.points.length - 1][1],\n        ),\n      );\n    }\n  }\n\n  return normalizeArrowElementUpdate(\n    newPoints,\n    nextFixedSegments.map((segment) => ({\n      ...segment,\n      start: pointFrom<LocalPoint>(\n        segment.start[0] - arrow.x,\n        segment.start[1] - arrow.y,\n      ),\n      end: pointFrom<LocalPoint>(\n        segment.end[0] - arrow.x,\n        segment.end[1] - arrow.y,\n      ),\n    })),\n    false, // If you move a segment, there is no special point anymore\n    false, // If you move a segment, there is no special point anymore\n  );\n};\n\nconst handleEndpointDrag = (\n  arrow: ExcalidrawElbowArrowElement,\n  updatedPoints: readonly LocalPoint[],\n  fixedSegments: readonly FixedSegment[],\n  startHeading: Heading,\n  endHeading: Heading,\n  startGlobalPoint: GlobalPoint,\n  endGlobalPoint: GlobalPoint,\n  hoveredStartElement: ExcalidrawBindableElement | null,\n  hoveredEndElement: ExcalidrawBindableElement | null,\n) => {\n  let startIsSpecial = arrow.startIsSpecial ?? null;\n  let endIsSpecial = arrow.endIsSpecial ?? null;\n  const globalUpdatedPoints = updatedPoints.map((p, i) =>\n    i === 0\n      ? pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1])\n      : i === updatedPoints.length - 1\n      ? pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1])\n      : pointFrom<GlobalPoint>(\n          arrow.x + arrow.points[i][0],\n          arrow.y + arrow.points[i][1],\n        ),\n  );\n  const nextFixedSegments = fixedSegments.map((segment) => ({\n    ...segment,\n    start: pointFrom<GlobalPoint>(\n      arrow.x + (segment.start[0] - updatedPoints[0][0]),\n      arrow.y + (segment.start[1] - updatedPoints[0][1]),\n    ),\n    end: pointFrom<GlobalPoint>(\n      arrow.x + (segment.end[0] - updatedPoints[0][0]),\n      arrow.y + (segment.end[1] - updatedPoints[0][1]),\n    ),\n  }));\n  const newPoints: GlobalPoint[] = [];\n\n  // Add the inside points\n  const offset = 2 + (startIsSpecial ? 1 : 0);\n  const endOffset = 2 + (endIsSpecial ? 1 : 0);\n  while (newPoints.length + offset < globalUpdatedPoints.length - endOffset) {\n    newPoints.push(globalUpdatedPoints[newPoints.length + offset]);\n  }\n\n  // Calculate the moving second point connection and add the start point\n  {\n    const secondPoint = globalUpdatedPoints[startIsSpecial ? 2 : 1];\n    const thirdPoint = globalUpdatedPoints[startIsSpecial ? 3 : 2];\n    const startIsHorizontal = headingIsHorizontal(startHeading);\n    const secondIsHorizontal = headingIsHorizontal(\n      vectorToHeading(vectorFromPoint(secondPoint, thirdPoint)),\n    );\n\n    if (hoveredStartElement && startIsHorizontal === secondIsHorizontal) {\n      const positive = startIsHorizontal\n        ? compareHeading(startHeading, HEADING_RIGHT)\n        : compareHeading(startHeading, HEADING_DOWN);\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal\n            ? thirdPoint[0]\n            : startGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING),\n          secondIsHorizontal\n            ? thirdPoint[1]\n            : startGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING),\n        ),\n      );\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          startIsHorizontal\n            ? startGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : startGlobalPoint[0],\n          !startIsHorizontal\n            ? startGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : startGlobalPoint[1],\n        ),\n      );\n      if (!startIsSpecial) {\n        startIsSpecial = true;\n        for (const segment of nextFixedSegments) {\n          if (segment.index > 1) {\n            segment.index += 1;\n          }\n        }\n      }\n    } else {\n      newPoints.unshift(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal ? secondPoint[0] : startGlobalPoint[0],\n          secondIsHorizontal ? secondPoint[1] : startGlobalPoint[1],\n        ),\n      );\n      if (startIsSpecial) {\n        startIsSpecial = false;\n        for (const segment of nextFixedSegments) {\n          if (segment.index > 1) {\n            segment.index -= 1;\n          }\n        }\n      }\n    }\n    newPoints.unshift(startGlobalPoint);\n  }\n\n  // Calculate the moving second to last point connection\n  {\n    const secondToLastPoint =\n      globalUpdatedPoints[globalUpdatedPoints.length - (endIsSpecial ? 3 : 2)];\n    const thirdToLastPoint =\n      globalUpdatedPoints[globalUpdatedPoints.length - (endIsSpecial ? 4 : 3)];\n    const endIsHorizontal = headingIsHorizontal(endHeading);\n    const secondIsHorizontal = headingForPointIsHorizontal(\n      thirdToLastPoint,\n      secondToLastPoint,\n    );\n    if (hoveredEndElement && endIsHorizontal === secondIsHorizontal) {\n      const positive = endIsHorizontal\n        ? compareHeading(endHeading, HEADING_RIGHT)\n        : compareHeading(endHeading, HEADING_DOWN);\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal\n            ? thirdToLastPoint[0]\n            : endGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING),\n          secondIsHorizontal\n            ? thirdToLastPoint[1]\n            : endGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING),\n        ),\n      );\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          endIsHorizontal\n            ? endGlobalPoint[0] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : endGlobalPoint[0],\n          !endIsHorizontal\n            ? endGlobalPoint[1] + (positive ? BASE_PADDING : -BASE_PADDING)\n            : endGlobalPoint[1],\n        ),\n      );\n      if (!endIsSpecial) {\n        endIsSpecial = true;\n      }\n    } else {\n      newPoints.push(\n        pointFrom<GlobalPoint>(\n          !secondIsHorizontal ? secondToLastPoint[0] : endGlobalPoint[0],\n          secondIsHorizontal ? secondToLastPoint[1] : endGlobalPoint[1],\n        ),\n      );\n      if (endIsSpecial) {\n        endIsSpecial = false;\n      }\n    }\n  }\n\n  newPoints.push(endGlobalPoint);\n\n  return normalizeArrowElementUpdate(\n    newPoints,\n    nextFixedSegments\n      .map(({ index }) => ({\n        index,\n        start: newPoints[index - 1],\n        end: newPoints[index],\n      }))\n      .map((segment) => ({\n        ...segment,\n        start: pointFrom<LocalPoint>(\n          segment.start[0] - startGlobalPoint[0],\n          segment.start[1] - startGlobalPoint[1],\n        ),\n        end: pointFrom<LocalPoint>(\n          segment.end[0] - startGlobalPoint[0],\n          segment.end[1] - startGlobalPoint[1],\n        ),\n      })),\n    startIsSpecial,\n    endIsSpecial,\n  );\n};\n\nconst MAX_POS = 1e6;\n\n/**\n *\n */\nexport const updateElbowArrowPoints = (\n  arrow: Readonly<ExcalidrawElbowArrowElement>,\n  elementsMap: NonDeletedSceneElementsMap,\n  updates: {\n    points?: readonly LocalPoint[];\n    fixedSegments?: readonly FixedSegment[] | null;\n    startBinding?: FixedPointBinding | null;\n    endBinding?: FixedPointBinding | null;\n  },\n  options?: {\n    isDragging?: boolean;\n  },\n): ElementUpdate<ExcalidrawElbowArrowElement> => {\n  if (arrow.points.length < 2) {\n    return { points: updates.points ?? arrow.points };\n  }\n\n  if (!import.meta.env.PROD) {\n    invariant(\n      !updates.points || updates.points.length >= 2,\n      \"Updated point array length must match the arrow point length, contain \" +\n        \"exactly the new start and end points or not be specified at all (i.e. \" +\n        \"you can't add new points between start and end manually to elbow arrows)\",\n    );\n\n    invariant(\n      !arrow.fixedSegments ||\n        arrow.fixedSegments\n          .map((s) => s.start[0] === s.end[0] || s.start[1] === s.end[1])\n          .every(Boolean),\n      \"Fixed segments must be either horizontal or vertical\",\n    );\n\n    invariant(\n      !updates.fixedSegments ||\n        updates.fixedSegments\n          .map((s) => s.start[0] === s.end[0] || s.start[1] === s.end[1])\n          .every(Boolean),\n      \"Updates to fixed segments must be either horizontal or vertical\",\n    );\n\n    invariant(\n      arrow.points\n        .slice(1)\n        .map(\n          (p, i) => p[0] === arrow.points[i][0] || p[1] === arrow.points[i][1],\n        ),\n      \"Elbow arrow segments must be either horizontal or vertical\",\n    );\n\n    invariant(\n      updates.fixedSegments?.find(\n        (segment) =>\n          segment.index === 1 &&\n          pointsEqual(segment.start, (updates.points ?? arrow.points)[0]),\n      ) == null &&\n        updates.fixedSegments?.find(\n          (segment) =>\n            segment.index === (updates.points ?? arrow.points).length - 1 &&\n            pointsEqual(\n              segment.end,\n              (updates.points ?? arrow.points)[\n                (updates.points ?? arrow.points).length - 1\n              ],\n            ),\n        ) == null,\n      \"The first and last segments cannot be fixed\",\n    );\n  }\n\n  const fixedSegments = updates.fixedSegments ?? arrow.fixedSegments ?? [];\n\n  const updatedPoints: readonly LocalPoint[] = updates.points\n    ? updates.points && updates.points.length === 2\n      ? arrow.points.map((p, idx) =>\n          idx === 0\n            ? updates.points![0]\n            : idx === arrow.points.length - 1\n            ? updates.points![1]\n            : p,\n        )\n      : updates.points.slice()\n    : arrow.points.slice();\n\n  // During all element replacement in the scene, we just need to renormalize\n  // the arrow\n  // TODO (dwelle,mtolmacs): Remove this once Scene.getScene() is removed\n  const {\n    startBinding: updatedStartBinding,\n    endBinding: updatedEndBinding,\n    ...restOfTheUpdates\n  } = updates;\n  const startBinding =\n    typeof updatedStartBinding !== \"undefined\"\n      ? updatedStartBinding\n      : arrow.startBinding;\n  const endBinding =\n    typeof updatedEndBinding !== \"undefined\"\n      ? updatedEndBinding\n      : arrow.endBinding;\n  const startElement =\n    startBinding &&\n    getBindableElementForId(startBinding.elementId, elementsMap);\n  const endElement =\n    endBinding && getBindableElementForId(endBinding.elementId, elementsMap);\n  const areUpdatedPointsValid = validateElbowPoints(updatedPoints);\n\n  if (\n    (startBinding && !startElement && areUpdatedPointsValid) ||\n    (endBinding && !endElement && areUpdatedPointsValid) ||\n    (elementsMap.size === 0 && areUpdatedPointsValid) ||\n    (Object.keys(restOfTheUpdates).length === 0 &&\n      (startElement?.id !== startBinding?.elementId ||\n        endElement?.id !== endBinding?.elementId))\n  ) {\n    return normalizeArrowElementUpdate(\n      updatedPoints.map((p) =>\n        pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]),\n      ),\n      arrow.fixedSegments,\n      arrow.startIsSpecial,\n      arrow.endIsSpecial,\n    );\n  }\n\n  const {\n    startHeading,\n    endHeading,\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    hoveredEndElement,\n    ...rest\n  } = getElbowArrowData(\n    {\n      x: arrow.x,\n      y: arrow.y,\n      startBinding,\n      endBinding,\n      startArrowhead: arrow.startArrowhead,\n      endArrowhead: arrow.endArrowhead,\n      points: arrow.points,\n    },\n    elementsMap,\n    updatedPoints,\n    options,\n  );\n\n  // 0. During all element replacement in the scene, we just need to renormalize\n  // the arrow\n  // TODO (dwelle,mtolmacs): Remove this once Scene.getScene() is removed\n  if (elementsMap.size === 0 && areUpdatedPointsValid) {\n    return normalizeArrowElementUpdate(\n      updatedPoints.map((p) =>\n        pointFrom<GlobalPoint>(arrow.x + p[0], arrow.y + p[1]),\n      ),\n      arrow.fixedSegments,\n      arrow.startIsSpecial,\n      arrow.endIsSpecial,\n    );\n  }\n\n  ////\n  // 1. Renormalize the arrow\n  ////\n  if (\n    !updates.points &&\n    !updates.fixedSegments &&\n    !updates.startBinding &&\n    !updates.endBinding\n  ) {\n    return handleSegmentRenormalization(arrow, elementsMap);\n  }\n\n  // Short circuit on no-op to avoid huge performance hit\n  if (\n    updates.startBinding === arrow.startBinding &&\n    updates.endBinding === arrow.endBinding &&\n    (updates.points ?? []).every((p, i) =>\n      pointsEqual(\n        p,\n        arrow.points[i] ?? pointFrom<LocalPoint>(Infinity, Infinity),\n      ),\n    ) &&\n    areUpdatedPointsValid\n  ) {\n    return {};\n  }\n\n  ////\n  // 2. Just normal elbow arrow things\n  ////\n  if (fixedSegments.length === 0) {\n    return normalizeArrowElementUpdate(\n      getElbowArrowCornerPoints(\n        removeElbowArrowShortSegments(\n          routeElbowArrow(arrow, {\n            startHeading,\n            endHeading,\n            startGlobalPoint,\n            endGlobalPoint,\n            hoveredStartElement,\n            hoveredEndElement,\n            ...rest,\n          }) ?? [],\n        ),\n      ),\n      fixedSegments,\n      null,\n      null,\n    );\n  }\n\n  ////\n  // 3. Handle releasing a fixed segment\n  if ((arrow.fixedSegments?.length ?? 0) > fixedSegments.length) {\n    return handleSegmentRelease(arrow, fixedSegments, elementsMap);\n  }\n\n  ////\n  // 4. Handle manual segment move\n  ////\n  if (!updates.points) {\n    return handleSegmentMove(\n      arrow,\n      fixedSegments,\n      startHeading,\n      endHeading,\n      hoveredStartElement,\n      hoveredEndElement,\n    );\n  }\n\n  ////\n  // 5. Handle resize\n  ////\n  if (updates.points && updates.fixedSegments) {\n    return updates;\n  }\n\n  ////\n  // 6. One or more segments are fixed and endpoints are moved\n  //\n  // The key insights are:\n  // - When segments are fixed, the arrow will keep the exact amount of segments\n  // - Fixed segments are \"replacements\" for exactly one segment in the old arrow\n  ////\n  return handleEndpointDrag(\n    arrow,\n    updatedPoints,\n    fixedSegments,\n    startHeading,\n    endHeading,\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    hoveredEndElement,\n  );\n};\n\n/**\n * Retrieves data necessary for calculating the elbow arrow path.\n *\n * @param arrow - The arrow object containing its properties.\n * @param elementsMap - A map of elements in the scene.\n * @param nextPoints - The next set of points for the arrow.\n * @param options - Optional parameters for the calculation.\n * @param options.isDragging - Indicates if the arrow is being dragged.\n * @param options.startIsMidPoint - Indicates if the start point is a midpoint.\n * @param options.endIsMidPoint - Indicates if the end point is a midpoint.\n *\n * @returns An object containing various properties needed for elbow arrow calculations:\n * - dynamicAABBs: Dynamically generated axis-aligned bounding boxes.\n * - startDonglePosition: The position of the start dongle.\n * - startGlobalPoint: The global coordinates of the start point.\n * - startHeading: The heading direction from the start point.\n * - endDonglePosition: The position of the end dongle.\n * - endGlobalPoint: The global coordinates of the end point.\n * - endHeading: The heading direction from the end point.\n * - commonBounds: The common bounding box that encompasses both start and end points.\n * - hoveredStartElement: The element being hovered over at the start point.\n * - hoveredEndElement: The element being hovered over at the end point.\n */\nconst getElbowArrowData = (\n  arrow: {\n    x: number;\n    y: number;\n    startBinding: FixedPointBinding | null;\n    endBinding: FixedPointBinding | null;\n    startArrowhead: Arrowhead | null;\n    endArrowhead: Arrowhead | null;\n    points: readonly LocalPoint[];\n  },\n  elementsMap: NonDeletedSceneElementsMap,\n  nextPoints: readonly LocalPoint[],\n  options?: {\n    isDragging?: boolean;\n    zoom?: AppState[\"zoom\"];\n  },\n) => {\n  const origStartGlobalPoint: GlobalPoint = pointTranslate<\n    LocalPoint,\n    GlobalPoint\n  >(nextPoints[0], vector(arrow.x, arrow.y));\n  const origEndGlobalPoint: GlobalPoint = pointTranslate<\n    LocalPoint,\n    GlobalPoint\n  >(nextPoints[nextPoints.length - 1], vector(arrow.x, arrow.y));\n\n  let hoveredStartElement = null;\n  let hoveredEndElement = null;\n  if (options?.isDragging) {\n    const elements = Array.from(elementsMap.values());\n    hoveredStartElement =\n      getHoveredElement(\n        origStartGlobalPoint,\n        elementsMap,\n        elements,\n        options?.zoom,\n      ) || null;\n    hoveredEndElement =\n      getHoveredElement(\n        origEndGlobalPoint,\n        elementsMap,\n        elements,\n        options?.zoom,\n      ) || null;\n  } else {\n    hoveredStartElement = arrow.startBinding\n      ? getBindableElementForId(arrow.startBinding.elementId, elementsMap) ||\n        null\n      : null;\n    hoveredEndElement = arrow.endBinding\n      ? getBindableElementForId(arrow.endBinding.elementId, elementsMap) || null\n      : null;\n  }\n\n  const startGlobalPoint = getGlobalPoint(\n    {\n      ...arrow,\n      type: \"arrow\",\n      elbowed: true,\n      points: nextPoints,\n    } as ExcalidrawElbowArrowElement,\n    \"start\",\n    arrow.startBinding?.fixedPoint,\n    origStartGlobalPoint,\n    hoveredStartElement,\n    elementsMap,\n    options?.isDragging,\n  );\n  const endGlobalPoint = getGlobalPoint(\n    {\n      ...arrow,\n      type: \"arrow\",\n      elbowed: true,\n      points: nextPoints,\n    } as ExcalidrawElbowArrowElement,\n    \"end\",\n    arrow.endBinding?.fixedPoint,\n    origEndGlobalPoint,\n    hoveredEndElement,\n    elementsMap,\n    options?.isDragging,\n  );\n  const startHeading = getBindPointHeading(\n    startGlobalPoint,\n    endGlobalPoint,\n    hoveredStartElement,\n    origStartGlobalPoint,\n    elementsMap,\n  );\n  const endHeading = getBindPointHeading(\n    endGlobalPoint,\n    startGlobalPoint,\n    hoveredEndElement,\n    origEndGlobalPoint,\n    elementsMap,\n  );\n  const startPointBounds = [\n    startGlobalPoint[0] - 2,\n    startGlobalPoint[1] - 2,\n    startGlobalPoint[0] + 2,\n    startGlobalPoint[1] + 2,\n  ] as Bounds;\n  const endPointBounds = [\n    endGlobalPoint[0] - 2,\n    endGlobalPoint[1] - 2,\n    endGlobalPoint[0] + 2,\n    endGlobalPoint[1] + 2,\n  ] as Bounds;\n  const startElementBounds = hoveredStartElement\n    ? aabbForElement(\n        hoveredStartElement,\n        elementsMap,\n        offsetFromHeading(\n          startHeading,\n          arrow.startArrowhead\n            ? FIXED_BINDING_DISTANCE * 6\n            : FIXED_BINDING_DISTANCE * 2,\n          1,\n        ),\n      )\n    : startPointBounds;\n  const endElementBounds = hoveredEndElement\n    ? aabbForElement(\n        hoveredEndElement,\n        elementsMap,\n        offsetFromHeading(\n          endHeading,\n          arrow.endArrowhead\n            ? FIXED_BINDING_DISTANCE * 6\n            : FIXED_BINDING_DISTANCE * 2,\n          1,\n        ),\n      )\n    : endPointBounds;\n  const boundsOverlap =\n    pointInsideBounds(\n      startGlobalPoint,\n      hoveredEndElement\n        ? aabbForElement(\n            hoveredEndElement,\n            elementsMap,\n            offsetFromHeading(endHeading, BASE_PADDING, BASE_PADDING),\n          )\n        : endPointBounds,\n    ) ||\n    pointInsideBounds(\n      endGlobalPoint,\n      hoveredStartElement\n        ? aabbForElement(\n            hoveredStartElement,\n            elementsMap,\n            offsetFromHeading(startHeading, BASE_PADDING, BASE_PADDING),\n          )\n        : startPointBounds,\n    );\n  const commonBounds = commonAABB(\n    boundsOverlap\n      ? [startPointBounds, endPointBounds]\n      : [startElementBounds, endElementBounds],\n  );\n  const dynamicAABBs = generateDynamicAABBs(\n    boundsOverlap ? startPointBounds : startElementBounds,\n    boundsOverlap ? endPointBounds : endElementBounds,\n    commonBounds,\n    boundsOverlap\n      ? offsetFromHeading(\n          startHeading,\n          !hoveredStartElement && !hoveredEndElement ? 0 : BASE_PADDING,\n          0,\n        )\n      : offsetFromHeading(\n          startHeading,\n          !hoveredStartElement && !hoveredEndElement\n            ? 0\n            : BASE_PADDING -\n                (arrow.startArrowhead\n                  ? FIXED_BINDING_DISTANCE * 6\n                  : FIXED_BINDING_DISTANCE * 2),\n          BASE_PADDING,\n        ),\n    boundsOverlap\n      ? offsetFromHeading(\n          endHeading,\n          !hoveredStartElement && !hoveredEndElement ? 0 : BASE_PADDING,\n          0,\n        )\n      : offsetFromHeading(\n          endHeading,\n          !hoveredStartElement && !hoveredEndElement\n            ? 0\n            : BASE_PADDING -\n                (arrow.endArrowhead\n                  ? FIXED_BINDING_DISTANCE * 6\n                  : FIXED_BINDING_DISTANCE * 2),\n          BASE_PADDING,\n        ),\n    boundsOverlap,\n    hoveredStartElement && aabbForElement(hoveredStartElement, elementsMap),\n    hoveredEndElement && aabbForElement(hoveredEndElement, elementsMap),\n  );\n  const startDonglePosition = getDonglePosition(\n    dynamicAABBs[0],\n    startHeading,\n    startGlobalPoint,\n  );\n  const endDonglePosition = getDonglePosition(\n    dynamicAABBs[1],\n    endHeading,\n    endGlobalPoint,\n  );\n\n  return {\n    dynamicAABBs,\n    startDonglePosition,\n    startGlobalPoint,\n    startHeading,\n    endDonglePosition,\n    endGlobalPoint,\n    endHeading,\n    commonBounds,\n    hoveredStartElement,\n    hoveredEndElement,\n    boundsOverlap,\n    startElementBounds,\n    endElementBounds,\n  };\n};\n\n/**\n * Generate the elbow arrow segments\n *\n * @param arrow\n * @param elementsMap\n * @param nextPoints\n * @param options\n * @returns\n */\nconst routeElbowArrow = (\n  arrow: ElbowArrowState,\n  elbowArrowData: ElbowArrowData,\n): GlobalPoint[] | null => {\n  const {\n    dynamicAABBs,\n    startDonglePosition,\n    startGlobalPoint,\n    startHeading,\n    endDonglePosition,\n    endGlobalPoint,\n    endHeading,\n    commonBounds,\n    hoveredEndElement,\n  } = elbowArrowData;\n\n  // Canculate Grid positions\n  const grid = calculateGrid(\n    dynamicAABBs,\n    startDonglePosition ? startDonglePosition : startGlobalPoint,\n    startHeading,\n    endDonglePosition ? endDonglePosition : endGlobalPoint,\n    endHeading,\n    commonBounds,\n  );\n\n  const startDongle =\n    startDonglePosition && pointToGridNode(startDonglePosition, grid);\n  const endDongle =\n    endDonglePosition && pointToGridNode(endDonglePosition, grid);\n\n  // Do not allow stepping on the true end or true start points\n  const endNode = pointToGridNode(endGlobalPoint, grid);\n  if (endNode && hoveredEndElement) {\n    endNode.closed = true;\n  }\n  const startNode = pointToGridNode(startGlobalPoint, grid);\n  if (startNode && arrow.startBinding) {\n    startNode.closed = true;\n  }\n  const dongleOverlap =\n    startDongle &&\n    endDongle &&\n    (pointInsideBounds(startDongle.pos, dynamicAABBs[1]) ||\n      pointInsideBounds(endDongle.pos, dynamicAABBs[0]));\n\n  // Create path to end dongle from start dongle\n  const path = astar(\n    startDongle ? startDongle : startNode!,\n    endDongle ? endDongle : endNode!,\n    grid,\n    startHeading ? startHeading : HEADING_RIGHT,\n    endHeading ? endHeading : HEADING_RIGHT,\n    dongleOverlap ? [] : dynamicAABBs,\n  );\n\n  if (path) {\n    const points = path.map((node) => [\n      node.pos[0],\n      node.pos[1],\n    ]) as GlobalPoint[];\n    startDongle && points.unshift(startGlobalPoint);\n    endDongle && points.push(endGlobalPoint);\n\n    return points;\n  }\n\n  return null;\n};\n\nconst offsetFromHeading = (\n  heading: Heading,\n  head: number,\n  side: number,\n): [number, number, number, number] => {\n  switch (heading) {\n    case HEADING_UP:\n      return [head, side, side, side];\n    case HEADING_RIGHT:\n      return [side, head, side, side];\n    case HEADING_DOWN:\n      return [side, side, head, side];\n  }\n\n  return [side, side, side, head];\n};\n\n/**\n * Routing algorithm based on the A* path search algorithm.\n * @see https://www.geeksforgeeks.org/a-search-algorithm/\n *\n * Binary heap is used to optimize node lookup.\n * See {@link calculateGrid} for the grid calculation details.\n *\n * Additional modifications added due to aesthetic route reasons:\n * 1) Arrow segment direction change is penalized by specific linear constant (bendMultiplier)\n * 2) Arrow segments are not allowed to go \"backwards\", overlapping with the previous segment\n */\nconst astar = (\n  start: Node,\n  end: Node,\n  grid: Grid,\n  startHeading: Heading,\n  endHeading: Heading,\n  aabbs: Bounds[],\n) => {\n  const bendMultiplier = m_dist(start.pos, end.pos);\n  const open = new BinaryHeap<Node>((node) => node.f);\n\n  open.push(start);\n\n  while (open.size() > 0) {\n    // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n    const current = open.pop();\n\n    if (!current || current.closed) {\n      // Current is not passable, continue with next element\n      continue;\n    }\n\n    // End case -- result has been found, return the traced path.\n    if (current === end) {\n      return pathTo(start, current);\n    }\n\n    // Normal case -- move current from open to closed, process each of its neighbors.\n    current.closed = true;\n\n    // Find all neighbors for the current node.\n    const neighbors = getNeighbors(current.addr, grid);\n\n    for (let i = 0; i < 4; i++) {\n      const neighbor = neighbors[i];\n\n      if (!neighbor || neighbor.closed) {\n        // Not a valid node to process, skip to next neighbor.\n        continue;\n      }\n\n      // Intersect\n      const neighborHalfPoint = pointScaleFromOrigin(\n        neighbor.pos,\n        current.pos,\n        0.5,\n      );\n      if (\n        isAnyTrue(\n          ...aabbs.map((aabb) => pointInsideBounds(neighborHalfPoint, aabb)),\n        )\n      ) {\n        continue;\n      }\n\n      // The g score is the shortest distance from start to current node.\n      // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n      const neighborHeading = neighborIndexToHeading(i as 0 | 1 | 2 | 3);\n      const previousDirection = current.parent\n        ? vectorToHeading(vectorFromPoint(current.pos, current.parent.pos))\n        : startHeading;\n\n      // Do not allow going in reverse\n      const reverseHeading = flipHeading(previousDirection);\n      const neighborIsReverseRoute =\n        compareHeading(reverseHeading, neighborHeading) ||\n        (gridAddressesEqual(start.addr, neighbor.addr) &&\n          compareHeading(neighborHeading, startHeading)) ||\n        (gridAddressesEqual(end.addr, neighbor.addr) &&\n          compareHeading(neighborHeading, endHeading));\n      if (neighborIsReverseRoute) {\n        continue;\n      }\n\n      const directionChange = previousDirection !== neighborHeading;\n      const gScore =\n        current.g +\n        m_dist(neighbor.pos, current.pos) +\n        (directionChange ? Math.pow(bendMultiplier, 3) : 0);\n\n      const beenVisited = neighbor.visited;\n\n      if (!beenVisited || gScore < neighbor.g) {\n        const estBendCount = estimateSegmentCount(\n          neighbor,\n          end,\n          neighborHeading,\n          endHeading,\n        );\n        // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n        neighbor.visited = true;\n        neighbor.parent = current;\n        neighbor.h =\n          m_dist(end.pos, neighbor.pos) +\n          estBendCount * Math.pow(bendMultiplier, 2);\n        neighbor.g = gScore;\n        neighbor.f = neighbor.g + neighbor.h;\n        if (!beenVisited) {\n          // Pushing to heap will put it in proper place based on the 'f' value.\n          open.push(neighbor);\n        } else {\n          // Already seen the node, but since it has been rescored we need to reorder it in the heap\n          open.rescoreElement(neighbor);\n        }\n      }\n    }\n  }\n\n  return null;\n};\n\nconst pathTo = (start: Node, node: Node) => {\n  let curr = node;\n  const path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  path.unshift(start);\n\n  return path;\n};\n\nconst m_dist = (a: GlobalPoint | LocalPoint, b: GlobalPoint | LocalPoint) =>\n  Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\n\n/**\n * Create dynamically resizing, always touching\n * bounding boxes having a minimum extent represented\n * by the given static bounds.\n */\nconst generateDynamicAABBs = (\n  a: Bounds,\n  b: Bounds,\n  common: Bounds,\n  startDifference?: [number, number, number, number],\n  endDifference?: [number, number, number, number],\n  disableSideHack?: boolean,\n  startElementBounds?: Bounds | null,\n  endElementBounds?: Bounds | null,\n): Bounds[] => {\n  const startEl = startElementBounds ?? a;\n  const endEl = endElementBounds ?? b;\n  const [startUp, startRight, startDown, startLeft] = startDifference ?? [\n    0, 0, 0, 0,\n  ];\n  const [endUp, endRight, endDown, endLeft] = endDifference ?? [0, 0, 0, 0];\n\n  const first = [\n    a[0] > b[2]\n      ? a[1] > b[3] || a[3] < b[1]\n        ? Math.min((startEl[0] + endEl[2]) / 2, a[0] - startLeft)\n        : (startEl[0] + endEl[2]) / 2\n      : a[0] > b[0]\n      ? a[0] - startLeft\n      : common[0] - startLeft,\n    a[1] > b[3]\n      ? a[0] > b[2] || a[2] < b[0]\n        ? Math.min((startEl[1] + endEl[3]) / 2, a[1] - startUp)\n        : (startEl[1] + endEl[3]) / 2\n      : a[1] > b[1]\n      ? a[1] - startUp\n      : common[1] - startUp,\n    a[2] < b[0]\n      ? a[1] > b[3] || a[3] < b[1]\n        ? Math.max((startEl[2] + endEl[0]) / 2, a[2] + startRight)\n        : (startEl[2] + endEl[0]) / 2\n      : a[2] < b[2]\n      ? a[2] + startRight\n      : common[2] + startRight,\n    a[3] < b[1]\n      ? a[0] > b[2] || a[2] < b[0]\n        ? Math.max((startEl[3] + endEl[1]) / 2, a[3] + startDown)\n        : (startEl[3] + endEl[1]) / 2\n      : a[3] < b[3]\n      ? a[3] + startDown\n      : common[3] + startDown,\n  ] as Bounds;\n  const second = [\n    b[0] > a[2]\n      ? b[1] > a[3] || b[3] < a[1]\n        ? Math.min((endEl[0] + startEl[2]) / 2, b[0] - endLeft)\n        : (endEl[0] + startEl[2]) / 2\n      : b[0] > a[0]\n      ? b[0] - endLeft\n      : common[0] - endLeft,\n    b[1] > a[3]\n      ? b[0] > a[2] || b[2] < a[0]\n        ? Math.min((endEl[1] + startEl[3]) / 2, b[1] - endUp)\n        : (endEl[1] + startEl[3]) / 2\n      : b[1] > a[1]\n      ? b[1] - endUp\n      : common[1] - endUp,\n    b[2] < a[0]\n      ? b[1] > a[3] || b[3] < a[1]\n        ? Math.max((endEl[2] + startEl[0]) / 2, b[2] + endRight)\n        : (endEl[2] + startEl[0]) / 2\n      : b[2] < a[2]\n      ? b[2] + endRight\n      : common[2] + endRight,\n    b[3] < a[1]\n      ? b[0] > a[2] || b[2] < a[0]\n        ? Math.max((endEl[3] + startEl[1]) / 2, b[3] + endDown)\n        : (endEl[3] + startEl[1]) / 2\n      : b[3] < a[3]\n      ? b[3] + endDown\n      : common[3] + endDown,\n  ] as Bounds;\n\n  const c = commonAABB([first, second]);\n  if (\n    !disableSideHack &&\n    first[2] - first[0] + second[2] - second[0] > c[2] - c[0] + 0.00000000001 &&\n    first[3] - first[1] + second[3] - second[1] > c[3] - c[1] + 0.00000000001\n  ) {\n    const [endCenterX, endCenterY] = [\n      (second[0] + second[2]) / 2,\n      (second[1] + second[3]) / 2,\n    ];\n    if (b[0] > a[2] && a[1] > b[3]) {\n      // BOTTOM LEFT\n      const cX = first[2] + (second[0] - first[2]) / 2;\n      const cY = second[3] + (first[1] - second[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[2] - endCenterX, a[1] - endCenterY),\n          vector(a[0] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [first[0], first[1], cX, first[3]],\n          [cX, second[1], second[2], second[3]],\n        ];\n      }\n\n      return [\n        [first[0], cY, first[2], first[3]],\n        [second[0], second[1], second[2], cY],\n      ];\n    } else if (a[2] < b[0] && a[3] < b[1]) {\n      // TOP LEFT\n      const cX = first[2] + (second[0] - first[2]) / 2;\n      const cY = first[3] + (second[1] - first[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[0] - endCenterX, a[1] - endCenterY),\n          vector(a[2] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [first[0], first[1], first[2], cY],\n          [second[0], cY, second[2], second[3]],\n        ];\n      }\n\n      return [\n        [first[0], first[1], cX, first[3]],\n        [cX, second[1], second[2], second[3]],\n      ];\n    } else if (a[0] > b[2] && a[3] < b[1]) {\n      // TOP RIGHT\n      const cX = second[2] + (first[0] - second[2]) / 2;\n      const cY = first[3] + (second[1] - first[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[2] - endCenterX, a[1] - endCenterY),\n          vector(a[0] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [cX, first[1], first[2], first[3]],\n          [second[0], second[1], cX, second[3]],\n        ];\n      }\n\n      return [\n        [first[0], first[1], first[2], cY],\n        [second[0], cY, second[2], second[3]],\n      ];\n    } else if (a[0] > b[2] && a[1] > b[3]) {\n      // BOTTOM RIGHT\n      const cX = second[2] + (first[0] - second[2]) / 2;\n      const cY = second[3] + (first[1] - second[3]) / 2;\n\n      if (\n        vectorCross(\n          vector(a[0] - endCenterX, a[1] - endCenterY),\n          vector(a[2] - endCenterX, a[3] - endCenterY),\n        ) > 0\n      ) {\n        return [\n          [cX, first[1], first[2], first[3]],\n          [second[0], second[1], cX, second[3]],\n        ];\n      }\n\n      return [\n        [first[0], cY, first[2], first[3]],\n        [second[0], second[1], second[2], cY],\n      ];\n    }\n  }\n\n  return [first, second];\n};\n\n/**\n * Calculates the grid which is used as nodes at\n * the grid line intersections by the A* algorithm.\n *\n * NOTE: This is not a uniform grid. It is built at\n * various intersections of bounding boxes.\n */\nconst calculateGrid = (\n  aabbs: Bounds[],\n  start: GlobalPoint,\n  startHeading: Heading,\n  end: GlobalPoint,\n  endHeading: Heading,\n  common: Bounds,\n): Grid => {\n  const horizontal = new Set<number>();\n  const vertical = new Set<number>();\n\n  if (startHeading === HEADING_LEFT || startHeading === HEADING_RIGHT) {\n    vertical.add(start[1]);\n  } else {\n    horizontal.add(start[0]);\n  }\n  if (endHeading === HEADING_LEFT || endHeading === HEADING_RIGHT) {\n    vertical.add(end[1]);\n  } else {\n    horizontal.add(end[0]);\n  }\n\n  aabbs.forEach((aabb) => {\n    horizontal.add(aabb[0]);\n    horizontal.add(aabb[2]);\n    vertical.add(aabb[1]);\n    vertical.add(aabb[3]);\n  });\n\n  horizontal.add(common[0]);\n  horizontal.add(common[2]);\n  vertical.add(common[1]);\n  vertical.add(common[3]);\n\n  const _vertical = Array.from(vertical).sort((a, b) => a - b);\n  const _horizontal = Array.from(horizontal).sort((a, b) => a - b);\n\n  return {\n    row: _vertical.length,\n    col: _horizontal.length,\n    data: _vertical.flatMap((y, row) =>\n      _horizontal.map(\n        (x, col): Node => ({\n          f: 0,\n          g: 0,\n          h: 0,\n          closed: false,\n          visited: false,\n          parent: null,\n          addr: [col, row] as GridAddress,\n          pos: [x, y] as GlobalPoint,\n        }),\n      ),\n    ),\n  };\n};\n\nconst getDonglePosition = (\n  bounds: Bounds,\n  heading: Heading,\n  p: GlobalPoint,\n): GlobalPoint => {\n  switch (heading) {\n    case HEADING_UP:\n      return pointFrom(p[0], bounds[1]);\n    case HEADING_RIGHT:\n      return pointFrom(bounds[2], p[1]);\n    case HEADING_DOWN:\n      return pointFrom(p[0], bounds[3]);\n  }\n  return pointFrom(bounds[0], p[1]);\n};\n\nconst estimateSegmentCount = (\n  start: Node,\n  end: Node,\n  startHeading: Heading,\n  endHeading: Heading,\n) => {\n  if (endHeading === HEADING_RIGHT) {\n    switch (startHeading) {\n      case HEADING_RIGHT: {\n        if (start.pos[0] >= end.pos[0]) {\n          return 4;\n        }\n        if (start.pos[1] === end.pos[1]) {\n          return 0;\n        }\n        return 2;\n      }\n      case HEADING_UP:\n        if (start.pos[1] > end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_DOWN:\n        if (start.pos[1] < end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_LEFT:\n        if (start.pos[1] === end.pos[1]) {\n          return 4;\n        }\n        return 2;\n    }\n  } else if (endHeading === HEADING_LEFT) {\n    switch (startHeading) {\n      case HEADING_RIGHT:\n        if (start.pos[1] === end.pos[1]) {\n          return 4;\n        }\n        return 2;\n      case HEADING_UP:\n        if (start.pos[1] > end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_DOWN:\n        if (start.pos[1] < end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_LEFT:\n        if (start.pos[0] <= end.pos[0]) {\n          return 4;\n        }\n        if (start.pos[1] === end.pos[1]) {\n          return 0;\n        }\n        return 2;\n    }\n  } else if (endHeading === HEADING_UP) {\n    switch (startHeading) {\n      case HEADING_RIGHT:\n        if (start.pos[1] > end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_UP:\n        if (start.pos[1] >= end.pos[1]) {\n          return 4;\n        }\n        if (start.pos[0] === end.pos[0]) {\n          return 0;\n        }\n        return 2;\n      case HEADING_DOWN:\n        if (start.pos[0] === end.pos[0]) {\n          return 4;\n        }\n        return 2;\n      case HEADING_LEFT:\n        if (start.pos[1] > end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n    }\n  } else if (endHeading === HEADING_DOWN) {\n    switch (startHeading) {\n      case HEADING_RIGHT:\n        if (start.pos[1] < end.pos[1] && start.pos[0] < end.pos[0]) {\n          return 1;\n        }\n        return 3;\n      case HEADING_UP:\n        if (start.pos[0] === end.pos[0]) {\n          return 4;\n        }\n        return 2;\n      case HEADING_DOWN:\n        if (start.pos[1] <= end.pos[1]) {\n          return 4;\n        }\n        if (start.pos[0] === end.pos[0]) {\n          return 0;\n        }\n        return 2;\n      case HEADING_LEFT:\n        if (start.pos[1] < end.pos[1] && start.pos[0] > end.pos[0]) {\n          return 1;\n        }\n        return 3;\n    }\n  }\n  return 0;\n};\n\n/**\n * Get neighboring points for a gived grid address\n */\nconst getNeighbors = ([col, row]: [number, number], grid: Grid) =>\n  [\n    gridNodeFromAddr([col, row - 1], grid),\n    gridNodeFromAddr([col + 1, row], grid),\n    gridNodeFromAddr([col, row + 1], grid),\n    gridNodeFromAddr([col - 1, row], grid),\n  ] as [Node | null, Node | null, Node | null, Node | null];\n\nconst gridNodeFromAddr = (\n  [col, row]: [col: number, row: number],\n  grid: Grid,\n): Node | null => {\n  if (col < 0 || col >= grid.col || row < 0 || row >= grid.row) {\n    return null;\n  }\n\n  return grid.data[row * grid.col + col] ?? null;\n};\n\n/**\n * Get node for global point on canvas (if exists)\n */\nconst pointToGridNode = (point: GlobalPoint, grid: Grid): Node | null => {\n  for (let col = 0; col < grid.col; col++) {\n    for (let row = 0; row < grid.row; row++) {\n      const candidate = gridNodeFromAddr([col, row], grid);\n      if (\n        candidate &&\n        point[0] === candidate.pos[0] &&\n        point[1] === candidate.pos[1]\n      ) {\n        return candidate;\n      }\n    }\n  }\n\n  return null;\n};\n\nconst commonAABB = (aabbs: Bounds[]): Bounds => [\n  Math.min(...aabbs.map((aabb) => aabb[0])),\n  Math.min(...aabbs.map((aabb) => aabb[1])),\n  Math.max(...aabbs.map((aabb) => aabb[2])),\n  Math.max(...aabbs.map((aabb) => aabb[3])),\n];\n\n/// #region Utils\n\nconst getBindableElementForId = (\n  id: string,\n  elementsMap: ElementsMap,\n): ExcalidrawBindableElement | null => {\n  const element = elementsMap.get(id);\n  if (element && isBindableElement(element)) {\n    return element;\n  }\n\n  return null;\n};\n\nconst normalizeArrowElementUpdate = (\n  global: GlobalPoint[],\n  nextFixedSegments: readonly FixedSegment[] | null,\n  startIsSpecial?: ExcalidrawElbowArrowElement[\"startIsSpecial\"],\n  endIsSpecial?: ExcalidrawElbowArrowElement[\"startIsSpecial\"],\n): {\n  points: LocalPoint[];\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  fixedSegments: readonly FixedSegment[] | null;\n  startIsSpecial?: ExcalidrawElbowArrowElement[\"startIsSpecial\"];\n  endIsSpecial?: ExcalidrawElbowArrowElement[\"startIsSpecial\"];\n} => {\n  const offsetX = global[0][0];\n  const offsetY = global[0][1];\n  let points = global.map((p) =>\n    pointTranslate<GlobalPoint, LocalPoint>(\n      p,\n      vectorScale(vectorFromPoint(global[0]), -1),\n    ),\n  );\n\n  // NOTE (mtolmacs): This is a temporary check to see if the normalization\n  // creates an overly large arrow. This should be removed once we have an answer.\n  if (\n    offsetX < -MAX_POS ||\n    offsetX > MAX_POS ||\n    offsetY < -MAX_POS ||\n    offsetY > MAX_POS ||\n    offsetX + points[points.length - 1][0] < -MAX_POS ||\n    offsetY + points[points.length - 1][0] > MAX_POS ||\n    offsetX + points[points.length - 1][1] < -MAX_POS ||\n    offsetY + points[points.length - 1][1] > MAX_POS\n  ) {\n    console.error(\n      \"Elbow arrow normalization is outside reasonable bounds (> 1e6)\",\n      {\n        x: offsetX,\n        y: offsetY,\n        points,\n        ...getSizeFromPoints(points),\n      },\n    );\n  }\n\n  points = points.map(([x, y]) =>\n    pointFrom<LocalPoint>(clamp(x, -1e6, 1e6), clamp(y, -1e6, 1e6)),\n  );\n\n  return {\n    points,\n    x: clamp(offsetX, -1e6, 1e6),\n    y: clamp(offsetY, -1e6, 1e6),\n    fixedSegments:\n      (nextFixedSegments?.length ?? 0) > 0 ? nextFixedSegments : null,\n    ...getSizeFromPoints(points),\n    startIsSpecial,\n    endIsSpecial,\n  };\n};\n\nconst getElbowArrowCornerPoints = (points: GlobalPoint[]): GlobalPoint[] => {\n  if (points.length > 1) {\n    let previousHorizontal =\n      Math.abs(points[0][1] - points[1][1]) <\n      Math.abs(points[0][0] - points[1][0]);\n\n    return points.filter((p, idx) => {\n      // The very first and last points are always kept\n      if (idx === 0 || idx === points.length - 1) {\n        return true;\n      }\n\n      const next = points[idx + 1];\n      const nextHorizontal =\n        Math.abs(p[1] - next[1]) < Math.abs(p[0] - next[0]);\n      if (previousHorizontal === nextHorizontal) {\n        previousHorizontal = nextHorizontal;\n        return false;\n      }\n\n      previousHorizontal = nextHorizontal;\n      return true;\n    });\n  }\n\n  return points;\n};\n\nconst removeElbowArrowShortSegments = (\n  points: GlobalPoint[],\n): GlobalPoint[] => {\n  if (points.length >= 4) {\n    return points.filter((p, idx) => {\n      if (idx === 0 || idx === points.length - 1) {\n        return true;\n      }\n\n      const prev = points[idx - 1];\n      const prevDist = pointDistance(prev, p);\n      return prevDist > DEDUP_TRESHOLD;\n    });\n  }\n\n  return points;\n};\n\nconst neighborIndexToHeading = (idx: number): Heading => {\n  switch (idx) {\n    case 0:\n      return HEADING_UP;\n    case 1:\n      return HEADING_RIGHT;\n    case 2:\n      return HEADING_DOWN;\n  }\n  return HEADING_LEFT;\n};\n\nconst getGlobalPoint = (\n  arrow: ExcalidrawElbowArrowElement,\n  startOrEnd: \"start\" | \"end\",\n  fixedPointRatio: [number, number] | undefined | null,\n  initialPoint: GlobalPoint,\n  element?: ExcalidrawBindableElement | null,\n  elementsMap?: ElementsMap,\n  isDragging?: boolean,\n): GlobalPoint => {\n  if (isDragging) {\n    if (element && elementsMap) {\n      return bindPointToSnapToElementOutline(\n        arrow,\n        element,\n        startOrEnd,\n        elementsMap,\n      );\n    }\n\n    return initialPoint;\n  }\n\n  if (element) {\n    return getGlobalFixedPointForBindableElement(\n      fixedPointRatio || [0, 0],\n      element,\n      elementsMap ?? arrayToMap([element]),\n    );\n  }\n\n  return initialPoint;\n};\n\nconst getBindPointHeading = (\n  p: GlobalPoint,\n  otherPoint: GlobalPoint,\n  hoveredElement: ExcalidrawBindableElement | null | undefined,\n  origPoint: GlobalPoint,\n  elementsMap: ElementsMap,\n): Heading =>\n  getHeadingForElbowArrowSnap(\n    p,\n    otherPoint,\n    hoveredElement,\n    hoveredElement &&\n      aabbForElement(\n        hoveredElement,\n        elementsMap,\n        Array(4).fill(distanceToElement(hoveredElement, elementsMap, p)) as [\n          number,\n          number,\n          number,\n          number,\n        ],\n      ),\n    origPoint,\n    elementsMap,\n  );\n\nconst getHoveredElement = (\n  origPoint: GlobalPoint,\n  elementsMap: NonDeletedSceneElementsMap,\n  elements: readonly NonDeletedExcalidrawElement[],\n  zoom?: AppState[\"zoom\"],\n) => {\n  return getHoveredElementForBinding(\n    tupleToCoors(origPoint),\n    elements,\n    elementsMap,\n    zoom,\n    true,\n    true,\n  );\n};\n\nconst gridAddressesEqual = (a: GridAddress, b: GridAddress): boolean =>\n  a[0] === b[0] && a[1] === b[1];\n\nexport const validateElbowPoints = <P extends GlobalPoint | LocalPoint>(\n  points: readonly P[],\n  tolerance: number = DEDUP_TRESHOLD,\n) =>\n  points\n    .slice(1)\n    .map(\n      (p, i) =>\n        Math.abs(p[0] - points[i][0]) < tolerance ||\n        Math.abs(p[1] - points[i][1]) < tolerance,\n    )\n    .every(Boolean);\n",
    "import {\n  SHIFT_LOCKING_ANGLE,\n  viewportCoordsToSceneCoords,\n} from \"@excalidraw/common\";\nimport {\n  normalizeRadians,\n  radiansBetweenAngles,\n  radiansDifference,\n  type Radians,\n} from \"@excalidraw/math\";\n\nimport { pointsEqual } from \"@excalidraw/math\";\n\nimport type { AppState, Offsets, Zoom } from \"excalidraw-custom/types\";\n\nimport { getCommonBounds, getElementBounds } from \"./bounds\";\nimport {\n  isArrowElement,\n  isFreeDrawElement,\n  isLinearElement,\n} from \"./typeChecks\";\n\nimport type { ElementsMap, ExcalidrawElement } from \"./types\";\n\nexport const INVISIBLY_SMALL_ELEMENT_SIZE = 0.1;\n\n// TODO:  remove invisible elements consistently actions, so that invisible elements are not recorded by the store, exported, broadcasted or persisted\n//        - perhaps could be as part of a standalone 'cleanup' action, in addition to 'finalize'\n//        - could also be part of `_clearElements`\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return (\n      element.points.length < 2 ||\n      (element.points.length === 2 &&\n        isArrowElement(element) &&\n        pointsEqual(\n          element.points[0],\n          element.points[element.points.length - 1],\n          INVISIBLY_SMALL_ELEMENT_SIZE,\n        ))\n    );\n  }\n\n  return element.width === 0 && element.height === 0;\n};\n\nexport const isElementInViewport = (\n  element: ExcalidrawElement,\n  width: number,\n  height: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n  elementsMap: ElementsMap,\n) => {\n  const [x1, y1, x2, y2] = getElementBounds(element, elementsMap); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft,\n      clientY: viewTransformations.offsetTop,\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + width,\n      clientY: viewTransformations.offsetTop + height,\n    },\n    viewTransformations,\n  );\n\n  return (\n    topLeftSceneCoords.x <= x2 &&\n    topLeftSceneCoords.y <= y2 &&\n    bottomRightSceneCoords.x >= x1 &&\n    bottomRightSceneCoords.y >= y1\n  );\n};\n\nexport const isElementCompletelyInViewport = (\n  elements: ExcalidrawElement[],\n  width: number,\n  height: number,\n  viewTransformations: {\n    zoom: Zoom;\n    offsetLeft: number;\n    offsetTop: number;\n    scrollX: number;\n    scrollY: number;\n  },\n  elementsMap: ElementsMap,\n  padding?: Offsets,\n) => {\n  const [x1, y1, x2, y2] = getCommonBounds(elements, elementsMap); // scene coordinates\n  const topLeftSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + (padding?.left || 0),\n      clientY: viewTransformations.offsetTop + (padding?.top || 0),\n    },\n    viewTransformations,\n  );\n  const bottomRightSceneCoords = viewportCoordsToSceneCoords(\n    {\n      clientX: viewTransformations.offsetLeft + width - (padding?.right || 0),\n      clientY: viewTransformations.offsetTop + height - (padding?.bottom || 0),\n    },\n    viewTransformations,\n  );\n\n  return (\n    x1 >= topLeftSceneCoords.x &&\n    y1 >= topLeftSceneCoords.y &&\n    x2 <= bottomRightSceneCoords.x &&\n    y2 <= bottomRightSceneCoords.y\n  );\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: AppState[\"activeTool\"][\"type\"],\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"freedraw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height = absWidth * Math.tan(lockedAngle) * Math.sign(height) || height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const getLockedLinearCursorAlignSize = (\n  originX: number,\n  originY: number,\n  x: number,\n  y: number,\n  customAngle?: number,\n) => {\n  let width = x - originX;\n  let height = y - originY;\n\n  const angle = Math.atan2(height, width) as Radians;\n  let lockedAngle = (Math.round(angle / SHIFT_LOCKING_ANGLE) *\n    SHIFT_LOCKING_ANGLE) as Radians;\n\n  if (customAngle) {\n    // If custom angle is provided, we check if the angle is close to the\n    // custom angle, snap to that if close engough, otherwise snap to the\n    // higher or lower angle depending on the current angle vs custom angle.\n    const lower = (Math.floor(customAngle / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE) as Radians;\n    if (\n      radiansBetweenAngles(\n        angle,\n        lower,\n        (lower + SHIFT_LOCKING_ANGLE) as Radians,\n      )\n    ) {\n      if (\n        radiansDifference(angle, customAngle as Radians) <\n        SHIFT_LOCKING_ANGLE / 6\n      ) {\n        lockedAngle = customAngle as Radians;\n      } else if (\n        normalizeRadians(angle) > normalizeRadians(customAngle as Radians)\n      ) {\n        lockedAngle = (lower + SHIFT_LOCKING_ANGLE) as Radians;\n      } else {\n        lockedAngle = lower;\n      }\n    }\n  }\n\n  if (lockedAngle === 0) {\n    height = 0;\n  } else if (lockedAngle === Math.PI / 2) {\n    width = 0;\n  } else {\n    // locked angle line, y = mx + b => mx - y + b = 0\n    const a1 = Math.tan(lockedAngle);\n    const b1 = -1;\n    const c1 = originY - a1 * originX;\n\n    // line through cursor, perpendicular to locked angle line\n    const a2 = -1 / a1;\n    const b2 = -1;\n    const c2 = y - a2 * x;\n\n    // intersection of the two lines above\n    const intersectX = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const intersectY = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);\n\n    // delta\n    width = intersectX - originX;\n    height = intersectY - originY;\n  }\n\n  return { width, height };\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n",
    "import {\n  type Radians,\n  pointFrom,\n  pointCenter,\n  pointRotateRads,\n  vectorFromPoint,\n  vectorNormalize,\n  vectorSubtract,\n  vectorAdd,\n  vectorScale,\n  pointFromVector,\n  clamp,\n  isCloseTo,\n} from \"@excalidraw/math\";\nimport { type Point } from \"points-on-curve\";\n\nimport {\n  elementCenterPoint,\n  getElementAbsoluteCoords,\n  getResizedElementAbsoluteCoords,\n} from \"./bounds\";\n\nimport type { TransformHandleType } from \"./transformHandles\";\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  ExcalidrawImageElement,\n  ImageCrop,\n  NonDeleted,\n} from \"./types\";\n\nexport const MINIMAL_CROP_SIZE = 10;\n\nexport const cropElement = (\n  element: ExcalidrawImageElement,\n  elementsMap: ElementsMap,\n  transformHandle: TransformHandleType,\n  naturalWidth: number,\n  naturalHeight: number,\n  pointerX: number,\n  pointerY: number,\n  widthAspectRatio?: number,\n) => {\n  const { width: uncroppedWidth, height: uncroppedHeight } =\n    getUncroppedWidthAndHeight(element);\n\n  const naturalWidthToUncropped = naturalWidth / uncroppedWidth;\n  const naturalHeightToUncropped = naturalHeight / uncroppedHeight;\n\n  const croppedLeft = (element.crop?.x ?? 0) / naturalWidthToUncropped;\n  const croppedTop = (element.crop?.y ?? 0) / naturalHeightToUncropped;\n\n  /**\n   *      uncropped width\n   * *––––––––––––––––––––––––*\n   * |     (x,y) (natural)    |\n   * |       *–––––––*        |\n   * |       |///////| height | uncropped height\n   * |       *–––––––*        |\n   * |    width (natural)     |\n   * *––––––––––––––––––––––––*\n   */\n\n  const rotatedPointer = pointRotateRads(\n    pointFrom(pointerX, pointerY),\n    elementCenterPoint(element, elementsMap),\n    -element.angle as Radians,\n  );\n\n  pointerX = rotatedPointer[0];\n  pointerY = rotatedPointer[1];\n\n  let nextWidth = element.width;\n  let nextHeight = element.height;\n\n  let crop: ImageCrop | null = element.crop ?? {\n    x: 0,\n    y: 0,\n    width: naturalWidth,\n    height: naturalHeight,\n    naturalWidth,\n    naturalHeight,\n  };\n\n  const previousCropHeight = crop.height;\n  const previousCropWidth = crop.width;\n\n  const isFlippedByX = element.scale[0] === -1;\n  const isFlippedByY = element.scale[1] === -1;\n\n  let changeInHeight = pointerY - element.y;\n  let changeInWidth = pointerX - element.x;\n\n  if (transformHandle.includes(\"n\")) {\n    nextHeight = clamp(\n      element.height - changeInHeight,\n      MINIMAL_CROP_SIZE,\n      isFlippedByY ? uncroppedHeight - croppedTop : element.height + croppedTop,\n    );\n  }\n\n  if (transformHandle.includes(\"s\")) {\n    changeInHeight = pointerY - element.y - element.height;\n    nextHeight = clamp(\n      element.height + changeInHeight,\n      MINIMAL_CROP_SIZE,\n      isFlippedByY ? element.height + croppedTop : uncroppedHeight - croppedTop,\n    );\n  }\n\n  if (transformHandle.includes(\"e\")) {\n    changeInWidth = pointerX - element.x - element.width;\n\n    nextWidth = clamp(\n      element.width + changeInWidth,\n      MINIMAL_CROP_SIZE,\n      isFlippedByX ? element.width + croppedLeft : uncroppedWidth - croppedLeft,\n    );\n  }\n\n  if (transformHandle.includes(\"w\")) {\n    nextWidth = clamp(\n      element.width - changeInWidth,\n      MINIMAL_CROP_SIZE,\n      isFlippedByX ? uncroppedWidth - croppedLeft : element.width + croppedLeft,\n    );\n  }\n\n  const updateCropWidthAndHeight = (crop: ImageCrop) => {\n    crop.height = nextHeight * naturalHeightToUncropped;\n    crop.width = nextWidth * naturalWidthToUncropped;\n  };\n\n  updateCropWidthAndHeight(crop);\n\n  const adjustFlipForHandle = (\n    handle: TransformHandleType,\n    crop: ImageCrop,\n  ) => {\n    updateCropWidthAndHeight(crop);\n    if (handle.includes(\"n\")) {\n      if (!isFlippedByY) {\n        crop.y += previousCropHeight - crop.height;\n      }\n    }\n    if (handle.includes(\"s\")) {\n      if (isFlippedByY) {\n        crop.y += previousCropHeight - crop.height;\n      }\n    }\n    if (handle.includes(\"e\")) {\n      if (isFlippedByX) {\n        crop.x += previousCropWidth - crop.width;\n      }\n    }\n    if (handle.includes(\"w\")) {\n      if (!isFlippedByX) {\n        crop.x += previousCropWidth - crop.width;\n      }\n    }\n  };\n\n  switch (transformHandle) {\n    case \"n\": {\n      if (widthAspectRatio) {\n        const distanceToLeft = croppedLeft + element.width / 2;\n        const distanceToRight =\n          uncroppedWidth - croppedLeft - element.width / 2;\n\n        const MAX_WIDTH = Math.min(distanceToLeft, distanceToRight) * 2;\n\n        nextWidth = clamp(\n          nextHeight * widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_WIDTH,\n        );\n        nextHeight = nextWidth / widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.x += (previousCropWidth - crop.width) / 2;\n      }\n\n      break;\n    }\n    case \"s\": {\n      if (widthAspectRatio) {\n        const distanceToLeft = croppedLeft + element.width / 2;\n        const distanceToRight =\n          uncroppedWidth - croppedLeft - element.width / 2;\n\n        const MAX_WIDTH = Math.min(distanceToLeft, distanceToRight) * 2;\n\n        nextWidth = clamp(\n          nextHeight * widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_WIDTH,\n        );\n        nextHeight = nextWidth / widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.x += (previousCropWidth - crop.width) / 2;\n      }\n\n      break;\n    }\n    case \"w\": {\n      if (widthAspectRatio) {\n        const distanceToTop = croppedTop + element.height / 2;\n        const distanceToBottom =\n          uncroppedHeight - croppedTop - element.height / 2;\n\n        const MAX_HEIGHT = Math.min(distanceToTop, distanceToBottom) * 2;\n\n        nextHeight = clamp(\n          nextWidth / widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_HEIGHT,\n        );\n        nextWidth = nextHeight * widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.y += (previousCropHeight - crop.height) / 2;\n      }\n\n      break;\n    }\n    case \"e\": {\n      if (widthAspectRatio) {\n        const distanceToTop = croppedTop + element.height / 2;\n        const distanceToBottom =\n          uncroppedHeight - croppedTop - element.height / 2;\n\n        const MAX_HEIGHT = Math.min(distanceToTop, distanceToBottom) * 2;\n\n        nextHeight = clamp(\n          nextWidth / widthAspectRatio,\n          MINIMAL_CROP_SIZE,\n          MAX_HEIGHT,\n        );\n        nextWidth = nextHeight * widthAspectRatio;\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n\n      if (widthAspectRatio) {\n        crop.y += (previousCropHeight - crop.height) / 2;\n      }\n\n      break;\n    }\n    case \"ne\": {\n      if (widthAspectRatio) {\n        if (changeInWidth > -changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? uncroppedHeight - croppedTop\n            : croppedTop + element.height;\n\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? croppedLeft + element.width\n            : uncroppedWidth - croppedLeft;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    case \"nw\": {\n      if (widthAspectRatio) {\n        if (changeInWidth < changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? uncroppedHeight - croppedTop\n            : croppedTop + element.height;\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? uncroppedWidth - croppedLeft\n            : croppedLeft + element.width;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    case \"se\": {\n      if (widthAspectRatio) {\n        if (changeInWidth > changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? croppedTop + element.height\n            : uncroppedHeight - croppedTop;\n\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? croppedLeft + element.width\n            : uncroppedWidth - croppedLeft;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    case \"sw\": {\n      if (widthAspectRatio) {\n        if (-changeInWidth > changeInHeight) {\n          const MAX_HEIGHT = isFlippedByY\n            ? croppedTop + element.height\n            : uncroppedHeight - croppedTop;\n\n          nextHeight = clamp(\n            nextWidth / widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_HEIGHT,\n          );\n          nextWidth = nextHeight * widthAspectRatio;\n        } else {\n          const MAX_WIDTH = isFlippedByX\n            ? uncroppedWidth - croppedLeft\n            : croppedLeft + element.width;\n\n          nextWidth = clamp(\n            nextHeight * widthAspectRatio,\n            MINIMAL_CROP_SIZE,\n            MAX_WIDTH,\n          );\n          nextHeight = nextWidth / widthAspectRatio;\n        }\n      }\n\n      adjustFlipForHandle(transformHandle, crop);\n      break;\n    }\n    default:\n      break;\n  }\n\n  const newOrigin = recomputeOrigin(\n    element,\n    transformHandle,\n    nextWidth,\n    nextHeight,\n    !!widthAspectRatio,\n  );\n\n  // reset crop to null if we're back to orig size\n  if (\n    isCloseTo(crop.width, crop.naturalWidth) &&\n    isCloseTo(crop.height, crop.naturalHeight)\n  ) {\n    crop = null;\n  }\n\n  return {\n    x: newOrigin[0],\n    y: newOrigin[1],\n    width: nextWidth,\n    height: nextHeight,\n    crop,\n  };\n};\n\nconst recomputeOrigin = (\n  stateAtCropStart: NonDeleted<ExcalidrawElement>,\n  transformHandle: TransformHandleType,\n  width: number,\n  height: number,\n  shouldMaintainAspectRatio?: boolean,\n) => {\n  const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(\n    stateAtCropStart,\n    stateAtCropStart.width,\n    stateAtCropStart.height,\n    true,\n  );\n  const startTopLeft = pointFrom(x1, y1);\n  const startBottomRight = pointFrom(x2, y2);\n  const startCenter: any = pointCenter(startTopLeft, startBottomRight);\n\n  const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] =\n    getResizedElementAbsoluteCoords(stateAtCropStart, width, height, true);\n  const newBoundsWidth = newBoundsX2 - newBoundsX1;\n  const newBoundsHeight = newBoundsY2 - newBoundsY1;\n\n  // Calculate new topLeft based on fixed corner during resize\n  let newTopLeft = [...startTopLeft] as [number, number];\n\n  if ([\"n\", \"w\", \"nw\"].includes(transformHandle)) {\n    newTopLeft = [\n      startBottomRight[0] - Math.abs(newBoundsWidth),\n      startBottomRight[1] - Math.abs(newBoundsHeight),\n    ];\n  }\n  if (transformHandle === \"ne\") {\n    const bottomLeft = [startTopLeft[0], startBottomRight[1]];\n    newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];\n  }\n  if (transformHandle === \"sw\") {\n    const topRight = [startBottomRight[0], startTopLeft[1]];\n    newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];\n  }\n\n  if (shouldMaintainAspectRatio) {\n    if ([\"s\", \"n\"].includes(transformHandle)) {\n      newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;\n    }\n    if ([\"e\", \"w\"].includes(transformHandle)) {\n      newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;\n    }\n  }\n\n  // adjust topLeft to new rotation point\n  const angle = stateAtCropStart.angle;\n  const rotatedTopLeft = pointRotateRads(newTopLeft, startCenter, angle);\n  const newCenter: Point = [\n    newTopLeft[0] + Math.abs(newBoundsWidth) / 2,\n    newTopLeft[1] + Math.abs(newBoundsHeight) / 2,\n  ];\n  const rotatedNewCenter = pointRotateRads(newCenter, startCenter, angle);\n  newTopLeft = pointRotateRads(\n    rotatedTopLeft,\n    rotatedNewCenter,\n    -angle as Radians,\n  );\n\n  const newOrigin = [...newTopLeft];\n  newOrigin[0] += stateAtCropStart.x - newBoundsX1;\n  newOrigin[1] += stateAtCropStart.y - newBoundsY1;\n\n  return newOrigin;\n};\n\n// refer to https://link.excalidraw.com/l/6rfy1007QOo/6stx5PmRn0k\nexport const getUncroppedImageElement = (\n  element: ExcalidrawImageElement,\n  elementsMap: ElementsMap,\n) => {\n  if (element.crop) {\n    const { width, height } = getUncroppedWidthAndHeight(element);\n\n    const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n      element,\n      elementsMap,\n    );\n\n    const topLeftVector = vectorFromPoint(\n      pointRotateRads(pointFrom(x1, y1), pointFrom(cx, cy), element.angle),\n    );\n    const topRightVector = vectorFromPoint(\n      pointRotateRads(pointFrom(x2, y1), pointFrom(cx, cy), element.angle),\n    );\n    const topEdgeNormalized = vectorNormalize(\n      vectorSubtract(topRightVector, topLeftVector),\n    );\n    const bottomLeftVector = vectorFromPoint(\n      pointRotateRads(pointFrom(x1, y2), pointFrom(cx, cy), element.angle),\n    );\n    const leftEdgeVector = vectorSubtract(bottomLeftVector, topLeftVector);\n    const leftEdgeNormalized = vectorNormalize(leftEdgeVector);\n\n    const { cropX, cropY } = adjustCropPosition(element.crop, element.scale);\n\n    const rotatedTopLeft = vectorAdd(\n      vectorAdd(\n        topLeftVector,\n        vectorScale(\n          topEdgeNormalized,\n          (-cropX * width) / element.crop.naturalWidth,\n        ),\n      ),\n      vectorScale(\n        leftEdgeNormalized,\n        (-cropY * height) / element.crop.naturalHeight,\n      ),\n    );\n\n    const center = pointFromVector(\n      vectorAdd(\n        vectorAdd(rotatedTopLeft, vectorScale(topEdgeNormalized, width / 2)),\n        vectorScale(leftEdgeNormalized, height / 2),\n      ),\n    );\n\n    const unrotatedTopLeft = pointRotateRads(\n      pointFromVector(rotatedTopLeft),\n      center,\n      -element.angle as Radians,\n    );\n\n    const uncroppedElement: ExcalidrawImageElement = {\n      ...element,\n      x: unrotatedTopLeft[0],\n      y: unrotatedTopLeft[1],\n      width,\n      height,\n      crop: null,\n    };\n\n    return uncroppedElement;\n  }\n\n  return element;\n};\n\nexport const getUncroppedWidthAndHeight = (element: ExcalidrawImageElement) => {\n  if (element.crop) {\n    const width =\n      element.width / (element.crop.width / element.crop.naturalWidth);\n    const height =\n      element.height / (element.crop.height / element.crop.naturalHeight);\n\n    return {\n      width,\n      height,\n    };\n  }\n\n  return {\n    width: element.width,\n    height: element.height,\n  };\n};\n\nconst adjustCropPosition = (\n  crop: ImageCrop,\n  scale: ExcalidrawImageElement[\"scale\"],\n) => {\n  let cropX = crop.x;\n  let cropY = crop.y;\n\n  const flipX = scale[0] === -1;\n  const flipY = scale[1] === -1;\n\n  if (flipX) {\n    cropX = crop.naturalWidth - Math.abs(cropX) - crop.width;\n  }\n\n  if (flipY) {\n    cropY = crop.naturalHeight - Math.abs(cropY) - crop.height;\n  }\n\n  return {\n    cropX,\n    cropY,\n  };\n};\n\nexport const getFlipAdjustedCropPosition = (\n  element: ExcalidrawImageElement,\n  natural = false,\n) => {\n  const crop = element.crop;\n  if (!crop) {\n    return null;\n  }\n\n  const isFlippedByX = element.scale[0] === -1;\n  const isFlippedByY = element.scale[1] === -1;\n\n  let cropX = crop.x;\n  let cropY = crop.y;\n\n  if (isFlippedByX) {\n    cropX = crop.naturalWidth - crop.width - crop.x;\n  }\n\n  if (isFlippedByY) {\n    cropY = crop.naturalHeight - crop.height - crop.y;\n  }\n\n  if (natural) {\n    return {\n      x: cropX,\n      y: cropY,\n    };\n  }\n\n  const { width, height } = getUncroppedWidthAndHeight(element);\n\n  return {\n    x: cropX / (crop.naturalWidth / width),\n    y: cropY / (crop.naturalHeight / height),\n  };\n};\n",
    "import { arrayToMap } from \"@excalidraw/common\";\nimport { isPointWithinBounds, pointFrom } from \"@excalidraw/math\";\nimport { doLineSegmentsIntersect } from \"@excalidraw/utils/bbox\";\nimport { elementsOverlappingBBox } from \"@excalidraw/utils/withinBounds\";\n\nimport type {\n  AppClassProperties,\n  AppState,\n  StaticCanvasAppState,\n} from \"excalidraw-custom/types\";\n\nimport type { ReadonlySetLike } from \"@excalidraw/common/utility-types\";\n\nimport { getElementsWithinSelection, getSelectedElements } from \"./selection\";\nimport { getElementsInGroup, selectGroupsFromGivenElements } from \"./groups\";\n\nimport {\n  getElementLineSegments,\n  getCommonBounds,\n  getElementAbsoluteCoords,\n} from \"./bounds\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getBoundTextElement, getContainerElement } from \"./textElement\";\nimport {\n  isFrameElement,\n  isFrameLikeElement,\n  isTextElement,\n} from \"./typeChecks\";\n\nimport type { ExcalidrawElementsIncludingDeleted } from \"./Scene\";\n\nimport type {\n  ElementsMap,\n  ElementsMapOrArray,\n  ExcalidrawElement,\n  ExcalidrawFrameLikeElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\n// --------------------------- Frame State ------------------------------------\nexport const bindElementsToFramesAfterDuplication = (\n  nextElements: readonly ExcalidrawElement[],\n  origElements: readonly ExcalidrawElement[],\n  origIdToDuplicateId: Map<ExcalidrawElement[\"id\"], ExcalidrawElement[\"id\"]>,\n) => {\n  const nextElementMap = arrayToMap(nextElements) as Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >;\n\n  for (const element of origElements) {\n    if (element.frameId) {\n      // use its frameId to get the new frameId\n      const nextElementId = origIdToDuplicateId.get(element.id);\n      const nextFrameId = origIdToDuplicateId.get(element.frameId);\n      const nextElement = nextElementId && nextElementMap.get(nextElementId);\n      if (nextElement) {\n        mutateElement(nextElement, nextElementMap, {\n          frameId: nextFrameId ?? null,\n        });\n      }\n    }\n  }\n};\n\nexport function isElementIntersectingFrame(\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) {\n  const frameLineSegments = getElementLineSegments(frame, elementsMap);\n\n  const elementLineSegments = getElementLineSegments(element, elementsMap);\n\n  const intersecting = frameLineSegments.some((frameLineSegment) =>\n    elementLineSegments.some((elementLineSegment) =>\n      doLineSegmentsIntersect(frameLineSegment, elementLineSegment),\n    ),\n  );\n\n  return intersecting;\n}\n\nexport const getElementsCompletelyInFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) =>\n  omitGroupsContainingFrameLikes(\n    getElementsWithinSelection(elements, frame, elementsMap, false),\n  ).filter(\n    (element) =>\n      (!isFrameLikeElement(element) && !element.frameId) ||\n      element.frameId === frame.id,\n  );\n\nexport const isElementContainingFrame = (\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  return getElementsWithinSelection([frame], element, elementsMap).some(\n    (e) => e.id === frame.id,\n  );\n};\n\nexport const getElementsIntersectingFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsMap = arrayToMap(elements);\n  return elements.filter((element) =>\n    isElementIntersectingFrame(element, frame, elementsMap),\n  );\n};\n\nexport const elementsAreInFrameBounds = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  const [frameX1, frameY1, frameX2, frameY2] = getElementAbsoluteCoords(\n    frame,\n    elementsMap,\n  );\n\n  const [elementX1, elementY1, elementX2, elementY2] =\n    getCommonBounds(elements);\n\n  return (\n    frameX1 <= elementX1 &&\n    frameY1 <= elementY1 &&\n    frameX2 >= elementX2 &&\n    frameY2 >= elementY2\n  );\n};\n\nexport const elementOverlapsWithFrame = (\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  return (\n    elementsAreInFrameBounds([element], frame, elementsMap) ||\n    isElementIntersectingFrame(element, frame, elementsMap) ||\n    isElementContainingFrame(element, frame, elementsMap)\n  );\n};\n\nexport const isCursorInFrame = (\n  cursorCoords: {\n    x: number;\n    y: number;\n  },\n  frame: NonDeleted<ExcalidrawFrameLikeElement>,\n  elementsMap: ElementsMap,\n) => {\n  const [fx1, fy1, fx2, fy2] = getElementAbsoluteCoords(frame, elementsMap);\n\n  return isPointWithinBounds(\n    pointFrom(fx1, fy1),\n    pointFrom(cursorCoords.x, cursorCoords.y),\n    pointFrom(fx2, fy2),\n  );\n};\n\nexport const groupsAreAtLeastIntersectingTheFrame = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  groupIds: readonly string[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsMap = arrayToMap(elements);\n  const elementsInGroup = groupIds.flatMap((groupId) =>\n    getElementsInGroup(elements, groupId),\n  );\n\n  if (elementsInGroup.length === 0) {\n    return true;\n  }\n\n  return !!elementsInGroup.find(\n    (element) =>\n      elementsAreInFrameBounds([element], frame, elementsMap) ||\n      isElementIntersectingFrame(element, frame, elementsMap),\n  );\n};\n\nexport const groupsAreCompletelyOutOfFrame = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  groupIds: readonly string[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsMap = arrayToMap(elements);\n  const elementsInGroup = groupIds.flatMap((groupId) =>\n    getElementsInGroup(elements, groupId),\n  );\n\n  if (elementsInGroup.length === 0) {\n    return true;\n  }\n\n  return (\n    elementsInGroup.find(\n      (element) =>\n        elementsAreInFrameBounds([element], frame, elementsMap) ||\n        isElementIntersectingFrame(element, frame, elementsMap),\n    ) === undefined\n  );\n};\n\n// --------------------------- Frame Utils ------------------------------------\n\n/**\n * Returns a map of frameId to frame elements. Includes empty frames.\n */\nexport const groupByFrameLikes = (elements: readonly ExcalidrawElement[]) => {\n  const frameElementsMap = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement[]\n  >();\n\n  for (const element of elements) {\n    const frameId = isFrameLikeElement(element) ? element.id : element.frameId;\n    if (frameId && !frameElementsMap.has(frameId)) {\n      frameElementsMap.set(frameId, getFrameChildren(elements, frameId));\n    }\n  }\n\n  return frameElementsMap;\n};\n\nexport const getFrameChildren = (\n  allElements: ElementsMapOrArray,\n  frameId: string,\n) => {\n  const frameChildren: ExcalidrawElement[] = [];\n  for (const element of allElements.values()) {\n    if (element.frameId === frameId) {\n      frameChildren.push(element);\n    }\n  }\n  return frameChildren;\n};\n\nexport const getFrameLikeElements = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n): ExcalidrawFrameLikeElement[] => {\n  return allElements.filter((element): element is ExcalidrawFrameLikeElement =>\n    isFrameLikeElement(element),\n  );\n};\n\n/**\n * Returns ExcalidrawFrameElements and non-frame-children elements.\n *\n * Considers children as root elements if they point to a frame parent\n * non-existing in the elements set.\n *\n * Considers non-frame bound elements (container or arrow labels) as root.\n */\nexport const getRootElements = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n) => {\n  const frameElements = arrayToMap(getFrameLikeElements(allElements));\n  return allElements.filter(\n    (element) =>\n      frameElements.has(element.id) ||\n      !element.frameId ||\n      !frameElements.has(element.frameId),\n  );\n};\n\nexport const getElementsInResizingFrame = (\n  allElements: ExcalidrawElementsIncludingDeleted,\n  frame: ExcalidrawFrameLikeElement,\n  appState: AppState,\n  elementsMap: ElementsMap,\n): ExcalidrawElement[] => {\n  const prevElementsInFrame = getFrameChildren(allElements, frame.id);\n  const nextElementsInFrame = new Set<ExcalidrawElement>(prevElementsInFrame);\n\n  const elementsCompletelyInFrame = new Set([\n    ...getElementsCompletelyInFrame(allElements, frame, elementsMap),\n    ...prevElementsInFrame.filter((element) =>\n      isElementContainingFrame(element, frame, elementsMap),\n    ),\n  ]);\n\n  const elementsNotCompletelyInFrame = prevElementsInFrame.filter(\n    (element) => !elementsCompletelyInFrame.has(element),\n  );\n\n  // for elements that are completely in the frame\n  // if they are part of some groups, then those groups are still\n  // considered to belong to the frame\n  const groupsToKeep = new Set<string>(\n    Array.from(elementsCompletelyInFrame).flatMap(\n      (element) => element.groupIds,\n    ),\n  );\n\n  for (const element of elementsNotCompletelyInFrame) {\n    if (!isElementIntersectingFrame(element, frame, elementsMap)) {\n      if (element.groupIds.length === 0) {\n        nextElementsInFrame.delete(element);\n      }\n    } else if (element.groupIds.length > 0) {\n      // group element intersects with the frame, we should keep the groups\n      // that this element is part of\n      for (const id of element.groupIds) {\n        groupsToKeep.add(id);\n      }\n    }\n  }\n\n  for (const element of elementsNotCompletelyInFrame) {\n    if (element.groupIds.length > 0) {\n      let shouldRemoveElement = true;\n\n      for (const id of element.groupIds) {\n        if (groupsToKeep.has(id)) {\n          shouldRemoveElement = false;\n        }\n      }\n\n      if (shouldRemoveElement) {\n        nextElementsInFrame.delete(element);\n      }\n    }\n  }\n\n  const individualElementsCompletelyInFrame = Array.from(\n    elementsCompletelyInFrame,\n  ).filter((element) => element.groupIds.length === 0);\n\n  for (const element of individualElementsCompletelyInFrame) {\n    nextElementsInFrame.add(element);\n  }\n\n  const newGroupElementsCompletelyInFrame = Array.from(\n    elementsCompletelyInFrame,\n  ).filter((element) => element.groupIds.length > 0);\n\n  const groupIds = selectGroupsFromGivenElements(\n    newGroupElementsCompletelyInFrame,\n    appState,\n  );\n\n  // new group elements\n  for (const [id, isSelected] of Object.entries(groupIds)) {\n    if (isSelected) {\n      const elementsInGroup = getElementsInGroup(allElements, id);\n\n      if (elementsAreInFrameBounds(elementsInGroup, frame, elementsMap)) {\n        for (const element of elementsInGroup) {\n          nextElementsInFrame.add(element);\n        }\n      }\n    }\n  }\n\n  return [...nextElementsInFrame].filter((element) => {\n    return !(isTextElement(element) && element.containerId);\n  });\n};\n\nexport const getElementsInNewFrame = (\n  elements: ExcalidrawElementsIncludingDeleted,\n  frame: ExcalidrawFrameLikeElement,\n  elementsMap: ElementsMap,\n) => {\n  return omitPartialGroups(\n    omitGroupsContainingFrameLikes(\n      elements,\n      getElementsCompletelyInFrame(elements, frame, elementsMap),\n    ),\n    frame,\n    elementsMap,\n  );\n};\n\nexport const omitPartialGroups = (\n  elements: ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  allElementsMap: ElementsMap,\n) => {\n  const elementsToReturn = [];\n  const checkedGroups = new Map<string, boolean>();\n\n  for (const element of elements) {\n    let shouldOmit = false;\n    if (element.groupIds.length > 0) {\n      // if some partial group should be omitted, then all elements in that group should be omitted\n      if (element.groupIds.some((gid) => checkedGroups.get(gid))) {\n        shouldOmit = true;\n      } else {\n        const allElementsInGroup = new Set(\n          element.groupIds.flatMap((gid) =>\n            getElementsInGroup(allElementsMap, gid),\n          ),\n        );\n\n        shouldOmit = !elementsAreInFrameBounds(\n          Array.from(allElementsInGroup),\n          frame,\n          allElementsMap,\n        );\n      }\n\n      element.groupIds.forEach((gid) => {\n        checkedGroups.set(gid, shouldOmit);\n      });\n    }\n\n    if (!shouldOmit) {\n      elementsToReturn.push(element);\n    }\n  }\n\n  return elementsToReturn;\n};\n\nexport const getContainingFrame = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n) => {\n  if (!element.frameId) {\n    return null;\n  }\n  return (elementsMap.get(element.frameId) ||\n    null) as null | ExcalidrawFrameLikeElement;\n};\n\n// --------------------------- Frame Operations -------------------------------\n\n/** */\nexport const filterElementsEligibleAsFrameChildren = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const otherFrames = new Set<ExcalidrawFrameLikeElement[\"id\"]>();\n  const elementsMap = arrayToMap(elements);\n  elements = omitGroupsContainingFrameLikes(elements);\n\n  for (const element of elements) {\n    if (isFrameLikeElement(element) && element.id !== frame.id) {\n      otherFrames.add(element.id);\n    }\n  }\n\n  const processedGroups = new Set<ExcalidrawElement[\"id\"]>();\n\n  const eligibleElements: ExcalidrawElement[] = [];\n\n  for (const element of elements) {\n    // don't add frames or their children\n    if (\n      isFrameLikeElement(element) ||\n      (element.frameId && otherFrames.has(element.frameId))\n    ) {\n      continue;\n    }\n\n    if (element.groupIds.length) {\n      const shallowestGroupId = element.groupIds.at(-1)!;\n      if (!processedGroups.has(shallowestGroupId)) {\n        processedGroups.add(shallowestGroupId);\n        const groupElements = getElementsInGroup(elements, shallowestGroupId);\n        if (\n          groupElements.some((el) =>\n            elementOverlapsWithFrame(el, frame, elementsMap),\n          )\n        ) {\n          for (const child of groupElements) {\n            eligibleElements.push(child);\n          }\n        }\n      }\n    } else {\n      const overlaps = elementOverlapsWithFrame(element, frame, elementsMap);\n      if (overlaps) {\n        eligibleElements.push(element);\n      }\n    }\n  }\n\n  return eligibleElements;\n};\n\n/**\n * Retains (or repairs for target frame) the ordering invriant where children\n * elements come right before the parent frame:\n * [el, el, child, child, frame, el]\n *\n * @returns mutated allElements (same data structure)\n */\nexport const addElementsToFrame = <T extends ElementsMapOrArray>(\n  allElements: T,\n  elementsToAdd: NonDeletedExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  appState: AppState,\n): T => {\n  const elementsMap = arrayToMap(allElements);\n  const currTargetFrameChildrenMap = new Map<ExcalidrawElement[\"id\"], true>();\n  for (const element of allElements.values()) {\n    if (element.frameId === frame.id) {\n      currTargetFrameChildrenMap.set(element.id, true);\n    }\n  }\n\n  const suppliedElementsToAddSet = new Set(elementsToAdd.map((el) => el.id));\n\n  const finalElementsToAdd: ExcalidrawElement[] = [];\n\n  const otherFrames = new Set<ExcalidrawFrameLikeElement[\"id\"]>();\n\n  for (const element of elementsToAdd) {\n    if (isFrameLikeElement(element) && element.id !== frame.id) {\n      otherFrames.add(element.id);\n    }\n  }\n\n  // - add bound text elements if not already in the array\n  // - filter out elements that are already in the frame\n  for (const element of omitGroupsContainingFrameLikes(\n    allElements,\n    elementsToAdd,\n  )) {\n    // don't add frames or their children\n    if (\n      isFrameLikeElement(element) ||\n      (element.frameId && otherFrames.has(element.frameId))\n    ) {\n      continue;\n    }\n\n    // if the element is already in another frame (which is also in elementsToAdd),\n    // it means that frame and children are selected at the same time\n    // => keep original frame membership, do not add to the target frame\n    if (\n      element.frameId &&\n      appState.selectedElementIds[element.id] &&\n      appState.selectedElementIds[element.frameId]\n    ) {\n      continue;\n    }\n\n    if (!currTargetFrameChildrenMap.has(element.id)) {\n      finalElementsToAdd.push(element);\n    }\n\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n    if (\n      boundTextElement &&\n      !suppliedElementsToAddSet.has(boundTextElement.id) &&\n      !currTargetFrameChildrenMap.has(boundTextElement.id)\n    ) {\n      finalElementsToAdd.push(boundTextElement);\n    }\n  }\n\n  for (const element of finalElementsToAdd) {\n    mutateElement(element, elementsMap, {\n      frameId: frame.id,\n    });\n  }\n\n  return allElements;\n};\n\nexport const removeElementsFromFrame = (\n  elementsToRemove: ReadonlySetLike<NonDeletedExcalidrawElement>,\n  elementsMap: ElementsMap,\n) => {\n  const _elementsToRemove = new Map<\n    ExcalidrawElement[\"id\"],\n    ExcalidrawElement\n  >();\n\n  const toRemoveElementsByFrame = new Map<\n    ExcalidrawFrameLikeElement[\"id\"],\n    ExcalidrawElement[]\n  >();\n\n  for (const element of elementsToRemove) {\n    if (element.frameId) {\n      _elementsToRemove.set(element.id, element);\n\n      const arr = toRemoveElementsByFrame.get(element.frameId) || [];\n      arr.push(element);\n\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n      if (boundTextElement) {\n        _elementsToRemove.set(boundTextElement.id, boundTextElement);\n        arr.push(boundTextElement);\n      }\n\n      toRemoveElementsByFrame.set(element.frameId, arr);\n    }\n  }\n\n  for (const [, element] of _elementsToRemove) {\n    mutateElement(element, elementsMap, {\n      frameId: null,\n    });\n  }\n};\n\nexport const removeAllElementsFromFrame = <T extends ExcalidrawElement>(\n  allElements: readonly T[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  const elementsInFrame = getFrameChildren(allElements, frame.id);\n  removeElementsFromFrame(elementsInFrame, arrayToMap(allElements));\n  return allElements;\n};\n\nexport const replaceAllElementsInFrame = <T extends ExcalidrawElement>(\n  allElements: readonly T[],\n  nextElementsInFrame: ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n  app: AppClassProperties,\n): T[] => {\n  return addElementsToFrame(\n    removeAllElementsFromFrame(allElements, frame),\n    nextElementsInFrame,\n    frame,\n    app.state,\n  ).slice();\n};\n\n/** does not mutate elements, but returns new ones */\nexport const updateFrameMembershipOfSelectedElements = <\n  T extends ElementsMapOrArray,\n>(\n  allElements: T,\n  appState: AppState,\n  app: AppClassProperties,\n) => {\n  const selectedElements = app.scene.getSelectedElements({\n    selectedElementIds: appState.selectedElementIds,\n    // supplying elements explicitly in case we're passed non-state elements\n    elements: allElements,\n  });\n  const elementsToFilter = new Set<ExcalidrawElement>(selectedElements);\n\n  if (appState.editingGroupId) {\n    for (const element of selectedElements) {\n      if (element.groupIds.length === 0) {\n        elementsToFilter.add(element);\n      } else {\n        element.groupIds\n          .flatMap((gid) => getElementsInGroup(allElements, gid))\n          .forEach((element) => elementsToFilter.add(element));\n      }\n    }\n  }\n\n  const elementsToRemove = new Set<ExcalidrawElement>();\n\n  const elementsMap = arrayToMap(allElements);\n\n  elementsToFilter.forEach((element) => {\n    if (\n      element.frameId &&\n      !isFrameLikeElement(element) &&\n      !isElementInFrame(element, elementsMap, appState)\n    ) {\n      elementsToRemove.add(element);\n    }\n  });\n\n  if (elementsToRemove.size > 0) {\n    removeElementsFromFrame(elementsToRemove, elementsMap);\n  }\n  return allElements;\n};\n\n/**\n * filters out elements that are inside groups that contain a frame element\n * anywhere in the group tree\n */\nexport const omitGroupsContainingFrameLikes = (\n  allElements: ElementsMapOrArray,\n  /** subset of elements you want to filter. Optional perf optimization so we\n   * don't have to filter all elements unnecessarily\n   */\n  selectedElements?: readonly ExcalidrawElement[],\n) => {\n  const uniqueGroupIds = new Set<string>();\n  const elements = selectedElements || allElements;\n\n  for (const el of elements.values()) {\n    const topMostGroupId = el.groupIds[el.groupIds.length - 1];\n    if (topMostGroupId) {\n      uniqueGroupIds.add(topMostGroupId);\n    }\n  }\n\n  const rejectedGroupIds = new Set<string>();\n  for (const groupId of uniqueGroupIds) {\n    if (\n      getElementsInGroup(allElements, groupId).some((el) =>\n        isFrameLikeElement(el),\n      )\n    ) {\n      rejectedGroupIds.add(groupId);\n    }\n  }\n\n  const ret: ExcalidrawElement[] = [];\n\n  for (const element of elements.values()) {\n    if (!rejectedGroupIds.has(element.groupIds[element.groupIds.length - 1])) {\n      ret.push(element);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * depending on the appState, return target frame, which is the frame the given element\n * is going to be added to or remove from\n */\nexport const getTargetFrame = (\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n  appState: StaticCanvasAppState,\n) => {\n  const _element = isTextElement(element)\n    ? getContainerElement(element, elementsMap) || element\n    : element;\n\n  // if the element and its containing frame are both selected, then\n  // the containing frame is the target frame\n  if (\n    _element.frameId &&\n    appState.selectedElementIds[_element.id] &&\n    appState.selectedElementIds[_element.frameId]\n  ) {\n    return getContainingFrame(_element, elementsMap);\n  }\n\n  return appState.selectedElementIds[_element.id] &&\n    appState.selectedElementsAreBeingDragged\n    ? appState.frameToHighlight\n    : getContainingFrame(_element, elementsMap);\n};\n\n// TODO: this a huge bottleneck for large scenes, optimise\n// given an element, return if the element is in some frame\nexport const isElementInFrame = (\n  element: ExcalidrawElement,\n  allElementsMap: ElementsMap,\n  appState: StaticCanvasAppState,\n  opts?: {\n    targetFrame?: ExcalidrawFrameLikeElement;\n    checkedGroups?: Map<string, boolean>;\n  },\n) => {\n  const frame =\n    opts?.targetFrame ?? getTargetFrame(element, allElementsMap, appState);\n\n  if (!frame) {\n    return false;\n  }\n\n  const _element = isTextElement(element)\n    ? getContainerElement(element, allElementsMap) || element\n    : element;\n\n  const setGroupsInFrame = (isInFrame: boolean) => {\n    if (opts?.checkedGroups) {\n      _element.groupIds.forEach((groupId) => {\n        opts.checkedGroups?.set(groupId, isInFrame);\n      });\n    }\n  };\n\n  if (\n    // if the element is not selected, or it is selected but not being dragged,\n    // frame membership won't update, so return true\n    !appState.selectedElementIds[_element.id] ||\n    !appState.selectedElementsAreBeingDragged ||\n    // if both frame and element are selected, won't update membership, so return true\n    (appState.selectedElementIds[_element.id] &&\n      appState.selectedElementIds[frame.id])\n  ) {\n    return true;\n  }\n\n  if (_element.groupIds.length === 0) {\n    return elementOverlapsWithFrame(_element, frame, allElementsMap);\n  }\n\n  for (const gid of _element.groupIds) {\n    if (opts?.checkedGroups?.has(gid)) {\n      return opts.checkedGroups.get(gid)!!;\n    }\n  }\n\n  const allElementsInGroup = new Set(\n    _element.groupIds\n      .filter((gid) => {\n        if (opts?.checkedGroups) {\n          return !opts.checkedGroups.has(gid);\n        }\n        return true;\n      })\n      .flatMap((gid) => getElementsInGroup(allElementsMap, gid)),\n  );\n\n  if (appState.editingGroupId && appState.selectedElementsAreBeingDragged) {\n    const selectedElements = new Set(\n      getSelectedElements(allElementsMap, appState),\n    );\n\n    const editingGroupOverlapsFrame = appState.frameToHighlight !== null;\n\n    if (editingGroupOverlapsFrame) {\n      return true;\n    }\n\n    selectedElements.forEach((selectedElement) => {\n      allElementsInGroup.delete(selectedElement);\n    });\n  }\n\n  for (const elementInGroup of allElementsInGroup) {\n    if (isFrameLikeElement(elementInGroup)) {\n      setGroupsInFrame(false);\n      return false;\n    }\n  }\n\n  for (const elementInGroup of allElementsInGroup) {\n    if (elementOverlapsWithFrame(elementInGroup, frame, allElementsMap)) {\n      setGroupsInFrame(true);\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport const shouldApplyFrameClip = (\n  element: ExcalidrawElement,\n  frame: ExcalidrawFrameLikeElement,\n  appState: StaticCanvasAppState,\n  elementsMap: ElementsMap,\n  checkedGroups?: Map<string, boolean>,\n) => {\n  if (!appState.frameRendering || !appState.frameRendering.clip) {\n    return false;\n  }\n\n  // for individual elements, only clip when the element is\n  // a. overlapping with the frame, or\n  // b. containing the frame, for example when an element is used as a background\n  //    and is therefore bigger than the frame and completely contains the frame\n  const shouldClipElementItself =\n    isElementIntersectingFrame(element, frame, elementsMap) ||\n    isElementContainingFrame(element, frame, elementsMap);\n\n  if (shouldClipElementItself) {\n    for (const groupId of element.groupIds) {\n      checkedGroups?.set(groupId, true);\n    }\n\n    return true;\n  }\n\n  // if an element is outside the frame, but is part of a group that has some elements\n  // \"in\" the frame, we should clip the element\n  if (\n    !shouldClipElementItself &&\n    element.groupIds.length > 0 &&\n    !elementsAreInFrameBounds([element], frame, elementsMap)\n  ) {\n    let shouldClip = false;\n\n    // if no elements are being dragged, we can skip the geometry check\n    // because we know if the element is in the given frame or not\n    if (!appState.selectedElementsAreBeingDragged) {\n      shouldClip = element.frameId === frame.id;\n      for (const groupId of element.groupIds) {\n        checkedGroups?.set(groupId, shouldClip);\n      }\n    } else {\n      shouldClip = isElementInFrame(element, elementsMap, appState, {\n        targetFrame: frame,\n        checkedGroups,\n      });\n    }\n\n    for (const groupId of element.groupIds) {\n      checkedGroups?.set(groupId, shouldClip);\n    }\n\n    return shouldClip;\n  }\n\n  return false;\n};\n\nconst DEFAULT_FRAME_NAME = \"Frame\";\nconst DEFAULT_AI_FRAME_NAME = \"AI Frame\";\n\nexport const getDefaultFrameName = (element: ExcalidrawFrameLikeElement) => {\n  // TODO name frames \"AI\" only if specific to AI frames\n  return isFrameElement(element) ? DEFAULT_FRAME_NAME : DEFAULT_AI_FRAME_NAME;\n};\n\nexport const getFrameLikeTitle = (element: ExcalidrawFrameLikeElement) => {\n  return element.name === null ? getDefaultFrameName(element) : element.name;\n};\n\nexport const getElementsOverlappingFrame = (\n  elements: readonly ExcalidrawElement[],\n  frame: ExcalidrawFrameLikeElement,\n) => {\n  return (\n    elementsOverlappingBBox({\n      elements,\n      bounds: frame,\n      type: \"overlap\",\n    })\n      // removes elements who are overlapping, but are in a different frame,\n      // and thus invisible in target frame\n      .filter((el) => !el.frameId || el.frameId === frame.id)\n  );\n};\n\nexport const frameAndChildrenSelectedTogether = (\n  selectedElements: readonly ExcalidrawElement[],\n) => {\n  const selectedElementsMap = arrayToMap(selectedElements);\n\n  return (\n    selectedElements.length > 1 &&\n    selectedElements.some(\n      (element) => element.frameId && selectedElementsMap.has(element.frameId),\n    )\n  );\n};\n",
    "import {\n  vectorCross,\n  vectorFromPoint,\n  type GlobalPoint,\n  type LocalPoint,\n} from \"@excalidraw/math\";\n\nimport type { Bounds } from \"@excalidraw/element\";\n\nexport type LineSegment<P extends LocalPoint | GlobalPoint> = [P, P];\n\nexport function getBBox<P extends LocalPoint | GlobalPoint>(\n  line: LineSegment<P>,\n): Bounds {\n  return [\n    Math.min(line[0][0], line[1][0]),\n    Math.min(line[0][1], line[1][1]),\n    Math.max(line[0][0], line[1][0]),\n    Math.max(line[0][1], line[1][1]),\n  ];\n}\n\nexport function doBBoxesIntersect(a: Bounds, b: Bounds) {\n  return a[0] <= b[2] && a[2] >= b[0] && a[1] <= b[3] && a[3] >= b[1];\n}\n\nconst EPSILON = 0.000001;\n\nexport function isPointOnLine<P extends GlobalPoint | LocalPoint>(\n  l: LineSegment<P>,\n  p: P,\n) {\n  const p1 = vectorFromPoint(l[1], l[0]);\n  const p2 = vectorFromPoint(p, l[0]);\n\n  const r = vectorCross(p1, p2);\n\n  return Math.abs(r) < EPSILON;\n}\n\nexport function isPointRightOfLine<P extends GlobalPoint | LocalPoint>(\n  l: LineSegment<P>,\n  p: P,\n) {\n  const p1 = vectorFromPoint(l[1], l[0]);\n  const p2 = vectorFromPoint(p, l[0]);\n\n  return vectorCross(p1, p2) < 0;\n}\n\nexport function isLineSegmentTouchingOrCrossingLine<\n  P extends GlobalPoint | LocalPoint,\n>(a: LineSegment<P>, b: LineSegment<P>) {\n  return (\n    isPointOnLine(a, b[0]) ||\n    isPointOnLine(a, b[1]) ||\n    (isPointRightOfLine(a, b[0])\n      ? !isPointRightOfLine(a, b[1])\n      : isPointRightOfLine(a, b[1]))\n  );\n}\n\n// https://martin-thoma.com/how-to-check-if-two-line-segments-intersect/\nexport function doLineSegmentsIntersect<P extends GlobalPoint | LocalPoint>(\n  a: LineSegment<P>,\n  b: LineSegment<P>,\n) {\n  return (\n    doBBoxesIntersect(getBBox(a), getBBox(b)) &&\n    isLineSegmentTouchingOrCrossingLine(a, b) &&\n    isLineSegmentTouchingOrCrossingLine(b, a)\n  );\n}\n",
    "import { arrayToMap } from \"@excalidraw/common\";\nimport { getElementBounds } from \"@excalidraw/element\";\nimport {\n  isArrowElement,\n  isExcalidrawElement,\n  isFreeDrawElement,\n  isLinearElement,\n  isTextElement,\n} from \"@excalidraw/element\";\nimport {\n  rangeIncludesValue,\n  pointFrom,\n  pointRotateRads,\n  rangeInclusive,\n} from \"@excalidraw/math\";\n\nimport type { Bounds } from \"@excalidraw/element\";\nimport type {\n  ExcalidrawElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawLinearElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\nimport type { LocalPoint } from \"@excalidraw/math\";\n\ntype Element = NonDeletedExcalidrawElement;\ntype Elements = readonly NonDeletedExcalidrawElement[];\n\ntype Points = readonly LocalPoint[];\n\n/** @returns vertices relative to element's top-left [0,0] position  */\nconst getNonLinearElementRelativePoints = (\n  element: Exclude<\n    Element,\n    ExcalidrawLinearElement | ExcalidrawFreeDrawElement\n  >,\n): [\n  TopLeft: LocalPoint,\n  TopRight: LocalPoint,\n  BottomRight: LocalPoint,\n  BottomLeft: LocalPoint,\n] => {\n  if (element.type === \"diamond\") {\n    return [\n      pointFrom(element.width / 2, 0),\n      pointFrom(element.width, element.height / 2),\n      pointFrom(element.width / 2, element.height),\n      pointFrom(0, element.height / 2),\n    ];\n  }\n  return [\n    pointFrom(0, 0),\n    pointFrom(0 + element.width, 0),\n    pointFrom(0 + element.width, element.height),\n    pointFrom(0, element.height),\n  ];\n};\n\n/** @returns vertices relative to element's top-left [0,0] position  */\nconst getElementRelativePoints = (element: ExcalidrawElement): Points => {\n  if (isLinearElement(element) || isFreeDrawElement(element)) {\n    return element.points;\n  }\n  return getNonLinearElementRelativePoints(element);\n};\n\nconst getMinMaxPoints = (points: Points) => {\n  const ret = points.reduce(\n    (limits, [x, y]) => {\n      limits.minY = Math.min(limits.minY, y);\n      limits.minX = Math.min(limits.minX, x);\n\n      limits.maxX = Math.max(limits.maxX, x);\n      limits.maxY = Math.max(limits.maxY, y);\n\n      return limits;\n    },\n    {\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity,\n      cx: 0,\n      cy: 0,\n    },\n  );\n\n  ret.cx = (ret.maxX + ret.minX) / 2;\n  ret.cy = (ret.maxY + ret.minY) / 2;\n\n  return ret;\n};\n\nconst getRotatedBBox = (element: Element): Bounds => {\n  const points = getElementRelativePoints(element);\n\n  const { cx, cy } = getMinMaxPoints(points);\n  const centerPoint = pointFrom<LocalPoint>(cx, cy);\n\n  const rotatedPoints = points.map((p) =>\n    pointRotateRads(p, centerPoint, element.angle),\n  );\n  const { minX, minY, maxX, maxY } = getMinMaxPoints(rotatedPoints);\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const isElementInsideBBox = (\n  element: Element,\n  bbox: Bounds,\n  eitherDirection = false,\n): boolean => {\n  const elementBBox = getRotatedBBox(element);\n\n  const elementInsideBbox =\n    bbox[0] <= elementBBox[0] &&\n    bbox[2] >= elementBBox[2] &&\n    bbox[1] <= elementBBox[1] &&\n    bbox[3] >= elementBBox[3];\n\n  if (!eitherDirection) {\n    return elementInsideBbox;\n  }\n\n  if (elementInsideBbox) {\n    return true;\n  }\n\n  return (\n    elementBBox[0] <= bbox[0] &&\n    elementBBox[2] >= bbox[2] &&\n    elementBBox[1] <= bbox[1] &&\n    elementBBox[3] >= bbox[3]\n  );\n};\n\nexport const elementPartiallyOverlapsWithOrContainsBBox = (\n  element: Element,\n  bbox: Bounds,\n): boolean => {\n  const elementBBox = getRotatedBBox(element);\n\n  return (\n    (rangeIncludesValue(elementBBox[0], rangeInclusive(bbox[0], bbox[2])) ||\n      rangeIncludesValue(\n        bbox[0],\n        rangeInclusive(elementBBox[0], elementBBox[2]),\n      )) &&\n    (rangeIncludesValue(elementBBox[1], rangeInclusive(bbox[1], bbox[3])) ||\n      rangeIncludesValue(\n        bbox[1],\n        rangeInclusive(elementBBox[1], elementBBox[3]),\n      ))\n  );\n};\n\nexport const elementsOverlappingBBox = ({\n  elements,\n  bounds,\n  type,\n  errorMargin = 0,\n}: {\n  elements: Elements;\n  bounds: Bounds | ExcalidrawElement;\n  /** safety offset. Defaults to 0. */\n  errorMargin?: number;\n  /**\n   * - overlap: elements overlapping or inside bounds\n   * - contain: elements inside bounds or bounds inside elements\n   * - inside: elements inside bounds\n   **/\n  type: \"overlap\" | \"contain\" | \"inside\";\n}) => {\n  if (isExcalidrawElement(bounds)) {\n    bounds = getElementBounds(bounds, arrayToMap(elements));\n  }\n  const adjustedBBox: Bounds = [\n    bounds[0] - errorMargin,\n    bounds[1] - errorMargin,\n    bounds[2] + errorMargin,\n    bounds[3] + errorMargin,\n  ];\n\n  const includedElementSet = new Set<string>();\n\n  for (const element of elements) {\n    if (includedElementSet.has(element.id)) {\n      continue;\n    }\n\n    const isOverlaping =\n      type === \"overlap\"\n        ? elementPartiallyOverlapsWithOrContainsBBox(element, adjustedBBox)\n        : type === \"inside\"\n        ? isElementInsideBBox(element, adjustedBBox)\n        : isElementInsideBBox(element, adjustedBBox, true);\n\n    if (isOverlaping) {\n      includedElementSet.add(element.id);\n\n      if (element.boundElements) {\n        for (const boundElement of element.boundElements) {\n          includedElementSet.add(boundElement.id);\n        }\n      }\n\n      if (isTextElement(element) && element.containerId) {\n        includedElementSet.add(element.containerId);\n      }\n\n      if (isArrowElement(element)) {\n        if (element.startBinding) {\n          includedElementSet.add(element.startBinding.elementId);\n        }\n\n        if (element.endBinding) {\n          includedElementSet.add(element.endBinding?.elementId);\n        }\n      }\n    }\n  }\n\n  return elements.filter((element) => includedElementSet.has(element.id));\n};\n",
    "import { arrayToMap, isShallowEqual } from \"@excalidraw/common\";\n\nimport type {\n  AppState,\n  InteractiveCanvasAppState,\n} from \"excalidraw-custom/types\";\n\nimport { getElementAbsoluteCoords, getElementBounds } from \"./bounds\";\nimport { isElementInViewport } from \"./sizeHelpers\";\nimport {\n  isBoundToContainer,\n  isFrameLikeElement,\n  isLinearElement,\n} from \"./typeChecks\";\nimport {\n  elementOverlapsWithFrame,\n  getContainingFrame,\n  getFrameChildren,\n} from \"./frame\";\n\nimport { LinearElementEditor } from \"./linearElementEditor\";\nimport { selectGroupsForSelectedElements } from \"./groups\";\n\nimport type {\n  ElementsMap,\n  ElementsMapOrArray,\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./types\";\n\n/**\n * Frames and their containing elements are not to be selected at the same time.\n * Given an array of selected elements, if there are frames and their containing elements\n * we only keep the frames.\n * @param selectedElements\n */\nexport const excludeElementsInFramesFromSelection = <\n  T extends ExcalidrawElement,\n>(\n  selectedElements: readonly T[],\n) => {\n  const framesInSelection = new Set<T[\"id\"]>();\n\n  selectedElements.forEach((element) => {\n    if (isFrameLikeElement(element)) {\n      framesInSelection.add(element.id);\n    }\n  });\n\n  return selectedElements.filter((element) => {\n    if (element.frameId && framesInSelection.has(element.frameId)) {\n      return false;\n    }\n    return true;\n  });\n};\n\nexport const getElementsWithinSelection = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selection: NonDeletedExcalidrawElement,\n  elementsMap: ElementsMap,\n  excludeElementsInFrames: boolean = true,\n) => {\n  const [selectionX1, selectionY1, selectionX2, selectionY2] =\n    getElementAbsoluteCoords(selection, elementsMap);\n\n  let elementsInSelection = elements.filter((element) => {\n    let [elementX1, elementY1, elementX2, elementY2] = getElementBounds(\n      element,\n      elementsMap,\n    );\n\n    const containingFrame = getContainingFrame(element, elementsMap);\n    if (containingFrame) {\n      const [fx1, fy1, fx2, fy2] = getElementBounds(\n        containingFrame,\n        elementsMap,\n      );\n\n      elementX1 = Math.max(fx1, elementX1);\n      elementY1 = Math.max(fy1, elementY1);\n      elementX2 = Math.min(fx2, elementX2);\n      elementY2 = Math.min(fy2, elementY2);\n    }\n\n    return (\n      element.locked === false &&\n      element.type !== \"selection\" &&\n      !isBoundToContainer(element) &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2\n    );\n  });\n\n  elementsInSelection = excludeElementsInFrames\n    ? excludeElementsInFramesFromSelection(elementsInSelection)\n    : elementsInSelection;\n\n  elementsInSelection = elementsInSelection.filter((element) => {\n    const containingFrame = getContainingFrame(element, elementsMap);\n\n    if (containingFrame) {\n      return elementOverlapsWithFrame(element, containingFrame, elementsMap);\n    }\n\n    return true;\n  });\n\n  return elementsInSelection;\n};\n\nexport const getVisibleAndNonSelectedElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selectedElements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  const selectedElementsSet = new Set(\n    selectedElements.map((element) => element.id),\n  );\n  return elements.filter((element) => {\n    const isVisible = isElementInViewport(\n      element,\n      appState.width,\n      appState.height,\n      appState,\n      elementsMap,\n    );\n\n    return !selectedElementsSet.has(element.id) && isVisible;\n  });\n};\n\n// FIXME move this into the editor instance to keep utility methods stateless\nexport const isSomeElementSelected = (function () {\n  let lastElements: readonly NonDeletedExcalidrawElement[] | null = null;\n  let lastSelectedElementIds: AppState[\"selectedElementIds\"] | null = null;\n  let isSelected: boolean | null = null;\n\n  const ret = (\n    elements: readonly NonDeletedExcalidrawElement[],\n    appState: Pick<AppState, \"selectedElementIds\">,\n  ): boolean => {\n    if (\n      isSelected != null &&\n      elements === lastElements &&\n      appState.selectedElementIds === lastSelectedElementIds\n    ) {\n      return isSelected;\n    }\n\n    isSelected = elements.some(\n      (element) => appState.selectedElementIds[element.id],\n    );\n    lastElements = elements;\n    lastSelectedElementIds = appState.selectedElementIds;\n\n    return isSelected;\n  };\n\n  ret.clearCache = () => {\n    lastElements = null;\n    lastSelectedElementIds = null;\n    isSelected = null;\n  };\n\n  return ret;\n})();\n\nexport const getSelectedElements = (\n  elements: ElementsMapOrArray,\n  appState: Pick<InteractiveCanvasAppState, \"selectedElementIds\">,\n  opts?: {\n    includeBoundTextElement?: boolean;\n    includeElementsInFrames?: boolean;\n  },\n) => {\n  const addedElements = new Set<ExcalidrawElement[\"id\"]>();\n  const selectedElements: ExcalidrawElement[] = [];\n  for (const element of elements.values()) {\n    if (appState.selectedElementIds[element.id]) {\n      selectedElements.push(element);\n      addedElements.add(element.id);\n      continue;\n    }\n    if (\n      opts?.includeBoundTextElement &&\n      isBoundToContainer(element) &&\n      appState.selectedElementIds[element?.containerId]\n    ) {\n      selectedElements.push(element);\n      addedElements.add(element.id);\n      continue;\n    }\n  }\n\n  if (opts?.includeElementsInFrames) {\n    const elementsToInclude: ExcalidrawElement[] = [];\n    selectedElements.forEach((element) => {\n      if (isFrameLikeElement(element)) {\n        getFrameChildren(elements, element.id).forEach(\n          (e) => !addedElements.has(e.id) && elementsToInclude.push(e),\n        );\n      }\n      elementsToInclude.push(element);\n    });\n\n    return elementsToInclude;\n  }\n\n  return selectedElements;\n};\n\nexport const getTargetElements = (\n  elements: ElementsMapOrArray,\n  appState: Pick<\n    AppState,\n    \"selectedElementIds\" | \"editingTextElement\" | \"newElement\"\n  >,\n) =>\n  appState.editingTextElement\n    ? [appState.editingTextElement]\n    : appState.newElement\n    ? [appState.newElement]\n    : getSelectedElements(elements, appState, {\n        includeBoundTextElement: true,\n      });\n\n/**\n * returns prevState's selectedElementids if no change from previous, so as to\n * retain reference identity for memoization\n */\nexport const makeNextSelectedElementIds = (\n  nextSelectedElementIds: AppState[\"selectedElementIds\"],\n  prevState: Pick<AppState, \"selectedElementIds\">,\n) => {\n  if (isShallowEqual(prevState.selectedElementIds, nextSelectedElementIds)) {\n    return prevState.selectedElementIds;\n  }\n\n  return nextSelectedElementIds;\n};\n\nconst _getLinearElementEditor = (\n  targetElements: readonly ExcalidrawElement[],\n  allElements: readonly NonDeletedExcalidrawElement[],\n) => {\n  const linears = targetElements.filter(isLinearElement);\n  if (linears.length === 1) {\n    const linear = linears[0];\n    const boundElements = linear.boundElements?.map((def) => def.id) ?? [];\n    const onlySingleLinearSelected = targetElements.every(\n      (el) => el.id === linear.id || boundElements.includes(el.id),\n    );\n\n    if (onlySingleLinearSelected) {\n      return new LinearElementEditor(linear, arrayToMap(allElements));\n    }\n  }\n\n  return null;\n};\n\nexport const getSelectionStateForElements = (\n  targetElements: readonly ExcalidrawElement[],\n  allElements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  return {\n    selectedLinearElement: _getLinearElementEditor(targetElements, allElements),\n    ...selectGroupsForSelectedElements(\n      {\n        editingGroupId: appState.editingGroupId,\n        selectedElementIds: excludeElementsInFramesFromSelection(\n          targetElements,\n        ).reduce((acc: Record<ExcalidrawElement[\"id\"], true>, element) => {\n          if (!isBoundToContainer(element)) {\n            acc[element.id] = true;\n          }\n          return acc;\n        }, {}),\n      },\n      allElements,\n      appState,\n      null,\n    ),\n  };\n};\n",
    "import type {\n  AppClassProperties,\n  AppState,\n  InteractiveCanvasAppState,\n} from \"excalidraw-custom/types\";\nimport type { Mutable } from \"@excalidraw/common/utility-types\";\n\nimport { getBoundTextElement } from \"./textElement\";\n\nimport { makeNextSelectedElementIds, getSelectedElements } from \"./selection\";\n\nimport type {\n  GroupId,\n  ExcalidrawElement,\n  NonDeleted,\n  NonDeletedExcalidrawElement,\n  ElementsMapOrArray,\n  ElementsMap,\n} from \"./types\";\n\nexport const selectGroup = (\n  groupId: GroupId,\n  appState: InteractiveCanvasAppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): Pick<\n  InteractiveCanvasAppState,\n  \"selectedGroupIds\" | \"selectedElementIds\" | \"editingGroupId\"\n> => {\n  const elementsInGroup = elements.reduce(\n    (acc: Record<string, true>, element) => {\n      if (element.groupIds.includes(groupId)) {\n        acc[element.id] = true;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  if (Object.keys(elementsInGroup).length < 2) {\n    if (\n      appState.selectedGroupIds[groupId] ||\n      appState.editingGroupId === groupId\n    ) {\n      return {\n        selectedElementIds: appState.selectedElementIds,\n        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },\n        editingGroupId: null,\n      };\n    }\n    return appState;\n  }\n\n  return {\n    editingGroupId: appState.editingGroupId,\n    selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },\n    selectedElementIds: {\n      ...appState.selectedElementIds,\n      ...elementsInGroup,\n    },\n  };\n};\n\nexport const selectGroupsForSelectedElements = (function () {\n  type SelectGroupsReturnType = Pick<\n    InteractiveCanvasAppState,\n    \"selectedGroupIds\" | \"editingGroupId\" | \"selectedElementIds\"\n  >;\n\n  let lastSelectedElements: readonly NonDeleted<ExcalidrawElement>[] | null =\n    null;\n  let lastElements: readonly NonDeleted<ExcalidrawElement>[] | null = null;\n  let lastReturnValue: SelectGroupsReturnType | null = null;\n\n  const _selectGroups = (\n    selectedElements: readonly NonDeleted<ExcalidrawElement>[],\n    elements: readonly NonDeleted<ExcalidrawElement>[],\n    appState: Pick<AppState, \"selectedElementIds\" | \"editingGroupId\">,\n    prevAppState: InteractiveCanvasAppState,\n  ): SelectGroupsReturnType => {\n    if (\n      lastReturnValue !== undefined &&\n      elements === lastElements &&\n      selectedElements === lastSelectedElements &&\n      appState.editingGroupId === lastReturnValue?.editingGroupId\n    ) {\n      return lastReturnValue;\n    }\n\n    const selectedGroupIds: Record<GroupId, boolean> = {};\n    // Gather all the groups withing selected elements\n    for (const selectedElement of selectedElements) {\n      let groupIds = selectedElement.groupIds;\n      if (appState.editingGroupId) {\n        // handle the case where a group is nested within a group\n        const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n        if (indexOfEditingGroup > -1) {\n          groupIds = groupIds.slice(0, indexOfEditingGroup);\n        }\n      }\n      if (groupIds.length > 0) {\n        const lastSelectedGroup = groupIds[groupIds.length - 1];\n        selectedGroupIds[lastSelectedGroup] = true;\n      }\n    }\n\n    // Gather all the elements within selected groups\n    const groupElementsIndex: Record<GroupId, string[]> = {};\n    const selectedElementIdsInGroups = elements.reduce(\n      (acc: Record<string, true>, element) => {\n        if (element.isDeleted) {\n          return acc;\n        }\n\n        const groupId = element.groupIds.find((id) => selectedGroupIds[id]);\n\n        if (groupId) {\n          acc[element.id] = true;\n\n          // Populate the index\n          if (!Array.isArray(groupElementsIndex[groupId])) {\n            groupElementsIndex[groupId] = [element.id];\n          } else {\n            groupElementsIndex[groupId].push(element.id);\n          }\n        }\n        return acc;\n      },\n      {},\n    );\n\n    for (const groupId of Object.keys(groupElementsIndex)) {\n      // If there is one element in the group, and the group is selected or it's being edited, it's not a group\n      if (groupElementsIndex[groupId].length < 2) {\n        if (selectedGroupIds[groupId]) {\n          selectedGroupIds[groupId] = false;\n        }\n      }\n    }\n\n    lastElements = elements;\n    lastSelectedElements = selectedElements;\n\n    lastReturnValue = {\n      editingGroupId: appState.editingGroupId,\n      selectedGroupIds,\n      selectedElementIds: makeNextSelectedElementIds(\n        {\n          ...appState.selectedElementIds,\n          ...selectedElementIdsInGroups,\n        },\n        prevAppState,\n      ),\n    };\n\n    return lastReturnValue;\n  };\n\n  /**\n   * When you select an element, you often want to actually select the whole group it's in, unless\n   * you're currently editing that group.\n   */\n  const selectGroupsForSelectedElements = (\n    appState: Pick<AppState, \"selectedElementIds\" | \"editingGroupId\">,\n    elements: readonly NonDeletedExcalidrawElement[],\n    prevAppState: InteractiveCanvasAppState,\n    /**\n     * supply null in cases where you don't have access to App instance and\n     * you don't care about optimizing selectElements retrieval\n     */\n    app: AppClassProperties | null,\n  ): Mutable<\n    Pick<\n      InteractiveCanvasAppState,\n      \"selectedGroupIds\" | \"editingGroupId\" | \"selectedElementIds\"\n    >\n  > => {\n    const selectedElements = app\n      ? app.scene.getSelectedElements({\n          selectedElementIds: appState.selectedElementIds,\n          // supplying elements explicitly in case we're passed non-state elements\n          elements,\n        })\n      : getSelectedElements(elements, appState);\n\n    if (!selectedElements.length) {\n      return {\n        selectedGroupIds: {},\n        editingGroupId: null,\n        selectedElementIds: makeNextSelectedElementIds(\n          appState.selectedElementIds,\n          prevAppState,\n        ),\n      };\n    }\n\n    return _selectGroups(selectedElements, elements, appState, prevAppState);\n  };\n\n  selectGroupsForSelectedElements.clearCache = () => {\n    lastElements = null;\n    lastSelectedElements = null;\n    lastReturnValue = null;\n  };\n\n  return selectGroupsForSelectedElements;\n})();\n\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\nexport const isSelectedViaGroup = (\n  appState: InteractiveCanvasAppState,\n  element: ExcalidrawElement,\n) => getSelectedGroupForElement(appState, element) != null;\n\nexport const getSelectedGroupForElement = (\n  appState: Pick<\n    InteractiveCanvasAppState,\n    \"editingGroupId\" | \"selectedGroupIds\"\n  >,\n  element: ExcalidrawElement,\n) =>\n  element.groupIds\n    .filter((groupId) => groupId !== appState.editingGroupId)\n    .find((groupId) => appState.selectedGroupIds[groupId]);\n\nexport const getSelectedGroupIds = (\n  appState: InteractiveCanvasAppState,\n): GroupId[] =>\n  Object.entries(appState.selectedGroupIds)\n    .filter(([groupId, isSelected]) => isSelected)\n    .map(([groupId, isSelected]) => groupId);\n\n// given a list of elements, return the the actual group ids that should be selected\n// or used to update the elements\nexport const selectGroupsFromGivenElements = (\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n  appState: InteractiveCanvasAppState,\n) => {\n  let nextAppState: InteractiveCanvasAppState = {\n    ...appState,\n    selectedGroupIds: {},\n  };\n\n  for (const element of elements) {\n    let groupIds = element.groupIds;\n    if (appState.editingGroupId) {\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = {\n        ...nextAppState,\n        ...selectGroup(groupId, nextAppState, elements),\n      };\n    }\n  }\n\n  return nextAppState.selectedGroupIds;\n};\n\nexport const editGroupForSelectedElement = (\n  appState: AppState,\n  element: NonDeleted<ExcalidrawElement>,\n): AppState => {\n  return {\n    ...appState,\n    editingGroupId: element.groupIds.length ? element.groupIds[0] : null,\n    selectedGroupIds: {},\n    selectedElementIds: {\n      [element.id]: true,\n    },\n  };\n};\n\nexport const isElementInGroup = (element: ExcalidrawElement, groupId: string) =>\n  element.groupIds.includes(groupId);\n\nexport const getElementsInGroup = (\n  elements: ElementsMapOrArray,\n  groupId: string,\n) => {\n  const elementsInGroup: ExcalidrawElement[] = [];\n  for (const element of elements.values()) {\n    if (isElementInGroup(element, groupId)) {\n      elementsInGroup.push(element);\n    }\n  }\n  return elementsInGroup;\n};\n\nexport const getSelectedGroupIdForElement = (\n  element: ExcalidrawElement,\n  selectedGroupIds: { [groupId: string]: boolean },\n) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);\n\nexport const addToGroup = (\n  prevGroupIds: ExcalidrawElement[\"groupIds\"],\n  newGroupId: GroupId,\n  editingGroupId: AppState[\"editingGroupId\"],\n) => {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const positionToInsert =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n};\n\nexport const removeFromSelectedGroups = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  selectedGroupIds: { [groupId: string]: boolean },\n) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);\n\nexport const getMaximumGroups = (\n  elements: ExcalidrawElement[],\n  elementsMap: ElementsMap,\n): ExcalidrawElement[][] => {\n  const groups: Map<String, ExcalidrawElement[]> = new Map<\n    String,\n    ExcalidrawElement[]\n  >();\n  elements.forEach((element: ExcalidrawElement) => {\n    const groupId =\n      element.groupIds.length === 0\n        ? element.id\n        : element.groupIds[element.groupIds.length - 1];\n\n    const currentGroupMembers = groups.get(groupId) || [];\n\n    // Include bound text if present when grouping\n    const boundTextElement = getBoundTextElement(element, elementsMap);\n    if (boundTextElement) {\n      currentGroupMembers.push(boundTextElement);\n    }\n    groups.set(groupId, [...currentGroupMembers, element]);\n  });\n\n  return Array.from(groups.values());\n};\n\nexport const getNonDeletedGroupIds = (elements: ElementsMap) => {\n  const nonDeletedGroupIds = new Set<string>();\n\n  for (const [, element] of elements) {\n    // defensive check\n    if (element.isDeleted) {\n      continue;\n    }\n\n    // defensive fallback\n    for (const groupId of element.groupIds ?? []) {\n      nonDeletedGroupIds.add(groupId);\n    }\n  }\n\n  return nonDeletedGroupIds;\n};\n\nexport const elementsAreInSameGroup = (\n  elements: readonly ExcalidrawElement[],\n) => {\n  const allGroups = elements.flatMap((element) => element.groupIds);\n  const groupCount = new Map<string, number>();\n  let maxGroup = 0;\n\n  for (const group of allGroups) {\n    groupCount.set(group, (groupCount.get(group) ?? 0) + 1);\n    if (groupCount.get(group)! > maxGroup) {\n      maxGroup = groupCount.get(group)!;\n    }\n  }\n\n  return maxGroup === elements.length;\n};\n\nexport const isInGroup = (element: NonDeletedExcalidrawElement) => {\n  return element.groupIds.length > 0;\n};\n\nexport const getNewGroupIdsForDuplication = (\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  editingGroupId: AppState[\"editingGroupId\"],\n  mapper: (groupId: GroupId) => GroupId,\n) => {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const endIndex =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  for (let index = 0; index < endIndex; index++) {\n    copy[index] = mapper(copy[index]);\n  }\n\n  return copy;\n};\n",
    "import type { ElementOrToolType } from \"excalidraw-custom/types\";\n\nexport const hasBackground = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"line\" ||\n  type === \"freedraw\";\n\nexport const hasStrokeColor = (type: ElementOrToolType) =>\n  type !== \"image\" && type !== \"frame\" && type !== \"magicframe\";\n\nexport const hasStrokeWidth = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"freedraw\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const hasStrokeStyle = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"ellipse\" ||\n  type === \"diamond\" ||\n  type === \"arrow\" ||\n  type === \"line\";\n\nexport const canChangeRoundness = (type: ElementOrToolType) =>\n  type === \"rectangle\" ||\n  type === \"iframe\" ||\n  type === \"embeddable\" ||\n  type === \"line\" ||\n  type === \"diamond\" ||\n  type === \"image\";\n\nexport const toolIsArrow = (type: ElementOrToolType) => type === \"arrow\";\n\nexport const canHaveArrowheads = (type: ElementOrToolType) => type === \"arrow\";\n",
    "import {\n  KEYS,\n  CANVAS_SEARCH_TAB,\n  CLASSES,\n  DEFAULT_SIDEBAR,\n} from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { searchIcon } from \"../components/icons\";\n\nimport { register } from \"./register\";\n\nimport type { AppState } from \"../types\";\n\nexport const actionToggleSearchMenu = register({\n  name: \"searchMenu\",\n  icon: searchIcon,\n  keywords: [\"search\", \"find\"],\n  label: \"search.title\",\n  viewMode: true,\n  trackEvent: {\n    category: \"search_menu\",\n    action: \"toggle\",\n    predicate: (appState) => appState.gridModeEnabled,\n  },\n  perform(elements, appState, _, app) {\n    if (appState.openDialog) {\n      return false;\n    }\n\n    if (\n      appState.openSidebar?.name === DEFAULT_SIDEBAR.name &&\n      appState.openSidebar.tab === CANVAS_SEARCH_TAB\n    ) {\n      const searchInput =\n        app.excalidrawContainerValue.container?.querySelector<HTMLInputElement>(\n          `.${CLASSES.SEARCH_MENU_INPUT_WRAPPER} input`,\n        );\n\n      searchInput?.focus();\n      searchInput?.select();\n      return false;\n    }\n\n    return {\n      appState: {\n        ...appState,\n        openSidebar: { name: DEFAULT_SIDEBAR.name, tab: CANVAS_SEARCH_TAB },\n        openDialog: null,\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  checked: (appState: AppState) => appState.gridModeEnabled,\n  predicate: (element, appState, props) => {\n    return props.gridModeEnabled === undefined;\n  },\n  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.F,\n});\n",
    "import { isImageElement } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ExcalidrawImageElement } from \"@excalidraw/element/types\";\n\nimport { ToolButton } from \"../components/ToolButton\";\nimport { cropIcon } from \"../components/icons\";\nimport { t } from \"../i18n\";\n\nimport { register } from \"./register\";\n\nexport const actionToggleCropEditor = register({\n  name: \"cropEditor\",\n  label: \"helpDialog.cropStart\",\n  icon: cropIcon,\n  viewMode: true,\n  trackEvent: { category: \"menu\" },\n  keywords: [\"image\", \"crop\"],\n  perform(elements, appState, _, app) {\n    const selectedElement = app.scene.getSelectedElements({\n      selectedElementIds: appState.selectedElementIds,\n      includeBoundTextElement: true,\n    })[0] as ExcalidrawImageElement;\n\n    return {\n      appState: {\n        ...appState,\n        isCropping: false,\n        croppingElementId: selectedElement.id,\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = app.scene.getSelectedElements(appState);\n    if (\n      !appState.croppingElementId &&\n      selectedElements.length === 1 &&\n      isImageElement(selectedElements[0])\n    ) {\n      return true;\n    }\n    return false;\n  },\n  PanelComponent: ({ appState, updateData, app }) => {\n    const label = t(\"helpDialog.cropStart\");\n\n    return (\n      <ToolButton\n        type=\"button\"\n        icon={cropIcon}\n        title={label}\n        aria-label={label}\n        onClick={() => updateData(null)}\n      />\n    );\n  },\n});\n",
    "import { randomId, arrayToMap } from \"@excalidraw/common\";\nimport { newElementWith, duplicateElements } from \"@excalidraw/element\";\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\nimport { isTextElement } from \"@excalidraw/element\";\n\nimport { ToolButton } from \"../components/ToolButton\";\nimport { t } from \"../i18n\";\nimport { getSelectedElements } from \"../scene\";\n\nimport { register } from \"./register\";\n\n// Simple API call function\nconst callApi = async (action: string, data: any) => {\n  try {\n    console.log(`🌐 API Call: ${action}`, data);\n\n    // Dùng JSONPlaceholder làm demo API - thay bằng URL thật của bạn\n    const response = await fetch(`https://jsonplaceholder.typicode.com/posts`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        action,\n        elementData: data,\n        timestamp: Date.now(),\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const result = await response.json();\n    console.log(`✅ API Response:`, result);\n\n    return { success: true, data: result };\n  } catch (error) {\n    console.error(`❌ API Error:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown error\",\n    };\n  }\n};\n\n// Custom icon\nconst HighlightIcon = (\n  <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n    <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\" />\n  </svg>\n);\n\nexport const actionCustomHighlight = register({\n  name: \"customHighlight\",\n  label: \"Custom Highlight\",\n  icon: HighlightIcon,\n  trackEvent: { category: \"element\", action: \"highlight\" },\n\n  perform: async (elements, appState, _, app) => {\n    console.log(\"🎨 Custom Highlight action triggered!\");\n    const selectedElements = getSelectedElements(elements, appState);\n\n    if (selectedElements.length === 0) {\n      return {\n        elements,\n        appState: {\n          ...appState,\n          errorMessage: \"Please select elements to highlight\",\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    }\n\n    // Prepare API data\n    const elementIds = selectedElements.map((el) => el.id);\n    const apiData = {\n      elementIds,\n      action: \"highlight\",\n      colors: { background: \"#ffe066\", stroke: \"#ff6b6b\" },\n    };\n\n    console.log(\"🔄 Calling API...\");\n\n    try {\n      // Call API\n      const apiResponse = await callApi(\"highlight\", apiData);\n\n      if (!apiResponse.success) {\n        return {\n          elements,\n          appState: {\n            ...appState,\n            errorMessage: `API Error: ${apiResponse.error}`,\n            toast: {\n              message: `❌ API failed: ${apiResponse.error}`,\n              closable: true,\n            },\n          },\n          captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n        };\n      }\n\n      // Update elements với highlight\n      const updatedElements = elements.map((element) => {\n        if (appState.selectedElementIds[element.id]) {\n          return newElementWith(element, {\n            backgroundColor: \"#ffe066\",\n            strokeColor: \"#ff6b6b\",\n            strokeWidth: Math.max(element.strokeWidth, 2),\n          });\n        }\n        return element;\n      });\n\n      return {\n        elements: updatedElements,\n        appState: {\n          ...appState,\n          toast: {\n            message: `✅ Highlighted ${selectedElements.length} element(s) and saved to API!`,\n            closable: true,\n          },\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    } catch (error) {\n      console.error(\"API call failed:\", error);\n      return {\n        elements,\n        appState: {\n          ...appState,\n          errorMessage: \"Failed to connect to server\",\n          toast: {\n            message: \"❌ Network error. Highlight not saved.\",\n            closable: true,\n          },\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    }\n  },\n\n  predicate: (elements, appState) => {\n    return Object.keys(appState.selectedElementIds).length > 0;\n  },\n\n  PanelComponent: ({ elements, appState, updateData }) => {\n    const selectedElements = getSelectedElements(elements, appState);\n    const isHighlighted = selectedElements.some(\n      (el) => el.backgroundColor === \"#ffe066\" && el.strokeColor === \"#ff6b6b\",\n    );\n\n    return (\n      <ToolButton\n        type=\"button\"\n        icon={HighlightIcon}\n        aria-label=\"Highlight selected elements\"\n        title=\"Apply custom highlight effect to selected elements\"\n        onClick={() => updateData(null)}\n        selected={isHighlighted}\n        className=\"custom-highlight-button\"\n      />\n    );\n  },\n});\n\nexport const actionClearHighlight = register({\n  name: \"clearHighlight\",\n  label: \"Clear Highlight\",\n  trackEvent: { category: \"element\", action: \"clear-highlight\" },\n\n  perform: async (elements, appState, _, app) => {\n    console.log(\"🧹 Clear Highlight action triggered!\");\n    const selectedElements = getSelectedElements(elements, appState);\n\n    if (selectedElements.length === 0) {\n      return {\n        elements,\n        appState: {\n          ...appState,\n          errorMessage: \"Please select elements to clear highlight\",\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    }\n\n    // Call API\n    const elementIds = selectedElements.map((el) => el.id);\n    console.log(\"🔄 Calling clear API...\");\n\n    try {\n      const apiResponse = await callApi(\"clear\", { elementIds });\n\n      if (!apiResponse.success) {\n        return {\n          elements,\n          appState: {\n            ...appState,\n            toast: {\n              message: `❌ API failed: ${apiResponse.error}`,\n              closable: true,\n            },\n          },\n          captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n        };\n      }\n\n      // Clear highlight\n      const updatedElements = elements.map((element) => {\n        if (appState.selectedElementIds[element.id]) {\n          return newElementWith(element, {\n            backgroundColor: \"transparent\",\n            strokeColor: \"#1e1e1e\",\n            strokeWidth: 1,\n          });\n        }\n        return element;\n      });\n\n      return {\n        elements: updatedElements,\n        appState: {\n          ...appState,\n          toast: {\n            message: `✅ Cleared ${selectedElements.length} element(s) and updated API!`,\n            closable: true,\n          },\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    } catch (error) {\n      console.error(\"API call failed:\", error);\n      return {\n        elements,\n        appState: {\n          ...appState,\n          toast: {\n            message: \"❌ Network error. Clear not saved.\",\n            closable: true,\n          },\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    }\n  },\n\n  predicate: (elements, appState) => {\n    const selectedElements = getSelectedElements(elements, appState);\n    return selectedElements.some(\n      (el) => el.backgroundColor === \"#ffe066\" && el.strokeColor === \"#ff6b6b\",\n    );\n  },\n\n  PanelComponent: ({ elements, appState, updateData }) => {\n    const selectedElements = getSelectedElements(elements, appState);\n    const hasHighlighted = selectedElements.some(\n      (el) => el.backgroundColor === \"#ffe066\" && el.strokeColor === \"#ff6b6b\",\n    );\n\n    if (!hasHighlighted) {\n      return null;\n    }\n\n    return (\n      <ToolButton\n        type=\"button\"\n        icon={<span>🧹</span>}\n        aria-label=\"Clear highlight from selected elements\"\n        title=\"Remove custom highlight effect\"\n        onClick={() => updateData(null)}\n        className=\"clear-highlight-button\"\n      />\n    );\n  },\n});\n\nexport const actionDuplicateAndHighlight = register({\n  name: \"duplicateAndHighlight\",\n  label: \"Duplicate & Highlight\",\n  trackEvent: { category: \"element\", action: \"duplicate-highlight\" },\n\n  perform: async (elements, appState, _, app) => {\n    console.log(\"🎨 Duplicate & Highlight action triggered!\");\n    const selectedElements = getSelectedElements(elements, appState);\n\n    if (selectedElements.length === 0) {\n      return {\n        elements,\n        appState: {\n          ...appState,\n          errorMessage: \"Please select elements to duplicate and highlight\",\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    }\n\n    // Call API\n    const elementIds = selectedElements.map((el) => el.id);\n    console.log(\"🔄 Calling duplicate API...\");\n\n    try {\n      const apiResponse = await callApi(\"duplicate\", {\n        elementIds,\n        action: \"duplicate\",\n        colors: { background: \"#66d9ef\", stroke: \"#a6e22e\" },\n      });\n\n      // Duplicate elements (regardless của API result)\n      const { duplicatedElements, elementsWithDuplicates } = duplicateElements({\n        type: \"in-place\",\n        elements,\n        idsOfElementsToDuplicate: arrayToMap(selectedElements),\n        appState,\n        randomizeSeed: true,\n        overrides: ({ origElement }) => ({\n          x: origElement.x + 50,\n          y: origElement.y + 50,\n          backgroundColor: \"#66d9ef\",\n          strokeColor: \"#a6e22e\",\n          strokeWidth: Math.max(origElement.strokeWidth, 2),\n        }),\n      });\n\n      const newSelectedElementIds = duplicatedElements.reduce((acc, el) => {\n        acc[el.id] = true;\n        return acc;\n      }, {} as Record<string, true>);\n\n      const message = apiResponse.success\n        ? `✅ Duplicated ${selectedElements.length} element(s) and logged to API!`\n        : `⚠️ Duplicated locally but API failed: ${apiResponse.error}`;\n\n      return {\n        elements: elementsWithDuplicates,\n        appState: {\n          ...appState,\n          selectedElementIds: newSelectedElementIds,\n          toast: {\n            message,\n            closable: true,\n          },\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    } catch (error) {\n      console.error(\"API call failed:\", error);\n\n      // Still duplicate even if API fails\n      const { duplicatedElements, elementsWithDuplicates } = duplicateElements({\n        type: \"in-place\",\n        elements,\n        idsOfElementsToDuplicate: arrayToMap(selectedElements),\n        appState,\n        randomizeSeed: true,\n        overrides: ({ origElement }) => ({\n          x: origElement.x + 50,\n          y: origElement.y + 50,\n          backgroundColor: \"#66d9ef\",\n          strokeColor: \"#a6e22e\",\n          strokeWidth: Math.max(origElement.strokeWidth, 2),\n        }),\n      });\n\n      const newSelectedElementIds = duplicatedElements.reduce((acc, el) => {\n        acc[el.id] = true;\n        return acc;\n      }, {} as Record<string, true>);\n\n      return {\n        elements: elementsWithDuplicates,\n        appState: {\n          ...appState,\n          selectedElementIds: newSelectedElementIds,\n          toast: {\n            message: \"⚠️ Duplicated locally but network error\",\n            closable: true,\n          },\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    }\n  },\n\n  predicate: (elements, appState) => {\n    return Object.keys(appState.selectedElementIds).length > 0;\n  },\n\n  PanelComponent: ({ elements, appState, updateData }) => {\n    return (\n      <ToolButton\n        type=\"button\"\n        icon={<span>🎨</span>}\n        aria-label=\"Duplicate and highlight selected elements\"\n        title=\"Create highlighted duplicates of selected elements\"\n        onClick={() => updateData(null)}\n        className=\"duplicate-highlight-button\"\n      />\n    );\n  },\n});\n",
    "import { getNonDeletedElements } from \"@excalidraw/element\";\nimport { mutateElement } from \"@excalidraw/element\";\nimport { newFrameElement } from \"@excalidraw/element\";\nimport { isFrameLikeElement } from \"@excalidraw/element\";\nimport {\n  addElementsToFrame,\n  removeAllElementsFromFrame,\n} from \"@excalidraw/element\";\nimport { getFrameChildren } from \"@excalidraw/element\";\n\nimport { KEYS, updateActiveTool } from \"@excalidraw/common\";\n\nimport { getElementsInGroup } from \"@excalidraw/element\";\n\nimport { getCommonBounds } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { setCursorForShape } from \"../cursor\";\nimport { frameToolIcon } from \"../components/icons\";\nimport { getSelectedElements } from \"../scene\";\n\nimport { register } from \"./register\";\n\nimport type { AppClassProperties, AppState, UIAppState } from \"../types\";\n\nconst isSingleFrameSelected = (\n  appState: UIAppState,\n  app: AppClassProperties,\n) => {\n  const selectedElements = app.scene.getSelectedElements(appState);\n\n  return (\n    selectedElements.length === 1 && isFrameLikeElement(selectedElements[0])\n  );\n};\n\nexport const actionSelectAllElementsInFrame = register({\n  name: \"selectAllElementsInFrame\",\n  label: \"labels.selectAllElementsInFrame\",\n  trackEvent: { category: \"canvas\" },\n  perform: (elements, appState, _, app) => {\n    const selectedElement =\n      app.scene.getSelectedElements(appState).at(0) || null;\n\n    if (isFrameLikeElement(selectedElement)) {\n      const elementsInFrame = getFrameChildren(\n        getNonDeletedElements(elements),\n        selectedElement.id,\n      ).filter((element) => !(element.type === \"text\" && element.containerId));\n\n      return {\n        elements,\n        appState: {\n          ...appState,\n          selectedElementIds: elementsInFrame.reduce((acc, element) => {\n            acc[element.id] = true;\n            return acc;\n          }, {} as Record<ExcalidrawElement[\"id\"], true>),\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    }\n\n    return {\n      elements,\n      appState,\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  predicate: (elements, appState, _, app) =>\n    isSingleFrameSelected(appState, app),\n});\n\nexport const actionRemoveAllElementsFromFrame = register({\n  name: \"removeAllElementsFromFrame\",\n  label: \"labels.removeAllElementsFromFrame\",\n  trackEvent: { category: \"history\" },\n  perform: (elements, appState, _, app) => {\n    const selectedElement =\n      app.scene.getSelectedElements(appState).at(0) || null;\n\n    if (isFrameLikeElement(selectedElement)) {\n      return {\n        elements: removeAllElementsFromFrame(elements, selectedElement),\n        appState: {\n          ...appState,\n          selectedElementIds: {\n            [selectedElement.id]: true,\n          },\n        },\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      };\n    }\n\n    return {\n      elements,\n      appState,\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  predicate: (elements, appState, _, app) =>\n    isSingleFrameSelected(appState, app),\n});\n\nexport const actionupdateFrameRendering = register({\n  name: \"updateFrameRendering\",\n  label: \"labels.updateFrameRendering\",\n  viewMode: true,\n  trackEvent: { category: \"canvas\" },\n  perform: (elements, appState) => {\n    return {\n      elements,\n      appState: {\n        ...appState,\n        frameRendering: {\n          ...appState.frameRendering,\n          enabled: !appState.frameRendering.enabled,\n        },\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  checked: (appState: AppState) => appState.frameRendering.enabled,\n});\n\nexport const actionSetFrameAsActiveTool = register({\n  name: \"setFrameAsActiveTool\",\n  label: \"toolBar.frame\",\n  trackEvent: { category: \"toolbar\" },\n  icon: frameToolIcon,\n  viewMode: false,\n  perform: (elements, appState, _, app) => {\n    const nextActiveTool = updateActiveTool(appState, {\n      type: \"frame\",\n    });\n\n    setCursorForShape(app.interactiveCanvas, {\n      ...appState,\n      activeTool: nextActiveTool,\n    });\n\n    return {\n      elements,\n      appState: {\n        ...appState,\n        activeTool: updateActiveTool(appState, {\n          type: \"frame\",\n        }),\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] &&\n    !event.shiftKey &&\n    !event.altKey &&\n    event.key.toLocaleLowerCase() === KEYS.F,\n});\n\nexport const actionWrapSelectionInFrame = register({\n  name: \"wrapSelectionInFrame\",\n  label: \"labels.wrapSelectionInFrame\",\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, _, app) => {\n    const selectedElements = getSelectedElements(elements, appState);\n\n    return (\n      selectedElements.length > 0 &&\n      !selectedElements.some((element) => isFrameLikeElement(element))\n    );\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = getSelectedElements(elements, appState);\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements, elementsMap);\n    const PADDING = 16;\n    const frame = newFrameElement({\n      x: x1 - PADDING,\n      y: y1 - PADDING,\n      width: x2 - x1 + PADDING * 2,\n      height: y2 - y1 + PADDING * 2,\n    });\n\n    // for a selected partial group, we want to remove it from the remainder of the group\n    if (appState.editingGroupId) {\n      const elementsInGroup = getElementsInGroup(\n        selectedElements,\n        appState.editingGroupId,\n      );\n\n      for (const elementInGroup of elementsInGroup) {\n        const index = elementInGroup.groupIds.indexOf(appState.editingGroupId);\n\n        mutateElement(elementInGroup, elementsMap, {\n          groupIds: elementInGroup.groupIds.slice(0, index),\n        });\n      }\n    }\n\n    const nextElements = addElementsToFrame(\n      [...app.scene.getElementsIncludingDeleted(), frame],\n      selectedElements,\n      frame,\n      appState,\n    );\n\n    return {\n      elements: nextElements,\n      appState: {\n        selectedElementIds: { [frame.id]: true },\n      },\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n});\n",
    "import { isWindows, KEYS, matchKey, arrayToMap } from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { orderByFractionalIndex } from \"@excalidraw/element\";\n\nimport type { SceneElementsMap } from \"@excalidraw/element/types\";\n\nimport { ToolButton } from \"../components/ToolButton\";\nimport { UndoIcon, RedoIcon } from \"../components/icons\";\nimport { HistoryChangedEvent } from \"../history\";\nimport { useEmitter } from \"../hooks/useEmitter\";\nimport { t } from \"../i18n\";\n\nimport type { History } from \"../history\";\nimport type { AppClassProperties, AppState } from \"../types\";\nimport type { Action, ActionResult } from \"./types\";\n\nconst executeHistoryAction = (\n  app: AppClassProperties,\n  appState: Readonly<AppState>,\n  updater: () => [SceneElementsMap, AppState] | void,\n): ActionResult => {\n  if (\n    !appState.multiElement &&\n    !appState.resizingElement &&\n    !appState.editingTextElement &&\n    !appState.newElement &&\n    !appState.selectedElementsAreBeingDragged &&\n    !appState.selectionElement &&\n    !app.flowChartCreator.isCreatingChart\n  ) {\n    const result = updater();\n\n    if (!result) {\n      return { captureUpdate: CaptureUpdateAction.EVENTUALLY };\n    }\n\n    const [nextElementsMap, nextAppState] = result;\n\n    // order by fractional indices in case the map was accidently modified in the meantime\n    const nextElements = orderByFractionalIndex(\n      Array.from(nextElementsMap.values()),\n    );\n\n    return {\n      appState: nextAppState,\n      elements: nextElements,\n      captureUpdate: CaptureUpdateAction.NEVER,\n    };\n  }\n\n  return { captureUpdate: CaptureUpdateAction.EVENTUALLY };\n};\n\ntype ActionCreator = (history: History) => Action;\n\nexport const createUndoAction: ActionCreator = (history) => ({\n  name: \"undo\",\n  label: \"buttons.undo\",\n  icon: UndoIcon,\n  trackEvent: { category: \"history\" },\n  viewMode: false,\n  perform: (elements, appState, value, app) =>\n    executeHistoryAction(app, appState, () =>\n      history.undo(arrayToMap(elements) as SceneElementsMap, appState),\n    ),\n  keyTest: (event) =>\n    event[KEYS.CTRL_OR_CMD] && matchKey(event, KEYS.Z) && !event.shiftKey,\n  PanelComponent: ({ updateData, data }) => {\n    const { isUndoStackEmpty } = useEmitter<HistoryChangedEvent>(\n      history.onHistoryChangedEmitter,\n      new HistoryChangedEvent(\n        history.isUndoStackEmpty,\n        history.isRedoStackEmpty,\n      ),\n    );\n\n    return (\n      <ToolButton\n        type=\"button\"\n        icon={UndoIcon}\n        aria-label={t(\"buttons.undo\")}\n        onClick={updateData}\n        size={data?.size || \"medium\"}\n        disabled={isUndoStackEmpty}\n        data-testid=\"button-undo\"\n      />\n    );\n  },\n});\n\nexport const createRedoAction: ActionCreator = (history) => ({\n  name: \"redo\",\n  label: \"buttons.redo\",\n  icon: RedoIcon,\n  trackEvent: { category: \"history\" },\n  viewMode: false,\n  perform: (elements, appState, __, app) =>\n    executeHistoryAction(app, appState, () =>\n      history.redo(arrayToMap(elements) as SceneElementsMap, appState),\n    ),\n  keyTest: (event) =>\n    (event[KEYS.CTRL_OR_CMD] && event.shiftKey && matchKey(event, KEYS.Z)) ||\n    (isWindows && event.ctrlKey && !event.shiftKey && matchKey(event, KEYS.Y)),\n  PanelComponent: ({ updateData, data }) => {\n    const { isRedoStackEmpty } = useEmitter(\n      history.onHistoryChangedEmitter,\n      new HistoryChangedEvent(\n        history.isUndoStackEmpty,\n        history.isRedoStackEmpty,\n      ),\n    );\n\n    return (\n      <ToolButton\n        type=\"button\"\n        icon={RedoIcon}\n        aria-label={t(\"buttons.redo\")}\n        onClick={updateData}\n        size={data?.size || \"medium\"}\n        disabled={isRedoStackEmpty}\n        data-testid=\"button-redo\"\n      />\n    );\n  },\n});\n",
    "import { Emitter } from \"@excalidraw/common\";\n\nimport {\n  CaptureUpdateAction,\n  StoreChange,\n  StoreDelta,\n} from \"@excalidraw/element\";\n\nimport type { StoreSnapshot, Store } from \"@excalidraw/element\";\n\nimport type { SceneElementsMap } from \"@excalidraw/element/types\";\n\nimport type { AppState } from \"./types\";\n\nexport class HistoryDelta extends StoreDelta {\n  /**\n   * Apply the delta to the passed elements and appState, does not modify the snapshot.\n   */\n  public applyTo(\n    elements: SceneElementsMap,\n    appState: AppState,\n    snapshot: StoreSnapshot,\n  ): [SceneElementsMap, AppState, boolean] {\n    const [nextElements, elementsContainVisibleChange] = this.elements.applyTo(\n      elements,\n      // used to fallback into local snapshot in case we couldn't apply the delta\n      // due to a missing (force deleted) elements in the scene\n      snapshot.elements,\n      // we don't want to apply the `version` and `versionNonce` properties for history\n      // as we always need to end up with a new version due to collaboration,\n      // approaching each undo / redo as a new user action\n      {\n        excludedProperties: new Set([\"version\", \"versionNonce\"]),\n      },\n    );\n\n    const [nextAppState, appStateContainsVisibleChange] = this.appState.applyTo(\n      appState,\n      nextElements,\n    );\n\n    const appliedVisibleChanges =\n      elementsContainVisibleChange || appStateContainsVisibleChange;\n\n    return [nextElements, nextAppState, appliedVisibleChanges];\n  }\n\n  /**\n   * Overriding once to avoid type casting everywhere.\n   */\n  public static override calculate(\n    prevSnapshot: StoreSnapshot,\n    nextSnapshot: StoreSnapshot,\n  ) {\n    return super.calculate(prevSnapshot, nextSnapshot) as HistoryDelta;\n  }\n\n  /**\n   * Overriding once to avoid type casting everywhere.\n   */\n  public static override inverse(delta: StoreDelta): HistoryDelta {\n    return super.inverse(delta) as HistoryDelta;\n  }\n\n  /**\n   * Overriding once to avoid type casting everywhere.\n   */\n  public static override applyLatestChanges(\n    delta: StoreDelta,\n    prevElements: SceneElementsMap,\n    nextElements: SceneElementsMap,\n    modifierOptions?: \"deleted\" | \"inserted\",\n  ) {\n    return super.applyLatestChanges(\n      delta,\n      prevElements,\n      nextElements,\n      modifierOptions,\n    ) as HistoryDelta;\n  }\n}\n\nexport class HistoryChangedEvent {\n  constructor(\n    public readonly isUndoStackEmpty: boolean = true,\n    public readonly isRedoStackEmpty: boolean = true,\n  ) {}\n}\n\nexport class History {\n  public readonly onHistoryChangedEmitter = new Emitter<\n    [HistoryChangedEvent]\n  >();\n\n  public readonly undoStack: HistoryDelta[] = [];\n  public readonly redoStack: HistoryDelta[] = [];\n\n  public get isUndoStackEmpty() {\n    return this.undoStack.length === 0;\n  }\n\n  public get isRedoStackEmpty() {\n    return this.redoStack.length === 0;\n  }\n\n  constructor(private readonly store: Store) {}\n\n  public clear() {\n    this.undoStack.length = 0;\n    this.redoStack.length = 0;\n  }\n\n  /**\n   * Record a non-empty local durable increment, which will go into the undo stack..\n   * Do not re-record history entries, which were already pushed to undo / redo stack, as part of history action.\n   */\n  public record(delta: StoreDelta) {\n    if (delta.isEmpty() || delta instanceof HistoryDelta) {\n      return;\n    }\n\n    // construct history entry, so once it's emitted, it's not recorded again\n    const historyDelta = HistoryDelta.inverse(delta);\n\n    this.undoStack.push(historyDelta);\n\n    if (!historyDelta.elements.isEmpty()) {\n      // don't reset redo stack on local appState changes,\n      // as a simple click (unselect) could lead to losing all the redo entries\n      // only reset on non empty elements changes!\n      this.redoStack.length = 0;\n    }\n\n    this.onHistoryChangedEmitter.trigger(\n      new HistoryChangedEvent(this.isUndoStackEmpty, this.isRedoStackEmpty),\n    );\n  }\n\n  public undo(elements: SceneElementsMap, appState: AppState) {\n    return this.perform(\n      elements,\n      appState,\n      () => History.pop(this.undoStack),\n      (entry: HistoryDelta) => History.push(this.redoStack, entry),\n    );\n  }\n\n  public redo(elements: SceneElementsMap, appState: AppState) {\n    return this.perform(\n      elements,\n      appState,\n      () => History.pop(this.redoStack),\n      (entry: HistoryDelta) => History.push(this.undoStack, entry),\n    );\n  }\n\n  private perform(\n    elements: SceneElementsMap,\n    appState: AppState,\n    pop: () => HistoryDelta | null,\n    push: (entry: HistoryDelta) => void,\n  ): [SceneElementsMap, AppState] | void {\n    try {\n      let historyDelta = pop();\n\n      if (historyDelta === null) {\n        return;\n      }\n\n      const action = CaptureUpdateAction.IMMEDIATELY;\n\n      let prevSnapshot = this.store.snapshot;\n\n      let nextElements = elements;\n      let nextAppState = appState;\n      let containsVisibleChange = false;\n\n      // iterate through the history entries in case ;they result in no visible changes\n      while (historyDelta) {\n        try {\n          [nextElements, nextAppState, containsVisibleChange] =\n            historyDelta.applyTo(nextElements, nextAppState, prevSnapshot);\n\n          const prevElements = prevSnapshot.elements;\n          const nextSnapshot = prevSnapshot.maybeClone(\n            action,\n            nextElements,\n            nextAppState,\n          );\n\n          const change = StoreChange.create(prevSnapshot, nextSnapshot);\n          const delta = HistoryDelta.applyLatestChanges(\n            historyDelta,\n            prevElements,\n            nextElements,\n          );\n\n          if (!delta.isEmpty()) {\n            // schedule immediate capture, so that it's emitted for the sync purposes\n            this.store.scheduleMicroAction({\n              action,\n              change,\n              delta,\n            });\n\n            historyDelta = delta;\n          }\n\n          prevSnapshot = nextSnapshot;\n        } finally {\n          push(historyDelta);\n        }\n\n        if (containsVisibleChange) {\n          break;\n        }\n\n        historyDelta = pop();\n      }\n\n      return [nextElements, nextAppState];\n    } finally {\n      // trigger the history change event before returning completely\n      // also trigger it just once, no need doing so on each entry\n      this.onHistoryChangedEmitter.trigger(\n        new HistoryChangedEvent(this.isUndoStackEmpty, this.isRedoStackEmpty),\n      );\n    }\n  }\n\n  private static pop(stack: HistoryDelta[]): HistoryDelta | null {\n    if (!stack.length) {\n      return null;\n    }\n\n    const entry = stack.pop();\n\n    if (entry !== undefined) {\n      return entry;\n    }\n\n    return null;\n  }\n\n  private static push(stack: HistoryDelta[], entry: HistoryDelta) {\n    const inversedEntry = HistoryDelta.inverse(entry);\n    return stack.push(inversedEntry);\n  }\n}\n",
    "import { useEffect, useState } from \"react\";\n\nimport type { Emitter } from \"@excalidraw/common\";\n\nexport const useEmitter = <TEvent extends unknown>(\n  emitter: Emitter<[TEvent]>,\n  initialState: TEvent,\n) => {\n  const [event, setEvent] = useState<TEvent>(initialState);\n\n  useEffect(() => {\n    const unsubscribe = emitter.on((event) => {\n      setEvent(event);\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, [emitter]);\n\n  return event;\n};\n",
    "import { getFontString } from \"@excalidraw/common\";\n\nimport { newElementWith } from \"@excalidraw/element\";\nimport { measureText } from \"@excalidraw/element\";\n\nimport { isTextElement } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { getSelectedElements } from \"../scene\";\n\nimport { register } from \"./register\";\n\nimport type { AppClassProperties } from \"../types\";\n\nexport const actionTextAutoResize = register({\n  name: \"autoResize\",\n  label: \"labels.autoResize\",\n  icon: null,\n  trackEvent: { category: \"element\" },\n  predicate: (elements, appState, _: unknown, app: AppClassProperties) => {\n    const selectedElements = getSelectedElements(elements, appState);\n    return (\n      selectedElements.length === 1 &&\n      isTextElement(selectedElements[0]) &&\n      !selectedElements[0].autoResize\n    );\n  },\n  perform: (elements, appState, _, app) => {\n    const selectedElements = getSelectedElements(elements, appState);\n\n    return {\n      appState,\n      elements: elements.map((element) => {\n        if (element.id === selectedElements[0].id && isTextElement(element)) {\n          const metrics = measureText(\n            element.originalText,\n            getFontString(element),\n            element.lineHeight,\n          );\n\n          return newElementWith(element, {\n            autoResize: true,\n            width: metrics.width,\n            height: metrics.height,\n            text: element.originalText,\n          });\n        }\n        return element;\n      }),\n      captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n    };\n  },\n});\n",
    "import { CODES, KEYS } from \"@excalidraw/common\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport { eyeIcon } from \"../components/icons\";\n\nimport { register } from \"./register\";\n\nexport const actionToggleViewMode = register({\n  name: \"viewMode\",\n  label: \"labels.viewMode\",\n  icon: eyeIcon,\n  viewMode: true,\n  trackEvent: {\n    category: \"canvas\",\n    predicate: (appState) => !appState.viewModeEnabled,\n  },\n  perform(elements, appState) {\n    return {\n      appState: {\n        ...appState,\n        viewModeEnabled: !this.checked!(appState),\n      },\n      captureUpdate: CaptureUpdateAction.EVENTUALLY,\n    };\n  },\n  checked: (appState) => appState.viewModeEnabled,\n  predicate: (elements, appState, appProps) => {\n    return typeof appProps.viewModeEnabled === \"undefined\";\n  },\n  keyTest: (event) =>\n    !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.R,\n});\n",
    "import React from \"react\";\n\nimport { isPromiseLike } from \"@excalidraw/common\";\n\nimport type {\n  ExcalidrawElement,\n  OrderedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport { trackEvent } from \"../analytics\";\n\nimport type { AppClassProperties, AppState } from \"../types\";\nimport type {\n  Action,\n  UpdaterFn,\n  ActionName,\n  ActionResult,\n  PanelComponentProps,\n  ActionSource,\n} from \"./types\";\n\nconst trackAction = (\n  action: Action,\n  source: ActionSource,\n  appState: Readonly<AppState>,\n  elements: readonly ExcalidrawElement[],\n  app: AppClassProperties,\n  value: any,\n) => {\n  if (action.trackEvent) {\n    try {\n      if (typeof action.trackEvent === \"object\") {\n        const shouldTrack = action.trackEvent.predicate\n          ? action.trackEvent.predicate(appState, elements, value)\n          : true;\n        if (shouldTrack) {\n          trackEvent(\n            action.trackEvent.category,\n            action.trackEvent.action || action.name,\n            `${source} (${app.device.editor.isMobile ? \"mobile\" : \"desktop\"})`,\n          );\n        }\n      }\n    } catch (error) {\n      console.error(\"error while logging action:\", error);\n    }\n  }\n};\n\nexport class ActionManager {\n  actions = {} as Record<ActionName, Action>;\n\n  updater: (actionResult: ActionResult | Promise<ActionResult>) => void;\n\n  getAppState: () => Readonly<AppState>;\n  getElementsIncludingDeleted: () => readonly OrderedExcalidrawElement[];\n  app: AppClassProperties;\n\n  constructor(\n    updater: UpdaterFn,\n    getAppState: () => AppState,\n    getElementsIncludingDeleted: () => readonly OrderedExcalidrawElement[],\n    app: AppClassProperties,\n  ) {\n    this.updater = (actionResult) => {\n      if (isPromiseLike(actionResult)) {\n        actionResult.then((actionResult) => {\n          return updater(actionResult);\n        });\n      } else {\n        return updater(actionResult);\n      }\n    };\n    this.getAppState = getAppState;\n    this.getElementsIncludingDeleted = getElementsIncludingDeleted;\n    this.app = app;\n  }\n\n  registerAction(action: Action) {\n    this.actions[action.name] = action;\n  }\n\n  registerAll(actions: readonly Action[]) {\n    actions.forEach((action) => this.registerAction(action));\n  }\n\n  handleKeyDown(event: React.KeyboardEvent | KeyboardEvent) {\n    const canvasActions = this.app.props.UIOptions.canvasActions;\n    const data = Object.values(this.actions)\n      .sort((a, b) => (b.keyPriority || 0) - (a.keyPriority || 0))\n      .filter(\n        (action) =>\n          (action.name in canvasActions\n            ? canvasActions[action.name as keyof typeof canvasActions]\n            : true) &&\n          action.keyTest &&\n          action.keyTest(\n            event,\n            this.getAppState(),\n            this.getElementsIncludingDeleted(),\n            this.app,\n          ),\n      );\n\n    if (data.length !== 1) {\n      if (data.length > 1) {\n        console.warn(\"Canceling as multiple actions match this shortcut\", data);\n      }\n      return false;\n    }\n\n    const action = data[0];\n\n    if (this.getAppState().viewModeEnabled && action.viewMode !== true) {\n      return false;\n    }\n\n    const elements = this.getElementsIncludingDeleted();\n    const appState = this.getAppState();\n    const value = null;\n\n    trackAction(action, \"keyboard\", appState, elements, this.app, null);\n\n    event.preventDefault();\n    event.stopPropagation();\n    this.updater(data[0].perform(elements, appState, value, this.app));\n    return true;\n  }\n\n  executeAction<T extends Action>(\n    action: T,\n    source: ActionSource = \"api\",\n    value: Parameters<T[\"perform\"]>[2] = null,\n  ) {\n    const elements = this.getElementsIncludingDeleted();\n    const appState = this.getAppState();\n\n    trackAction(action, source, appState, elements, this.app, value);\n\n    this.updater(action.perform(elements, appState, value, this.app));\n  }\n\n  /**\n   * @param data additional data sent to the PanelComponent\n   */\n  renderAction = (name: ActionName, data?: PanelComponentProps[\"data\"]) => {\n    const canvasActions = this.app.props.UIOptions.canvasActions;\n\n    if (\n      this.actions[name] &&\n      \"PanelComponent\" in this.actions[name] &&\n      (name in canvasActions\n        ? canvasActions[name as keyof typeof canvasActions]\n        : true)\n    ) {\n      const action = this.actions[name];\n      const PanelComponent = action.PanelComponent!;\n      PanelComponent.displayName = \"PanelComponent\";\n      const elements = this.getElementsIncludingDeleted();\n      const appState = this.getAppState();\n      const updateData = (formState?: any) => {\n        trackAction(action, \"ui\", appState, elements, this.app, formState);\n\n        this.updater(\n          action.perform(\n            this.getElementsIncludingDeleted(),\n            this.getAppState(),\n            formState,\n            this.app,\n          ),\n        );\n      };\n\n      return (\n        <PanelComponent\n          elements={this.getElementsIncludingDeleted()}\n          appState={this.getAppState()}\n          updateData={updateData}\n          appProps={this.app.props}\n          app={this.app}\n          data={data}\n          renderAction={this.renderAction}\n        />\n      );\n    }\n\n    return null;\n  };\n\n  isActionEnabled = (action: Action) => {\n    const elements = this.getElementsIncludingDeleted();\n    const appState = this.getAppState();\n\n    return (\n      !action.predicate ||\n      action.predicate(elements, appState, this.app.props, this.app)\n    );\n  };\n}\n",
    "export type AnimationCallback = (timestamp: number) => void | boolean;\n\nexport type AnimationTarget = {\n  callback: AnimationCallback;\n  stopped: boolean;\n};\n\nexport class AnimationFrameHandler {\n  private targets = new WeakMap<object, AnimationTarget>();\n  private rafIds = new WeakMap<object, number>();\n\n  register(key: object, callback: AnimationCallback) {\n    this.targets.set(key, { callback, stopped: true });\n  }\n\n  start(key: object) {\n    const target = this.targets.get(key);\n\n    if (!target) {\n      return;\n    }\n\n    if (this.rafIds.has(key)) {\n      return;\n    }\n\n    this.targets.set(key, { ...target, stopped: false });\n    this.scheduleFrame(key);\n  }\n\n  stop(key: object) {\n    const target = this.targets.get(key);\n    if (target && !target.stopped) {\n      this.targets.set(key, { ...target, stopped: true });\n    }\n\n    this.cancelFrame(key);\n  }\n\n  private constructFrame(key: object): FrameRequestCallback {\n    return (timestamp: number) => {\n      const target = this.targets.get(key);\n\n      if (!target) {\n        return;\n      }\n\n      const shouldAbort = this.onFrame(target, timestamp);\n\n      if (!target.stopped && !shouldAbort) {\n        this.scheduleFrame(key);\n      } else {\n        this.cancelFrame(key);\n      }\n    };\n  }\n\n  private scheduleFrame(key: object) {\n    const rafId = requestAnimationFrame(this.constructFrame(key));\n\n    this.rafIds.set(key, rafId);\n  }\n\n  private cancelFrame(key: object) {\n    if (this.rafIds.has(key)) {\n      const rafId = this.rafIds.get(key)!;\n\n      cancelAnimationFrame(rafId);\n    }\n\n    this.rafIds.delete(key);\n  }\n\n  private onFrame(target: AnimationTarget, timestamp: number): boolean {\n    const shouldAbort = target.callback(timestamp);\n\n    return shouldAbort ?? false;\n  }\n}\n",
    "import type { PointerCoords } from \"./types\";\n\nexport const getCenter = (pointers: Map<number, PointerCoords>) => {\n  const allCoords = Array.from(pointers.values());\n  return {\n    x: sum(allCoords, (coords) => coords.x) / allCoords.length,\n    y: sum(allCoords, (coords) => coords.y) / allCoords.length,\n  };\n};\n\nexport const getDistance = ([a, b]: readonly PointerCoords[]) =>\n  Math.hypot(a.x - b.x, a.y - b.y);\n\nconst sum = <T>(array: readonly T[], mapper: (item: T) => number): number =>\n  array.reduce((acc, item) => acc + mapper(item), 0);\n",
    "import {\n  pointFrom,\n  pointRotateRads,\n  rangeInclusive,\n  rangeIntersection,\n  rangesOverlap,\n  type GlobalPoint,\n} from \"@excalidraw/math\";\n\nimport { TOOL_TYPE, KEYS } from \"@excalidraw/common\";\nimport {\n  getCommonBounds,\n  getDraggedElementsBounds,\n  getElementAbsoluteCoords,\n} from \"@excalidraw/element\";\nimport { isBoundToContainer, isFrameLikeElement } from \"@excalidraw/element\";\n\nimport { getMaximumGroups } from \"@excalidraw/element\";\n\nimport {\n  getSelectedElements,\n  getVisibleAndNonSelectedElements,\n} from \"@excalidraw/element\";\n\nimport type { InclusiveRange } from \"@excalidraw/math\";\n\nimport type { Bounds } from \"@excalidraw/element\";\nimport type { MaybeTransformHandleType } from \"@excalidraw/element\";\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport type {\n  AppClassProperties,\n  AppState,\n  KeyboardModifiersObject,\n} from \"./types\";\n\nconst SNAP_DISTANCE = 8;\n\n// do not comput more gaps per axis than this limit\n// TODO increase or remove once we optimize\nconst VISIBLE_GAPS_LIMIT_PER_AXIS = 99999;\n\n// snap distance with zoom value taken into consideration\nexport const getSnapDistance = (zoomValue: number) => {\n  return SNAP_DISTANCE / zoomValue;\n};\n\ntype Vector2D = {\n  x: number;\n  y: number;\n};\n\ntype PointPair = [GlobalPoint, GlobalPoint];\n\nexport type PointSnap = {\n  type: \"point\";\n  points: PointPair;\n  offset: number;\n};\n\nexport type Gap = {\n  //  start side ↓     length\n  // ┌───────────┐◄───────────────►\n  // │           │-----------------┌───────────┐\n  // │  start    │       ↑         │           │\n  // │  element  │    overlap      │  end      │\n  // │           │       ↓         │  element  │\n  // └───────────┘-----------------│           │\n  //                               └───────────┘\n  //                               ↑ end side\n  startBounds: Bounds;\n  endBounds: Bounds;\n  startSide: [GlobalPoint, GlobalPoint];\n  endSide: [GlobalPoint, GlobalPoint];\n  overlap: InclusiveRange;\n  length: number;\n};\n\nexport type GapSnap = {\n  type: \"gap\";\n  direction:\n    | \"center_horizontal\"\n    | \"center_vertical\"\n    | \"side_left\"\n    | \"side_right\"\n    | \"side_top\"\n    | \"side_bottom\";\n  gap: Gap;\n  offset: number;\n};\n\nexport type GapSnaps = GapSnap[];\n\nexport type Snap = GapSnap | PointSnap;\nexport type Snaps = Snap[];\n\nexport type PointSnapLine = {\n  type: \"points\";\n  points: GlobalPoint[];\n};\n\nexport type PointerSnapLine = {\n  type: \"pointer\";\n  points: PointPair;\n  direction: \"horizontal\" | \"vertical\";\n};\n\nexport type GapSnapLine = {\n  type: \"gap\";\n  direction: \"horizontal\" | \"vertical\";\n  points: PointPair;\n};\n\nexport type SnapLine = PointSnapLine | GapSnapLine | PointerSnapLine;\n\n// -----------------------------------------------------------------------------\n\nexport class SnapCache {\n  private static referenceSnapPoints: GlobalPoint[] | null = null;\n\n  private static visibleGaps: {\n    verticalGaps: Gap[];\n    horizontalGaps: Gap[];\n  } | null = null;\n\n  public static setReferenceSnapPoints = (snapPoints: GlobalPoint[] | null) => {\n    SnapCache.referenceSnapPoints = snapPoints;\n  };\n\n  public static getReferenceSnapPoints = () => {\n    return SnapCache.referenceSnapPoints;\n  };\n\n  public static setVisibleGaps = (\n    gaps: {\n      verticalGaps: Gap[];\n      horizontalGaps: Gap[];\n    } | null,\n  ) => {\n    SnapCache.visibleGaps = gaps;\n  };\n\n  public static getVisibleGaps = () => {\n    return SnapCache.visibleGaps;\n  };\n\n  public static destroy = () => {\n    SnapCache.referenceSnapPoints = null;\n    SnapCache.visibleGaps = null;\n  };\n}\n\n// -----------------------------------------------------------------------------\n\nexport const isGridModeEnabled = (app: AppClassProperties): boolean =>\n  app.props.gridModeEnabled ?? app.state.gridModeEnabled;\n\nexport const isSnappingEnabled = ({\n  event,\n  app,\n  selectedElements,\n}: {\n  app: AppClassProperties;\n  event: KeyboardModifiersObject;\n  selectedElements: NonDeletedExcalidrawElement[];\n}) => {\n  if (event) {\n    return (\n      app.state.activeTool.type !== \"lasso\" &&\n      ((app.state.objectsSnapModeEnabled && !event[KEYS.CTRL_OR_CMD]) ||\n        (!app.state.objectsSnapModeEnabled &&\n          event[KEYS.CTRL_OR_CMD] &&\n          !isGridModeEnabled(app)))\n    );\n  }\n\n  // do not suggest snaps for an arrow to give way to binding\n  if (selectedElements.length === 1 && selectedElements[0].type === \"arrow\") {\n    return false;\n  }\n  return app.state.objectsSnapModeEnabled;\n};\n\nexport const areRoughlyEqual = (a: number, b: number, precision = 0.01) => {\n  return Math.abs(a - b) <= precision;\n};\n\nexport const getElementsCorners = (\n  elements: ExcalidrawElement[],\n  elementsMap: ElementsMap,\n  {\n    omitCenter,\n    boundingBoxCorners,\n    dragOffset,\n  }: {\n    omitCenter?: boolean;\n    boundingBoxCorners?: boolean;\n    dragOffset?: Vector2D;\n  } = {\n    omitCenter: false,\n    boundingBoxCorners: false,\n  },\n): GlobalPoint[] => {\n  let result: GlobalPoint[] = [];\n\n  if (elements.length === 1) {\n    const element = elements[0];\n\n    let [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n      element,\n      elementsMap,\n    );\n\n    if (dragOffset) {\n      x1 += dragOffset.x;\n      x2 += dragOffset.x;\n      cx += dragOffset.x;\n\n      y1 += dragOffset.y;\n      y2 += dragOffset.y;\n      cy += dragOffset.y;\n    }\n\n    const halfWidth = (x2 - x1) / 2;\n    const halfHeight = (y2 - y1) / 2;\n\n    if (\n      (element.type === \"diamond\" || element.type === \"ellipse\") &&\n      !boundingBoxCorners\n    ) {\n      const leftMid = pointRotateRads<GlobalPoint>(\n        pointFrom(x1, y1 + halfHeight),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const topMid = pointRotateRads<GlobalPoint>(\n        pointFrom(x1 + halfWidth, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const rightMid = pointRotateRads<GlobalPoint>(\n        pointFrom(x2, y1 + halfHeight),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const bottomMid = pointRotateRads<GlobalPoint>(\n        pointFrom(x1 + halfWidth, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const center = pointFrom<GlobalPoint>(cx, cy);\n\n      result = omitCenter\n        ? [leftMid, topMid, rightMid, bottomMid]\n        : [leftMid, topMid, rightMid, bottomMid, center];\n    } else {\n      const topLeft = pointRotateRads<GlobalPoint>(\n        pointFrom(x1, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const topRight = pointRotateRads<GlobalPoint>(\n        pointFrom(x2, y1),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const bottomLeft = pointRotateRads<GlobalPoint>(\n        pointFrom(x1, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const bottomRight = pointRotateRads<GlobalPoint>(\n        pointFrom(x2, y2),\n        pointFrom(cx, cy),\n        element.angle,\n      );\n      const center = pointFrom<GlobalPoint>(cx, cy);\n\n      result = omitCenter\n        ? [topLeft, topRight, bottomLeft, bottomRight]\n        : [topLeft, topRight, bottomLeft, bottomRight, center];\n    }\n  } else if (elements.length > 1) {\n    const [minX, minY, maxX, maxY] = getDraggedElementsBounds(\n      elements,\n      dragOffset ?? { x: 0, y: 0 },\n    );\n    const width = maxX - minX;\n    const height = maxY - minY;\n\n    const topLeft = pointFrom<GlobalPoint>(minX, minY);\n    const topRight = pointFrom<GlobalPoint>(maxX, minY);\n    const bottomLeft = pointFrom<GlobalPoint>(minX, maxY);\n    const bottomRight = pointFrom<GlobalPoint>(maxX, maxY);\n    const center = pointFrom<GlobalPoint>(minX + width / 2, minY + height / 2);\n\n    result = omitCenter\n      ? [topLeft, topRight, bottomLeft, bottomRight]\n      : [topLeft, topRight, bottomLeft, bottomRight, center];\n  }\n\n  return result.map((p) => pointFrom(round(p[0]), round(p[1])));\n};\n\nconst getReferenceElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selectedElements: NonDeletedExcalidrawElement[],\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  const selectedFrames = selectedElements\n    .filter((element) => isFrameLikeElement(element))\n    .map((frame) => frame.id);\n\n  return getVisibleAndNonSelectedElements(\n    elements,\n    selectedElements,\n    appState,\n    elementsMap,\n  ).filter(\n    (element) => !(element.frameId && selectedFrames.includes(element.frameId)),\n  );\n};\n\nexport const getVisibleGaps = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selectedElements: ExcalidrawElement[],\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  const referenceElements: ExcalidrawElement[] = getReferenceElements(\n    elements,\n    selectedElements,\n    appState,\n    elementsMap,\n  );\n\n  const referenceBounds = getMaximumGroups(referenceElements, elementsMap)\n    .filter(\n      (elementsGroup) =>\n        !(elementsGroup.length === 1 && isBoundToContainer(elementsGroup[0])),\n    )\n    .map(\n      (group) =>\n        getCommonBounds(group).map((bound) =>\n          round(bound),\n        ) as unknown as Bounds,\n    );\n\n  const horizontallySorted = referenceBounds.sort((a, b) => a[0] - b[0]);\n\n  const horizontalGaps: Gap[] = [];\n\n  let c = 0;\n\n  horizontal: for (let i = 0; i < horizontallySorted.length; i++) {\n    const startBounds = horizontallySorted[i];\n\n    for (let j = i + 1; j < horizontallySorted.length; j++) {\n      if (++c > VISIBLE_GAPS_LIMIT_PER_AXIS) {\n        break horizontal;\n      }\n\n      const endBounds = horizontallySorted[j];\n\n      const [, startMinY, startMaxX, startMaxY] = startBounds;\n      const [endMinX, endMinY, , endMaxY] = endBounds;\n\n      if (\n        startMaxX < endMinX &&\n        rangesOverlap(\n          rangeInclusive(startMinY, startMaxY),\n          rangeInclusive(endMinY, endMaxY),\n        )\n      ) {\n        horizontalGaps.push({\n          startBounds,\n          endBounds,\n          startSide: [\n            pointFrom(startMaxX, startMinY),\n            pointFrom(startMaxX, startMaxY),\n          ],\n          endSide: [pointFrom(endMinX, endMinY), pointFrom(endMinX, endMaxY)],\n          length: endMinX - startMaxX,\n          overlap: rangeIntersection(\n            rangeInclusive(startMinY, startMaxY),\n            rangeInclusive(endMinY, endMaxY),\n          )!,\n        });\n      }\n    }\n  }\n\n  const verticallySorted = referenceBounds.sort((a, b) => a[1] - b[1]);\n\n  const verticalGaps: Gap[] = [];\n\n  c = 0;\n\n  vertical: for (let i = 0; i < verticallySorted.length; i++) {\n    const startBounds = verticallySorted[i];\n\n    for (let j = i + 1; j < verticallySorted.length; j++) {\n      if (++c > VISIBLE_GAPS_LIMIT_PER_AXIS) {\n        break vertical;\n      }\n      const endBounds = verticallySorted[j];\n\n      const [startMinX, , startMaxX, startMaxY] = startBounds;\n      const [endMinX, endMinY, endMaxX] = endBounds;\n\n      if (\n        startMaxY < endMinY &&\n        rangesOverlap(\n          rangeInclusive(startMinX, startMaxX),\n          rangeInclusive(endMinX, endMaxX),\n        )\n      ) {\n        verticalGaps.push({\n          startBounds,\n          endBounds,\n          startSide: [\n            pointFrom(startMinX, startMaxY),\n            pointFrom(startMaxX, startMaxY),\n          ],\n          endSide: [pointFrom(endMinX, endMinY), pointFrom(endMaxX, endMinY)],\n          length: endMinY - startMaxY,\n          overlap: rangeIntersection(\n            rangeInclusive(startMinX, startMaxX),\n            rangeInclusive(endMinX, endMaxX),\n          )!,\n        });\n      }\n    }\n  }\n\n  return {\n    horizontalGaps,\n    verticalGaps,\n  };\n};\n\nconst getGapSnaps = (\n  selectedElements: ExcalidrawElement[],\n  dragOffset: Vector2D,\n  app: AppClassProperties,\n  event: KeyboardModifiersObject,\n  nearestSnapsX: Snaps,\n  nearestSnapsY: Snaps,\n  minOffset: Vector2D,\n) => {\n  if (!isSnappingEnabled({ app, event, selectedElements })) {\n    return [];\n  }\n\n  if (selectedElements.length === 0) {\n    return [];\n  }\n\n  const visibleGaps = SnapCache.getVisibleGaps();\n\n  if (visibleGaps) {\n    const { horizontalGaps, verticalGaps } = visibleGaps;\n\n    const [minX, minY, maxX, maxY] = getDraggedElementsBounds(\n      selectedElements,\n      dragOffset,\n    ).map((bound) => round(bound));\n    const centerX = (minX + maxX) / 2;\n    const centerY = (minY + maxY) / 2;\n\n    for (const gap of horizontalGaps) {\n      if (!rangesOverlap(rangeInclusive(minY, maxY), gap.overlap)) {\n        continue;\n      }\n\n      // center gap\n      const gapMidX = gap.startSide[0][0] + gap.length / 2;\n      const centerOffset = round(gapMidX - centerX);\n      const gapIsLargerThanSelection = gap.length > maxX - minX;\n\n      if (gapIsLargerThanSelection && Math.abs(centerOffset) <= minOffset.x) {\n        if (Math.abs(centerOffset) < minOffset.x) {\n          nearestSnapsX.length = 0;\n        }\n        minOffset.x = Math.abs(centerOffset);\n\n        const snap: GapSnap = {\n          type: \"gap\",\n          direction: \"center_horizontal\",\n          gap,\n          offset: centerOffset,\n        };\n\n        nearestSnapsX.push(snap);\n        continue;\n      }\n\n      // side gap, from the right\n      const [, , endMaxX] = gap.endBounds;\n      const distanceToEndElementX = minX - endMaxX;\n      const sideOffsetRight = round(gap.length - distanceToEndElementX);\n\n      if (Math.abs(sideOffsetRight) <= minOffset.x) {\n        if (Math.abs(sideOffsetRight) < minOffset.x) {\n          nearestSnapsX.length = 0;\n        }\n        minOffset.x = Math.abs(sideOffsetRight);\n\n        const snap: GapSnap = {\n          type: \"gap\",\n          direction: \"side_right\",\n          gap,\n          offset: sideOffsetRight,\n        };\n        nearestSnapsX.push(snap);\n        continue;\n      }\n\n      // side gap, from the left\n      const [startMinX, , ,] = gap.startBounds;\n      const distanceToStartElementX = startMinX - maxX;\n      const sideOffsetLeft = round(distanceToStartElementX - gap.length);\n\n      if (Math.abs(sideOffsetLeft) <= minOffset.x) {\n        if (Math.abs(sideOffsetLeft) < minOffset.x) {\n          nearestSnapsX.length = 0;\n        }\n        minOffset.x = Math.abs(sideOffsetLeft);\n\n        const snap: GapSnap = {\n          type: \"gap\",\n          direction: \"side_left\",\n          gap,\n          offset: sideOffsetLeft,\n        };\n        nearestSnapsX.push(snap);\n        continue;\n      }\n    }\n    for (const gap of verticalGaps) {\n      if (!rangesOverlap(rangeInclusive(minX, maxX), gap.overlap)) {\n        continue;\n      }\n\n      // center gap\n      const gapMidY = gap.startSide[0][1] + gap.length / 2;\n      const centerOffset = round(gapMidY - centerY);\n      const gapIsLargerThanSelection = gap.length > maxY - minY;\n\n      if (gapIsLargerThanSelection && Math.abs(centerOffset) <= minOffset.y) {\n        if (Math.abs(centerOffset) < minOffset.y) {\n          nearestSnapsY.length = 0;\n        }\n        minOffset.y = Math.abs(centerOffset);\n\n        const snap: GapSnap = {\n          type: \"gap\",\n          direction: \"center_vertical\",\n          gap,\n          offset: centerOffset,\n        };\n\n        nearestSnapsY.push(snap);\n        continue;\n      }\n\n      // side gap, from the top\n      const [, startMinY, ,] = gap.startBounds;\n      const distanceToStartElementY = startMinY - maxY;\n      const sideOffsetTop = round(distanceToStartElementY - gap.length);\n\n      if (Math.abs(sideOffsetTop) <= minOffset.y) {\n        if (Math.abs(sideOffsetTop) < minOffset.y) {\n          nearestSnapsY.length = 0;\n        }\n        minOffset.y = Math.abs(sideOffsetTop);\n\n        const snap: GapSnap = {\n          type: \"gap\",\n          direction: \"side_top\",\n          gap,\n          offset: sideOffsetTop,\n        };\n        nearestSnapsY.push(snap);\n        continue;\n      }\n\n      // side gap, from the bottom\n      const [, , , endMaxY] = gap.endBounds;\n      const distanceToEndElementY = round(minY - endMaxY);\n      const sideOffsetBottom = gap.length - distanceToEndElementY;\n\n      if (Math.abs(sideOffsetBottom) <= minOffset.y) {\n        if (Math.abs(sideOffsetBottom) < minOffset.y) {\n          nearestSnapsY.length = 0;\n        }\n        minOffset.y = Math.abs(sideOffsetBottom);\n\n        const snap: GapSnap = {\n          type: \"gap\",\n          direction: \"side_bottom\",\n          gap,\n          offset: sideOffsetBottom,\n        };\n        nearestSnapsY.push(snap);\n        continue;\n      }\n    }\n  }\n};\n\nexport const getReferenceSnapPoints = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selectedElements: ExcalidrawElement[],\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  const referenceElements = getReferenceElements(\n    elements,\n    selectedElements,\n    appState,\n    elementsMap,\n  );\n  return getMaximumGroups(referenceElements, elementsMap)\n    .filter(\n      (elementsGroup) =>\n        !(elementsGroup.length === 1 && isBoundToContainer(elementsGroup[0])),\n    )\n    .flatMap((elementGroup) => getElementsCorners(elementGroup, elementsMap));\n};\n\nconst getPointSnaps = (\n  selectedElements: ExcalidrawElement[],\n  selectionSnapPoints: GlobalPoint[],\n  app: AppClassProperties,\n  event: KeyboardModifiersObject,\n  nearestSnapsX: Snaps,\n  nearestSnapsY: Snaps,\n  minOffset: Vector2D,\n) => {\n  if (\n    !isSnappingEnabled({ app, event, selectedElements }) ||\n    (selectedElements.length === 0 && selectionSnapPoints.length === 0)\n  ) {\n    return [];\n  }\n\n  const referenceSnapPoints = SnapCache.getReferenceSnapPoints();\n\n  if (referenceSnapPoints) {\n    for (const thisSnapPoint of selectionSnapPoints) {\n      for (const otherSnapPoint of referenceSnapPoints) {\n        const offsetX = otherSnapPoint[0] - thisSnapPoint[0];\n        const offsetY = otherSnapPoint[1] - thisSnapPoint[1];\n\n        if (Math.abs(offsetX) <= minOffset.x) {\n          if (Math.abs(offsetX) < minOffset.x) {\n            nearestSnapsX.length = 0;\n          }\n\n          nearestSnapsX.push({\n            type: \"point\",\n            points: [thisSnapPoint, otherSnapPoint],\n            offset: offsetX,\n          });\n\n          minOffset.x = Math.abs(offsetX);\n        }\n\n        if (Math.abs(offsetY) <= minOffset.y) {\n          if (Math.abs(offsetY) < minOffset.y) {\n            nearestSnapsY.length = 0;\n          }\n\n          nearestSnapsY.push({\n            type: \"point\",\n            points: [thisSnapPoint, otherSnapPoint],\n            offset: offsetY,\n          });\n\n          minOffset.y = Math.abs(offsetY);\n        }\n      }\n    }\n  }\n};\n\nexport const snapDraggedElements = (\n  elements: ExcalidrawElement[],\n  dragOffset: Vector2D,\n  app: AppClassProperties,\n  event: KeyboardModifiersObject,\n  elementsMap: ElementsMap,\n) => {\n  const appState = app.state;\n  const selectedElements = getSelectedElements(elements, appState);\n  if (\n    !isSnappingEnabled({ app, event, selectedElements }) ||\n    selectedElements.length === 0\n  ) {\n    return {\n      snapOffset: {\n        x: 0,\n        y: 0,\n      },\n      snapLines: [],\n    };\n  }\n  dragOffset.x = round(dragOffset.x);\n  dragOffset.y = round(dragOffset.y);\n  const nearestSnapsX: Snaps = [];\n  const nearestSnapsY: Snaps = [];\n  const snapDistance = getSnapDistance(appState.zoom.value);\n  const minOffset = {\n    x: snapDistance,\n    y: snapDistance,\n  };\n\n  const selectionPoints = getElementsCorners(selectedElements, elementsMap, {\n    dragOffset,\n  });\n\n  // get the nearest horizontal and vertical point and gap snaps\n  getPointSnaps(\n    selectedElements,\n    selectionPoints,\n    app,\n    event,\n    nearestSnapsX,\n    nearestSnapsY,\n    minOffset,\n  );\n\n  getGapSnaps(\n    selectedElements,\n    dragOffset,\n    app,\n    event,\n    nearestSnapsX,\n    nearestSnapsY,\n    minOffset,\n  );\n\n  // using the nearest snaps to figure out how\n  // much the elements need to be offset to be snapped\n  // to some reference elements\n  const snapOffset = {\n    x: nearestSnapsX[0]?.offset ?? 0,\n    y: nearestSnapsY[0]?.offset ?? 0,\n  };\n\n  // once the elements are snapped\n  // and moved to the snapped position\n  // we want to use the element's snapped position\n  // to update nearest snaps so that we can create\n  // point and gap snap lines correctly without any shifting\n\n  minOffset.x = 0;\n  minOffset.y = 0;\n  nearestSnapsX.length = 0;\n  nearestSnapsY.length = 0;\n  const newDragOffset = {\n    x: round(dragOffset.x + snapOffset.x),\n    y: round(dragOffset.y + snapOffset.y),\n  };\n\n  getPointSnaps(\n    selectedElements,\n    getElementsCorners(selectedElements, elementsMap, {\n      dragOffset: newDragOffset,\n    }),\n    app,\n    event,\n    nearestSnapsX,\n    nearestSnapsY,\n    minOffset,\n  );\n\n  getGapSnaps(\n    selectedElements,\n    newDragOffset,\n    app,\n    event,\n    nearestSnapsX,\n    nearestSnapsY,\n    minOffset,\n  );\n\n  const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);\n\n  const gapSnapLines = createGapSnapLines(\n    selectedElements,\n    newDragOffset,\n    [...nearestSnapsX, ...nearestSnapsY].filter(\n      (snap) => snap.type === \"gap\",\n    ) as GapSnap[],\n  );\n\n  return {\n    snapOffset,\n    snapLines: [...pointSnapLines, ...gapSnapLines],\n  };\n};\n\nconst round = (x: number) => {\n  const decimalPlaces = 6;\n  return Math.round(x * 10 ** decimalPlaces) / 10 ** decimalPlaces;\n};\n\nconst dedupePoints = (points: GlobalPoint[]): GlobalPoint[] => {\n  const map = new Map<string, GlobalPoint>();\n\n  for (const point of points) {\n    const key = point.join(\",\");\n\n    if (!map.has(key)) {\n      map.set(key, point);\n    }\n  }\n\n  return Array.from(map.values());\n};\n\nconst createPointSnapLines = (\n  nearestSnapsX: Snaps,\n  nearestSnapsY: Snaps,\n): PointSnapLine[] => {\n  const snapsX = {} as { [key: string]: GlobalPoint[] };\n  const snapsY = {} as { [key: string]: GlobalPoint[] };\n\n  if (nearestSnapsX.length > 0) {\n    for (const snap of nearestSnapsX) {\n      if (snap.type === \"point\") {\n        // key = thisPoint.x\n        const key = round(snap.points[0][0]);\n        if (!snapsX[key]) {\n          snapsX[key] = [];\n        }\n        snapsX[key].push(\n          ...snap.points.map((p) =>\n            pointFrom<GlobalPoint>(round(p[0]), round(p[1])),\n          ),\n        );\n      }\n    }\n  }\n\n  if (nearestSnapsY.length > 0) {\n    for (const snap of nearestSnapsY) {\n      if (snap.type === \"point\") {\n        // key = thisPoint.y\n        const key = round(snap.points[0][1]);\n        if (!snapsY[key]) {\n          snapsY[key] = [];\n        }\n        snapsY[key].push(\n          ...snap.points.map((p) =>\n            pointFrom<GlobalPoint>(round(p[0]), round(p[1])),\n          ),\n        );\n      }\n    }\n  }\n\n  return Object.entries(snapsX)\n    .map(([key, points]) => {\n      return {\n        type: \"points\",\n        points: dedupePoints(\n          points\n            .map((p) => {\n              return pointFrom<GlobalPoint>(Number(key), p[1]);\n            })\n            .sort((a, b) => a[1] - b[1]),\n        ),\n      } as PointSnapLine;\n    })\n    .concat(\n      Object.entries(snapsY).map(([key, points]) => {\n        return {\n          type: \"points\",\n          points: dedupePoints(\n            points\n              .map((p) => {\n                return pointFrom<GlobalPoint>(p[0], Number(key));\n              })\n              .sort((a, b) => a[0] - b[0]),\n          ),\n        } as PointSnapLine;\n      }),\n    );\n};\n\nconst dedupeGapSnapLines = (gapSnapLines: GapSnapLine[]) => {\n  const map = new Map<string, GapSnapLine>();\n\n  for (const gapSnapLine of gapSnapLines) {\n    const key = gapSnapLine.points\n      .flat()\n      .map((point) => [round(point)])\n      .join(\",\");\n\n    if (!map.has(key)) {\n      map.set(key, gapSnapLine);\n    }\n  }\n\n  return Array.from(map.values());\n};\n\nconst createGapSnapLines = (\n  selectedElements: ExcalidrawElement[],\n  dragOffset: Vector2D,\n  gapSnaps: GapSnap[],\n): GapSnapLine[] => {\n  const [minX, minY, maxX, maxY] = getDraggedElementsBounds(\n    selectedElements,\n    dragOffset,\n  );\n\n  const gapSnapLines: GapSnapLine[] = [];\n\n  for (const gapSnap of gapSnaps) {\n    const [startMinX, startMinY, startMaxX, startMaxY] =\n      gapSnap.gap.startBounds;\n    const [endMinX, endMinY, endMaxX, endMaxY] = gapSnap.gap.endBounds;\n\n    const verticalIntersection = rangeIntersection(\n      rangeInclusive(minY, maxY),\n      gapSnap.gap.overlap,\n    );\n\n    const horizontalGapIntersection = rangeIntersection(\n      rangeInclusive(minX, maxX),\n      gapSnap.gap.overlap,\n    );\n\n    switch (gapSnap.direction) {\n      case \"center_horizontal\": {\n        if (verticalIntersection) {\n          const gapLineY =\n            (verticalIntersection[0] + verticalIntersection[1]) / 2;\n\n          gapSnapLines.push(\n            {\n              type: \"gap\",\n              direction: \"horizontal\",\n              points: [\n                pointFrom(gapSnap.gap.startSide[0][0], gapLineY),\n                pointFrom(minX, gapLineY),\n              ],\n            },\n            {\n              type: \"gap\",\n              direction: \"horizontal\",\n              points: [\n                pointFrom(maxX, gapLineY),\n                pointFrom(gapSnap.gap.endSide[0][0], gapLineY),\n              ],\n            },\n          );\n        }\n        break;\n      }\n      case \"center_vertical\": {\n        if (horizontalGapIntersection) {\n          const gapLineX =\n            (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;\n\n          gapSnapLines.push(\n            {\n              type: \"gap\",\n              direction: \"vertical\",\n              points: [\n                pointFrom(gapLineX, gapSnap.gap.startSide[0][1]),\n                pointFrom(gapLineX, minY),\n              ],\n            },\n            {\n              type: \"gap\",\n              direction: \"vertical\",\n              points: [\n                pointFrom(gapLineX, maxY),\n                pointFrom(gapLineX, gapSnap.gap.endSide[0][1]),\n              ],\n            },\n          );\n        }\n        break;\n      }\n      case \"side_right\": {\n        if (verticalIntersection) {\n          const gapLineY =\n            (verticalIntersection[0] + verticalIntersection[1]) / 2;\n\n          gapSnapLines.push(\n            {\n              type: \"gap\",\n              direction: \"horizontal\",\n              points: [\n                pointFrom(startMaxX, gapLineY),\n                pointFrom(endMinX, gapLineY),\n              ],\n            },\n            {\n              type: \"gap\",\n              direction: \"horizontal\",\n              points: [pointFrom(endMaxX, gapLineY), pointFrom(minX, gapLineY)],\n            },\n          );\n        }\n        break;\n      }\n      case \"side_left\": {\n        if (verticalIntersection) {\n          const gapLineY =\n            (verticalIntersection[0] + verticalIntersection[1]) / 2;\n\n          gapSnapLines.push(\n            {\n              type: \"gap\",\n              direction: \"horizontal\",\n              points: [\n                pointFrom(maxX, gapLineY),\n                pointFrom(startMinX, gapLineY),\n              ],\n            },\n            {\n              type: \"gap\",\n              direction: \"horizontal\",\n              points: [\n                pointFrom(startMaxX, gapLineY),\n                pointFrom(endMinX, gapLineY),\n              ],\n            },\n          );\n        }\n        break;\n      }\n      case \"side_top\": {\n        if (horizontalGapIntersection) {\n          const gapLineX =\n            (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;\n\n          gapSnapLines.push(\n            {\n              type: \"gap\",\n              direction: \"vertical\",\n              points: [\n                pointFrom(gapLineX, maxY),\n                pointFrom(gapLineX, startMinY),\n              ],\n            },\n            {\n              type: \"gap\",\n              direction: \"vertical\",\n              points: [\n                pointFrom(gapLineX, startMaxY),\n                pointFrom(gapLineX, endMinY),\n              ],\n            },\n          );\n        }\n        break;\n      }\n      case \"side_bottom\": {\n        if (horizontalGapIntersection) {\n          const gapLineX =\n            (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;\n\n          gapSnapLines.push(\n            {\n              type: \"gap\",\n              direction: \"vertical\",\n              points: [\n                pointFrom(gapLineX, startMaxY),\n                pointFrom(gapLineX, endMinY),\n              ],\n            },\n            {\n              type: \"gap\",\n              direction: \"vertical\",\n              points: [pointFrom(gapLineX, endMaxY), pointFrom(gapLineX, minY)],\n            },\n          );\n        }\n        break;\n      }\n    }\n  }\n\n  return dedupeGapSnapLines(\n    gapSnapLines.map((gapSnapLine) => {\n      return {\n        ...gapSnapLine,\n        points: gapSnapLine.points.map((p) =>\n          pointFrom(round(p[0]), round(p[1])),\n        ) as PointPair,\n      };\n    }),\n  );\n};\n\nexport const snapResizingElements = (\n  // use the latest elements to create snap lines\n  selectedElements: ExcalidrawElement[],\n  // while using the original elements to appy dragOffset to calculate snaps\n  selectedOriginalElements: ExcalidrawElement[],\n  app: AppClassProperties,\n  event: KeyboardModifiersObject,\n  dragOffset: Vector2D,\n  transformHandle: MaybeTransformHandleType,\n) => {\n  if (\n    !isSnappingEnabled({ event, selectedElements, app }) ||\n    selectedElements.length === 0 ||\n    (selectedElements.length === 1 &&\n      !areRoughlyEqual(selectedElements[0].angle, 0))\n  ) {\n    return {\n      snapOffset: { x: 0, y: 0 },\n      snapLines: [],\n    };\n  }\n\n  let [minX, minY, maxX, maxY] = getCommonBounds(selectedOriginalElements);\n\n  if (transformHandle) {\n    if (transformHandle.includes(\"e\")) {\n      maxX += dragOffset.x;\n    } else if (transformHandle.includes(\"w\")) {\n      minX += dragOffset.x;\n    }\n\n    if (transformHandle.includes(\"n\")) {\n      minY += dragOffset.y;\n    } else if (transformHandle.includes(\"s\")) {\n      maxY += dragOffset.y;\n    }\n  }\n\n  const selectionSnapPoints: GlobalPoint[] = [];\n\n  if (transformHandle) {\n    switch (transformHandle) {\n      case \"e\": {\n        selectionSnapPoints.push(pointFrom(maxX, minY), pointFrom(maxX, maxY));\n        break;\n      }\n      case \"w\": {\n        selectionSnapPoints.push(pointFrom(minX, minY), pointFrom(minX, maxY));\n        break;\n      }\n      case \"n\": {\n        selectionSnapPoints.push(pointFrom(minX, minY), pointFrom(maxX, minY));\n        break;\n      }\n      case \"s\": {\n        selectionSnapPoints.push(pointFrom(minX, maxY), pointFrom(maxX, maxY));\n        break;\n      }\n      case \"ne\": {\n        selectionSnapPoints.push(pointFrom(maxX, minY));\n        break;\n      }\n      case \"nw\": {\n        selectionSnapPoints.push(pointFrom(minX, minY));\n        break;\n      }\n      case \"se\": {\n        selectionSnapPoints.push(pointFrom(maxX, maxY));\n        break;\n      }\n      case \"sw\": {\n        selectionSnapPoints.push(pointFrom(minX, maxY));\n        break;\n      }\n    }\n  }\n\n  const snapDistance = getSnapDistance(app.state.zoom.value);\n\n  const minOffset = {\n    x: snapDistance,\n    y: snapDistance,\n  };\n\n  const nearestSnapsX: Snaps = [];\n  const nearestSnapsY: Snaps = [];\n\n  getPointSnaps(\n    selectedOriginalElements,\n    selectionSnapPoints,\n    app,\n    event,\n    nearestSnapsX,\n    nearestSnapsY,\n    minOffset,\n  );\n\n  const snapOffset = {\n    x: nearestSnapsX[0]?.offset ?? 0,\n    y: nearestSnapsY[0]?.offset ?? 0,\n  };\n\n  // again, once snap offset is calculated\n  // reset to recompute for creating snap lines to be rendered\n  minOffset.x = 0;\n  minOffset.y = 0;\n  nearestSnapsX.length = 0;\n  nearestSnapsY.length = 0;\n\n  const [x1, y1, x2, y2] = getCommonBounds(selectedElements).map((bound) =>\n    round(bound),\n  );\n\n  const corners: GlobalPoint[] = [\n    pointFrom(x1, y1),\n    pointFrom(x1, y2),\n    pointFrom(x2, y1),\n    pointFrom(x2, y2),\n  ];\n\n  getPointSnaps(\n    selectedElements,\n    corners,\n    app,\n    event,\n    nearestSnapsX,\n    nearestSnapsY,\n    minOffset,\n  );\n\n  const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);\n\n  return {\n    snapOffset,\n    snapLines: pointSnapLines,\n  };\n};\n\nexport const snapNewElement = (\n  newElement: ExcalidrawElement,\n  app: AppClassProperties,\n  event: KeyboardModifiersObject,\n  origin: Vector2D,\n  dragOffset: Vector2D,\n  elementsMap: ElementsMap,\n) => {\n  if (!isSnappingEnabled({ event, selectedElements: [newElement], app })) {\n    return {\n      snapOffset: { x: 0, y: 0 },\n      snapLines: [],\n    };\n  }\n\n  const selectionSnapPoints: GlobalPoint[] = [\n    pointFrom(origin.x + dragOffset.x, origin.y + dragOffset.y),\n  ];\n\n  const snapDistance = getSnapDistance(app.state.zoom.value);\n\n  const minOffset = {\n    x: snapDistance,\n    y: snapDistance,\n  };\n\n  const nearestSnapsX: Snaps = [];\n  const nearestSnapsY: Snaps = [];\n\n  getPointSnaps(\n    [newElement],\n    selectionSnapPoints,\n    app,\n    event,\n    nearestSnapsX,\n    nearestSnapsY,\n    minOffset,\n  );\n\n  const snapOffset = {\n    x: nearestSnapsX[0]?.offset ?? 0,\n    y: nearestSnapsY[0]?.offset ?? 0,\n  };\n\n  minOffset.x = 0;\n  minOffset.y = 0;\n  nearestSnapsX.length = 0;\n  nearestSnapsY.length = 0;\n\n  const corners = getElementsCorners([newElement], elementsMap, {\n    boundingBoxCorners: true,\n    omitCenter: true,\n  });\n\n  getPointSnaps(\n    [newElement],\n    corners,\n    app,\n    event,\n    nearestSnapsX,\n    nearestSnapsY,\n    minOffset,\n  );\n\n  const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);\n\n  return {\n    snapOffset,\n    snapLines: pointSnapLines,\n  };\n};\n\nexport const getSnapLinesAtPointer = (\n  elements: readonly ExcalidrawElement[],\n  app: AppClassProperties,\n  pointer: Vector2D,\n  event: KeyboardModifiersObject,\n  elementsMap: ElementsMap,\n) => {\n  if (!isSnappingEnabled({ event, selectedElements: [], app })) {\n    return {\n      originOffset: { x: 0, y: 0 },\n      snapLines: [],\n    };\n  }\n\n  const referenceElements = getVisibleAndNonSelectedElements(\n    elements,\n    [],\n    app.state,\n    elementsMap,\n  );\n\n  const snapDistance = getSnapDistance(app.state.zoom.value);\n\n  const minOffset = {\n    x: snapDistance,\n    y: snapDistance,\n  };\n\n  const horizontalSnapLines: PointerSnapLine[] = [];\n  const verticalSnapLines: PointerSnapLine[] = [];\n\n  for (const referenceElement of referenceElements) {\n    const corners = getElementsCorners([referenceElement], elementsMap);\n\n    for (const corner of corners) {\n      const offsetX = corner[0] - pointer.x;\n\n      if (Math.abs(offsetX) <= Math.abs(minOffset.x)) {\n        if (Math.abs(offsetX) < Math.abs(minOffset.x)) {\n          verticalSnapLines.length = 0;\n        }\n\n        verticalSnapLines.push({\n          type: \"pointer\",\n          points: [corner, pointFrom(corner[0], pointer.y)],\n          direction: \"vertical\",\n        });\n\n        minOffset.x = offsetX;\n      }\n\n      const offsetY = corner[1] - pointer.y;\n\n      if (Math.abs(offsetY) <= Math.abs(minOffset.y)) {\n        if (Math.abs(offsetY) < Math.abs(minOffset.y)) {\n          horizontalSnapLines.length = 0;\n        }\n\n        horizontalSnapLines.push({\n          type: \"pointer\",\n          points: [corner, pointFrom(pointer.x, corner[1])],\n          direction: \"horizontal\",\n        });\n\n        minOffset.y = offsetY;\n      }\n    }\n  }\n\n  return {\n    originOffset: {\n      x:\n        verticalSnapLines.length > 0\n          ? verticalSnapLines[0].points[0][0] - pointer.x\n          : 0,\n      y:\n        horizontalSnapLines.length > 0\n          ? horizontalSnapLines[0].points[0][1] - pointer.y\n          : 0,\n    },\n    snapLines: [...verticalSnapLines, ...horizontalSnapLines],\n  };\n};\n\nexport const isActiveToolNonLinearSnappable = (\n  activeToolType: AppState[\"activeTool\"][\"type\"],\n) => {\n  return (\n    activeToolType === TOOL_TYPE.rectangle ||\n    activeToolType === TOOL_TYPE.ellipse ||\n    activeToolType === TOOL_TYPE.diamond ||\n    activeToolType === TOOL_TYPE.frame ||\n    activeToolType === TOOL_TYPE.magicframe ||\n    activeToolType === TOOL_TYPE.image ||\n    activeToolType === TOOL_TYPE.text\n  );\n};\n",
    "import { pointFrom, type LocalPoint } from \"@excalidraw/math\";\n\nimport {\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_SIZE,\n  TEXT_ALIGN,\n  VERTICAL_ALIGN,\n  getSizeFromPoints,\n  randomId,\n  arrayToMap,\n  assertNever,\n  cloneJSON,\n  getFontString,\n  isDevEnv,\n  toBrandedType,\n  getLineHeight,\n} from \"@excalidraw/common\";\n\nimport { bindLinearElement } from \"@excalidraw/element\";\nimport {\n  newArrowElement,\n  newElement,\n  newFrameElement,\n  newImageElement,\n  newLinearElement,\n  newMagicFrameElement,\n  newTextElement,\n} from \"@excalidraw/element\";\nimport { measureText, normalizeText } from \"@excalidraw/element\";\nimport { isArrowElement } from \"@excalidraw/element\";\n\nimport { syncInvalidIndices } from \"@excalidraw/element\";\n\nimport { redrawTextBoundingBox } from \"@excalidraw/element\";\n\nimport { LinearElementEditor } from \"@excalidraw/element\";\n\nimport { getCommonBounds } from \"@excalidraw/element\";\n\nimport { Scene } from \"@excalidraw/element\";\n\nimport type { ElementConstructorOpts } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawArrowElement,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawFrameElement,\n  ExcalidrawFreeDrawElement,\n  ExcalidrawGenericElement,\n  ExcalidrawIframeLikeElement,\n  ExcalidrawImageElement,\n  ExcalidrawLinearElement,\n  ExcalidrawMagicFrameElement,\n  ExcalidrawSelectionElement,\n  ExcalidrawTextElement,\n  FileId,\n  FontFamilyValues,\n  NonDeletedSceneElementsMap,\n  TextAlign,\n  VerticalAlign,\n} from \"@excalidraw/element/types\";\n\nimport type { MarkOptional } from \"@excalidraw/common/utility-types\";\n\nexport type ValidLinearElement = {\n  type: \"arrow\" | \"line\";\n  x: number;\n  y: number;\n  label?: {\n    text: string;\n    fontSize?: number;\n    fontFamily?: FontFamilyValues;\n    textAlign?: TextAlign;\n    verticalAlign?: VerticalAlign;\n  } & MarkOptional<ElementConstructorOpts, \"x\" | \"y\">;\n  end?:\n    | (\n        | (\n            | {\n                type: Exclude<\n                  ExcalidrawBindableElement[\"type\"],\n                  | \"image\"\n                  | \"text\"\n                  | \"frame\"\n                  | \"magicframe\"\n                  | \"embeddable\"\n                  | \"iframe\"\n                >;\n                id?: ExcalidrawGenericElement[\"id\"];\n              }\n            | {\n                id: ExcalidrawGenericElement[\"id\"];\n                type?: Exclude<\n                  ExcalidrawBindableElement[\"type\"],\n                  | \"image\"\n                  | \"text\"\n                  | \"frame\"\n                  | \"magicframe\"\n                  | \"embeddable\"\n                  | \"iframe\"\n                >;\n              }\n          )\n        | ((\n            | {\n                type: \"text\";\n                text: string;\n              }\n            | {\n                type?: \"text\";\n                id: ExcalidrawTextElement[\"id\"];\n                text: string;\n              }\n          ) &\n            Partial<ExcalidrawTextElement>)\n      ) &\n        MarkOptional<ElementConstructorOpts, \"x\" | \"y\">;\n  start?:\n    | (\n        | (\n            | {\n                type: Exclude<\n                  ExcalidrawBindableElement[\"type\"],\n                  | \"image\"\n                  | \"text\"\n                  | \"frame\"\n                  | \"magicframe\"\n                  | \"embeddable\"\n                  | \"iframe\"\n                >;\n                id?: ExcalidrawGenericElement[\"id\"];\n              }\n            | {\n                id: ExcalidrawGenericElement[\"id\"];\n                type?: Exclude<\n                  ExcalidrawBindableElement[\"type\"],\n                  | \"image\"\n                  | \"text\"\n                  | \"frame\"\n                  | \"magicframe\"\n                  | \"embeddable\"\n                  | \"iframe\"\n                >;\n              }\n          )\n        | ((\n            | {\n                type: \"text\";\n                text: string;\n              }\n            | {\n                type?: \"text\";\n                id: ExcalidrawTextElement[\"id\"];\n                text: string;\n              }\n          ) &\n            Partial<ExcalidrawTextElement>)\n      ) &\n        MarkOptional<ElementConstructorOpts, \"x\" | \"y\">;\n} & Partial<ExcalidrawLinearElement>;\n\nexport type ValidContainer =\n  | {\n      type: Exclude<ExcalidrawGenericElement[\"type\"], \"selection\">;\n      id?: ExcalidrawGenericElement[\"id\"];\n      label?: {\n        text: string;\n        fontSize?: number;\n        fontFamily?: FontFamilyValues;\n        textAlign?: TextAlign;\n        verticalAlign?: VerticalAlign;\n      } & MarkOptional<ElementConstructorOpts, \"x\" | \"y\">;\n    } & ElementConstructorOpts;\n\nexport type ExcalidrawElementSkeleton =\n  | Extract<\n      Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n      ExcalidrawIframeLikeElement | ExcalidrawFreeDrawElement\n    >\n  | ({\n      type: Extract<ExcalidrawLinearElement[\"type\"], \"line\">;\n      x: number;\n      y: number;\n    } & Partial<ExcalidrawLinearElement>)\n  | ValidContainer\n  | ValidLinearElement\n  | ({\n      type: \"text\";\n      text: string;\n      x: number;\n      y: number;\n      id?: ExcalidrawTextElement[\"id\"];\n    } & Partial<ExcalidrawTextElement>)\n  | ({\n      type: Extract<ExcalidrawImageElement[\"type\"], \"image\">;\n      x: number;\n      y: number;\n      fileId: FileId;\n    } & Partial<ExcalidrawImageElement>)\n  | ({\n      type: \"frame\";\n      children: readonly ExcalidrawElement[\"id\"][];\n      name?: string;\n    } & Partial<ExcalidrawFrameElement>)\n  | ({\n      type: \"magicframe\";\n      children: readonly ExcalidrawElement[\"id\"][];\n      name?: string;\n    } & Partial<ExcalidrawMagicFrameElement>);\n\nconst DEFAULT_LINEAR_ELEMENT_PROPS = {\n  width: 100,\n  height: 0,\n};\n\nconst DEFAULT_DIMENSION = 100;\n\nconst bindTextToContainer = (\n  container: ExcalidrawElement,\n  textProps: { text: string } & MarkOptional<ElementConstructorOpts, \"x\" | \"y\">,\n  scene: Scene,\n) => {\n  const textElement: ExcalidrawTextElement = newTextElement({\n    x: 0,\n    y: 0,\n    textAlign: TEXT_ALIGN.CENTER,\n    verticalAlign: VERTICAL_ALIGN.MIDDLE,\n    ...textProps,\n    containerId: container.id,\n    strokeColor: textProps.strokeColor || container.strokeColor,\n  });\n\n  Object.assign(container, {\n    boundElements: (container.boundElements || []).concat({\n      type: \"text\",\n      id: textElement.id,\n    }),\n  });\n\n  redrawTextBoundingBox(textElement, container, scene);\n\n  return [container, textElement] as const;\n};\n\nconst bindLinearElementToElement = (\n  linearElement: ExcalidrawArrowElement,\n  start: ValidLinearElement[\"start\"],\n  end: ValidLinearElement[\"end\"],\n  elementStore: ElementStore,\n  scene: Scene,\n): {\n  linearElement: ExcalidrawLinearElement;\n  startBoundElement?: ExcalidrawElement;\n  endBoundElement?: ExcalidrawElement;\n} => {\n  let startBoundElement;\n  let endBoundElement;\n\n  Object.assign(linearElement, {\n    startBinding: linearElement?.startBinding || null,\n    endBinding: linearElement.endBinding || null,\n  });\n\n  if (start) {\n    const width = start?.width ?? DEFAULT_DIMENSION;\n    const height = start?.height ?? DEFAULT_DIMENSION;\n\n    let existingElement;\n    if (start.id) {\n      existingElement = elementStore.getElement(start.id);\n      if (!existingElement) {\n        console.error(`No element for start binding with id ${start.id} found`);\n      }\n    }\n\n    const startX = start.x || linearElement.x - width;\n    const startY = start.y || linearElement.y - height / 2;\n    const startType = existingElement ? existingElement.type : start.type;\n\n    if (startType) {\n      if (startType === \"text\") {\n        let text = \"\";\n        if (existingElement && existingElement.type === \"text\") {\n          text = existingElement.text;\n        } else if (start.type === \"text\") {\n          text = start.text;\n        }\n        if (!text) {\n          console.error(\n            `No text found for start binding text element for ${linearElement.id}`,\n          );\n        }\n        startBoundElement = newTextElement({\n          x: startX,\n          y: startY,\n          type: \"text\",\n          ...existingElement,\n          ...start,\n          text,\n        });\n        // to position the text correctly when coordinates not provided\n        Object.assign(startBoundElement, {\n          x: start.x || linearElement.x - startBoundElement.width,\n          y: start.y || linearElement.y - startBoundElement.height / 2,\n        });\n      } else {\n        switch (startType) {\n          case \"rectangle\":\n          case \"ellipse\":\n          case \"diamond\": {\n            startBoundElement = newElement({\n              x: startX,\n              y: startY,\n              width,\n              height,\n              ...existingElement,\n              ...start,\n              type: startType,\n            });\n            break;\n          }\n          default: {\n            assertNever(\n              linearElement as never,\n              `Unhandled element start type \"${start.type}\"`,\n              true,\n            );\n          }\n        }\n      }\n\n      bindLinearElement(\n        linearElement,\n        startBoundElement as ExcalidrawBindableElement,\n        \"start\",\n        scene,\n      );\n    }\n  }\n  if (end) {\n    const height = end?.height ?? DEFAULT_DIMENSION;\n    const width = end?.width ?? DEFAULT_DIMENSION;\n\n    let existingElement;\n    if (end.id) {\n      existingElement = elementStore.getElement(end.id);\n      if (!existingElement) {\n        console.error(`No element for end binding with id ${end.id} found`);\n      }\n    }\n    const endX = end.x || linearElement.x + linearElement.width;\n    const endY = end.y || linearElement.y - height / 2;\n    const endType = existingElement ? existingElement.type : end.type;\n\n    if (endType) {\n      if (endType === \"text\") {\n        let text = \"\";\n        if (existingElement && existingElement.type === \"text\") {\n          text = existingElement.text;\n        } else if (end.type === \"text\") {\n          text = end.text;\n        }\n\n        if (!text) {\n          console.error(\n            `No text found for end binding text element for ${linearElement.id}`,\n          );\n        }\n        endBoundElement = newTextElement({\n          x: endX,\n          y: endY,\n          type: \"text\",\n          ...existingElement,\n          ...end,\n          text,\n        });\n        // to position the text correctly when coordinates not provided\n        Object.assign(endBoundElement, {\n          y: end.y || linearElement.y - endBoundElement.height / 2,\n        });\n      } else {\n        switch (endType) {\n          case \"rectangle\":\n          case \"ellipse\":\n          case \"diamond\": {\n            endBoundElement = newElement({\n              x: endX,\n              y: endY,\n              width,\n              height,\n              ...existingElement,\n              ...end,\n              type: endType,\n            });\n            break;\n          }\n          default: {\n            assertNever(\n              linearElement as never,\n              `Unhandled element end type \"${endType}\"`,\n              true,\n            );\n          }\n        }\n      }\n\n      bindLinearElement(\n        linearElement,\n        endBoundElement as ExcalidrawBindableElement,\n        \"end\",\n        scene,\n      );\n    }\n  }\n\n  // Safe check to early return for single point\n  if (linearElement.points.length < 2) {\n    return {\n      linearElement,\n      startBoundElement,\n      endBoundElement,\n    };\n  }\n\n  // Update start/end points by 0.5 so bindings don't overlap with start/end bound element coordinates.\n  const endPointIndex = linearElement.points.length - 1;\n  const delta = 0.5;\n\n  const newPoints = cloneJSON<readonly LocalPoint[]>(linearElement.points);\n\n  // left to right so shift the arrow towards right\n  if (\n    linearElement.points[endPointIndex][0] >\n    linearElement.points[endPointIndex - 1][0]\n  ) {\n    newPoints[0][0] = delta;\n    newPoints[endPointIndex][0] -= delta;\n  }\n\n  // right to left so shift the arrow towards left\n  if (\n    linearElement.points[endPointIndex][0] <\n    linearElement.points[endPointIndex - 1][0]\n  ) {\n    newPoints[0][0] = -delta;\n    newPoints[endPointIndex][0] += delta;\n  }\n  // top to bottom so shift the arrow towards top\n  if (\n    linearElement.points[endPointIndex][1] >\n    linearElement.points[endPointIndex - 1][1]\n  ) {\n    newPoints[0][1] = delta;\n    newPoints[endPointIndex][1] -= delta;\n  }\n\n  // bottom to top so shift the arrow towards bottom\n  if (\n    linearElement.points[endPointIndex][1] <\n    linearElement.points[endPointIndex - 1][1]\n  ) {\n    newPoints[0][1] = -delta;\n    newPoints[endPointIndex][1] += delta;\n  }\n\n  Object.assign(\n    linearElement,\n    LinearElementEditor.getNormalizeElementPointsAndCoords({\n      ...linearElement,\n      points: newPoints,\n    }),\n  );\n\n  return {\n    linearElement,\n    startBoundElement,\n    endBoundElement,\n  };\n};\n\nclass ElementStore {\n  excalidrawElements = new Map<string, ExcalidrawElement>();\n\n  add = (ele?: ExcalidrawElement) => {\n    if (!ele) {\n      return;\n    }\n\n    this.excalidrawElements.set(ele.id, ele);\n  };\n\n  getElements = () => {\n    return syncInvalidIndices(Array.from(this.excalidrawElements.values()));\n  };\n\n  getElementsMap = () => {\n    return toBrandedType<NonDeletedSceneElementsMap>(\n      arrayToMap(this.getElements()),\n    );\n  };\n\n  getElement = (id: string) => {\n    return this.excalidrawElements.get(id);\n  };\n}\n\nexport const convertToExcalidrawElements = (\n  elementsSkeleton: ExcalidrawElementSkeleton[] | null,\n  opts?: { regenerateIds: boolean },\n) => {\n  if (!elementsSkeleton) {\n    return [];\n  }\n  const elements = cloneJSON(elementsSkeleton);\n  const elementStore = new ElementStore();\n  const elementsWithIds = new Map<string, ExcalidrawElementSkeleton>();\n  const oldToNewElementIdMap = new Map<string, string>();\n\n  // Create individual elements\n  for (const element of elements) {\n    let excalidrawElement: ExcalidrawElement;\n    const originalId = element.id;\n    if (opts?.regenerateIds !== false) {\n      Object.assign(element, { id: randomId() });\n    }\n\n    switch (element.type) {\n      case \"rectangle\":\n      case \"ellipse\":\n      case \"diamond\": {\n        const width =\n          element?.label?.text && element.width === undefined\n            ? 0\n            : element?.width || DEFAULT_DIMENSION;\n        const height =\n          element?.label?.text && element.height === undefined\n            ? 0\n            : element?.height || DEFAULT_DIMENSION;\n        excalidrawElement = newElement({\n          ...element,\n          width,\n          height,\n        });\n\n        break;\n      }\n      case \"line\": {\n        const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;\n        const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;\n        excalidrawElement = newLinearElement({\n          width,\n          height,\n          points: [pointFrom(0, 0), pointFrom(width, height)],\n          ...element,\n        });\n\n        break;\n      }\n      case \"arrow\": {\n        const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;\n        const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;\n        excalidrawElement = newArrowElement({\n          width,\n          height,\n          endArrowhead: \"arrow\",\n          points: [pointFrom(0, 0), pointFrom(width, height)],\n          ...element,\n          type: \"arrow\",\n        });\n\n        Object.assign(\n          excalidrawElement,\n          getSizeFromPoints(excalidrawElement.points),\n        );\n        break;\n      }\n      case \"text\": {\n        const fontFamily = element?.fontFamily || DEFAULT_FONT_FAMILY;\n        const fontSize = element?.fontSize || DEFAULT_FONT_SIZE;\n        const lineHeight = element?.lineHeight || getLineHeight(fontFamily);\n        const text = element.text ?? \"\";\n        const normalizedText = normalizeText(text);\n        const metrics = measureText(\n          normalizedText,\n          getFontString({ fontFamily, fontSize }),\n          lineHeight,\n        );\n\n        excalidrawElement = newTextElement({\n          width: metrics.width,\n          height: metrics.height,\n          fontFamily,\n          fontSize,\n          ...element,\n        });\n        break;\n      }\n      case \"image\": {\n        excalidrawElement = newImageElement({\n          width: element?.width || DEFAULT_DIMENSION,\n          height: element?.height || DEFAULT_DIMENSION,\n          ...element,\n        });\n\n        break;\n      }\n      case \"frame\": {\n        excalidrawElement = newFrameElement({\n          x: 0,\n          y: 0,\n          ...element,\n        });\n        break;\n      }\n      case \"magicframe\": {\n        excalidrawElement = newMagicFrameElement({\n          x: 0,\n          y: 0,\n          ...element,\n        });\n        break;\n      }\n      case \"freedraw\":\n      case \"iframe\":\n      case \"embeddable\": {\n        excalidrawElement = element;\n        break;\n      }\n\n      default: {\n        excalidrawElement = element;\n        assertNever(\n          element,\n          `Unhandled element type \"${(element as any).type}\"`,\n          true,\n        );\n      }\n    }\n    const existingElement = elementStore.getElement(excalidrawElement.id);\n    if (existingElement) {\n      console.error(`Duplicate id found for ${excalidrawElement.id}`);\n    } else {\n      elementStore.add(excalidrawElement);\n      elementsWithIds.set(excalidrawElement.id, element);\n      if (originalId) {\n        oldToNewElementIdMap.set(originalId, excalidrawElement.id);\n      }\n    }\n  }\n\n  const elementsMap = elementStore.getElementsMap();\n  // we don't have a real scene, so we just use a temp scene to query and mutate elements\n  const scene = new Scene(elementsMap);\n\n  // Add labels and arrow bindings\n  for (const [id, element] of elementsWithIds) {\n    const excalidrawElement = elementStore.getElement(id)!;\n\n    switch (element.type) {\n      case \"rectangle\":\n      case \"ellipse\":\n      case \"diamond\":\n      case \"arrow\": {\n        if (element.label?.text) {\n          let [container, text] = bindTextToContainer(\n            excalidrawElement,\n            element?.label,\n            scene,\n          );\n          elementStore.add(container);\n          elementStore.add(text);\n\n          if (isArrowElement(container)) {\n            const originalStart =\n              element.type === \"arrow\" ? element?.start : undefined;\n            const originalEnd =\n              element.type === \"arrow\" ? element?.end : undefined;\n            if (originalStart && originalStart.id) {\n              const newStartId = oldToNewElementIdMap.get(originalStart.id);\n              if (newStartId) {\n                Object.assign(originalStart, { id: newStartId });\n              }\n            }\n            if (originalEnd && originalEnd.id) {\n              const newEndId = oldToNewElementIdMap.get(originalEnd.id);\n              if (newEndId) {\n                Object.assign(originalEnd, { id: newEndId });\n              }\n            }\n            const { linearElement, startBoundElement, endBoundElement } =\n              bindLinearElementToElement(\n                container,\n                originalStart,\n                originalEnd,\n                elementStore,\n                scene,\n              );\n            container = linearElement;\n            elementStore.add(linearElement);\n            elementStore.add(startBoundElement);\n            elementStore.add(endBoundElement);\n          }\n        } else {\n          switch (element.type) {\n            case \"arrow\": {\n              const { start, end } = element;\n              if (start && start.id) {\n                const newStartId = oldToNewElementIdMap.get(start.id);\n                Object.assign(start, { id: newStartId });\n              }\n              if (end && end.id) {\n                const newEndId = oldToNewElementIdMap.get(end.id);\n                Object.assign(end, { id: newEndId });\n              }\n              const { linearElement, startBoundElement, endBoundElement } =\n                bindLinearElementToElement(\n                  excalidrawElement as ExcalidrawArrowElement,\n                  start,\n                  end,\n                  elementStore,\n                  scene,\n                );\n\n              elementStore.add(linearElement);\n              elementStore.add(startBoundElement);\n              elementStore.add(endBoundElement);\n              break;\n            }\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  // Once all the excalidraw elements are created, we can add frames since we\n  // need to calculate coordinates and dimensions of frame which is possible after all\n  // frame children are processed.\n  for (const [id, element] of elementsWithIds) {\n    if (element.type !== \"frame\" && element.type !== \"magicframe\") {\n      continue;\n    }\n    const frame = elementStore.getElement(id);\n\n    if (!frame) {\n      throw new Error(`Excalidraw element with id ${id} doesn't exist`);\n    }\n    const childrenElements: ExcalidrawElement[] = [];\n\n    element.children.forEach((id) => {\n      const newElementId = oldToNewElementIdMap.get(id);\n      if (!newElementId) {\n        throw new Error(`Element with ${id} wasn't mapped correctly`);\n      }\n\n      const elementInFrame = elementStore.getElement(newElementId);\n      if (!elementInFrame) {\n        throw new Error(`Frame element with id ${newElementId} doesn't exist`);\n      }\n      Object.assign(elementInFrame, { frameId: frame.id });\n\n      elementInFrame?.boundElements?.forEach((boundElement) => {\n        const ele = elementStore.getElement(boundElement.id);\n        if (!ele) {\n          throw new Error(\n            `Bound element with id ${boundElement.id} doesn't exist`,\n          );\n        }\n        Object.assign(ele, { frameId: frame.id });\n        childrenElements.push(ele);\n      });\n\n      childrenElements.push(elementInFrame);\n    });\n\n    let [minX, minY, maxX, maxY] = getCommonBounds(childrenElements);\n\n    const PADDING = 10;\n    minX = minX - PADDING;\n    minY = minY - PADDING;\n    maxX = maxX + PADDING;\n    maxY = maxY + PADDING;\n\n    const frameX = frame?.x || minX;\n    const frameY = frame?.y || minY;\n    const frameWidth = frame?.width || maxX - minX;\n    const frameHeight = frame?.height || maxY - minY;\n\n    Object.assign(frame, {\n      x: frameX,\n      y: frameY,\n      width: frameWidth,\n      height: frameHeight,\n    });\n    if (\n      isDevEnv() &&\n      element.children.length &&\n      (frame?.x || frame?.y || frame?.width || frame?.height)\n    ) {\n      console.info(\n        \"User provided frame attributes are being considered, if you find this inaccurate, please remove any of the attributes - x, y, width and height so frame coordinates and dimensions are calculated automatically\",\n      );\n    }\n  }\n\n  return elementStore.getElements();\n};\n",
    "import { isElementInViewport } from \"@excalidraw/element\";\n\nimport { memoize, toBrandedType } from \"@excalidraw/common\";\n\nimport type {\n  ExcalidrawElement,\n  NonDeletedElementsMap,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport { renderInteractiveSceneThrottled } from \"../renderer/interactiveScene\";\nimport { renderStaticSceneThrottled } from \"../renderer/staticScene\";\n\nimport type { RenderableElementsMap } from \"./types\";\n\nimport type { AppState } from \"../types\";\n\nexport class Renderer {\n  private scene: Scene;\n\n  constructor(scene: Scene) {\n    this.scene = scene;\n  }\n\n  public getRenderableElements = (() => {\n    const getVisibleCanvasElements = ({\n      elementsMap,\n      zoom,\n      offsetLeft,\n      offsetTop,\n      scrollX,\n      scrollY,\n      height,\n      width,\n    }: {\n      elementsMap: NonDeletedElementsMap;\n      zoom: AppState[\"zoom\"];\n      offsetLeft: AppState[\"offsetLeft\"];\n      offsetTop: AppState[\"offsetTop\"];\n      scrollX: AppState[\"scrollX\"];\n      scrollY: AppState[\"scrollY\"];\n      height: AppState[\"height\"];\n      width: AppState[\"width\"];\n    }): readonly NonDeletedExcalidrawElement[] => {\n      const visibleElements: NonDeletedExcalidrawElement[] = [];\n      for (const element of elementsMap.values()) {\n        if (\n          isElementInViewport(\n            element,\n            width,\n            height,\n            {\n              zoom,\n              offsetLeft,\n              offsetTop,\n              scrollX,\n              scrollY,\n            },\n            elementsMap,\n          )\n        ) {\n          visibleElements.push(element);\n        }\n      }\n      return visibleElements;\n    };\n\n    const getRenderableElements = ({\n      elements,\n      editingTextElement,\n      newElementId,\n    }: {\n      elements: readonly NonDeletedExcalidrawElement[];\n      editingTextElement: AppState[\"editingTextElement\"];\n      newElementId: ExcalidrawElement[\"id\"] | undefined;\n    }) => {\n      const elementsMap = toBrandedType<RenderableElementsMap>(new Map());\n\n      for (const element of elements) {\n        if (newElementId === element.id) {\n          continue;\n        }\n\n        // we don't want to render text element that's being currently edited\n        // (it's rendered on remote only)\n        if (\n          !editingTextElement ||\n          editingTextElement.type !== \"text\" ||\n          element.id !== editingTextElement.id\n        ) {\n          elementsMap.set(element.id, element);\n        }\n      }\n      return elementsMap;\n    };\n\n    return memoize(\n      ({\n        zoom,\n        offsetLeft,\n        offsetTop,\n        scrollX,\n        scrollY,\n        height,\n        width,\n        editingTextElement,\n        newElementId,\n        // cache-invalidation nonce\n        sceneNonce: _sceneNonce,\n      }: {\n        zoom: AppState[\"zoom\"];\n        offsetLeft: AppState[\"offsetLeft\"];\n        offsetTop: AppState[\"offsetTop\"];\n        scrollX: AppState[\"scrollX\"];\n        scrollY: AppState[\"scrollY\"];\n        height: AppState[\"height\"];\n        width: AppState[\"width\"];\n        editingTextElement: AppState[\"editingTextElement\"];\n        /** note: first render of newElement will always bust the cache\n         * (we'd have to prefilter elements outside of this function) */\n        newElementId: ExcalidrawElement[\"id\"] | undefined;\n        sceneNonce: ReturnType<InstanceType<typeof Scene>[\"getSceneNonce\"]>;\n      }) => {\n        const elements = this.scene.getNonDeletedElements();\n\n        const elementsMap = getRenderableElements({\n          elements,\n          editingTextElement,\n          newElementId,\n        });\n\n        const visibleElements = getVisibleCanvasElements({\n          elementsMap,\n          zoom,\n          offsetLeft,\n          offsetTop,\n          scrollX,\n          scrollY,\n          height,\n          width,\n        });\n\n        return { elementsMap, visibleElements };\n      },\n    );\n  })();\n\n  // NOTE Doesn't destroy everything (scene, rc, etc.) because it may not be\n  // safe to break TS contract here (for upstream cases)\n  public destroy() {\n    renderInteractiveSceneThrottled.cancel();\n    renderStaticSceneThrottled.cancel();\n    this.getRenderableElements.clear();\n  }\n}\n",
    "import {\n  pointFrom,\n  pointsEqual,\n  type GlobalPoint,\n  type LocalPoint,\n  type Radians,\n} from \"@excalidraw/math\";\nimport oc from \"open-color\";\n\nimport {\n  arrayToMap,\n  DEFAULT_TRANSFORM_HANDLE_SPACING,\n  FRAME_STYLE,\n  invariant,\n  THEME,\n  throttleRAF,\n} from \"@excalidraw/common\";\n\nimport { FIXED_BINDING_DISTANCE, maxBindingGap } from \"@excalidraw/element\";\nimport { LinearElementEditor } from \"@excalidraw/element\";\nimport {\n  getOmitSidesForDevice,\n  getTransformHandles,\n  getTransformHandlesFromCoords,\n  shouldShowBoundingBox,\n} from \"@excalidraw/element\";\nimport {\n  isElbowArrow,\n  isFrameLikeElement,\n  isImageElement,\n  isLinearElement,\n  isLineElement,\n  isTextElement,\n} from \"@excalidraw/element\";\n\nimport { renderSelectionElement } from \"@excalidraw/element\";\n\nimport {\n  getElementsInGroup,\n  getSelectedGroupIds,\n  isSelectedViaGroup,\n  selectGroupsFromGivenElements,\n} from \"@excalidraw/element\";\n\nimport { getCommonBounds, getElementAbsoluteCoords } from \"@excalidraw/element\";\n\nimport type {\n  SuggestedBinding,\n  SuggestedPointBinding,\n} from \"@excalidraw/element\";\n\nimport type {\n  TransformHandles,\n  TransformHandleType,\n} from \"@excalidraw/element\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawBindableElement,\n  ExcalidrawElement,\n  ExcalidrawFrameLikeElement,\n  ExcalidrawImageElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElement,\n  GroupId,\n  NonDeleted,\n} from \"@excalidraw/element/types\";\n\nimport { renderSnaps } from \"../renderer/renderSnaps\";\nimport { roundRect } from \"../renderer/roundRect\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH,\n} from \"../scene/scrollbars\";\nimport { type InteractiveCanvasAppState } from \"../types\";\n\nimport { getClientColor, renderRemoteCursors } from \"../clients\";\n\nimport {\n  bootstrapCanvas,\n  drawHighlightForDiamondWithRotation,\n  drawHighlightForRectWithRotation,\n  fillCircle,\n  getNormalizedCanvasDimensions,\n  strokeEllipseWithRotation,\n  strokeRectWithRotation,\n} from \"./helpers\";\n\nimport type {\n  InteractiveCanvasRenderConfig,\n  InteractiveSceneRenderConfig,\n  RenderableElementsMap,\n} from \"../scene/types\";\n\nconst renderElbowArrowMidPointHighlight = (\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n) => {\n  invariant(appState.selectedLinearElement, \"selectedLinearElement is null\");\n\n  const { segmentMidPointHoveredCoords } = appState.selectedLinearElement;\n\n  invariant(segmentMidPointHoveredCoords, \"midPointCoords is null\");\n\n  context.save();\n  context.translate(appState.scrollX, appState.scrollY);\n\n  highlightPoint(segmentMidPointHoveredCoords, context, appState);\n\n  context.restore();\n};\n\nconst renderLinearElementPointHighlight = (\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  elementsMap: ElementsMap,\n) => {\n  const { elementId, hoverPointIndex } = appState.selectedLinearElement!;\n  if (\n    appState.editingLinearElement?.selectedPointsIndices?.includes(\n      hoverPointIndex,\n    )\n  ) {\n    return;\n  }\n  const element = LinearElementEditor.getElement(elementId, elementsMap);\n\n  if (!element) {\n    return;\n  }\n  const point = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n    element,\n    hoverPointIndex,\n    elementsMap,\n  );\n  context.save();\n  context.translate(appState.scrollX, appState.scrollY);\n\n  highlightPoint(point, context, appState);\n  context.restore();\n};\n\nconst highlightPoint = <Point extends LocalPoint | GlobalPoint>(\n  point: Point,\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n) => {\n  context.fillStyle = \"rgba(105, 101, 219, 0.4)\";\n\n  fillCircle(\n    context,\n    point[0],\n    point[1],\n    LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value,\n    false,\n  );\n};\n\nconst renderSingleLinearPoint = <Point extends GlobalPoint | LocalPoint>(\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  point: Point,\n  radius: number,\n  isSelected: boolean,\n  isPhantomPoint: boolean,\n  isOverlappingPoint: boolean,\n) => {\n  context.strokeStyle = \"#5e5ad8\";\n  context.setLineDash([]);\n  context.fillStyle = \"rgba(255, 255, 255, 0.9)\";\n  if (isSelected) {\n    context.fillStyle = \"rgba(134, 131, 226, 0.9)\";\n  } else if (isPhantomPoint) {\n    context.fillStyle = \"rgba(177, 151, 252, 0.7)\";\n  }\n\n  fillCircle(\n    context,\n    point[0],\n    point[1],\n    (isOverlappingPoint\n      ? radius * (appState.editingLinearElement ? 1.5 : 2)\n      : radius) / appState.zoom.value,\n    !isPhantomPoint,\n    !isOverlappingPoint || isSelected,\n  );\n};\n\nconst renderBindingHighlightForBindableElement = (\n  context: CanvasRenderingContext2D,\n  element: ExcalidrawBindableElement,\n  elementsMap: ElementsMap,\n  zoom: InteractiveCanvasAppState[\"zoom\"],\n) => {\n  const padding = maxBindingGap(element, element.width, element.height, zoom);\n\n  context.fillStyle = \"rgba(0,0,0,.05)\";\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"text\":\n    case \"image\":\n    case \"iframe\":\n    case \"embeddable\":\n    case \"frame\":\n    case \"magicframe\":\n      drawHighlightForRectWithRotation(context, element, elementsMap, padding);\n      break;\n    case \"diamond\":\n      drawHighlightForDiamondWithRotation(\n        context,\n        padding,\n        element,\n        elementsMap,\n      );\n      break;\n    case \"ellipse\": {\n      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);\n      const width = x2 - x1;\n      const height = y2 - y1;\n\n      context.strokeStyle = \"rgba(0,0,0,.05)\";\n      context.lineWidth = padding - FIXED_BINDING_DISTANCE;\n\n      strokeEllipseWithRotation(\n        context,\n        width + padding + FIXED_BINDING_DISTANCE,\n        height + padding + FIXED_BINDING_DISTANCE,\n        x1 + width / 2,\n        y1 + height / 2,\n        element.angle,\n      );\n      break;\n    }\n  }\n};\n\nconst renderBindingHighlightForSuggestedPointBinding = (\n  context: CanvasRenderingContext2D,\n  suggestedBinding: SuggestedPointBinding,\n  elementsMap: ElementsMap,\n  zoom: InteractiveCanvasAppState[\"zoom\"],\n) => {\n  const [element, startOrEnd, bindableElement] = suggestedBinding;\n\n  const threshold = maxBindingGap(\n    bindableElement,\n    bindableElement.width,\n    bindableElement.height,\n    zoom,\n  );\n\n  context.strokeStyle = \"rgba(0,0,0,0)\";\n  context.fillStyle = \"rgba(0,0,0,.05)\";\n\n  const pointIndices =\n    startOrEnd === \"both\" ? [0, -1] : startOrEnd === \"start\" ? [0] : [-1];\n  pointIndices.forEach((index) => {\n    const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(\n      element,\n      index,\n      elementsMap,\n    );\n    fillCircle(context, x, y, threshold, true);\n  });\n};\n\ntype ElementSelectionBorder = {\n  angle: number;\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n  selectionColors: string[];\n  dashed?: boolean;\n  cx: number;\n  cy: number;\n  activeEmbeddable: boolean;\n  padding?: number;\n};\n\nconst renderSelectionBorder = (\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  elementProperties: ElementSelectionBorder,\n) => {\n  const {\n    angle,\n    x1,\n    y1,\n    x2,\n    y2,\n    selectionColors,\n    cx,\n    cy,\n    dashed,\n    activeEmbeddable,\n  } = elementProperties;\n  const elementWidth = x2 - x1;\n  const elementHeight = y2 - y1;\n\n  const padding =\n    elementProperties.padding ?? DEFAULT_TRANSFORM_HANDLE_SPACING * 2;\n\n  const linePadding = padding / appState.zoom.value;\n  const lineWidth = 8 / appState.zoom.value;\n  const spaceWidth = 4 / appState.zoom.value;\n\n  context.save();\n  context.translate(appState.scrollX, appState.scrollY);\n  context.lineWidth = (activeEmbeddable ? 4 : 1) / appState.zoom.value;\n\n  const count = selectionColors.length;\n  for (let index = 0; index < count; ++index) {\n    context.strokeStyle = selectionColors[index];\n    if (dashed) {\n      context.setLineDash([\n        lineWidth,\n        spaceWidth + (lineWidth + spaceWidth) * (count - 1),\n      ]);\n    }\n    context.lineDashOffset = (lineWidth + spaceWidth) * index;\n    strokeRectWithRotation(\n      context,\n      x1 - linePadding,\n      y1 - linePadding,\n      elementWidth + linePadding * 2,\n      elementHeight + linePadding * 2,\n      cx,\n      cy,\n      angle,\n    );\n  }\n  context.restore();\n};\n\nconst renderBindingHighlight = (\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  suggestedBinding: SuggestedBinding,\n  elementsMap: ElementsMap,\n) => {\n  const renderHighlight = Array.isArray(suggestedBinding)\n    ? renderBindingHighlightForSuggestedPointBinding\n    : renderBindingHighlightForBindableElement;\n\n  context.save();\n  context.translate(appState.scrollX, appState.scrollY);\n  renderHighlight(context, suggestedBinding as any, elementsMap, appState.zoom);\n\n  context.restore();\n};\n\nconst renderFrameHighlight = (\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  frame: NonDeleted<ExcalidrawFrameLikeElement>,\n  elementsMap: ElementsMap,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(frame, elementsMap);\n  const width = x2 - x1;\n  const height = y2 - y1;\n\n  context.strokeStyle = \"rgb(0,118,255)\";\n  context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;\n\n  context.save();\n  context.translate(appState.scrollX, appState.scrollY);\n  strokeRectWithRotation(\n    context,\n    x1,\n    y1,\n    width,\n    height,\n    x1 + width / 2,\n    y1 + height / 2,\n    frame.angle,\n    false,\n    FRAME_STYLE.radius / appState.zoom.value,\n  );\n  context.restore();\n};\n\nconst renderElementsBoxHighlight = (\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  elements: NonDeleted<ExcalidrawElement>[],\n  config?: { colors?: string[]; dashed?: boolean },\n) => {\n  const { colors = [\"rgb(0,118,255)\"], dashed = false } = config || {};\n  const individualElements = elements.filter(\n    (element) => element.groupIds.length === 0,\n  );\n\n  const elementsInGroups = elements.filter(\n    (element) => element.groupIds.length > 0,\n  );\n\n  const getSelectionFromElements = (elements: ExcalidrawElement[]) => {\n    const [x1, y1, x2, y2] = getCommonBounds(elements);\n    return {\n      angle: 0,\n      x1,\n      x2,\n      y1,\n      y2,\n      selectionColors: colors,\n      dashed,\n      cx: x1 + (x2 - x1) / 2,\n      cy: y1 + (y2 - y1) / 2,\n      activeEmbeddable: false,\n    };\n  };\n\n  const getSelectionForGroupId = (groupId: GroupId) => {\n    const groupElements = getElementsInGroup(elements, groupId);\n    return getSelectionFromElements(groupElements);\n  };\n\n  Object.entries(selectGroupsFromGivenElements(elementsInGroups, appState))\n    .filter(([id, isSelected]) => isSelected)\n    .map(([id, isSelected]) => id)\n    .map((groupId) => getSelectionForGroupId(groupId))\n    .concat(\n      individualElements.map((element) => getSelectionFromElements([element])),\n    )\n    .forEach((selection) =>\n      renderSelectionBorder(context, appState, selection),\n    );\n};\n\nconst renderLinearPointHandles = (\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  element: NonDeleted<ExcalidrawLinearElement>,\n  elementsMap: RenderableElementsMap,\n) => {\n  if (!appState.selectedLinearElement) {\n    return;\n  }\n  context.save();\n  context.translate(appState.scrollX, appState.scrollY);\n  context.lineWidth = 1 / appState.zoom.value;\n  const points: GlobalPoint[] = LinearElementEditor.getPointsGlobalCoordinates(\n    element,\n    elementsMap,\n  );\n\n  const { POINT_HANDLE_SIZE } = LinearElementEditor;\n  const radius = appState.editingLinearElement\n    ? POINT_HANDLE_SIZE\n    : POINT_HANDLE_SIZE / 2;\n\n  const _isElbowArrow = isElbowArrow(element);\n  const _isLineElement = isLineElement(element);\n\n  points.forEach((point, idx) => {\n    if (_isElbowArrow && idx !== 0 && idx !== points.length - 1) {\n      return;\n    }\n\n    const isOverlappingPoint =\n      idx > 0 &&\n      (idx !== points.length - 1 || !_isLineElement || !element.polygon) &&\n      pointsEqual(\n        point,\n        idx === points.length - 1 ? points[0] : points[idx - 1],\n        2 / appState.zoom.value,\n      );\n\n    let isSelected =\n      !!appState.editingLinearElement?.selectedPointsIndices?.includes(idx);\n    // when element is a polygon, highlight the last point as well if first\n    // point is selected since they overlap and the last point tends to be\n    // rendered on top\n    if (\n      _isLineElement &&\n      element.polygon &&\n      !isSelected &&\n      idx === element.points.length - 1 &&\n      !!appState.editingLinearElement?.selectedPointsIndices?.includes(0)\n    ) {\n      isSelected = true;\n    }\n\n    renderSingleLinearPoint(\n      context,\n      appState,\n      point,\n      radius,\n      isSelected,\n      false,\n      isOverlappingPoint,\n    );\n  });\n\n  // Rendering segment mid points\n  if (isElbowArrow(element)) {\n    const fixedSegments =\n      element.fixedSegments?.map((segment) => segment.index) || [];\n    points.slice(0, -1).forEach((p, idx) => {\n      if (\n        !LinearElementEditor.isSegmentTooShort(\n          element,\n          points[idx + 1],\n          points[idx],\n          idx,\n          appState.zoom,\n        )\n      ) {\n        renderSingleLinearPoint(\n          context,\n          appState,\n          pointFrom<GlobalPoint>(\n            (p[0] + points[idx + 1][0]) / 2,\n            (p[1] + points[idx + 1][1]) / 2,\n          ),\n          POINT_HANDLE_SIZE / 2,\n          false,\n          !fixedSegments.includes(idx + 1),\n          false,\n        );\n      }\n    });\n  } else {\n    const midPoints = LinearElementEditor.getEditorMidPoints(\n      element,\n      elementsMap,\n      appState,\n    ).filter(\n      (midPoint, idx, midPoints): midPoint is GlobalPoint =>\n        midPoint !== null &&\n        !(isElbowArrow(element) && (idx === 0 || idx === midPoints.length - 1)),\n    );\n\n    midPoints.forEach((segmentMidPoint) => {\n      if (appState.editingLinearElement || points.length === 2) {\n        renderSingleLinearPoint(\n          context,\n          appState,\n          segmentMidPoint,\n          POINT_HANDLE_SIZE / 2,\n          false,\n          true,\n          false,\n        );\n      }\n    });\n  }\n\n  context.restore();\n};\n\nconst renderTransformHandles = (\n  context: CanvasRenderingContext2D,\n  renderConfig: InteractiveCanvasRenderConfig,\n  appState: InteractiveCanvasAppState,\n  transformHandles: TransformHandles,\n  angle: number,\n): void => {\n  Object.keys(transformHandles).forEach((key) => {\n    const transformHandle = transformHandles[key as TransformHandleType];\n    if (transformHandle !== undefined) {\n      const [x, y, width, height] = transformHandle;\n\n      context.save();\n      context.lineWidth = 1 / appState.zoom.value;\n      if (renderConfig.selectionColor) {\n        context.strokeStyle = renderConfig.selectionColor;\n      }\n      if (key === \"rotation\") {\n        fillCircle(context, x + width / 2, y + height / 2, width / 2, true);\n        // prefer round corners if roundRect API is available\n      } else if (context.roundRect) {\n        context.beginPath();\n        context.roundRect(x, y, width, height, 2 / appState.zoom.value);\n        context.fill();\n        context.stroke();\n      } else {\n        strokeRectWithRotation(\n          context,\n          x,\n          y,\n          width,\n          height,\n          x + width / 2,\n          y + height / 2,\n          angle,\n          true, // fill before stroke\n        );\n      }\n      context.restore();\n    }\n  });\n};\n\nconst renderCropHandles = (\n  context: CanvasRenderingContext2D,\n  renderConfig: InteractiveCanvasRenderConfig,\n  appState: InteractiveCanvasAppState,\n  croppingElement: ExcalidrawImageElement,\n  elementsMap: ElementsMap,\n): void => {\n  const [x1, y1, , , cx, cy] = getElementAbsoluteCoords(\n    croppingElement,\n    elementsMap,\n  );\n\n  const LINE_WIDTH = 3;\n  const LINE_LENGTH = 20;\n\n  const ZOOMED_LINE_WIDTH = LINE_WIDTH / appState.zoom.value;\n  const ZOOMED_HALF_LINE_WIDTH = ZOOMED_LINE_WIDTH / 2;\n\n  const HALF_WIDTH = cx - x1 + ZOOMED_LINE_WIDTH;\n  const HALF_HEIGHT = cy - y1 + ZOOMED_LINE_WIDTH;\n\n  const HORIZONTAL_LINE_LENGTH = Math.min(\n    LINE_LENGTH / appState.zoom.value,\n    HALF_WIDTH,\n  );\n  const VERTICAL_LINE_LENGTH = Math.min(\n    LINE_LENGTH / appState.zoom.value,\n    HALF_HEIGHT,\n  );\n\n  context.save();\n  context.fillStyle = renderConfig.selectionColor;\n  context.strokeStyle = renderConfig.selectionColor;\n  context.lineWidth = ZOOMED_LINE_WIDTH;\n\n  const handles: Array<\n    [\n      [number, number],\n      [number, number],\n      [number, number],\n      [number, number],\n      [number, number],\n    ]\n  > = [\n    [\n      // x, y\n      [-HALF_WIDTH, -HALF_HEIGHT],\n      // horizontal line: first start and to\n      [0, ZOOMED_HALF_LINE_WIDTH],\n      [HORIZONTAL_LINE_LENGTH, ZOOMED_HALF_LINE_WIDTH],\n      // vertical line: second  start and to\n      [ZOOMED_HALF_LINE_WIDTH, 0],\n      [ZOOMED_HALF_LINE_WIDTH, VERTICAL_LINE_LENGTH],\n    ],\n    [\n      [HALF_WIDTH - ZOOMED_HALF_LINE_WIDTH, -HALF_HEIGHT],\n      [ZOOMED_HALF_LINE_WIDTH, ZOOMED_HALF_LINE_WIDTH],\n      [\n        -HORIZONTAL_LINE_LENGTH + ZOOMED_HALF_LINE_WIDTH,\n        ZOOMED_HALF_LINE_WIDTH,\n      ],\n      [0, 0],\n      [0, VERTICAL_LINE_LENGTH],\n    ],\n    [\n      [-HALF_WIDTH, HALF_HEIGHT],\n      [0, -ZOOMED_HALF_LINE_WIDTH],\n      [HORIZONTAL_LINE_LENGTH, -ZOOMED_HALF_LINE_WIDTH],\n      [ZOOMED_HALF_LINE_WIDTH, 0],\n      [ZOOMED_HALF_LINE_WIDTH, -VERTICAL_LINE_LENGTH],\n    ],\n    [\n      [HALF_WIDTH - ZOOMED_HALF_LINE_WIDTH, HALF_HEIGHT],\n      [ZOOMED_HALF_LINE_WIDTH, -ZOOMED_HALF_LINE_WIDTH],\n      [\n        -HORIZONTAL_LINE_LENGTH + ZOOMED_HALF_LINE_WIDTH,\n        -ZOOMED_HALF_LINE_WIDTH,\n      ],\n      [0, 0],\n      [0, -VERTICAL_LINE_LENGTH],\n    ],\n  ];\n\n  handles.forEach((handle) => {\n    const [[x, y], [x1s, y1s], [x1t, y1t], [x2s, y2s], [x2t, y2t]] = handle;\n\n    context.save();\n    context.translate(cx, cy);\n    context.rotate(croppingElement.angle);\n\n    context.beginPath();\n    context.moveTo(x + x1s, y + y1s);\n    context.lineTo(x + x1t, y + y1t);\n    context.stroke();\n\n    context.beginPath();\n    context.moveTo(x + x2s, y + y2s);\n    context.lineTo(x + x2t, y + y2t);\n    context.stroke();\n    context.restore();\n  });\n\n  context.restore();\n};\n\nconst renderTextBox = (\n  text: NonDeleted<ExcalidrawTextElement>,\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n  selectionColor: InteractiveCanvasRenderConfig[\"selectionColor\"],\n) => {\n  context.save();\n  const padding = (DEFAULT_TRANSFORM_HANDLE_SPACING * 2) / appState.zoom.value;\n  const width = text.width + padding * 2;\n  const height = text.height + padding * 2;\n  const cx = text.x + width / 2;\n  const cy = text.y + height / 2;\n  const shiftX = -(width / 2 + padding);\n  const shiftY = -(height / 2 + padding);\n  context.translate(cx + appState.scrollX, cy + appState.scrollY);\n  context.rotate(text.angle);\n  context.lineWidth = 1 / appState.zoom.value;\n  context.strokeStyle = selectionColor;\n  context.strokeRect(shiftX, shiftY, width, height);\n  context.restore();\n};\n\nconst _renderInteractiveScene = ({\n  canvas,\n  elementsMap,\n  visibleElements,\n  selectedElements,\n  allElementsMap,\n  scale,\n  appState,\n  renderConfig,\n  device,\n}: InteractiveSceneRenderConfig) => {\n  if (canvas === null) {\n    return { atLeastOneVisibleElement: false, elementsMap };\n  }\n\n  const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(\n    canvas,\n    scale,\n  );\n\n  const context = bootstrapCanvas({\n    canvas,\n    scale,\n    normalizedWidth,\n    normalizedHeight,\n  });\n\n  // Apply zoom\n  context.save();\n  context.scale(appState.zoom.value, appState.zoom.value);\n\n  let editingLinearElement: NonDeleted<ExcalidrawLinearElement> | undefined =\n    undefined;\n\n  visibleElements.forEach((element) => {\n    // Getting the element using LinearElementEditor during collab mismatches version - being one head of visible elements due to\n    // ShapeCache returns empty hence making sure that we get the\n    // correct element from visible elements\n    if (appState.editingLinearElement?.elementId === element.id) {\n      if (element) {\n        editingLinearElement = element as NonDeleted<ExcalidrawLinearElement>;\n      }\n    }\n  });\n\n  if (editingLinearElement) {\n    renderLinearPointHandles(\n      context,\n      appState,\n      editingLinearElement,\n      elementsMap,\n    );\n  }\n\n  // Paint selection element\n  if (appState.selectionElement && !appState.isCropping) {\n    try {\n      renderSelectionElement(\n        appState.selectionElement,\n        context,\n        appState,\n        renderConfig.selectionColor,\n      );\n    } catch (error: any) {\n      console.error(error);\n    }\n  }\n\n  if (\n    appState.editingTextElement &&\n    isTextElement(appState.editingTextElement)\n  ) {\n    const textElement = allElementsMap.get(appState.editingTextElement.id) as\n      | ExcalidrawTextElement\n      | undefined;\n    if (textElement && !textElement.autoResize) {\n      renderTextBox(\n        textElement,\n        context,\n        appState,\n        renderConfig.selectionColor,\n      );\n    }\n  }\n\n  if (appState.isBindingEnabled) {\n    appState.suggestedBindings\n      .filter((binding) => binding != null)\n      .forEach((suggestedBinding) => {\n        renderBindingHighlight(\n          context,\n          appState,\n          suggestedBinding!,\n          elementsMap,\n        );\n      });\n  }\n\n  if (appState.frameToHighlight) {\n    renderFrameHighlight(\n      context,\n      appState,\n      appState.frameToHighlight,\n      elementsMap,\n    );\n  }\n\n  if (appState.elementsToHighlight) {\n    renderElementsBoxHighlight(context, appState, appState.elementsToHighlight);\n  }\n\n  if (appState.activeLockedId) {\n    const element = allElementsMap.get(appState.activeLockedId);\n    const elements = element\n      ? [element]\n      : getElementsInGroup(allElementsMap, appState.activeLockedId);\n    renderElementsBoxHighlight(context, appState, elements, {\n      colors: [\"#ced4da\"],\n      dashed: true,\n    });\n  }\n\n  const isFrameSelected = selectedElements.some((element) =>\n    isFrameLikeElement(element),\n  );\n\n  // Getting the element using LinearElementEditor during collab mismatches version - being one head of visible elements due to\n  // ShapeCache returns empty hence making sure that we get the\n  // correct element from visible elements\n  if (\n    selectedElements.length === 1 &&\n    appState.editingLinearElement?.elementId === selectedElements[0].id\n  ) {\n    renderLinearPointHandles(\n      context,\n      appState,\n      selectedElements[0] as NonDeleted<ExcalidrawLinearElement>,\n      elementsMap,\n    );\n  }\n\n  // Arrows have a different highlight behavior when\n  // they are the only selected element\n  if (appState.selectedLinearElement) {\n    const editor = appState.selectedLinearElement;\n    const firstSelectedLinear = selectedElements.find(\n      (el) => el.id === editor.elementId, // Don't forget bound text elements!\n    );\n\n    if (editor.segmentMidPointHoveredCoords) {\n      renderElbowArrowMidPointHighlight(context, appState);\n    } else if (\n      isElbowArrow(firstSelectedLinear)\n        ? editor.hoverPointIndex === 0 ||\n          editor.hoverPointIndex === firstSelectedLinear.points.length - 1\n        : editor.hoverPointIndex >= 0\n    ) {\n      renderLinearElementPointHighlight(context, appState, elementsMap);\n    }\n  }\n\n  // Paint selected elements\n  if (!appState.multiElement && !appState.editingLinearElement) {\n    const showBoundingBox = shouldShowBoundingBox(selectedElements, appState);\n\n    const isSingleLinearElementSelected =\n      selectedElements.length === 1 && isLinearElement(selectedElements[0]);\n    // render selected linear element points\n    if (\n      isSingleLinearElementSelected &&\n      appState.selectedLinearElement?.elementId === selectedElements[0].id &&\n      !selectedElements[0].locked\n    ) {\n      renderLinearPointHandles(\n        context,\n        appState,\n        selectedElements[0] as ExcalidrawLinearElement,\n        elementsMap,\n      );\n    }\n    const selectionColor = renderConfig.selectionColor || oc.black;\n\n    if (showBoundingBox) {\n      // Optimisation for finding quickly relevant element ids\n      const locallySelectedIds = arrayToMap(selectedElements);\n\n      const selections: ElementSelectionBorder[] = [];\n\n      for (const element of elementsMap.values()) {\n        const selectionColors = [];\n        const remoteClients = renderConfig.remoteSelectedElementIds.get(\n          element.id,\n        );\n        if (\n          !(\n            // Elbow arrow elements cannot be selected when bound on either end\n            (\n              isSingleLinearElementSelected &&\n              isElbowArrow(element) &&\n              (element.startBinding || element.endBinding)\n            )\n          )\n        ) {\n          // local user\n          if (\n            locallySelectedIds.has(element.id) &&\n            !isSelectedViaGroup(appState, element)\n          ) {\n            selectionColors.push(selectionColor);\n          }\n          // remote users\n          if (remoteClients) {\n            selectionColors.push(\n              ...remoteClients.map((socketId) => {\n                const background = getClientColor(\n                  socketId,\n                  appState.collaborators.get(socketId),\n                );\n                return background;\n              }),\n            );\n          }\n        }\n\n        if (selectionColors.length) {\n          const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(\n            element,\n            elementsMap,\n            true,\n          );\n          selections.push({\n            angle: element.angle,\n            x1,\n            y1,\n            x2,\n            y2,\n            selectionColors: element.locked ? [\"#ced4da\"] : selectionColors,\n            dashed: !!remoteClients || element.locked,\n            cx,\n            cy,\n            activeEmbeddable:\n              appState.activeEmbeddable?.element === element &&\n              appState.activeEmbeddable.state === \"active\",\n            padding:\n              element.id === appState.croppingElementId ||\n              isImageElement(element)\n                ? 0\n                : undefined,\n          });\n        }\n      }\n\n      const addSelectionForGroupId = (groupId: GroupId) => {\n        const groupElements = getElementsInGroup(elementsMap, groupId);\n        const [x1, y1, x2, y2] = getCommonBounds(groupElements);\n        selections.push({\n          angle: 0,\n          x1,\n          x2,\n          y1,\n          y2,\n          selectionColors: groupElements.some((el) => el.locked)\n            ? [\"#ced4da\"]\n            : [oc.black],\n          dashed: true,\n          cx: x1 + (x2 - x1) / 2,\n          cy: y1 + (y2 - y1) / 2,\n          activeEmbeddable: false,\n        });\n      };\n\n      for (const groupId of getSelectedGroupIds(appState)) {\n        // TODO: support multiplayer selected group IDs\n        addSelectionForGroupId(groupId);\n      }\n\n      if (appState.editingGroupId) {\n        addSelectionForGroupId(appState.editingGroupId);\n      }\n\n      selections.forEach((selection) =>\n        renderSelectionBorder(context, appState, selection),\n      );\n    }\n    // Paint resize transformHandles\n    context.save();\n    context.translate(appState.scrollX, appState.scrollY);\n\n    if (selectedElements.length === 1) {\n      context.fillStyle = oc.white;\n      const transformHandles = getTransformHandles(\n        selectedElements[0],\n        appState.zoom,\n        elementsMap,\n        \"mouse\", // when we render we don't know which pointer type so use mouse,\n        getOmitSidesForDevice(device),\n      );\n      if (\n        !appState.viewModeEnabled &&\n        showBoundingBox &&\n        // do not show transform handles when text is being edited\n        !isTextElement(appState.editingTextElement) &&\n        // do not show transform handles when image is being cropped\n        !appState.croppingElementId\n      ) {\n        renderTransformHandles(\n          context,\n          renderConfig,\n          appState,\n          transformHandles,\n          selectedElements[0].angle,\n        );\n      }\n\n      if (appState.croppingElementId && !appState.isCropping) {\n        const croppingElement = elementsMap.get(appState.croppingElementId);\n\n        if (croppingElement && isImageElement(croppingElement)) {\n          renderCropHandles(\n            context,\n            renderConfig,\n            appState,\n            croppingElement,\n            elementsMap,\n          );\n        }\n      }\n    } else if (\n      selectedElements.length > 1 &&\n      !appState.isRotating &&\n      !selectedElements.some((el) => el.locked)\n    ) {\n      const dashedLinePadding =\n        (DEFAULT_TRANSFORM_HANDLE_SPACING * 2) / appState.zoom.value;\n      context.fillStyle = oc.white;\n      const [x1, y1, x2, y2] = getCommonBounds(selectedElements, elementsMap);\n      const initialLineDash = context.getLineDash();\n      context.setLineDash([2 / appState.zoom.value]);\n      const lineWidth = context.lineWidth;\n      context.lineWidth = 1 / appState.zoom.value;\n      context.strokeStyle = selectionColor;\n      strokeRectWithRotation(\n        context,\n        x1 - dashedLinePadding,\n        y1 - dashedLinePadding,\n        x2 - x1 + dashedLinePadding * 2,\n        y2 - y1 + dashedLinePadding * 2,\n        (x1 + x2) / 2,\n        (y1 + y2) / 2,\n        0,\n      );\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n      const transformHandles = getTransformHandlesFromCoords(\n        [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2],\n        0 as Radians,\n        appState.zoom,\n        \"mouse\",\n        isFrameSelected\n          ? { ...getOmitSidesForDevice(device), rotation: true }\n          : getOmitSidesForDevice(device),\n      );\n      if (selectedElements.some((element) => !element.locked)) {\n        renderTransformHandles(\n          context,\n          renderConfig,\n          appState,\n          transformHandles,\n          0,\n        );\n      }\n    }\n    context.restore();\n  }\n\n  appState.searchMatches?.matches.forEach(({ id, focus, matchedLines }) => {\n    const element = elementsMap.get(id);\n\n    if (element) {\n      const [elementX1, elementY1, , , cx, cy] = getElementAbsoluteCoords(\n        element,\n        elementsMap,\n        true,\n      );\n\n      context.save();\n      if (appState.theme === THEME.LIGHT) {\n        if (focus) {\n          context.fillStyle = \"rgba(255, 124, 0, 0.4)\";\n        } else {\n          context.fillStyle = \"rgba(255, 226, 0, 0.4)\";\n        }\n      } else if (focus) {\n        context.fillStyle = \"rgba(229, 82, 0, 0.4)\";\n      } else {\n        context.fillStyle = \"rgba(99, 52, 0, 0.4)\";\n      }\n\n      const zoomFactor = isFrameLikeElement(element) ? appState.zoom.value : 1;\n\n      context.translate(appState.scrollX, appState.scrollY);\n      context.translate(cx, cy);\n      context.rotate(element.angle);\n\n      matchedLines.forEach((matchedLine) => {\n        (matchedLine.showOnCanvas || focus) &&\n          context.fillRect(\n            elementX1 + matchedLine.offsetX / zoomFactor - cx,\n            elementY1 + matchedLine.offsetY / zoomFactor - cy,\n            matchedLine.width / zoomFactor,\n            matchedLine.height / zoomFactor,\n          );\n      });\n\n      context.restore();\n    }\n  });\n\n  renderSnaps(context, appState);\n\n  context.restore();\n\n  renderRemoteCursors({\n    context,\n    renderConfig,\n    appState,\n    normalizedWidth,\n    normalizedHeight,\n  });\n\n  // Paint scrollbars\n  let scrollBars;\n  if (renderConfig.renderScrollbars) {\n    scrollBars = getScrollBars(\n      elementsMap,\n      normalizedWidth,\n      normalizedHeight,\n      appState,\n    );\n\n    context.save();\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {\n      if (scrollBar) {\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2,\n        );\n      }\n    });\n    context.restore();\n  }\n\n  return {\n    scrollBars,\n    atLeastOneVisibleElement: visibleElements.length > 0,\n    elementsMap,\n  };\n};\n\n/** throttled to animation framerate */\nexport const renderInteractiveSceneThrottled = throttleRAF(\n  (config: InteractiveSceneRenderConfig) => {\n    const ret = _renderInteractiveScene(config);\n    config.callback?.(ret);\n  },\n  { trailing: true },\n);\n\n/**\n * Interactive scene is the ui-canvas where we render bounding boxes, selections\n * and other ui stuff.\n */\nexport const renderInteractiveScene = <\n  U extends typeof _renderInteractiveScene,\n  T extends boolean = false,\n>(\n  renderConfig: InteractiveSceneRenderConfig,\n  throttle?: T,\n): T extends true ? void : ReturnType<U> => {\n  if (throttle) {\n    renderInteractiveSceneThrottled(renderConfig);\n    return undefined as T extends true ? void : ReturnType<U>;\n  }\n  const ret = _renderInteractiveScene(renderConfig);\n  renderConfig.callback(ret);\n  return ret as T extends true ? void : ReturnType<U>;\n};\n",
    "import { pointFrom, type GlobalPoint, type LocalPoint } from \"@excalidraw/math\";\n\nimport { THEME } from \"@excalidraw/common\";\n\nimport type { PointSnapLine, PointerSnapLine } from \"../snapping\";\nimport type { InteractiveCanvasAppState } from \"../types\";\n\nconst SNAP_COLOR_LIGHT = \"#ff6b6b\";\nconst SNAP_COLOR_DARK = \"#ff0000\";\nconst SNAP_WIDTH = 1;\nconst SNAP_CROSS_SIZE = 2;\n\nexport const renderSnaps = (\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n) => {\n  if (!appState.snapLines.length) {\n    return;\n  }\n\n  // in dark mode, we need to adjust the color to account for color inversion.\n  // Don't change if zen mode, because we draw only crosses, we want the\n  // colors to be more visible\n  const snapColor =\n    appState.theme === THEME.LIGHT || appState.zenModeEnabled\n      ? SNAP_COLOR_LIGHT\n      : SNAP_COLOR_DARK;\n  // in zen mode make the cross more visible since we don't draw the lines\n  const snapWidth =\n    (appState.zenModeEnabled ? SNAP_WIDTH * 1.5 : SNAP_WIDTH) /\n    appState.zoom.value;\n\n  context.save();\n  context.translate(appState.scrollX, appState.scrollY);\n\n  for (const snapLine of appState.snapLines) {\n    if (snapLine.type === \"pointer\") {\n      context.lineWidth = snapWidth;\n      context.strokeStyle = snapColor;\n\n      drawPointerSnapLine(snapLine, context, appState);\n    } else if (snapLine.type === \"gap\") {\n      context.lineWidth = snapWidth;\n      context.strokeStyle = snapColor;\n\n      drawGapLine(\n        snapLine.points[0],\n        snapLine.points[1],\n        snapLine.direction,\n        appState,\n        context,\n      );\n    } else if (snapLine.type === \"points\") {\n      context.lineWidth = snapWidth;\n      context.strokeStyle = snapColor;\n      drawPointsSnapLine(snapLine, context, appState);\n    }\n  }\n\n  context.restore();\n};\n\nconst drawPointsSnapLine = (\n  pointSnapLine: PointSnapLine,\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n) => {\n  if (!appState.zenModeEnabled) {\n    const firstPoint = pointSnapLine.points[0];\n    const lastPoint = pointSnapLine.points[pointSnapLine.points.length - 1];\n\n    drawLine(firstPoint, lastPoint, context);\n  }\n\n  for (const point of pointSnapLine.points) {\n    drawCross(point, appState, context);\n  }\n};\n\nconst drawPointerSnapLine = (\n  pointerSnapLine: PointerSnapLine,\n  context: CanvasRenderingContext2D,\n  appState: InteractiveCanvasAppState,\n) => {\n  drawCross(pointerSnapLine.points[0], appState, context);\n  if (!appState.zenModeEnabled) {\n    drawLine(pointerSnapLine.points[0], pointerSnapLine.points[1], context);\n  }\n};\n\nconst drawCross = <Point extends LocalPoint | GlobalPoint>(\n  [x, y]: Point,\n  appState: InteractiveCanvasAppState,\n  context: CanvasRenderingContext2D,\n) => {\n  context.save();\n  const size =\n    (appState.zenModeEnabled ? SNAP_CROSS_SIZE * 1.5 : SNAP_CROSS_SIZE) /\n    appState.zoom.value;\n  context.beginPath();\n\n  context.moveTo(x - size, y - size);\n  context.lineTo(x + size, y + size);\n\n  context.moveTo(x + size, y - size);\n  context.lineTo(x - size, y + size);\n\n  context.stroke();\n  context.restore();\n};\n\nconst drawLine = <Point extends LocalPoint | GlobalPoint>(\n  from: Point,\n  to: Point,\n  context: CanvasRenderingContext2D,\n) => {\n  context.beginPath();\n  context.lineTo(from[0], from[1]);\n  context.lineTo(to[0], to[1]);\n  context.stroke();\n};\n\nconst drawGapLine = <Point extends LocalPoint | GlobalPoint>(\n  from: Point,\n  to: Point,\n  direction: \"horizontal\" | \"vertical\",\n  appState: InteractiveCanvasAppState,\n  context: CanvasRenderingContext2D,\n) => {\n  // a horizontal gap snap line\n  // |–––––––||–––––––|\n  // ^    ^   ^       ^\n  // \\    \\   \\       \\\n  // (1)  (2) (3)     (4)\n\n  const FULL = 8 / appState.zoom.value;\n  const HALF = FULL / 2;\n  const QUARTER = FULL / 4;\n\n  if (direction === \"horizontal\") {\n    const halfPoint = [(from[0] + to[0]) / 2, from[1]];\n    // (1)\n    if (!appState.zenModeEnabled) {\n      drawLine(\n        pointFrom(from[0], from[1] - FULL),\n        pointFrom(from[0], from[1] + FULL),\n        context,\n      );\n    }\n\n    // (3)\n    drawLine(\n      pointFrom(halfPoint[0] - QUARTER, halfPoint[1] - HALF),\n      pointFrom(halfPoint[0] - QUARTER, halfPoint[1] + HALF),\n      context,\n    );\n    drawLine(\n      pointFrom(halfPoint[0] + QUARTER, halfPoint[1] - HALF),\n      pointFrom(halfPoint[0] + QUARTER, halfPoint[1] + HALF),\n      context,\n    );\n\n    if (!appState.zenModeEnabled) {\n      // (4)\n      drawLine(\n        pointFrom(to[0], to[1] - FULL),\n        pointFrom(to[0], to[1] + FULL),\n        context,\n      );\n\n      // (2)\n      drawLine(from, to, context);\n    }\n  } else {\n    const halfPoint = [from[0], (from[1] + to[1]) / 2];\n    // (1)\n    if (!appState.zenModeEnabled) {\n      drawLine(\n        pointFrom(from[0] - FULL, from[1]),\n        pointFrom(from[0] + FULL, from[1]),\n        context,\n      );\n    }\n\n    // (3)\n    drawLine(\n      pointFrom(halfPoint[0] - HALF, halfPoint[1] - QUARTER),\n      pointFrom(halfPoint[0] + HALF, halfPoint[1] - QUARTER),\n      context,\n    );\n    drawLine(\n      pointFrom(halfPoint[0] - HALF, halfPoint[1] + QUARTER),\n      pointFrom(halfPoint[0] + HALF, halfPoint[1] + QUARTER),\n      context,\n    );\n\n    if (!appState.zenModeEnabled) {\n      // (4)\n      drawLine(\n        pointFrom(to[0] - FULL, to[1]),\n        pointFrom(to[0] + FULL, to[1]),\n        context,\n      );\n\n      // (2)\n      drawLine(from, to, context);\n    }\n  }\n};\n",
    "import { getGlobalCSSVariable } from \"@excalidraw/common\";\n\nimport { getCommonBounds } from \"@excalidraw/element\";\n\nimport { getLanguage } from \"../i18n\";\n\nimport type { InteractiveCanvasAppState } from \"../types\";\nimport type { RenderableElementsMap, ScrollBars } from \"./types\";\n\nexport const SCROLLBAR_MARGIN = 4;\nexport const SCROLLBAR_WIDTH = 6;\nexport const SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\n\n// The scrollbar represents where the viewport is in relationship to the scene\nexport const getScrollBars = (\n  elements: RenderableElementsMap,\n  viewportWidth: number,\n  viewportHeight: number,\n  appState: InteractiveCanvasAppState,\n): ScrollBars => {\n  if (!elements.size) {\n    return {\n      horizontal: null,\n      vertical: null,\n    };\n  }\n  // This is the bounding box of all the elements\n  const [elementsMinX, elementsMinY, elementsMaxX, elementsMaxY] =\n    getCommonBounds(elements);\n\n  // Apply zoom\n  const viewportWidthWithZoom = viewportWidth / appState.zoom.value;\n  const viewportHeightWithZoom = viewportHeight / appState.zoom.value;\n\n  const safeArea = {\n    top: parseInt(getGlobalCSSVariable(\"sat\")) || 0,\n    bottom: parseInt(getGlobalCSSVariable(\"sab\")) || 0,\n    left: parseInt(getGlobalCSSVariable(\"sal\")) || 0,\n    right: parseInt(getGlobalCSSVariable(\"sar\")) || 0,\n  };\n\n  const isRTL = getLanguage().rtl;\n\n  // The viewport is the rectangle currently visible for the user\n  const viewportMinX = -appState.scrollX + safeArea.left;\n  const viewportMinY = -appState.scrollY + safeArea.top;\n  const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;\n  const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;\n\n  // The scene is the bounding box of both the elements and viewport\n  const sceneMinX = Math.min(elementsMinX, viewportMinX);\n  const sceneMinY = Math.min(elementsMinY, viewportMinY);\n  const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);\n  const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);\n\n  // the elements-only bbox\n  const sceneWidth = elementsMaxX - elementsMinX;\n  const sceneHeight = elementsMaxY - elementsMinY;\n\n  // scene (elements) bbox + the viewport bbox that extends outside of it\n  const extendedSceneWidth = sceneMaxX - sceneMinX;\n  const extendedSceneHeight = sceneMaxY - sceneMinY;\n\n  const scrollWidthOffset =\n    Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right) +\n    SCROLLBAR_WIDTH * 2;\n\n  const scrollbarWidth =\n    viewportWidth * (viewportWidthWithZoom / extendedSceneWidth) -\n    scrollWidthOffset;\n\n  const scrollbarHeightOffset =\n    Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom) +\n    SCROLLBAR_WIDTH * 2;\n\n  const scrollbarHeight =\n    viewportHeight * (viewportHeightWithZoom / extendedSceneHeight) -\n    scrollbarHeightOffset;\n  // NOTE the delta multiplier calculation isn't quite correct when viewport\n  // is extended outside the scene (elements) bbox as there's some small\n  // accumulation error. I'll let this be an exercise for others to fix. ^^\n  const horizontalDeltaMultiplier =\n    extendedSceneWidth > sceneWidth\n      ? (extendedSceneWidth * appState.zoom.value) /\n        (scrollbarWidth + scrollWidthOffset)\n      : viewportWidth / (scrollbarWidth + scrollWidthOffset);\n\n  const verticalDeltaMultiplier =\n    extendedSceneHeight > sceneHeight\n      ? (extendedSceneHeight * appState.zoom.value) /\n        (scrollbarHeight + scrollbarHeightOffset)\n      : viewportHeight / (scrollbarHeight + scrollbarHeightOffset);\n  return {\n    horizontal:\n      viewportMinX === sceneMinX && viewportMaxX === sceneMaxX\n        ? null\n        : {\n            x:\n              Math.max(safeArea.left, SCROLLBAR_MARGIN) +\n              SCROLLBAR_WIDTH +\n              ((viewportMinX - sceneMinX) / extendedSceneWidth) * viewportWidth,\n            y:\n              viewportHeight -\n              SCROLLBAR_WIDTH -\n              Math.max(SCROLLBAR_MARGIN, safeArea.bottom),\n            width: scrollbarWidth,\n            height: SCROLLBAR_WIDTH,\n            deltaMultiplier: horizontalDeltaMultiplier,\n          },\n\n    vertical:\n      viewportMinY === sceneMinY && viewportMaxY === sceneMaxY\n        ? null\n        : {\n            x: isRTL\n              ? Math.max(safeArea.left, SCROLLBAR_MARGIN)\n              : viewportWidth -\n                SCROLLBAR_WIDTH -\n                Math.max(safeArea.right, SCROLLBAR_MARGIN),\n            y:\n              Math.max(safeArea.top, SCROLLBAR_MARGIN) +\n              SCROLLBAR_WIDTH +\n              ((viewportMinY - sceneMinY) / extendedSceneHeight) *\n                viewportHeight,\n            width: SCROLLBAR_WIDTH,\n            height: scrollbarHeight,\n            deltaMultiplier: verticalDeltaMultiplier,\n          },\n  };\n};\n\nexport const isOverScrollBars = (\n  scrollBars: ScrollBars,\n  x: number,\n  y: number,\n): {\n  isOverEither: boolean;\n  isOverHorizontal: boolean;\n  isOverVertical: boolean;\n} => {\n  const [isOverHorizontal, isOverVertical] = [\n    scrollBars.horizontal,\n    scrollBars.vertical,\n  ].map((scrollBar) => {\n    return (\n      scrollBar != null &&\n      scrollBar.x <= x &&\n      x <= scrollBar.x + scrollBar.width &&\n      scrollBar.y <= y &&\n      y <= scrollBar.y + scrollBar.height\n    );\n  });\n  const isOverEither = isOverHorizontal || isOverVertical;\n  return { isOverEither, isOverHorizontal, isOverVertical };\n};\n",
    "import { sceneCoordsToViewportCoords } from \"@excalidraw/common\";\nimport { getElementAbsoluteCoords } from \"@excalidraw/element\";\n\nimport type {\n  ElementsMap,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport { useExcalidrawAppState } from \"../components/App\";\n\nimport \"./ElementCanvasButtons.scss\";\n\nimport type { AppState } from \"../types\";\n\nconst CONTAINER_PADDING = 5;\n\nconst getContainerCoords = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  elementsMap: ElementsMap,\n) => {\n  const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);\n  const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n    { sceneX: x1 + element.width, sceneY: y1 },\n    appState,\n  );\n  const x = viewportX - appState.offsetLeft + 10;\n  const y = viewportY - appState.offsetTop;\n  return { x, y };\n};\n\nexport const ElementCanvasButtons = ({\n  children,\n  element,\n  elementsMap,\n}: {\n  children: React.ReactNode;\n  element: NonDeletedExcalidrawElement;\n  elementsMap: ElementsMap;\n}) => {\n  const appState = useExcalidrawAppState();\n\n  if (\n    appState.contextMenu ||\n    appState.newElement ||\n    appState.resizingElement ||\n    appState.isRotating ||\n    appState.openMenu ||\n    appState.viewModeEnabled\n  ) {\n    return null;\n  }\n\n  const { x, y } = getContainerCoords(element, appState, elementsMap);\n\n  return (\n    <div\n      className=\"excalidraw-canvas-buttons\"\n      style={{\n        top: `${y}px`,\n        left: `${x}px`,\n        // width: CONTAINER_WIDTH,\n        padding: CONTAINER_PADDING,\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n",
    "import { DEFAULT_LASER_COLOR, easeOut } from \"@excalidraw/common\";\n\nimport type { LaserPointerOptions } from \"@excalidraw/laser-pointer\";\n\nimport { AnimatedTrail } from \"./animated-trail\";\nimport { getClientColor } from \"./clients\";\n\nimport type { Trail } from \"./animated-trail\";\nimport type { AnimationFrameHandler } from \"./animation-frame-handler\";\nimport type App from \"./components/App\";\nimport type { SocketId } from \"./types\";\n\nexport class LaserTrails implements Trail {\n  public localTrail: AnimatedTrail;\n  private collabTrails = new Map<SocketId, AnimatedTrail>();\n\n  private container?: SVGSVGElement;\n\n  constructor(\n    private animationFrameHandler: AnimationFrameHandler,\n    private app: App,\n  ) {\n    this.animationFrameHandler.register(this, this.onFrame.bind(this));\n\n    this.localTrail = new AnimatedTrail(animationFrameHandler, app, {\n      ...this.getTrailOptions(),\n      fill: () => DEFAULT_LASER_COLOR,\n    });\n  }\n\n  private getTrailOptions() {\n    return {\n      simplify: 0,\n      streamline: 0.4,\n      sizeMapping: (c) => {\n        const DECAY_TIME = 1000;\n        const DECAY_LENGTH = 50;\n        const t = Math.max(\n          0,\n          1 - (performance.now() - c.pressure) / DECAY_TIME,\n        );\n        const l =\n          (DECAY_LENGTH -\n            Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) /\n          DECAY_LENGTH;\n\n        return Math.min(easeOut(l), easeOut(t));\n      },\n    } as Partial<LaserPointerOptions>;\n  }\n\n  startPath(x: number, y: number): void {\n    this.localTrail.startPath(x, y);\n  }\n\n  addPointToPath(x: number, y: number): void {\n    this.localTrail.addPointToPath(x, y);\n  }\n\n  endPath(): void {\n    this.localTrail.endPath();\n  }\n\n  start(container: SVGSVGElement) {\n    this.container = container;\n\n    this.animationFrameHandler.start(this);\n    this.localTrail.start(container);\n  }\n\n  stop() {\n    this.animationFrameHandler.stop(this);\n    this.localTrail.stop();\n  }\n\n  onFrame() {\n    this.updateCollabTrails();\n  }\n\n  private updateCollabTrails() {\n    if (!this.container || this.app.state.collaborators.size === 0) {\n      return;\n    }\n\n    for (const [key, collaborator] of this.app.state.collaborators.entries()) {\n      let trail!: AnimatedTrail;\n\n      if (!this.collabTrails.has(key)) {\n        trail = new AnimatedTrail(this.animationFrameHandler, this.app, {\n          ...this.getTrailOptions(),\n          fill: () =>\n            collaborator.pointer?.laserColor ||\n            getClientColor(key, collaborator),\n        });\n        trail.start(this.container);\n\n        this.collabTrails.set(key, trail);\n      } else {\n        trail = this.collabTrails.get(key)!;\n      }\n\n      if (collaborator.pointer && collaborator.pointer.tool === \"laser\") {\n        if (collaborator.button === \"down\" && !trail.hasCurrentTrail) {\n          trail.startPath(collaborator.pointer.x, collaborator.pointer.y);\n        }\n\n        if (\n          collaborator.button === \"down\" &&\n          trail.hasCurrentTrail &&\n          !trail.hasLastPoint(collaborator.pointer.x, collaborator.pointer.y)\n        ) {\n          trail.addPointToPath(collaborator.pointer.x, collaborator.pointer.y);\n        }\n\n        if (collaborator.button === \"up\" && trail.hasCurrentTrail) {\n          trail.addPointToPath(collaborator.pointer.x, collaborator.pointer.y);\n          trail.endPath();\n        }\n      }\n    }\n\n    for (const key of this.collabTrails.keys()) {\n      if (!this.app.state.collaborators.has(key)) {\n        const trail = this.collabTrails.get(key)!;\n        trail.stop();\n        this.collabTrails.delete(key);\n      }\n    }\n  }\n}\n",
    "import { LaserPointer } from \"@excalidraw/laser-pointer\";\n\nimport {\n  SVG_NS,\n  getSvgPathFromStroke,\n  sceneCoordsToViewportCoords,\n} from \"@excalidraw/common\";\n\nimport type { LaserPointerOptions } from \"@excalidraw/laser-pointer\";\n\nimport type { AnimationFrameHandler } from \"./animation-frame-handler\";\nimport type App from \"./components/App\";\nimport type { AppState } from \"./types\";\n\nexport interface Trail {\n  start(container: SVGSVGElement): void;\n  stop(): void;\n\n  startPath(x: number, y: number): void;\n  addPointToPath(x: number, y: number): void;\n  endPath(): void;\n}\n\nexport interface AnimatedTrailOptions {\n  fill: (trail: AnimatedTrail) => string;\n  stroke?: (trail: AnimatedTrail) => string;\n  animateTrail?: boolean;\n}\n\nexport class AnimatedTrail implements Trail {\n  private currentTrail?: LaserPointer;\n  private pastTrails: LaserPointer[] = [];\n\n  private container?: SVGSVGElement;\n  private trailElement: SVGPathElement;\n  private trailAnimation?: SVGAnimateElement;\n\n  constructor(\n    private animationFrameHandler: AnimationFrameHandler,\n    protected app: App,\n    private options: Partial<LaserPointerOptions> &\n      Partial<AnimatedTrailOptions>,\n  ) {\n    this.animationFrameHandler.register(this, this.onFrame.bind(this));\n\n    this.trailElement = document.createElementNS(SVG_NS, \"path\");\n    if (this.options.animateTrail) {\n      this.trailAnimation = document.createElementNS(SVG_NS, \"animate\");\n      // TODO: make this configurable\n      this.trailAnimation.setAttribute(\"attributeName\", \"stroke-dashoffset\");\n      this.trailElement.setAttribute(\"stroke-dasharray\", \"7 7\");\n      this.trailElement.setAttribute(\"stroke-dashoffset\", \"10\");\n      this.trailAnimation.setAttribute(\"from\", \"0\");\n      this.trailAnimation.setAttribute(\"to\", `-14`);\n      this.trailAnimation.setAttribute(\"dur\", \"0.3s\");\n      this.trailElement.appendChild(this.trailAnimation);\n    }\n  }\n\n  get hasCurrentTrail() {\n    return !!this.currentTrail;\n  }\n\n  hasLastPoint(x: number, y: number) {\n    if (this.currentTrail) {\n      const len = this.currentTrail.originalPoints.length;\n      return (\n        this.currentTrail.originalPoints[len - 1][0] === x &&\n        this.currentTrail.originalPoints[len - 1][1] === y\n      );\n    }\n\n    return false;\n  }\n\n  start(container?: SVGSVGElement) {\n    if (container) {\n      this.container = container;\n    }\n\n    if (this.trailElement.parentNode !== this.container && this.container) {\n      this.container.appendChild(this.trailElement);\n    }\n\n    this.animationFrameHandler.start(this);\n  }\n\n  stop() {\n    this.animationFrameHandler.stop(this);\n\n    if (this.trailElement.parentNode === this.container) {\n      this.container?.removeChild(this.trailElement);\n    }\n  }\n\n  startPath(x: number, y: number) {\n    this.currentTrail = new LaserPointer(this.options);\n\n    this.currentTrail.addPoint([x, y, performance.now()]);\n\n    this.update();\n  }\n\n  addPointToPath(x: number, y: number) {\n    if (this.currentTrail) {\n      this.currentTrail.addPoint([x, y, performance.now()]);\n      this.update();\n    }\n  }\n\n  endPath() {\n    if (this.currentTrail) {\n      this.currentTrail.close();\n      this.currentTrail.options.keepHead = false;\n      this.pastTrails.push(this.currentTrail);\n      this.currentTrail = undefined;\n      this.update();\n    }\n  }\n\n  getCurrentTrail() {\n    return this.currentTrail;\n  }\n\n  clearTrails() {\n    this.pastTrails = [];\n    this.currentTrail = undefined;\n    this.update();\n  }\n\n  private update() {\n    this.start();\n    if (this.trailAnimation) {\n      this.trailAnimation.setAttribute(\"begin\", \"indefinite\");\n      this.trailAnimation.setAttribute(\"repeatCount\", \"indefinite\");\n    }\n  }\n\n  private onFrame() {\n    const paths: string[] = [];\n\n    for (const trail of this.pastTrails) {\n      paths.push(this.drawTrail(trail, this.app.state));\n    }\n\n    if (this.currentTrail) {\n      const currentPath = this.drawTrail(this.currentTrail, this.app.state);\n\n      paths.push(currentPath);\n    }\n\n    this.pastTrails = this.pastTrails.filter((trail) => {\n      return trail.getStrokeOutline().length !== 0;\n    });\n\n    if (paths.length === 0) {\n      this.stop();\n    }\n\n    const svgPaths = paths.join(\" \").trim();\n\n    this.trailElement.setAttribute(\"d\", svgPaths);\n    if (this.trailAnimation) {\n      this.trailElement.setAttribute(\n        \"fill\",\n        (this.options.fill ?? (() => \"black\"))(this),\n      );\n      this.trailElement.setAttribute(\n        \"stroke\",\n        (this.options.stroke ?? (() => \"black\"))(this),\n      );\n    } else {\n      this.trailElement.setAttribute(\n        \"fill\",\n        (this.options.fill ?? (() => \"black\"))(this),\n      );\n    }\n  }\n\n  private drawTrail(trail: LaserPointer, state: AppState): string {\n    const _stroke = trail\n      .getStrokeOutline(trail.options.size / state.zoom.value)\n      .map(([x, y]) => {\n        const result = sceneCoordsToViewportCoords(\n          { sceneX: x, sceneY: y },\n          state,\n        );\n\n        return [result.x, result.y];\n      });\n\n    const stroke = this.trailAnimation\n      ? _stroke.slice(0, _stroke.length / 2)\n      : _stroke;\n\n    return getSvgPathFromStroke(stroke, true);\n  }\n}\n",
    "/**\n * @param func handler taking at most single parameter (event).\n */\n\nimport { version as ReactVersion } from \"react\";\nimport { unstable_batchedUpdates } from \"react-dom\";\n\nimport { throttleRAF } from \"@excalidraw/common\";\n\nexport const withBatchedUpdates = <\n  TFunction extends ((event: any) => void) | (() => void),\n>(\n  func: Parameters<TFunction>[\"length\"] extends 0 | 1 ? TFunction : never,\n) =>\n  ((event) => {\n    unstable_batchedUpdates(func as TFunction, event);\n  }) as TFunction;\n\n/**\n * barches React state updates and throttles the calls to a single call per\n * animation frame\n */\nexport const withBatchedUpdatesThrottled = <\n  TFunction extends ((event: any) => void) | (() => void),\n>(\n  func: Parameters<TFunction>[\"length\"] extends 0 | 1 ? TFunction : never,\n) => {\n  // @ts-ignore\n  return throttleRAF<Parameters<TFunction>>(((event) => {\n    unstable_batchedUpdates(func, event);\n  }) as TFunction);\n};\n\nexport const isRenderThrottlingEnabled = (() => {\n  // we don't want to throttle in react < 18 because of #5439 and it was\n  // getting more complex to maintain the fix\n  let IS_REACT_18_AND_UP: boolean;\n  try {\n    const version = ReactVersion.split(\".\");\n    IS_REACT_18_AND_UP = Number(version[0]) > 17;\n  } catch {\n    IS_REACT_18_AND_UP = false;\n  }\n\n  let hasWarned = false;\n\n  return () => {\n    if (window.EXCALIDRAW_THROTTLE_RENDER === true) {\n      if (!IS_REACT_18_AND_UP) {\n        if (!hasWarned) {\n          hasWarned = true;\n          console.warn(\n            \"Excalidraw: render throttling is disabled on React versions < 18.\",\n          );\n        }\n        return false;\n      }\n      return true;\n    }\n    return false;\n  };\n})();\n",
    "import {\n  CODES,\n  KEYS,\n  CLASSES,\n  POINTER_BUTTON,\n  isWritableElement,\n  getFontString,\n  getFontFamilyString,\n  isTestEnv,\n} from \"@excalidraw/common\";\n\nimport {\n  originalContainerCache,\n  updateOriginalContainerCache,\n} from \"@excalidraw/element\";\n\nimport { LinearElementEditor } from \"@excalidraw/element\";\nimport { bumpVersion } from \"@excalidraw/element\";\nimport {\n  getBoundTextElementId,\n  getContainerElement,\n  getTextElementAngle,\n  redrawTextBoundingBox,\n  getBoundTextMaxHeight,\n  getBoundTextMaxWidth,\n  computeContainerDimensionForBoundText,\n  computeBoundTextPosition,\n  getBoundTextElement,\n} from \"@excalidraw/element\";\nimport { getTextWidth } from \"@excalidraw/element\";\nimport { normalizeText } from \"@excalidraw/element\";\nimport { wrapText } from \"@excalidraw/element\";\nimport {\n  isArrowElement,\n  isBoundToContainer,\n  isTextElement,\n} from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  ExcalidrawTextElementWithContainer,\n  ExcalidrawTextElement,\n} from \"@excalidraw/element/types\";\n\nimport { actionSaveToActiveFile } from \"../actions\";\n\nimport { parseClipboard } from \"../clipboard\";\nimport {\n  actionDecreaseFontSize,\n  actionIncreaseFontSize,\n} from \"../actions/actionProperties\";\nimport {\n  actionResetZoom,\n  actionZoomIn,\n  actionZoomOut,\n} from \"../actions/actionCanvas\";\n\nimport type App from \"../components/App\";\nimport type { AppState } from \"../types\";\n\nconst getTransform = (\n  width: number,\n  height: number,\n  angle: number,\n  appState: AppState,\n  maxWidth: number,\n  maxHeight: number,\n) => {\n  const { zoom } = appState;\n  const degree = (180 * angle) / Math.PI;\n  let translateX = (width * (zoom.value - 1)) / 2;\n  let translateY = (height * (zoom.value - 1)) / 2;\n  if (width > maxWidth && zoom.value !== 1) {\n    translateX = (maxWidth * (zoom.value - 1)) / 2;\n  }\n  if (height > maxHeight && zoom.value !== 1) {\n    translateY = (maxHeight * (zoom.value - 1)) / 2;\n  }\n  return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;\n};\n\ntype SubmitHandler = () => void;\n\nexport const textWysiwyg = ({\n  id,\n  onChange,\n  onSubmit,\n  getViewportCoords,\n  element,\n  canvas,\n  excalidrawContainer,\n  app,\n  autoSelect = true,\n}: {\n  id: ExcalidrawElement[\"id\"];\n  /**\n   * textWysiwyg only deals with `originalText`\n   *\n   * Note: `text`, which can be wrapped and therefore different from `originalText`,\n   *       is derived from `originalText`\n   */\n  onChange?: (nextOriginalText: string) => void;\n  onSubmit: (data: { viaKeyboard: boolean; nextOriginalText: string }) => void;\n  getViewportCoords: (x: number, y: number) => [number, number];\n  element: ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  excalidrawContainer: HTMLDivElement | null;\n  app: App;\n  autoSelect?: boolean;\n}): SubmitHandler => {\n  const textPropertiesUpdated = (\n    updatedTextElement: ExcalidrawTextElement,\n    editable: HTMLTextAreaElement,\n  ) => {\n    if (!editable.style.fontFamily || !editable.style.fontSize) {\n      return false;\n    }\n    const currentFont = editable.style.fontFamily.replace(/\"/g, \"\");\n    if (\n      getFontFamilyString({ fontFamily: updatedTextElement.fontFamily }) !==\n      currentFont\n    ) {\n      return true;\n    }\n    if (`${updatedTextElement.fontSize}px` !== editable.style.fontSize) {\n      return true;\n    }\n    return false;\n  };\n\n  const updateWysiwygStyle = () => {\n    const appState = app.state;\n    const updatedTextElement = app.scene.getElement<ExcalidrawTextElement>(id);\n\n    if (!updatedTextElement) {\n      return;\n    }\n    const { textAlign, verticalAlign } = updatedTextElement;\n    const elementsMap = app.scene.getNonDeletedElementsMap();\n    if (updatedTextElement && isTextElement(updatedTextElement)) {\n      let coordX = updatedTextElement.x;\n      let coordY = updatedTextElement.y;\n      const container = getContainerElement(\n        updatedTextElement,\n        app.scene.getNonDeletedElementsMap(),\n      );\n\n      let width = updatedTextElement.width;\n\n      // set to element height by default since that's\n      // what is going to be used for unbounded text\n      let height = updatedTextElement.height;\n\n      let maxWidth = updatedTextElement.width;\n      let maxHeight = updatedTextElement.height;\n\n      if (container && updatedTextElement.containerId) {\n        if (isArrowElement(container)) {\n          const boundTextCoords =\n            LinearElementEditor.getBoundTextElementPosition(\n              container,\n              updatedTextElement as ExcalidrawTextElementWithContainer,\n              elementsMap,\n            );\n          coordX = boundTextCoords.x;\n          coordY = boundTextCoords.y;\n        }\n        const propertiesUpdated = textPropertiesUpdated(\n          updatedTextElement,\n          editable,\n        );\n\n        let originalContainerData;\n        if (propertiesUpdated) {\n          originalContainerData = updateOriginalContainerCache(\n            container.id,\n            container.height,\n          );\n        } else {\n          originalContainerData = originalContainerCache[container.id];\n          if (!originalContainerData) {\n            originalContainerData = updateOriginalContainerCache(\n              container.id,\n              container.height,\n            );\n          }\n        }\n\n        maxWidth = getBoundTextMaxWidth(container, updatedTextElement);\n        maxHeight = getBoundTextMaxHeight(\n          container,\n          updatedTextElement as ExcalidrawTextElementWithContainer,\n        );\n\n        // autogrow container height if text exceeds\n        if (!isArrowElement(container) && height > maxHeight) {\n          const targetContainerHeight = computeContainerDimensionForBoundText(\n            height,\n            container.type,\n          );\n\n          app.scene.mutateElement(container, { height: targetContainerHeight });\n          return;\n        } else if (\n          // autoshrink container height until original container height\n          // is reached when text is removed\n          !isArrowElement(container) &&\n          container.height > originalContainerData.height &&\n          height < maxHeight\n        ) {\n          const targetContainerHeight = computeContainerDimensionForBoundText(\n            height,\n            container.type,\n          );\n          app.scene.mutateElement(container, { height: targetContainerHeight });\n        } else {\n          const { y } = computeBoundTextPosition(\n            container,\n            updatedTextElement as ExcalidrawTextElementWithContainer,\n            elementsMap,\n          );\n          coordY = y;\n        }\n      }\n      const [viewportX, viewportY] = getViewportCoords(coordX, coordY);\n      const initialSelectionStart = editable.selectionStart;\n      const initialSelectionEnd = editable.selectionEnd;\n      const initialLength = editable.value.length;\n\n      // restore cursor position after value updated so it doesn't\n      // go to the end of text when container auto expanded\n      if (\n        initialSelectionStart === initialSelectionEnd &&\n        initialSelectionEnd !== initialLength\n      ) {\n        // get diff between length and selection end and shift\n        // the cursor by \"diff\" times to position correctly\n        const diff = initialLength - initialSelectionEnd;\n        editable.selectionStart = editable.value.length - diff;\n        editable.selectionEnd = editable.value.length - diff;\n      }\n\n      if (!container) {\n        maxWidth = (appState.width - 8 - viewportX) / appState.zoom.value;\n        width = Math.min(width, maxWidth);\n      } else {\n        width += 0.5;\n      }\n\n      // add 5% buffer otherwise it causes wysiwyg to jump\n      height *= 1.05;\n\n      const font = getFontString(updatedTextElement);\n\n      // Make sure text editor height doesn't go beyond viewport\n      const editorMaxHeight =\n        (appState.height - viewportY) / appState.zoom.value;\n      Object.assign(editable.style, {\n        font,\n        // must be defined *after* font ¯\\_(ツ)_/¯\n        lineHeight: updatedTextElement.lineHeight,\n        width: `${width}px`,\n        height: `${height}px`,\n        left: `${viewportX}px`,\n        top: `${viewportY}px`,\n        transform: getTransform(\n          width,\n          height,\n          getTextElementAngle(updatedTextElement, container),\n          appState,\n          maxWidth,\n          editorMaxHeight,\n        ),\n        textAlign,\n        verticalAlign,\n        color: updatedTextElement.strokeColor,\n        opacity: updatedTextElement.opacity / 100,\n        filter: \"var(--theme-filter)\",\n        maxHeight: `${editorMaxHeight}px`,\n      });\n      editable.scrollTop = 0;\n      // For some reason updating font attribute doesn't set font family\n      // hence updating font family explicitly for test environment\n      if (isTestEnv()) {\n        editable.style.fontFamily = getFontFamilyString(updatedTextElement);\n      }\n\n      app.scene.mutateElement(updatedTextElement, { x: coordX, y: coordY });\n    }\n  };\n\n  const editable = document.createElement(\"textarea\");\n\n  editable.dir = \"auto\";\n  editable.tabIndex = 0;\n  editable.dataset.type = \"wysiwyg\";\n  // prevent line wrapping on Safari\n  editable.wrap = \"off\";\n  editable.classList.add(\"excalidraw-wysiwyg\");\n\n  let whiteSpace = \"pre\";\n  let wordBreak = \"normal\";\n\n  if (isBoundToContainer(element) || !element.autoResize) {\n    whiteSpace = \"pre-wrap\";\n    wordBreak = \"break-word\";\n  }\n  Object.assign(editable.style, {\n    position: \"absolute\",\n    display: \"inline-block\",\n    minHeight: \"1em\",\n    backfaceVisibility: \"hidden\",\n    margin: 0,\n    padding: 0,\n    border: 0,\n    outline: 0,\n    resize: \"none\",\n    background: \"transparent\",\n    overflow: \"hidden\",\n    // must be specified because in dark mode canvas creates a stacking context\n    zIndex: \"var(--zIndex-wysiwyg)\",\n    wordBreak,\n    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)\n    whiteSpace,\n    overflowWrap: \"break-word\",\n    boxSizing: \"content-box\",\n  });\n  editable.value = element.originalText;\n  updateWysiwygStyle();\n\n  if (onChange) {\n    editable.onpaste = async (event) => {\n      const clipboardData = await parseClipboard(event, true);\n      if (!clipboardData.text) {\n        return;\n      }\n      const data = normalizeText(clipboardData.text);\n      if (!data) {\n        return;\n      }\n      const container = getContainerElement(\n        element,\n        app.scene.getNonDeletedElementsMap(),\n      );\n\n      const font = getFontString({\n        fontSize: app.state.currentItemFontSize,\n        fontFamily: app.state.currentItemFontFamily,\n      });\n      if (container) {\n        const boundTextElement = getBoundTextElement(\n          container,\n          app.scene.getNonDeletedElementsMap(),\n        );\n        const wrappedText = wrapText(\n          `${editable.value}${data}`,\n          font,\n          getBoundTextMaxWidth(container, boundTextElement),\n        );\n        const width = getTextWidth(wrappedText, font);\n        editable.style.width = `${width}px`;\n      }\n    };\n\n    editable.oninput = () => {\n      const normalized = normalizeText(editable.value);\n      if (editable.value !== normalized) {\n        const selectionStart = editable.selectionStart;\n        editable.value = normalized;\n        // put the cursor at some position close to where it was before\n        // normalization (otherwise it'll end up at the end of the text)\n        editable.selectionStart = selectionStart;\n        editable.selectionEnd = selectionStart;\n      }\n      onChange(editable.value);\n    };\n  }\n\n  editable.onkeydown = (event) => {\n    if (!event.shiftKey && actionZoomIn.keyTest(event)) {\n      event.preventDefault();\n      app.actionManager.executeAction(actionZoomIn);\n      updateWysiwygStyle();\n    } else if (!event.shiftKey && actionZoomOut.keyTest(event)) {\n      event.preventDefault();\n      app.actionManager.executeAction(actionZoomOut);\n      updateWysiwygStyle();\n    } else if (!event.shiftKey && actionResetZoom.keyTest(event)) {\n      event.preventDefault();\n      app.actionManager.executeAction(actionResetZoom);\n      updateWysiwygStyle();\n    } else if (actionDecreaseFontSize.keyTest(event)) {\n      app.actionManager.executeAction(actionDecreaseFontSize);\n    } else if (actionIncreaseFontSize.keyTest(event)) {\n      app.actionManager.executeAction(actionIncreaseFontSize);\n    } else if (event.key === KEYS.ESCAPE) {\n      event.preventDefault();\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (actionSaveToActiveFile.keyTest(event)) {\n      event.preventDefault();\n      handleSubmit();\n      app.actionManager.executeAction(actionSaveToActiveFile);\n    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {\n      event.preventDefault();\n      if (event.isComposing || event.keyCode === 229) {\n        return;\n      }\n      submittedViaKeyboard = true;\n      handleSubmit();\n    } else if (\n      event.key === KEYS.TAB ||\n      (event[KEYS.CTRL_OR_CMD] &&\n        (event.code === CODES.BRACKET_LEFT ||\n          event.code === CODES.BRACKET_RIGHT))\n    ) {\n      event.preventDefault();\n      if (event.isComposing) {\n        return;\n      } else if (event.shiftKey || event.code === CODES.BRACKET_LEFT) {\n        outdent();\n      } else {\n        indent();\n      }\n      // We must send an input event to resize the element\n      editable.dispatchEvent(new Event(\"input\"));\n    }\n  };\n\n  const TAB_SIZE = 4;\n  const TAB = \" \".repeat(TAB_SIZE);\n  const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);\n  const indent = () => {\n    const { selectionStart, selectionEnd } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n\n    let value = editable.value;\n    linesStartIndices.forEach((startIndex: number) => {\n      const startValue = value.slice(0, startIndex);\n      const endValue = value.slice(startIndex);\n\n      value = `${startValue}${TAB}${endValue}`;\n    });\n\n    editable.value = value;\n\n    editable.selectionStart = selectionStart + TAB_SIZE;\n    editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;\n  };\n\n  const outdent = () => {\n    const { selectionStart, selectionEnd } = editable;\n    const linesStartIndices = getSelectedLinesStartIndices();\n    const removedTabs: number[] = [];\n\n    let value = editable.value;\n    linesStartIndices.forEach((startIndex) => {\n      const tabMatch = value\n        .slice(startIndex, startIndex + TAB_SIZE)\n        .match(RE_LEADING_TAB);\n\n      if (tabMatch) {\n        const startValue = value.slice(0, startIndex);\n        const endValue = value.slice(startIndex + tabMatch[0].length);\n\n        // Delete a tab from the line\n        value = `${startValue}${endValue}`;\n        removedTabs.push(startIndex);\n      }\n    });\n\n    editable.value = value;\n\n    if (removedTabs.length) {\n      if (selectionStart > removedTabs[removedTabs.length - 1]) {\n        editable.selectionStart = Math.max(\n          selectionStart - TAB_SIZE,\n          removedTabs[removedTabs.length - 1],\n        );\n      } else {\n        // If the cursor is before the first tab removed, ex:\n        // Line| #1\n        //     Line #2\n        // Lin|e #3\n        // we should reset the selectionStart to his initial value.\n        editable.selectionStart = selectionStart;\n      }\n      editable.selectionEnd = Math.max(\n        editable.selectionStart,\n        selectionEnd - TAB_SIZE * removedTabs.length,\n      );\n    }\n  };\n\n  /**\n   * @returns indices of start positions of selected lines, in reverse order\n   */\n  const getSelectedLinesStartIndices = () => {\n    let { selectionStart, selectionEnd, value } = editable;\n\n    // chars before selectionStart on the same line\n    const startOffset = value.slice(0, selectionStart).match(/[^\\n]*$/)![0]\n      .length;\n    // put caret at the start of the line\n    selectionStart = selectionStart - startOffset;\n\n    const selected = value.slice(selectionStart, selectionEnd);\n\n    return selected\n      .split(\"\\n\")\n      .reduce(\n        (startIndices, line, idx, lines) =>\n          startIndices.concat(\n            idx\n              ? // curr line index is prev line's start + prev line's length + \\n\n                startIndices[idx - 1] + lines[idx - 1].length + 1\n              : // first selected line\n                selectionStart,\n          ),\n        [] as number[],\n      )\n      .reverse();\n  };\n\n  const stopEvent = (event: Event) => {\n    if (event.target instanceof HTMLCanvasElement) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  // using a state variable instead of passing it to the handleSubmit callback\n  // so that we don't need to create separate a callback for event handlers\n  let submittedViaKeyboard = false;\n  const handleSubmit = () => {\n    // prevent double submit\n    if (isDestroyed) {\n      return;\n    }\n    isDestroyed = true;\n    // cleanup must be run before onSubmit otherwise when app blurs the wysiwyg\n    // it'd get stuck in an infinite loop of blur→onSubmit after we re-focus the\n    // wysiwyg on update\n    cleanup();\n    const updateElement = app.scene.getElement(\n      element.id,\n    ) as ExcalidrawTextElement;\n    if (!updateElement) {\n      return;\n    }\n    const container = getContainerElement(\n      updateElement,\n      app.scene.getNonDeletedElementsMap(),\n    );\n\n    if (container) {\n      if (editable.value.trim()) {\n        const boundTextElementId = getBoundTextElementId(container);\n        if (!boundTextElementId || boundTextElementId !== element.id) {\n          app.scene.mutateElement(container, {\n            boundElements: (container.boundElements || []).concat({\n              type: \"text\",\n              id: element.id,\n            }),\n          });\n        } else if (isArrowElement(container)) {\n          // updating an arrow label may change bounds, prevent stale cache:\n          bumpVersion(container);\n        }\n      } else {\n        app.scene.mutateElement(container, {\n          boundElements: container.boundElements?.filter(\n            (ele) =>\n              !isTextElement(\n                ele as ExcalidrawTextElement | ExcalidrawLinearElement,\n              ),\n          ),\n        });\n      }\n\n      redrawTextBoundingBox(updateElement, container, app.scene);\n    }\n\n    onSubmit({\n      viaKeyboard: submittedViaKeyboard,\n      nextOriginalText: editable.value,\n    });\n  };\n\n  const cleanup = () => {\n    // remove events to ensure they don't late-fire\n    editable.onblur = null;\n    editable.oninput = null;\n    editable.onkeydown = null;\n\n    if (observer) {\n      observer.disconnect();\n    }\n\n    window.removeEventListener(\"resize\", updateWysiwygStyle);\n    window.removeEventListener(\"wheel\", stopEvent, true);\n    window.removeEventListener(\"pointerdown\", onPointerDown);\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    window.removeEventListener(\"blur\", handleSubmit);\n    window.removeEventListener(\"beforeunload\", handleSubmit);\n    unbindUpdate();\n    unbindOnScroll();\n\n    editable.remove();\n  };\n\n  const bindBlurEvent = (event?: MouseEvent) => {\n    window.removeEventListener(\"pointerup\", bindBlurEvent);\n    // Deferred so that the pointerdown that initiates the wysiwyg doesn't\n    // trigger the blur on ensuing pointerup.\n    // Also to handle cases such as picking a color which would trigger a blur\n    // in that same tick.\n    const target = event?.target;\n\n    const isPropertiesTrigger =\n      target instanceof HTMLElement &&\n      target.classList.contains(\"properties-trigger\");\n\n    setTimeout(() => {\n      editable.onblur = handleSubmit;\n\n      // case: clicking on the same property → no change → no update → no focus\n      if (!isPropertiesTrigger) {\n        editable.focus();\n      }\n    });\n  };\n\n  const temporarilyDisableSubmit = () => {\n    editable.onblur = null;\n    window.addEventListener(\"pointerup\", bindBlurEvent);\n    // handle edge-case where pointerup doesn't fire e.g. due to user\n    // alt-tabbing away\n    window.addEventListener(\"blur\", handleSubmit);\n  };\n\n  // prevent blur when changing properties from the menu\n  const onPointerDown = (event: MouseEvent) => {\n    const target = event?.target;\n\n    // panning canvas\n    if (event.button === POINTER_BUTTON.WHEEL) {\n      // trying to pan by clicking inside text area itself -> handle here\n      if (target instanceof HTMLTextAreaElement) {\n        event.preventDefault();\n        app.handleCanvasPanUsingWheelOrSpaceDrag(event);\n      }\n      temporarilyDisableSubmit();\n      return;\n    }\n\n    const isPropertiesTrigger =\n      target instanceof HTMLElement &&\n      target.classList.contains(\"properties-trigger\");\n\n    if (\n      ((event.target instanceof HTMLElement ||\n        event.target instanceof SVGElement) &&\n        event.target.closest(\n          `.${CLASSES.SHAPE_ACTIONS_MENU}, .${CLASSES.ZOOM_ACTIONS}`,\n        ) &&\n        !isWritableElement(event.target)) ||\n      isPropertiesTrigger\n    ) {\n      temporarilyDisableSubmit();\n    } else if (\n      event.target instanceof HTMLCanvasElement &&\n      // Vitest simply ignores stopPropagation, capture-mode, or rAF\n      // so without introducing crazier hacks, nothing we can do\n      !isTestEnv()\n    ) {\n      // On mobile, blur event doesn't seem to always fire correctly,\n      // so we want to also submit on pointerdown outside the wysiwyg.\n      // Done in the next frame to prevent pointerdown from creating a new text\n      // immediately (if tools locked) so that users on mobile have chance\n      // to submit first (to hide virtual keyboard).\n      // Note: revisit if we want to differ this behavior on Desktop\n      requestAnimationFrame(() => {\n        handleSubmit();\n      });\n    }\n  };\n\n  // handle updates of textElement properties of editing element\n  const unbindUpdate = app.scene.onUpdate(() => {\n    updateWysiwygStyle();\n    const isPopupOpened = !!document.activeElement?.closest(\n      \".properties-content\",\n    );\n    if (!isPopupOpened) {\n      editable.focus();\n    }\n  });\n\n  const unbindOnScroll = app.onScrollChangeEmitter.on(() => {\n    updateWysiwygStyle();\n  });\n\n  // ---------------------------------------------------------------------------\n\n  let isDestroyed = false;\n\n  if (autoSelect) {\n    // select on init (focusing is done separately inside the bindBlurEvent()\n    // because we need it to happen *after* the blur event from `pointerdown`)\n    editable.select();\n  }\n  bindBlurEvent();\n\n  // reposition wysiwyg in case of canvas is resized. Using ResizeObserver\n  // is preferred so we catch changes from host, where window may not resize.\n  let observer: ResizeObserver | null = null;\n  if (canvas && \"ResizeObserver\" in window) {\n    observer = new window.ResizeObserver(() => {\n      updateWysiwygStyle();\n    });\n    observer.observe(canvas);\n  } else {\n    window.addEventListener(\"resize\", updateWysiwygStyle);\n  }\n\n  editable.onpointerdown = (event) => event.stopPropagation();\n\n  // rAF (+ capture to by doubly sure) so we don't catch te pointerdown that\n  // triggered the wysiwyg\n  requestAnimationFrame(() => {\n    window.addEventListener(\"pointerdown\", onPointerDown, { capture: true });\n  });\n  window.addEventListener(\"beforeunload\", handleSubmit);\n  excalidrawContainer\n    ?.querySelector(\".excalidraw-textEditorContainer\")!\n    .appendChild(editable);\n\n  return handleSubmit;\n};\n",
    "/** heuristically checks whether the text may be a mermaid diagram definition */\nexport const isMaybeMermaidDefinition = (text: string) => {\n  const chartTypes = [\n    \"flowchart\",\n    \"graph\",\n    \"sequenceDiagram\",\n    \"classDiagram\",\n    \"stateDiagram\",\n    \"stateDiagram-v2\",\n    \"erDiagram\",\n    \"journey\",\n    \"gantt\",\n    \"pie\",\n    \"quadrantChart\",\n    \"requirementDiagram\",\n    \"gitGraph\",\n    \"C4Context\",\n    \"mindmap\",\n    \"timeline\",\n    \"zenuml\",\n    \"sankey\",\n    \"xychart\",\n    \"block\",\n  ];\n\n  const re = new RegExp(\n    `^(?:%%{.*?}%%[\\\\s\\\\n]*)?\\\\b(?:${chartTypes\n      .map((x) => `\\\\s*${x}(-beta)?`)\n      .join(\"|\")})\\\\b`,\n  );\n\n  return re.test(text.trim());\n};\n",
    "import {\n  type GlobalPoint,\n  type LineSegment,\n  pointFrom,\n} from \"@excalidraw/math\";\n\nimport { getElementLineSegments } from \"@excalidraw/element\";\nimport { LinearElementEditor } from \"@excalidraw/element\";\nimport {\n  isFrameLikeElement,\n  isLinearElement,\n  isTextElement,\n} from \"@excalidraw/element\";\n\nimport { getFrameChildren } from \"@excalidraw/element\";\nimport { selectGroupsForSelectedElements } from \"@excalidraw/element\";\n\nimport { getContainerElement } from \"@excalidraw/element\";\n\nimport { arrayToMap, easeOut, isShallowEqual } from \"@excalidraw/common\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawLinearElement,\n  NonDeleted,\n} from \"@excalidraw/element/types\";\n\nimport { type AnimationFrameHandler } from \"../animation-frame-handler\";\n\nimport { AnimatedTrail } from \"../animated-trail\";\n\nimport { getLassoSelectedElementIds } from \"./utils\";\n\nimport type App from \"../components/App\";\n\ntype CanvasTranslate = {\n  scrollX: number;\n  scrollY: number;\n  zoom: number;\n};\n\nexport class LassoTrail extends AnimatedTrail {\n  private intersectedElements: Set<ExcalidrawElement[\"id\"]> = new Set();\n  private enclosedElements: Set<ExcalidrawElement[\"id\"]> = new Set();\n  private elementsSegments: Map<string, LineSegment<GlobalPoint>[]> | null =\n    null;\n  private canvasTranslate: CanvasTranslate | null = null;\n  private keepPreviousSelection: boolean = false;\n\n  constructor(animationFrameHandler: AnimationFrameHandler, app: App) {\n    super(animationFrameHandler, app, {\n      animateTrail: true,\n      streamline: 0.4,\n      sizeMapping: (c) => {\n        const DECAY_TIME = Infinity;\n        const DECAY_LENGTH = 5000;\n        const t = Math.max(\n          0,\n          1 - (performance.now() - c.pressure) / DECAY_TIME,\n        );\n        const l =\n          (DECAY_LENGTH -\n            Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) /\n          DECAY_LENGTH;\n\n        return Math.min(easeOut(l), easeOut(t));\n      },\n      fill: () => \"rgba(105,101,219,0.05)\",\n      stroke: () => \"rgba(105,101,219)\",\n    });\n  }\n\n  startPath(x: number, y: number, keepPreviousSelection = false) {\n    // clear any existing trails just in case\n    this.endPath();\n\n    super.startPath(x, y);\n    this.intersectedElements.clear();\n    this.enclosedElements.clear();\n\n    this.keepPreviousSelection = keepPreviousSelection;\n\n    if (!this.keepPreviousSelection) {\n      this.app.setState({\n        selectedElementIds: {},\n        selectedGroupIds: {},\n        selectedLinearElement: null,\n      });\n    }\n  }\n\n  selectElementsFromIds = (ids: string[]) => {\n    this.app.setState((prevState) => {\n      const nextSelectedElementIds = ids.reduce((acc, id) => {\n        acc[id] = true;\n        return acc;\n      }, {} as Record<ExcalidrawElement[\"id\"], true>);\n\n      if (this.keepPreviousSelection) {\n        for (const id of Object.keys(prevState.selectedElementIds)) {\n          nextSelectedElementIds[id] = true;\n        }\n      }\n\n      for (const [id] of Object.entries(nextSelectedElementIds)) {\n        const element = this.app.scene.getNonDeletedElement(id);\n\n        if (element && isTextElement(element)) {\n          const container = getContainerElement(\n            element,\n            this.app.scene.getNonDeletedElementsMap(),\n          );\n          if (container) {\n            nextSelectedElementIds[container.id] = true;\n            delete nextSelectedElementIds[element.id];\n          }\n        }\n      }\n\n      // remove all children of selected frames\n      for (const [id] of Object.entries(nextSelectedElementIds)) {\n        const element = this.app.scene.getNonDeletedElement(id);\n\n        if (element && isFrameLikeElement(element)) {\n          const elementsInFrame = getFrameChildren(\n            this.app.scene.getNonDeletedElementsMap(),\n            element.id,\n          );\n          for (const child of elementsInFrame) {\n            delete nextSelectedElementIds[child.id];\n          }\n        }\n      }\n\n      const nextSelection = selectGroupsForSelectedElements(\n        {\n          editingGroupId: prevState.editingGroupId,\n          selectedElementIds: nextSelectedElementIds,\n        },\n        this.app.scene.getNonDeletedElements(),\n        prevState,\n        this.app,\n      );\n\n      const selectedIds = [...Object.keys(nextSelection.selectedElementIds)];\n      const selectedGroupIds = [...Object.keys(nextSelection.selectedGroupIds)];\n\n      return {\n        selectedElementIds: nextSelection.selectedElementIds,\n        selectedGroupIds: nextSelection.selectedGroupIds,\n        selectedLinearElement:\n          selectedIds.length === 1 &&\n          !selectedGroupIds.length &&\n          isLinearElement(this.app.scene.getNonDeletedElement(selectedIds[0]))\n            ? new LinearElementEditor(\n                this.app.scene.getNonDeletedElement(\n                  selectedIds[0],\n                ) as NonDeleted<ExcalidrawLinearElement>,\n                this.app.scene.getNonDeletedElementsMap(),\n              )\n            : null,\n      };\n    });\n  };\n\n  addPointToPath = (x: number, y: number, keepPreviousSelection = false) => {\n    super.addPointToPath(x, y);\n\n    this.keepPreviousSelection = keepPreviousSelection;\n\n    this.updateSelection();\n  };\n\n  private updateSelection = () => {\n    const lassoPath = super\n      .getCurrentTrail()\n      ?.originalPoints?.map((p) => pointFrom<GlobalPoint>(p[0], p[1]));\n\n    const currentCanvasTranslate: CanvasTranslate = {\n      scrollX: this.app.state.scrollX,\n      scrollY: this.app.state.scrollY,\n      zoom: this.app.state.zoom.value,\n    };\n\n    if (\n      !this.elementsSegments ||\n      !isShallowEqual(currentCanvasTranslate, this.canvasTranslate ?? {})\n    ) {\n      this.canvasTranslate = currentCanvasTranslate;\n      this.elementsSegments = new Map();\n      const visibleElementsMap = arrayToMap(this.app.visibleElements);\n      for (const element of this.app.visibleElements) {\n        const segments = getElementLineSegments(element, visibleElementsMap);\n        this.elementsSegments.set(element.id, segments);\n      }\n    }\n\n    if (lassoPath) {\n      const { selectedElementIds } = getLassoSelectedElementIds({\n        lassoPath,\n        elements: this.app.visibleElements,\n        elementsMap: this.app.scene.getNonDeletedElementsMap(),\n        elementsSegments: this.elementsSegments,\n        intersectedElements: this.intersectedElements,\n        enclosedElements: this.enclosedElements,\n        simplifyDistance: 5 / this.app.state.zoom.value,\n      });\n\n      this.selectElementsFromIds(selectedElementIds);\n    }\n  };\n\n  endPath(): void {\n    super.endPath();\n    super.clearTrails();\n    this.intersectedElements.clear();\n    this.enclosedElements.clear();\n    this.elementsSegments = null;\n  }\n}\n",
    "import { simplify } from \"points-on-curve\";\n\nimport {\n  polygonFromPoints,\n  lineSegment,\n  polygonIncludesPointNonZero,\n} from \"@excalidraw/math\";\n\nimport {\n  type Bounds,\n  computeBoundTextPosition,\n  doBoundsIntersect,\n  getBoundTextElement,\n  getElementBounds,\n  intersectElementWithLineSegment,\n} from \"@excalidraw/element\";\n\nimport type { ElementsSegmentsMap, GlobalPoint } from \"@excalidraw/math/types\";\nimport type { ElementsMap, ExcalidrawElement } from \"@excalidraw/element/types\";\n\nexport const getLassoSelectedElementIds = (input: {\n  lassoPath: GlobalPoint[];\n  elements: readonly ExcalidrawElement[];\n  elementsMap: ElementsMap;\n  elementsSegments: ElementsSegmentsMap;\n  intersectedElements: Set<ExcalidrawElement[\"id\"]>;\n  enclosedElements: Set<ExcalidrawElement[\"id\"]>;\n  simplifyDistance?: number;\n}): {\n  selectedElementIds: string[];\n} => {\n  const {\n    lassoPath,\n    elements,\n    elementsMap,\n    elementsSegments,\n    intersectedElements,\n    enclosedElements,\n    simplifyDistance,\n  } = input;\n  // simplify the path to reduce the number of points\n  let path: GlobalPoint[] = lassoPath;\n  if (simplifyDistance) {\n    path = simplify(lassoPath, simplifyDistance) as GlobalPoint[];\n  }\n  const unlockedElements = elements.filter((el) => !el.locked);\n  // as the path might not enclose a shape anymore, clear before checking\n  enclosedElements.clear();\n  intersectedElements.clear();\n  const lassoBounds = lassoPath.reduce(\n    (acc, item) => {\n      return [\n        Math.min(acc[0], item[0]),\n        Math.min(acc[1], item[1]),\n        Math.max(acc[2], item[0]),\n        Math.max(acc[3], item[1]),\n      ];\n    },\n    [Infinity, Infinity, -Infinity, -Infinity],\n  ) as Bounds;\n  for (const element of unlockedElements) {\n    // First check if the lasso segment intersects the element's axis-aligned\n    // bounding box as it is much faster than checking intersection against\n    // the element's shape\n    const elementBounds = getElementBounds(element, elementsMap);\n\n    if (\n      doBoundsIntersect(lassoBounds, elementBounds) &&\n      !intersectedElements.has(element.id) &&\n      !enclosedElements.has(element.id)\n    ) {\n      const enclosed = enclosureTest(path, element, elementsSegments);\n      if (enclosed) {\n        enclosedElements.add(element.id);\n      } else {\n        const intersects = intersectionTest(path, element, elementsMap);\n        if (intersects) {\n          intersectedElements.add(element.id);\n        }\n      }\n    }\n  }\n\n  const results = [...intersectedElements, ...enclosedElements];\n\n  return {\n    selectedElementIds: results,\n  };\n};\n\nconst enclosureTest = (\n  lassoPath: GlobalPoint[],\n  element: ExcalidrawElement,\n  elementsSegments: ElementsSegmentsMap,\n): boolean => {\n  const lassoPolygon = polygonFromPoints(lassoPath);\n  const segments = elementsSegments.get(element.id);\n  if (!segments) {\n    return false;\n  }\n\n  return segments.some((segment) => {\n    return segment.some((point) =>\n      polygonIncludesPointNonZero(point, lassoPolygon),\n    );\n  });\n};\n\nconst intersectionTest = (\n  lassoPath: GlobalPoint[],\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): boolean => {\n  const lassoSegments = lassoPath\n    .slice(1)\n    .map((point: GlobalPoint, index) => lineSegment(lassoPath[index], point))\n    .concat([lineSegment(lassoPath[lassoPath.length - 1], lassoPath[0])]);\n\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n\n  return lassoSegments.some(\n    (lassoSegment) =>\n      intersectElementWithLineSegment(\n        element,\n        elementsMap,\n        lassoSegment,\n        0,\n        true,\n      ).length > 0 ||\n      (!!boundTextElement &&\n        intersectElementWithLineSegment(\n          {\n            ...boundTextElement,\n            ...computeBoundTextPosition(element, boundTextElement, elementsMap),\n          },\n          elementsMap,\n          lassoSegment,\n          0,\n          true,\n        ).length > 0),\n  );\n};\n",
    "import { arrayToMap, easeOut, THEME } from \"@excalidraw/common\";\nimport {\n  computeBoundTextPosition,\n  getBoundTextElement,\n  intersectElementWithLineSegment,\n  isPointInElement,\n} from \"@excalidraw/element\";\nimport { lineSegment, pointFrom } from \"@excalidraw/math\";\n\nimport { getElementsInGroup } from \"@excalidraw/element\";\n\nimport { shouldTestInside } from \"@excalidraw/element\";\nimport { hasBoundTextElement, isBoundToContainer } from \"@excalidraw/element\";\nimport { getBoundTextElementId } from \"@excalidraw/element\";\n\nimport type { GlobalPoint, LineSegment } from \"@excalidraw/math/types\";\nimport type { ElementsMap, ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { AnimatedTrail } from \"../animated-trail\";\n\nimport type { AnimationFrameHandler } from \"../animation-frame-handler\";\n\nimport type App from \"../components/App\";\n\nexport class EraserTrail extends AnimatedTrail {\n  private elementsToErase: Set<ExcalidrawElement[\"id\"]> = new Set();\n  private groupsToErase: Set<ExcalidrawElement[\"id\"]> = new Set();\n\n  constructor(animationFrameHandler: AnimationFrameHandler, app: App) {\n    super(animationFrameHandler, app, {\n      streamline: 0.2,\n      size: 5,\n      keepHead: true,\n      sizeMapping: (c) => {\n        const DECAY_TIME = 200;\n        const DECAY_LENGTH = 10;\n        const t = Math.max(\n          0,\n          1 - (performance.now() - c.pressure) / DECAY_TIME,\n        );\n        const l =\n          (DECAY_LENGTH -\n            Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) /\n          DECAY_LENGTH;\n\n        return Math.min(easeOut(l), easeOut(t));\n      },\n      fill: () =>\n        app.state.theme === THEME.LIGHT\n          ? \"rgba(0, 0, 0, 0.2)\"\n          : \"rgba(255, 255, 255, 0.2)\",\n    });\n  }\n\n  startPath(x: number, y: number): void {\n    this.endPath();\n    super.startPath(x, y);\n    this.elementsToErase.clear();\n  }\n\n  addPointToPath(x: number, y: number, restore = false) {\n    super.addPointToPath(x, y);\n\n    const elementsToEraser = this.updateElementsToBeErased(restore);\n\n    return elementsToEraser;\n  }\n\n  private updateElementsToBeErased(restoreToErase?: boolean) {\n    const eraserPath: GlobalPoint[] =\n      super\n        .getCurrentTrail()\n        ?.originalPoints?.map((p) => pointFrom<GlobalPoint>(p[0], p[1])) || [];\n\n    if (eraserPath.length < 2) {\n      return [];\n    }\n\n    // for efficiency and avoid unnecessary calculations,\n    // take only POINTS_ON_TRAIL points to form some number of segments\n    const pathSegment = lineSegment<GlobalPoint>(\n      eraserPath[eraserPath.length - 1],\n      eraserPath[eraserPath.length - 2],\n    );\n\n    const candidateElements = this.app.visibleElements.filter(\n      (el) => !el.locked,\n    );\n\n    const candidateElementsMap = arrayToMap(candidateElements);\n\n    for (const element of candidateElements) {\n      // restore only if already added to the to-be-erased set\n      if (restoreToErase && this.elementsToErase.has(element.id)) {\n        const intersects = eraserTest(\n          pathSegment,\n          element,\n          candidateElementsMap,\n        );\n\n        if (intersects) {\n          const shallowestGroupId = element.groupIds.at(-1)!;\n\n          if (this.groupsToErase.has(shallowestGroupId)) {\n            const elementsInGroup = getElementsInGroup(\n              this.app.scene.getNonDeletedElementsMap(),\n              shallowestGroupId,\n            );\n            for (const elementInGroup of elementsInGroup) {\n              this.elementsToErase.delete(elementInGroup.id);\n            }\n            this.groupsToErase.delete(shallowestGroupId);\n          }\n\n          if (isBoundToContainer(element)) {\n            this.elementsToErase.delete(element.containerId);\n          }\n\n          if (hasBoundTextElement(element)) {\n            const boundText = getBoundTextElementId(element);\n\n            if (boundText) {\n              this.elementsToErase.delete(boundText);\n            }\n          }\n\n          this.elementsToErase.delete(element.id);\n        }\n      } else if (!restoreToErase && !this.elementsToErase.has(element.id)) {\n        const intersects = eraserTest(\n          pathSegment,\n          element,\n          candidateElementsMap,\n        );\n\n        if (intersects) {\n          const shallowestGroupId = element.groupIds.at(-1)!;\n\n          if (!this.groupsToErase.has(shallowestGroupId)) {\n            const elementsInGroup = getElementsInGroup(\n              this.app.scene.getNonDeletedElementsMap(),\n              shallowestGroupId,\n            );\n\n            for (const elementInGroup of elementsInGroup) {\n              this.elementsToErase.add(elementInGroup.id);\n            }\n            this.groupsToErase.add(shallowestGroupId);\n          }\n\n          if (hasBoundTextElement(element)) {\n            const boundText = getBoundTextElementId(element);\n\n            if (boundText) {\n              this.elementsToErase.add(boundText);\n            }\n          }\n\n          if (isBoundToContainer(element)) {\n            this.elementsToErase.add(element.containerId);\n          }\n\n          this.elementsToErase.add(element.id);\n        }\n      }\n    }\n\n    return Array.from(this.elementsToErase);\n  }\n\n  endPath(): void {\n    super.endPath();\n    super.clearTrails();\n    this.elementsToErase.clear();\n    this.groupsToErase.clear();\n  }\n}\n\nconst eraserTest = (\n  pathSegment: LineSegment<GlobalPoint>,\n  element: ExcalidrawElement,\n  elementsMap: ElementsMap,\n): boolean => {\n  const lastPoint = pathSegment[1];\n  if (\n    shouldTestInside(element) &&\n    isPointInElement(lastPoint, element, elementsMap)\n  ) {\n    return true;\n  }\n\n  const boundTextElement = getBoundTextElement(element, elementsMap);\n\n  return (\n    intersectElementWithLineSegment(element, elementsMap, pathSegment, 0, true)\n      .length > 0 ||\n    (!!boundTextElement &&\n      intersectElementWithLineSegment(\n        {\n          ...boundTextElement,\n          ...computeBoundTextPosition(element, boundTextElement, elementsMap),\n        },\n        elementsMap,\n        pathSegment,\n        0,\n        true,\n      ).length > 0)\n  );\n};\n",
    "import Trans from \"./Trans\";\n\nconst BraveMeasureTextError = () => {\n  return (\n    <div data-testid=\"brave-measure-text-error\">\n      <p>\n        <Trans\n          i18nKey=\"errors.brave_measure_text_error.line1\"\n          bold={(el) => <span style={{ fontWeight: 600 }}>{el}</span>}\n        />\n      </p>\n      <p>\n        <Trans\n          i18nKey=\"errors.brave_measure_text_error.line2\"\n          bold={(el) => <span style={{ fontWeight: 600 }}>{el}</span>}\n        />\n      </p>\n      <p>\n        <Trans\n          i18nKey=\"errors.brave_measure_text_error.line3\"\n          link={(el) => (\n            <a href=\"http://docs.excalidraw.com/docs/excalidraw-custom/faq#turning-off-aggresive-block-fingerprinting-in-brave-browser\">\n              {el}\n            </a>\n          )}\n        />\n      </p>\n      <p>\n        <Trans\n          i18nKey=\"errors.brave_measure_text_error.line4\"\n          issueLink={(el) => (\n            <a href=\"https://github.com/excalidraw/excalidraw/issues/new\">\n              {el}\n            </a>\n          )}\n          discordLink={(el) => <a href=\"https://discord.gg/UexuTaE\">{el}.</a>}\n        />\n      </p>\n    </div>\n  );\n};\n\nexport default BraveMeasureTextError;\n",
    "import clsx from \"clsx\";\nimport React from \"react\";\n\nimport { getShortcutFromShortcutName } from \"../actions/shortcuts\";\nimport { t } from \"../i18n\";\n\nimport { useExcalidrawAppState, useExcalidrawElements } from \"./App\";\n\nimport { Popover } from \"./Popover\";\n\nimport \"./ContextMenu.scss\";\n\nimport type { ActionManager } from \"../actions/manager\";\nimport type { ShortcutName } from \"../actions/shortcuts\";\nimport type { Action } from \"../actions/types\";\n\nimport type { TranslationKeys } from \"../i18n\";\n\nexport type ContextMenuItem = typeof CONTEXT_MENU_SEPARATOR | Action;\n\nexport type ContextMenuItems = (ContextMenuItem | false | null | undefined)[];\n\ntype ContextMenuProps = {\n  actionManager: ActionManager;\n  items: ContextMenuItems;\n  top: number;\n  left: number;\n  onClose: (callback?: () => void) => void;\n};\n\nexport const CONTEXT_MENU_SEPARATOR = \"separator\";\n\nexport const ContextMenu = React.memo(\n  ({ actionManager, items, top, left, onClose }: ContextMenuProps) => {\n    const appState = useExcalidrawAppState();\n    const elements = useExcalidrawElements();\n\n    const filteredItems = items.reduce((acc: ContextMenuItem[], item) => {\n      if (\n        item &&\n        (item === CONTEXT_MENU_SEPARATOR ||\n          !item.predicate ||\n          item.predicate(\n            elements,\n            appState,\n            actionManager.app.props,\n            actionManager.app,\n          ))\n      ) {\n        acc.push(item);\n      }\n      return acc;\n    }, []);\n\n    return (\n      <Popover\n        onCloseRequest={() => {\n          onClose();\n        }}\n        top={top}\n        left={left}\n        fitInViewport={true}\n        offsetLeft={appState.offsetLeft}\n        offsetTop={appState.offsetTop}\n        viewportWidth={appState.width}\n        viewportHeight={appState.height}\n      >\n        <ul\n          className=\"context-menu\"\n          onContextMenu={(event) => event.preventDefault()}\n        >\n          {filteredItems.map((item, idx) => {\n            if (item === CONTEXT_MENU_SEPARATOR) {\n              if (\n                !filteredItems[idx - 1] ||\n                filteredItems[idx - 1] === CONTEXT_MENU_SEPARATOR\n              ) {\n                return null;\n              }\n              return <hr key={idx} className=\"context-menu-item-separator\" />;\n            }\n\n            const actionName = item.name;\n            let label = \"\";\n            if (item.label) {\n              if (typeof item.label === \"function\") {\n                label = t(\n                  item.label(\n                    elements,\n                    appState,\n                    actionManager.app,\n                  ) as unknown as TranslationKeys,\n                );\n              } else {\n                label = t(item.label as unknown as TranslationKeys);\n              }\n            }\n\n            return (\n              <li\n                key={idx}\n                data-testid={actionName}\n                onClick={() => {\n                  // we need update state before executing the action in case\n                  // the action uses the appState it's being passed (that still\n                  // contains a defined contextMenu) to return the next state.\n                  onClose(() => {\n                    actionManager.executeAction(item, \"contextMenu\");\n                  });\n                }}\n              >\n                <button\n                  type=\"button\"\n                  className={clsx(\"context-menu-item\", {\n                    dangerous: actionName === \"deleteSelectedElements\",\n                    checkmark: item.checked?.(appState),\n                  })}\n                >\n                  <div className=\"context-menu-item__label\">{label}</div>\n                  <kbd className=\"context-menu-item__shortcut\">\n                    {actionName\n                      ? getShortcutFromShortcutName(actionName as ShortcutName)\n                      : \"\"}\n                  </kbd>\n                </button>\n              </li>\n            );\n          })}\n        </ul>\n      </Popover>\n    );\n  },\n);\n",
    "import React, { useLayoutEffect, useRef, useEffect } from \"react\";\nimport { unstable_batchedUpdates } from \"react-dom\";\n\nimport { KEYS, queryFocusableElements } from \"@excalidraw/common\";\n\nimport \"./Popover.scss\";\n\ntype Props = {\n  top?: number;\n  left?: number;\n  children?: React.ReactNode;\n  onCloseRequest?(event: PointerEvent): void;\n  fitInViewport?: boolean;\n  offsetLeft?: number;\n  offsetTop?: number;\n  viewportWidth?: number;\n  viewportHeight?: number;\n};\n\nexport const Popover = ({\n  children,\n  left,\n  top,\n  onCloseRequest,\n  fitInViewport = false,\n  offsetLeft = 0,\n  offsetTop = 0,\n  viewportWidth = window.innerWidth,\n  viewportHeight = window.innerHeight,\n}: Props) => {\n  const popoverRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const container = popoverRef.current;\n\n    if (!container) {\n      return;\n    }\n\n    // focus popover only if the caller didn't focus on something else nested\n    // within the popover, which should take precedence. Fixes cases\n    // like color picker listening to keydown events on containers nested\n    // in the popover.\n    if (!container.contains(document.activeElement)) {\n      container.focus();\n    }\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === KEYS.TAB) {\n        const focusableElements = queryFocusableElements(container);\n        const { activeElement } = document;\n        const currentIndex = focusableElements.findIndex(\n          (element) => element === activeElement,\n        );\n\n        if (activeElement === container) {\n          if (event.shiftKey) {\n            focusableElements[focusableElements.length - 1]?.focus();\n          } else {\n            focusableElements[0].focus();\n          }\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        } else if (currentIndex === 0 && event.shiftKey) {\n          focusableElements[focusableElements.length - 1]?.focus();\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        } else if (\n          currentIndex === focusableElements.length - 1 &&\n          !event.shiftKey\n        ) {\n          focusableElements[0]?.focus();\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        }\n      }\n    };\n\n    container.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => container.removeEventListener(\"keydown\", handleKeyDown);\n  }, []);\n\n  const lastInitializedPosRef = useRef<{ top: number; left: number } | null>(\n    null,\n  );\n\n  // ensure the popover doesn't overflow the viewport\n  useLayoutEffect(() => {\n    if (fitInViewport && popoverRef.current && top != null && left != null) {\n      const container = popoverRef.current;\n      const { width, height } = container.getBoundingClientRect();\n\n      // hack for StrictMode so this effect only runs once for\n      // the same top/left position, otherwise\n      // we'd potentically reposition twice (once for viewport overflow)\n      // and once for top/left position afterwards\n      if (\n        lastInitializedPosRef.current?.top === top &&\n        lastInitializedPosRef.current?.left === left\n      ) {\n        return;\n      }\n      lastInitializedPosRef.current = { top, left };\n\n      if (width >= viewportWidth) {\n        container.style.width = `${viewportWidth}px`;\n        container.style.left = \"0px\";\n        container.style.overflowX = \"scroll\";\n      } else if (left + width - offsetLeft > viewportWidth) {\n        container.style.left = `${viewportWidth - width - 10}px`;\n      } else {\n        container.style.left = `${left}px`;\n      }\n\n      if (height >= viewportHeight) {\n        container.style.height = `${viewportHeight - 20}px`;\n        container.style.top = \"10px\";\n        container.style.overflowY = \"scroll\";\n      } else if (top + height - offsetTop > viewportHeight) {\n        container.style.top = `${viewportHeight - height}px`;\n      } else {\n        container.style.top = `${top}px`;\n      }\n    }\n  }, [\n    top,\n    left,\n    fitInViewport,\n    viewportWidth,\n    viewportHeight,\n    offsetLeft,\n    offsetTop,\n  ]);\n\n  useEffect(() => {\n    if (onCloseRequest) {\n      const handler = (event: PointerEvent) => {\n        if (!popoverRef.current?.contains(event.target as Node)) {\n          unstable_batchedUpdates(() => onCloseRequest(event));\n        }\n      };\n      document.addEventListener(\"pointerdown\", handler, false);\n      return () => document.removeEventListener(\"pointerdown\", handler, false);\n    }\n  }, [onCloseRequest]);\n\n  return (\n    <div className=\"popover\" ref={popoverRef} tabIndex={-1}>\n      {children}\n    </div>\n  );\n};\n",
    "import { CloseIcon } from \"../icons\";\n\nimport \"./FollowMode.scss\";\n\nimport type { UserToFollow } from \"../../types\";\n\ninterface FollowModeProps {\n  width: number;\n  height: number;\n  userToFollow: UserToFollow;\n  onDisconnect: () => void;\n}\n\nconst FollowMode = ({\n  height,\n  width,\n  userToFollow,\n  onDisconnect,\n}: FollowModeProps) => {\n  return (\n    <div className=\"follow-mode\" style={{ width, height }}>\n      <div className=\"follow-mode__badge\">\n        <div className=\"follow-mode__badge__label\">\n          Following{\" \"}\n          <span\n            className=\"follow-mode__badge__username\"\n            title={userToFollow.username}\n          >\n            {userToFollow.username}\n          </span>\n        </div>\n        <button\n          type=\"button\"\n          onClick={onDisconnect}\n          className=\"follow-mode__disconnect-btn\"\n        >\n          {CloseIcon}\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default FollowMode;\n",
    "import clsx from \"clsx\";\nimport React from \"react\";\n\nimport {\n  CLASSES,\n  DEFAULT_SIDEBAR,\n  TOOL_TYPE,\n  arrayToMap,\n  capitalizeString,\n  isShallowEqual,\n} from \"@excalidraw/common\";\n\nimport { mutateElement } from \"@excalidraw/element\";\n\nimport { showSelectedShapeActions } from \"@excalidraw/element\";\n\nimport { ShapeCache } from \"@excalidraw/element\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { actionToggleStats } from \"../actions\";\nimport { trackEvent } from \"../analytics\";\nimport { isHandToolActive } from \"../appState\";\nimport { TunnelsContext, useInitializeTunnels } from \"../context/tunnels\";\nimport { UIAppStateContext } from \"../context/ui-appState\";\nimport { useAtom, useAtomValue } from \"../editor-jotai\";\n\nimport { t } from \"../i18n\";\nimport { calculateScrollCenter } from \"../scene\";\n\nimport { SelectedShapeActions, ShapesSwitcher } from \"./Actions\";\nimport { LoadingMessage } from \"./LoadingMessage\";\nimport { LockButton } from \"./LockButton\";\nimport { MobileMenu } from \"./MobileMenu\";\nimport { PasteChartDialog } from \"./PasteChartDialog\";\nimport { Section } from \"./Section\";\nimport Stack from \"./Stack\";\nimport { UserList } from \"./UserList\";\nimport { PenModeButton } from \"./PenModeButton\";\nimport Footer from \"./footer/Footer\";\nimport { isSidebarDockedAtom } from \"./Sidebar/Sidebar\";\nimport MainMenu from \"./main-menu/MainMenu\";\nimport { ActiveConfirmDialog } from \"./ActiveConfirmDialog\";\nimport { useDevice } from \"./App\";\nimport { OverwriteConfirmDialog } from \"./OverwriteConfirm/OverwriteConfirm\";\nimport { LibraryIcon } from \"./icons\";\nimport { DefaultSidebar } from \"./DefaultSidebar\";\nimport { TTDDialog } from \"./TTDDialog/TTDDialog\";\nimport { Stats } from \"./Stats\";\nimport ElementLinkDialog from \"./ElementLinkDialog\";\nimport { ErrorDialog } from \"./ErrorDialog\";\nimport { EyeDropper, activeEyeDropperAtom } from \"./EyeDropper\";\nimport { FixedSideContainer } from \"./FixedSideContainer\";\nimport { HandButton } from \"./HandButton\";\nimport { HelpDialog } from \"./HelpDialog\";\nimport { HintViewer } from \"./HintViewer\";\nimport { ImageExportDialog } from \"./ImageExportDialog\";\nimport { Island } from \"./Island\";\nimport { JSONExportDialog } from \"./JSONExportDialog\";\nimport { LaserPointerButton } from \"./LaserPointerButton\";\n\nimport \"./LayerUI.scss\";\nimport \"./Toolbar.scss\";\n\nimport type { ActionManager } from \"../actions/manager\";\n\nimport type { Language } from \"../i18n\";\nimport type {\n  AppProps,\n  AppState,\n  ExcalidrawProps,\n  BinaryFiles,\n  UIAppState,\n  AppClassProperties,\n} from \"../types\";\n\ninterface LayerUIProps {\n  actionManager: ActionManager;\n  appState: UIAppState;\n  files: BinaryFiles;\n  canvas: HTMLCanvasElement;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  onLockToggle: () => void;\n  onHandToolToggle: () => void;\n  onPenModeToggle: AppClassProperties[\"togglePenMode\"];\n  showExitZenModeBtn: boolean;\n  langCode: Language[\"code\"];\n  renderTopRightUI?: ExcalidrawProps[\"renderTopRightUI\"];\n  renderCustomStats?: ExcalidrawProps[\"renderCustomStats\"];\n  UIOptions: AppProps[\"UIOptions\"];\n  onExportImage: AppClassProperties[\"onExportImage\"];\n  renderWelcomeScreen: boolean;\n  children?: React.ReactNode;\n  app: AppClassProperties;\n  isCollaborating: boolean;\n  generateLinkForSelection?: AppProps[\"generateLinkForSelection\"];\n}\n\nconst DefaultMainMenu: React.FC<{\n  UIOptions: AppProps[\"UIOptions\"];\n}> = ({ UIOptions }) => {\n  return (\n    <MainMenu __fallback>\n      <MainMenu.DefaultItems.LoadScene />\n      <MainMenu.DefaultItems.SaveToActiveFile />\n      {/* FIXME we should to test for this inside the item itself */}\n      {UIOptions.canvasActions.export && <MainMenu.DefaultItems.Export />}\n      {/* FIXME we should to test for this inside the item itself */}\n      {UIOptions.canvasActions.saveAsImage && (\n        <MainMenu.DefaultItems.SaveAsImage />\n      )}\n      <MainMenu.DefaultItems.SearchMenu />\n      <MainMenu.DefaultItems.Help />\n      <MainMenu.DefaultItems.ClearCanvas />\n      <MainMenu.Separator />\n      <MainMenu.Group title=\"Excalidraw links\">\n        <MainMenu.DefaultItems.Socials />\n      </MainMenu.Group>\n      <MainMenu.Separator />\n      <MainMenu.DefaultItems.ToggleTheme />\n      <MainMenu.DefaultItems.ChangeCanvasBackground />\n    </MainMenu>\n  );\n};\n\nconst DefaultOverwriteConfirmDialog = () => {\n  return (\n    <OverwriteConfirmDialog __fallback>\n      <OverwriteConfirmDialog.Actions.SaveToDisk />\n      <OverwriteConfirmDialog.Actions.ExportToImage />\n    </OverwriteConfirmDialog>\n  );\n};\n\nconst LayerUI = ({\n  actionManager,\n  appState,\n  files,\n  setAppState,\n  elements,\n  canvas,\n  onLockToggle,\n  onHandToolToggle,\n  onPenModeToggle,\n  showExitZenModeBtn,\n  renderTopRightUI,\n  renderCustomStats,\n  UIOptions,\n  onExportImage,\n  renderWelcomeScreen,\n  children,\n  app,\n  isCollaborating,\n  generateLinkForSelection,\n}: LayerUIProps) => {\n  const device = useDevice();\n  const tunnels = useInitializeTunnels();\n\n  const TunnelsJotaiProvider = tunnels.tunnelsJotai.Provider;\n\n  const [eyeDropperState, setEyeDropperState] = useAtom(activeEyeDropperAtom);\n\n  const renderJSONExportDialog = () => {\n    if (!UIOptions.canvasActions.export) {\n      return null;\n    }\n\n    return (\n      <JSONExportDialog\n        elements={elements}\n        appState={appState}\n        files={files}\n        actionManager={actionManager}\n        exportOpts={UIOptions.canvasActions.export}\n        canvas={canvas}\n        setAppState={setAppState}\n      />\n    );\n  };\n\n  const renderImageExportDialog = () => {\n    if (\n      !UIOptions.canvasActions.saveAsImage ||\n      appState.openDialog?.name !== \"imageExport\"\n    ) {\n      return null;\n    }\n\n    return (\n      <ImageExportDialog\n        elements={elements}\n        appState={appState}\n        files={files}\n        actionManager={actionManager}\n        onExportImage={onExportImage}\n        onCloseRequest={() => setAppState({ openDialog: null })}\n        name={app.getName()}\n      />\n    );\n  };\n\n  const renderCanvasActions = () => (\n    <div style={{ position: \"relative\" }}>\n      {/* wrapping to Fragment stops React from occasionally complaining\n                about identical Keys */}\n      <tunnels.MainMenuTunnel.Out />\n      {renderWelcomeScreen && <tunnels.WelcomeScreenMenuHintTunnel.Out />}\n    </div>\n  );\n\n  const renderSelectedShapeActions = () => (\n    <Section\n      heading=\"selectedShapeActions\"\n      className={clsx(\"selected-shape-actions zen-mode-transition\", {\n        \"transition-left\": appState.zenModeEnabled,\n      })}\n    >\n      <Island\n        className={CLASSES.SHAPE_ACTIONS_MENU}\n        padding={2}\n        style={{\n          // we want to make sure this doesn't overflow so subtracting the\n          // approximate height of hamburgerMenu + footer\n          maxHeight: `${appState.height - 166}px`,\n        }}\n      >\n        <SelectedShapeActions\n          appState={appState}\n          elementsMap={app.scene.getNonDeletedElementsMap()}\n          renderAction={actionManager.renderAction}\n          app={app}\n        />\n      </Island>\n    </Section>\n  );\n\n  const renderFixedSideContainer = () => {\n    const shouldRenderSelectedShapeActions = showSelectedShapeActions(\n      appState,\n      elements,\n    );\n\n    const shouldShowStats =\n      appState.stats.open &&\n      !appState.zenModeEnabled &&\n      !appState.viewModeEnabled &&\n      appState.openDialog?.name !== \"elementLinkSelector\";\n\n    return (\n      <FixedSideContainer side=\"top\">\n        <div className=\"App-menu App-menu_top\">\n          <Stack.Col gap={6} className={clsx(\"App-menu_top__left\")}>\n            {renderCanvasActions()}\n            {shouldRenderSelectedShapeActions && renderSelectedShapeActions()}\n          </Stack.Col>\n          {!appState.viewModeEnabled &&\n            appState.openDialog?.name !== \"elementLinkSelector\" && (\n              <Section heading=\"shapes\" className=\"shapes-section\">\n                {(heading: React.ReactNode) => (\n                  <div style={{ position: \"relative\" }}>\n                    {renderWelcomeScreen && (\n                      <tunnels.WelcomeScreenToolbarHintTunnel.Out />\n                    )}\n                    <Stack.Col gap={4} align=\"start\">\n                      <Stack.Row\n                        gap={1}\n                        className={clsx(\"App-toolbar-container\", {\n                          \"zen-mode\": appState.zenModeEnabled,\n                        })}\n                      >\n                        <Island\n                          padding={1}\n                          className={clsx(\"App-toolbar\", {\n                            \"zen-mode\": appState.zenModeEnabled,\n                          })}\n                        >\n                          <HintViewer\n                            appState={appState}\n                            isMobile={device.editor.isMobile}\n                            device={device}\n                            app={app}\n                          />\n                          {heading}\n                          <Stack.Row gap={1}>\n                            <PenModeButton\n                              zenModeEnabled={appState.zenModeEnabled}\n                              checked={appState.penMode}\n                              onChange={() => onPenModeToggle(null)}\n                              title={t(\"toolBar.penMode\")}\n                              penDetected={appState.penDetected}\n                            />\n                            <LockButton\n                              checked={appState.activeTool.locked}\n                              onChange={onLockToggle}\n                              title={t(\"toolBar.lock\")}\n                            />\n\n                            <div className=\"App-toolbar__divider\" />\n\n                            <HandButton\n                              checked={isHandToolActive(appState)}\n                              onChange={() => onHandToolToggle()}\n                              title={t(\"toolBar.hand\")}\n                              isMobile\n                            />\n\n                            <ShapesSwitcher\n                              appState={appState}\n                              activeTool={appState.activeTool}\n                              UIOptions={UIOptions}\n                              app={app}\n                            />\n                          </Stack.Row>\n                        </Island>\n                        {isCollaborating && (\n                          <Island\n                            style={{\n                              marginLeft: 8,\n                              alignSelf: \"center\",\n                              height: \"fit-content\",\n                            }}\n                          >\n                            <LaserPointerButton\n                              title={t(\"toolBar.laser\")}\n                              checked={\n                                appState.activeTool.type === TOOL_TYPE.laser\n                              }\n                              onChange={() =>\n                                app.setActiveTool({ type: TOOL_TYPE.laser })\n                              }\n                              isMobile\n                            />\n                          </Island>\n                        )}\n                      </Stack.Row>\n                    </Stack.Col>\n                  </div>\n                )}\n              </Section>\n            )}\n          <div\n            className={clsx(\n              \"layer-ui__wrapper__top-right zen-mode-transition\",\n              {\n                \"transition-right\": appState.zenModeEnabled,\n              },\n            )}\n          >\n            {appState.collaborators.size > 0 && (\n              <UserList\n                collaborators={appState.collaborators}\n                userToFollow={appState.userToFollow?.socketId || null}\n              />\n            )}\n            {renderTopRightUI?.(device.editor.isMobile, appState)}\n            {!appState.viewModeEnabled &&\n              appState.openDialog?.name !== \"elementLinkSelector\" &&\n              // hide button when sidebar docked\n              (!isSidebarDocked ||\n                appState.openSidebar?.name !== DEFAULT_SIDEBAR.name) && (\n                <tunnels.DefaultSidebarTriggerTunnel.Out />\n              )}\n            {shouldShowStats && (\n              <Stats\n                app={app}\n                onClose={() => {\n                  actionManager.executeAction(actionToggleStats);\n                }}\n                renderCustomStats={renderCustomStats}\n              />\n            )}\n          </div>\n        </div>\n      </FixedSideContainer>\n    );\n  };\n\n  const renderSidebars = () => {\n    return (\n      <DefaultSidebar\n        __fallback\n        onDock={(docked) => {\n          trackEvent(\n            \"sidebar\",\n            `toggleDock (${docked ? \"dock\" : \"undock\"})`,\n            `(${device.editor.isMobile ? \"mobile\" : \"desktop\"})`,\n          );\n        }}\n      />\n    );\n  };\n\n  const isSidebarDocked = useAtomValue(isSidebarDockedAtom);\n\n  const layerUIJSX = (\n    <>\n      {/* ------------------------- tunneled UI ---------------------------- */}\n      {/* make sure we render host app components first so that we can detect\n          them first on initial render to optimize layout shift */}\n      {children}\n      {/* render component fallbacks. Can be rendered anywhere as they'll be\n          tunneled away. We only render tunneled components that actually\n        have defaults when host do not render anything. */}\n      <DefaultMainMenu UIOptions={UIOptions} />\n      <DefaultSidebar.Trigger\n        __fallback\n        icon={LibraryIcon}\n        title={capitalizeString(t(\"toolBar.library\"))}\n        onToggle={(open) => {\n          if (open) {\n            trackEvent(\n              \"sidebar\",\n              `${DEFAULT_SIDEBAR.name} (open)`,\n              `button (${device.editor.isMobile ? \"mobile\" : \"desktop\"})`,\n            );\n          }\n        }}\n        tab={DEFAULT_SIDEBAR.defaultTab}\n      >\n        {t(\"toolBar.library\")}\n      </DefaultSidebar.Trigger>\n      <DefaultOverwriteConfirmDialog />\n      {appState.openDialog?.name === \"ttd\" && <TTDDialog __fallback />}\n      {/* ------------------------------------------------------------------ */}\n\n      {appState.isLoading && <LoadingMessage delay={250} />}\n      {appState.errorMessage && (\n        <ErrorDialog onClose={() => setAppState({ errorMessage: null })}>\n          {appState.errorMessage}\n        </ErrorDialog>\n      )}\n      {eyeDropperState && !device.editor.isMobile && (\n        <EyeDropper\n          colorPickerType={eyeDropperState.colorPickerType}\n          onCancel={() => {\n            setEyeDropperState(null);\n          }}\n          onChange={(colorPickerType, color, selectedElements, { altKey }) => {\n            if (\n              colorPickerType !== \"elementBackground\" &&\n              colorPickerType !== \"elementStroke\"\n            ) {\n              return;\n            }\n\n            if (selectedElements.length) {\n              for (const element of selectedElements) {\n                mutateElement(element, arrayToMap(elements), {\n                  [altKey && eyeDropperState.swapPreviewOnAlt\n                    ? colorPickerType === \"elementBackground\"\n                      ? \"strokeColor\"\n                      : \"backgroundColor\"\n                    : colorPickerType === \"elementBackground\"\n                    ? \"backgroundColor\"\n                    : \"strokeColor\"]: color,\n                });\n                ShapeCache.delete(element);\n              }\n              app.scene.triggerUpdate();\n            } else if (colorPickerType === \"elementBackground\") {\n              setAppState({\n                currentItemBackgroundColor: color,\n              });\n            } else {\n              setAppState({ currentItemStrokeColor: color });\n            }\n          }}\n          onSelect={(color, event) => {\n            setEyeDropperState((state) => {\n              return state?.keepOpenOnAlt && event.altKey ? state : null;\n            });\n            eyeDropperState?.onSelect?.(color, event);\n          }}\n        />\n      )}\n      {appState.openDialog?.name === \"help\" && (\n        <HelpDialog\n          onClose={() => {\n            setAppState({ openDialog: null });\n          }}\n        />\n      )}\n      <ActiveConfirmDialog />\n      {appState.openDialog?.name === \"elementLinkSelector\" && (\n        <ElementLinkDialog\n          sourceElementId={appState.openDialog.sourceElementId}\n          onClose={() => {\n            setAppState({\n              openDialog: null,\n            });\n          }}\n          scene={app.scene}\n          appState={appState}\n          generateLinkForSelection={generateLinkForSelection}\n        />\n      )}\n      <tunnels.OverwriteConfirmDialogTunnel.Out />\n      {renderImageExportDialog()}\n      {renderJSONExportDialog()}\n      {appState.pasteDialog.shown && (\n        <PasteChartDialog\n          setAppState={setAppState}\n          appState={appState}\n          onClose={() =>\n            setAppState({\n              pasteDialog: { shown: false, data: null },\n            })\n          }\n        />\n      )}\n      {device.editor.isMobile && (\n        <MobileMenu\n          app={app}\n          appState={appState}\n          elements={elements}\n          actionManager={actionManager}\n          renderJSONExportDialog={renderJSONExportDialog}\n          renderImageExportDialog={renderImageExportDialog}\n          setAppState={setAppState}\n          onLockToggle={onLockToggle}\n          onHandToolToggle={onHandToolToggle}\n          onPenModeToggle={onPenModeToggle}\n          renderTopRightUI={renderTopRightUI}\n          renderCustomStats={renderCustomStats}\n          renderSidebars={renderSidebars}\n          device={device}\n          renderWelcomeScreen={renderWelcomeScreen}\n          UIOptions={UIOptions}\n        />\n      )}\n      {!device.editor.isMobile && (\n        <>\n          <div\n            className=\"layer-ui__wrapper\"\n            style={\n              appState.openSidebar &&\n              isSidebarDocked &&\n              device.editor.canFitSidebar\n                ? { width: `calc(100% - var(--right-sidebar-width))` }\n                : {}\n            }\n          >\n            {renderWelcomeScreen && <tunnels.WelcomeScreenCenterTunnel.Out />}\n            {renderFixedSideContainer()}\n            <Footer\n              appState={appState}\n              actionManager={actionManager}\n              showExitZenModeBtn={showExitZenModeBtn}\n              renderWelcomeScreen={renderWelcomeScreen}\n            />\n            {appState.scrolledOutside && (\n              <button\n                type=\"button\"\n                className=\"scroll-back-to-content\"\n                onClick={() => {\n                  setAppState((appState) => ({\n                    ...calculateScrollCenter(elements, appState),\n                  }));\n                }}\n              >\n                {t(\"buttons.scrollBackToContent\")}\n              </button>\n            )}\n          </div>\n          {renderSidebars()}\n        </>\n      )}\n    </>\n  );\n\n  return (\n    <UIAppStateContext.Provider value={appState}>\n      <TunnelsJotaiProvider>\n        <TunnelsContext.Provider value={tunnels}>\n          {layerUIJSX}\n        </TunnelsContext.Provider>\n      </TunnelsJotaiProvider>\n    </UIAppStateContext.Provider>\n  );\n};\n\nconst stripIrrelevantAppStateProps = (appState: AppState): UIAppState => {\n  const {\n    suggestedBindings,\n    startBoundElement,\n    cursorButton,\n    scrollX,\n    scrollY,\n    ...ret\n  } = appState;\n  return ret;\n};\n\nconst areEqual = (prevProps: LayerUIProps, nextProps: LayerUIProps) => {\n  // short-circuit early\n  if (prevProps.children !== nextProps.children) {\n    return false;\n  }\n\n  const { canvas: _pC, appState: prevAppState, ...prev } = prevProps;\n  const { canvas: _nC, appState: nextAppState, ...next } = nextProps;\n\n  return (\n    isShallowEqual(\n      // asserting AppState because we're being passed the whole AppState\n      // but resolve to only the UI-relevant props\n      stripIrrelevantAppStateProps(prevAppState as AppState),\n      stripIrrelevantAppStateProps(nextAppState as AppState),\n      {\n        selectedElementIds: isShallowEqual,\n        selectedGroupIds: isShallowEqual,\n      },\n    ) && isShallowEqual(prev, next)\n  );\n};\n\nexport default React.memo(LayerUI, areEqual);\n",
    "import clsx from \"clsx\";\nimport { useState, useEffect } from \"react\";\n\nimport { THEME } from \"@excalidraw/common\";\n\nimport type { Theme } from \"@excalidraw/element/types\";\n\nimport { t } from \"../i18n\";\n\nimport Spinner from \"./Spinner\";\n\nexport const LoadingMessage: React.FC<{ delay?: number; theme?: Theme }> = ({\n  delay,\n  theme,\n}) => {\n  const [isWaiting, setIsWaiting] = useState(!!delay);\n\n  useEffect(() => {\n    if (!delay) {\n      return;\n    }\n    const timer = setTimeout(() => {\n      setIsWaiting(false);\n    }, delay);\n    return () => clearTimeout(timer);\n  }, [delay]);\n\n  if (isWaiting) {\n    return null;\n  }\n\n  return (\n    <div\n      className={clsx(\"LoadingMessage\", {\n        \"LoadingMessage--dark\": theme === THEME.DARK,\n      })}\n    >\n      <div>\n        <Spinner />\n      </div>\n      <div className=\"LoadingMessage-text\">{t(\"labels.loadingScene\")}</div>\n    </div>\n  );\n};\n",
    "import clsx from \"clsx\";\n\nimport \"./ToolIcon.scss\";\n\nimport { LockedIcon, UnlockedIcon } from \"./icons\";\n\nimport type { ToolButtonSize } from \"./ToolButton\";\n\ntype LockIconProps = {\n  title?: string;\n  name?: string;\n  checked: boolean;\n  onChange?(): void;\n  isMobile?: boolean;\n};\n\nconst DEFAULT_SIZE: ToolButtonSize = \"medium\";\n\nconst ICONS = {\n  CHECKED: LockedIcon,\n  UNCHECKED: UnlockedIcon,\n};\n\nexport const LockButton = (props: LockIconProps) => {\n  return (\n    <label\n      className={clsx(\n        \"ToolIcon ToolIcon__lock\",\n        `ToolIcon_size_${DEFAULT_SIZE}`,\n        {\n          \"is-mobile\": props.isMobile,\n        },\n      )}\n      title={`${props.title} — Q`}\n    >\n      <input\n        className=\"ToolIcon_type_checkbox\"\n        type=\"checkbox\"\n        name={props.name}\n        onChange={props.onChange}\n        checked={props.checked}\n        aria-label={props.title}\n        data-testid=\"toolbar-lock\"\n      />\n      <div className=\"ToolIcon__icon\">\n        {props.checked ? ICONS.CHECKED : ICONS.UNCHECKED}\n      </div>\n    </label>\n  );\n};\n",
    "import React from \"react\";\n\nimport { showSelectedShapeActions } from \"@excalidraw/element\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { isHandToolActive } from \"../appState\";\nimport { useTunnels } from \"../context/tunnels\";\nimport { t } from \"../i18n\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { SCROLLBAR_WIDTH, SCROLLBAR_MARGIN } from \"../scene/scrollbars\";\n\nimport { SelectedShapeActions, ShapesSwitcher } from \"./Actions\";\nimport { FixedSideContainer } from \"./FixedSideContainer\";\nimport { HandButton } from \"./HandButton\";\nimport { HintViewer } from \"./HintViewer\";\nimport { Island } from \"./Island\";\nimport { LockButton } from \"./LockButton\";\nimport { PenModeButton } from \"./PenModeButton\";\nimport { Section } from \"./Section\";\nimport Stack from \"./Stack\";\n\nimport type { ActionManager } from \"../actions/manager\";\nimport type {\n  AppClassProperties,\n  AppProps,\n  AppState,\n  Device,\n  ExcalidrawProps,\n  UIAppState,\n} from \"../types\";\nimport type { JSX } from \"react\";\n\ntype MobileMenuProps = {\n  appState: UIAppState;\n  actionManager: ActionManager;\n  renderJSONExportDialog: () => React.ReactNode;\n  renderImageExportDialog: () => React.ReactNode;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n  elements: readonly NonDeletedExcalidrawElement[];\n  onLockToggle: () => void;\n  onHandToolToggle: () => void;\n  onPenModeToggle: AppClassProperties[\"togglePenMode\"];\n\n  renderTopRightUI?: (\n    isMobile: boolean,\n    appState: UIAppState,\n  ) => JSX.Element | null;\n  renderCustomStats?: ExcalidrawProps[\"renderCustomStats\"];\n  renderSidebars: () => JSX.Element | null;\n  device: Device;\n  renderWelcomeScreen: boolean;\n  UIOptions: AppProps[\"UIOptions\"];\n  app: AppClassProperties;\n};\n\nexport const MobileMenu = ({\n  appState,\n  elements,\n  actionManager,\n  setAppState,\n  onLockToggle,\n  onHandToolToggle,\n  onPenModeToggle,\n\n  renderTopRightUI,\n  renderCustomStats,\n  renderSidebars,\n  device,\n  renderWelcomeScreen,\n  UIOptions,\n  app,\n}: MobileMenuProps) => {\n  const {\n    WelcomeScreenCenterTunnel,\n    MainMenuTunnel,\n    DefaultSidebarTriggerTunnel,\n  } = useTunnels();\n  const renderToolbar = () => {\n    return (\n      <FixedSideContainer side=\"top\" className=\"App-top-bar\">\n        {renderWelcomeScreen && <WelcomeScreenCenterTunnel.Out />}\n        <Section heading=\"shapes\">\n          {(heading: React.ReactNode) => (\n            <Stack.Col gap={4} align=\"center\">\n              <Stack.Row gap={1} className=\"App-toolbar-container\">\n                <Island padding={1} className=\"App-toolbar App-toolbar--mobile\">\n                  {heading}\n                  <Stack.Row gap={1}>\n                    <ShapesSwitcher\n                      appState={appState}\n                      activeTool={appState.activeTool}\n                      UIOptions={UIOptions}\n                      app={app}\n                    />\n                  </Stack.Row>\n                </Island>\n                {renderTopRightUI && renderTopRightUI(true, appState)}\n                <div className=\"mobile-misc-tools-container\">\n                  {!appState.viewModeEnabled &&\n                    appState.openDialog?.name !== \"elementLinkSelector\" && (\n                      <DefaultSidebarTriggerTunnel.Out />\n                    )}\n                  <PenModeButton\n                    checked={appState.penMode}\n                    onChange={() => onPenModeToggle(null)}\n                    title={t(\"toolBar.penMode\")}\n                    isMobile\n                    penDetected={appState.penDetected}\n                  />\n                  <LockButton\n                    checked={appState.activeTool.locked}\n                    onChange={onLockToggle}\n                    title={t(\"toolBar.lock\")}\n                    isMobile\n                  />\n                  <HandButton\n                    checked={isHandToolActive(appState)}\n                    onChange={() => onHandToolToggle()}\n                    title={t(\"toolBar.hand\")}\n                    isMobile\n                  />\n                </div>\n              </Stack.Row>\n            </Stack.Col>\n          )}\n        </Section>\n        <HintViewer\n          appState={appState}\n          isMobile={true}\n          device={device}\n          app={app}\n        />\n      </FixedSideContainer>\n    );\n  };\n\n  const renderAppToolbar = () => {\n    if (\n      appState.viewModeEnabled ||\n      appState.openDialog?.name === \"elementLinkSelector\"\n    ) {\n      return (\n        <div className=\"App-toolbar-content\">\n          <MainMenuTunnel.Out />\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"App-toolbar-content\">\n        <MainMenuTunnel.Out />\n        {actionManager.renderAction(\"toggleEditMenu\")}\n        {actionManager.renderAction(\n          appState.multiElement ? \"finalize\" : \"duplicateSelection\",\n        )}\n        {actionManager.renderAction(\"deleteSelectedElements\")}\n        <div>\n          {actionManager.renderAction(\"undo\")}\n          {actionManager.renderAction(\"redo\")}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <>\n      {renderSidebars()}\n      {!appState.viewModeEnabled &&\n        appState.openDialog?.name !== \"elementLinkSelector\" &&\n        renderToolbar()}\n      <div\n        className=\"App-bottom-bar\"\n        style={{\n          marginBottom: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n          marginLeft: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n          marginRight: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,\n        }}\n      >\n        <Island padding={0}>\n          {appState.openMenu === \"shape\" &&\n          !appState.viewModeEnabled &&\n          appState.openDialog?.name !== \"elementLinkSelector\" &&\n          showSelectedShapeActions(appState, elements) ? (\n            <Section className=\"App-mobile-menu\" heading=\"selectedShapeActions\">\n              <SelectedShapeActions\n                appState={appState}\n                elementsMap={app.scene.getNonDeletedElementsMap()}\n                renderAction={actionManager.renderAction}\n                app={app}\n              />\n            </Section>\n          ) : null}\n          <footer className=\"App-toolbar\">\n            {renderAppToolbar()}\n            {appState.scrolledOutside &&\n              !appState.openMenu &&\n              !appState.openSidebar && (\n                <button\n                  type=\"button\"\n                  className=\"scroll-back-to-content\"\n                  onClick={() => {\n                    setAppState((appState) => ({\n                      ...calculateScrollCenter(elements, appState),\n                    }));\n                  }}\n                >\n                  {t(\"buttons.scrollBackToContent\")}\n                </button>\n              )}\n          </footer>\n        </Island>\n      </div>\n    </>\n  );\n};\n",
    "import React from \"react\";\nimport clsx from \"clsx\";\n\nimport \"./FixedSideContainer.scss\";\n\ntype FixedSideContainerProps = {\n  children: React.ReactNode;\n  side: \"top\" | \"left\" | \"right\";\n  className?: string;\n};\n\nexport const FixedSideContainer = ({\n  children,\n  side,\n  className,\n}: FixedSideContainerProps) => (\n  <div\n    className={clsx(\n      \"FixedSideContainer\",\n      `FixedSideContainer_side_${side}`,\n      className,\n    )}\n  >\n    {children}\n  </div>\n);\n",
    "import clsx from \"clsx\";\n\nimport { KEYS } from \"@excalidraw/common\";\n\nimport { ToolButton } from \"./ToolButton\";\nimport { handIcon } from \"./icons\";\n\nimport \"./ToolIcon.scss\";\n\ntype LockIconProps = {\n  title?: string;\n  name?: string;\n  checked: boolean;\n  onChange?(): void;\n  isMobile?: boolean;\n};\n\nexport const HandButton = (props: LockIconProps) => {\n  return (\n    <ToolButton\n      className={clsx(\"Shape\", { fillable: false })}\n      type=\"radio\"\n      icon={handIcon}\n      name=\"editor-current-shape\"\n      checked={props.checked}\n      title={`${props.title} — H`}\n      keyBindingLabel={!props.isMobile ? KEYS.H.toLocaleUpperCase() : undefined}\n      aria-label={`${props.title} — H`}\n      aria-keyshortcuts={KEYS.H}\n      data-testid={`toolbar-hand`}\n      onChange={() => props.onChange?.()}\n    />\n  );\n};\n",
    "import { CANVAS_SEARCH_TAB, DEFAULT_SIDEBAR } from \"@excalidraw/common\";\n\nimport {\n  isFlowchartNodeElement,\n  isImageElement,\n  isLinearElement,\n  isLineElement,\n  isTextBindableContainer,\n  isTextElement,\n} from \"@excalidraw/element\";\n\nimport { getShortcutKey } from \"@excalidraw/common\";\n\nimport { isNodeInFlowchart } from \"@excalidraw/element\";\n\nimport { t } from \"../i18n\";\nimport { isEraserActive } from \"../appState\";\nimport { isGridModeEnabled } from \"../snapping\";\n\nimport \"./HintViewer.scss\";\n\nimport type { AppClassProperties, Device, UIAppState } from \"../types\";\n\ninterface HintViewerProps {\n  appState: UIAppState;\n  isMobile: boolean;\n  device: Device;\n  app: AppClassProperties;\n}\n\nconst getHints = ({\n  appState,\n  isMobile,\n  device,\n  app,\n}: HintViewerProps): null | string | string[] => {\n  const { activeTool, isResizing, isRotating, lastPointerDownWith } = appState;\n  const multiMode = appState.multiElement !== null;\n\n  if (\n    appState.openSidebar?.name === DEFAULT_SIDEBAR.name &&\n    appState.openSidebar.tab === CANVAS_SEARCH_TAB &&\n    appState.searchMatches?.matches.length\n  ) {\n    return t(\"hints.dismissSearch\");\n  }\n\n  if (appState.openSidebar && !device.editor.canFitSidebar) {\n    return null;\n  }\n\n  if (isEraserActive(appState)) {\n    return t(\"hints.eraserRevert\");\n  }\n  if (activeTool.type === \"arrow\" || activeTool.type === \"line\") {\n    if (multiMode) {\n      return t(\"hints.linearElementMulti\");\n    }\n    if (activeTool.type === \"arrow\") {\n      return t(\"hints.arrowTool\", { arrowShortcut: getShortcutKey(\"A\") });\n    }\n    return t(\"hints.linearElement\");\n  }\n\n  if (activeTool.type === \"freedraw\") {\n    return t(\"hints.freeDraw\");\n  }\n\n  if (activeTool.type === \"text\") {\n    return t(\"hints.text\");\n  }\n\n  if (activeTool.type === \"embeddable\") {\n    return t(\"hints.embeddable\");\n  }\n\n  const selectedElements = app.scene.getSelectedElements(appState);\n\n  if (\n    isResizing &&\n    lastPointerDownWith === \"mouse\" &&\n    selectedElements.length === 1\n  ) {\n    const targetElement = selectedElements[0];\n    if (isLinearElement(targetElement) && targetElement.points.length === 2) {\n      return t(\"hints.lockAngle\");\n    }\n    return isImageElement(targetElement)\n      ? t(\"hints.resizeImage\")\n      : t(\"hints.resize\");\n  }\n\n  if (isRotating && lastPointerDownWith === \"mouse\") {\n    return t(\"hints.rotate\");\n  }\n\n  if (selectedElements.length === 1 && isTextElement(selectedElements[0])) {\n    return t(\"hints.text_selected\");\n  }\n\n  if (appState.editingTextElement) {\n    return t(\"hints.text_editing\");\n  }\n\n  if (appState.croppingElementId) {\n    return t(\"hints.leaveCropEditor\");\n  }\n\n  if (selectedElements.length === 1 && isImageElement(selectedElements[0])) {\n    return t(\"hints.enterCropEditor\");\n  }\n\n  if (activeTool.type === \"selection\") {\n    if (\n      appState.selectionElement &&\n      !selectedElements.length &&\n      !appState.editingTextElement &&\n      !appState.editingLinearElement\n    ) {\n      return [t(\"hints.deepBoxSelect\")];\n    }\n\n    if (isGridModeEnabled(app) && appState.selectedElementsAreBeingDragged) {\n      return t(\"hints.disableSnapping\");\n    }\n\n    if (!selectedElements.length && !isMobile) {\n      return [t(\"hints.canvasPanning\")];\n    }\n\n    if (selectedElements.length === 1) {\n      if (isLinearElement(selectedElements[0])) {\n        if (appState.editingLinearElement) {\n          return appState.editingLinearElement.selectedPointsIndices\n            ? t(\"hints.lineEditor_pointSelected\")\n            : t(\"hints.lineEditor_nothingSelected\");\n        }\n        return isLineElement(selectedElements[0])\n          ? t(\"hints.lineEditor_line_info\")\n          : t(\"hints.lineEditor_info\");\n      }\n      if (\n        !appState.newElement &&\n        !appState.selectedElementsAreBeingDragged &&\n        isTextBindableContainer(selectedElements[0])\n      ) {\n        if (isFlowchartNodeElement(selectedElements[0])) {\n          if (\n            isNodeInFlowchart(\n              selectedElements[0],\n              app.scene.getNonDeletedElementsMap(),\n            )\n          ) {\n            return [t(\"hints.bindTextToElement\"), t(\"hints.createFlowchart\")];\n          }\n\n          return [t(\"hints.bindTextToElement\"), t(\"hints.createFlowchart\")];\n        }\n\n        return t(\"hints.bindTextToElement\");\n      }\n    }\n  }\n\n  return null;\n};\n\nexport const HintViewer = ({\n  appState,\n  isMobile,\n  device,\n  app,\n}: HintViewerProps) => {\n  const hints = getHints({\n    appState,\n    isMobile,\n    device,\n    app,\n  });\n\n  if (!hints) {\n    return null;\n  }\n\n  const hint = Array.isArray(hints)\n    ? hints\n        .map((hint) => {\n          return getShortcutKey(hint).replace(/\\. ?$/, \"\");\n        })\n        .join(\". \")\n    : getShortcutKey(hints);\n\n  return (\n    <div className=\"HintViewer\">\n      <span>{hint}</span>\n    </div>\n  );\n};\n",
    "import clsx from \"clsx\";\n\nimport \"./ToolIcon.scss\";\n\nimport { PenModeIcon } from \"./icons\";\n\nimport type { ToolButtonSize } from \"./ToolButton\";\n\ntype PenModeIconProps = {\n  title?: string;\n  name?: string;\n  checked: boolean;\n  onChange?(): void;\n  zenModeEnabled?: boolean;\n  isMobile?: boolean;\n  penDetected: boolean;\n};\n\nconst DEFAULT_SIZE: ToolButtonSize = \"medium\";\n\nexport const PenModeButton = (props: PenModeIconProps) => {\n  if (!props.penDetected) {\n    return null;\n  }\n\n  return (\n    <label\n      className={clsx(\n        \"ToolIcon ToolIcon__penMode\",\n        `ToolIcon_size_${DEFAULT_SIZE}`,\n        {\n          \"is-mobile\": props.isMobile,\n        },\n      )}\n      title={`${props.title}`}\n    >\n      <input\n        className=\"ToolIcon_type_checkbox\"\n        type=\"checkbox\"\n        name={props.name}\n        onChange={props.onChange}\n        checked={props.checked}\n        aria-label={props.title}\n      />\n      <div className=\"ToolIcon__icon\">{PenModeIcon}</div>\n    </label>\n  );\n};\n",
    "import React from \"react\";\n\nimport { t } from \"../i18n\";\n\nimport { useExcalidrawContainer } from \"./App\";\n\nexport const Section: React.FC<{\n  heading: \"canvasActions\" | \"selectedShapeActions\" | \"shapes\";\n  children?: React.ReactNode | ((heading: React.ReactNode) => React.ReactNode);\n  className?: string;\n}> = ({ heading, children, ...props }) => {\n  const { id } = useExcalidrawContainer();\n  const header = (\n    <h2 className=\"visually-hidden\" id={`${id}-${heading}-title`}>\n      {t(`headings.${heading}`)}\n    </h2>\n  );\n  return (\n    <section {...props} aria-labelledby={`${id}-${heading}-title`}>\n      {typeof children === \"function\" ? (\n        children(header)\n      ) : (\n        <>\n          {header}\n          {children}\n        </>\n      )}\n    </section>\n  );\n};\n",
    "import oc from \"open-color\";\nimport React, { useLayoutEffect, useRef, useState } from \"react\";\n\nimport type { ChartType } from \"@excalidraw/element/types\";\n\nimport { trackEvent } from \"../analytics\";\nimport { renderSpreadsheet } from \"../charts\";\nimport { t } from \"../i18n\";\nimport { exportToSvg } from \"../scene/export\";\n\nimport { useApp } from \"./App\";\nimport { Dialog } from \"./Dialog\";\n\nimport \"./PasteChartDialog.scss\";\n\nimport type { ChartElements, Spreadsheet } from \"../charts\";\nimport type { UIAppState } from \"../types\";\n\ntype OnInsertChart = (chartType: ChartType, elements: ChartElements) => void;\n\nconst ChartPreviewBtn = (props: {\n  spreadsheet: Spreadsheet | null;\n  chartType: ChartType;\n  selected: boolean;\n  onClick: OnInsertChart;\n}) => {\n  const previewRef = useRef<HTMLDivElement | null>(null);\n  const [chartElements, setChartElements] = useState<ChartElements | null>(\n    null,\n  );\n\n  useLayoutEffect(() => {\n    if (!props.spreadsheet) {\n      return;\n    }\n\n    const elements = renderSpreadsheet(\n      props.chartType,\n      props.spreadsheet,\n      0,\n      0,\n    );\n    setChartElements(elements);\n    let svg: SVGSVGElement;\n    const previewNode = previewRef.current!;\n\n    (async () => {\n      svg = await exportToSvg(\n        elements,\n        {\n          exportBackground: false,\n          viewBackgroundColor: oc.white,\n        },\n        null, // files\n        {\n          skipInliningFonts: true,\n        },\n      );\n      svg.querySelector(\".style-fonts\")?.remove();\n      previewNode.replaceChildren();\n      previewNode.appendChild(svg);\n\n      if (props.selected) {\n        (previewNode.parentNode as HTMLDivElement).focus();\n      }\n    })();\n\n    return () => {\n      previewNode.replaceChildren();\n    };\n  }, [props.spreadsheet, props.chartType, props.selected]);\n\n  return (\n    <button\n      type=\"button\"\n      className=\"ChartPreview\"\n      onClick={() => {\n        if (chartElements) {\n          props.onClick(props.chartType, chartElements);\n        }\n      }}\n    >\n      <div ref={previewRef} />\n    </button>\n  );\n};\n\nexport const PasteChartDialog = ({\n  setAppState,\n  appState,\n  onClose,\n}: {\n  appState: UIAppState;\n  onClose: () => void;\n  setAppState: React.Component<any, UIAppState>[\"setState\"];\n}) => {\n  const { onInsertElements } = useApp();\n  const handleClose = React.useCallback(() => {\n    if (onClose) {\n      onClose();\n    }\n  }, [onClose]);\n\n  const handleChartClick = (chartType: ChartType, elements: ChartElements) => {\n    onInsertElements(elements);\n    trackEvent(\"paste\", \"chart\", chartType);\n    setAppState({\n      currentChartType: chartType,\n      pasteDialog: {\n        shown: false,\n        data: null,\n      },\n    });\n  };\n\n  return (\n    <Dialog\n      size=\"small\"\n      onCloseRequest={handleClose}\n      title={t(\"labels.pasteCharts\")}\n      className={\"PasteChartDialog\"}\n      autofocus={false}\n    >\n      <div className={\"container\"}>\n        <ChartPreviewBtn\n          chartType=\"bar\"\n          spreadsheet={appState.pasteDialog.data}\n          selected={appState.currentChartType === \"bar\"}\n          onClick={handleChartClick}\n        />\n        <ChartPreviewBtn\n          chartType=\"line\"\n          spreadsheet={appState.pasteDialog.data}\n          selected={appState.currentChartType === \"line\"}\n          onClick={handleChartClick}\n        />\n      </div>\n    </Dialog>\n  );\n};\n",
    "import * as Popover from \"@radix-ui/react-popover\";\nimport clsx from \"clsx\";\nimport React, { useLayoutEffect } from \"react\";\n\nimport { supportsResizeObserver, isShallowEqual } from \"@excalidraw/common\";\n\nimport type { MarkRequired } from \"@excalidraw/common/utility-types\";\n\nimport { t } from \"../i18n\";\n\nimport { useExcalidrawActionManager } from \"./App\";\nimport { Island } from \"./Island\";\nimport { QuickSearch } from \"./QuickSearch\";\nimport { ScrollableList } from \"./ScrollableList\";\nimport { Tooltip } from \"./Tooltip\";\n\nimport \"./UserList.scss\";\n\nimport type { ActionManager } from \"../actions/manager\";\nimport type { Collaborator, SocketId } from \"../types\";\n\nexport type GoToCollaboratorComponentProps = {\n  socketId: SocketId;\n  collaborator: Collaborator;\n  withName: boolean;\n  isBeingFollowed: boolean;\n};\n\n/** collaborator user id or socket id (fallback) */\ntype ClientId = string & { _brand: \"UserId\" };\n\nconst DEFAULT_MAX_AVATARS = 4;\nconst SHOW_COLLABORATORS_FILTER_AT = 8;\n\nconst ConditionalTooltipWrapper = ({\n  shouldWrap,\n  children,\n  username,\n}: {\n  shouldWrap: boolean;\n  children: React.ReactNode;\n  username?: string | null;\n}) =>\n  shouldWrap ? (\n    <Tooltip label={username || \"Unknown user\"}>{children}</Tooltip>\n  ) : (\n    <>{children}</>\n  );\n\nconst renderCollaborator = ({\n  actionManager,\n  collaborator,\n  socketId,\n  withName = false,\n  shouldWrapWithTooltip = false,\n  isBeingFollowed,\n}: {\n  actionManager: ActionManager;\n  collaborator: Collaborator;\n  socketId: SocketId;\n  withName?: boolean;\n  shouldWrapWithTooltip?: boolean;\n  isBeingFollowed: boolean;\n}) => {\n  const data: GoToCollaboratorComponentProps = {\n    socketId,\n    collaborator,\n    withName,\n    isBeingFollowed,\n  };\n  const avatarJSX = actionManager.renderAction(\"goToCollaborator\", data);\n\n  return (\n    <ConditionalTooltipWrapper\n      key={socketId}\n      username={collaborator.username}\n      shouldWrap={shouldWrapWithTooltip}\n    >\n      {avatarJSX}\n    </ConditionalTooltipWrapper>\n  );\n};\n\ntype UserListUserObject = Pick<\n  Collaborator,\n  | \"avatarUrl\"\n  | \"id\"\n  | \"socketId\"\n  | \"username\"\n  | \"isInCall\"\n  | \"isSpeaking\"\n  | \"isMuted\"\n>;\n\ntype UserListProps = {\n  className?: string;\n  mobile?: boolean;\n  collaborators: Map<SocketId, UserListUserObject>;\n  userToFollow: SocketId | null;\n};\n\nconst collaboratorComparatorKeys = [\n  \"avatarUrl\",\n  \"id\",\n  \"socketId\",\n  \"username\",\n  \"isInCall\",\n  \"isSpeaking\",\n  \"isMuted\",\n] as const;\n\nexport const UserList = React.memo(\n  ({ className, mobile, collaborators, userToFollow }: UserListProps) => {\n    const actionManager = useExcalidrawActionManager();\n\n    const uniqueCollaboratorsMap = new Map<\n      ClientId,\n      MarkRequired<Collaborator, \"socketId\">\n    >();\n\n    collaborators.forEach((collaborator, socketId) => {\n      const userId = (collaborator.id || socketId) as ClientId;\n      uniqueCollaboratorsMap.set(\n        // filter on user id, else fall back on unique socketId\n        userId,\n        { ...collaborator, socketId },\n      );\n    });\n\n    const uniqueCollaboratorsArray = Array.from(\n      uniqueCollaboratorsMap.values(),\n    ).filter((collaborator) => collaborator.username?.trim());\n\n    const [searchTerm, setSearchTerm] = React.useState(\"\");\n    const filteredCollaborators = uniqueCollaboratorsArray.filter(\n      (collaborator) =>\n        collaborator.username?.toLowerCase().includes(searchTerm),\n    );\n\n    const userListWrapper = React.useRef<HTMLDivElement | null>(null);\n\n    useLayoutEffect(() => {\n      if (userListWrapper.current) {\n        const updateMaxAvatars = (width: number) => {\n          const maxAvatars = Math.max(1, Math.min(8, Math.floor(width / 38)));\n          setMaxAvatars(maxAvatars);\n        };\n\n        updateMaxAvatars(userListWrapper.current.clientWidth);\n\n        if (!supportsResizeObserver) {\n          return;\n        }\n\n        const resizeObserver = new ResizeObserver((entries) => {\n          for (const entry of entries) {\n            const { width } = entry.contentRect;\n            updateMaxAvatars(width);\n          }\n        });\n\n        resizeObserver.observe(userListWrapper.current);\n\n        return () => {\n          resizeObserver.disconnect();\n        };\n      }\n    }, []);\n\n    const [maxAvatars, setMaxAvatars] = React.useState(DEFAULT_MAX_AVATARS);\n\n    const firstNCollaborators = uniqueCollaboratorsArray.slice(\n      0,\n      maxAvatars - 1,\n    );\n\n    const firstNAvatarsJSX = firstNCollaborators.map((collaborator) =>\n      renderCollaborator({\n        actionManager,\n        collaborator,\n        socketId: collaborator.socketId,\n        shouldWrapWithTooltip: true,\n        isBeingFollowed: collaborator.socketId === userToFollow,\n      }),\n    );\n\n    return mobile ? (\n      <div className={clsx(\"UserList UserList_mobile\", className)}>\n        {uniqueCollaboratorsArray.map((collaborator) =>\n          renderCollaborator({\n            actionManager,\n            collaborator,\n            socketId: collaborator.socketId,\n            shouldWrapWithTooltip: true,\n            isBeingFollowed: collaborator.socketId === userToFollow,\n          }),\n        )}\n      </div>\n    ) : (\n      <div className=\"UserList__wrapper\" ref={userListWrapper}>\n        <div\n          className={clsx(\"UserList\", className)}\n          style={{ [`--max-avatars` as any]: maxAvatars }}\n        >\n          {firstNAvatarsJSX}\n\n          {uniqueCollaboratorsArray.length > maxAvatars - 1 && (\n            <Popover.Root>\n              <Popover.Trigger className=\"UserList__more\">\n                +{uniqueCollaboratorsArray.length - maxAvatars + 1}\n              </Popover.Trigger>\n              <Popover.Content\n                style={{\n                  zIndex: 2,\n                  width: \"15rem\",\n                  textAlign: \"left\",\n                }}\n                align=\"end\"\n                sideOffset={10}\n              >\n                <Island padding={2}>\n                  {uniqueCollaboratorsArray.length >=\n                    SHOW_COLLABORATORS_FILTER_AT && (\n                    <QuickSearch\n                      placeholder={t(\"quickSearch.placeholder\")}\n                      onChange={setSearchTerm}\n                    />\n                  )}\n                  <ScrollableList\n                    className={\"dropdown-menu UserList__collaborators\"}\n                    placeholder={t(\"userList.empty\")}\n                  >\n                    {/* The list checks for `Children.count()`, hence defensively returning empty list */}\n                    {filteredCollaborators.length > 0\n                      ? [\n                          <div className=\"hint\">{t(\"userList.hint.text\")}</div>,\n                          filteredCollaborators.map((collaborator) =>\n                            renderCollaborator({\n                              actionManager,\n                              collaborator,\n                              socketId: collaborator.socketId,\n                              withName: true,\n                              isBeingFollowed:\n                                collaborator.socketId === userToFollow,\n                            }),\n                          ),\n                        ]\n                      : []}\n                  </ScrollableList>\n                  <Popover.Arrow\n                    width={20}\n                    height={10}\n                    style={{\n                      fill: \"var(--popup-bg-color)\",\n                      filter: \"drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)\",\n                    }}\n                  />\n                </Island>\n              </Popover.Content>\n            </Popover.Root>\n          )}\n        </div>\n      </div>\n    );\n  },\n  (prev, next) => {\n    if (\n      prev.collaborators.size !== next.collaborators.size ||\n      prev.mobile !== next.mobile ||\n      prev.className !== next.className ||\n      prev.userToFollow !== next.userToFollow\n    ) {\n      return false;\n    }\n\n    const nextCollaboratorSocketIds = next.collaborators.keys();\n\n    for (const [socketId, collaborator] of prev.collaborators) {\n      const nextCollaborator = next.collaborators.get(socketId);\n      if (\n        !nextCollaborator ||\n        // this checks order of collaborators in the map is the same\n        // as previous render\n        socketId !== nextCollaboratorSocketIds.next().value ||\n        !isShallowEqual(\n          collaborator,\n          nextCollaborator,\n          collaboratorComparatorKeys,\n        )\n      ) {\n        return false;\n      }\n    }\n    return true;\n  },\n);\n",
    "import clsx from \"clsx\";\n\nimport { actionShortcuts } from \"../../actions\";\nimport { useTunnels } from \"../../context/tunnels\";\nimport {\n  ExitZenModeAction,\n  FinalizeAction,\n  UndoRedoActions,\n  ZoomActions,\n} from \"../Actions\";\nimport { useDevice } from \"../App\";\nimport { HelpButton } from \"../HelpButton\";\nimport { Section } from \"../Section\";\nimport Stack from \"../Stack\";\n\nimport type { ActionManager } from \"../../actions/manager\";\nimport type { UIAppState } from \"../../types\";\n\nconst Footer = ({\n  appState,\n  actionManager,\n  showExitZenModeBtn,\n  renderWelcomeScreen,\n}: {\n  appState: UIAppState;\n  actionManager: ActionManager;\n  showExitZenModeBtn: boolean;\n  renderWelcomeScreen: boolean;\n}) => {\n  const { FooterCenterTunnel, WelcomeScreenHelpHintTunnel } = useTunnels();\n\n  const device = useDevice();\n  const showFinalize =\n    !appState.viewModeEnabled && appState.multiElement && device.isTouchScreen;\n\n  return (\n    <footer\n      role=\"contentinfo\"\n      className=\"layer-ui__wrapper__footer App-menu App-menu_bottom\"\n    >\n      <div\n        className={clsx(\"layer-ui__wrapper__footer-left zen-mode-transition\", {\n          \"layer-ui__wrapper__footer-left--transition-left\":\n            appState.zenModeEnabled,\n        })}\n      >\n        <Stack.Col gap={2}>\n          <Section heading=\"canvasActions\">\n            <ZoomActions\n              renderAction={actionManager.renderAction}\n              zoom={appState.zoom}\n            />\n\n            {!appState.viewModeEnabled && (\n              <UndoRedoActions\n                renderAction={actionManager.renderAction}\n                className={clsx(\"zen-mode-transition\", {\n                  \"layer-ui__wrapper__footer-left--transition-bottom\":\n                    appState.zenModeEnabled,\n                })}\n              />\n            )}\n            {showFinalize && (\n              <FinalizeAction\n                renderAction={actionManager.renderAction}\n                className={clsx(\"zen-mode-transition\", {\n                  \"layer-ui__wrapper__footer-left--transition-left\":\n                    appState.zenModeEnabled,\n                })}\n              />\n            )}\n          </Section>\n        </Stack.Col>\n      </div>\n      <FooterCenterTunnel.Out />\n      <div\n        className={clsx(\"layer-ui__wrapper__footer-right zen-mode-transition\", {\n          \"transition-right\": appState.zenModeEnabled,\n        })}\n      >\n        <div style={{ position: \"relative\" }}>\n          {renderWelcomeScreen && <WelcomeScreenHelpHintTunnel.Out />}\n          <HelpButton\n            onClick={() => actionManager.executeAction(actionShortcuts)}\n          />\n        </div>\n      </div>\n      <ExitZenModeAction\n        actionManager={actionManager}\n        showExitZenModeBtn={showExitZenModeBtn}\n      />\n    </footer>\n  );\n};\n\nexport default Footer;\nFooter.displayName = \"Footer\";\n",
    "import { t } from \"../i18n\";\n\nimport { HelpIcon } from \"./icons\";\n\ntype HelpButtonProps = {\n  name?: string;\n  id?: string;\n  onClick?(): void;\n};\n\nexport const HelpButton = (props: HelpButtonProps) => (\n  <button\n    className=\"help-icon\"\n    onClick={props.onClick}\n    type=\"button\"\n    title={`${t(\"helpDialog.title\")} — ?`}\n    aria-label={t(\"helpDialog.title\")}\n  >\n    {HelpIcon}\n  </button>\n);\n",
    "import clsx from \"clsx\";\nimport React, {\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n  forwardRef,\n  useImperativeHandle,\n  useCallback,\n} from \"react\";\n\nimport { EVENT, isDevEnv, KEYS, updateObject } from \"@excalidraw/common\";\n\nimport { useUIAppState } from \"../../context/ui-appState\";\nimport { atom, useSetAtom } from \"../../editor-jotai\";\nimport { useOutsideClick } from \"../../hooks/useOutsideClick\";\nimport { useDevice, useExcalidrawSetAppState } from \"../App\";\nimport { Island } from \"../Island\";\n\nimport { SidebarHeader } from \"./SidebarHeader\";\nimport { SidebarTabTrigger } from \"./SidebarTabTrigger\";\nimport { SidebarTabTriggers } from \"./SidebarTabTriggers\";\nimport { SidebarTrigger } from \"./SidebarTrigger\";\nimport { SidebarPropsContext } from \"./common\";\nimport { SidebarTabs } from \"./SidebarTabs\";\nimport { SidebarTab } from \"./SidebarTab\";\n\nimport \"./Sidebar.scss\";\n\nimport type { SidebarProps, SidebarPropsContextValue } from \"./common\";\n\n/**\n * Flags whether the currently rendered Sidebar is docked or not, for use\n * in upstream components that need to act on this (e.g. LayerUI to shift the\n * UI). We use an atom because of potential host app sidebars (for the default\n * sidebar we could just read from appState.defaultSidebarDockedPreference).\n *\n * Since we can only render one Sidebar at a time, we can use a simple flag.\n */\nexport const isSidebarDockedAtom = atom(false);\n\nexport const SidebarInner = forwardRef(\n  (\n    {\n      name,\n      children,\n      onDock,\n      docked,\n      className,\n      ...rest\n    }: SidebarProps & Omit<React.RefAttributes<HTMLDivElement>, \"onSelect\">,\n    ref: React.ForwardedRef<HTMLDivElement>,\n  ) => {\n    if (isDevEnv() && onDock && docked == null) {\n      console.warn(\n        \"Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`\",\n      );\n    }\n\n    const setAppState = useExcalidrawSetAppState();\n\n    const setIsSidebarDockedAtom = useSetAtom(isSidebarDockedAtom);\n\n    useLayoutEffect(() => {\n      setIsSidebarDockedAtom(!!docked);\n      return () => {\n        setIsSidebarDockedAtom(false);\n      };\n    }, [setIsSidebarDockedAtom, docked]);\n\n    const headerPropsRef = useRef<SidebarPropsContextValue>(\n      {} as SidebarPropsContextValue,\n    );\n    headerPropsRef.current.onCloseRequest = () => {\n      setAppState({ openSidebar: null });\n    };\n    headerPropsRef.current.onDock = (isDocked) => onDock?.(isDocked);\n    // renew the ref object if the following props change since we want to\n    // rerender. We can't pass down as component props manually because\n    // the <Sidebar.Header/> can be rendered upstream.\n    headerPropsRef.current = updateObject(headerPropsRef.current, {\n      docked,\n      // explicit prop to rerender on update\n      shouldRenderDockButton: !!onDock && docked != null,\n    });\n\n    const islandRef = useRef<HTMLDivElement>(null);\n\n    useImperativeHandle(ref, () => {\n      return islandRef.current!;\n    });\n\n    const device = useDevice();\n\n    const closeLibrary = useCallback(() => {\n      const isDialogOpen = !!document.querySelector(\".Dialog\");\n\n      // Prevent closing if any dialog is open\n      if (isDialogOpen) {\n        return;\n      }\n      setAppState({ openSidebar: null });\n    }, [setAppState]);\n\n    useOutsideClick(\n      islandRef,\n      useCallback(\n        (event) => {\n          // If click on the library icon, do nothing so that LibraryButton\n          // can toggle library menu\n          if ((event.target as Element).closest(\".sidebar-trigger\")) {\n            return;\n          }\n          if (!docked || !device.editor.canFitSidebar) {\n            closeLibrary();\n          }\n        },\n        [closeLibrary, docked, device.editor.canFitSidebar],\n      ),\n    );\n\n    useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (\n          event.key === KEYS.ESCAPE &&\n          (!docked || !device.editor.canFitSidebar)\n        ) {\n          closeLibrary();\n        }\n      };\n      document.addEventListener(EVENT.KEYDOWN, handleKeyDown);\n      return () => {\n        document.removeEventListener(EVENT.KEYDOWN, handleKeyDown);\n      };\n    }, [closeLibrary, docked, device.editor.canFitSidebar]);\n\n    return (\n      <Island\n        {...rest}\n        className={clsx(\"sidebar\", { \"sidebar--docked\": docked }, className)}\n        ref={islandRef}\n      >\n        <SidebarPropsContext.Provider value={headerPropsRef.current}>\n          {children}\n        </SidebarPropsContext.Provider>\n      </Island>\n    );\n  },\n);\nSidebarInner.displayName = \"SidebarInner\";\n\nexport const Sidebar = Object.assign(\n  forwardRef((props: SidebarProps, ref: React.ForwardedRef<HTMLDivElement>) => {\n    const appState = useUIAppState();\n\n    const { onStateChange } = props;\n\n    const refPrevOpenSidebar = useRef(appState.openSidebar);\n    useEffect(() => {\n      if (\n        // closing sidebar\n        ((!appState.openSidebar &&\n          refPrevOpenSidebar?.current?.name === props.name) ||\n          // opening current sidebar\n          (appState.openSidebar?.name === props.name &&\n            refPrevOpenSidebar?.current?.name !== props.name) ||\n          // switching tabs or switching to a different sidebar\n          refPrevOpenSidebar.current?.name === props.name) &&\n        appState.openSidebar !== refPrevOpenSidebar.current\n      ) {\n        onStateChange?.(\n          appState.openSidebar?.name !== props.name\n            ? null\n            : appState.openSidebar,\n        );\n      }\n      refPrevOpenSidebar.current = appState.openSidebar;\n    }, [appState.openSidebar, onStateChange, props.name]);\n\n    const [mounted, setMounted] = useState(false);\n    useLayoutEffect(() => {\n      setMounted(true);\n      return () => setMounted(false);\n    }, []);\n\n    // We want to render in the next tick (hence `mounted` flag) so that it's\n    // guaranteed to happen after unmount of the previous sidebar (in case the\n    // previous sidebar is mounted after the next one). This is necessary to\n    // prevent flicker of subcomponents that support fallbacks\n    // (e.g. SidebarHeader). This is because we're using flags to determine\n    // whether prefer the fallback component or not (otherwise both will render\n    // initially), and the flag won't be reset in time if the unmount order\n    // it not correct.\n    //\n    // Alternative, and more general solution would be to namespace the fallback\n    // HoC so that state is not shared between subcomponents when the wrapping\n    // component is of the same type (e.g. Sidebar -> SidebarHeader).\n    const shouldRender = mounted && appState.openSidebar?.name === props.name;\n\n    if (!shouldRender) {\n      return null;\n    }\n\n    return <SidebarInner {...props} ref={ref} key={props.name} />;\n  }),\n  {\n    Header: SidebarHeader,\n    TabTriggers: SidebarTabTriggers,\n    TabTrigger: SidebarTabTrigger,\n    Tabs: SidebarTabs,\n    Tab: SidebarTab,\n    Trigger: SidebarTrigger,\n  },\n);\nSidebar.displayName = \"Sidebar\";\n",
    "import clsx from \"clsx\";\nimport { useContext } from \"react\";\n\nimport { t } from \"../../i18n\";\nimport { useDevice } from \"../App\";\nimport { Button } from \"../Button\";\nimport { Tooltip } from \"../Tooltip\";\nimport { CloseIcon, PinIcon } from \"../icons\";\n\nimport { SidebarPropsContext } from \"./common\";\n\nexport const SidebarHeader = ({\n  children,\n  className,\n}: {\n  children?: React.ReactNode;\n  className?: string;\n}) => {\n  const device = useDevice();\n  const props = useContext(SidebarPropsContext);\n\n  const renderDockButton = !!(\n    device.editor.canFitSidebar && props.shouldRenderDockButton\n  );\n\n  return (\n    <div\n      className={clsx(\"sidebar__header\", className)}\n      data-testid=\"sidebar-header\"\n    >\n      {children}\n      <div className=\"sidebar__header__buttons\">\n        {renderDockButton && (\n          <Tooltip label={t(\"labels.sidebarLock\")}>\n            <Button\n              onSelect={() => props.onDock?.(!props.docked)}\n              selected={!!props.docked}\n              className=\"sidebar__dock\"\n              data-testid=\"sidebar-dock\"\n              aria-label={t(\"labels.sidebarLock\")}\n            >\n              {PinIcon}\n            </Button>\n          </Tooltip>\n        )}\n        <Button\n          data-testid=\"sidebar-close\"\n          className=\"sidebar__close\"\n          onSelect={props.onCloseRequest}\n          aria-label={t(\"buttons.close\")}\n        >\n          {CloseIcon}\n        </Button>\n      </div>\n    </div>\n  );\n};\n\nSidebarHeader.displayName = \"SidebarHeader\";\n",
    "import React from \"react\";\n\nimport type { AppState, SidebarName, SidebarTabName } from \"../../types\";\nimport type { JSX } from \"react\";\n\nexport type SidebarTriggerProps = {\n  name: SidebarName;\n  tab?: SidebarTabName;\n  icon?: JSX.Element;\n  children?: React.ReactNode;\n  title?: string;\n  className?: string;\n  onToggle?: (open: boolean) => void;\n  style?: React.CSSProperties;\n};\n\nexport type SidebarProps<P = {}> = {\n  name: SidebarName;\n  children: React.ReactNode;\n  /**\n   * Called on sidebar open/close or tab change.\n   */\n  onStateChange?: (state: AppState[\"openSidebar\"]) => void;\n  /**\n   * supply alongside `docked` prop in order to make the Sidebar user-dockable\n   */\n  onDock?: (docked: boolean) => void;\n  docked?: boolean;\n  className?: string;\n  // NOTE sidebars we use internally inside the editor must have this flag set.\n  // It indicates that this sidebar should have lower precedence over host\n  // sidebars, if both are open.\n  /** @private internal */\n  __fallback?: boolean;\n} & P;\n\nexport type SidebarPropsContextValue = Pick<\n  SidebarProps,\n  \"onDock\" | \"docked\"\n> & { onCloseRequest: () => void; shouldRenderDockButton: boolean };\n\nexport const SidebarPropsContext =\n  React.createContext<SidebarPropsContextValue>({} as SidebarPropsContextValue);\n",
    "import * as RadixTabs from \"@radix-ui/react-tabs\";\n\nimport type { SidebarTabName } from \"../../types\";\n\nexport const SidebarTabTrigger = ({\n  children,\n  tab,\n  onSelect,\n  ...rest\n}: {\n  children: React.ReactNode;\n  tab: SidebarTabName;\n  onSelect?: React.ReactEventHandler<HTMLButtonElement> | undefined;\n} & Omit<React.HTMLAttributes<HTMLButtonElement>, \"onSelect\">) => {\n  return (\n    <RadixTabs.Trigger value={tab} asChild onSelect={onSelect}>\n      <button\n        type={\"button\"}\n        className={`excalidraw-button sidebar-tab-trigger`}\n        {...rest}\n      >\n        {children}\n      </button>\n    </RadixTabs.Trigger>\n  );\n};\nSidebarTabTrigger.displayName = \"SidebarTabTrigger\";\n",
    "import * as RadixTabs from \"@radix-ui/react-tabs\";\n\nexport const SidebarTabTriggers = ({\n  children,\n  ...rest\n}: { children: React.ReactNode } & Omit<\n  React.RefAttributes<HTMLDivElement>,\n  \"onSelect\"\n>) => {\n  return (\n    <RadixTabs.List className=\"sidebar-triggers\" {...rest}>\n      {children}\n    </RadixTabs.List>\n  );\n};\nSidebarTabTriggers.displayName = \"SidebarTabTriggers\";\n",
    "import clsx from \"clsx\";\n\nimport { useUIAppState } from \"../../context/ui-appState\";\nimport { useExcalidrawSetAppState } from \"../App\";\n\nimport \"./SidebarTrigger.scss\";\n\nimport type { SidebarTriggerProps } from \"./common\";\n\nexport const SidebarTrigger = ({\n  name,\n  tab,\n  icon,\n  title,\n  children,\n  onToggle,\n  className,\n  style,\n}: SidebarTriggerProps) => {\n  const setAppState = useExcalidrawSetAppState();\n  const appState = useUIAppState();\n\n  return (\n    <label title={title} className=\"sidebar-trigger__label-element\">\n      <input\n        className=\"ToolIcon_type_checkbox\"\n        type=\"checkbox\"\n        onChange={(event) => {\n          document\n            .querySelector(\".layer-ui__wrapper\")\n            ?.classList.remove(\"animate\");\n          const isOpen = event.target.checked;\n          setAppState({ openSidebar: isOpen ? { name, tab } : null });\n          onToggle?.(isOpen);\n        }}\n        checked={appState.openSidebar?.name === name}\n        aria-label={title}\n        aria-keyshortcuts=\"0\"\n      />\n      <div className={clsx(\"sidebar-trigger\", className)} style={style}>\n        {icon && <div>{icon}</div>}\n        {children && <div className=\"sidebar-trigger__label\">{children}</div>}\n      </div>\n    </label>\n  );\n};\nSidebarTrigger.displayName = \"SidebarTrigger\";\n",
    "import * as RadixTabs from \"@radix-ui/react-tabs\";\n\nimport { useUIAppState } from \"../../context/ui-appState\";\nimport { useExcalidrawSetAppState } from \"../App\";\n\nexport const SidebarTabs = ({\n  children,\n  ...rest\n}: {\n  children: React.ReactNode;\n} & Omit<React.RefAttributes<HTMLDivElement>, \"onSelect\">) => {\n  const appState = useUIAppState();\n  const setAppState = useExcalidrawSetAppState();\n\n  if (!appState.openSidebar) {\n    return null;\n  }\n\n  const { name } = appState.openSidebar;\n\n  return (\n    <RadixTabs.Root\n      className=\"sidebar-tabs-root\"\n      value={appState.openSidebar.tab}\n      onValueChange={(tab) =>\n        setAppState((state) => ({\n          ...state,\n          openSidebar: { ...state.openSidebar, name, tab },\n        }))\n      }\n      {...rest}\n    >\n      {children}\n    </RadixTabs.Root>\n  );\n};\nSidebarTabs.displayName = \"SidebarTabs\";\n",
    "import * as RadixTabs from \"@radix-ui/react-tabs\";\n\nimport type { SidebarTabName } from \"../../types\";\n\nexport const SidebarTab = ({\n  tab,\n  children,\n  ...rest\n}: {\n  tab: SidebarTabName;\n  children: React.ReactNode;\n} & React.HTMLAttributes<HTMLDivElement>) => {\n  return (\n    <RadixTabs.Content {...rest} value={tab} data-testid={tab}>\n      {children}\n    </RadixTabs.Content>\n  );\n};\nSidebarTab.displayName = \"SidebarTab\";\n",
    "import React from \"react\";\n\nimport { composeEventHandlers } from \"@excalidraw/common\";\n\nimport { useTunnels } from \"../../context/tunnels\";\nimport { useUIAppState } from \"../../context/ui-appState\";\nimport { t } from \"../../i18n\";\nimport { useDevice, useExcalidrawSetAppState } from \"../App\";\nimport { UserList } from \"../UserList\";\nimport DropdownMenu from \"../dropdownMenu/DropdownMenu\";\nimport { withInternalFallback } from \"../hoc/withInternalFallback\";\nimport { HamburgerMenuIcon } from \"../icons\";\n\nimport * as DefaultItems from \"./DefaultItems\";\n\nconst MainMenu = Object.assign(\n  withInternalFallback(\n    \"MainMenu\",\n    ({\n      children,\n      onSelect,\n    }: {\n      children?: React.ReactNode;\n      /**\n       * Called when any menu item is selected (clicked on).\n       */\n      onSelect?: (event: Event) => void;\n    }) => {\n      const { MainMenuTunnel } = useTunnels();\n      const device = useDevice();\n      const appState = useUIAppState();\n      const setAppState = useExcalidrawSetAppState();\n      const onClickOutside = device.editor.isMobile\n        ? undefined\n        : () => setAppState({ openMenu: null });\n\n      return (\n        <MainMenuTunnel.In>\n          <DropdownMenu open={appState.openMenu === \"canvas\"}>\n            <DropdownMenu.Trigger\n              onToggle={() => {\n                setAppState({\n                  openMenu: appState.openMenu === \"canvas\" ? null : \"canvas\",\n                });\n              }}\n              data-testid=\"main-menu-trigger\"\n              className=\"main-menu-trigger\"\n            >\n              {HamburgerMenuIcon}\n            </DropdownMenu.Trigger>\n            <DropdownMenu.Content\n              onClickOutside={onClickOutside}\n              onSelect={composeEventHandlers(onSelect, () => {\n                setAppState({ openMenu: null });\n              })}\n            >\n              {children}\n              {device.editor.isMobile && appState.collaborators.size > 0 && (\n                <fieldset className=\"UserList-Wrapper\">\n                  <legend>{t(\"labels.collaborators\")}</legend>\n                  <UserList\n                    mobile={true}\n                    collaborators={appState.collaborators}\n                    userToFollow={appState.userToFollow?.socketId || null}\n                  />\n                </fieldset>\n              )}\n            </DropdownMenu.Content>\n          </DropdownMenu>\n        </MainMenuTunnel.In>\n      );\n    },\n  ),\n  {\n    Trigger: DropdownMenu.Trigger,\n    Item: DropdownMenu.Item,\n    ItemLink: DropdownMenu.ItemLink,\n    ItemCustom: DropdownMenu.ItemCustom,\n    Group: DropdownMenu.Group,\n    Separator: DropdownMenu.Separator,\n    DefaultItems,\n  },\n);\n\nexport default MainMenu;\n",
    "import React, { useLayoutEffect, useRef } from \"react\";\n\nimport { useTunnels } from \"../../context/tunnels\";\nimport { atom } from \"../../editor-jotai\";\n\nexport const withInternalFallback = <P,>(\n  componentName: string,\n  Component: React.FC<P>,\n) => {\n  const renderAtom = atom(0);\n\n  const WrapperComponent: React.FC<\n    P & {\n      __fallback?: boolean;\n    }\n  > = (props) => {\n    const {\n      tunnelsJotai: { useAtom },\n    } = useTunnels();\n    // for rerenders\n    const [, setCounter] = useAtom(renderAtom);\n    // for initial & subsequent renders. Tracked as component state\n    // due to excalidraw multi-instance scanerios.\n    const metaRef = useRef({\n      // flag set on initial render to tell the fallback component to skip the\n      // render until mount counter are initialized. This is because the counter\n      // is initialized in an effect, and thus we could end rendering both\n      // components at the same time until counter is initialized.\n      preferHost: false,\n      counter: 0,\n    });\n\n    useLayoutEffect(() => {\n      const meta = metaRef.current;\n      setCounter((c) => {\n        const next = c + 1;\n        meta.counter = next;\n\n        return next;\n      });\n      return () => {\n        setCounter((c) => {\n          const next = c - 1;\n          meta.counter = next;\n          if (!next) {\n            meta.preferHost = false;\n          }\n          return next;\n        });\n      };\n    }, [setCounter]);\n\n    if (!props.__fallback) {\n      metaRef.current.preferHost = true;\n    }\n\n    // ensure we don't render fallback and host components at the same time\n    if (\n      // either before the counters are initialized\n      (!metaRef.current.counter &&\n        props.__fallback &&\n        metaRef.current.preferHost) ||\n      // or after the counters are initialized, and both are rendered\n      // (this is the default when host renders as well)\n      (metaRef.current.counter > 1 && props.__fallback)\n    ) {\n      return null;\n    }\n\n    return <Component {...props} />;\n  };\n\n  WrapperComponent.displayName = componentName;\n\n  return WrapperComponent;\n};\n",
    "import clsx from \"clsx\";\n\nimport { THEME } from \"@excalidraw/common\";\n\nimport type { Theme } from \"@excalidraw/element/types\";\n\nimport {\n  actionClearCanvas,\n  actionLoadScene,\n  actionSaveToActiveFile,\n  actionShortcuts,\n  actionToggleSearchMenu,\n  actionToggleTheme,\n} from \"../../actions\";\nimport { getShortcutFromShortcutName } from \"../../actions/shortcuts\";\nimport { trackEvent } from \"../../analytics\";\nimport { useUIAppState } from \"../../context/ui-appState\";\nimport { useSetAtom } from \"../../editor-jotai\";\nimport { useI18n } from \"../../i18n\";\nimport { activeConfirmDialogAtom } from \"../ActiveConfirmDialog\";\nimport {\n  useExcalidrawSetAppState,\n  useExcalidrawActionManager,\n  useExcalidrawElements,\n  useAppProps,\n} from \"../App\";\nimport { openConfirmModal } from \"../OverwriteConfirm/OverwriteConfirmState\";\nimport Trans from \"../Trans\";\nimport DropdownMenuItem from \"../dropdownMenu/DropdownMenuItem\";\nimport DropdownMenuItemContentRadio from \"../dropdownMenu/DropdownMenuItemContentRadio\";\nimport DropdownMenuItemLink from \"../dropdownMenu/DropdownMenuItemLink\";\nimport { GithubIcon, DiscordIcon, XBrandIcon } from \"../icons\";\nimport {\n  boltIcon,\n  DeviceDesktopIcon,\n  ExportIcon,\n  ExportImageIcon,\n  HelpIcon,\n  LoadIcon,\n  MoonIcon,\n  save,\n  searchIcon,\n  SunIcon,\n  TrashIcon,\n  usersIcon,\n} from \"../icons\";\n\nimport \"./DefaultItems.scss\";\n\nexport const LoadScene = () => {\n  const { t } = useI18n();\n  const actionManager = useExcalidrawActionManager();\n  const elements = useExcalidrawElements();\n\n  if (!actionManager.isActionEnabled(actionLoadScene)) {\n    return null;\n  }\n\n  const handleSelect = async () => {\n    if (\n      !elements.length ||\n      (await openConfirmModal({\n        title: t(\"overwriteConfirm.modal.loadFromFile.title\"),\n        actionLabel: t(\"overwriteConfirm.modal.loadFromFile.button\"),\n        color: \"warning\",\n        description: (\n          <Trans\n            i18nKey=\"overwriteConfirm.modal.loadFromFile.description\"\n            bold={(text) => <strong>{text}</strong>}\n            br={() => <br />}\n          />\n        ),\n      }))\n    ) {\n      actionManager.executeAction(actionLoadScene);\n    }\n  };\n\n  return (\n    <DropdownMenuItem\n      icon={LoadIcon}\n      onSelect={handleSelect}\n      data-testid=\"load-button\"\n      shortcut={getShortcutFromShortcutName(\"loadScene\")}\n      aria-label={t(\"buttons.load\")}\n    >\n      {t(\"buttons.load\")}\n    </DropdownMenuItem>\n  );\n};\nLoadScene.displayName = \"LoadScene\";\n\nexport const SaveToActiveFile = () => {\n  const { t } = useI18n();\n  const actionManager = useExcalidrawActionManager();\n\n  if (!actionManager.isActionEnabled(actionSaveToActiveFile)) {\n    return null;\n  }\n\n  return (\n    <DropdownMenuItem\n      shortcut={getShortcutFromShortcutName(\"saveScene\")}\n      data-testid=\"save-button\"\n      onSelect={() => actionManager.executeAction(actionSaveToActiveFile)}\n      icon={save}\n      aria-label={`${t(\"buttons.save\")}`}\n    >{`${t(\"buttons.save\")}`}</DropdownMenuItem>\n  );\n};\nSaveToActiveFile.displayName = \"SaveToActiveFile\";\n\nexport const SaveAsImage = () => {\n  const setAppState = useExcalidrawSetAppState();\n  const { t } = useI18n();\n  return (\n    <DropdownMenuItem\n      icon={ExportImageIcon}\n      data-testid=\"image-export-button\"\n      onSelect={() => setAppState({ openDialog: { name: \"imageExport\" } })}\n      shortcut={getShortcutFromShortcutName(\"imageExport\")}\n      aria-label={t(\"buttons.exportImage\")}\n    >\n      {t(\"buttons.exportImage\")}\n    </DropdownMenuItem>\n  );\n};\nSaveAsImage.displayName = \"SaveAsImage\";\n\nexport const CommandPalette = (opts?: { className?: string }) => {\n  const setAppState = useExcalidrawSetAppState();\n  const { t } = useI18n();\n\n  return (\n    <DropdownMenuItem\n      icon={boltIcon}\n      data-testid=\"command-palette-button\"\n      onSelect={() => {\n        trackEvent(\"command_palette\", \"open\", \"menu\");\n        setAppState({ openDialog: { name: \"commandPalette\" } });\n      }}\n      shortcut={getShortcutFromShortcutName(\"commandPalette\")}\n      aria-label={t(\"commandPalette.title\")}\n      className={opts?.className}\n    >\n      {t(\"commandPalette.title\")}\n    </DropdownMenuItem>\n  );\n};\nCommandPalette.displayName = \"CommandPalette\";\n\nexport const SearchMenu = (opts?: { className?: string }) => {\n  const { t } = useI18n();\n  const actionManager = useExcalidrawActionManager();\n\n  return (\n    <DropdownMenuItem\n      icon={searchIcon}\n      data-testid=\"search-menu-button\"\n      onSelect={() => {\n        actionManager.executeAction(actionToggleSearchMenu);\n      }}\n      shortcut={getShortcutFromShortcutName(\"searchMenu\")}\n      aria-label={t(\"search.title\")}\n      className={opts?.className}\n    >\n      {t(\"search.title\")}\n    </DropdownMenuItem>\n  );\n};\nSearchMenu.displayName = \"SearchMenu\";\n\nexport const Help = () => {\n  const { t } = useI18n();\n\n  const actionManager = useExcalidrawActionManager();\n\n  return (\n    <DropdownMenuItem\n      data-testid=\"help-menu-item\"\n      icon={HelpIcon}\n      onSelect={() => actionManager.executeAction(actionShortcuts)}\n      shortcut=\"?\"\n      aria-label={t(\"helpDialog.title\")}\n    >\n      {t(\"helpDialog.title\")}\n    </DropdownMenuItem>\n  );\n};\nHelp.displayName = \"Help\";\n\nexport const ClearCanvas = () => {\n  const { t } = useI18n();\n\n  const setActiveConfirmDialog = useSetAtom(activeConfirmDialogAtom);\n  const actionManager = useExcalidrawActionManager();\n\n  if (!actionManager.isActionEnabled(actionClearCanvas)) {\n    return null;\n  }\n\n  return (\n    <DropdownMenuItem\n      icon={TrashIcon}\n      onSelect={() => setActiveConfirmDialog(\"clearCanvas\")}\n      data-testid=\"clear-canvas-button\"\n      aria-label={t(\"buttons.clearReset\")}\n    >\n      {t(\"buttons.clearReset\")}\n    </DropdownMenuItem>\n  );\n};\nClearCanvas.displayName = \"ClearCanvas\";\n\nexport const ToggleTheme = (\n  props:\n    | {\n        allowSystemTheme: true;\n        theme: Theme | \"system\";\n        onSelect: (theme: Theme | \"system\") => void;\n      }\n    | {\n        allowSystemTheme?: false;\n        onSelect?: (theme: Theme) => void;\n      },\n) => {\n  const { t } = useI18n();\n  const appState = useUIAppState();\n  const actionManager = useExcalidrawActionManager();\n  const shortcut = getShortcutFromShortcutName(\"toggleTheme\");\n\n  if (!actionManager.isActionEnabled(actionToggleTheme)) {\n    return null;\n  }\n\n  if (props?.allowSystemTheme) {\n    return (\n      <DropdownMenuItemContentRadio\n        name=\"theme\"\n        value={props.theme}\n        onChange={(value: Theme | \"system\") => props.onSelect(value)}\n        choices={[\n          {\n            value: THEME.LIGHT,\n            label: SunIcon,\n            ariaLabel: `${t(\"buttons.lightMode\")} - ${shortcut}`,\n          },\n          {\n            value: THEME.DARK,\n            label: MoonIcon,\n            ariaLabel: `${t(\"buttons.darkMode\")} - ${shortcut}`,\n          },\n          {\n            value: \"system\",\n            label: DeviceDesktopIcon,\n            ariaLabel: t(\"buttons.systemMode\"),\n          },\n        ]}\n      >\n        {t(\"labels.theme\")}\n      </DropdownMenuItemContentRadio>\n    );\n  }\n\n  return (\n    <DropdownMenuItem\n      onSelect={(event) => {\n        // do not close the menu when changing theme\n        event.preventDefault();\n\n        if (props?.onSelect) {\n          props.onSelect(\n            appState.theme === THEME.DARK ? THEME.LIGHT : THEME.DARK,\n          );\n        } else {\n          return actionManager.executeAction(actionToggleTheme);\n        }\n      }}\n      icon={appState.theme === THEME.DARK ? SunIcon : MoonIcon}\n      data-testid=\"toggle-dark-mode\"\n      shortcut={shortcut}\n      aria-label={\n        appState.theme === THEME.DARK\n          ? t(\"buttons.lightMode\")\n          : t(\"buttons.darkMode\")\n      }\n    >\n      {appState.theme === THEME.DARK\n        ? t(\"buttons.lightMode\")\n        : t(\"buttons.darkMode\")}\n    </DropdownMenuItem>\n  );\n};\nToggleTheme.displayName = \"ToggleTheme\";\n\nexport const ChangeCanvasBackground = () => {\n  const { t } = useI18n();\n  const appState = useUIAppState();\n  const actionManager = useExcalidrawActionManager();\n  const appProps = useAppProps();\n\n  if (\n    appState.viewModeEnabled ||\n    !appProps.UIOptions.canvasActions.changeViewBackgroundColor\n  ) {\n    return null;\n  }\n  return (\n    <div style={{ marginTop: \"0.5rem\" }}>\n      <div\n        data-testid=\"canvas-background-label\"\n        style={{ fontSize: \".75rem\", marginBottom: \".5rem\" }}\n      >\n        {t(\"labels.canvasBackground\")}\n      </div>\n      <div style={{ padding: \"0 0.625rem\" }}>\n        {actionManager.renderAction(\"changeViewBackgroundColor\")}\n      </div>\n    </div>\n  );\n};\nChangeCanvasBackground.displayName = \"ChangeCanvasBackground\";\n\nexport const Export = () => {\n  const { t } = useI18n();\n  const setAppState = useExcalidrawSetAppState();\n  return (\n    <DropdownMenuItem\n      icon={ExportIcon}\n      onSelect={() => {\n        setAppState({ openDialog: { name: \"jsonExport\" } });\n      }}\n      data-testid=\"json-export-button\"\n      aria-label={t(\"buttons.export\")}\n    >\n      {t(\"buttons.export\")}\n    </DropdownMenuItem>\n  );\n};\nExport.displayName = \"Export\";\n\nexport const Socials = () => {\n  const { t } = useI18n();\n\n  return (\n    <>\n      <DropdownMenuItemLink\n        icon={GithubIcon}\n        href=\"https://github.com/excalidraw/excalidraw\"\n        aria-label=\"GitHub\"\n      >\n        GitHub\n      </DropdownMenuItemLink>\n      <DropdownMenuItemLink\n        icon={XBrandIcon}\n        href=\"https://x.com/excalidraw\"\n        aria-label=\"X\"\n      >\n        {t(\"labels.followUs\")}\n      </DropdownMenuItemLink>\n      <DropdownMenuItemLink\n        icon={DiscordIcon}\n        href=\"https://discord.gg/UexuTaE\"\n        aria-label=\"Discord\"\n      >\n        {t(\"labels.discordChat\")}\n      </DropdownMenuItemLink>\n    </>\n  );\n};\nSocials.displayName = \"Socials\";\n\nexport const LiveCollaborationTrigger = ({\n  onSelect,\n  isCollaborating,\n}: {\n  onSelect: () => void;\n  isCollaborating: boolean;\n}) => {\n  const { t } = useI18n();\n  return (\n    <DropdownMenuItem\n      data-testid=\"collab-button\"\n      icon={usersIcon}\n      className={clsx({\n        \"active-collab\": isCollaborating,\n      })}\n      onSelect={onSelect}\n    >\n      {t(\"labels.liveCollaboration\")}\n    </DropdownMenuItem>\n  );\n};\n\nLiveCollaborationTrigger.displayName = \"LiveCollaborationTrigger\";\n",
    "import { atom, editorJotaiStore } from \"../../editor-jotai\";\n\nimport type React from \"react\";\n\nexport type OverwriteConfirmState =\n  | {\n      active: true;\n      title: string;\n      description: React.ReactNode;\n      actionLabel: string;\n      color: \"danger\" | \"warning\";\n\n      onClose: () => void;\n      onConfirm: () => void;\n      onReject: () => void;\n    }\n  | { active: false };\n\nexport const overwriteConfirmStateAtom = atom<OverwriteConfirmState>({\n  active: false,\n});\n\nexport async function openConfirmModal({\n  title,\n  description,\n  actionLabel,\n  color,\n}: {\n  title: string;\n  description: React.ReactNode;\n  actionLabel: string;\n  color: \"danger\" | \"warning\";\n}) {\n  return new Promise<boolean>((resolve) => {\n    editorJotaiStore.set(overwriteConfirmStateAtom, {\n      active: true,\n      onConfirm: () => resolve(true),\n      onClose: () => resolve(false),\n      onReject: () => resolve(false),\n      title,\n      description,\n      actionLabel,\n      color,\n    });\n  });\n}\n",
    "import clsx from \"clsx\";\n\nimport \"./RadioGroup.scss\";\n\nexport type RadioGroupChoice<T> = {\n  value: T;\n  label: React.ReactNode;\n  ariaLabel?: string;\n};\n\nexport type RadioGroupProps<T> = {\n  choices: RadioGroupChoice<T>[];\n  value: T;\n  onChange: (value: T) => void;\n  name: string;\n};\n\nexport const RadioGroup = function <T>({\n  onChange,\n  value,\n  choices,\n  name,\n}: RadioGroupProps<T>) {\n  return (\n    <div className=\"RadioGroup\">\n      {choices.map((choice) => (\n        <div\n          className={clsx(\"RadioGroup__choice\", {\n            active: choice.value === value,\n          })}\n          key={String(choice.value)}\n          title={choice.ariaLabel}\n        >\n          <input\n            name={name}\n            type=\"radio\"\n            checked={choice.value === value}\n            onChange={() => onChange(choice.value)}\n            aria-label={choice.ariaLabel}\n          />\n          {choice.label}\n        </div>\n      ))}\n    </div>\n  );\n};\n",
    "import { useDevice } from \"../App\";\nimport { RadioGroup } from \"../RadioGroup\";\n\ntype Props<T> = {\n  value: T;\n  shortcut?: string;\n  choices: {\n    value: T;\n    label: React.ReactNode;\n    ariaLabel?: string;\n  }[];\n  onChange: (value: T) => void;\n  children: React.ReactNode;\n  name: string;\n};\n\nconst DropdownMenuItemContentRadio = <T,>({\n  value,\n  shortcut,\n  onChange,\n  choices,\n  children,\n  name,\n}: Props<T>) => {\n  const device = useDevice();\n\n  return (\n    <>\n      <div className=\"dropdown-menu-item-base dropdown-menu-item-bare\">\n        <label className=\"dropdown-menu-item__text\" htmlFor={name}>\n          {children}\n        </label>\n        <RadioGroup\n          name={name}\n          value={value}\n          onChange={onChange}\n          choices={choices}\n        />\n      </div>\n      {shortcut && !device.editor.isMobile && (\n        <div className=\"dropdown-menu-item__shortcut dropdown-menu-item__shortcut--orphaned\">\n          {shortcut}\n        </div>\n      )}\n    </>\n  );\n};\n\nDropdownMenuItemContentRadio.displayName = \"DropdownMenuItemContentRadio\";\n\nexport default DropdownMenuItemContentRadio;\n",
    "import clsx from \"clsx\";\nimport React, { forwardRef, useState } from \"react\";\n\nimport { isPromiseLike } from \"@excalidraw/common\";\n\nimport { AbortError } from \"../errors\";\n\nimport Spinner from \"./Spinner\";\nimport { tablerCheckIcon } from \"./icons\";\n\nimport \"./FilledButton.scss\";\n\nexport type ButtonVariant = \"filled\" | \"outlined\" | \"icon\";\nexport type ButtonColor =\n  | \"primary\"\n  | \"danger\"\n  | \"warning\"\n  | \"muted\"\n  | \"success\";\nexport type ButtonSize = \"medium\" | \"large\";\n\nexport type FilledButtonProps = {\n  label: string;\n\n  children?: React.ReactNode;\n  onClick?: (event: React.MouseEvent) => void;\n  status?: null | \"loading\" | \"success\";\n\n  variant?: ButtonVariant;\n  color?: ButtonColor;\n  size?: ButtonSize;\n  className?: string;\n  fullWidth?: boolean;\n\n  icon?: React.ReactNode;\n};\n\nexport const FilledButton = forwardRef<HTMLButtonElement, FilledButtonProps>(\n  (\n    {\n      children,\n      icon,\n      onClick,\n      label,\n      variant = \"filled\",\n      color = \"primary\",\n      size = \"medium\",\n      fullWidth,\n      className,\n      status,\n    },\n    ref,\n  ) => {\n    const [isLoading, setIsLoading] = useState(false);\n\n    const _onClick = async (event: React.MouseEvent) => {\n      const ret = onClick?.(event);\n\n      if (isPromiseLike(ret)) {\n        // delay loading state to prevent flicker in case of quick response\n        const timer = window.setTimeout(() => {\n          setIsLoading(true);\n        }, 50);\n        try {\n          await ret;\n        } catch (error: any) {\n          if (!(error instanceof AbortError)) {\n            throw error;\n          } else {\n            console.warn(error);\n          }\n        } finally {\n          clearTimeout(timer);\n          setIsLoading(false);\n        }\n      }\n    };\n\n    const _status = isLoading ? \"loading\" : status;\n    color = _status === \"success\" ? \"success\" : color;\n\n    return (\n      <button\n        className={clsx(\n          \"ExcButton\",\n          `ExcButton--color-${color}`,\n          `ExcButton--variant-${variant}`,\n          `ExcButton--size-${size}`,\n          `ExcButton--status-${_status}`,\n          { \"ExcButton--fullWidth\": fullWidth },\n          className,\n        )}\n        onClick={_onClick}\n        type=\"button\"\n        aria-label={label}\n        ref={ref}\n        disabled={_status === \"loading\" || _status === \"success\"}\n      >\n        <div className=\"ExcButton__contents\">\n          {_status === \"loading\" ? (\n            <Spinner className=\"ExcButton__statusIcon\" />\n          ) : (\n            _status === \"success\" && (\n              <div className=\"ExcButton__statusIcon\">{tablerCheckIcon}</div>\n            )\n          )}\n          {icon && (\n            <div className=\"ExcButton__icon\" aria-hidden>\n              {icon}\n            </div>\n          )}\n          {variant !== \"icon\" && (children ?? label)}\n        </div>\n      </button>\n    );\n  },\n);\n",
    "import React from \"react\";\n\nimport { actionSaveFileToDisk } from \"../../actions\";\nimport { actionChangeExportEmbedScene } from \"../../actions/actionExport\";\nimport { useI18n } from \"../../i18n\";\nimport { useExcalidrawActionManager, useExcalidrawSetAppState } from \"../App\";\nimport { FilledButton } from \"../FilledButton\";\n\nexport type ActionProps = {\n  title: string;\n  children: React.ReactNode;\n  actionLabel: string;\n  onClick: () => void;\n};\n\nexport const Action = ({\n  title,\n  children,\n  actionLabel,\n  onClick,\n}: ActionProps) => {\n  return (\n    <div className=\"OverwriteConfirm__Actions__Action\">\n      <h4>{title}</h4>\n      <div className=\"OverwriteConfirm__Actions__Action__content\">\n        {children}\n      </div>\n      <FilledButton\n        variant=\"outlined\"\n        color=\"muted\"\n        label={actionLabel}\n        size=\"large\"\n        fullWidth\n        onClick={onClick}\n      />\n    </div>\n  );\n};\n\nexport const ExportToImage = () => {\n  const { t } = useI18n();\n  const actionManager = useExcalidrawActionManager();\n  const setAppState = useExcalidrawSetAppState();\n\n  return (\n    <Action\n      title={t(\"overwriteConfirm.action.exportToImage.title\")}\n      actionLabel={t(\"overwriteConfirm.action.exportToImage.button\")}\n      onClick={() => {\n        actionManager.executeAction(actionChangeExportEmbedScene, \"ui\", true);\n        setAppState({ openDialog: { name: \"imageExport\" } });\n      }}\n    >\n      {t(\"overwriteConfirm.action.exportToImage.description\")}\n    </Action>\n  );\n};\n\nexport const SaveToDisk = () => {\n  const { t } = useI18n();\n  const actionManager = useExcalidrawActionManager();\n\n  return (\n    <Action\n      title={t(\"overwriteConfirm.action.saveToDisk.title\")}\n      actionLabel={t(\"overwriteConfirm.action.saveToDisk.button\")}\n      onClick={() => {\n        actionManager.executeAction(actionSaveFileToDisk, \"ui\");\n      }}\n    >\n      {t(\"overwriteConfirm.action.saveToDisk.description\")}\n    </Action>\n  );\n};\n\nconst Actions = Object.assign(\n  ({ children }: { children: React.ReactNode }) => {\n    return <div className=\"OverwriteConfirm__Actions\">{children}</div>;\n  },\n  {\n    ExportToImage,\n    SaveToDisk,\n  },\n);\n\nexport { Actions };\n",
    "import React from \"react\";\n\nimport { useTunnels } from \"../../context/tunnels\";\nimport { useAtom } from \"../../editor-jotai\";\nimport { Dialog } from \"../Dialog\";\nimport { FilledButton } from \"../FilledButton\";\nimport { withInternalFallback } from \"../hoc/withInternalFallback\";\nimport { alertTriangleIcon } from \"../icons\";\n\nimport { Actions, Action } from \"./OverwriteConfirmActions\";\nimport { overwriteConfirmStateAtom } from \"./OverwriteConfirmState\";\n\nimport \"./OverwriteConfirm.scss\";\n\nexport type OverwriteConfirmDialogProps = {\n  children: React.ReactNode;\n};\n\nconst OverwriteConfirmDialog = Object.assign(\n  withInternalFallback(\n    \"OverwriteConfirmDialog\",\n    ({ children }: OverwriteConfirmDialogProps) => {\n      const { OverwriteConfirmDialogTunnel } = useTunnels();\n      const [overwriteConfirmState, setState] = useAtom(\n        overwriteConfirmStateAtom,\n      );\n\n      if (!overwriteConfirmState.active) {\n        return null;\n      }\n\n      const handleClose = () => {\n        overwriteConfirmState.onClose();\n        setState((state) => ({ ...state, active: false }));\n      };\n\n      const handleConfirm = () => {\n        overwriteConfirmState.onConfirm();\n        setState((state) => ({ ...state, active: false }));\n      };\n\n      return (\n        <OverwriteConfirmDialogTunnel.In>\n          <Dialog onCloseRequest={handleClose} title={false} size={916}>\n            <div className=\"OverwriteConfirm\">\n              <h3>{overwriteConfirmState.title}</h3>\n              <div\n                className={`OverwriteConfirm__Description OverwriteConfirm__Description--color-${overwriteConfirmState.color}`}\n              >\n                <div className=\"OverwriteConfirm__Description__icon\">\n                  {alertTriangleIcon}\n                </div>\n                <div>{overwriteConfirmState.description}</div>\n                <div className=\"OverwriteConfirm__Description__spacer\"></div>\n                <FilledButton\n                  color={overwriteConfirmState.color}\n                  size=\"large\"\n                  label={overwriteConfirmState.actionLabel}\n                  onClick={handleConfirm}\n                />\n              </div>\n              <Actions>{children}</Actions>\n            </div>\n          </Dialog>\n        </OverwriteConfirmDialogTunnel.In>\n      );\n    },\n  ),\n  {\n    Actions,\n    Action,\n  },\n);\n\nexport { OverwriteConfirmDialog };\n",
    "import clsx from \"clsx\";\n\nimport {\n  CANVAS_SEARCH_TAB,\n  DEFAULT_SIDEBAR,\n  LIBRARY_SIDEBAR_TAB,\n  composeEventHandlers,\n} from \"@excalidraw/common\";\n\nimport type { MarkOptional, Merge } from \"@excalidraw/common/utility-types\";\n\nimport { useTunnels } from \"../context/tunnels\";\nimport { useUIAppState } from \"../context/ui-appState\";\n\nimport \"../components/dropdownMenu/DropdownMenu.scss\";\n\nimport { useExcalidrawSetAppState } from \"./App\";\nimport { LibraryMenu } from \"./LibraryMenu\";\nimport { SearchMenu } from \"./SearchMenu\";\nimport { Sidebar } from \"./Sidebar/Sidebar\";\nimport { withInternalFallback } from \"./hoc/withInternalFallback\";\nimport { LibraryIcon, searchIcon } from \"./icons\";\n\nimport type { SidebarProps, SidebarTriggerProps } from \"./Sidebar/common\";\n\nconst DefaultSidebarTrigger = withInternalFallback(\n  \"DefaultSidebarTrigger\",\n  (\n    props: Omit<SidebarTriggerProps, \"name\"> &\n      React.HTMLAttributes<HTMLDivElement>,\n  ) => {\n    const { DefaultSidebarTriggerTunnel } = useTunnels();\n    return (\n      <DefaultSidebarTriggerTunnel.In>\n        <Sidebar.Trigger\n          {...props}\n          className=\"default-sidebar-trigger\"\n          name={DEFAULT_SIDEBAR.name}\n        />\n      </DefaultSidebarTriggerTunnel.In>\n    );\n  },\n);\nDefaultSidebarTrigger.displayName = \"DefaultSidebarTrigger\";\n\nconst DefaultTabTriggers = ({ children }: { children: React.ReactNode }) => {\n  const { DefaultSidebarTabTriggersTunnel } = useTunnels();\n  return (\n    <DefaultSidebarTabTriggersTunnel.In>\n      {children}\n    </DefaultSidebarTabTriggersTunnel.In>\n  );\n};\nDefaultTabTriggers.displayName = \"DefaultTabTriggers\";\n\nexport const DefaultSidebar = Object.assign(\n  withInternalFallback(\n    \"DefaultSidebar\",\n    ({\n      children,\n      className,\n      onDock,\n      docked,\n      ...rest\n    }: Merge<\n      MarkOptional<Omit<SidebarProps, \"name\">, \"children\">,\n      {\n        /** pass `false` to disable docking */\n        onDock?: SidebarProps[\"onDock\"] | false;\n      }\n    >) => {\n      const appState = useUIAppState();\n      const setAppState = useExcalidrawSetAppState();\n\n      const { DefaultSidebarTabTriggersTunnel } = useTunnels();\n\n      const isForceDocked = appState.openSidebar?.tab === CANVAS_SEARCH_TAB;\n\n      return (\n        <Sidebar\n          {...rest}\n          name=\"default\"\n          key=\"default\"\n          className={clsx(\"default-sidebar\", className)}\n          docked={\n            isForceDocked || (docked ?? appState.defaultSidebarDockedPreference)\n          }\n          onDock={\n            // `onDock=false` disables docking.\n            // if `docked` passed, but no onDock passed, disable manual docking.\n            isForceDocked || onDock === false || (!onDock && docked != null)\n              ? undefined\n              : // compose to allow the host app to listen on default behavior\n                composeEventHandlers(onDock, (docked) => {\n                  setAppState({ defaultSidebarDockedPreference: docked });\n                })\n          }\n        >\n          <Sidebar.Tabs>\n            <Sidebar.Header>\n              <Sidebar.TabTriggers>\n                <Sidebar.TabTrigger tab={CANVAS_SEARCH_TAB}>\n                  {searchIcon}\n                </Sidebar.TabTrigger>\n                <Sidebar.TabTrigger tab={LIBRARY_SIDEBAR_TAB}>\n                  {LibraryIcon}\n                </Sidebar.TabTrigger>\n                <DefaultSidebarTabTriggersTunnel.Out />\n              </Sidebar.TabTriggers>\n            </Sidebar.Header>\n            <Sidebar.Tab tab={LIBRARY_SIDEBAR_TAB}>\n              <LibraryMenu />\n            </Sidebar.Tab>\n            <Sidebar.Tab tab={CANVAS_SEARCH_TAB}>\n              <SearchMenu />\n            </Sidebar.Tab>\n            {children}\n          </Sidebar.Tabs>\n        </Sidebar>\n      );\n    },\n  ),\n  {\n    Trigger: DefaultSidebarTrigger,\n    TabTriggers: DefaultTabTriggers,\n  },\n);\n",
    "import { round } from \"@excalidraw/math\";\nimport clsx from \"clsx\";\nimport debounce from \"lodash.debounce\";\nimport { Fragment, memo, useEffect, useMemo, useRef, useState } from \"react\";\n\nimport {\n  CLASSES,\n  EVENT,\n  FONT_FAMILY,\n  FRAME_STYLE,\n  getLineHeight,\n} from \"@excalidraw/common\";\n\nimport { isElementCompletelyInViewport } from \"@excalidraw/element\";\n\nimport { measureText } from \"@excalidraw/element\";\n\nimport {\n  KEYS,\n  randomInteger,\n  addEventListener,\n  getFontString,\n} from \"@excalidraw/common\";\n\nimport { newTextElement } from \"@excalidraw/element\";\nimport { isTextElement, isFrameLikeElement } from \"@excalidraw/element\";\n\nimport { getDefaultFrameName } from \"@excalidraw/element/frame\";\n\nimport type {\n  ExcalidrawFrameLikeElement,\n  ExcalidrawTextElement,\n} from \"@excalidraw/element/types\";\n\nimport { atom, useAtom } from \"../editor-jotai\";\n\nimport { useStable } from \"../hooks/useStable\";\nimport { t } from \"../i18n\";\n\nimport { useApp, useExcalidrawSetAppState } from \"./App\";\nimport { Button } from \"./Button\";\nimport { TextField } from \"./TextField\";\nimport {\n  collapseDownIcon,\n  upIcon,\n  searchIcon,\n  frameToolIcon,\n  TextIcon,\n} from \"./icons\";\n\nimport \"./SearchMenu.scss\";\n\nimport type { AppClassProperties, SearchMatch } from \"../types\";\n\nconst searchQueryAtom = atom<string>(\"\");\nexport const searchItemInFocusAtom = atom<number | null>(null);\n\nconst SEARCH_DEBOUNCE = 350;\n\ntype SearchMatchItem = {\n  element: ExcalidrawTextElement | ExcalidrawFrameLikeElement;\n  searchQuery: SearchQuery;\n  index: number;\n  preview: {\n    indexInSearchQuery: number;\n    previewText: string;\n    moreBefore: boolean;\n    moreAfter: boolean;\n  };\n  matchedLines: SearchMatch[\"matchedLines\"];\n};\n\ntype SearchMatches = {\n  nonce: number | null;\n  items: SearchMatchItem[];\n};\n\ntype SearchQuery = string & { _brand: \"SearchQuery\" };\n\nexport const SearchMenu = () => {\n  const app = useApp();\n  const setAppState = useExcalidrawSetAppState();\n\n  const searchInputRef = useRef<HTMLInputElement>(null);\n\n  const [inputValue, setInputValue] = useAtom(searchQueryAtom);\n  const searchQuery = inputValue.trim() as SearchQuery;\n\n  const [isSearching, setIsSearching] = useState(false);\n\n  const [searchMatches, setSearchMatches] = useState<SearchMatches>({\n    nonce: null,\n    items: [],\n  });\n  const searchedQueryRef = useRef<SearchQuery | null>(null);\n  const lastSceneNonceRef = useRef<number | undefined>(undefined);\n\n  const [focusIndex, setFocusIndex] = useAtom(searchItemInFocusAtom);\n  const elementsMap = app.scene.getNonDeletedElementsMap();\n\n  useEffect(() => {\n    if (isSearching) {\n      return;\n    }\n    if (\n      searchQuery !== searchedQueryRef.current ||\n      app.scene.getSceneNonce() !== lastSceneNonceRef.current\n    ) {\n      searchedQueryRef.current = null;\n      handleSearch(searchQuery, app, (matchItems, index) => {\n        setSearchMatches({\n          nonce: randomInteger(),\n          items: matchItems,\n        });\n        searchedQueryRef.current = searchQuery;\n        lastSceneNonceRef.current = app.scene.getSceneNonce();\n        setAppState({\n          searchMatches: matchItems.length\n            ? {\n                focusedId: null,\n                matches: matchItems.map((searchMatch) => ({\n                  id: searchMatch.element.id,\n                  focus: false,\n                  matchedLines: searchMatch.matchedLines,\n                })),\n              }\n            : null,\n        });\n      });\n    }\n  }, [\n    isSearching,\n    searchQuery,\n    elementsMap,\n    app,\n    setAppState,\n    setFocusIndex,\n    lastSceneNonceRef,\n  ]);\n\n  const goToNextItem = () => {\n    if (searchMatches.items.length > 0) {\n      setFocusIndex((focusIndex) => {\n        if (focusIndex === null) {\n          return 0;\n        }\n\n        return (focusIndex + 1) % searchMatches.items.length;\n      });\n    }\n  };\n\n  const goToPreviousItem = () => {\n    if (searchMatches.items.length > 0) {\n      setFocusIndex((focusIndex) => {\n        if (focusIndex === null) {\n          return 0;\n        }\n\n        return focusIndex - 1 < 0\n          ? searchMatches.items.length - 1\n          : focusIndex - 1;\n      });\n    }\n  };\n\n  useEffect(() => {\n    setAppState((state) => {\n      if (!state.searchMatches) {\n        return null;\n      }\n\n      const focusedId =\n        focusIndex !== null\n          ? state.searchMatches?.matches[focusIndex]?.id || null\n          : null;\n\n      return {\n        searchMatches: {\n          focusedId,\n          matches: state.searchMatches.matches.map((match, index) => {\n            if (index === focusIndex) {\n              return { ...match, focus: true };\n            }\n            return { ...match, focus: false };\n          }),\n        },\n      };\n    });\n  }, [focusIndex, setAppState]);\n\n  useEffect(() => {\n    if (searchMatches.items.length > 0 && focusIndex !== null) {\n      const match = searchMatches.items[focusIndex];\n\n      if (match) {\n        const zoomValue = app.state.zoom.value;\n\n        const matchAsElement = newTextElement({\n          text: match.searchQuery,\n          x: match.element.x + (match.matchedLines[0]?.offsetX ?? 0),\n          y: match.element.y + (match.matchedLines[0]?.offsetY ?? 0),\n          width: match.matchedLines[0]?.width,\n          height: match.matchedLines[0]?.height,\n          fontSize: isFrameLikeElement(match.element)\n            ? FRAME_STYLE.nameFontSize\n            : match.element.fontSize,\n          fontFamily: isFrameLikeElement(match.element)\n            ? FONT_FAMILY.Assistant\n            : match.element.fontFamily,\n        });\n\n        const FONT_SIZE_LEGIBILITY_THRESHOLD = 14;\n\n        const fontSize = matchAsElement.fontSize;\n        const isTextTiny =\n          fontSize * zoomValue < FONT_SIZE_LEGIBILITY_THRESHOLD;\n\n        if (\n          !isElementCompletelyInViewport(\n            [matchAsElement],\n            app.canvas.width / window.devicePixelRatio,\n            app.canvas.height / window.devicePixelRatio,\n            {\n              offsetLeft: app.state.offsetLeft,\n              offsetTop: app.state.offsetTop,\n              scrollX: app.state.scrollX,\n              scrollY: app.state.scrollY,\n              zoom: app.state.zoom,\n            },\n            app.scene.getNonDeletedElementsMap(),\n            app.getEditorUIOffsets(),\n          ) ||\n          isTextTiny\n        ) {\n          let zoomOptions: Parameters<AppClassProperties[\"scrollToContent\"]>[1];\n\n          if (isTextTiny) {\n            if (fontSize >= FONT_SIZE_LEGIBILITY_THRESHOLD) {\n              zoomOptions = { fitToContent: true };\n            } else {\n              zoomOptions = {\n                fitToViewport: true,\n                // calculate zoom level to make the fontSize ~equal to FONT_SIZE_THRESHOLD, rounded to nearest 10%\n                maxZoom: round(FONT_SIZE_LEGIBILITY_THRESHOLD / fontSize, 1),\n              };\n            }\n          } else {\n            zoomOptions = { fitToContent: true };\n          }\n\n          app.scrollToContent(matchAsElement, {\n            animate: true,\n            duration: 300,\n            ...zoomOptions,\n            canvasOffsets: app.getEditorUIOffsets(),\n          });\n        }\n      }\n    }\n  }, [focusIndex, searchMatches, app]);\n\n  useEffect(() => {\n    return () => {\n      setFocusIndex(null);\n      searchedQueryRef.current = null;\n      lastSceneNonceRef.current = undefined;\n      setAppState({\n        searchMatches: null,\n      });\n      setIsSearching(false);\n    };\n  }, [setAppState, setFocusIndex]);\n\n  const stableState = useStable({\n    goToNextItem,\n    goToPreviousItem,\n    searchMatches,\n  });\n\n  useEffect(() => {\n    const eventHandler = (event: KeyboardEvent) => {\n      if (\n        event.key === KEYS.ESCAPE &&\n        !app.state.openDialog &&\n        !app.state.openPopup\n      ) {\n        event.preventDefault();\n        event.stopPropagation();\n        setAppState({\n          openSidebar: null,\n        });\n        return;\n      }\n\n      if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.F) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        if (app.state.openDialog) {\n          return;\n        }\n\n        if (!searchInputRef.current?.matches(\":focus\")) {\n          if (app.state.openDialog) {\n            setAppState({\n              openDialog: null,\n            });\n          }\n          searchInputRef.current?.focus();\n          searchInputRef.current?.select();\n        }\n      }\n\n      if (\n        event.target instanceof HTMLElement &&\n        event.target.closest(\".layer-ui__search\")\n      ) {\n        if (stableState.searchMatches.items.length) {\n          if (event.key === KEYS.ENTER) {\n            event.stopPropagation();\n            stableState.goToNextItem();\n          }\n\n          if (event.key === KEYS.ARROW_UP) {\n            event.stopPropagation();\n            stableState.goToPreviousItem();\n          } else if (event.key === KEYS.ARROW_DOWN) {\n            event.stopPropagation();\n            stableState.goToNextItem();\n          }\n        }\n      }\n    };\n\n    // `capture` needed to prevent firing on initial open from App.tsx,\n    // as well as to handle events before App ones\n    return addEventListener(window, EVENT.KEYDOWN, eventHandler, {\n      capture: true,\n      passive: false,\n    });\n  }, [setAppState, stableState, app]);\n\n  const matchCount = `${searchMatches.items.length} ${\n    searchMatches.items.length === 1\n      ? t(\"search.singleResult\")\n      : t(\"search.multipleResults\")\n  }`;\n\n  return (\n    <div className=\"layer-ui__search\">\n      <div className=\"layer-ui__search-header\">\n        <TextField\n          className={CLASSES.SEARCH_MENU_INPUT_WRAPPER}\n          value={inputValue}\n          ref={searchInputRef}\n          placeholder={t(\"search.placeholder\")}\n          icon={searchIcon}\n          onChange={(value) => {\n            setInputValue(value);\n            setIsSearching(true);\n            const searchQuery = value.trim() as SearchQuery;\n            handleSearch(searchQuery, app, (matchItems, index) => {\n              setSearchMatches({\n                nonce: randomInteger(),\n                items: matchItems,\n              });\n              setFocusIndex(index);\n              searchedQueryRef.current = searchQuery;\n              lastSceneNonceRef.current = app.scene.getSceneNonce();\n              setAppState({\n                searchMatches: matchItems.length\n                  ? {\n                      focusedId: null,\n                      matches: matchItems.map((searchMatch) => ({\n                        id: searchMatch.element.id,\n                        focus: false,\n                        matchedLines: searchMatch.matchedLines,\n                      })),\n                    }\n                  : null,\n              });\n\n              setIsSearching(false);\n            });\n          }}\n          selectOnRender\n        />\n      </div>\n\n      <div className=\"layer-ui__search-count\">\n        {searchMatches.items.length > 0 && (\n          <>\n            {focusIndex !== null && focusIndex > -1 ? (\n              <div>\n                {focusIndex + 1} / {matchCount}\n              </div>\n            ) : (\n              <div>{matchCount}</div>\n            )}\n            <div className=\"result-nav\">\n              <Button\n                onSelect={() => {\n                  goToNextItem();\n                }}\n                className=\"result-nav-btn\"\n              >\n                {collapseDownIcon}\n              </Button>\n              <Button\n                onSelect={() => {\n                  goToPreviousItem();\n                }}\n                className=\"result-nav-btn\"\n              >\n                {upIcon}\n              </Button>\n            </div>\n          </>\n        )}\n\n        {searchMatches.items.length === 0 &&\n          searchQuery &&\n          searchedQueryRef.current && (\n            <div style={{ margin: \"1rem auto\" }}>{t(\"search.noMatch\")}</div>\n          )}\n      </div>\n\n      <MatchList\n        matches={searchMatches}\n        onItemClick={setFocusIndex}\n        focusIndex={focusIndex}\n        searchQuery={searchQuery}\n      />\n    </div>\n  );\n};\n\nconst ListItem = (props: {\n  preview: SearchMatchItem[\"preview\"];\n  searchQuery: SearchQuery;\n  highlighted: boolean;\n  onClick?: () => void;\n}) => {\n  const preview = [\n    props.preview.moreBefore ? \"...\" : \"\",\n    props.preview.previewText.slice(0, props.preview.indexInSearchQuery),\n    props.preview.previewText.slice(\n      props.preview.indexInSearchQuery,\n      props.preview.indexInSearchQuery + props.searchQuery.length,\n    ),\n    props.preview.previewText.slice(\n      props.preview.indexInSearchQuery + props.searchQuery.length,\n    ),\n    props.preview.moreAfter ? \"...\" : \"\",\n  ];\n\n  return (\n    <div\n      tabIndex={-1}\n      className={clsx(\"layer-ui__result-item\", {\n        active: props.highlighted,\n      })}\n      onClick={props.onClick}\n      ref={(ref) => {\n        if (props.highlighted) {\n          ref?.scrollIntoView({ behavior: \"auto\", block: \"nearest\" });\n        }\n      }}\n    >\n      <div className=\"preview-text\">\n        {preview.flatMap((text, idx) => (\n          <Fragment key={idx}>{idx === 2 ? <b>{text}</b> : text}</Fragment>\n        ))}\n      </div>\n    </div>\n  );\n};\n\ninterface MatchListProps {\n  matches: SearchMatches;\n  onItemClick: (index: number) => void;\n  focusIndex: number | null;\n  searchQuery: SearchQuery;\n}\n\nconst MatchListBase = (props: MatchListProps) => {\n  const frameNameMatches = useMemo(\n    () =>\n      props.matches.items.filter((match) => isFrameLikeElement(match.element)),\n    [props.matches],\n  );\n\n  const textMatches = useMemo(\n    () => props.matches.items.filter((match) => isTextElement(match.element)),\n    [props.matches],\n  );\n\n  return (\n    <div>\n      {frameNameMatches.length > 0 && (\n        <div className=\"layer-ui__search-result-container\">\n          <div className=\"layer-ui__search-result-title\">\n            <div className=\"title-icon\">{frameToolIcon}</div>\n            <div>{t(\"search.frames\")}</div>\n          </div>\n          {frameNameMatches.map((searchMatch, index) => (\n            <ListItem\n              key={searchMatch.element.id + searchMatch.index}\n              searchQuery={props.searchQuery}\n              preview={searchMatch.preview}\n              highlighted={index === props.focusIndex}\n              onClick={() => props.onItemClick(index)}\n            />\n          ))}\n\n          {textMatches.length > 0 && <div className=\"layer-ui__divider\" />}\n        </div>\n      )}\n\n      {textMatches.length > 0 && (\n        <div className=\"layer-ui__search-result-container\">\n          <div className=\"layer-ui__search-result-title\">\n            <div className=\"title-icon\">{TextIcon}</div>\n            <div>{t(\"search.texts\")}</div>\n          </div>\n          {textMatches.map((searchMatch, index) => (\n            <ListItem\n              key={searchMatch.element.id + searchMatch.index}\n              searchQuery={props.searchQuery}\n              preview={searchMatch.preview}\n              highlighted={index + frameNameMatches.length === props.focusIndex}\n              onClick={() => props.onItemClick(index + frameNameMatches.length)}\n            />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n\nconst areEqual = (prevProps: MatchListProps, nextProps: MatchListProps) => {\n  return (\n    prevProps.matches.nonce === nextProps.matches.nonce &&\n    prevProps.focusIndex === nextProps.focusIndex\n  );\n};\n\nconst MatchList = memo(MatchListBase, areEqual);\n\nconst getMatchPreview = (\n  text: string,\n  index: number,\n  searchQuery: SearchQuery,\n) => {\n  const WORDS_BEFORE = 2;\n  const WORDS_AFTER = 5;\n\n  const substrBeforeQuery = text.slice(0, index);\n  const wordsBeforeQuery = substrBeforeQuery.split(/\\s+/);\n  // text = \"small\", query = \"mall\", not complete before\n  // text = \"small\", query = \"smal\", complete before\n  const isQueryCompleteBefore = substrBeforeQuery.endsWith(\" \");\n  const startWordIndex =\n    wordsBeforeQuery.length -\n    WORDS_BEFORE -\n    1 -\n    (isQueryCompleteBefore ? 0 : 1);\n  let wordsBeforeAsString =\n    wordsBeforeQuery.slice(startWordIndex <= 0 ? 0 : startWordIndex).join(\" \") +\n    (isQueryCompleteBefore ? \" \" : \"\");\n\n  const MAX_ALLOWED_CHARS = 20;\n\n  wordsBeforeAsString =\n    wordsBeforeAsString.length > MAX_ALLOWED_CHARS\n      ? wordsBeforeAsString.slice(-MAX_ALLOWED_CHARS)\n      : wordsBeforeAsString;\n\n  const substrAfterQuery = text.slice(index + searchQuery.length);\n  const wordsAfter = substrAfterQuery.split(/\\s+/);\n  // text = \"small\", query = \"mall\", complete after\n  // text = \"small\", query = \"smal\", not complete after\n  const isQueryCompleteAfter = !substrAfterQuery.startsWith(\" \");\n  const numberOfWordsToTake = isQueryCompleteAfter\n    ? WORDS_AFTER + 1\n    : WORDS_AFTER;\n  const wordsAfterAsString =\n    (isQueryCompleteAfter ? \"\" : \" \") +\n    wordsAfter.slice(0, numberOfWordsToTake).join(\" \");\n\n  return {\n    indexInSearchQuery: wordsBeforeAsString.length,\n    previewText: wordsBeforeAsString + searchQuery + wordsAfterAsString,\n    moreBefore: startWordIndex > 0,\n    moreAfter: wordsAfter.length > numberOfWordsToTake,\n  };\n};\n\nconst normalizeWrappedText = (\n  wrappedText: string,\n  originalText: string,\n): string => {\n  const wrappedLines = wrappedText.split(\"\\n\");\n  const normalizedLines: string[] = [];\n  let originalIndex = 0;\n\n  for (let i = 0; i < wrappedLines.length; i++) {\n    let currentLine = wrappedLines[i];\n    const nextLine = wrappedLines[i + 1];\n\n    if (nextLine) {\n      const nextLineIndexInOriginal = originalText.indexOf(\n        nextLine,\n        originalIndex,\n      );\n\n      if (nextLineIndexInOriginal > currentLine.length + originalIndex) {\n        let j = nextLineIndexInOriginal - (currentLine.length + originalIndex);\n\n        while (j > 0) {\n          currentLine += \" \";\n          j--;\n        }\n      }\n    }\n\n    normalizedLines.push(currentLine);\n    originalIndex = originalIndex + currentLine.length;\n  }\n\n  return normalizedLines.join(\"\\n\");\n};\n\nconst getMatchedLines = (\n  textElement: ExcalidrawTextElement,\n  searchQuery: SearchQuery,\n  index: number,\n) => {\n  const normalizedText = normalizeWrappedText(\n    textElement.text,\n    textElement.originalText,\n  );\n\n  const lines = normalizedText.split(\"\\n\");\n\n  const lineIndexRanges = [];\n  let currentIndex = 0;\n  let lineNumber = 0;\n\n  for (const line of lines) {\n    const startIndex = currentIndex;\n    const endIndex = startIndex + line.length - 1;\n\n    lineIndexRanges.push({\n      line,\n      startIndex,\n      endIndex,\n      lineNumber,\n    });\n\n    // Move to the next line's start index\n    currentIndex = endIndex + 1;\n    lineNumber++;\n  }\n\n  let startIndex = index;\n  let remainingQuery = textElement.originalText.slice(\n    index,\n    index + searchQuery.length,\n  );\n  const matchedLines: SearchMatch[\"matchedLines\"] = [];\n\n  for (const lineIndexRange of lineIndexRanges) {\n    if (remainingQuery === \"\") {\n      break;\n    }\n\n    if (\n      startIndex >= lineIndexRange.startIndex &&\n      startIndex <= lineIndexRange.endIndex\n    ) {\n      const matchCapacity = lineIndexRange.endIndex + 1 - startIndex;\n      const textToStart = lineIndexRange.line.slice(\n        0,\n        startIndex - lineIndexRange.startIndex,\n      );\n\n      const matchedWord = remainingQuery.slice(0, matchCapacity);\n      remainingQuery = remainingQuery.slice(matchCapacity);\n\n      const offset = measureText(\n        textToStart,\n        getFontString(textElement),\n        textElement.lineHeight,\n      );\n\n      // measureText returns a non-zero width for the empty string\n      // which is not what we're after here, hence the check and the correction\n      if (textToStart === \"\") {\n        offset.width = 0;\n      }\n\n      if (textElement.textAlign !== \"left\" && lineIndexRange.line.length > 0) {\n        const lineLength = measureText(\n          lineIndexRange.line,\n          getFontString(textElement),\n          textElement.lineHeight,\n        );\n\n        const spaceToStart =\n          textElement.textAlign === \"center\"\n            ? (textElement.width - lineLength.width) / 2\n            : textElement.width - lineLength.width;\n        offset.width += spaceToStart;\n      }\n\n      const { width, height } = measureText(\n        matchedWord,\n        getFontString(textElement),\n        textElement.lineHeight,\n      );\n\n      const offsetX = offset.width;\n      const offsetY = lineIndexRange.lineNumber * offset.height;\n\n      matchedLines.push({\n        offsetX,\n        offsetY,\n        width,\n        height,\n        showOnCanvas: true,\n      });\n\n      startIndex += matchCapacity;\n    }\n  }\n\n  return matchedLines;\n};\n\nconst getMatchInFrame = (\n  frame: ExcalidrawFrameLikeElement,\n  searchQuery: SearchQuery,\n  index: number,\n  zoomValue: number,\n): SearchMatch[\"matchedLines\"] => {\n  const text = frame.name ?? getDefaultFrameName(frame);\n  const matchedText = text.slice(index, index + searchQuery.length);\n\n  const prefixText = text.slice(0, index);\n  const font = getFontString({\n    fontSize: FRAME_STYLE.nameFontSize,\n    fontFamily: FONT_FAMILY.Assistant,\n  });\n\n  const lineHeight = getLineHeight(FONT_FAMILY.Assistant);\n\n  const offset = measureText(prefixText, font, lineHeight);\n\n  // Correct non-zero width for empty string\n  if (prefixText === \"\") {\n    offset.width = 0;\n  }\n\n  const matchedMetrics = measureText(matchedText, font, lineHeight);\n\n  const offsetX = offset.width;\n  const offsetY = -offset.height - FRAME_STYLE.strokeWidth;\n  const width = matchedMetrics.width;\n\n  return [\n    {\n      offsetX,\n      offsetY,\n      width,\n      height: matchedMetrics.height,\n      showOnCanvas: offsetX + width <= frame.width * zoomValue,\n    },\n  ];\n};\n\nconst escapeSpecialCharacters = (string: string) => {\n  return string.replace(/[.*+?^${}()|[\\]\\\\-]/g, \"\\\\$&\");\n};\n\nconst handleSearch = debounce(\n  (\n    searchQuery: SearchQuery,\n    app: AppClassProperties,\n    cb: (matchItems: SearchMatchItem[], focusIndex: number | null) => void,\n  ) => {\n    if (!searchQuery || searchQuery === \"\") {\n      cb([], null);\n      return;\n    }\n\n    const elements = app.scene.getNonDeletedElements();\n    const texts = elements.filter((el) =>\n      isTextElement(el),\n    ) as ExcalidrawTextElement[];\n\n    const frames = elements.filter((el) =>\n      isFrameLikeElement(el),\n    ) as ExcalidrawFrameLikeElement[];\n\n    texts.sort((a, b) => a.y - b.y);\n    frames.sort((a, b) => a.y - b.y);\n\n    const textMatches: SearchMatchItem[] = [];\n\n    const regex = new RegExp(escapeSpecialCharacters(searchQuery), \"gi\");\n\n    for (const textEl of texts) {\n      let match = null;\n      const text = textEl.originalText;\n\n      while ((match = regex.exec(text)) !== null) {\n        const preview = getMatchPreview(text, match.index, searchQuery);\n        const matchedLines = getMatchedLines(textEl, searchQuery, match.index);\n\n        if (matchedLines.length > 0) {\n          textMatches.push({\n            element: textEl,\n            searchQuery,\n            preview,\n            index: match.index,\n            matchedLines,\n          });\n        }\n      }\n    }\n\n    const frameMatches: SearchMatchItem[] = [];\n\n    for (const frame of frames) {\n      let match = null;\n      const name = frame.name ?? getDefaultFrameName(frame);\n\n      while ((match = regex.exec(name)) !== null) {\n        const preview = getMatchPreview(name, match.index, searchQuery);\n        const matchedLines = getMatchInFrame(\n          frame,\n          searchQuery,\n          match.index,\n          app.state.zoom.value,\n        );\n\n        if (matchedLines.length > 0) {\n          frameMatches.push({\n            element: frame,\n            searchQuery,\n            preview,\n            index: match.index,\n            matchedLines,\n          });\n        }\n      }\n    }\n\n    const visibleIds = new Set(\n      app.visibleElements.map((visibleElement) => visibleElement.id),\n    );\n\n    // putting frame matches first\n    const matchItems: SearchMatchItem[] = [...frameMatches, ...textMatches];\n\n    const focusIndex =\n      matchItems.findIndex((matchItem) =>\n        visibleIds.has(matchItem.element.id),\n      ) ?? null;\n\n    cb(matchItems, focusIndex);\n  },\n  SEARCH_DEBOUNCE,\n);\n",
    "import { useEffect, useRef, useState } from \"react\";\n\nimport { isFiniteNumber } from \"@excalidraw/math\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { trackEvent } from \"../../analytics\";\nimport { useUIAppState } from \"../../context/ui-appState\";\nimport { atom, useAtom } from \"../../editor-jotai\";\nimport { t } from \"../../i18n\";\nimport { useApp, useExcalidrawSetAppState } from \"../App\";\nimport { Dialog } from \"../Dialog\";\nimport { InlineIcon } from \"../InlineIcon\";\nimport { withInternalFallback } from \"../hoc/withInternalFallback\";\nimport { ArrowRightIcon } from \"../icons\";\n\nimport MermaidToExcalidraw from \"./MermaidToExcalidraw\";\nimport TTDDialogTabs from \"./TTDDialogTabs\";\nimport { TTDDialogTabTriggers } from \"./TTDDialogTabTriggers\";\nimport { TTDDialogTabTrigger } from \"./TTDDialogTabTrigger\";\nimport { TTDDialogTab } from \"./TTDDialogTab\";\nimport { TTDDialogInput } from \"./TTDDialogInput\";\nimport { TTDDialogOutput } from \"./TTDDialogOutput\";\nimport { TTDDialogPanel } from \"./TTDDialogPanel\";\nimport { TTDDialogPanels } from \"./TTDDialogPanels\";\n\nimport {\n  convertMermaidToExcalidraw,\n  insertToEditor,\n  saveMermaidDataToStorage,\n} from \"./common\";\nimport { TTDDialogSubmitShortcut } from \"./TTDDialogSubmitShortcut\";\n\nimport \"./TTDDialog.scss\";\n\nimport type { ChangeEventHandler } from \"react\";\nimport type { MermaidToExcalidrawLibProps } from \"./common\";\n\nimport type { BinaryFiles } from \"../../types\";\n\nconst MIN_PROMPT_LENGTH = 3;\nconst MAX_PROMPT_LENGTH = 1000;\n\nconst rateLimitsAtom = atom<{\n  rateLimit: number;\n  rateLimitRemaining: number;\n} | null>(null);\n\nconst ttdGenerationAtom = atom<{\n  generatedResponse: string | null;\n  prompt: string | null;\n} | null>(null);\n\ntype OnTestSubmitRetValue = {\n  rateLimit?: number | null;\n  rateLimitRemaining?: number | null;\n} & (\n  | { generatedResponse: string | undefined; error?: null | undefined }\n  | {\n      error: Error;\n      generatedResponse?: null | undefined;\n    }\n);\n\nexport const TTDDialog = (\n  props:\n    | {\n        onTextSubmit(value: string): Promise<OnTestSubmitRetValue>;\n      }\n    | { __fallback: true },\n) => {\n  const appState = useUIAppState();\n\n  if (appState.openDialog?.name !== \"ttd\") {\n    return null;\n  }\n\n  return <TTDDialogBase {...props} tab={appState.openDialog.tab} />;\n};\n\n/**\n * Text to diagram (TTD) dialog\n */\nexport const TTDDialogBase = withInternalFallback(\n  \"TTDDialogBase\",\n  ({\n    tab,\n    ...rest\n  }: {\n    tab: \"text-to-diagram\" | \"mermaid\";\n  } & (\n    | {\n        onTextSubmit(value: string): Promise<OnTestSubmitRetValue>;\n      }\n    | { __fallback: true }\n  )) => {\n    const app = useApp();\n    const setAppState = useExcalidrawSetAppState();\n\n    const someRandomDivRef = useRef<HTMLDivElement>(null);\n\n    const [ttdGeneration, setTtdGeneration] = useAtom(ttdGenerationAtom);\n\n    const [text, setText] = useState(ttdGeneration?.prompt ?? \"\");\n\n    const prompt = text.trim();\n\n    const handleTextChange: ChangeEventHandler<HTMLTextAreaElement> = (\n      event,\n    ) => {\n      setText(event.target.value);\n      setTtdGeneration((s) => ({\n        generatedResponse: s?.generatedResponse ?? null,\n        prompt: event.target.value,\n      }));\n    };\n\n    const [onTextSubmitInProgess, setOnTextSubmitInProgess] = useState(false);\n    const [rateLimits, setRateLimits] = useAtom(rateLimitsAtom);\n\n    const onGenerate = async () => {\n      if (\n        prompt.length > MAX_PROMPT_LENGTH ||\n        prompt.length < MIN_PROMPT_LENGTH ||\n        onTextSubmitInProgess ||\n        rateLimits?.rateLimitRemaining === 0 ||\n        // means this is not a text-to-diagram dialog (needed for TS only)\n        \"__fallback\" in rest\n      ) {\n        if (prompt.length < MIN_PROMPT_LENGTH) {\n          setError(\n            new Error(\n              `Prompt is too short (min ${MIN_PROMPT_LENGTH} characters)`,\n            ),\n          );\n        }\n        if (prompt.length > MAX_PROMPT_LENGTH) {\n          setError(\n            new Error(\n              `Prompt is too long (max ${MAX_PROMPT_LENGTH} characters)`,\n            ),\n          );\n        }\n\n        return;\n      }\n\n      try {\n        setOnTextSubmitInProgess(true);\n\n        trackEvent(\"ai\", \"generate\", \"ttd\");\n\n        const { generatedResponse, error, rateLimit, rateLimitRemaining } =\n          await rest.onTextSubmit(prompt);\n\n        if (typeof generatedResponse === \"string\") {\n          setTtdGeneration((s) => ({\n            generatedResponse,\n            prompt: s?.prompt ?? null,\n          }));\n        }\n\n        if (isFiniteNumber(rateLimit) && isFiniteNumber(rateLimitRemaining)) {\n          setRateLimits({ rateLimit, rateLimitRemaining });\n        }\n\n        if (error) {\n          setError(error);\n          return;\n        }\n        if (!generatedResponse) {\n          setError(new Error(\"Generation failed\"));\n          return;\n        }\n\n        try {\n          await convertMermaidToExcalidraw({\n            canvasRef: someRandomDivRef,\n            data,\n            mermaidToExcalidrawLib,\n            setError,\n            mermaidDefinition: generatedResponse,\n          });\n          trackEvent(\"ai\", \"mermaid parse success\", \"ttd\");\n        } catch (error: any) {\n          console.info(\n            `%cTTD mermaid render errror: ${error.message}`,\n            \"color: red\",\n          );\n          console.info(\n            `>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\nTTD mermaid definition render errror: ${error.message}`,\n            \"color: yellow\",\n          );\n          trackEvent(\"ai\", \"mermaid parse failed\", \"ttd\");\n          setError(\n            new Error(\n              \"Generated an invalid diagram :(. You may also try a different prompt.\",\n            ),\n          );\n        }\n      } catch (error: any) {\n        let message: string | undefined = error.message;\n        if (!message || message === \"Failed to fetch\") {\n          message = \"Request failed\";\n        }\n        setError(new Error(message));\n      } finally {\n        setOnTextSubmitInProgess(false);\n      }\n    };\n\n    const refOnGenerate = useRef(onGenerate);\n    refOnGenerate.current = onGenerate;\n\n    const [mermaidToExcalidrawLib, setMermaidToExcalidrawLib] =\n      useState<MermaidToExcalidrawLibProps>({\n        loaded: false,\n        api: import(\"@excalidraw/mermaid-to-excalidraw\"),\n      });\n\n    useEffect(() => {\n      const fn = async () => {\n        await mermaidToExcalidrawLib.api;\n        setMermaidToExcalidrawLib((prev) => ({ ...prev, loaded: true }));\n      };\n      fn();\n    }, [mermaidToExcalidrawLib.api]);\n\n    const data = useRef<{\n      elements: readonly NonDeletedExcalidrawElement[];\n      files: BinaryFiles | null;\n    }>({ elements: [], files: null });\n\n    const [error, setError] = useState<Error | null>(null);\n\n    return (\n      <Dialog\n        className=\"ttd-dialog\"\n        onCloseRequest={() => {\n          app.setOpenDialog(null);\n        }}\n        size={1200}\n        title={false}\n        {...rest}\n        autofocus={false}\n      >\n        <TTDDialogTabs dialog=\"ttd\" tab={tab}>\n          {\"__fallback\" in rest && rest.__fallback ? (\n            <p className=\"dialog-mermaid-title\">{t(\"mermaid.title\")}</p>\n          ) : (\n            <TTDDialogTabTriggers>\n              <TTDDialogTabTrigger tab=\"text-to-diagram\">\n                <div style={{ display: \"flex\", alignItems: \"center\" }}>\n                  {t(\"labels.textToDiagram\")}\n                  <div\n                    style={{\n                      display: \"flex\",\n                      alignItems: \"center\",\n                      justifyContent: \"center\",\n                      padding: \"1px 6px\",\n                      marginLeft: \"10px\",\n                      fontSize: 10,\n                      borderRadius: \"12px\",\n                      background: \"var(--color-promo)\",\n                      color: \"var(--color-surface-lowest)\",\n                    }}\n                  >\n                    AI Beta\n                  </div>\n                </div>\n              </TTDDialogTabTrigger>\n              <TTDDialogTabTrigger tab=\"mermaid\">Mermaid</TTDDialogTabTrigger>\n            </TTDDialogTabTriggers>\n          )}\n\n          <TTDDialogTab className=\"ttd-dialog-content\" tab=\"mermaid\">\n            <MermaidToExcalidraw\n              mermaidToExcalidrawLib={mermaidToExcalidrawLib}\n            />\n          </TTDDialogTab>\n          {!(\"__fallback\" in rest) && (\n            <TTDDialogTab className=\"ttd-dialog-content\" tab=\"text-to-diagram\">\n              <div className=\"ttd-dialog-desc\">\n                Currently we use Mermaid as a middle step, so you'll get best\n                results if you describe a diagram, workflow, flow chart, and\n                similar.\n              </div>\n              <TTDDialogPanels>\n                <TTDDialogPanel\n                  label={t(\"labels.prompt\")}\n                  panelAction={{\n                    action: onGenerate,\n                    label: \"Generate\",\n                    icon: ArrowRightIcon,\n                  }}\n                  onTextSubmitInProgess={onTextSubmitInProgess}\n                  panelActionDisabled={\n                    prompt.length > MAX_PROMPT_LENGTH ||\n                    rateLimits?.rateLimitRemaining === 0\n                  }\n                  renderTopRight={() => {\n                    if (!rateLimits) {\n                      return null;\n                    }\n\n                    return (\n                      <div\n                        className=\"ttd-dialog-rate-limit\"\n                        style={{\n                          fontSize: 12,\n                          marginLeft: \"auto\",\n                          color:\n                            rateLimits.rateLimitRemaining === 0\n                              ? \"var(--color-danger)\"\n                              : undefined,\n                        }}\n                      >\n                        {rateLimits.rateLimitRemaining} requests left today\n                      </div>\n                    );\n                  }}\n                  renderSubmitShortcut={() => <TTDDialogSubmitShortcut />}\n                  renderBottomRight={() => {\n                    if (typeof ttdGeneration?.generatedResponse === \"string\") {\n                      return (\n                        <div\n                          className=\"excalidraw-link\"\n                          style={{ marginLeft: \"auto\", fontSize: 14 }}\n                          onClick={() => {\n                            if (\n                              typeof ttdGeneration?.generatedResponse ===\n                              \"string\"\n                            ) {\n                              saveMermaidDataToStorage(\n                                ttdGeneration.generatedResponse,\n                              );\n                              setAppState({\n                                openDialog: { name: \"ttd\", tab: \"mermaid\" },\n                              });\n                            }\n                          }}\n                        >\n                          View as Mermaid\n                          <InlineIcon icon={ArrowRightIcon} />\n                        </div>\n                      );\n                    }\n                    const ratio = prompt.length / MAX_PROMPT_LENGTH;\n                    if (ratio > 0.8) {\n                      return (\n                        <div\n                          style={{\n                            marginLeft: \"auto\",\n                            fontSize: 12,\n                            fontFamily: \"monospace\",\n                            color:\n                              ratio > 1 ? \"var(--color-danger)\" : undefined,\n                          }}\n                        >\n                          Length: {prompt.length}/{MAX_PROMPT_LENGTH}\n                        </div>\n                      );\n                    }\n\n                    return null;\n                  }}\n                >\n                  <TTDDialogInput\n                    onChange={handleTextChange}\n                    input={text}\n                    placeholder={\"Describe what you want to see...\"}\n                    onKeyboardSubmit={() => {\n                      refOnGenerate.current();\n                    }}\n                  />\n                </TTDDialogPanel>\n                <TTDDialogPanel\n                  label=\"Preview\"\n                  panelAction={{\n                    action: () => {\n                      console.info(\"Panel action clicked\");\n                      insertToEditor({ app, data });\n                    },\n                    label: \"Insert\",\n                    icon: ArrowRightIcon,\n                  }}\n                >\n                  <TTDDialogOutput\n                    canvasRef={someRandomDivRef}\n                    error={error}\n                    loaded={mermaidToExcalidrawLib.loaded}\n                  />\n                </TTDDialogPanel>\n              </TTDDialogPanels>\n            </TTDDialogTab>\n          )}\n        </TTDDialogTabs>\n      </Dialog>\n    );\n  },\n);\n",
    "import { useState, useRef, useEffect, useDeferredValue } from \"react\";\n\nimport { EDITOR_LS_KEYS, debounce, isDevEnv } from \"@excalidraw/common\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { useApp } from \"../App\";\nimport { ArrowRightIcon } from \"../icons\";\nimport { EditorLocalStorage } from \"../../data/EditorLocalStorage\";\nimport { t } from \"../../i18n\";\nimport Trans from \"../Trans\";\n\nimport { TTDDialogInput } from \"./TTDDialogInput\";\nimport { TTDDialogOutput } from \"./TTDDialogOutput\";\nimport { TTDDialogPanel } from \"./TTDDialogPanel\";\nimport { TTDDialogPanels } from \"./TTDDialogPanels\";\nimport { TTDDialogSubmitShortcut } from \"./TTDDialogSubmitShortcut\";\nimport {\n  convertMermaidToExcalidraw,\n  insertToEditor,\n  saveMermaidDataToStorage,\n} from \"./common\";\n\nimport \"./MermaidToExcalidraw.scss\";\n\nimport type { BinaryFiles } from \"../../types\";\nimport type { MermaidToExcalidrawLibProps } from \"./common\";\n\nconst MERMAID_EXAMPLE =\n  \"flowchart TD\\n A[Christmas] -->|Get money| B(Go shopping)\\n B --> C{Let me think}\\n C -->|One| D[Laptop]\\n C -->|Two| E[iPhone]\\n C -->|Three| F[Car]\";\n\nconst debouncedSaveMermaidDefinition = debounce(saveMermaidDataToStorage, 300);\n\nconst MermaidToExcalidraw = ({\n  mermaidToExcalidrawLib,\n}: {\n  mermaidToExcalidrawLib: MermaidToExcalidrawLibProps;\n}) => {\n  const [text, setText] = useState(\n    () =>\n      EditorLocalStorage.get<string>(EDITOR_LS_KEYS.MERMAID_TO_EXCALIDRAW) ||\n      MERMAID_EXAMPLE,\n  );\n  const deferredText = useDeferredValue(text.trim());\n  const [error, setError] = useState<Error | null>(null);\n\n  const canvasRef = useRef<HTMLDivElement>(null);\n  const data = useRef<{\n    elements: readonly NonDeletedExcalidrawElement[];\n    files: BinaryFiles | null;\n  }>({ elements: [], files: null });\n\n  const app = useApp();\n\n  useEffect(() => {\n    convertMermaidToExcalidraw({\n      canvasRef,\n      data,\n      mermaidToExcalidrawLib,\n      setError,\n      mermaidDefinition: deferredText,\n    }).catch((err) => {\n      if (isDevEnv()) {\n        console.error(\"Failed to parse mermaid definition\", err);\n      }\n    });\n\n    debouncedSaveMermaidDefinition(deferredText);\n  }, [deferredText, mermaidToExcalidrawLib]);\n\n  useEffect(\n    () => () => {\n      debouncedSaveMermaidDefinition.flush();\n    },\n    [],\n  );\n\n  const onInsertToEditor = () => {\n    insertToEditor({\n      app,\n      data,\n      text,\n      shouldSaveMermaidDataToStorage: true,\n    });\n  };\n\n  return (\n    <>\n      <div className=\"ttd-dialog-desc\">\n        <Trans\n          i18nKey=\"mermaid.description\"\n          flowchartLink={(el) => (\n            <a href=\"https://mermaid.js.org/syntax/flowchart.html\">{el}</a>\n          )}\n          sequenceLink={(el) => (\n            <a href=\"https://mermaid.js.org/syntax/sequenceDiagram.html\">\n              {el}\n            </a>\n          )}\n          classLink={(el) => (\n            <a href=\"https://mermaid.js.org/syntax/classDiagram.html\">{el}</a>\n          )}\n        />\n      </div>\n      <TTDDialogPanels>\n        <TTDDialogPanel label={t(\"mermaid.syntax\")}>\n          <TTDDialogInput\n            input={text}\n            placeholder={\"Write Mermaid diagram defintion here...\"}\n            onChange={(event) => setText(event.target.value)}\n            onKeyboardSubmit={() => {\n              onInsertToEditor();\n            }}\n          />\n        </TTDDialogPanel>\n        <TTDDialogPanel\n          label={t(\"mermaid.preview\")}\n          panelAction={{\n            action: () => {\n              onInsertToEditor();\n            },\n            label: t(\"mermaid.button\"),\n            icon: ArrowRightIcon,\n          }}\n          renderSubmitShortcut={() => <TTDDialogSubmitShortcut />}\n        >\n          <TTDDialogOutput\n            canvasRef={canvasRef}\n            loaded={mermaidToExcalidrawLib.loaded}\n            error={error}\n          />\n        </TTDDialogPanel>\n      </TTDDialogPanels>\n    </>\n  );\n};\nexport default MermaidToExcalidraw;\n",
    "import { useEffect, useRef } from \"react\";\n\nimport { EVENT, KEYS } from \"@excalidraw/common\";\n\nimport type { ChangeEventHandler } from \"react\";\n\ninterface TTDDialogInputProps {\n  input: string;\n  placeholder: string;\n  onChange: ChangeEventHandler<HTMLTextAreaElement>;\n  onKeyboardSubmit?: () => void;\n}\n\nexport const TTDDialogInput = ({\n  input,\n  placeholder,\n  onChange,\n  onKeyboardSubmit,\n}: TTDDialogInputProps) => {\n  const ref = useRef<HTMLTextAreaElement>(null);\n\n  const callbackRef = useRef(onKeyboardSubmit);\n  callbackRef.current = onKeyboardSubmit;\n\n  useEffect(() => {\n    if (!callbackRef.current) {\n      return;\n    }\n    const textarea = ref.current;\n    if (textarea) {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.ENTER) {\n          event.preventDefault();\n          callbackRef.current?.();\n        }\n      };\n      textarea.focus();\n      textarea.addEventListener(EVENT.KEYDOWN, handleKeyDown);\n      return () => {\n        textarea.removeEventListener(EVENT.KEYDOWN, handleKeyDown);\n      };\n    }\n  }, []);\n\n  return (\n    <textarea\n      className=\"ttd-dialog-input\"\n      onChange={onChange}\n      value={input}\n      placeholder={placeholder}\n      ref={ref}\n    />\n  );\n};\n",
    "import Spinner from \"../Spinner\";\n\nconst ErrorComp = ({ error }: { error: string }) => {\n  return (\n    <div\n      data-testid=\"ttd-dialog-output-error\"\n      className=\"ttd-dialog-output-error\"\n    >\n      Error! <p>{error}</p>\n    </div>\n  );\n};\n\ninterface TTDDialogOutputProps {\n  error: Error | null;\n  canvasRef: React.RefObject<HTMLDivElement | null>;\n  loaded: boolean;\n}\n\nexport const TTDDialogOutput = ({\n  error,\n  canvasRef,\n  loaded,\n}: TTDDialogOutputProps) => {\n  return (\n    <div className=\"ttd-dialog-output-wrapper\">\n      {error && <ErrorComp error={error.message} />}\n      {loaded ? (\n        <div\n          ref={canvasRef}\n          style={{ opacity: error ? \"0.15\" : 1 }}\n          className=\"ttd-dialog-output-canvas-container\"\n        />\n      ) : (\n        <Spinner size=\"2rem\" />\n      )}\n    </div>\n  );\n};\n",
    "import clsx from \"clsx\";\n\nimport { Button } from \"../Button\";\nimport Spinner from \"../Spinner\";\n\nimport type { ReactNode } from \"react\";\n\ninterface TTDDialogPanelProps {\n  label: string;\n  children: ReactNode;\n  panelAction?: {\n    label: string;\n    action: () => void;\n    icon?: ReactNode;\n  };\n  panelActionDisabled?: boolean;\n  onTextSubmitInProgess?: boolean;\n  renderTopRight?: () => ReactNode;\n  renderSubmitShortcut?: () => ReactNode;\n  renderBottomRight?: () => ReactNode;\n}\n\nexport const TTDDialogPanel = ({\n  label,\n  children,\n  panelAction,\n  panelActionDisabled = false,\n  onTextSubmitInProgess,\n  renderTopRight,\n  renderSubmitShortcut,\n  renderBottomRight,\n}: TTDDialogPanelProps) => {\n  return (\n    <div className=\"ttd-dialog-panel\">\n      <div className=\"ttd-dialog-panel__header\">\n        <label>{label}</label>\n        {renderTopRight?.()}\n      </div>\n\n      {children}\n      <div\n        className={clsx(\"ttd-dialog-panel-button-container\", {\n          invisible: !panelAction,\n        })}\n        style={{ display: \"flex\", alignItems: \"center\" }}\n      >\n        <Button\n          className=\"ttd-dialog-panel-button\"\n          onSelect={panelAction ? panelAction.action : () => {}}\n          disabled={panelActionDisabled || onTextSubmitInProgess}\n        >\n          <div className={clsx({ invisible: onTextSubmitInProgess })}>\n            {panelAction?.label}\n            {panelAction?.icon && <span>{panelAction.icon}</span>}\n          </div>\n          {onTextSubmitInProgess && <Spinner />}\n        </Button>\n        {!panelActionDisabled &&\n          !onTextSubmitInProgess &&\n          renderSubmitShortcut?.()}\n        {renderBottomRight?.()}\n      </div>\n    </div>\n  );\n};\n",
    "import type { ReactNode } from \"react\";\n\nexport const TTDDialogPanels = ({ children }: { children: ReactNode }) => {\n  return <div className=\"ttd-dialog-panels\">{children}</div>;\n};\n",
    "import { getShortcutKey } from \"@excalidraw/common\";\n\nexport const TTDDialogSubmitShortcut = () => {\n  return (\n    <div className=\"ttd-dialog-submit-shortcut\">\n      <div className=\"ttd-dialog-submit-shortcut__key\">\n        {getShortcutKey(\"CtrlOrCmd\")}\n      </div>\n      <div className=\"ttd-dialog-submit-shortcut__key\">\n        {getShortcutKey(\"Enter\")}\n      </div>\n    </div>\n  );\n};\n",
    "import { DEFAULT_EXPORT_PADDING, EDITOR_LS_KEYS } from \"@excalidraw/common\";\n\nimport type { MermaidConfig } from \"@excalidraw/mermaid-to-excalidraw\";\nimport type { MermaidToExcalidrawResult } from \"@excalidraw/mermaid-to-excalidraw/dist/interfaces\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { EditorLocalStorage } from \"../../data/EditorLocalStorage\";\nimport { canvasToBlob } from \"../../data/blob\";\nimport { t } from \"../../i18n\";\nimport { convertToExcalidrawElements, exportToCanvas } from \"../../index\";\n\nimport type { AppClassProperties, BinaryFiles } from \"../../types\";\n\nconst resetPreview = ({\n  canvasRef,\n  setError,\n}: {\n  canvasRef: React.RefObject<HTMLDivElement | null>;\n  setError: (error: Error | null) => void;\n}) => {\n  const canvasNode = canvasRef.current;\n\n  if (!canvasNode) {\n    return;\n  }\n  const parent = canvasNode.parentElement;\n  if (!parent) {\n    return;\n  }\n  parent.style.background = \"\";\n  setError(null);\n  canvasNode.replaceChildren();\n};\n\nexport interface MermaidToExcalidrawLibProps {\n  loaded: boolean;\n  api: Promise<{\n    parseMermaidToExcalidraw: (\n      definition: string,\n      config?: MermaidConfig,\n    ) => Promise<MermaidToExcalidrawResult>;\n  }>;\n}\n\ninterface ConvertMermaidToExcalidrawFormatProps {\n  canvasRef: React.RefObject<HTMLDivElement | null>;\n  mermaidToExcalidrawLib: MermaidToExcalidrawLibProps;\n  mermaidDefinition: string;\n  setError: (error: Error | null) => void;\n  data: React.MutableRefObject<{\n    elements: readonly NonDeletedExcalidrawElement[];\n    files: BinaryFiles | null;\n  }>;\n}\n\nexport const convertMermaidToExcalidraw = async ({\n  canvasRef,\n  mermaidToExcalidrawLib,\n  mermaidDefinition,\n  setError,\n  data,\n}: ConvertMermaidToExcalidrawFormatProps) => {\n  const canvasNode = canvasRef.current;\n  const parent = canvasNode?.parentElement;\n\n  if (!canvasNode || !parent) {\n    return;\n  }\n\n  if (!mermaidDefinition) {\n    resetPreview({ canvasRef, setError });\n    return;\n  }\n\n  try {\n    const api = await mermaidToExcalidrawLib.api;\n\n    let ret;\n    try {\n      ret = await api.parseMermaidToExcalidraw(mermaidDefinition);\n    } catch (err: any) {\n      ret = await api.parseMermaidToExcalidraw(\n        mermaidDefinition.replace(/\"/g, \"'\"),\n      );\n    }\n    const { elements, files } = ret;\n    setError(null);\n\n    data.current = {\n      elements: convertToExcalidrawElements(elements, {\n        regenerateIds: true,\n      }),\n      files,\n    };\n\n    const canvas = await exportToCanvas({\n      elements: data.current.elements,\n      files: data.current.files,\n      exportPadding: DEFAULT_EXPORT_PADDING,\n      maxWidthOrHeight:\n        Math.max(parent.offsetWidth, parent.offsetHeight) *\n        window.devicePixelRatio,\n    });\n    // if converting to blob fails, there's some problem that will\n    // likely prevent preview and export (e.g. canvas too big)\n    try {\n      await canvasToBlob(canvas);\n    } catch (e: any) {\n      if (e.name === \"CANVAS_POSSIBLY_TOO_BIG\") {\n        throw new Error(t(\"canvasError.canvasTooBig\"));\n      }\n      throw e;\n    }\n    parent.style.background = \"var(--default-bg-color)\";\n    canvasNode.replaceChildren(canvas);\n  } catch (err: any) {\n    parent.style.background = \"var(--default-bg-color)\";\n    if (mermaidDefinition) {\n      setError(err);\n    }\n\n    throw err;\n  }\n};\n\nexport const saveMermaidDataToStorage = (mermaidDefinition: string) => {\n  EditorLocalStorage.set(\n    EDITOR_LS_KEYS.MERMAID_TO_EXCALIDRAW,\n    mermaidDefinition,\n  );\n};\n\nexport const insertToEditor = ({\n  app,\n  data,\n  text,\n  shouldSaveMermaidDataToStorage,\n}: {\n  app: AppClassProperties;\n  data: React.MutableRefObject<{\n    elements: readonly NonDeletedExcalidrawElement[];\n    files: BinaryFiles | null;\n  }>;\n  text?: string;\n  shouldSaveMermaidDataToStorage?: boolean;\n}) => {\n  const { elements: newElements, files } = data.current;\n\n  if (!newElements.length) {\n    return;\n  }\n\n  app.addElementsFromPasteOrLibrary({\n    elements: newElements,\n    files,\n    position: \"center\",\n    fitToContent: true,\n  });\n  app.setOpenDialog(null);\n\n  if (shouldSaveMermaidDataToStorage && text) {\n    saveMermaidDataToStorage(text);\n  }\n};\n",
    "import * as RadixTabs from \"@radix-ui/react-tabs\";\nimport { useRef } from \"react\";\n\nimport { isMemberOf } from \"@excalidraw/common\";\n\nimport { useExcalidrawSetAppState } from \"../App\";\n\nimport type { ReactNode } from \"react\";\n\nconst TTDDialogTabs = (\n  props: {\n    children: ReactNode;\n  } & { dialog: \"ttd\"; tab: \"text-to-diagram\" | \"mermaid\" },\n) => {\n  const setAppState = useExcalidrawSetAppState();\n\n  const rootRef = useRef<HTMLDivElement>(null);\n  const minHeightRef = useRef<number>(0);\n\n  return (\n    <RadixTabs.Root\n      ref={rootRef}\n      className=\"ttd-dialog-tabs-root\"\n      value={props.tab}\n      onValueChange={(\n        // at least in test enviros, `tab` can be `undefined`\n        tab: string | undefined,\n      ) => {\n        if (!tab) {\n          return;\n        }\n        const modalContentNode =\n          rootRef.current?.closest<HTMLElement>(\".Modal__content\");\n        if (modalContentNode) {\n          const currHeight = modalContentNode.offsetHeight || 0;\n          if (currHeight > minHeightRef.current) {\n            minHeightRef.current = currHeight;\n            modalContentNode.style.minHeight = `min(${minHeightRef.current}px, 100%)`;\n          }\n        }\n        if (\n          props.dialog === \"ttd\" &&\n          isMemberOf([\"text-to-diagram\", \"mermaid\"], tab)\n        ) {\n          setAppState({\n            openDialog: { name: props.dialog, tab },\n          });\n        }\n      }}\n    >\n      {props.children}\n    </RadixTabs.Root>\n  );\n};\n\nTTDDialogTabs.displayName = \"TTDDialogTabs\";\n\nexport default TTDDialogTabs;\n",
    "import * as RadixTabs from \"@radix-ui/react-tabs\";\n\nexport const TTDDialogTabTriggers = ({\n  children,\n  ...rest\n}: { children: React.ReactNode } & React.HTMLAttributes<HTMLDivElement>) => {\n  return (\n    <RadixTabs.List className=\"ttd-dialog-triggers\" {...rest}>\n      {children}\n    </RadixTabs.List>\n  );\n};\nTTDDialogTabTriggers.displayName = \"TTDDialogTabTriggers\";\n",
    "import * as RadixTabs from \"@radix-ui/react-tabs\";\n\nexport const TTDDialogTabTrigger = ({\n  children,\n  tab,\n  onSelect,\n  ...rest\n}: {\n  children: React.ReactNode;\n  tab: string;\n  onSelect?: React.ReactEventHandler<HTMLButtonElement> | undefined;\n} & Omit<React.HTMLAttributes<HTMLButtonElement>, \"onSelect\">) => {\n  return (\n    <RadixTabs.Trigger value={tab} asChild onSelect={onSelect}>\n      <button type=\"button\" className=\"ttd-dialog-tab-trigger\" {...rest}>\n        {children}\n      </button>\n    </RadixTabs.Trigger>\n  );\n};\nTTDDialogTabTrigger.displayName = \"TTDDialogTabTrigger\";\n",
    "import * as RadixTabs from \"@radix-ui/react-tabs\";\n\nexport const TTDDialogTab = ({\n  tab,\n  children,\n  ...rest\n}: {\n  tab: string;\n  children: React.ReactNode;\n} & React.HTMLAttributes<HTMLDivElement>) => {\n  return (\n    <RadixTabs.Content {...rest} value={tab}>\n      {children}\n    </RadixTabs.Content>\n  );\n};\nTTDDialogTab.displayName = \"TTDDialogTab\";\n",
    "import { round } from \"@excalidraw/math\";\nimport clsx from \"clsx\";\nimport throttle from \"lodash.throttle\";\nimport { useEffect, useMemo, useState, memo } from \"react\";\n\nimport { STATS_PANELS } from \"@excalidraw/common\";\nimport { getCommonBounds } from \"@excalidraw/element\";\nimport { getUncroppedWidthAndHeight } from \"@excalidraw/element\";\nimport { isElbowArrow, isImageElement } from \"@excalidraw/element\";\n\nimport { frameAndChildrenSelectedTogether } from \"@excalidraw/element\";\n\nimport { elementsAreInSameGroup } from \"@excalidraw/element\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { t } from \"../../i18n\";\nimport { isGridModeEnabled } from \"../../snapping\";\nimport { useExcalidrawAppState, useExcalidrawSetAppState } from \"../App\";\nimport { Island } from \"../Island\";\nimport { CloseIcon } from \"../icons\";\n\nimport Angle from \"./Angle\";\nimport CanvasGrid from \"./CanvasGrid\";\nimport Collapsible from \"./Collapsible\";\nimport Dimension from \"./Dimension\";\nimport FontSize from \"./FontSize\";\nimport MultiAngle from \"./MultiAngle\";\nimport MultiDimension from \"./MultiDimension\";\nimport MultiFontSize from \"./MultiFontSize\";\nimport MultiPosition from \"./MultiPosition\";\nimport Position from \"./Position\";\nimport { getAtomicUnits } from \"./utils\";\n\nimport \"./Stats.scss\";\n\nimport type {\n  AppClassProperties,\n  AppState,\n  ExcalidrawProps,\n} from \"../../types\";\n\ninterface StatsProps {\n  app: AppClassProperties;\n  onClose: () => void;\n  renderCustomStats: ExcalidrawProps[\"renderCustomStats\"];\n}\n\nconst STATS_TIMEOUT = 50;\n\nexport const Stats = (props: StatsProps) => {\n  const appState = useExcalidrawAppState();\n  const sceneNonce = props.app.scene.getSceneNonce() || 1;\n  const selectedElements = props.app.scene.getSelectedElements({\n    selectedElementIds: appState.selectedElementIds,\n    includeBoundTextElement: false,\n  });\n  const gridModeEnabled = isGridModeEnabled(props.app);\n\n  return (\n    <StatsInner\n      {...props}\n      appState={appState}\n      sceneNonce={sceneNonce}\n      selectedElements={selectedElements}\n      gridModeEnabled={gridModeEnabled}\n    />\n  );\n};\n\nconst StatsRow = ({\n  children,\n  columns = 1,\n  heading,\n  style,\n  ...rest\n}: {\n  children: React.ReactNode;\n  columns?: number;\n  heading?: boolean;\n  style?: React.CSSProperties;\n} & React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={clsx(\"exc-stats__row\", { \"exc-stats__row--heading\": heading })}\n    style={{\n      gridTemplateColumns: `repeat(${columns}, 1fr)`,\n      ...style,\n    }}\n    {...rest}\n  >\n    {children}\n  </div>\n);\nStatsRow.displayName = \"StatsRow\";\n\nconst StatsRows = ({\n  children,\n  order,\n  style,\n  ...rest\n}: {\n  children: React.ReactNode;\n  order?: number;\n  style?: React.CSSProperties;\n} & React.HTMLAttributes<HTMLDivElement>) => (\n  <div className=\"exc-stats__rows\" style={{ order, ...style }} {...rest}>\n    {children}\n  </div>\n);\nStatsRows.displayName = \"StatsRows\";\n\nStats.StatsRow = StatsRow;\nStats.StatsRows = StatsRows;\n\nexport const StatsInner = memo(\n  ({\n    app,\n    onClose,\n    renderCustomStats,\n    selectedElements,\n    appState,\n    sceneNonce,\n    gridModeEnabled,\n  }: StatsProps & {\n    sceneNonce: number;\n    selectedElements: readonly NonDeletedExcalidrawElement[];\n    appState: AppState;\n    gridModeEnabled: boolean;\n  }) => {\n    const scene = app.scene;\n    const elements = scene.getNonDeletedElements();\n    const elementsMap = scene.getNonDeletedElementsMap();\n    const setAppState = useExcalidrawSetAppState();\n\n    const singleElement =\n      selectedElements.length === 1 ? selectedElements[0] : null;\n\n    const multipleElements =\n      selectedElements.length > 1 ? selectedElements : null;\n\n    const cropMode =\n      appState.croppingElementId && isImageElement(singleElement);\n\n    const unCroppedDimension = cropMode\n      ? getUncroppedWidthAndHeight(singleElement)\n      : null;\n\n    const [sceneDimension, setSceneDimension] = useState<{\n      width: number;\n      height: number;\n    }>({\n      width: 0,\n      height: 0,\n    });\n\n    const throttledSetSceneDimension = useMemo(\n      () =>\n        throttle((elements: readonly NonDeletedExcalidrawElement[]) => {\n          const boundingBox = getCommonBounds(elements);\n          setSceneDimension({\n            width: Math.round(boundingBox[2]) - Math.round(boundingBox[0]),\n            height: Math.round(boundingBox[3]) - Math.round(boundingBox[1]),\n          });\n        }, STATS_TIMEOUT),\n      [],\n    );\n\n    useEffect(() => {\n      throttledSetSceneDimension(elements);\n    }, [sceneNonce, elements, throttledSetSceneDimension]);\n\n    useEffect(\n      () => () => throttledSetSceneDimension.cancel(),\n      [throttledSetSceneDimension],\n    );\n\n    const atomicUnits = useMemo(() => {\n      return getAtomicUnits(selectedElements, appState);\n    }, [selectedElements, appState]);\n\n    const _frameAndChildrenSelectedTogether = useMemo(() => {\n      return frameAndChildrenSelectedTogether(selectedElements);\n    }, [selectedElements]);\n\n    return (\n      <div className=\"exc-stats\">\n        <Island padding={3}>\n          <div className=\"title\">\n            <h2>{t(\"stats.title\")}</h2>\n            <div className=\"close\" onClick={onClose}>\n              {CloseIcon}\n            </div>\n          </div>\n\n          <Collapsible\n            label={<h3>{t(\"stats.generalStats\")}</h3>}\n            open={!!(appState.stats.panels & STATS_PANELS.generalStats)}\n            openTrigger={() =>\n              setAppState((state) => {\n                return {\n                  stats: {\n                    open: true,\n                    panels: state.stats.panels ^ STATS_PANELS.generalStats,\n                  },\n                };\n              })\n            }\n          >\n            <StatsRows>\n              <StatsRow heading>{t(\"stats.scene\")}</StatsRow>\n              <StatsRow columns={2}>\n                <div>{t(\"stats.shapes\")}</div>\n                <div>{elements.length}</div>\n              </StatsRow>\n              <StatsRow columns={2}>\n                <div>{t(\"stats.width\")}</div>\n                <div>{sceneDimension.width}</div>\n              </StatsRow>\n              <StatsRow columns={2}>\n                <div>{t(\"stats.height\")}</div>\n                <div>{sceneDimension.height}</div>\n              </StatsRow>\n              {gridModeEnabled && (\n                <>\n                  <StatsRow heading>Canvas</StatsRow>\n                  <StatsRow>\n                    <CanvasGrid\n                      property=\"gridStep\"\n                      scene={scene}\n                      appState={appState}\n                      setAppState={setAppState}\n                    />\n                  </StatsRow>\n                </>\n              )}\n            </StatsRows>\n\n            {renderCustomStats?.(elements, appState)}\n          </Collapsible>\n\n          {!_frameAndChildrenSelectedTogether && selectedElements.length > 0 && (\n            <div\n              id=\"elementStats\"\n              style={{\n                marginTop: 12,\n              }}\n            >\n              <Collapsible\n                label={<h3>{t(\"stats.elementProperties\")}</h3>}\n                open={\n                  !!(appState.stats.panels & STATS_PANELS.elementProperties)\n                }\n                openTrigger={() =>\n                  setAppState((state) => {\n                    return {\n                      stats: {\n                        open: true,\n                        panels:\n                          state.stats.panels ^ STATS_PANELS.elementProperties,\n                      },\n                    };\n                  })\n                }\n              >\n                <StatsRows>\n                  {singleElement && (\n                    <>\n                      {cropMode && (\n                        <StatsRow heading>\n                          {t(\"labels.unCroppedDimension\")}\n                        </StatsRow>\n                      )}\n\n                      {appState.croppingElementId &&\n                        isImageElement(singleElement) &&\n                        unCroppedDimension && (\n                          <StatsRow columns={2}>\n                            <div>{t(\"stats.width\")}</div>\n                            <div>{round(unCroppedDimension.width, 2)}</div>\n                          </StatsRow>\n                        )}\n\n                      {appState.croppingElementId &&\n                        isImageElement(singleElement) &&\n                        unCroppedDimension && (\n                          <StatsRow columns={2}>\n                            <div>{t(\"stats.height\")}</div>\n                            <div>{round(unCroppedDimension.height, 2)}</div>\n                          </StatsRow>\n                        )}\n\n                      <StatsRow\n                        heading\n                        data-testid=\"stats-element-type\"\n                        style={{ margin: \"0.3125rem 0\" }}\n                      >\n                        {appState.croppingElementId\n                          ? t(\"labels.imageCropping\")\n                          : t(`element.${singleElement.type}`)}\n                      </StatsRow>\n\n                      <StatsRow>\n                        <Position\n                          element={singleElement}\n                          property=\"x\"\n                          elementsMap={elementsMap}\n                          scene={scene}\n                          appState={appState}\n                        />\n                      </StatsRow>\n                      <StatsRow>\n                        <Position\n                          element={singleElement}\n                          property=\"y\"\n                          elementsMap={elementsMap}\n                          scene={scene}\n                          appState={appState}\n                        />\n                      </StatsRow>\n                      <StatsRow>\n                        <Dimension\n                          property=\"width\"\n                          element={singleElement}\n                          scene={scene}\n                          appState={appState}\n                        />\n                      </StatsRow>\n                      <StatsRow>\n                        <Dimension\n                          property=\"height\"\n                          element={singleElement}\n                          scene={scene}\n                          appState={appState}\n                        />\n                      </StatsRow>\n                      {!isElbowArrow(singleElement) && (\n                        <StatsRow>\n                          <Angle\n                            property=\"angle\"\n                            element={singleElement}\n                            scene={scene}\n                            appState={appState}\n                          />\n                        </StatsRow>\n                      )}\n                      <StatsRow>\n                        <FontSize\n                          property=\"fontSize\"\n                          element={singleElement}\n                          scene={scene}\n                          appState={appState}\n                        />\n                      </StatsRow>\n                    </>\n                  )}\n\n                  {multipleElements && (\n                    <>\n                      {elementsAreInSameGroup(multipleElements) && (\n                        <StatsRow heading>{t(\"element.group\")}</StatsRow>\n                      )}\n\n                      <StatsRow columns={2} style={{ margin: \"0.3125rem 0\" }}>\n                        <div>{t(\"stats.shapes\")}</div>\n                        <div>{selectedElements.length}</div>\n                      </StatsRow>\n\n                      <StatsRow>\n                        <MultiPosition\n                          property=\"x\"\n                          elements={multipleElements}\n                          elementsMap={elementsMap}\n                          atomicUnits={atomicUnits}\n                          scene={scene}\n                          appState={appState}\n                        />\n                      </StatsRow>\n                      <StatsRow>\n                        <MultiPosition\n                          property=\"y\"\n                          elements={multipleElements}\n                          elementsMap={elementsMap}\n                          atomicUnits={atomicUnits}\n                          scene={scene}\n                          appState={appState}\n                        />\n                      </StatsRow>\n                      <StatsRow>\n                        <MultiDimension\n                          property=\"width\"\n                          elements={multipleElements}\n                          elementsMap={elementsMap}\n                          atomicUnits={atomicUnits}\n                          scene={scene}\n                          appState={appState}\n                        />\n                      </StatsRow>\n                      <StatsRow>\n                        <MultiDimension\n                          property=\"height\"\n                          elements={multipleElements}\n                          elementsMap={elementsMap}\n                          atomicUnits={atomicUnits}\n                          scene={scene}\n                          appState={appState}\n                        />\n                      </StatsRow>\n                      <StatsRow>\n                        <MultiAngle\n                          property=\"angle\"\n                          elements={multipleElements}\n                          scene={scene}\n                          appState={appState}\n                        />\n                      </StatsRow>\n                      <StatsRow>\n                        <MultiFontSize\n                          property=\"fontSize\"\n                          elements={multipleElements}\n                          scene={scene}\n                          appState={appState}\n                          elementsMap={elementsMap}\n                        />\n                      </StatsRow>\n                    </>\n                  )}\n                </StatsRows>\n              </Collapsible>\n            </div>\n          )}\n        </Island>\n      </div>\n    );\n  },\n  (prev, next) => {\n    return (\n      prev.sceneNonce === next.sceneNonce &&\n      prev.selectedElements === next.selectedElements &&\n      prev.appState.stats.panels === next.appState.stats.panels &&\n      prev.gridModeEnabled === next.gridModeEnabled &&\n      prev.appState.gridStep === next.appState.gridStep &&\n      prev.appState.croppingElementId === next.appState.croppingElementId\n    );\n  },\n);\n",
    "import { degreesToRadians, radiansToDegrees } from \"@excalidraw/math\";\n\nimport { getBoundTextElement } from \"@excalidraw/element\";\nimport { isArrowElement, isElbowArrow } from \"@excalidraw/element\";\n\nimport { updateBindings } from \"@excalidraw/element\";\n\nimport type { Degrees } from \"@excalidraw/math\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport { angleIcon } from \"../icons\";\n\nimport DragInput from \"./DragInput\";\nimport { getStepSizedValue, isPropertyEditable } from \"./utils\";\n\nimport type { DragInputCallbackType } from \"./DragInput\";\nimport type { AppState } from \"../../types\";\n\ninterface AngleProps {\n  element: ExcalidrawElement;\n  scene: Scene;\n  appState: AppState;\n  property: \"angle\";\n}\n\nconst STEP_SIZE = 15;\n\nconst handleDegreeChange: DragInputCallbackType<AngleProps[\"property\"]> = ({\n  accumulatedChange,\n  originalElements,\n  shouldChangeByStepSize,\n  nextValue,\n  scene,\n}) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const origElement = originalElements[0];\n  if (origElement && !isElbowArrow(origElement)) {\n    const latestElement = elementsMap.get(origElement.id);\n    if (!latestElement) {\n      return;\n    }\n\n    if (nextValue !== undefined) {\n      const nextAngle = degreesToRadians(nextValue as Degrees);\n      scene.mutateElement(latestElement, {\n        angle: nextAngle,\n      });\n      updateBindings(latestElement, scene);\n\n      const boundTextElement = getBoundTextElement(latestElement, elementsMap);\n      if (boundTextElement && !isArrowElement(latestElement)) {\n        scene.mutateElement(boundTextElement, { angle: nextAngle });\n      }\n\n      return;\n    }\n\n    const originalAngleInDegrees =\n      Math.round(radiansToDegrees(origElement.angle) * 100) / 100;\n    const changeInDegrees = Math.round(accumulatedChange);\n    let nextAngleInDegrees = (originalAngleInDegrees + changeInDegrees) % 360;\n    if (shouldChangeByStepSize) {\n      nextAngleInDegrees = getStepSizedValue(nextAngleInDegrees, STEP_SIZE);\n    }\n\n    nextAngleInDegrees =\n      nextAngleInDegrees < 0 ? nextAngleInDegrees + 360 : nextAngleInDegrees;\n\n    const nextAngle = degreesToRadians(nextAngleInDegrees as Degrees);\n\n    scene.mutateElement(latestElement, {\n      angle: nextAngle,\n    });\n    updateBindings(latestElement, scene);\n\n    const boundTextElement = getBoundTextElement(latestElement, elementsMap);\n    if (boundTextElement && !isArrowElement(latestElement)) {\n      scene.mutateElement(boundTextElement, { angle: nextAngle });\n    }\n  }\n};\n\nconst Angle = ({ element, scene, appState, property }: AngleProps) => {\n  return (\n    <DragInput\n      label=\"A\"\n      icon={angleIcon}\n      value={Math.round((radiansToDegrees(element.angle) % 360) * 100) / 100}\n      elements={[element]}\n      dragInputCallback={handleDegreeChange}\n      editable={isPropertyEditable(element, \"angle\")}\n      scene={scene}\n      appState={appState}\n      property={property}\n    />\n  );\n};\n\nexport default Angle;\n",
    "import clsx from \"clsx\";\nimport { useEffect, useRef, useState } from \"react\";\n\nimport { EVENT, KEYS, cloneJSON } from \"@excalidraw/common\";\n\nimport { deepCopyElement } from \"@excalidraw/element\";\n\nimport { CaptureUpdateAction } from \"@excalidraw/element\";\n\nimport type { ElementsMap, ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport { useApp, useExcalidrawSetAppState } from \"../App\";\nimport { InlineIcon } from \"../InlineIcon\";\n\nimport { SMALLEST_DELTA } from \"./utils\";\n\nimport \"./DragInput.scss\";\n\nimport type { StatsInputProperty } from \"./utils\";\nimport type { AppState } from \"../../types\";\n\nexport type DragInputCallbackType<\n  P extends StatsInputProperty,\n  E = ExcalidrawElement,\n> = (props: {\n  accumulatedChange: number;\n  instantChange: number;\n  originalElements: readonly E[];\n  originalElementsMap: ElementsMap;\n  shouldKeepAspectRatio: boolean;\n  shouldChangeByStepSize: boolean;\n  scene: Scene;\n  nextValue?: number;\n  property: P;\n  originalAppState: AppState;\n  setInputValue: (value: number) => void;\n  app: ReturnType<typeof useApp>;\n  setAppState: ReturnType<typeof useExcalidrawSetAppState>;\n}) => void;\n\nexport type DragFinishedCallbackType<E = ExcalidrawElement> = (props: {\n  app: ReturnType<typeof useApp>;\n  setAppState: ReturnType<typeof useExcalidrawSetAppState>;\n  originalElements: readonly E[] | null;\n  originalAppState: AppState;\n}) => void;\n\ninterface StatsDragInputProps<\n  T extends StatsInputProperty,\n  E = ExcalidrawElement,\n> {\n  label: string | React.ReactNode;\n  icon?: React.ReactNode;\n  value: number | \"Mixed\";\n  elements: readonly E[];\n  editable?: boolean;\n  shouldKeepAspectRatio?: boolean;\n  dragInputCallback: DragInputCallbackType<T, E>;\n  property: T;\n  scene: Scene;\n  appState: AppState;\n  /** how many px you need to drag to get 1 unit change */\n  sensitivity?: number;\n  dragFinishedCallback?: DragFinishedCallbackType;\n}\n\nconst StatsDragInput = <\n  T extends StatsInputProperty,\n  E extends ExcalidrawElement = ExcalidrawElement,\n>({\n  label,\n  icon,\n  dragInputCallback,\n  value,\n  elements,\n  editable = true,\n  shouldKeepAspectRatio,\n  property,\n  scene,\n  appState,\n  sensitivity = 1,\n  dragFinishedCallback,\n}: StatsDragInputProps<T, E>) => {\n  const app = useApp();\n  const setAppState = useExcalidrawSetAppState();\n  const inputRef = useRef<HTMLInputElement>(null);\n  const labelRef = useRef<HTMLDivElement>(null);\n\n  const [inputValue, setInputValue] = useState(value.toString());\n\n  const stateRef = useRef<{\n    originalAppState: AppState;\n    originalElements: readonly E[];\n    lastUpdatedValue: string;\n    updatePending: boolean;\n  }>(null!);\n  if (!stateRef.current) {\n    stateRef.current = {\n      originalAppState: cloneJSON(appState),\n      originalElements: elements,\n      lastUpdatedValue: inputValue,\n      updatePending: false,\n    };\n  }\n\n  useEffect(() => {\n    const inputValue = value.toString();\n    setInputValue(inputValue);\n    stateRef.current.lastUpdatedValue = inputValue;\n  }, [value]);\n\n  const handleInputValue = (\n    updatedValue: string,\n    elements: readonly E[],\n    appState: AppState,\n  ) => {\n    if (!stateRef.current.updatePending) {\n      return false;\n    }\n    stateRef.current.updatePending = false;\n\n    const parsed = Number(updatedValue);\n    if (isNaN(parsed)) {\n      setInputValue(value.toString());\n      return;\n    }\n\n    const rounded = Number(parsed.toFixed(2));\n    const original = Number(value);\n\n    // only update when\n    // 1. original was \"Mixed\" and we have a new value\n    // 2. original was not \"Mixed\" and the difference between a new value and previous value is greater\n    //    than the smallest delta allowed, which is 0.01\n    // reason: idempotent to avoid unnecessary\n    if (isNaN(original) || Math.abs(rounded - original) >= SMALLEST_DELTA) {\n      stateRef.current.lastUpdatedValue = updatedValue;\n      dragInputCallback({\n        accumulatedChange: 0,\n        instantChange: 0,\n        originalElements: elements,\n        originalElementsMap: app.scene.getNonDeletedElementsMap(),\n        shouldKeepAspectRatio: shouldKeepAspectRatio!!,\n        shouldChangeByStepSize: false,\n        scene,\n        nextValue: rounded,\n        property,\n        originalAppState: appState,\n        setInputValue: (value) => setInputValue(String(value)),\n        app,\n        setAppState,\n      });\n      app.syncActionResult({\n        captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n      });\n    }\n  };\n\n  const callbacksRef = useRef<\n    Partial<{\n      handleInputValue: typeof handleInputValue;\n      onPointerUp: (event: PointerEvent) => void;\n      onPointerMove: (event: PointerEvent) => void;\n    }>\n  >({});\n  callbacksRef.current.handleInputValue = handleInputValue;\n\n  // make sure that clicking on canvas (which umounts the component)\n  // updates current input value (blur isn't triggered)\n  useEffect(() => {\n    const input = inputRef.current;\n    const callbacks = callbacksRef.current;\n    return () => {\n      const nextValue = input?.value;\n      if (nextValue) {\n        callbacks.handleInputValue?.(\n          nextValue,\n          stateRef.current.originalElements,\n          stateRef.current.originalAppState,\n        );\n      }\n\n      // generally not needed, but in case `pointerup` doesn't fire and\n      // we don't remove the listeners that way, we should at least remove\n      // on unmount\n      window.removeEventListener(\n        EVENT.POINTER_MOVE,\n        callbacks.onPointerMove!,\n        false,\n      );\n      window.removeEventListener(\n        EVENT.POINTER_UP,\n        callbacks.onPointerUp!,\n        false,\n      );\n    };\n  }, [\n    // we need to track change of `editable` state as mount/unmount\n    // because react doesn't trigger `blur` when a an input is blurred due\n    // to being disabled (https://github.com/facebook/react/issues/9142).\n    // As such, if we keep rendering disabled inputs, then change in selection\n    // to an element that has a given property as non-editable would not trigger\n    // blur/unmount and wouldn't update the value.\n    editable,\n  ]);\n\n  if (!editable) {\n    return null;\n  }\n\n  return (\n    <div\n      className={clsx(\"drag-input-container\", !editable && \"disabled\")}\n      data-testid={label}\n    >\n      <div\n        className=\"drag-input-label\"\n        ref={labelRef}\n        onPointerDown={(event) => {\n          if (inputRef.current && editable) {\n            document.body.classList.add(\"excalidraw-cursor-resize\");\n\n            let startValue = Number(inputRef.current.value);\n            if (isNaN(startValue)) {\n              startValue = 0;\n            }\n\n            let lastPointer: {\n              x: number;\n              y: number;\n            } | null = null;\n\n            let originalElementsMap: ElementsMap | null = app.scene\n              .getNonDeletedElements()\n              .reduce((acc: ElementsMap, element) => {\n                acc.set(element.id, deepCopyElement(element));\n                return acc;\n              }, new Map());\n\n            let originalElements: readonly E[] | null = elements.map(\n              (element) => originalElementsMap!.get(element.id) as E,\n            );\n\n            const originalAppState: AppState = cloneJSON(appState);\n\n            let accumulatedChange = 0;\n            let stepChange = 0;\n\n            const onPointerMove = (event: PointerEvent) => {\n              if (\n                lastPointer &&\n                originalElementsMap !== null &&\n                originalElements !== null\n              ) {\n                const instantChange = event.clientX - lastPointer.x;\n\n                if (instantChange !== 0) {\n                  stepChange += instantChange;\n\n                  if (Math.abs(stepChange) >= sensitivity) {\n                    stepChange =\n                      Math.sign(stepChange) *\n                      Math.floor(Math.abs(stepChange) / sensitivity);\n\n                    accumulatedChange += stepChange;\n\n                    dragInputCallback({\n                      accumulatedChange,\n                      instantChange: stepChange,\n                      originalElements,\n                      originalElementsMap,\n                      shouldKeepAspectRatio: shouldKeepAspectRatio!!,\n                      shouldChangeByStepSize: event.shiftKey,\n                      property,\n                      scene,\n                      originalAppState,\n                      setInputValue: (value) => setInputValue(String(value)),\n                      app,\n                      setAppState,\n                    });\n\n                    stepChange = 0;\n                  }\n                }\n              }\n\n              lastPointer = {\n                x: event.clientX,\n                y: event.clientY,\n              };\n            };\n\n            const onPointerUp = () => {\n              window.removeEventListener(\n                EVENT.POINTER_MOVE,\n                onPointerMove,\n                false,\n              );\n\n              app.syncActionResult({\n                captureUpdate: CaptureUpdateAction.IMMEDIATELY,\n              });\n\n              // Notify implementors\n              dragFinishedCallback?.({\n                app,\n                setAppState,\n                originalElements,\n                originalAppState,\n              });\n\n              lastPointer = null;\n              accumulatedChange = 0;\n              stepChange = 0;\n              originalElements = null;\n              originalElementsMap = null;\n\n              document.body.classList.remove(\"excalidraw-cursor-resize\");\n\n              window.removeEventListener(EVENT.POINTER_UP, onPointerUp, false);\n            };\n\n            callbacksRef.current.onPointerMove = onPointerMove;\n            callbacksRef.current.onPointerUp = onPointerUp;\n\n            window.addEventListener(EVENT.POINTER_MOVE, onPointerMove, false);\n            window.addEventListener(EVENT.POINTER_UP, onPointerUp, false);\n          }\n        }}\n        onPointerEnter={() => {\n          if (labelRef.current) {\n            labelRef.current.style.cursor = \"ew-resize\";\n          }\n        }}\n      >\n        {icon ? <InlineIcon icon={icon} /> : label}\n      </div>\n      <input\n        className=\"drag-input\"\n        autoComplete=\"off\"\n        spellCheck=\"false\"\n        onKeyDown={(event) => {\n          if (editable) {\n            const eventTarget = event.target;\n            if (\n              eventTarget instanceof HTMLInputElement &&\n              event.key === KEYS.ENTER\n            ) {\n              handleInputValue(eventTarget.value, elements, appState);\n              app.focusContainer();\n            }\n          }\n        }}\n        ref={inputRef}\n        value={inputValue}\n        onChange={(event) => {\n          stateRef.current.updatePending = true;\n          setInputValue(event.target.value);\n        }}\n        onFocus={(event) => {\n          event.target.select();\n          stateRef.current.originalElements = elements;\n          stateRef.current.originalAppState = cloneJSON(appState);\n        }}\n        onBlur={(event) => {\n          if (!inputValue) {\n            setInputValue(value.toString());\n          } else if (editable) {\n            handleInputValue(\n              event.target.value,\n              stateRef.current.originalElements,\n              stateRef.current.originalAppState,\n            );\n          }\n        }}\n        disabled={!editable}\n      />\n    </div>\n  );\n};\n\nexport default StatsDragInput;\n",
    "import { pointFrom, pointRotateRads } from \"@excalidraw/math\";\n\nimport { getBoundTextElement } from \"@excalidraw/element\";\nimport { isFrameLikeElement } from \"@excalidraw/element\";\n\nimport {\n  getSelectedGroupIds,\n  getElementsInGroup,\n  isInGroup,\n} from \"@excalidraw/element\";\n\nimport { getFrameChildren } from \"@excalidraw/element\";\n\nimport { updateBindings } from \"@excalidraw/element\";\n\nimport type { Radians } from \"@excalidraw/math\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport type { AppState } from \"../../types\";\n\nexport type StatsInputProperty =\n  | \"x\"\n  | \"y\"\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"fontSize\"\n  | \"gridStep\";\n\nexport const SMALLEST_DELTA = 0.01;\nexport const STEP_SIZE = 10;\n\nexport const isPropertyEditable = (\n  element: ExcalidrawElement,\n  property: keyof ExcalidrawElement,\n) => {\n  if (property === \"angle\" && isFrameLikeElement(element)) {\n    return false;\n  }\n  return true;\n};\n\nexport const getStepSizedValue = (value: number, stepSize: number) => {\n  const v = value + stepSize / 2;\n  return v - (v % stepSize);\n};\n\nexport type AtomicUnit = Record<string, true>;\nexport const getElementsInAtomicUnit = (\n  atomicUnit: AtomicUnit,\n  elementsMap: ElementsMap,\n  originalElementsMap?: ElementsMap,\n) => {\n  return Object.keys(atomicUnit)\n    .map((id) => ({\n      original: (originalElementsMap ?? elementsMap).get(id),\n      latest: elementsMap.get(id),\n    }))\n    .filter((el) => el.original !== undefined && el.latest !== undefined) as {\n    original: NonDeletedExcalidrawElement;\n    latest: NonDeletedExcalidrawElement;\n  }[];\n};\n\nexport const newOrigin = (\n  x1: number,\n  y1: number,\n  w1: number,\n  h1: number,\n  w2: number,\n  h2: number,\n  angle: number,\n) => {\n  /**\n   * The formula below is the result of solving\n   *   rotate(x1, y1, cx1, cy1, angle) = rotate(x2, y2, cx2, cy2, angle)\n   * where rotate is the function defined in math.ts\n   *\n   * This is so that the new origin (x2, y2),\n   * when rotated against the new center (cx2, cy2),\n   * coincides with (x1, y1) rotated against (cx1, cy1)\n   *\n   * The reason for doing this computation is so the element's top left corner\n   * on the canvas remains fixed after any changes in its dimension.\n   */\n\n  return {\n    x:\n      x1 +\n      (w1 - w2) / 2 +\n      ((w2 - w1) / 2) * Math.cos(angle) +\n      ((h1 - h2) / 2) * Math.sin(angle),\n    y:\n      y1 +\n      (h1 - h2) / 2 +\n      ((w2 - w1) / 2) * Math.sin(angle) +\n      ((h2 - h1) / 2) * Math.cos(angle),\n  };\n};\n\nexport const moveElement = (\n  newTopLeftX: number,\n  newTopLeftY: number,\n  originalElement: ExcalidrawElement,\n  scene: Scene,\n  originalElementsMap: ElementsMap,\n  shouldInformMutation = true,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const latestElement = elementsMap.get(originalElement.id);\n  if (!latestElement) {\n    return;\n  }\n  const [cx, cy] = [\n    originalElement.x + originalElement.width / 2,\n    originalElement.y + originalElement.height / 2,\n  ];\n  const [topLeftX, topLeftY] = pointRotateRads(\n    pointFrom(originalElement.x, originalElement.y),\n    pointFrom(cx, cy),\n    originalElement.angle,\n  );\n\n  const changeInX = newTopLeftX - topLeftX;\n  const changeInY = newTopLeftY - topLeftY;\n\n  const [x, y] = pointRotateRads(\n    pointFrom(newTopLeftX, newTopLeftY),\n    pointFrom(cx + changeInX, cy + changeInY),\n    -originalElement.angle as Radians,\n  );\n\n  scene.mutateElement(\n    latestElement,\n    {\n      x,\n      y,\n    },\n    { informMutation: shouldInformMutation, isDragging: false },\n  );\n  updateBindings(latestElement, scene);\n\n  const boundTextElement = getBoundTextElement(\n    originalElement,\n    originalElementsMap,\n  );\n  if (boundTextElement) {\n    const latestBoundTextElement = elementsMap.get(boundTextElement.id);\n    latestBoundTextElement &&\n      scene.mutateElement(\n        latestBoundTextElement,\n        {\n          x: boundTextElement.x + changeInX,\n          y: boundTextElement.y + changeInY,\n        },\n        { informMutation: shouldInformMutation, isDragging: false },\n      );\n  }\n\n  if (isFrameLikeElement(originalElement)) {\n    const originalChildren = getFrameChildren(\n      originalElementsMap,\n      originalElement.id,\n    );\n    originalChildren.forEach((child) => {\n      const latestChildElement = elementsMap.get(child.id);\n\n      if (!latestChildElement) {\n        return;\n      }\n\n      const [childCX, childCY] = [\n        child.x + child.width / 2,\n        child.y + child.height / 2,\n      ];\n      const [childTopLeftX, childTopLeftY] = pointRotateRads(\n        pointFrom(child.x, child.y),\n        pointFrom(childCX, childCY),\n        child.angle,\n      );\n\n      const childNewTopLeftX = Math.round(childTopLeftX + changeInX);\n      const childNewTopLeftY = Math.round(childTopLeftY + changeInY);\n\n      const [childX, childY] = pointRotateRads(\n        pointFrom(childNewTopLeftX, childNewTopLeftY),\n        pointFrom(childCX + changeInX, childCY + changeInY),\n        -child.angle as Radians,\n      );\n\n      scene.mutateElement(\n        latestChildElement,\n        {\n          x: childX,\n          y: childY,\n        },\n        { informMutation: shouldInformMutation, isDragging: false },\n      );\n      updateBindings(latestChildElement, scene, {\n        simultaneouslyUpdated: originalChildren,\n      });\n    });\n  }\n};\n\nexport const getAtomicUnits = (\n  targetElements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const selectedGroupIds = getSelectedGroupIds(appState);\n  const _atomicUnits = selectedGroupIds.map((gid) => {\n    return getElementsInGroup(targetElements, gid).reduce((acc, el) => {\n      acc[el.id] = true;\n      return acc;\n    }, {} as AtomicUnit);\n  });\n  targetElements\n    .filter((el) => !isInGroup(el))\n    .forEach((el) => {\n      _atomicUnits.push({\n        [el.id]: true,\n      });\n    });\n  return _atomicUnits;\n};\n",
    "import type { Scene } from \"@excalidraw/element\";\n\nimport { getNormalizedGridStep } from \"../../scene\";\n\nimport StatsDragInput from \"./DragInput\";\nimport { getStepSizedValue } from \"./utils\";\n\nimport type { AppState } from \"../../types\";\n\ninterface PositionProps {\n  property: \"gridStep\";\n  scene: Scene;\n  appState: AppState;\n  setAppState: React.Component<any, AppState>[\"setState\"];\n}\n\nconst STEP_SIZE = 5;\n\nconst CanvasGrid = ({\n  property,\n  scene,\n  appState,\n  setAppState,\n}: PositionProps) => {\n  return (\n    <StatsDragInput\n      label=\"Grid step\"\n      sensitivity={8}\n      elements={[]}\n      dragInputCallback={({\n        nextValue,\n        instantChange,\n        shouldChangeByStepSize,\n        setInputValue,\n      }) => {\n        setAppState((state) => {\n          let nextGridStep;\n\n          if (nextValue) {\n            nextGridStep = nextValue;\n          } else if (instantChange) {\n            nextGridStep = shouldChangeByStepSize\n              ? getStepSizedValue(\n                  state.gridStep + STEP_SIZE * Math.sign(instantChange),\n                  STEP_SIZE,\n                )\n              : state.gridStep + instantChange;\n          }\n\n          if (!nextGridStep) {\n            setInputValue(state.gridStep);\n            return null;\n          }\n\n          nextGridStep = getNormalizedGridStep(nextGridStep);\n          setInputValue(nextGridStep);\n          return {\n            gridStep: nextGridStep,\n          };\n        });\n      }}\n      scene={scene}\n      value={appState.gridStep}\n      property={property}\n      appState={appState}\n    />\n  );\n};\n\nexport default CanvasGrid;\n",
    "import { clamp, round } from \"@excalidraw/math\";\n\nimport { MIN_WIDTH_OR_HEIGHT } from \"@excalidraw/common\";\nimport {\n  MINIMAL_CROP_SIZE,\n  getUncroppedWidthAndHeight,\n} from \"@excalidraw/element\";\nimport { resizeSingleElement } from \"@excalidraw/element\";\nimport { isImageElement } from \"@excalidraw/element\";\nimport { isFrameLikeElement } from \"@excalidraw/element\";\nimport { getElementsInResizingFrame } from \"@excalidraw/element\";\nimport { replaceAllElementsInFrame } from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport DragInput from \"./DragInput\";\nimport { getStepSizedValue, isPropertyEditable } from \"./utils\";\n\nimport type {\n  DragFinishedCallbackType,\n  DragInputCallbackType,\n} from \"./DragInput\";\nimport type { AppState } from \"../../types\";\n\ninterface DimensionDragInputProps {\n  property: \"width\" | \"height\";\n  element: ExcalidrawElement;\n  scene: Scene;\n  appState: AppState;\n}\n\nconst STEP_SIZE = 10;\nconst _shouldKeepAspectRatio = (element: ExcalidrawElement) => {\n  return element.type === \"image\";\n};\n\nconst handleDimensionChange: DragInputCallbackType<\n  DimensionDragInputProps[\"property\"]\n> = ({\n  accumulatedChange,\n  originalElements,\n  originalElementsMap,\n  shouldKeepAspectRatio,\n  shouldChangeByStepSize,\n  nextValue,\n  property,\n  originalAppState,\n  instantChange,\n  scene,\n  app,\n  setAppState,\n}) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const origElement = originalElements[0];\n  const latestElement = elementsMap.get(origElement.id);\n  if (origElement && latestElement) {\n    const keepAspectRatio =\n      shouldKeepAspectRatio || _shouldKeepAspectRatio(origElement);\n    const aspectRatio = origElement.width / origElement.height;\n\n    if (originalAppState.croppingElementId === origElement.id) {\n      const element = elementsMap.get(origElement.id);\n\n      if (!element || !isImageElement(element) || !element.crop) {\n        return;\n      }\n\n      const crop = element.crop;\n      let nextCrop = { ...crop };\n\n      const isFlippedByX = element.scale[0] === -1;\n      const isFlippedByY = element.scale[1] === -1;\n\n      const { width: uncroppedWidth, height: uncroppedHeight } =\n        getUncroppedWidthAndHeight(element);\n\n      const naturalToUncroppedWidthRatio = crop.naturalWidth / uncroppedWidth;\n      const naturalToUncroppedHeightRatio =\n        crop.naturalHeight / uncroppedHeight;\n\n      const MAX_POSSIBLE_WIDTH = isFlippedByX\n        ? crop.width + crop.x\n        : crop.naturalWidth - crop.x;\n\n      const MAX_POSSIBLE_HEIGHT = isFlippedByY\n        ? crop.height + crop.y\n        : crop.naturalHeight - crop.y;\n\n      const MIN_WIDTH = MINIMAL_CROP_SIZE * naturalToUncroppedWidthRatio;\n      const MIN_HEIGHT = MINIMAL_CROP_SIZE * naturalToUncroppedHeightRatio;\n\n      if (nextValue !== undefined) {\n        if (property === \"width\") {\n          const nextValueInNatural = nextValue * naturalToUncroppedWidthRatio;\n\n          const nextCropWidth = clamp(\n            nextValueInNatural,\n            MIN_WIDTH,\n            MAX_POSSIBLE_WIDTH,\n          );\n\n          nextCrop = {\n            ...nextCrop,\n            width: nextCropWidth,\n            x: isFlippedByX ? crop.x + crop.width - nextCropWidth : crop.x,\n          };\n        } else if (property === \"height\") {\n          const nextValueInNatural = nextValue * naturalToUncroppedHeightRatio;\n          const nextCropHeight = clamp(\n            nextValueInNatural,\n            MIN_HEIGHT,\n            MAX_POSSIBLE_HEIGHT,\n          );\n\n          nextCrop = {\n            ...nextCrop,\n            height: nextCropHeight,\n            y: isFlippedByY ? crop.y + crop.height - nextCropHeight : crop.y,\n          };\n        }\n\n        scene.mutateElement(element, {\n          crop: nextCrop,\n          width: nextCrop.width / (crop.naturalWidth / uncroppedWidth),\n          height: nextCrop.height / (crop.naturalHeight / uncroppedHeight),\n        });\n        return;\n      }\n\n      const changeInWidth = property === \"width\" ? instantChange : 0;\n      const changeInHeight = property === \"height\" ? instantChange : 0;\n\n      const nextCropWidth = clamp(\n        crop.width + changeInWidth,\n        MIN_WIDTH,\n        MAX_POSSIBLE_WIDTH,\n      );\n\n      const nextCropHeight = clamp(\n        crop.height + changeInHeight,\n        MIN_WIDTH,\n        MAX_POSSIBLE_HEIGHT,\n      );\n\n      nextCrop = {\n        ...crop,\n        x: isFlippedByX ? crop.x + crop.width - nextCropWidth : crop.x,\n        y: isFlippedByY ? crop.y + crop.height - nextCropHeight : crop.y,\n        width: nextCropWidth,\n        height: nextCropHeight,\n      };\n\n      scene.mutateElement(element, {\n        crop: nextCrop,\n        width: nextCrop.width / (crop.naturalWidth / uncroppedWidth),\n        height: nextCrop.height / (crop.naturalHeight / uncroppedHeight),\n      });\n\n      return;\n    }\n\n    // User types in a value to stats then presses Enter\n    if (nextValue !== undefined) {\n      const nextWidth = Math.max(\n        property === \"width\"\n          ? nextValue\n          : keepAspectRatio\n          ? nextValue * aspectRatio\n          : origElement.width,\n        MIN_WIDTH_OR_HEIGHT,\n      );\n      const nextHeight = Math.max(\n        property === \"height\"\n          ? nextValue\n          : keepAspectRatio\n          ? nextValue / aspectRatio\n          : origElement.height,\n        MIN_WIDTH_OR_HEIGHT,\n      );\n\n      resizeSingleElement(\n        nextWidth,\n        nextHeight,\n        latestElement,\n        origElement,\n        originalElementsMap,\n        scene,\n        property === \"width\" ? \"e\" : \"s\",\n        {\n          shouldMaintainAspectRatio: keepAspectRatio,\n        },\n      );\n\n      // Handle frame membership update for resized frames\n      if (isFrameLikeElement(latestElement)) {\n        const nextElementsInFrame = getElementsInResizingFrame(\n          scene.getElementsIncludingDeleted(),\n          latestElement,\n          originalAppState,\n          scene.getNonDeletedElementsMap(),\n        );\n\n        const updatedElements = replaceAllElementsInFrame(\n          scene.getElementsIncludingDeleted(),\n          nextElementsInFrame,\n          latestElement,\n          app,\n        );\n\n        scene.replaceAllElements(updatedElements);\n      }\n\n      return;\n    }\n\n    // Stats slider is dragged\n    {\n      const changeInWidth = property === \"width\" ? accumulatedChange : 0;\n      const changeInHeight = property === \"height\" ? accumulatedChange : 0;\n\n      let nextWidth = Math.max(0, origElement.width + changeInWidth);\n      if (property === \"width\") {\n        if (shouldChangeByStepSize) {\n          nextWidth = getStepSizedValue(nextWidth, STEP_SIZE);\n        } else {\n          nextWidth = Math.round(nextWidth);\n        }\n      }\n\n      let nextHeight = Math.max(0, origElement.height + changeInHeight);\n      if (property === \"height\") {\n        if (shouldChangeByStepSize) {\n          nextHeight = getStepSizedValue(nextHeight, STEP_SIZE);\n        } else {\n          nextHeight = Math.round(nextHeight);\n        }\n      }\n\n      if (keepAspectRatio) {\n        if (property === \"width\") {\n          nextHeight = Math.round((nextWidth / aspectRatio) * 100) / 100;\n        } else {\n          nextWidth = Math.round(nextHeight * aspectRatio * 100) / 100;\n        }\n      }\n\n      nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);\n      nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);\n\n      resizeSingleElement(\n        nextWidth,\n        nextHeight,\n        latestElement,\n        origElement,\n        originalElementsMap,\n        scene,\n        property === \"width\" ? \"e\" : \"s\",\n        {\n          shouldMaintainAspectRatio: keepAspectRatio,\n        },\n      );\n\n      // Handle highlighting frame element candidates\n      if (isFrameLikeElement(latestElement)) {\n        const nextElementsInFrame = getElementsInResizingFrame(\n          scene.getElementsIncludingDeleted(),\n          latestElement,\n          originalAppState,\n          scene.getNonDeletedElementsMap(),\n        );\n\n        setAppState({\n          elementsToHighlight: nextElementsInFrame,\n        });\n      }\n    }\n  }\n};\n\nconst handleDragFinished: DragFinishedCallbackType = ({\n  setAppState,\n  app,\n  originalElements,\n  originalAppState,\n}) => {\n  const elementsMap = app.scene.getNonDeletedElementsMap();\n  const origElement = originalElements?.[0];\n  const latestElement = origElement && elementsMap.get(origElement.id);\n\n  // Handle frame membership update for resized frames\n  if (latestElement && isFrameLikeElement(latestElement)) {\n    const nextElementsInFrame = getElementsInResizingFrame(\n      app.scene.getElementsIncludingDeleted(),\n      latestElement,\n      originalAppState,\n      app.scene.getNonDeletedElementsMap(),\n    );\n\n    const updatedElements = replaceAllElementsInFrame(\n      app.scene.getElementsIncludingDeleted(),\n      nextElementsInFrame,\n      latestElement,\n      app,\n    );\n\n    app.scene.replaceAllElements(updatedElements);\n\n    setAppState({\n      elementsToHighlight: null,\n    });\n  }\n};\n\nconst DimensionDragInput = ({\n  property,\n  element,\n  scene,\n  appState,\n}: DimensionDragInputProps) => {\n  let value = round(property === \"width\" ? element.width : element.height, 2);\n\n  if (\n    appState.croppingElementId &&\n    appState.croppingElementId === element.id &&\n    isImageElement(element) &&\n    element.crop\n  ) {\n    const { width: uncroppedWidth, height: uncroppedHeight } =\n      getUncroppedWidthAndHeight(element);\n    if (property === \"width\") {\n      const ratio = uncroppedWidth / element.crop.naturalWidth;\n      value = round(element.crop.width * ratio, 2);\n    }\n    if (property === \"height\") {\n      const ratio = uncroppedHeight / element.crop.naturalHeight;\n      value = round(element.crop.height * ratio, 2);\n    }\n  }\n\n  return (\n    <DragInput\n      label={property === \"width\" ? \"W\" : \"H\"}\n      elements={[element]}\n      dragInputCallback={handleDimensionChange}\n      value={value}\n      editable={isPropertyEditable(element, property)}\n      scene={scene}\n      appState={appState}\n      property={property}\n      dragFinishedCallback={handleDragFinished}\n    />\n  );\n};\n\nexport default DimensionDragInput;\n",
    "import {\n  getBoundTextElement,\n  redrawTextBoundingBox,\n} from \"@excalidraw/element\";\nimport { hasBoundTextElement, isTextElement } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n} from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport { fontSizeIcon } from \"../icons\";\n\nimport StatsDragInput from \"./DragInput\";\nimport { getStepSizedValue } from \"./utils\";\n\nimport type { DragInputCallbackType } from \"./DragInput\";\nimport type { AppState } from \"../../types\";\n\ninterface FontSizeProps {\n  element: ExcalidrawElement;\n  scene: Scene;\n  appState: AppState;\n  property: \"fontSize\";\n}\n\nconst MIN_FONT_SIZE = 4;\nconst STEP_SIZE = 4;\n\nconst handleFontSizeChange: DragInputCallbackType<\n  FontSizeProps[\"property\"],\n  ExcalidrawTextElement\n> = ({\n  accumulatedChange,\n  originalElements,\n  shouldChangeByStepSize,\n  nextValue,\n  scene,\n}) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  const origElement = originalElements[0];\n  if (origElement) {\n    const latestElement = elementsMap.get(origElement.id);\n    if (!latestElement || !isTextElement(latestElement)) {\n      return;\n    }\n\n    let nextFontSize;\n\n    if (nextValue !== undefined) {\n      nextFontSize = Math.max(Math.round(nextValue), MIN_FONT_SIZE);\n    } else if (origElement.type === \"text\") {\n      const originalFontSize = Math.round(origElement.fontSize);\n      const changeInFontSize = Math.round(accumulatedChange);\n      nextFontSize = Math.max(\n        originalFontSize + changeInFontSize,\n        MIN_FONT_SIZE,\n      );\n      if (shouldChangeByStepSize) {\n        nextFontSize = getStepSizedValue(nextFontSize, STEP_SIZE);\n      }\n    }\n\n    if (nextFontSize) {\n      scene.mutateElement(latestElement, {\n        fontSize: nextFontSize,\n      });\n      redrawTextBoundingBox(\n        latestElement,\n        scene.getContainerElement(latestElement),\n        scene,\n      );\n    }\n  }\n};\n\nconst FontSize = ({ element, scene, appState, property }: FontSizeProps) => {\n  const _element = isTextElement(element)\n    ? element\n    : hasBoundTextElement(element)\n    ? getBoundTextElement(element, scene.getNonDeletedElementsMap())\n    : null;\n\n  if (!_element) {\n    return null;\n  }\n\n  return (\n    <StatsDragInput\n      label=\"F\"\n      value={Math.round(_element.fontSize * 10) / 10}\n      elements={[_element]}\n      dragInputCallback={handleFontSizeChange}\n      icon={fontSizeIcon}\n      appState={appState}\n      scene={scene}\n      property={property}\n    />\n  );\n};\n\nexport default FontSize;\n",
    "import { degreesToRadians, radiansToDegrees } from \"@excalidraw/math\";\n\nimport { getBoundTextElement } from \"@excalidraw/element\";\nimport { isArrowElement } from \"@excalidraw/element\";\n\nimport { isInGroup } from \"@excalidraw/element\";\n\nimport type { Degrees } from \"@excalidraw/math\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport { angleIcon } from \"../icons\";\n\nimport DragInput from \"./DragInput\";\nimport { getStepSizedValue, isPropertyEditable } from \"./utils\";\n\nimport type { DragInputCallbackType } from \"./DragInput\";\nimport type { AppState } from \"../../types\";\n\ninterface MultiAngleProps {\n  elements: readonly ExcalidrawElement[];\n  scene: Scene;\n  appState: AppState;\n  property: \"angle\";\n}\n\nconst STEP_SIZE = 15;\n\nconst handleDegreeChange: DragInputCallbackType<\n  MultiAngleProps[\"property\"]\n> = ({\n  accumulatedChange,\n  originalElements,\n  shouldChangeByStepSize,\n  nextValue,\n  property,\n  scene,\n}) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const editableLatestIndividualElements = originalElements\n    .map((el) => elementsMap.get(el.id))\n    .filter((el) => el && !isInGroup(el) && isPropertyEditable(el, property));\n  const editableOriginalIndividualElements = originalElements.filter(\n    (el) => !isInGroup(el) && isPropertyEditable(el, property),\n  );\n\n  if (nextValue !== undefined) {\n    const nextAngle = degreesToRadians(nextValue as Degrees);\n\n    for (const element of editableLatestIndividualElements) {\n      if (!element) {\n        continue;\n      }\n      scene.mutateElement(element, {\n        angle: nextAngle,\n      });\n\n      const boundTextElement = getBoundTextElement(element, elementsMap);\n      if (boundTextElement && !isArrowElement(element)) {\n        scene.mutateElement(boundTextElement, { angle: nextAngle });\n      }\n    }\n\n    scene.triggerUpdate();\n\n    return;\n  }\n\n  for (let i = 0; i < editableLatestIndividualElements.length; i++) {\n    const latestElement = editableLatestIndividualElements[i];\n    if (!latestElement) {\n      continue;\n    }\n    const originalElement = editableOriginalIndividualElements[i];\n    const originalAngleInDegrees =\n      Math.round(radiansToDegrees(originalElement.angle) * 100) / 100;\n    const changeInDegrees = Math.round(accumulatedChange);\n    let nextAngleInDegrees = (originalAngleInDegrees + changeInDegrees) % 360;\n    if (shouldChangeByStepSize) {\n      nextAngleInDegrees = getStepSizedValue(nextAngleInDegrees, STEP_SIZE);\n    }\n\n    nextAngleInDegrees =\n      nextAngleInDegrees < 0 ? nextAngleInDegrees + 360 : nextAngleInDegrees;\n\n    const nextAngle = degreesToRadians(nextAngleInDegrees as Degrees);\n\n    scene.mutateElement(latestElement, {\n      angle: nextAngle,\n    });\n\n    const boundTextElement = getBoundTextElement(latestElement, elementsMap);\n    if (boundTextElement && !isArrowElement(latestElement)) {\n      scene.mutateElement(boundTextElement, { angle: nextAngle });\n    }\n  }\n  scene.triggerUpdate();\n};\n\nconst MultiAngle = ({\n  elements,\n  scene,\n  appState,\n  property,\n}: MultiAngleProps) => {\n  const editableLatestIndividualElements = elements.filter(\n    (el) => !isInGroup(el) && isPropertyEditable(el, \"angle\"),\n  );\n  const angles = editableLatestIndividualElements.map(\n    (el) => Math.round((radiansToDegrees(el.angle) % 360) * 100) / 100,\n  );\n  const value = new Set(angles).size === 1 ? angles[0] : \"Mixed\";\n\n  const editable = editableLatestIndividualElements.some((el) =>\n    isPropertyEditable(el, \"angle\"),\n  );\n\n  return (\n    <DragInput\n      label=\"A\"\n      icon={angleIcon}\n      value={value}\n      elements={elements}\n      dragInputCallback={handleDegreeChange}\n      editable={editable}\n      appState={appState}\n      scene={scene}\n      property={property}\n    />\n  );\n};\n\nexport default MultiAngle;\n",
    "import { pointFrom, type GlobalPoint } from \"@excalidraw/math\";\nimport { useMemo } from \"react\";\n\nimport { MIN_WIDTH_OR_HEIGHT } from \"@excalidraw/common\";\nimport {\n  getElementsInResizingFrame,\n  isFrameLikeElement,\n  replaceAllElementsInFrame,\n  updateBoundElements,\n} from \"@excalidraw/element\";\nimport {\n  rescalePointsInElement,\n  resizeSingleElement,\n} from \"@excalidraw/element\";\nimport { getBoundTextElement, handleBindTextResize } from \"@excalidraw/element\";\n\nimport { isTextElement } from \"@excalidraw/element\";\n\nimport { getCommonBounds } from \"@excalidraw/utils\";\n\nimport type {\n  ElementsMap,\n  ExcalidrawElement,\n  NonDeletedSceneElementsMap,\n} from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport DragInput from \"./DragInput\";\nimport { getAtomicUnits, getStepSizedValue, isPropertyEditable } from \"./utils\";\nimport { getElementsInAtomicUnit } from \"./utils\";\n\nimport type {\n  DragFinishedCallbackType,\n  DragInputCallbackType,\n} from \"./DragInput\";\nimport type { AtomicUnit } from \"./utils\";\nimport type { AppState } from \"../../types\";\n\ninterface MultiDimensionProps {\n  property: \"width\" | \"height\";\n  elements: readonly ExcalidrawElement[];\n  elementsMap: NonDeletedSceneElementsMap;\n  atomicUnits: AtomicUnit[];\n  scene: Scene;\n  appState: AppState;\n}\n\nconst STEP_SIZE = 10;\n\nconst getResizedUpdates = (\n  anchorX: number,\n  anchorY: number,\n  scale: number,\n  origElement: ExcalidrawElement,\n) => {\n  const offsetX = origElement.x - anchorX;\n  const offsetY = origElement.y - anchorY;\n  const nextWidth = origElement.width * scale;\n  const nextHeight = origElement.height * scale;\n  const x = anchorX + offsetX * scale;\n  const y = anchorY + offsetY * scale;\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x,\n    y,\n    ...rescalePointsInElement(origElement, nextWidth, nextHeight, false),\n    ...(isTextElement(origElement)\n      ? { fontSize: origElement.fontSize * scale }\n      : {}),\n  };\n};\n\nconst resizeElementInGroup = (\n  anchorX: number,\n  anchorY: number,\n  property: MultiDimensionProps[\"property\"],\n  scale: number,\n  latestElement: ExcalidrawElement,\n  origElement: ExcalidrawElement,\n  originalElementsMap: ElementsMap,\n  scene: Scene,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const updates = getResizedUpdates(anchorX, anchorY, scale, origElement);\n\n  scene.mutateElement(latestElement, updates);\n\n  const boundTextElement = getBoundTextElement(\n    origElement,\n    originalElementsMap,\n  );\n  if (boundTextElement) {\n    const newFontSize = boundTextElement.fontSize * scale;\n    updateBoundElements(latestElement, scene, {\n      newSize: { width: updates.width, height: updates.height },\n    });\n    const latestBoundTextElement = elementsMap.get(boundTextElement.id);\n    if (latestBoundTextElement && isTextElement(latestBoundTextElement)) {\n      scene.mutateElement(latestBoundTextElement, {\n        fontSize: newFontSize,\n      });\n      handleBindTextResize(\n        latestElement,\n        scene,\n        property === \"width\" ? \"e\" : \"s\",\n        true,\n      );\n    }\n  }\n};\n\nconst resizeGroup = (\n  nextWidth: number,\n  nextHeight: number,\n  initialHeight: number,\n  aspectRatio: number,\n  anchor: GlobalPoint,\n  property: MultiDimensionProps[\"property\"],\n  latestElements: ExcalidrawElement[],\n  originalElements: ExcalidrawElement[],\n  originalElementsMap: ElementsMap,\n  scene: Scene,\n) => {\n  // keep aspect ratio for groups\n  if (property === \"width\") {\n    nextHeight = Math.round((nextWidth / aspectRatio) * 100) / 100;\n  } else {\n    nextWidth = Math.round(nextHeight * aspectRatio * 100) / 100;\n  }\n\n  const scale = nextHeight / initialHeight;\n\n  for (let i = 0; i < originalElements.length; i++) {\n    const origElement = originalElements[i];\n    const latestElement = latestElements[i];\n\n    resizeElementInGroup(\n      anchor[0],\n      anchor[1],\n      property,\n      scale,\n      latestElement,\n      origElement,\n      originalElementsMap,\n      scene,\n    );\n  }\n};\n\nconst handleDimensionChange: DragInputCallbackType<\n  MultiDimensionProps[\"property\"]\n> = ({\n  accumulatedChange,\n  originalElements,\n  originalElementsMap,\n  originalAppState,\n  shouldChangeByStepSize,\n  nextValue,\n  scene,\n  property,\n  setAppState,\n  app,\n}) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const atomicUnits = getAtomicUnits(originalElements, originalAppState);\n  if (nextValue !== undefined) {\n    for (const atomicUnit of atomicUnits) {\n      const elementsInUnit = getElementsInAtomicUnit(\n        atomicUnit,\n        elementsMap,\n        originalElementsMap,\n      );\n\n      if (elementsInUnit.length > 1) {\n        const latestElements = elementsInUnit.map((el) => el.latest!);\n        const originalElements = elementsInUnit.map((el) => el.original!);\n        const [x1, y1, x2, y2] = getCommonBounds(originalElements);\n        const initialWidth = x2 - x1;\n        const initialHeight = y2 - y1;\n        const aspectRatio = initialWidth / initialHeight;\n        const nextWidth = Math.max(\n          MIN_WIDTH_OR_HEIGHT,\n          property === \"width\" ? Math.max(0, nextValue) : initialWidth,\n        );\n        const nextHeight = Math.max(\n          MIN_WIDTH_OR_HEIGHT,\n          property === \"height\" ? Math.max(0, nextValue) : initialHeight,\n        );\n\n        resizeGroup(\n          nextWidth,\n          nextHeight,\n          initialHeight,\n          aspectRatio,\n          pointFrom(x1, y1),\n          property,\n          latestElements,\n          originalElements,\n          originalElementsMap,\n          scene,\n        );\n      } else {\n        const [el] = elementsInUnit;\n        const latestElement = el?.latest;\n        const origElement = el?.original;\n\n        if (\n          latestElement &&\n          origElement &&\n          isPropertyEditable(latestElement, property)\n        ) {\n          let nextWidth =\n            property === \"width\" ? Math.max(0, nextValue) : latestElement.width;\n          if (property === \"width\") {\n            if (shouldChangeByStepSize) {\n              nextWidth = getStepSizedValue(nextWidth, STEP_SIZE);\n            } else {\n              nextWidth = Math.round(nextWidth);\n            }\n          }\n\n          let nextHeight =\n            property === \"height\"\n              ? Math.max(0, nextValue)\n              : latestElement.height;\n          if (property === \"height\") {\n            if (shouldChangeByStepSize) {\n              nextHeight = getStepSizedValue(nextHeight, STEP_SIZE);\n            } else {\n              nextHeight = Math.round(nextHeight);\n            }\n          }\n\n          nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);\n          nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);\n\n          resizeSingleElement(\n            nextWidth,\n            nextHeight,\n            latestElement,\n            origElement,\n            originalElementsMap,\n            scene,\n            property === \"width\" ? \"e\" : \"s\",\n            {\n              shouldInformMutation: false,\n            },\n          );\n\n          // Handle frame membership update for resized frames\n          if (isFrameLikeElement(latestElement)) {\n            const nextElementsInFrame = getElementsInResizingFrame(\n              scene.getElementsIncludingDeleted(),\n              latestElement,\n              originalAppState,\n              scene.getNonDeletedElementsMap(),\n            );\n\n            const updatedElements = replaceAllElementsInFrame(\n              scene.getElementsIncludingDeleted(),\n              nextElementsInFrame,\n              latestElement,\n              app,\n            );\n\n            scene.replaceAllElements(updatedElements);\n          }\n        }\n      }\n    }\n\n    scene.triggerUpdate();\n\n    return;\n  }\n\n  const changeInWidth = property === \"width\" ? accumulatedChange : 0;\n  const changeInHeight = property === \"height\" ? accumulatedChange : 0;\n  const elementsToHighlight: ExcalidrawElement[] = [];\n\n  for (const atomicUnit of atomicUnits) {\n    const elementsInUnit = getElementsInAtomicUnit(\n      atomicUnit,\n      elementsMap,\n      originalElementsMap,\n    );\n\n    if (elementsInUnit.length > 1) {\n      const latestElements = elementsInUnit.map((el) => el.latest!);\n      const originalElements = elementsInUnit.map((el) => el.original!);\n\n      const [x1, y1, x2, y2] = getCommonBounds(originalElements);\n      const initialWidth = x2 - x1;\n      const initialHeight = y2 - y1;\n      const aspectRatio = initialWidth / initialHeight;\n      let nextWidth = Math.max(0, initialWidth + changeInWidth);\n      if (property === \"width\") {\n        if (shouldChangeByStepSize) {\n          nextWidth = getStepSizedValue(nextWidth, STEP_SIZE);\n        } else {\n          nextWidth = Math.round(nextWidth);\n        }\n      }\n\n      let nextHeight = Math.max(0, initialHeight + changeInHeight);\n      if (property === \"height\") {\n        if (shouldChangeByStepSize) {\n          nextHeight = getStepSizedValue(nextHeight, STEP_SIZE);\n        } else {\n          nextHeight = Math.round(nextHeight);\n        }\n      }\n\n      nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);\n      nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);\n\n      resizeGroup(\n        nextWidth,\n        nextHeight,\n        initialHeight,\n        aspectRatio,\n        pointFrom(x1, y1),\n        property,\n        latestElements,\n        originalElements,\n        originalElementsMap,\n        scene,\n      );\n    } else {\n      const [el] = elementsInUnit;\n      const latestElement = el?.latest;\n      const origElement = el?.original;\n\n      if (\n        latestElement &&\n        origElement &&\n        isPropertyEditable(latestElement, property)\n      ) {\n        let nextWidth = Math.max(0, origElement.width + changeInWidth);\n        if (property === \"width\") {\n          if (shouldChangeByStepSize) {\n            nextWidth = getStepSizedValue(nextWidth, STEP_SIZE);\n          } else {\n            nextWidth = Math.round(nextWidth);\n          }\n        }\n\n        let nextHeight = Math.max(0, origElement.height + changeInHeight);\n        if (property === \"height\") {\n          if (shouldChangeByStepSize) {\n            nextHeight = getStepSizedValue(nextHeight, STEP_SIZE);\n          } else {\n            nextHeight = Math.round(nextHeight);\n          }\n        }\n\n        nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);\n        nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);\n\n        resizeSingleElement(\n          nextWidth,\n          nextHeight,\n          latestElement,\n          origElement,\n          originalElementsMap,\n          scene,\n          property === \"width\" ? \"e\" : \"s\",\n          {\n            shouldInformMutation: false,\n          },\n        );\n\n        // Handle highlighting frame element candidates\n        if (isFrameLikeElement(latestElement)) {\n          const nextElementsInFrame = getElementsInResizingFrame(\n            scene.getElementsIncludingDeleted(),\n            latestElement,\n            originalAppState,\n            scene.getNonDeletedElementsMap(),\n          );\n\n          elementsToHighlight.push(...nextElementsInFrame);\n        }\n      }\n    }\n  }\n\n  setAppState({\n    elementsToHighlight,\n  });\n\n  scene.triggerUpdate();\n};\n\nconst handleDragFinished: DragFinishedCallbackType = ({\n  setAppState,\n  app,\n  originalElements,\n  originalAppState,\n}) => {\n  const elementsMap = app.scene.getNonDeletedElementsMap();\n  const origElement = originalElements?.[0];\n  const latestElement = origElement && elementsMap.get(origElement.id);\n\n  // Handle frame membership update for resized frames\n  if (latestElement && isFrameLikeElement(latestElement)) {\n    const nextElementsInFrame = getElementsInResizingFrame(\n      app.scene.getElementsIncludingDeleted(),\n      latestElement,\n      originalAppState,\n      app.scene.getNonDeletedElementsMap(),\n    );\n\n    const updatedElements = replaceAllElementsInFrame(\n      app.scene.getElementsIncludingDeleted(),\n      nextElementsInFrame,\n      latestElement,\n      app,\n    );\n\n    app.scene.replaceAllElements(updatedElements);\n\n    setAppState({\n      elementsToHighlight: null,\n    });\n  }\n};\n\nconst MultiDimension = ({\n  property,\n  elements,\n  elementsMap,\n  atomicUnits,\n  scene,\n  appState,\n}: MultiDimensionProps) => {\n  const sizes = useMemo(\n    () =>\n      atomicUnits.map((atomicUnit) => {\n        const elementsInUnit = getElementsInAtomicUnit(atomicUnit, elementsMap);\n\n        if (elementsInUnit.length > 1) {\n          const [x1, y1, x2, y2] = getCommonBounds(\n            elementsInUnit.map((el) => el.latest),\n          );\n          return (\n            Math.round((property === \"width\" ? x2 - x1 : y2 - y1) * 100) / 100\n          );\n        }\n        const [el] = elementsInUnit;\n\n        return (\n          Math.round(\n            (property === \"width\" ? el.latest.width : el.latest.height) * 100,\n          ) / 100\n        );\n      }),\n    [elementsMap, atomicUnits, property],\n  );\n\n  const value =\n    new Set(sizes).size === 1 ? Math.round(sizes[0] * 100) / 100 : \"Mixed\";\n\n  const editable = sizes.length > 0;\n\n  return (\n    <DragInput\n      label={property === \"width\" ? \"W\" : \"H\"}\n      elements={elements}\n      dragInputCallback={handleDimensionChange}\n      value={value}\n      editable={editable}\n      appState={appState}\n      property={property}\n      scene={scene}\n      dragFinishedCallback={handleDragFinished}\n    />\n  );\n};\n\nexport default MultiDimension;\n",
    "export * from \"./export\";\nexport * from \"./withinBounds\";\nexport * from \"./bbox\";\nexport { getCommonBounds } from \"@excalidraw/element\";\n",
    "import {\n  getBoundTextElement,\n  redrawTextBoundingBox,\n} from \"@excalidraw/element\";\nimport { hasBoundTextElement, isTextElement } from \"@excalidraw/element\";\n\nimport { isInGroup } from \"@excalidraw/element\";\n\nimport type {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  NonDeletedSceneElementsMap,\n} from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport { fontSizeIcon } from \"../icons\";\n\nimport StatsDragInput from \"./DragInput\";\nimport { getStepSizedValue } from \"./utils\";\n\nimport type { DragInputCallbackType } from \"./DragInput\";\nimport type { AppState } from \"../../types\";\n\ninterface MultiFontSizeProps {\n  elements: readonly ExcalidrawElement[];\n  scene: Scene;\n  elementsMap: NonDeletedSceneElementsMap;\n  appState: AppState;\n  property: \"fontSize\";\n}\n\nconst MIN_FONT_SIZE = 4;\nconst STEP_SIZE = 4;\n\nconst getApplicableTextElements = (\n  elements: readonly (ExcalidrawElement | undefined)[],\n  elementsMap: NonDeletedSceneElementsMap,\n) =>\n  elements.reduce(\n    (acc: ExcalidrawTextElement[], el) => {\n      if (!el || isInGroup(el)) {\n        return acc;\n      }\n      if (isTextElement(el)) {\n        acc.push(el);\n        return acc;\n      }\n      if (hasBoundTextElement(el)) {\n        const boundTextElement = getBoundTextElement(el, elementsMap);\n        if (boundTextElement) {\n          acc.push(boundTextElement);\n          return acc;\n        }\n      }\n\n      return acc;\n    },\n\n    [],\n  );\n\nconst handleFontSizeChange: DragInputCallbackType<\n  MultiFontSizeProps[\"property\"],\n  ExcalidrawTextElement\n> = ({\n  accumulatedChange,\n  originalElements,\n  shouldChangeByStepSize,\n  nextValue,\n  scene,\n}) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const latestTextElements = originalElements.map((el) =>\n    elementsMap.get(el.id),\n  ) as ExcalidrawTextElement[];\n\n  let nextFontSize;\n\n  if (nextValue) {\n    nextFontSize = Math.max(Math.round(nextValue), MIN_FONT_SIZE);\n\n    for (const textElement of latestTextElements) {\n      scene.mutateElement(textElement, {\n        fontSize: nextFontSize,\n      });\n\n      redrawTextBoundingBox(\n        textElement,\n        scene.getContainerElement(textElement),\n        scene,\n      );\n    }\n\n    scene.triggerUpdate();\n  } else {\n    const originalTextElements = originalElements as ExcalidrawTextElement[];\n\n    for (let i = 0; i < latestTextElements.length; i++) {\n      const latestElement = latestTextElements[i];\n      const originalElement = originalTextElements[i];\n\n      const originalFontSize = Math.round(originalElement.fontSize);\n      const changeInFontSize = Math.round(accumulatedChange);\n      let nextFontSize = Math.max(\n        originalFontSize + changeInFontSize,\n        MIN_FONT_SIZE,\n      );\n      if (shouldChangeByStepSize) {\n        nextFontSize = getStepSizedValue(nextFontSize, STEP_SIZE);\n      }\n      scene.mutateElement(latestElement, {\n        fontSize: nextFontSize,\n      });\n\n      redrawTextBoundingBox(\n        latestElement,\n        scene.getContainerElement(latestElement),\n        scene,\n      );\n    }\n\n    scene.triggerUpdate();\n  }\n};\n\nconst MultiFontSize = ({\n  elements,\n  scene,\n  appState,\n  property,\n  elementsMap,\n}: MultiFontSizeProps) => {\n  const latestTextElements = getApplicableTextElements(elements, elementsMap);\n\n  if (!latestTextElements.length) {\n    return null;\n  }\n\n  const fontSizes = latestTextElements.map(\n    (textEl) => Math.round(textEl.fontSize * 10) / 10,\n  );\n  const value = new Set(fontSizes).size === 1 ? fontSizes[0] : \"Mixed\";\n  const editable = fontSizes.length > 0;\n\n  return (\n    <StatsDragInput\n      label=\"F\"\n      icon={fontSizeIcon}\n      elements={latestTextElements}\n      dragInputCallback={handleFontSizeChange}\n      value={value}\n      editable={editable}\n      scene={scene}\n      property={property}\n      appState={appState}\n    />\n  );\n};\n\nexport default MultiFontSize;\n",
    "import { pointFrom, pointRotateRads } from \"@excalidraw/math\";\nimport { useMemo } from \"react\";\n\nimport { isTextElement } from \"@excalidraw/element\";\n\nimport { getCommonBounds } from \"@excalidraw/element\";\n\nimport type { ElementsMap, ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport StatsDragInput from \"./DragInput\";\nimport {\n  getAtomicUnits,\n  getStepSizedValue,\n  isPropertyEditable,\n  STEP_SIZE,\n} from \"./utils\";\nimport { getElementsInAtomicUnit, moveElement } from \"./utils\";\n\nimport type { DragInputCallbackType } from \"./DragInput\";\nimport type { AtomicUnit } from \"./utils\";\nimport type { AppState } from \"../../types\";\n\ninterface MultiPositionProps {\n  property: \"x\" | \"y\";\n  elements: readonly ExcalidrawElement[];\n  elementsMap: ElementsMap;\n  atomicUnits: AtomicUnit[];\n  scene: Scene;\n  appState: AppState;\n}\n\nconst moveElements = (\n  property: MultiPositionProps[\"property\"],\n  changeInTopX: number,\n  changeInTopY: number,\n  originalElements: readonly ExcalidrawElement[],\n  originalElementsMap: ElementsMap,\n  scene: Scene,\n) => {\n  for (let i = 0; i < originalElements.length; i++) {\n    const origElement = originalElements[i];\n\n    const [cx, cy] = [\n      origElement.x + origElement.width / 2,\n      origElement.y + origElement.height / 2,\n    ];\n    const [topLeftX, topLeftY] = pointRotateRads(\n      pointFrom(origElement.x, origElement.y),\n      pointFrom(cx, cy),\n      origElement.angle,\n    );\n\n    const newTopLeftX =\n      property === \"x\" ? Math.round(topLeftX + changeInTopX) : topLeftX;\n\n    const newTopLeftY =\n      property === \"y\" ? Math.round(topLeftY + changeInTopY) : topLeftY;\n\n    moveElement(\n      newTopLeftX,\n      newTopLeftY,\n      origElement,\n      scene,\n      originalElementsMap,\n      false,\n    );\n  }\n};\n\nconst moveGroupTo = (\n  nextX: number,\n  nextY: number,\n  originalElements: ExcalidrawElement[],\n  originalElementsMap: ElementsMap,\n  scene: Scene,\n) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const [x1, y1, ,] = getCommonBounds(originalElements);\n  const offsetX = nextX - x1;\n  const offsetY = nextY - y1;\n\n  for (let i = 0; i < originalElements.length; i++) {\n    const origElement = originalElements[i];\n\n    const latestElement = elementsMap.get(origElement.id);\n    if (!latestElement) {\n      continue;\n    }\n\n    // bound texts are moved with their containers\n    if (!isTextElement(latestElement) || !latestElement.containerId) {\n      const [cx, cy] = [\n        latestElement.x + latestElement.width / 2,\n        latestElement.y + latestElement.height / 2,\n      ];\n\n      const [topLeftX, topLeftY] = pointRotateRads(\n        pointFrom(latestElement.x, latestElement.y),\n        pointFrom(cx, cy),\n        latestElement.angle,\n      );\n\n      moveElement(\n        topLeftX + offsetX,\n        topLeftY + offsetY,\n        origElement,\n        scene,\n        originalElementsMap,\n        false,\n      );\n    }\n  }\n};\n\nconst handlePositionChange: DragInputCallbackType<\n  MultiPositionProps[\"property\"]\n> = ({\n  accumulatedChange,\n  originalElements,\n  originalElementsMap,\n  shouldChangeByStepSize,\n  nextValue,\n  property,\n  scene,\n  originalAppState,\n}) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n\n  if (nextValue !== undefined) {\n    for (const atomicUnit of getAtomicUnits(\n      originalElements,\n      originalAppState,\n    )) {\n      const elementsInUnit = getElementsInAtomicUnit(\n        atomicUnit,\n        elementsMap,\n        originalElementsMap,\n      );\n\n      if (elementsInUnit.length > 1) {\n        const [x1, y1, ,] = getCommonBounds(\n          elementsInUnit.map((el) => el.latest!),\n        );\n        const newTopLeftX = property === \"x\" ? nextValue : x1;\n        const newTopLeftY = property === \"y\" ? nextValue : y1;\n\n        moveGroupTo(\n          newTopLeftX,\n          newTopLeftY,\n          elementsInUnit.map((el) => el.original),\n          originalElementsMap,\n          scene,\n        );\n      } else {\n        const origElement = elementsInUnit[0]?.original;\n        const latestElement = elementsInUnit[0]?.latest;\n        if (\n          origElement &&\n          latestElement &&\n          isPropertyEditable(latestElement, property)\n        ) {\n          const [cx, cy] = [\n            origElement.x + origElement.width / 2,\n            origElement.y + origElement.height / 2,\n          ];\n          const [topLeftX, topLeftY] = pointRotateRads(\n            pointFrom(origElement.x, origElement.y),\n            pointFrom(cx, cy),\n            origElement.angle,\n          );\n\n          const newTopLeftX = property === \"x\" ? nextValue : topLeftX;\n          const newTopLeftY = property === \"y\" ? nextValue : topLeftY;\n          moveElement(\n            newTopLeftX,\n            newTopLeftY,\n            origElement,\n            scene,\n            originalElementsMap,\n            false,\n          );\n        }\n      }\n    }\n\n    scene.triggerUpdate();\n    return;\n  }\n\n  const change = shouldChangeByStepSize\n    ? getStepSizedValue(accumulatedChange, STEP_SIZE)\n    : accumulatedChange;\n\n  const changeInTopX = property === \"x\" ? change : 0;\n  const changeInTopY = property === \"y\" ? change : 0;\n\n  moveElements(\n    property,\n    changeInTopX,\n    changeInTopY,\n    originalElements,\n    originalElementsMap,\n    scene,\n  );\n\n  scene.triggerUpdate();\n};\n\nconst MultiPosition = ({\n  property,\n  elements,\n  elementsMap,\n  atomicUnits,\n  scene,\n  appState,\n}: MultiPositionProps) => {\n  const positions = useMemo(\n    () =>\n      atomicUnits.map((atomicUnit) => {\n        const elementsInUnit = Object.keys(atomicUnit)\n          .map((id) => elementsMap.get(id))\n          .filter((el) => el !== undefined) as ExcalidrawElement[];\n\n        // we're dealing with a group\n        if (elementsInUnit.length > 1) {\n          const [x1, y1] = getCommonBounds(elementsInUnit);\n          return Math.round((property === \"x\" ? x1 : y1) * 100) / 100;\n        }\n\n        const [el] = elementsInUnit;\n        const [cx, cy] = [el.x + el.width / 2, el.y + el.height / 2];\n\n        const [topLeftX, topLeftY] = pointRotateRads(\n          pointFrom(el.x, el.y),\n          pointFrom(cx, cy),\n          el.angle,\n        );\n\n        return Math.round((property === \"x\" ? topLeftX : topLeftY) * 100) / 100;\n      }),\n    [atomicUnits, elementsMap, property],\n  );\n\n  const value = new Set(positions).size === 1 ? positions[0] : \"Mixed\";\n\n  return (\n    <StatsDragInput\n      label={property === \"x\" ? \"X\" : \"Y\"}\n      elements={elements}\n      dragInputCallback={handlePositionChange}\n      value={value}\n      property={property}\n      scene={scene}\n      appState={appState}\n    />\n  );\n};\n\nexport default MultiPosition;\n",
    "import { clamp, pointFrom, pointRotateRads, round } from \"@excalidraw/math\";\n\nimport {\n  getFlipAdjustedCropPosition,\n  getUncroppedWidthAndHeight,\n} from \"@excalidraw/element\";\nimport { isImageElement } from \"@excalidraw/element\";\n\nimport type { ElementsMap, ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport StatsDragInput from \"./DragInput\";\nimport { getStepSizedValue, moveElement, STEP_SIZE } from \"./utils\";\n\nimport type { DragInputCallbackType } from \"./DragInput\";\nimport type { AppState } from \"../../types\";\n\ninterface PositionProps {\n  property: \"x\" | \"y\";\n  element: ExcalidrawElement;\n  elementsMap: ElementsMap;\n  scene: Scene;\n  appState: AppState;\n}\n\nconst handlePositionChange: DragInputCallbackType<\"x\" | \"y\"> = ({\n  accumulatedChange,\n  instantChange,\n  originalElements,\n  originalElementsMap,\n  shouldChangeByStepSize,\n  nextValue,\n  property,\n  scene,\n  originalAppState,\n}) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const origElement = originalElements[0];\n  const [cx, cy] = [\n    origElement.x + origElement.width / 2,\n    origElement.y + origElement.height / 2,\n  ];\n  const [topLeftX, topLeftY] = pointRotateRads(\n    pointFrom(origElement.x, origElement.y),\n    pointFrom(cx, cy),\n    origElement.angle,\n  );\n\n  if (originalAppState.croppingElementId === origElement.id) {\n    const element = elementsMap.get(origElement.id);\n\n    if (!element || !isImageElement(element) || !element.crop) {\n      return;\n    }\n\n    const crop = element.crop;\n    let nextCrop = crop;\n    const isFlippedByX = element.scale[0] === -1;\n    const isFlippedByY = element.scale[1] === -1;\n    const { width: uncroppedWidth, height: uncroppedHeight } =\n      getUncroppedWidthAndHeight(element);\n\n    if (nextValue !== undefined) {\n      if (property === \"x\") {\n        const nextValueInNatural =\n          nextValue * (crop.naturalWidth / uncroppedWidth);\n\n        if (isFlippedByX) {\n          nextCrop = {\n            ...crop,\n            x: clamp(\n              crop.naturalWidth - nextValueInNatural - crop.width,\n              0,\n              crop.naturalWidth - crop.width,\n            ),\n          };\n        } else {\n          nextCrop = {\n            ...crop,\n            x: clamp(\n              nextValue * (crop.naturalWidth / uncroppedWidth),\n              0,\n              crop.naturalWidth - crop.width,\n            ),\n          };\n        }\n      }\n\n      if (property === \"y\") {\n        nextCrop = {\n          ...crop,\n          y: clamp(\n            nextValue * (crop.naturalHeight / uncroppedHeight),\n            0,\n            crop.naturalHeight - crop.height,\n          ),\n        };\n      }\n\n      scene.mutateElement(element, {\n        crop: nextCrop,\n      });\n\n      return;\n    }\n\n    const changeInX =\n      (property === \"x\" ? instantChange : 0) * (isFlippedByX ? -1 : 1);\n    const changeInY =\n      (property === \"y\" ? instantChange : 0) * (isFlippedByY ? -1 : 1);\n\n    nextCrop = {\n      ...crop,\n      x: clamp(crop.x + changeInX, 0, crop.naturalWidth - crop.width),\n      y: clamp(crop.y + changeInY, 0, crop.naturalHeight - crop.height),\n    };\n\n    scene.mutateElement(element, {\n      crop: nextCrop,\n    });\n\n    return;\n  }\n\n  if (nextValue !== undefined) {\n    const newTopLeftX = property === \"x\" ? nextValue : topLeftX;\n    const newTopLeftY = property === \"y\" ? nextValue : topLeftY;\n    moveElement(\n      newTopLeftX,\n      newTopLeftY,\n      origElement,\n      scene,\n      originalElementsMap,\n    );\n    return;\n  }\n\n  const changeInTopX = property === \"x\" ? accumulatedChange : 0;\n  const changeInTopY = property === \"y\" ? accumulatedChange : 0;\n\n  const newTopLeftX =\n    property === \"x\"\n      ? Math.round(\n          shouldChangeByStepSize\n            ? getStepSizedValue(origElement.x + changeInTopX, STEP_SIZE)\n            : topLeftX + changeInTopX,\n        )\n      : topLeftX;\n\n  const newTopLeftY =\n    property === \"y\"\n      ? Math.round(\n          shouldChangeByStepSize\n            ? getStepSizedValue(origElement.y + changeInTopY, STEP_SIZE)\n            : topLeftY + changeInTopY,\n        )\n      : topLeftY;\n\n  moveElement(\n    newTopLeftX,\n    newTopLeftY,\n    origElement,\n    scene,\n    originalElementsMap,\n  );\n};\n\nconst Position = ({\n  property,\n  element,\n  elementsMap,\n  scene,\n  appState,\n}: PositionProps) => {\n  const [topLeftX, topLeftY] = pointRotateRads(\n    pointFrom(element.x, element.y),\n    pointFrom(element.x + element.width / 2, element.y + element.height / 2),\n    element.angle,\n  );\n  let value = round(property === \"x\" ? topLeftX : topLeftY, 2);\n\n  if (\n    appState.croppingElementId === element.id &&\n    isImageElement(element) &&\n    element.crop\n  ) {\n    const flipAdjustedPosition = getFlipAdjustedCropPosition(element);\n\n    if (flipAdjustedPosition) {\n      value = round(\n        property === \"x\" ? flipAdjustedPosition.x : flipAdjustedPosition.y,\n        2,\n      );\n    }\n  }\n\n  return (\n    <StatsDragInput\n      label={property === \"x\" ? \"X\" : \"Y\"}\n      elements={[element]}\n      dragInputCallback={handlePositionChange}\n      scene={scene}\n      value={value}\n      property={property}\n      appState={appState}\n    />\n  );\n};\n\nexport default Position;\n",
    "import { useCallback, useEffect, useState } from \"react\";\n\nimport { normalizeLink, KEYS } from \"@excalidraw/common\";\n\nimport {\n  defaultGetElementLinkFromSelection,\n  getLinkIdAndTypeFromSelection,\n} from \"@excalidraw/element\";\n\nimport type { ExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { Scene } from \"@excalidraw/element\";\n\nimport { t } from \"../i18n\";\nimport { getSelectedElements } from \"../scene\";\n\nimport DialogActionButton from \"./DialogActionButton\";\nimport { TextField } from \"./TextField\";\nimport { ToolButton } from \"./ToolButton\";\nimport { TrashIcon } from \"./icons\";\n\nimport \"./ElementLinkDialog.scss\";\n\nimport type { AppProps, AppState, UIAppState } from \"../types\";\nconst ElementLinkDialog = ({\n  sourceElementId,\n  onClose,\n  appState,\n  scene,\n  generateLinkForSelection = defaultGetElementLinkFromSelection,\n}: {\n  sourceElementId: ExcalidrawElement[\"id\"];\n  appState: UIAppState;\n  scene: Scene;\n  onClose?: () => void;\n  generateLinkForSelection: AppProps[\"generateLinkForSelection\"];\n}) => {\n  const elementsMap = scene.getNonDeletedElementsMap();\n  const originalLink = elementsMap.get(sourceElementId)?.link ?? null;\n\n  const [nextLink, setNextLink] = useState<string | null>(originalLink);\n  const [linkEdited, setLinkEdited] = useState(false);\n\n  useEffect(() => {\n    const selectedElements = getSelectedElements(elementsMap, appState);\n    let nextLink = originalLink;\n\n    if (selectedElements.length > 0 && generateLinkForSelection) {\n      const idAndType = getLinkIdAndTypeFromSelection(\n        selectedElements,\n        appState as AppState,\n      );\n\n      if (idAndType) {\n        nextLink = normalizeLink(\n          generateLinkForSelection(idAndType.id, idAndType.type),\n        );\n      }\n    }\n\n    setNextLink(nextLink);\n  }, [\n    elementsMap,\n    appState,\n    appState.selectedElementIds,\n    originalLink,\n    generateLinkForSelection,\n  ]);\n\n  const handleConfirm = useCallback(() => {\n    if (nextLink && nextLink !== elementsMap.get(sourceElementId)?.link) {\n      const elementToLink = elementsMap.get(sourceElementId);\n      elementToLink &&\n        scene.mutateElement(elementToLink, {\n          link: nextLink,\n        });\n    }\n\n    if (!nextLink && linkEdited && sourceElementId) {\n      const elementToLink = elementsMap.get(sourceElementId);\n      elementToLink &&\n        scene.mutateElement(elementToLink, {\n          link: null,\n        });\n    }\n\n    onClose?.();\n  }, [sourceElementId, nextLink, elementsMap, linkEdited, scene, onClose]);\n\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (\n        appState.openDialog?.name === \"elementLinkSelector\" &&\n        event.key === KEYS.ENTER\n      ) {\n        handleConfirm();\n      }\n\n      if (\n        appState.openDialog?.name === \"elementLinkSelector\" &&\n        event.key === KEYS.ESCAPE\n      ) {\n        onClose?.();\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => {\n      window.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, [appState, onClose, handleConfirm]);\n\n  return (\n    <div className=\"ElementLinkDialog\">\n      <div className=\"ElementLinkDialog__header\">\n        <h2>{t(\"elementLink.title\")}</h2>\n        <p>{t(\"elementLink.desc\")}</p>\n      </div>\n\n      <div className=\"ElementLinkDialog__input\">\n        <TextField\n          value={nextLink ?? \"\"}\n          onChange={(value) => {\n            if (!linkEdited) {\n              setLinkEdited(true);\n            }\n            setNextLink(value);\n          }}\n          onKeyDown={(event) => {\n            if (event.key === KEYS.ENTER) {\n              handleConfirm();\n            }\n          }}\n          className=\"ElementLinkDialog__input-field\"\n          selectOnRender\n        />\n\n        {originalLink && nextLink && (\n          <ToolButton\n            type=\"button\"\n            title={t(\"buttons.remove\")}\n            aria-label={t(\"buttons.remove\")}\n            label={t(\"buttons.remove\")}\n            onClick={() => {\n              // removes the link from the input\n              // but doesn't update the element\n\n              // when confirmed, will remove the link from the element\n              setNextLink(null);\n              setLinkEdited(true);\n            }}\n            className=\"ElementLinkDialog__remove\"\n            icon={TrashIcon}\n          />\n        )}\n      </div>\n\n      <div className=\"ElementLinkDialog__actions\">\n        <DialogActionButton\n          label={t(\"buttons.cancel\")}\n          onClick={() => {\n            onClose?.();\n          }}\n          style={{\n            marginRight: 10,\n          }}\n        />\n\n        <DialogActionButton\n          label={t(\"buttons.confirm\")}\n          onClick={handleConfirm}\n          actionType=\"primary\"\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default ElementLinkDialog;\n",
    "import React, { useState } from \"react\";\n\nimport { t } from \"../i18n\";\n\nimport { useExcalidrawContainer } from \"./App\";\nimport { Dialog } from \"./Dialog\";\n\nexport const ErrorDialog = ({\n  children,\n  onClose,\n}: {\n  children?: React.ReactNode;\n  onClose?: () => void;\n}) => {\n  const [modalIsShown, setModalIsShown] = useState(!!children);\n  const { container: excalidrawContainer } = useExcalidrawContainer();\n\n  const handleClose = React.useCallback(() => {\n    setModalIsShown(false);\n\n    if (onClose) {\n      onClose();\n    }\n    // TODO: Fix the A11y issues so this is never needed since we should always focus on last active element\n    excalidrawContainer?.focus();\n  }, [onClose, excalidrawContainer]);\n\n  return (\n    <>\n      {modalIsShown && (\n        <Dialog\n          size=\"small\"\n          onCloseRequest={handleClose}\n          title={t(\"errorDialog.title\")}\n        >\n          <div style={{ whiteSpace: \"pre-wrap\" }}>{children}</div>\n        </Dialog>\n      )}\n    </>\n  );\n};\n",
    "import React from \"react\";\n\nimport { isDarwin, isFirefox, isWindows } from \"@excalidraw/common\";\n\nimport { KEYS, getShortcutKey } from \"@excalidraw/common\";\n\nimport { getShortcutFromShortcutName } from \"../actions/shortcuts\";\nimport { probablySupportsClipboardBlob } from \"../clipboard\";\nimport { t } from \"../i18n\";\n\nimport { Dialog } from \"./Dialog\";\nimport { ExternalLinkIcon, GithubIcon, youtubeIcon } from \"./icons\";\n\nimport \"./HelpDialog.scss\";\n\nimport type { JSX } from \"react\";\n\nconst Header = () => (\n  <div className=\"HelpDialog__header\">\n    <a\n      className=\"HelpDialog__btn\"\n      href=\"https://docs.excalidraw.com\"\n      target=\"_blank\"\n      rel=\"noopener\"\n    >\n      <div className=\"HelpDialog__link-icon\">{ExternalLinkIcon}</div>\n      {t(\"helpDialog.documentation\")}\n    </a>\n    <a\n      className=\"HelpDialog__btn\"\n      href=\"https://plus.excalidraw.com/blog\"\n      target=\"_blank\"\n      rel=\"noopener\"\n    >\n      <div className=\"HelpDialog__link-icon\">{ExternalLinkIcon}</div>\n      {t(\"helpDialog.blog\")}\n    </a>\n    <a\n      className=\"HelpDialog__btn\"\n      href=\"https://github.com/excalidraw/excalidraw/issues\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      <div className=\"HelpDialog__link-icon\">{GithubIcon}</div>\n      {t(\"helpDialog.github\")}\n    </a>\n    <a\n      className=\"HelpDialog__btn\"\n      href=\"https://youtube.com/@excalidraw\"\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n    >\n      <div className=\"HelpDialog__link-icon\">{youtubeIcon}</div>\n      YouTube\n    </a>\n  </div>\n);\n\nconst Section = (props: { title: string; children: React.ReactNode }) => (\n  <>\n    <h3>{props.title}</h3>\n    <div className=\"HelpDialog__islands-container\">{props.children}</div>\n  </>\n);\n\nconst ShortcutIsland = (props: {\n  caption: string;\n  children: React.ReactNode;\n  className?: string;\n}) => (\n  <div className={`HelpDialog__island ${props.className}`}>\n    <h4 className=\"HelpDialog__island-title\">{props.caption}</h4>\n    <div className=\"HelpDialog__island-content\">{props.children}</div>\n  </div>\n);\n\nfunction* intersperse(as: JSX.Element[][], delim: string | null) {\n  let first = true;\n  for (const x of as) {\n    if (!first) {\n      yield delim;\n    }\n    first = false;\n    yield x;\n  }\n}\n\nconst upperCaseSingleChars = (str: string) => {\n  return str.replace(/\\b[a-z]\\b/, (c) => c.toUpperCase());\n};\n\nconst Shortcut = ({\n  label,\n  shortcuts,\n  isOr = true,\n}: {\n  label: string;\n  shortcuts: string[];\n  isOr?: boolean;\n}) => {\n  const splitShortcutKeys = shortcuts.map((shortcut) => {\n    const keys = shortcut.endsWith(\"++\")\n      ? [...shortcut.slice(0, -2).split(\"+\"), \"+\"]\n      : shortcut.split(\"+\");\n\n    return keys.map((key) => (\n      <ShortcutKey key={key}>{upperCaseSingleChars(key)}</ShortcutKey>\n    ));\n  });\n\n  return (\n    <div className=\"HelpDialog__shortcut\">\n      <div>{label}</div>\n      <div className=\"HelpDialog__key-container\">\n        {[...intersperse(splitShortcutKeys, isOr ? t(\"helpDialog.or\") : null)]}\n      </div>\n    </div>\n  );\n};\n\nconst ShortcutKey = (props: { children: React.ReactNode }) => (\n  <kbd className=\"HelpDialog__key\" {...props} />\n);\n\nexport const HelpDialog = ({ onClose }: { onClose?: () => void }) => {\n  const handleClose = React.useCallback(() => {\n    if (onClose) {\n      onClose();\n    }\n  }, [onClose]);\n\n  return (\n    <>\n      <Dialog\n        onCloseRequest={handleClose}\n        title={t(\"helpDialog.title\")}\n        className={\"HelpDialog\"}\n      >\n        <Header />\n        <Section title={t(\"helpDialog.shortcuts\")}>\n          <ShortcutIsland\n            className=\"HelpDialog__island--tools\"\n            caption={t(\"helpDialog.tools\")}\n          >\n            <Shortcut label={t(\"toolBar.hand\")} shortcuts={[KEYS.H]} />\n            <Shortcut\n              label={t(\"toolBar.selection\")}\n              shortcuts={[KEYS.V, KEYS[\"1\"]]}\n            />\n            <Shortcut\n              label={t(\"toolBar.rectangle\")}\n              shortcuts={[KEYS.R, KEYS[\"2\"]]}\n            />\n            <Shortcut\n              label={t(\"toolBar.diamond\")}\n              shortcuts={[KEYS.D, KEYS[\"3\"]]}\n            />\n            <Shortcut\n              label={t(\"toolBar.ellipse\")}\n              shortcuts={[KEYS.O, KEYS[\"4\"]]}\n            />\n            <Shortcut\n              label={t(\"toolBar.arrow\")}\n              shortcuts={[KEYS.A, KEYS[\"5\"]]}\n            />\n            <Shortcut\n              label={t(\"toolBar.line\")}\n              shortcuts={[KEYS.L, KEYS[\"6\"]]}\n            />\n            <Shortcut\n              label={t(\"toolBar.freedraw\")}\n              shortcuts={[KEYS.P, KEYS[\"7\"]]}\n            />\n            <Shortcut\n              label={t(\"toolBar.text\")}\n              shortcuts={[KEYS.T, KEYS[\"8\"]]}\n            />\n            <Shortcut label={t(\"toolBar.image\")} shortcuts={[KEYS[\"9\"]]} />\n            <Shortcut\n              label={t(\"toolBar.eraser\")}\n              shortcuts={[KEYS.E, KEYS[\"0\"]]}\n            />\n            <Shortcut label={t(\"toolBar.frame\")} shortcuts={[KEYS.F]} />\n            <Shortcut label={t(\"toolBar.laser\")} shortcuts={[KEYS.K]} />\n            <Shortcut\n              label={t(\"labels.eyeDropper\")}\n              shortcuts={[KEYS.I, \"Shift+S\", \"Shift+G\"]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.editLineArrowPoints\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Enter\")]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.editText\")}\n              shortcuts={[getShortcutKey(\"Enter\")]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.textNewLine\")}\n              shortcuts={[\n                getShortcutKey(\"Enter\"),\n                getShortcutKey(\"Shift+Enter\"),\n              ]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.textFinish\")}\n              shortcuts={[\n                getShortcutKey(\"Esc\"),\n                getShortcutKey(\"CtrlOrCmd+Enter\"),\n              ]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.curvedArrow\")}\n              shortcuts={[\n                \"A\",\n                t(\"helpDialog.click\"),\n                t(\"helpDialog.click\"),\n                t(\"helpDialog.click\"),\n              ]}\n              isOr={false}\n            />\n            <Shortcut\n              label={t(\"helpDialog.curvedLine\")}\n              shortcuts={[\n                \"L\",\n                t(\"helpDialog.click\"),\n                t(\"helpDialog.click\"),\n                t(\"helpDialog.click\"),\n              ]}\n              isOr={false}\n            />\n            <Shortcut\n              label={t(\"helpDialog.cropStart\")}\n              shortcuts={[t(\"helpDialog.doubleClick\"), getShortcutKey(\"Enter\")]}\n              isOr={true}\n            />\n            <Shortcut\n              label={t(\"helpDialog.cropFinish\")}\n              shortcuts={[getShortcutKey(\"Enter\"), getShortcutKey(\"Escape\")]}\n              isOr={true}\n            />\n            <Shortcut label={t(\"toolBar.lock\")} shortcuts={[KEYS.Q]} />\n            <Shortcut\n              label={t(\"helpDialog.preventBinding\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd\")]}\n            />\n            <Shortcut\n              label={t(\"toolBar.link\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+K\")]}\n            />\n            <Shortcut\n              label={t(\"toolBar.convertElementType\")}\n              shortcuts={[\"Tab\", \"Shift+Tab\"]}\n              isOr={true}\n            />\n          </ShortcutIsland>\n          <ShortcutIsland\n            className=\"HelpDialog__island--view\"\n            caption={t(\"helpDialog.view\")}\n          >\n            <Shortcut\n              label={t(\"buttons.zoomIn\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd++\")]}\n            />\n            <Shortcut\n              label={t(\"buttons.zoomOut\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+-\")]}\n            />\n            <Shortcut\n              label={t(\"buttons.resetZoom\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+0\")]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.zoomToFit\")}\n              shortcuts={[\"Shift+1\"]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.zoomToSelection\")}\n              shortcuts={[\"Shift+2\"]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.movePageUpDown\")}\n              shortcuts={[\"PgUp/PgDn\"]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.movePageLeftRight\")}\n              shortcuts={[\"Shift+PgUp/PgDn\"]}\n            />\n            <Shortcut\n              label={t(\"buttons.zenMode\")}\n              shortcuts={[getShortcutKey(\"Alt+Z\")]}\n            />\n            <Shortcut\n              label={t(\"buttons.objectsSnapMode\")}\n              shortcuts={[getShortcutKey(\"Alt+S\")]}\n            />\n            <Shortcut\n              label={t(\"labels.toggleGrid\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+'\")]}\n            />\n            <Shortcut\n              label={t(\"labels.viewMode\")}\n              shortcuts={[getShortcutKey(\"Alt+R\")]}\n            />\n            <Shortcut\n              label={t(\"labels.toggleTheme\")}\n              shortcuts={[getShortcutKey(\"Alt+Shift+D\")]}\n            />\n            <Shortcut\n              label={t(\"stats.fullTitle\")}\n              shortcuts={[getShortcutKey(\"Alt+/\")]}\n            />\n            <Shortcut\n              label={t(\"search.title\")}\n              shortcuts={[getShortcutFromShortcutName(\"searchMenu\")]}\n            />\n            <Shortcut\n              label={t(\"commandPalette.title\")}\n              shortcuts={\n                isFirefox\n                  ? [getShortcutFromShortcutName(\"commandPalette\")]\n                  : [\n                      getShortcutFromShortcutName(\"commandPalette\"),\n                      getShortcutFromShortcutName(\"commandPalette\", 1),\n                    ]\n              }\n            />\n          </ShortcutIsland>\n          <ShortcutIsland\n            className=\"HelpDialog__island--editor\"\n            caption={t(\"helpDialog.editor\")}\n          >\n            <Shortcut\n              label={t(\"helpDialog.createFlowchart\")}\n              shortcuts={[getShortcutKey(`CtrlOrCmd+Arrow Key`)]}\n              isOr={true}\n            />\n            <Shortcut\n              label={t(\"helpDialog.navigateFlowchart\")}\n              shortcuts={[getShortcutKey(`Alt+Arrow Key`)]}\n              isOr={true}\n            />\n            <Shortcut\n              label={t(\"labels.moveCanvas\")}\n              shortcuts={[\n                getShortcutKey(`Space+${t(\"helpDialog.drag\")}`),\n                getShortcutKey(`Wheel+${t(\"helpDialog.drag\")}`),\n              ]}\n              isOr={true}\n            />\n            <Shortcut\n              label={t(\"buttons.clearReset\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Delete\")]}\n            />\n            <Shortcut\n              label={t(\"labels.delete\")}\n              shortcuts={[getShortcutKey(\"Delete\")]}\n            />\n            <Shortcut\n              label={t(\"labels.cut\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+X\")]}\n            />\n            <Shortcut\n              label={t(\"labels.copy\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+C\")]}\n            />\n            <Shortcut\n              label={t(\"labels.paste\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+V\")]}\n            />\n            <Shortcut\n              label={t(\"labels.pasteAsPlaintext\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+V\")]}\n            />\n            <Shortcut\n              label={t(\"labels.selectAll\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+A\")]}\n            />\n            <Shortcut\n              label={t(\"labels.multiSelect\")}\n              shortcuts={[getShortcutKey(`Shift+${t(\"helpDialog.click\")}`)]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.deepSelect\")}\n              shortcuts={[getShortcutKey(`CtrlOrCmd+${t(\"helpDialog.click\")}`)]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.deepBoxSelect\")}\n              shortcuts={[getShortcutKey(`CtrlOrCmd+${t(\"helpDialog.drag\")}`)]}\n            />\n            {/* firefox supports clipboard API under a flag, so we'll\n                show users what they can do in the error message */}\n            {(probablySupportsClipboardBlob || isFirefox) && (\n              <Shortcut\n                label={t(\"labels.copyAsPng\")}\n                shortcuts={[getShortcutKey(\"Shift+Alt+C\")]}\n              />\n            )}\n            <Shortcut\n              label={t(\"labels.copyStyles\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Alt+C\")]}\n            />\n            <Shortcut\n              label={t(\"labels.pasteStyles\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Alt+V\")]}\n            />\n            <Shortcut\n              label={t(\"labels.sendToBack\")}\n              shortcuts={[\n                isDarwin\n                  ? getShortcutKey(\"CtrlOrCmd+Alt+[\")\n                  : getShortcutKey(\"CtrlOrCmd+Shift+[\"),\n              ]}\n            />\n            <Shortcut\n              label={t(\"labels.bringToFront\")}\n              shortcuts={[\n                isDarwin\n                  ? getShortcutKey(\"CtrlOrCmd+Alt+]\")\n                  : getShortcutKey(\"CtrlOrCmd+Shift+]\"),\n              ]}\n            />\n            <Shortcut\n              label={t(\"labels.sendBackward\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+[\")]}\n            />\n            <Shortcut\n              label={t(\"labels.bringForward\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+]\")]}\n            />\n            <Shortcut\n              label={t(\"labels.alignTop\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Up\")]}\n            />\n            <Shortcut\n              label={t(\"labels.alignBottom\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Down\")]}\n            />\n            <Shortcut\n              label={t(\"labels.alignLeft\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Left\")]}\n            />\n            <Shortcut\n              label={t(\"labels.alignRight\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+Right\")]}\n            />\n            <Shortcut\n              label={t(\"labels.duplicateSelection\")}\n              shortcuts={[\n                getShortcutKey(\"CtrlOrCmd+D\"),\n                getShortcutKey(`Alt+${t(\"helpDialog.drag\")}`),\n              ]}\n            />\n            <Shortcut\n              label={t(\"helpDialog.toggleElementLock\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+L\")]}\n            />\n            <Shortcut\n              label={t(\"buttons.undo\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Z\")]}\n            />\n            <Shortcut\n              label={t(\"buttons.redo\")}\n              shortcuts={\n                isWindows\n                  ? [\n                      getShortcutKey(\"CtrlOrCmd+Y\"),\n                      getShortcutKey(\"CtrlOrCmd+Shift+Z\"),\n                    ]\n                  : [getShortcutKey(\"CtrlOrCmd+Shift+Z\")]\n              }\n            />\n            <Shortcut\n              label={t(\"labels.group\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+G\")]}\n            />\n            <Shortcut\n              label={t(\"labels.ungroup\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+G\")]}\n            />\n            <Shortcut\n              label={t(\"labels.flipHorizontal\")}\n              shortcuts={[getShortcutKey(\"Shift+H\")]}\n            />\n            <Shortcut\n              label={t(\"labels.flipVertical\")}\n              shortcuts={[getShortcutKey(\"Shift+V\")]}\n            />\n            <Shortcut\n              label={t(\"labels.showStroke\")}\n              shortcuts={[getShortcutKey(\"S\")]}\n            />\n            <Shortcut\n              label={t(\"labels.showBackground\")}\n              shortcuts={[getShortcutKey(\"G\")]}\n            />\n            <Shortcut\n              label={t(\"labels.showFonts\")}\n              shortcuts={[getShortcutKey(\"Shift+F\")]}\n            />\n            <Shortcut\n              label={t(\"labels.decreaseFontSize\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+<\")]}\n            />\n            <Shortcut\n              label={t(\"labels.increaseFontSize\")}\n              shortcuts={[getShortcutKey(\"CtrlOrCmd+Shift+>\")]}\n            />\n          </ShortcutIsland>\n        </Section>\n      </Dialog>\n    </>\n  );\n};\n",
    "import { exportToCanvas } from \"@excalidraw/utils/export\";\nimport React, { useEffect, useRef, useState } from \"react\";\n\nimport {\n  DEFAULT_EXPORT_PADDING,\n  EXPORT_IMAGE_TYPES,\n  isFirefox,\n  EXPORT_SCALES,\n  cloneJSON,\n} from \"@excalidraw/common\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport {\n  actionExportWithDarkMode,\n  actionChangeExportBackground,\n  actionChangeExportEmbedScene,\n  actionChangeExportScale,\n  actionChangeProjectName,\n} from \"../actions/actionExport\";\nimport { probablySupportsClipboardBlob } from \"../clipboard\";\nimport { prepareElementsForExport } from \"../data\";\nimport { canvasToBlob } from \"../data/blob\";\nimport { nativeFileSystemSupported } from \"../data/filesystem\";\nimport { useCopyStatus } from \"../hooks/useCopiedIndicator\";\n\nimport { t } from \"../i18n\";\nimport { isSomeElementSelected } from \"../scene\";\n\nimport { copyIcon, downloadIcon, helpIcon } from \"./icons\";\nimport { Dialog } from \"./Dialog\";\nimport { RadioGroup } from \"./RadioGroup\";\nimport { Switch } from \"./Switch\";\nimport { Tooltip } from \"./Tooltip\";\nimport { FilledButton } from \"./FilledButton\";\n\nimport \"./ImageExportDialog.scss\";\n\nimport type { ActionManager } from \"../actions/manager\";\n\nimport type { AppClassProperties, BinaryFiles, UIAppState } from \"../types\";\n\nconst supportsContextFilters =\n  \"filter\" in document.createElement(\"canvas\").getContext(\"2d\")!;\n\nexport const ErrorCanvasPreview = () => {\n  return (\n    <div>\n      <h3>{t(\"canvasError.cannotShowPreview\")}</h3>\n      <p>\n        <span>{t(\"canvasError.canvasTooBig\")}</span>\n      </p>\n      <em>({t(\"canvasError.canvasTooBigTip\")})</em>\n    </div>\n  );\n};\n\ntype ImageExportModalProps = {\n  appStateSnapshot: Readonly<UIAppState>;\n  elementsSnapshot: readonly NonDeletedExcalidrawElement[];\n  files: BinaryFiles;\n  actionManager: ActionManager;\n  onExportImage: AppClassProperties[\"onExportImage\"];\n  name: string;\n};\n\nconst ImageExportModal = ({\n  appStateSnapshot,\n  elementsSnapshot,\n  files,\n  actionManager,\n  onExportImage,\n  name,\n}: ImageExportModalProps) => {\n  const hasSelection = isSomeElementSelected(\n    elementsSnapshot,\n    appStateSnapshot,\n  );\n\n  const [projectName, setProjectName] = useState(name);\n  const [exportSelectionOnly, setExportSelectionOnly] = useState(hasSelection);\n  const [exportWithBackground, setExportWithBackground] = useState(\n    appStateSnapshot.exportBackground,\n  );\n  const [exportDarkMode, setExportDarkMode] = useState(\n    appStateSnapshot.exportWithDarkMode,\n  );\n  const [embedScene, setEmbedScene] = useState(\n    appStateSnapshot.exportEmbedScene,\n  );\n  const [exportScale, setExportScale] = useState(appStateSnapshot.exportScale);\n\n  const previewRef = useRef<HTMLDivElement>(null);\n  const [renderError, setRenderError] = useState<Error | null>(null);\n\n  const { onCopy, copyStatus, resetCopyStatus } = useCopyStatus();\n\n  useEffect(() => {\n    // if user changes setting right after export to clipboard, reset the status\n    // so they don't have to wait for the timeout to click the button again\n    resetCopyStatus();\n  }, [\n    projectName,\n    exportWithBackground,\n    exportDarkMode,\n    exportScale,\n    embedScene,\n    resetCopyStatus,\n  ]);\n\n  const { exportedElements, exportingFrame } = prepareElementsForExport(\n    elementsSnapshot,\n    appStateSnapshot,\n    exportSelectionOnly,\n  );\n\n  useEffect(() => {\n    const previewNode = previewRef.current;\n    if (!previewNode) {\n      return;\n    }\n    const maxWidth = previewNode.offsetWidth;\n    const maxHeight = previewNode.offsetHeight;\n    if (!maxWidth) {\n      return;\n    }\n\n    exportToCanvas({\n      elements: exportedElements,\n      appState: {\n        ...appStateSnapshot,\n        name: projectName,\n        exportBackground: exportWithBackground,\n        exportWithDarkMode: exportDarkMode,\n        exportScale,\n        exportEmbedScene: embedScene,\n      },\n      files,\n      exportPadding: DEFAULT_EXPORT_PADDING,\n      maxWidthOrHeight: Math.max(maxWidth, maxHeight),\n      exportingFrame,\n    })\n      .then((canvas) => {\n        setRenderError(null);\n        // if converting to blob fails, there's some problem that will\n        // likely prevent preview and export (e.g. canvas too big)\n        return canvasToBlob(canvas)\n          .then(() => {\n            previewNode.replaceChildren(canvas);\n          })\n          .catch((e) => {\n            if (e.name === \"CANVAS_POSSIBLY_TOO_BIG\") {\n              throw new Error(t(\"canvasError.canvasTooBig\"));\n            }\n            throw e;\n          });\n      })\n      .catch((error) => {\n        console.error(error);\n        setRenderError(error);\n      });\n  }, [\n    appStateSnapshot,\n    files,\n    exportedElements,\n    exportingFrame,\n    projectName,\n    exportWithBackground,\n    exportDarkMode,\n    exportScale,\n    embedScene,\n  ]);\n\n  return (\n    <div className=\"ImageExportModal\">\n      <h3>{t(\"imageExportDialog.header\")}</h3>\n      <div className=\"ImageExportModal__preview\">\n        <div className=\"ImageExportModal__preview__canvas\" ref={previewRef}>\n          {renderError && <ErrorCanvasPreview />}\n        </div>\n        <div className=\"ImageExportModal__preview__filename\">\n          {!nativeFileSystemSupported && (\n            <input\n              type=\"text\"\n              className=\"TextInput\"\n              value={projectName}\n              style={{ width: \"30ch\" }}\n              onChange={(event) => {\n                setProjectName(event.target.value);\n                actionManager.executeAction(\n                  actionChangeProjectName,\n                  \"ui\",\n                  event.target.value,\n                );\n              }}\n            />\n          )}\n        </div>\n      </div>\n      <div className=\"ImageExportModal__settings\">\n        <h3>{t(\"imageExportDialog.header\")}</h3>\n        {hasSelection && (\n          <ExportSetting\n            label={t(\"imageExportDialog.label.onlySelected\")}\n            name=\"exportOnlySelected\"\n          >\n            <Switch\n              name=\"exportOnlySelected\"\n              checked={exportSelectionOnly}\n              onChange={(checked) => {\n                setExportSelectionOnly(checked);\n              }}\n            />\n          </ExportSetting>\n        )}\n        <ExportSetting\n          label={t(\"imageExportDialog.label.withBackground\")}\n          name=\"exportBackgroundSwitch\"\n        >\n          <Switch\n            name=\"exportBackgroundSwitch\"\n            checked={exportWithBackground}\n            onChange={(checked) => {\n              setExportWithBackground(checked);\n              actionManager.executeAction(\n                actionChangeExportBackground,\n                \"ui\",\n                checked,\n              );\n            }}\n          />\n        </ExportSetting>\n        {supportsContextFilters && (\n          <ExportSetting\n            label={t(\"imageExportDialog.label.darkMode\")}\n            name=\"exportDarkModeSwitch\"\n          >\n            <Switch\n              name=\"exportDarkModeSwitch\"\n              checked={exportDarkMode}\n              onChange={(checked) => {\n                setExportDarkMode(checked);\n                actionManager.executeAction(\n                  actionExportWithDarkMode,\n                  \"ui\",\n                  checked,\n                );\n              }}\n            />\n          </ExportSetting>\n        )}\n        <ExportSetting\n          label={t(\"imageExportDialog.label.embedScene\")}\n          tooltip={t(\"imageExportDialog.tooltip.embedScene\")}\n          name=\"exportEmbedSwitch\"\n        >\n          <Switch\n            name=\"exportEmbedSwitch\"\n            checked={embedScene}\n            onChange={(checked) => {\n              setEmbedScene(checked);\n              actionManager.executeAction(\n                actionChangeExportEmbedScene,\n                \"ui\",\n                checked,\n              );\n            }}\n          />\n        </ExportSetting>\n        <ExportSetting\n          label={t(\"imageExportDialog.label.scale\")}\n          name=\"exportScale\"\n        >\n          <RadioGroup\n            name=\"exportScale\"\n            value={exportScale}\n            onChange={(scale) => {\n              setExportScale(scale);\n              actionManager.executeAction(actionChangeExportScale, \"ui\", scale);\n            }}\n            choices={EXPORT_SCALES.map((scale) => ({\n              value: scale,\n              label: `${scale}\\u00d7`,\n            }))}\n          />\n        </ExportSetting>\n\n        <div className=\"ImageExportModal__settings__buttons\">\n          <FilledButton\n            className=\"ImageExportModal__settings__buttons__button\"\n            label={t(\"imageExportDialog.title.exportToPng\")}\n            onClick={() =>\n              onExportImage(EXPORT_IMAGE_TYPES.png, exportedElements, {\n                exportingFrame,\n              })\n            }\n            icon={downloadIcon}\n          >\n            {t(\"imageExportDialog.button.exportToPng\")}\n          </FilledButton>\n          <FilledButton\n            className=\"ImageExportModal__settings__buttons__button\"\n            label={t(\"imageExportDialog.title.exportToSvg\")}\n            onClick={() =>\n              onExportImage(EXPORT_IMAGE_TYPES.svg, exportedElements, {\n                exportingFrame,\n              })\n            }\n            icon={downloadIcon}\n          >\n            {t(\"imageExportDialog.button.exportToSvg\")}\n          </FilledButton>\n          {(probablySupportsClipboardBlob || isFirefox) && (\n            <FilledButton\n              className=\"ImageExportModal__settings__buttons__button\"\n              label={t(\"imageExportDialog.title.copyPngToClipboard\")}\n              status={copyStatus}\n              onClick={async () => {\n                await onExportImage(\n                  EXPORT_IMAGE_TYPES.clipboard,\n                  exportedElements,\n                  {\n                    exportingFrame,\n                  },\n                );\n                onCopy();\n              }}\n              icon={copyIcon}\n            >\n              {t(\"imageExportDialog.button.copyPngToClipboard\")}\n            </FilledButton>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\ntype ExportSettingProps = {\n  label: string;\n  children: React.ReactNode;\n  tooltip?: string;\n  name?: string;\n};\n\nconst ExportSetting = ({\n  label,\n  children,\n  tooltip,\n  name,\n}: ExportSettingProps) => {\n  return (\n    <div className=\"ImageExportModal__settings__setting\" title={label}>\n      <label\n        htmlFor={name}\n        className=\"ImageExportModal__settings__setting__label\"\n      >\n        {label}\n        {tooltip && (\n          <Tooltip label={tooltip} long={true}>\n            {helpIcon}\n          </Tooltip>\n        )}\n      </label>\n      <div className=\"ImageExportModal__settings__setting__content\">\n        {children}\n      </div>\n    </div>\n  );\n};\n\nexport const ImageExportDialog = ({\n  elements,\n  appState,\n  files,\n  actionManager,\n  onExportImage,\n  onCloseRequest,\n  name,\n}: {\n  appState: UIAppState;\n  elements: readonly NonDeletedExcalidrawElement[];\n  files: BinaryFiles;\n  actionManager: ActionManager;\n  onExportImage: AppClassProperties[\"onExportImage\"];\n  onCloseRequest: () => void;\n  name: string;\n}) => {\n  // we need to take a snapshot so that the exported state can't be modified\n  // while the dialog is open\n  const [{ appStateSnapshot, elementsSnapshot }] = useState(() => {\n    return {\n      appStateSnapshot: cloneJSON(appState),\n      elementsSnapshot: cloneJSON(elements),\n    };\n  });\n\n  return (\n    <Dialog onCloseRequest={onCloseRequest} size=\"wide\" title={false}>\n      <ImageExportModal\n        elementsSnapshot={elementsSnapshot}\n        appStateSnapshot={appStateSnapshot}\n        files={files}\n        actionManager={actionManager}\n        onExportImage={onExportImage}\n        name={name}\n      />\n    </Dialog>\n  );\n};\n",
    "import { useCallback, useRef, useState } from \"react\";\n\nconst TIMEOUT = 2000;\n\nexport const useCopyStatus = () => {\n  const [copyStatus, setCopyStatus] = useState<\"success\" | null>(null);\n  const timeoutRef = useRef<number>(0);\n\n  const onCopy = () => {\n    clearTimeout(timeoutRef.current);\n    setCopyStatus(\"success\");\n\n    timeoutRef.current = window.setTimeout(() => {\n      setCopyStatus(null);\n    }, TIMEOUT);\n  };\n\n  const resetCopyStatus = useCallback(() => {\n    setCopyStatus(null);\n  }, []);\n\n  return {\n    copyStatus,\n    resetCopyStatus,\n    onCopy,\n  };\n};\n",
    "import clsx from \"clsx\";\n\nimport \"./Switch.scss\";\n\nexport type SwitchProps = {\n  name: string;\n  checked: boolean;\n  title?: string;\n  onChange: (value: boolean) => void;\n  disabled?: boolean;\n};\n\nexport const Switch = ({\n  title,\n  name,\n  checked,\n  onChange,\n  disabled = false,\n}: SwitchProps) => {\n  return (\n    <div className={clsx(\"Switch\", { toggled: checked, disabled })}>\n      <input\n        name={name}\n        id={name}\n        title={title}\n        type=\"checkbox\"\n        checked={checked}\n        disabled={disabled}\n        onChange={() => onChange(!checked)}\n        onKeyDown={(event) => {\n          if (event.key === \" \") {\n            onChange(!checked);\n          }\n        }}\n      />\n    </div>\n  );\n};\n",
    "import React from \"react\";\n\nimport { getFrame } from \"@excalidraw/common\";\n\nimport type { NonDeletedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport { actionSaveFileToDisk } from \"../actions/actionExport\";\n\nimport { trackEvent } from \"../analytics\";\nimport { nativeFileSystemSupported } from \"../data/filesystem\";\nimport { t } from \"../i18n\";\n\nimport { Card } from \"./Card\";\nimport { Dialog } from \"./Dialog\";\nimport { ToolButton } from \"./ToolButton\";\nimport { exportToFileIcon, LinkIcon } from \"./icons\";\n\nimport \"./ExportDialog.scss\";\n\nimport type { ActionManager } from \"../actions/manager\";\n\nimport type { ExportOpts, BinaryFiles, UIAppState } from \"../types\";\n\nexport type ExportCB = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  scale?: number,\n) => void;\n\nconst JSONExportModal = ({\n  elements,\n  appState,\n  setAppState,\n  files,\n  actionManager,\n  exportOpts,\n  canvas,\n  onCloseRequest,\n}: {\n  appState: UIAppState;\n  setAppState: React.Component<any, UIAppState>[\"setState\"];\n  files: BinaryFiles;\n  elements: readonly NonDeletedExcalidrawElement[];\n  actionManager: ActionManager;\n  onCloseRequest: () => void;\n  exportOpts: ExportOpts;\n  canvas: HTMLCanvasElement;\n}) => {\n  const { onExportToBackend } = exportOpts;\n  return (\n    <div className=\"ExportDialog ExportDialog--json\">\n      <div className=\"ExportDialog-cards\">\n        {exportOpts.saveFileToDisk && (\n          <Card color=\"lime\">\n            <div className=\"Card-icon\">{exportToFileIcon}</div>\n            <h2>{t(\"exportDialog.disk_title\")}</h2>\n            <div className=\"Card-details\">\n              {t(\"exportDialog.disk_details\")}\n              {!nativeFileSystemSupported &&\n                actionManager.renderAction(\"changeProjectName\")}\n            </div>\n            <ToolButton\n              className=\"Card-button\"\n              type=\"button\"\n              title={t(\"exportDialog.disk_button\")}\n              aria-label={t(\"exportDialog.disk_button\")}\n              showAriaLabel={true}\n              onClick={() => {\n                actionManager.executeAction(actionSaveFileToDisk, \"ui\");\n              }}\n            />\n          </Card>\n        )}\n        {onExportToBackend && (\n          <Card color=\"pink\">\n            <div className=\"Card-icon\">{LinkIcon}</div>\n            <h2>{t(\"exportDialog.link_title\")}</h2>\n            <div className=\"Card-details\">{t(\"exportDialog.link_details\")}</div>\n            <ToolButton\n              className=\"Card-button\"\n              type=\"button\"\n              title={t(\"exportDialog.link_button\")}\n              aria-label={t(\"exportDialog.link_button\")}\n              showAriaLabel={true}\n              onClick={async () => {\n                try {\n                  trackEvent(\"export\", \"link\", `ui (${getFrame()})`);\n                  await onExportToBackend(elements, appState, files);\n                  onCloseRequest();\n                } catch (error: any) {\n                  setAppState({ errorMessage: error.message });\n                }\n              }}\n            />\n          </Card>\n        )}\n        {exportOpts.renderCustomUI &&\n          exportOpts.renderCustomUI(elements, appState, files, canvas)}\n      </div>\n    </div>\n  );\n};\n\nexport const JSONExportDialog = ({\n  elements,\n  appState,\n  files,\n  actionManager,\n  exportOpts,\n  canvas,\n  setAppState,\n}: {\n  elements: readonly NonDeletedExcalidrawElement[];\n  appState: UIAppState;\n  files: BinaryFiles;\n  actionManager: ActionManager;\n  exportOpts: ExportOpts;\n  canvas: HTMLCanvasElement;\n  setAppState: React.Component<any, UIAppState>[\"setState\"];\n}) => {\n  const handleClose = React.useCallback(() => {\n    setAppState({ openDialog: null });\n  }, [setAppState]);\n\n  return (\n    <>\n      {appState.openDialog?.name === \"jsonExport\" && (\n        <Dialog onCloseRequest={handleClose} title={t(\"buttons.export\")}>\n          <JSONExportModal\n            elements={elements}\n            appState={appState}\n            setAppState={setAppState}\n            files={files}\n            actionManager={actionManager}\n            onCloseRequest={handleClose}\n            exportOpts={exportOpts}\n            canvas={canvas}\n          />\n        </Dialog>\n      )}\n    </>\n  );\n};\n",
    "import OpenColor from \"open-color\";\n\nimport \"./Card.scss\";\n\nexport const Card: React.FC<{\n  color: keyof OpenColor | \"primary\";\n  children?: React.ReactNode;\n}> = ({ children, color }) => {\n  return (\n    <div\n      className=\"Card\"\n      style={{\n        [\"--card-color\" as any]:\n          color === \"primary\" ? \"var(--color-primary)\" : OpenColor[color][7],\n        [\"--card-color-darker\" as any]:\n          color === \"primary\"\n            ? \"var(--color-primary-darker)\"\n            : OpenColor[color][8],\n        [\"--card-color-darkest\" as any]:\n          color === \"primary\"\n            ? \"var(--color-primary-darkest)\"\n            : OpenColor[color][9],\n      }}\n    >\n      {children}\n    </div>\n  );\n};\n",
    "import clsx from \"clsx\";\n\nimport \"./ToolIcon.scss\";\n\nimport { laserPointerToolIcon } from \"./icons\";\n\nimport type { ToolButtonSize } from \"./ToolButton\";\n\ntype LaserPointerIconProps = {\n  title?: string;\n  name?: string;\n  checked: boolean;\n  onChange?(): void;\n  isMobile?: boolean;\n};\n\nconst DEFAULT_SIZE: ToolButtonSize = \"small\";\n\nexport const LaserPointerButton = (props: LaserPointerIconProps) => {\n  return (\n    <label\n      className={clsx(\n        \"ToolIcon ToolIcon__LaserPointer\",\n        `ToolIcon_size_${DEFAULT_SIZE}`,\n        {\n          \"is-mobile\": props.isMobile,\n        },\n      )}\n      title={`${props.title}`}\n    >\n      <input\n        className=\"ToolIcon_type_checkbox\"\n        type=\"checkbox\"\n        name={props.name}\n        onChange={props.onChange}\n        checked={props.checked}\n        aria-label={props.title}\n        data-testid=\"toolbar-LaserPointer\"\n      />\n      <div className=\"ToolIcon__icon\">{laserPointerToolIcon}</div>\n    </label>\n  );\n};\n",
    "import clsx from \"clsx\";\n\nimport \"./ToolIcon.scss\";\n\nimport type { ToolButtonSize } from \"./ToolButton\";\nimport type { JSX } from \"react\";\n\nconst DEFAULT_SIZE: ToolButtonSize = \"small\";\n\nexport const ElementCanvasButton = (props: {\n  title?: string;\n  icon: JSX.Element;\n  name?: string;\n  checked: boolean;\n  onChange?(): void;\n  isMobile?: boolean;\n}) => {\n  return (\n    <label\n      className={clsx(\n        \"ToolIcon ToolIcon__MagicButton\",\n        `ToolIcon_size_${DEFAULT_SIZE}`,\n        {\n          \"is-mobile\": props.isMobile,\n        },\n      )}\n      title={`${props.title}`}\n    >\n      <input\n        className=\"ToolIcon_type_checkbox\"\n        type=\"checkbox\"\n        name={props.name}\n        onChange={props.onChange}\n        checked={props.checked}\n        aria-label={props.title}\n      />\n      <div className=\"ToolIcon__icon\">{props.icon}</div>\n    </label>\n  );\n};\n",
    "import React from \"react\";\n\nimport { sceneCoordsToViewportCoords } from \"@excalidraw/common\";\n\nimport { getElementAbsoluteCoords } from \"@excalidraw/element\";\n\nimport type {\n  ElementsMap,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/element/types\";\n\nimport { getSelectedElements } from \"../scene\";\n\nimport { ElementCanvasButton } from \"./MagicButton\";\nimport { useExcalidrawAppState, useExcalidrawActionManager } from \"./App\";\n\nimport type { AppClassProperties } from \"../types\";\n\n// Custom icons\nconst HighlightIcon = (\n  <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n    <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\" />\n  </svg>\n);\n\nconst ClearIcon = (\n  <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n    <path d=\"M9 3v1H4v2h1v13a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V6h1V4h-5V3H9zM7 6h10v13H7V6zm2 2v9h2V8H9zm4 0v9h2V8h-2z\" />\n  </svg>\n);\n\nconst DuplicateHighlightIcon = (\n  <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n    <path d=\"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z\" />\n  </svg>\n);\n\ninterface CustomHighlightCanvasButtonsProps {\n  elements: readonly NonDeletedExcalidrawElement[];\n  elementsMap: ElementsMap;\n  app: AppClassProperties;\n}\n\nexport const CustomHighlightCanvasButtons: React.FC<\n  CustomHighlightCanvasButtonsProps\n> = ({ elements, elementsMap, app }) => {\n  const appState = useExcalidrawAppState();\n  const actionManager = useExcalidrawActionManager();\n\n  const selectedElements = getSelectedElements(elements, appState);\n\n  // Don't show if no elements selected or in certain states\n  if (\n    selectedElements.length === 0 ||\n    appState.contextMenu ||\n    appState.newElement ||\n    appState.resizingElement ||\n    appState.isRotating ||\n    appState.openMenu ||\n    appState.viewModeEnabled ||\n    appState.editingTextElement\n  ) {\n    return null;\n  }\n\n  // Check if selection is a group that contains arrow with start and end points\n  const isGroupWithArrowAndPoints = () => {\n    // Must have more than one element (indicating a group selection)\n    if (selectedElements.length <= 1) {\n      return false;\n    }\n\n    // Check if there's an arrow with both start and end bindings in the selection\n    const hasArrowWithPoints = selectedElements.some((el) => {\n      return (\n        el.type === \"arrow\" &&\n        el.startBinding !== null &&\n        el.endBinding !== null\n      );\n    });\n\n    return hasArrowWithPoints;\n  };\n\n  // Only show custom buttons if we have a group with arrow and connection points\n  if (!isGroupWithArrowAndPoints()) {\n    return null;\n  }\n\n  // Get the first selected element to position buttons near\n  const targetElement = selectedElements[0];\n\n  // Check if any selected elements are highlighted\n  const hasHighlighted = selectedElements.some(\n    (el) => el.backgroundColor === \"#ffe066\" && el.strokeColor === \"#ff6b6b\",\n  );\n\n  const executeCustomAction = (actionName: string) => {\n    console.log(`🎨 Executing custom action: ${actionName}`);\n    const action =\n      actionManager.actions[actionName as keyof typeof actionManager.actions];\n    if (action) {\n      actionManager.executeAction(action, \"ui\");\n    }\n  };\n\n  // Custom positioning logic - place buttons below the center of the group\n  const getCustomContainerCoords = () => {\n    // Calculate bounding box of all selected elements (group)\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    selectedElements.forEach((element) => {\n      const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);\n      const x2 = x1 + element.width;\n      const y2 = y1 + element.height;\n\n      minX = Math.min(minX, x1);\n      minY = Math.min(minY, y1);\n      maxX = Math.max(maxX, x2);\n      maxY = Math.max(maxY, y2);\n    });\n\n    // Center X position of the group\n    const groupCenterX = (minX + maxX) / 2;\n    // Bottom Y position of the group\n    const groupBottomY = maxY;\n\n    const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(\n      { sceneX: groupCenterX, sceneY: groupBottomY },\n      appState,\n    );\n\n    // Center the buttons container horizontally\n    const x = viewportX - appState.offsetLeft;\n    const y = viewportY - appState.offsetTop + 10; // Small gap below group\n    return { x, y };\n  };\n\n  const { x, y } = getCustomContainerCoords();\n\n  return (\n    <div\n      className=\"excalidraw-canvas-buttons\"\n      style={{\n        position: \"absolute\",\n        top: `${y}px`,\n        left: `${x}px`,\n        background: \"transparent\",\n        boxShadow: \"none\",\n        display: \"flex\",\n        flexDirection: \"row\",\n        gap: \"1rem\",\n        transform: \"translateX(-50%)\", // Center horizontally\n      }}\n    >\n      <div\n        style={{\n          display: \"flex\",\n          flexDirection: \"row\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          gap: \"0.375rem\",\n          padding: \"5px\",\n          boxShadow: \"0px 2px 4px 0 rgb(0 0 0 / 30%)\",\n          zIndex: \"var(--zIndex-canvasButtons)\",\n          background: \"var(--island-bg-color)\",\n          borderRadius: \"var(--border-radius-lg)\",\n        }}\n      >\n        {/* Custom Highlight Button */}\n        <ElementCanvasButton\n          title=\"Apply custom highlight effect\"\n          icon={HighlightIcon}\n          checked={hasHighlighted}\n          onChange={() => executeCustomAction(\"customHighlight\")}\n        />\n        Ask Arisa\n      </div>\n\n      <div\n        style={{\n          display: \"flex\",\n          flexDirection: \"row\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          gap: \"0.375rem\",\n          padding: \"5px\",\n          boxShadow: \"0px 2px 4px 0 rgb(0 0 0 / 30%)\",\n          zIndex: \"var(--zIndex-canvasButtons)\",\n          background: \"var(--island-bg-color)\",\n          borderRadius: \"var(--border-radius-lg)\",\n        }}\n      >\n        {/* Duplicate & Highlight Button */}\n        <ElementCanvasButton\n          title=\"Duplicate and highlight\"\n          icon={DuplicateHighlightIcon}\n          checked={false}\n          onChange={() => executeCustomAction(\"duplicateAndHighlight\")}\n        />\n        Duplicate & Highlight\n      </div>\n\n      {/* Clear Highlight Button - only show if there are highlighted elements */}\n      {hasHighlighted && (\n        <ElementCanvasButton\n          title=\"Clear highlight effect\"\n          icon={ClearIcon}\n          checked={false}\n          onChange={() => executeCustomAction(\"clearHighlight\")}\n        />\n      )}\n    </div>\n  );\n};\n",
    "import { useEffect, useRef } from \"react\";\n\nimport \"./SVGLayer.scss\";\n\nimport type { Trail } from \"../animated-trail\";\n\ntype SVGLayerProps = {\n  trails: Trail[];\n};\n\nexport const SVGLayer = ({ trails }: SVGLayerProps) => {\n  const svgRef = useRef<SVGSVGElement | null>(null);\n\n  useEffect(() => {\n    if (svgRef.current) {\n      for (const trail of trails) {\n        trail.start(svgRef.current);\n      }\n    }\n\n    return () => {\n      for (const trail of trails) {\n        trail.stop();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, trails);\n\n  return (\n    <div className=\"SVGLayer\">\n      <svg ref={svgRef} />\n    </div>\n  );\n};\n",
    "import React, { useEffect, useRef } from \"react\";\n\nimport {\n  CURSOR_TYPE,\n  isShallowEqual,\n  sceneCoordsToViewportCoords,\n} from \"@excalidraw/common\";\n\nimport type {\n  NonDeletedExcalidrawElement,\n  NonDeletedSceneElementsMap,\n} from \"@excalidraw/element/types\";\n\nimport { t } from \"../../i18n\";\nimport { isRenderThrottlingEnabled } from \"../../reactUtils\";\nimport { renderInteractiveScene } from \"../../renderer/interactiveScene\";\n\nimport type {\n  InteractiveCanvasRenderConfig,\n  RenderableElementsMap,\n  RenderInteractiveSceneCallback,\n} from \"../../scene/types\";\nimport type { AppState, Device, InteractiveCanvasAppState } from \"../../types\";\nimport type { DOMAttributes } from \"react\";\n\ntype InteractiveCanvasProps = {\n  containerRef: React.RefObject<HTMLDivElement | null>;\n  canvas: HTMLCanvasElement | null;\n  elementsMap: RenderableElementsMap;\n  visibleElements: readonly NonDeletedExcalidrawElement[];\n  selectedElements: readonly NonDeletedExcalidrawElement[];\n  allElementsMap: NonDeletedSceneElementsMap;\n  sceneNonce: number | undefined;\n  selectionNonce: number | undefined;\n  scale: number;\n  appState: InteractiveCanvasAppState;\n  renderScrollbars: boolean;\n  device: Device;\n  renderInteractiveSceneCallback: (\n    data: RenderInteractiveSceneCallback,\n  ) => void;\n  handleCanvasRef: (canvas: HTMLCanvasElement | null) => void;\n  onContextMenu: Exclude<\n    DOMAttributes<HTMLCanvasElement | HTMLDivElement>[\"onContextMenu\"],\n    undefined\n  >;\n  onPointerMove: Exclude<\n    DOMAttributes<HTMLCanvasElement>[\"onPointerMove\"],\n    undefined\n  >;\n  onPointerUp: Exclude<\n    DOMAttributes<HTMLCanvasElement>[\"onPointerUp\"],\n    undefined\n  >;\n  onPointerCancel: Exclude<\n    DOMAttributes<HTMLCanvasElement>[\"onPointerCancel\"],\n    undefined\n  >;\n  onTouchMove: Exclude<\n    DOMAttributes<HTMLCanvasElement>[\"onTouchMove\"],\n    undefined\n  >;\n  onPointerDown: Exclude<\n    DOMAttributes<HTMLCanvasElement>[\"onPointerDown\"],\n    undefined\n  >;\n  onDoubleClick: Exclude<\n    DOMAttributes<HTMLCanvasElement>[\"onDoubleClick\"],\n    undefined\n  >;\n};\n\nconst InteractiveCanvas = (props: InteractiveCanvasProps) => {\n  const isComponentMounted = useRef(false);\n\n  useEffect(() => {\n    if (!isComponentMounted.current) {\n      isComponentMounted.current = true;\n      return;\n    }\n\n    const remotePointerButton: InteractiveCanvasRenderConfig[\"remotePointerButton\"] =\n      new Map();\n    const remotePointerViewportCoords: InteractiveCanvasRenderConfig[\"remotePointerViewportCoords\"] =\n      new Map();\n    const remoteSelectedElementIds: InteractiveCanvasRenderConfig[\"remoteSelectedElementIds\"] =\n      new Map();\n    const remotePointerUsernames: InteractiveCanvasRenderConfig[\"remotePointerUsernames\"] =\n      new Map();\n    const remotePointerUserStates: InteractiveCanvasRenderConfig[\"remotePointerUserStates\"] =\n      new Map();\n\n    props.appState.collaborators.forEach((user, socketId) => {\n      if (user.selectedElementIds) {\n        for (const id of Object.keys(user.selectedElementIds)) {\n          if (!remoteSelectedElementIds.has(id)) {\n            remoteSelectedElementIds.set(id, []);\n          }\n          remoteSelectedElementIds.get(id)!.push(socketId);\n        }\n      }\n      if (!user.pointer || user.pointer.renderCursor === false) {\n        return;\n      }\n      if (user.username) {\n        remotePointerUsernames.set(socketId, user.username);\n      }\n      if (user.userState) {\n        remotePointerUserStates.set(socketId, user.userState);\n      }\n      remotePointerViewportCoords.set(\n        socketId,\n        sceneCoordsToViewportCoords(\n          {\n            sceneX: user.pointer.x,\n            sceneY: user.pointer.y,\n          },\n          props.appState,\n        ),\n      );\n      remotePointerButton.set(socketId, user.button);\n    });\n\n    const selectionColor =\n      (props.containerRef?.current &&\n        getComputedStyle(props.containerRef.current).getPropertyValue(\n          \"--color-selection\",\n        )) ||\n      \"#6965db\";\n\n    renderInteractiveScene(\n      {\n        canvas: props.canvas,\n        elementsMap: props.elementsMap,\n        visibleElements: props.visibleElements,\n        selectedElements: props.selectedElements,\n        allElementsMap: props.allElementsMap,\n        scale: window.devicePixelRatio,\n        appState: props.appState,\n        renderConfig: {\n          remotePointerViewportCoords,\n          remotePointerButton,\n          remoteSelectedElementIds,\n          remotePointerUsernames,\n          remotePointerUserStates,\n          selectionColor,\n          renderScrollbars: props.renderScrollbars,\n        },\n        device: props.device,\n        callback: props.renderInteractiveSceneCallback,\n      },\n      isRenderThrottlingEnabled(),\n    );\n  });\n\n  return (\n    <canvas\n      className=\"excalidraw__canvas interactive\"\n      style={{\n        width: props.appState.width,\n        height: props.appState.height,\n        cursor: props.appState.viewModeEnabled\n          ? CURSOR_TYPE.GRAB\n          : CURSOR_TYPE.AUTO,\n      }}\n      width={props.appState.width * props.scale}\n      height={props.appState.height * props.scale}\n      ref={props.handleCanvasRef}\n      onContextMenu={props.onContextMenu}\n      onPointerMove={props.onPointerMove}\n      onPointerUp={props.onPointerUp}\n      onPointerCancel={props.onPointerCancel}\n      onTouchMove={props.onTouchMove}\n      onPointerDown={props.onPointerDown}\n      onDoubleClick={\n        props.appState.viewModeEnabled ? undefined : props.onDoubleClick\n      }\n    >\n      {t(\"labels.drawingCanvas\")}\n    </canvas>\n  );\n};\n\nconst getRelevantAppStateProps = (\n  appState: AppState,\n): InteractiveCanvasAppState => ({\n  zoom: appState.zoom,\n  scrollX: appState.scrollX,\n  scrollY: appState.scrollY,\n  width: appState.width,\n  height: appState.height,\n  viewModeEnabled: appState.viewModeEnabled,\n  openDialog: appState.openDialog,\n  editingGroupId: appState.editingGroupId,\n  editingLinearElement: appState.editingLinearElement,\n  selectedElementIds: appState.selectedElementIds,\n  frameToHighlight: appState.frameToHighlight,\n  offsetLeft: appState.offsetLeft,\n  offsetTop: appState.offsetTop,\n  theme: appState.theme,\n  selectionElement: appState.selectionElement,\n  selectedGroupIds: appState.selectedGroupIds,\n  selectedLinearElement: appState.selectedLinearElement,\n  multiElement: appState.multiElement,\n  isBindingEnabled: appState.isBindingEnabled,\n  suggestedBindings: appState.suggestedBindings,\n  isRotating: appState.isRotating,\n  elementsToHighlight: appState.elementsToHighlight,\n  collaborators: appState.collaborators, // Necessary for collab. sessions\n  activeEmbeddable: appState.activeEmbeddable,\n  snapLines: appState.snapLines,\n  zenModeEnabled: appState.zenModeEnabled,\n  editingTextElement: appState.editingTextElement,\n  isCropping: appState.isCropping,\n  croppingElementId: appState.croppingElementId,\n  searchMatches: appState.searchMatches,\n  activeLockedId: appState.activeLockedId,\n});\n\nconst areEqual = (\n  prevProps: InteractiveCanvasProps,\n  nextProps: InteractiveCanvasProps,\n) => {\n  // This could be further optimised if needed, as we don't have to render interactive canvas on each scene mutation\n  if (\n    prevProps.selectionNonce !== nextProps.selectionNonce ||\n    prevProps.sceneNonce !== nextProps.sceneNonce ||\n    prevProps.scale !== nextProps.scale ||\n    // we need to memoize on elementsMap because they may have renewed\n    // even if sceneNonce didn't change (e.g. we filter elements out based\n    // on appState)\n    prevProps.elementsMap !== nextProps.elementsMap ||\n    prevProps.visibleElements !== nextProps.visibleElements ||\n    prevProps.selectedElements !== nextProps.selectedElements ||\n    prevProps.renderScrollbars !== nextProps.renderScrollbars\n  ) {\n    return false;\n  }\n\n  // Comparing the interactive appState for changes in case of some edge cases\n  return isShallowEqual(\n    // asserting AppState because we're being passed the whole AppState\n    // but resolve to only the InteractiveCanvas-relevant props\n    getRelevantAppStateProps(prevProps.appState as AppState),\n    getRelevantAppStateProps(nextProps.appState as AppState),\n  );\n};\n\nexport default React.memo(InteractiveCanvas, areEqual);\n",
    "import React, { useEffect, useRef } from \"react\";\n\nimport { isShallowEqual } from \"@excalidraw/common\";\n\nimport type {\n  NonDeletedExcalidrawElement,\n  NonDeletedSceneElementsMap,\n} from \"@excalidraw/element/types\";\n\nimport { isRenderThrottlingEnabled } from \"../../reactUtils\";\nimport { renderStaticScene } from \"../../renderer/staticScene\";\n\nimport type {\n  RenderableElementsMap,\n  StaticCanvasRenderConfig,\n} from \"../../scene/types\";\nimport type { AppState, StaticCanvasAppState } from \"../../types\";\nimport type { RoughCanvas } from \"roughjs/bin/canvas\";\n\ntype StaticCanvasProps = {\n  canvas: HTMLCanvasElement;\n  rc: RoughCanvas;\n  elementsMap: RenderableElementsMap;\n  allElementsMap: NonDeletedSceneElementsMap;\n  visibleElements: readonly NonDeletedExcalidrawElement[];\n  sceneNonce: number | undefined;\n  selectionNonce: number | undefined;\n  scale: number;\n  appState: StaticCanvasAppState;\n  renderConfig: StaticCanvasRenderConfig;\n};\n\nconst StaticCanvas = (props: StaticCanvasProps) => {\n  const wrapperRef = useRef<HTMLDivElement>(null);\n  const isComponentMounted = useRef(false);\n\n  useEffect(() => {\n    const wrapper = wrapperRef.current;\n    if (!wrapper) {\n      return;\n    }\n\n    const canvas = props.canvas;\n\n    if (!isComponentMounted.current) {\n      isComponentMounted.current = true;\n\n      wrapper.replaceChildren(canvas);\n      canvas.classList.add(\"excalidraw__canvas\", \"static\");\n    }\n\n    const widthString = `${props.appState.width}px`;\n    const heightString = `${props.appState.height}px`;\n    if (canvas.style.width !== widthString) {\n      canvas.style.width = widthString;\n    }\n    if (canvas.style.height !== heightString) {\n      canvas.style.height = heightString;\n    }\n\n    const scaledWidth = props.appState.width * props.scale;\n    const scaledHeight = props.appState.height * props.scale;\n    // setting width/height resets the canvas even if dimensions not changed,\n    // which would cause flicker when we skip frame (due to throttling)\n    if (canvas.width !== scaledWidth) {\n      canvas.width = scaledWidth;\n    }\n    if (canvas.height !== scaledHeight) {\n      canvas.height = scaledHeight;\n    }\n\n    renderStaticScene(\n      {\n        canvas,\n        rc: props.rc,\n        scale: props.scale,\n        elementsMap: props.elementsMap,\n        allElementsMap: props.allElementsMap,\n        visibleElements: props.visibleElements,\n        appState: props.appState,\n        renderConfig: props.renderConfig,\n      },\n      isRenderThrottlingEnabled(),\n    );\n  });\n\n  return <div className=\"excalidraw__canvas-wrapper\" ref={wrapperRef} />;\n};\n\nconst getRelevantAppStateProps = (appState: AppState): StaticCanvasAppState => {\n  const relevantAppStateProps = {\n    zoom: appState.zoom,\n    scrollX: appState.scrollX,\n    scrollY: appState.scrollY,\n    width: appState.width,\n    height: appState.height,\n    viewModeEnabled: appState.viewModeEnabled,\n    openDialog: appState.openDialog,\n    hoveredElementIds: appState.hoveredElementIds,\n    offsetLeft: appState.offsetLeft,\n    offsetTop: appState.offsetTop,\n    theme: appState.theme,\n    shouldCacheIgnoreZoom: appState.shouldCacheIgnoreZoom,\n    viewBackgroundColor: appState.viewBackgroundColor,\n    exportScale: appState.exportScale,\n    selectedElementsAreBeingDragged: appState.selectedElementsAreBeingDragged,\n    gridSize: appState.gridSize,\n    gridStep: appState.gridStep,\n    frameRendering: appState.frameRendering,\n    selectedElementIds: appState.selectedElementIds,\n    frameToHighlight: appState.frameToHighlight,\n    editingGroupId: appState.editingGroupId,\n    currentHoveredFontFamily: appState.currentHoveredFontFamily,\n    croppingElementId: appState.croppingElementId,\n  };\n\n  return relevantAppStateProps;\n};\n\nconst areEqual = (\n  prevProps: StaticCanvasProps,\n  nextProps: StaticCanvasProps,\n) => {\n  if (\n    prevProps.sceneNonce !== nextProps.sceneNonce ||\n    prevProps.scale !== nextProps.scale ||\n    // we need to memoize on elementsMap because they may have renewed\n    // even if sceneNonce didn't change (e.g. we filter elements out based\n    // on appState)\n    prevProps.elementsMap !== nextProps.elementsMap ||\n    prevProps.visibleElements !== nextProps.visibleElements\n  ) {\n    return false;\n  }\n\n  return (\n    isShallowEqual(\n      // asserting AppState because we're being passed the whole AppState\n      // but resolve to only the StaticCanvas-relevant props\n      getRelevantAppStateProps(prevProps.appState as AppState),\n      getRelevantAppStateProps(nextProps.appState as AppState),\n    ) && isShallowEqual(prevProps.renderConfig, nextProps.renderConfig)\n  );\n};\n\nexport default React.memo(StaticCanvas, areEqual);\n",
    "import { useEffect, useRef } from \"react\";\n\nimport type { NonDeletedSceneElementsMap } from \"@excalidraw/element/types\";\n\nimport { isRenderThrottlingEnabled } from \"../../reactUtils\";\nimport { renderNewElementScene } from \"../../renderer/renderNewElementScene\";\n\nimport type {\n  RenderableElementsMap,\n  StaticCanvasRenderConfig,\n} from \"../../scene/types\";\nimport type { AppState } from \"../../types\";\nimport type { RoughCanvas } from \"roughjs/bin/canvas\";\n\ninterface NewElementCanvasProps {\n  appState: AppState;\n  elementsMap: RenderableElementsMap;\n  allElementsMap: NonDeletedSceneElementsMap;\n  scale: number;\n  rc: RoughCanvas;\n  renderConfig: StaticCanvasRenderConfig;\n}\n\nconst NewElementCanvas = (props: NewElementCanvasProps) => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  useEffect(() => {\n    if (!canvasRef.current) {\n      return;\n    }\n    renderNewElementScene(\n      {\n        canvas: canvasRef.current,\n        scale: props.scale,\n        newElement: props.appState.newElement,\n        elementsMap: props.elementsMap,\n        allElementsMap: props.allElementsMap,\n        rc: props.rc,\n        renderConfig: props.renderConfig,\n        appState: props.appState,\n      },\n      isRenderThrottlingEnabled(),\n    );\n  });\n\n  return (\n    <canvas\n      className=\"excalidraw__canvas\"\n      style={{\n        width: props.appState.width,\n        height: props.appState.height,\n      }}\n      width={props.appState.width * props.scale}\n      height={props.appState.height * props.scale}\n      ref={canvasRef}\n    />\n  );\n};\n\nexport default NewElementCanvas;\n",
    "import { throttleRAF } from \"@excalidraw/common\";\n\nimport { renderElement } from \"@excalidraw/element\";\n\nimport { bootstrapCanvas, getNormalizedCanvasDimensions } from \"./helpers\";\n\nimport type { NewElementSceneRenderConfig } from \"../scene/types\";\n\nconst _renderNewElementScene = ({\n  canvas,\n  rc,\n  newElement,\n  elementsMap,\n  allElementsMap,\n  scale,\n  appState,\n  renderConfig,\n}: NewElementSceneRenderConfig) => {\n  if (canvas) {\n    const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(\n      canvas,\n      scale,\n    );\n\n    const context = bootstrapCanvas({\n      canvas,\n      scale,\n      normalizedWidth,\n      normalizedHeight,\n    });\n\n    // Apply zoom\n    context.save();\n    context.scale(appState.zoom.value, appState.zoom.value);\n\n    if (newElement && newElement.type !== \"selection\") {\n      renderElement(\n        newElement,\n        elementsMap,\n        allElementsMap,\n        rc,\n        context,\n        renderConfig,\n        appState,\n      );\n    } else {\n      context.clearRect(0, 0, normalizedWidth, normalizedHeight);\n    }\n  }\n};\n\nexport const renderNewElementSceneThrottled = throttleRAF(\n  (config: NewElementSceneRenderConfig) => {\n    _renderNewElementScene(config);\n  },\n  { trailing: true },\n);\n\nexport const renderNewElementScene = (\n  renderConfig: NewElementSceneRenderConfig,\n  throttle?: boolean,\n) => {\n  if (throttle) {\n    renderNewElementSceneThrottled(renderConfig);\n    return;\n  }\n\n  _renderNewElementScene(renderConfig);\n};\n",
    "import { useCallback, useEffect, useRef } from \"react\";\n\nimport { CloseIcon } from \"./icons\";\nimport { ToolButton } from \"./ToolButton\";\n\nimport \"./Toast.scss\";\n\nimport type { CSSProperties } from \"react\";\n\nconst DEFAULT_TOAST_TIMEOUT = 5000;\n\nexport const Toast = ({\n  message,\n  onClose,\n  closable = false,\n  // To prevent autoclose, pass duration as Infinity\n  duration = DEFAULT_TOAST_TIMEOUT,\n  style,\n}: {\n  message: string;\n  onClose: () => void;\n  closable?: boolean;\n  duration?: number;\n  style?: CSSProperties;\n}) => {\n  const timerRef = useRef<number>(0);\n  const shouldAutoClose = duration !== Infinity;\n  const scheduleTimeout = useCallback(() => {\n    if (!shouldAutoClose) {\n      return;\n    }\n    timerRef.current = window.setTimeout(() => onClose(), duration);\n  }, [onClose, duration, shouldAutoClose]);\n\n  useEffect(() => {\n    if (!shouldAutoClose) {\n      return;\n    }\n    scheduleTimeout();\n    return () => clearTimeout(timerRef.current);\n  }, [scheduleTimeout, message, duration, shouldAutoClose]);\n\n  const onMouseEnter = shouldAutoClose\n    ? () => clearTimeout(timerRef?.current)\n    : undefined;\n  const onMouseLeave = shouldAutoClose ? scheduleTimeout : undefined;\n  return (\n    <div\n      className=\"Toast\"\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      style={style}\n    >\n      <p className=\"Toast__message\">{message}</p>\n      {closable && (\n        <ToolButton\n          icon={CloseIcon}\n          aria-label=\"close\"\n          type=\"icon\"\n          onClick={onClose}\n          className=\"close\"\n        />\n      )}\n    </div>\n  );\n};\n",
    "import {\n  getCommonBounds,\n  getElementsInGroup,\n  selectGroupsFromGivenElements,\n} from \"@excalidraw/element\";\nimport { sceneCoordsToViewportCoords } from \"@excalidraw/common\";\n\nimport { flushSync } from \"react-dom\";\n\nimport { actionToggleElementLock } from \"../actions\";\nimport { t } from \"../i18n\";\n\nimport \"./UnlockPopup.scss\";\n\nimport { LockedIconFilled } from \"./icons\";\n\nimport type App from \"./App\";\n\nimport type { AppState } from \"../types\";\n\nconst UnlockPopup = ({\n  app,\n  activeLockedId,\n}: {\n  app: App;\n  activeLockedId: NonNullable<AppState[\"activeLockedId\"]>;\n}) => {\n  const element = app.scene.getElement(activeLockedId);\n\n  const elements = element\n    ? [element]\n    : getElementsInGroup(app.scene.getNonDeletedElementsMap(), activeLockedId);\n\n  if (elements.length === 0) {\n    return null;\n  }\n\n  const [x, y] = getCommonBounds(elements);\n  const { x: viewX, y: viewY } = sceneCoordsToViewportCoords(\n    { sceneX: x, sceneY: y },\n    app.state,\n  );\n\n  return (\n    <div\n      className=\"UnlockPopup\"\n      style={{\n        bottom: `${app.state.height + 12 - viewY + app.state.offsetTop}px`,\n        left: `${viewX - app.state.offsetLeft}px`,\n      }}\n      onClick={() => {\n        flushSync(() => {\n          const groupIds = selectGroupsFromGivenElements(elements, app.state);\n          app.setState({\n            selectedElementIds: elements.reduce(\n              (acc, element) => ({\n                ...acc,\n                [element.id]: true,\n              }),\n              {},\n            ),\n            selectedGroupIds: groupIds,\n            activeLockedId: null,\n          });\n        });\n        app.actionManager.executeAction(actionToggleElementLock);\n      }}\n      title={t(\"labels.elementLock.unlock\")}\n    >\n      {LockedIconFilled}\n    </div>\n  );\n};\n\nexport default UnlockPopup;\n",
    "import React, { useEffect, useState } from \"react\";\n\nimport type { Theme } from \"@excalidraw/element/types\";\n\nimport { defaultLang, languages, setLanguage } from \"../i18n\";\n\nimport { LoadingMessage } from \"./LoadingMessage\";\n\nimport type { Language } from \"../i18n\";\n\ninterface Props {\n  langCode: Language[\"code\"];\n  children: React.ReactElement;\n  theme?: Theme;\n}\n\nexport const InitializeApp = (props: Props) => {\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const updateLang = async () => {\n      await setLanguage(currentLang);\n      setLoading(false);\n    };\n    const currentLang =\n      languages.find((lang) => lang.code === props.langCode) || defaultLang;\n    updateLang();\n  }, [props.langCode]);\n\n  return loading ? <LoadingMessage theme={props.theme} /> : props.children;\n};\n",
    "import clsx from \"clsx\";\n\nimport { useTunnels } from \"../../context/tunnels\";\nimport { useUIAppState } from \"../../context/ui-appState\";\n\nimport \"./FooterCenter.scss\";\n\nconst FooterCenter = ({ children }: { children?: React.ReactNode }) => {\n  const { FooterCenterTunnel } = useTunnels();\n  const appState = useUIAppState();\n  return (\n    <FooterCenterTunnel.In>\n      <div\n        className={clsx(\"footer-center zen-mode-transition\", {\n          \"layer-ui__wrapper__footer-left--transition-bottom\":\n            appState.zenModeEnabled,\n        })}\n      >\n        {children}\n      </div>\n    </FooterCenterTunnel.In>\n  );\n};\n\nexport default FooterCenter;\nFooterCenter.displayName = \"FooterCenter\";\n",
    "import clsx from \"clsx\";\n\nimport { t } from \"../../i18n\";\nimport { Button } from \"../Button\";\nimport { share } from \"../icons\";\nimport { useUIAppState } from \"../../context/ui-appState\";\n\nimport \"./LiveCollaborationTrigger.scss\";\n\nconst LiveCollaborationTrigger = ({\n  isCollaborating,\n  onSelect,\n  ...rest\n}: {\n  isCollaborating: boolean;\n  onSelect: () => void;\n} & React.ButtonHTMLAttributes<HTMLButtonElement>) => {\n  const appState = useUIAppState();\n\n  const showIconOnly = appState.width < 830;\n\n  return (\n    <Button\n      {...rest}\n      className={clsx(\"collab-button\", { active: isCollaborating })}\n      type=\"button\"\n      onSelect={onSelect}\n      style={{ position: \"relative\", width: showIconOnly ? undefined : \"auto\" }}\n      title={t(\"labels.liveCollaboration\")}\n    >\n      {showIconOnly ? share : t(\"labels.share\")}\n      {appState.collaborators.size > 0 && (\n        <div className=\"CollabButton-collaborators\">\n          {appState.collaborators.size}\n        </div>\n      )}\n    </Button>\n  );\n};\n\nexport default LiveCollaborationTrigger;\nLiveCollaborationTrigger.displayName = \"LiveCollaborationTrigger\";\n",
    "import \"./ExcalidrawLogo.scss\";\n\nconst LogoIcon = () => (\n  <svg\n    viewBox=\"0 0 40 40\"\n    fill=\"none\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    className=\"ExcalidrawLogo-icon\"\n  >\n    <path\n      d=\"M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n);\n\nconst LogoText = () => (\n  <svg\n    viewBox=\"0 0 450 55\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    className=\"ExcalidrawLogo-text\"\n  >\n    <path\n      d=\"M429.27 96.74c2.47-1.39 4.78-3.02 6.83-4.95 1.43-1.35 2.73-2.86 3.81-4.51-.66.9-1.4 1.77-2.23 2.59-2.91 2.84-5.72 5.09-8.42 6.87h.01ZM343.6 69.36c.33 3.13.58 6.27.79 9.4.09 1.37.18 2.75.25 4.12-.12-4.46-.27-8.93-.5-13.39-.11-2.08-.24-4.16-.4-6.24-.06 1.79-.11 3.85-.13 6.11h-.01ZM378.47 98.34c.01-.37.07-1.13.01-6.51-.11 1.9-.22 3.81-.31 5.71-.07 1.42-.22 2.91-.16 4.35.39.03.78.07 1.17.1-.92-.85-.76-2.01-.72-3.66l.01.01ZM344.09 86.12c-.09-2.41-.22-4.83-.39-7.24v12.21c.15-.05.32-.09.47-.14.05-1.61-.03-3.23-.09-4.83h.01ZM440.69 66.79c-.22-.34-.45-.67-.69-.99-3.71-4.87-9.91-7.14-15.65-8.55-1.05-.26-2.12-.49-3.18-.71 2.29.59 4.48 1.26 6.64 2.02 7.19 2.54 10.57 5.41 12.88 8.23ZM305.09 72.46l1.2 3.6c.84 2.53 1.67 5.06 2.46 7.61.24.78.5 1.57.73 2.36.22-.04.44-.08.67-.12a776.9 776.9 0 0 1-5.01-13.57c-.02.04-.03.09-.05.13v-.01ZM345.49 90.25v.31c1.48-.42 3.05-.83 4.66-1.2-1.56.25-3.12.52-4.66.89ZM371.02 90.22c0-.57-.04-1.14-.11-1.71-.06-.02-.12-.04-.19-.05-.21-.05-.43-.08-.65-.11.42.16.74.88.95 1.87ZM398.93 54.23c-.13 0-.27-.01-.4-.02l.03.4c.11-.15.23-.27.37-.38ZM401.57 62.28v-.15c-1.22-.24-2.86-.61-3.23-1.25-.09-.15-.18-.51-.27-.98-.09.37-.2.73-.33 1.09 1.24.56 2.52.98 3.83 1.29ZM421.73 88.68c-2.97 1.65-6.28 3.12-9.69 3.68v.18c4.72-.14 11.63-3.85 16.33-8.38-2.04 1.75-4.33 3.24-6.63 4.53l-.01-.01ZM411.28 80.92c-.05-1.2-.09-2.4-.15-3.6-.21 5.66-.46 11.38-.47 14.51.24-.02.48-.04.71-.07.15-3.61.05-7.23-.09-10.83v-.01Z\"\n      transform=\"translate(-144.023 -51.76)\"\n    />\n    <path\n      d=\"M425.38 67.41c-3.5-1.45-7.19-2.57-14.06-3.62.09 1.97.06 4.88-.03 8.12.03.04.06.09.06.15.19 1.36.28 2.73.37 4.1.25 3.77.39 7.55.41 11.33 0 1.38-.01 2.76-.07 4.13 1.4-.25 2.78-.65 4.12-1.15 4.07-1.5 7.94-3.78 11.28-6.54 2.33-1.92 5.13-4.49 5.88-7.58.63-3.53-2.45-6.68-7.97-8.96l.01.02ZM411.35 92.53v-.06l-.34.03c.11.01.22.03.34.03ZM314.26 64.06c-.23-.59-.47-1.17-.7-1.75.57 1.62 1.11 3.25 1.6 4.9l.15.54 2.35 6.05c.32.82.66 1.64.98 2.46-1.38-4.1-2.83-8.17-4.39-12.2h.01ZM156.82 103.07c-.18.13-.38.23-.58.33 1.32-.03 2.66-.2 3.93-.34.86-.09 1.72-.22 2.58-.33-2.12.1-4.12.17-5.94.34h.01ZM210.14 68.88s.03.04.05.07c.18-.31.39-.64.58-.96-.21.3-.42.6-.64.89h.01ZM201.65 82.8c-.5.77-1.02 1.56-1.49 2.37 1.11-1.55 2.21-3.1 3.2-4.59-.23.23-.49.51-.75.79-.32.47-.65.95-.96 1.43ZM194.03 98.66c-.33-.4-.65-.84-1.05-1.17-.24-.2-.07-.49.17-.56-.23-.26-.42-.5-.63-.75 1.51-2.55 3.93-5.87 6.4-9.28-.17-.08-.29-.28-.2-.49.04-.09.09-.17.13-.26-1.21 1.78-2.42 3.55-3.61 5.33-.87 1.31-1.74 2.64-2.54 4-.29.5-.63 1.04-.87 1.61.81.65 1.63 1.27 2.47 1.88-.09-.11-.18-.21-.27-.32v.01ZM307.79 82.93c-1-3.17-2.05-6.32-3.1-9.48-1.62 4.08-3.69 9.17-6.16 15.19 3.32-1.04 6.77-1.87 10.27-2.5-.32-1.08-.67-2.15-1.01-3.21ZM149.5 80.7c.05-1.71.04-3.43 0-5.14-.1 2.26-.16 4.51-.22 6.77-.02.73-.03 1.46-.04 2.19.14-1.27.2-2.55.24-3.82h.02ZM228.98 98.3c.39 1.25.91 3.03.94 3.91.06-.03.12-.07.17-.1.08-1.29-.55-2.65-1.11-3.81ZM307.72 53.36c.81.5 1.53 1.04 2.07 1.49-.38-.8-.78-1.58-1.21-2.35-.17.03-.34.06-.51.11-.43.12-.86.26-1.29.41.35-.01.53.1.94.34ZM283.69 96.14c3.91-7.25 6.89-13.35 8.88-18.15l1.1-2.66c-1.27 2.64-2.56 5.27-3.83 7.9-1.53 3.15-3.06 6.31-4.58 9.47-.87 1.81-1.76 3.62-2.54 5.47.04.02.07.04.11.07.05.05.1.09.15.14.05-.73.27-1.48.71-2.24ZM289.92 103.23s-.04.01-.05.03c0-.02.04-.03.05-.04.05-.05.11-.1.16-.15l.21-.21c-.55 0-1.5-.27-2.55-.72.4.26.8.51 1.22.74.24.13.48.26.73.37.05.02.1.03.14.05a.27.27 0 0 1 .08-.07h.01ZM269.23 68.49c-.39-.19-.82-.48-1.33-.87-3.06-1.56-6.31-2.78-9.36-2.35-3.5.49-5.7 1.11-7.74 2.44 5.71-2.6 12.82-2.07 18.44.79l-.01-.01ZM177.87 53.69l1.06.03c-.96-.22-2-.25-2.89-.3-4.95-.26-9.99.33-14.86 1.19-2.44.43-4.88.95-7.28 1.59 9.09-1.76 15.69-2.77 23.97-2.51ZM219.85 55.51c-.18.12-.36.27-.56.45-.45.53-.86 1.11-1.26 1.66-1.91 2.61-3.71 5.31-5.57 7.95l-.12.18 8.05-10.11c-.18-.05-.36-.1-.55-.13h.01ZM510.71 54.1c.12-.15.29-.3.53-.45.69-.4 3.72-.63 5.87-.74-.36-.02-.73-.04-1.09-.05-1.84-.03-3.67.09-5.49.35.05.3.12.59.18.88v.01ZM510.76 86.02c1.37-3.07 2.49-6.27 3.57-9.46.55-1.64 1.12-3.3 1.6-4.97-1.59 4.01-3.67 9.14-6.2 15.3.24-.08.5-.14.74-.22.1-.22.19-.44.29-.65ZM566.95 75.76c.11-.02.23.03.31.11-.05-.13-.09-.26-.14-.39-.05.09-.11.18-.17.28ZM511.33 86.41c3.08-.89 6.24-1.62 9.46-2.14-1.51-3.98-2.98-7.96-4.39-11.87-.05.15-.09.31-.14.46-1.02 3.32-2.15 6.61-3.39 9.85-.48 1.25-.98 2.49-1.53 3.7h-.01ZM578.24 74.45c.11-.44.23-.87.35-1.31-.31.7-.64 1.39-.97 2.08.09.21.19.4.28.61.12-.46.23-.92.35-1.38h-.01ZM520.62 53.11c-.09 0-.18-.01-.28-.02.38.34.29 1.08.93 2.53l6.65 17.15c2.2 5.68 4.69 11.36 7.41 16.87l1.06 2.17c-2.95-7.05-5.92-14.08-8.87-21.13-1.58-3.79-3.16-7.59-4.7-11.4-.78-1.92-1.73-3.89-2.25-5.91-.03-.1 0-.19.04-.26h.01ZM578.78 77.87c1.45-5.77 3.07-10.43 3.58-13.36.05-.34.16-.88.31-1.55-.67 1.79-1.37 3.56-2.08 5.33-.12.43-.23.86-.35 1.29-.65 2.43-1.29 4.86-1.9 7.3.14.33.29.65.43 1l.01-.01ZM545.3 94.66c.02-.44.03-.83.05-1.12.02-1.01.05-2.02.11-3.02.03-6.66-.46-14.33-1.46-22.8-.13-.42-.27-1.24-.56-2.89 0-.02 0-.04-.01-.06.62 6.61.95 13.25 1.32 19.87.17 3.08.33 6.16.52 9.23.02.25.03.52.04.78l-.01.01ZM580.77 102.81c.13.2.27.38.37.49.27-.11.53-.22.8-.32-.43.09-.82.05-1.17-.16v-.01ZM530.48 104.07h.33c-.36-.13-.71-.32-1.04-.56.14.24.3.47.45.7.06-.08.14-.13.26-.13v-.01ZM542.63 58.82c.06.23.11.47.15.71.14-.33.36-.62.7-.86-.28.05-.57.11-.85.15ZM583.81 57.87c.15-.7.29-1.41.42-2.11-.14.45-.28.9-.42 1.34-.46 1.44-.89 2.89-1.31 4.34.44-1.19.88-2.37 1.31-3.57ZM523.62 91.48c-4.66 1.17-9.05 2.89-14.02 5.27 4.65-1.84 9.48-3.29 14.28-4.63-.09-.22-.17-.41-.26-.64ZM460.64 78.3c-.04-2.9-.11-5.81-.28-8.71-.1-1.68-.17-3.43-.5-5.09-.07.02-.14.03-.2.05.3 6.54.45 12.17.51 17.12.17-.07.34-.14.51-.2 0-1.06-.01-2.11-.03-3.17h-.01ZM470.63 63.24c-3.38-.26-6.81.32-10.1 1.1.41 2.01.47 4.14.57 6.18.18 3.55.25 7.11.27 10.67 3.31-1.38 6.5-3.12 9.3-5.35 1.96-1.56 3.86-3.41 5.02-5.66.73-1.41 1.19-3.22.26-4.65-1.09-1.7-3.46-2.14-5.32-2.29ZM460.29 63.68c1-.24 2.01-.46 3.04-.65-1.15.16-2.37.38-3.71.69v.13c.07-.02.15-.04.22-.05.11-.13.3-.18.45-.11v-.01ZM457.24 100.96c.43-.03.86-.07 1.29-.11.14-.49.27-.99.38-1.49-.44.7-1 1.23-1.67 1.6ZM482.88 104.98c-.18.23-.36.38-.55.47.14.09.27.19.4.28a70.76 70.76 0 0 0 4.37-4.63c.76-.89 1.52-1.81 2.19-2.77-.3-.27-.61-.53-.92-.79-.07 1.94-4.62 6.32-5.49 7.45v-.01Z\"\n      transform=\"translate(-144.023 -51.76)\"\n    />\n    <path\n      d=\"M474.36 63.31c-.4-.16-.84-.27-1.29-.37 1.56.42 3.08 1.22 3.76 2.74.62 1.4.32 2.95-.28 4.32.7-1.22.94-2.34.74-3.47-.24-1.33-1.19-2.54-2.93-3.21v-.01ZM477.34 89.18c-1.2-.81-2.4-1.62-3.6-2.42-.14.1-.26.19-.4.29 1.4.67 2.73 1.39 4 2.13ZM465.88 93.85c.37.25.74.5 1.1.75.46.32.92.65 1.38.97-1.57-1.2-2.01-1.61-2.49-1.72h.01ZM574.92 90.06c-2.28-5.21-4.93-11.13-5.67-12.26-.1-.15-1.57-3.01-1.63-3.08 0 0-.01.02-.02.02.4 1.37 1.09 2.69 1.65 3.99 2.14 4.95 4.36 9.86 6.67 14.73.6 1.26 1.21 2.52 1.83 3.78-.75-2.01-1.64-4.45-2.83-7.18ZM448.73 65.29c.1.2.22.38.34.57.22-.02.43-.06.65-.08v-.08c-.14-.05-.25 0-.99-.41ZM460.16 94.81c-.02.31-.06.59-.1.89-.03 1.71-.33 3.43-.79 5.07.15-.02.3-.03.45-.05.01-.04.02-.08.03-.11.09-.34.15-.69.2-1.03.17-1.07.25-2.16.33-3.24.05-.69.08-1.39.12-2.08-.27.1-.27.26-.24.57v-.02Z\"\n      transform=\"translate(-144.023 -51.76)\"\n    />\n    <path\n      d=\"m328.67 98.12-3.22-6.58c-1.29-2.63-2.53-5.29-3.72-7.97-.25-.85-.52-1.69-.79-2.53-.81-2.57-1.67-5.12-2.55-7.67-1.92-5.53-3.9-11.08-6.32-16.41-.72-1.58-1.46-3.44-2.63-4.79-.03-.17-.16-.29-.34-.36a.282.282 0 0 0-.23-.04c-.06-.01-.12 0-.18.01-.74.06-1.5.38-2.19.61-2.22.77-4.4 1.64-6.63 2.38-.03-.08-.06-.16-.09-.25-.15-.42-.82-.24-.67.19.03.09.07.19.1.28l-.18.06c-.36.11-.28.6 0 .68.18 1.18.63 2.36.98 3.49.03.09.06.17.08.26-.08.23-.17.46-.24.64-.37.98-.79 1.94-1.21 2.9-1.27 2.89-2.62 5.75-3.98 8.6-3.18 6.67-6.44 13.31-9.64 19.97-1.08 2.25-2.2 4.5-3.15 6.81-.13.32.24.5.5.37 1.34 1.33 2.84 2.5 4.4 3.57.65.44 1.31.87 2.01 1.24.4.22.86.48 1.33.5.24.01.35-.19.33-.37.11-.1.21-.21.28-.28.41-.41.81-.84 1.2-1.26.85-.92 1.69-1.87 2.5-2.84 6.31-2.34 12.6-4.31 18.71-5.84 2.14 5.3 3.43 8.43 3.97 9.58.55 1.05 1.15 1.88 1.82 2.52 1.32.56 6.96-.03 9.23-1.96.87-1.28 1.19-2.67.93-4.15-.09-.5-.22-.95-.4-1.33l-.01-.03Zm-20.09-45.61c.43.77.83 1.56 1.21 2.35-.54-.45-1.27-.99-2.07-1.49-.42-.24-.6-.35-.94-.34.43-.15.85-.29 1.29-.41.17-.05.34-.08.51-.11Zm-25.86 45.66c.78-1.85 1.67-3.66 2.54-5.47 1.51-3.16 3.05-6.31 4.58-9.47 1.28-2.63 2.56-5.26 3.83-7.9l-1.1 2.66c-1.99 4.79-4.97 10.9-8.88 18.15-.43.76-.66 1.51-.71 2.24-.05-.05-.1-.09-.15-.14a.259.259 0 0 0-.11-.07Zm6.24 4.71c-.42-.23-.82-.48-1.22-.74 1.05.45 2 .72 2.55.72l-.21.21c-.05.05-.11.1-.16.15-.01.01-.04.03-.05.04 0-.02.03-.02.05-.03a.27.27 0 0 0-.08.07c-.05-.02-.1-.03-.14-.05-.25-.1-.49-.24-.73-.37h-.01Zm15.73-29.43c1.05 3.15 2.1 6.31 3.1 9.48.34 1.06.69 2.13 1.01 3.21-3.5.63-6.95 1.46-10.27 2.5 2.48-6.03 4.54-11.11 6.16-15.19Zm4.79 12.57c-.23-.79-.49-1.58-.73-2.36-.79-2.54-1.63-5.08-2.46-7.61l-1.2-3.6c.02-.04.04-.09.05-.13 1.6 4.45 3.28 9 5.01 13.57l-.67.12v.01Zm5.83-18.27-.15-.54c-.49-1.64-1.03-3.28-1.6-4.9.23.58.47 1.17.7 1.75 1.56 4.03 3.01 8.1 4.39 12.2-.33-.82-.67-1.64-.98-2.46l-2.35-6.05h-.01ZM390.43 79.37c-.13-10.43-.22-17.5-.24-19.97-.24-1.6.21-2.88-.65-3.65-.14-.13-.32-.23-.52-.32h.03c.45 0 .45-.69 0-.7-1.75-.03-3.5-.04-5.25-.14-1.38-.08-2.76-.21-4.15-.31-.07 0-.12.01-.17.04-.21-.07-.47.03-.45.31l.03.45c-.11.14-.19.3-.22.5-.21 1.26-.32 13.67-.36 23.59-.32 5.79-.67 11.57-.97 17.36-.09 1.73-.29 3.54-.21 5.3-.39.02-.38.64.04.69v.12c.05.44.74.45.7 0v-.06c1.1.09 2.2.21 3.3.3 1.14.19 2.44.2 3.29.17 1.73-.05 2.92-.05 3.8-.37.45-.05.9-.11 1.35-.17.44-.06.25-.73-.19-.67h-.01c.24-.32.45-.72.62-1.25.66-1.84.41-6.36.34-11.33l-.13-9.9.02.01Zm-12.26 18.17c.09-1.91.2-3.81.31-5.71.06 5.38 0 6.14-.01 6.51-.05 1.65-.21 2.81.72 3.66-.39-.04-.78-.07-1.17-.1-.06-1.44.09-2.93.16-4.35l-.01-.01ZM588.97 53.85c-2.06-.25-3.17-.51-3.76-.6a.3.3 0 0 1 .04-.08c.22-.39-.39-.75-.6-.35-.56 1.02-.9 2.19-1.26 3.29-.61 1.88-1.17 3.78-1.72 5.68-.63 2.19-1.24 4.39-1.83 6.59-.81 2.03-1.67 4.05-2.61 6.03-1.7-3.64-3.11-6.04-4.03-7.57-2.26-3.74-2.85-5.48-3.57-6.08l.31-.09c.43-.12.25-.8-.19-.67-1.06.3-2.12.6-3.17.95-.93.32-1.85.69-2.76 1.07-.13.05-.19.16-.22.27-.04.02-.08.05-.11.07-.04-.06-.07-.12-.11-.18a.354.354 0 0 0-.48-.12c-.16.09-.22.32-.13.48l.33.54c0 .09.02.18.06.28.51 1.16.78 1.38.72 1.47-2.42 3.44-5.41 7.86-6.2 9.1-1.27 1.97-2.01 3.14-2.45 3.84l-.91-6.56-.43-4.1c-.19-1.85-.37-3.23-.53-4.13-.19-1.1-.3-2.15-.45-3.16-.2-1.36-.29-2.06-.47-2.42h.04c.45.02.45-.68 0-.7-3.43-.16-6.81.94-10.17 1.48-.24-.22-.73-.04-.58.32.24.59.33 1.25.43 1.87.17 1.06.29 2.13.4 3.2.32 3.09.53 6.2.74 9.3.44 6.75.77 13.51 1.17 20.26.11 1.95.13 3.96.46 5.89.05.3.37.31.55.14.74 1.71 2.87 1.27 6.13 1.27 1.34 0 2.39.04 2.99-.11.02.32.48.53.63.18 3.61-8.26 7.41-16.46 12.05-24.2.03-.05.04-.1.05-.15.3.73.64 1.45.94 2.16.97 2.26 1.97 4.52 2.98 6.76 2.26 5.03 4.54 10.07 7.09 14.96.47.9.94 1.79 1.47 2.65.2.32.4.67.66.96-.18.25 0 .68.34.54.91-.38 1.82-.75 2.76-1.07 1.04-.35 2.11-.65 3.17-.95.39-.11.28-.66-.07-.68.62-.4.95-.96.87-1.91-.3-3.34.72-7.47.86-8.52l2.14-11.43c1.75-10.74 3.13-17.51 3.23-20.86.02-.49.08-2.84.13-3.24.17-1.25.48-1-4.96-1.65l.03-.02Zm-46.19 5.67c-.04-.24-.09-.48-.15-.71l.85-.15c-.34.24-.56.53-.7.86Zm1.95 25.12c-.36-6.63-.7-13.26-1.32-19.87 0 .02 0 .04.01.06.29 1.65.44 2.47.56 2.89 1 8.46 1.5 16.14 1.46 22.8-.06.99-.1 2-.11 3.02-.01.29-.03.68-.05 1.12-.01-.26-.03-.53-.04-.78-.19-3.08-.35-6.16-.52-9.23l.01-.01Zm36.4 18.66c-.11-.11-.24-.29-.37-.49.35.21.74.26 1.17.16-.27.11-.53.22-.8.32v.01Zm-.89-33.72c.12-.43.23-.86.35-1.29.71-1.77 1.41-3.55 2.08-5.33-.15.68-.26 1.22-.31 1.55-.5 2.94-2.13 7.59-3.58 13.36-.15-.35-.29-.66-.43-1 .61-2.44 1.25-4.87 1.9-7.3l-.01.01Zm3.56-12.48c.14-.44.28-.89.42-1.34-.13.7-.27 1.41-.42 2.11-.43 1.19-.86 2.38-1.31 3.57.42-1.45.85-2.9 1.31-4.34Zm-5.22 16.05c-.11.44-.23.87-.35 1.31-.12.46-.23.92-.35 1.38-.1-.22-.19-.4-.28-.61.34-.69.66-1.38.97-2.08h.01Zm-11.64 2.62c.06-.1.12-.19.17-.28.05.13.09.26.14.39a.398.398 0 0 0-.31-.11Zm2.3 2.98c-.56-1.3-1.25-2.63-1.65-3.99 0 0 .01-.02.02-.02.06.08 1.52 2.93 1.63 3.08.73 1.13 3.38 7.04 5.67 12.26 1.2 2.73 2.08 5.17 2.83 7.18-.62-1.25-1.23-2.51-1.83-3.78-2.31-4.87-4.53-9.78-6.67-14.73ZM275.92 87.03c-1.06-2.18-1.13-3.45-2.44-2.93-1.52.57-2.94 1.3-4.5 2.1-1.4.72-2.68 1.44-3.92 2.12.01-.25-.24-.5-.51-.34-4.8 2.93-12.41 4.7-17.28 1.31-1.98-1.77-3.32-4.15-3.97-5.78-.29-.95-.49-1.94-.63-2.93-.14-3.34 1.58-6.53 3.9-9.12.8-.79 1.68-1.51 2.66-2.12 3.7-2.3 8.22-3.07 12.51-2.51 2.71.35 5.32 1.24 7.71 2.55.39.22.75-.39.35-.6-.18-.1-.37-.18-.55-.27.56.27 1.03.33 1.51.19l-.48.39c-.15.11-.23.3-.13.48.09.15.33.24.48.13 1.3-.97 2.46-2.09 3.45-3.37.37-.29.64-.6.65-.97v-.02c.08-.33-.03-.7-.21-1.08-.31-.87-.98-2.01-2.19-3.26-2.43-2.52-3.79-3.45-5.68-4.26-1.14-.49-3.12-1.06-4.42-1.23-3.28-.42-10.64-1.21-18.18 4.11-7.74 5.46-11.94 12.3-12.23 20.61-.08 2.06.04 3.98.34 5.71.74 4.18 2.57 8 5.44 11.34 4.26 4.99 9.76 7.52 16.34 7.52 4.85 0 9.69-1.77 14.89-4.62.23-.12.45-.23.68-.35 2.19-1.1 4.37-2.23 6.46-3.5.49-.3 1.03-.61 1.5-.98 1.47-.87 1.11-1.12.49-2.95-.39-1.14-.76-2.7-2.06-5.36l.02-.01Zm-17.38-21.76c3.05-.42 6.31.79 9.36 2.35.51.39.94.68 1.33.87-5.61-2.86-12.72-3.39-18.44-.79 2.05-1.33 4.24-1.95 7.74-2.44l.01.01ZM443.67 72.67c-.4-2.2-1.15-4.33-2.37-6.22-1.49-2.32-3.58-4.19-5.91-5.64-6.17-3.81-13.75-5.11-20.83-6.01-3.23-.41-6.47-.69-9.72-.92l-1.39-.12c-.85-.07-1.52-.1-2.05-.1-1.08-.06-2.17-.12-3.25-.17-.08 0-.14.02-.19.05-.1.05-.18.14-.16.3.27 2.55-.01 5.12-.92 7.52-.15.38.4.56.62.28 1.32.59 2.68 1.05 4.08 1.37 0 2.78-.14 7.58-.33 12.91 0 0 0 .02-.01.03-.61 3.66-.79 7.42-1 11.12-.23 4.01-.43 8.03-.44 12.05 0 .64 0 1.28.03 1.93.02.31 0 .68.15.96.06.11.14.16.24.17-.2.17-.21.54.11.59 3.83.67 7.78.71 11.68.25 2.3-.19 4.87-.65 7.65-1.56 1.85-.54 3.67-1.18 5.43-1.91 7.2-3.02 14.31-8.07 17.35-15.53.76-1.86 1.17-3.8 1.31-5.75.3-1.93.28-3.82-.09-5.58l.01-.02Zm-19.32-15.42c5.74 1.41 11.94 3.68 15.65 8.55.25.32.47.65.69.99-2.3-2.82-5.68-5.69-12.88-8.23-2.16-.76-4.35-1.43-6.64-2.02 1.06.21 2.13.45 3.18.71Zm-25.82-3.04c.13 0 .27.01.4.02-.14.1-.26.23-.37.38 0-.13-.02-.26-.03-.4Zm34.82 22.17c-.75 3.09-3.55 5.66-5.88 7.58-3.35 2.76-7.21 5.03-11.28 6.54-1.33.49-2.71.9-4.12 1.15.06-1.38.08-2.76.07-4.13-.02-3.78-.16-7.56-.41-11.33-.09-1.37-.18-2.74-.37-4.1 0-.06-.03-.11-.06-.15.09-3.25.12-6.16.03-8.12 6.86 1.05 10.56 2.17 14.06 3.62 5.52 2.28 8.59 5.44 7.97 8.96l-.01-.02Zm-22 16.15c-.12 0-.23-.02-.34-.03l.34-.03v.06Zm-.69-.7c0-3.13.26-8.84.47-14.51.06 1.2.11 2.41.15 3.6.15 3.6.25 7.23.09 10.83-.24.03-.48.05-.71.07v.01Zm-12.33-30.94c.37.63 2.01 1.01 3.23 1.25v.15c-1.31-.31-2.59-.73-3.83-1.29.12-.36.23-.72.33-1.09.08.48.18.84.27.98Zm13.7 31.65v-.18c3.41-.56 6.71-2.02 9.69-3.68 2.31-1.28 4.59-2.78 6.63-4.53-4.69 4.53-11.61 8.24-16.33 8.38l.01.01Zm24.07-.75c-2.05 1.93-4.37 3.56-6.83 4.95 2.7-1.78 5.52-4.03 8.42-6.87.82-.82 1.56-1.69 2.23-2.59-1.08 1.65-2.38 3.16-3.81 4.51h-.01ZM187.16 92.14c-.79-2.47-2.1-7.12-3.1-6.87-.19-.01-2.09.77-4.08 1.54-3.06 1.18-5.91 2.13-10.09 2.82-2.74.42-5.87 1.01-10.61 1.06.04-3.34.05-6.01.05-7.99 7.97-.65 12.33-2.11 16.37-3.55 1.11-.39 2.69-1.01 2.63-1.8-.08-.35-.55-1.39-1.17-2.61-.47-1.16-.98-2.31-1.61-3.38-.42-.71-1.04-1.69-1.86-2.06-.11-.08-.22-.13-.29-.12-.02 0-.04 0-.07.01-.19-.04-.39-.05-.6-.01-.17.03-.24.15-.25.28-.04.02-.09.04-.14.05-4.33 1.48-8.85 2.33-13.24 3.61a499.1 499.1 0 0 0-.31-8.19c4.51-.99 8.88-1.38 13.11-1.82 3.68-.38 6.28.12 7.47.34.59.11.9.16 1.16.18h.1c-.1.37.44.66.62.28.02-.04.03-.08.05-.13.15.2.53.22.62-.1.17-.58.19-1.21.21-1.81v-.36c.03-.15.05-.3.07-.45.52-2.47.33-5.09-.64-7.44-.11-.27-.44-.28-.6-.14-.08-.21-.15-.42-.24-.62-.19-.41-.79-.05-.6.35.03.07.05.15.09.22-.98-.42-2.15-.54-3.17-.63-2.17-.19-4.37-.14-6.54 0-5.7.35-11.4 1.3-16.91 2.79-2.08.56-4.13 1.22-6.14 2-4.54 1.05-3.79 1.51-2.17 6.07.18.51.46 1.68.54 1.94.82 2.47 1.08 2.13 3.1 2.13s0 .05 0 .08h.52c-.48 2.66-.51 5.45-.62 8.13-.15 3.48-.22 6.96-.28 10.45 0 .41-.01.82-.02 1.23-.16.29-.33.57-.51.85-.05.38-.09.77-.14 1.18-.42 3.52-.59 6.48-.52 8.8v.34c.02.47.05.76.06.87.16 1.57-.26 3.47 1.35 3.79 1.61.32 3.5.55 4.85.55.11 0 .22-.02.33-.02 1.79.24 3.67.05 5.45-.12 2.85-.28 5.69-.7 8.51-1.19 3.03-.53 6.05-1.14 9.04-1.86 2.4-.58 4.82-1.19 7.13-2.06.51-.19 1.73-.57 2.46-1.14 1.81-.68 2.18-1 1.57-2.67-.23-.62-.48-1.49-.91-2.78l-.03-.02Zm-11.12-38.71c.89.05 1.93.08 2.89.3-.33 0-.68-.02-1.06-.03-8.28-.26-14.88.75-23.97 2.51 2.41-.64 4.85-1.16 7.28-1.59 4.87-.86 9.91-1.45 14.86-1.19Zm-26.53 22.13c.03 1.71.04 3.43 0 5.14-.04 1.27-.11 2.55-.24 3.82 0-.73.02-1.46.04-2.19.05-2.26.12-4.51.22-6.77h-.02Zm6.73 27.85c.2-.1.4-.21.58-.33 1.82-.17 3.82-.24 5.94-.34-.86.11-1.72.24-2.58.33-1.27.14-2.61.31-3.93.34h-.01ZM534.48 85.44c-3.52-8.38-7.07-16.75-10.5-25.17-.63-1.54-1.25-3.09-1.86-4.65-.31-.8-.65-1.6-.87-2.43-.04-.17-.17-.24-.31-.25.1-.2 0-.51-.29-.53-1.59-.08-3.18-.22-4.78-.25-1.96-.03-3.91.13-5.84.42-.31.05-.31.38-.13.56-.03.06-.05.14-.04.22.23 1.54.63 3.06 1.16 4.53.13.35.27.7.41 1.06l-2.68 6.18c-.11.03-.2.09-.25.22-.67 1.9-1.52 3.73-2.34 5.56a536.85 536.85 0 0 1-3.9 8.45c-2.64 5.64-5.34 11.25-7.91 16.93-.44.97-.88 1.94-1.29 2.93-.2.48-.47 1-.55 1.52v.05c-.02.12.02.26.16.34 1.19.73 2.41 1.41 3.66 2.05 1.2.62 2.45 1.25 3.76 1.61.43.12.62-.55.19-.67-1.13-.31-2.2-.83-3.24-1.36 1.09.36 2.1.69 2.75.93 2.82 1.01 2.38 1.1 4.3-3.75 2.1-1.09 4.34-1.96 6.53-2.79 4.35-1.64 8.8-3.03 13.27-4.29.82 2.01 1.77 3.97 2.72 5.92.35.83.62 1.45.79 1.82.22.42.45.8.69 1.15.17.33.33.67.5 1 .42.8.84 1.63 1.4 2.35.23.29.6 0 .55-.31 1.53-.02 3.06-.07 4.58-.27.92-.12 1.82-.32 2.71-.54 1.39-.27 3.85-1.11 3.74-1.42-.67-1.96-1.55-3.87-2.34-5.78-1.57-3.78-3.16-7.56-4.75-11.33v-.01Zm-11.65-26.16c1.54 3.81 3.12 7.6 4.7 11.4 2.94 7.05 5.91 14.09 8.87 21.13l-1.06-2.17c-2.71-5.51-5.2-11.19-7.41-16.87l-6.65-17.15c-.65-1.45-.55-2.19-.93-2.53.09 0 .18.01.28.02a.29.29 0 0 0-.04.26c.52 2.02 1.47 3.98 2.25 5.91h-.01Zm-6.58 13.58c.05-.15.09-.31.14-.46 1.41 3.92 2.88 7.9 4.39 11.87-3.22.52-6.38 1.25-9.46 2.14.55-1.22 1.05-2.46 1.53-3.7 1.24-3.24 2.37-6.53 3.39-9.85h.01Zm-.23-20c.36 0 .73.03 1.09.05-2.15.1-5.18.33-5.87.74-.24.15-.41.3-.53.45-.06-.29-.13-.58-.18-.88 1.82-.26 3.65-.39 5.49-.35v-.01Zm-.09 18.72c-.49 1.67-1.05 3.33-1.6 4.97-1.07 3.19-2.19 6.38-3.57 9.46-.09.21-.19.43-.29.65-.25.07-.5.14-.74.22 2.53-6.16 4.61-11.29 6.2-15.3Zm-6.34 25.16c4.97-2.38 9.37-4.1 14.02-5.27l.26.64c-4.8 1.35-9.63 2.8-14.28 4.63Zm20.17 6.76c.33.23.68.42 1.04.56h-.33c-.12 0-.21.06-.26.13-.15-.23-.31-.45-.45-.7v.01ZM226.57 91.75c-3.55-4.74-6.68-9.11-9.31-12.99 9.2-15.25 10.05-17.81 10.35-18.38.17-.34 1.09-2.27.64-2.53-1.13-.65-1.03-.65-2.97-1.71-1.19-.65-3.04-1.61-4.53-2.12-1.71-.59-1.24-.36-3 2.77-.06.1-.11.2-.17.3-.75 1.02-1.48 2.05-2.2 3.09-1.88 2.71-3.73 5.45-5.69 8.1-3.68-4.91-6.88-8.76-9.51-11.43-.15-.15-.3-.29-.46-.42-1.27-1.28-7.24 3.53-7.93 5.58-.09.09-.19.16-.28.25-.27.26.03.64.33.58.19.65.5 1.29.94 1.91 3.85 5.06 7.19 9.76 9.94 14-1.23 2.61-3.06 5-4.67 7.38l-2.28 3.33c-.5.66-.93 1.23-1.29 1.69-.67.93-2.09 2.61-2.3 3.87-.51.85-1.16 1.84-1.29 2.83-.06.44.61.63.67.19.01-.08.04-.15.06-.22 1.36 1.08 2.76 2.11 4.19 3.11 1.3.91 2.62 1.85 4.04 2.56.21.1.4 0 .48-.17.24.07.48.14.72.2.44.1.62-.57.19-.67-2.02-.48-3.77-1.57-5.23-3.02-.47-.46-.9-.96-1.32-1.46 1.74 1.35 4.2 2.89 5.89 4.14 1.39 1.03 2.85-2.27 4.22-4.2 1.86-2.64 3.96-5.86 5.52-8.29l10.39 14.51c.67.81 1.14 1.21 1.57 1.36-.05.24.12.51.41.4 1.53-.58 3.05-1.19 4.54-1.87 1.52-.69 3.06-1.45 4.36-2.5a.28.28 0 0 0 .12-.23c1.66-1.1.81-1.74-1.41-4.91-1.13-1.58-1.71-2.36-3.7-5.01l-.03-.02Zm2.41 6.54c.56 1.15 1.19 2.52 1.11 3.81-.06.04-.12.07-.17.1-.03-.88-.55-2.66-.94-3.91Zm-16.51-32.73c1.86-2.65 3.65-5.35 5.57-7.95.4-.55.81-1.13 1.26-1.66.19-.18.38-.33.56-.45.18.03.36.08.55.13l-8.05 10.11.12-.18h-.01ZM192.7 95.48c.79-1.37 1.66-2.69 2.54-4 1.19-1.79 2.4-3.56 3.61-5.33-.04.09-.09.17-.13.26-.1.22.03.41.2.49-2.47 3.42-4.89 6.73-6.4 9.28.21.24.4.48.63.75-.24.07-.4.36-.17.56.4.33.72.77 1.05 1.17.09.11.18.21.27.32-.84-.61-1.66-1.24-2.47-1.88.24-.57.58-1.11.87-1.61v-.01Zm7.46-10.32c.47-.81.98-1.59 1.49-2.37.31-.48.64-.95.96-1.43.26-.29.52-.56.75-.79-.99 1.48-2.09 3.03-3.2 4.59Zm10.03-16.22s-.03-.05-.05-.07c.22-.29.43-.59.64-.89-.2.32-.4.65-.58.96h-.01ZM371.54 87.96c-.01-.08-.01-.16-.03-.23-.06-.38-.58-.29-.66.03-.3-.05-.6-.08-.81-.11-1.14-.15-2.29-.19-3.44-.2 1.04-.09 2.09-.18 3.14-.23.45-.02.45-.72 0-.7-6.57.35-13.14 1.23-19.65 2.11-1.53.21-3.05.42-4.57.68-.01 0-.02.01-.04.01-.04-3.33-.13-6.66-.24-9.99-.19-5.7-.4-11.41-.88-17.1-.13-1.51-.23-3.07-.49-4.58 0-.25 0-.48-.02-.68-.06-1.19-.04-2.61-.68-2.78-.16-.07-.72-.16-1.5-.24.22-.17.16-.62-.2-.63-1.19-.04-2.39.09-3.57.23-1.2.14-2.41.32-3.59.6-.16-.1-.41-.06-.5.12-.06.02-.13.03-.19.05-.35.1-.29.55-.03.66-.26.6-.19 2.27-.21 3-.02.66-.66 33.73-.9 40.3-.03.65.06 1.12.04 1.45-.16 3.05.87 4.96 6.34 3.93 1.09-.08 2.75-.77 5.36-1.43 4.13-1.04 5.78-1.52 6.2-1.65 6.43-1.69 6.78-1.97 11.72-2.43.55-.05 4.8-.38 6.03-.3.64.04 1.19.07 1.65.1.09 0 .16-.03.24-.05.1.27.56.33.66-.02.39-1.32.61-2.71.78-4.08.2-1.61.29-3.24.15-4.86.24.03.52-.23.38-.53-.09-.2-.27-.33-.49-.43v-.02Zm-.63.56c.07.57.11 1.14.11 1.71-.21-.99-.53-1.71-.95-1.87.22.03.44.06.65.11.06.01.12.04.19.05Zm-25.41 1.73c1.54-.36 3.1-.64 4.66-.89-1.61.37-3.18.77-4.66 1.2v-.31Zm-.86-7.37c-.07-1.37-.16-2.75-.25-4.12-.21-3.13-.45-6.27-.79-9.4.02-2.25.08-4.31.13-6.11.16 2.08.29 4.16.4 6.24.23 4.46.38 8.93.5 13.39h.01Zm-.94-4c.16 2.41.29 4.83.39 7.24.06 1.6.14 3.22.09 4.83-.15.05-.32.09-.47.14V78.88h-.01ZM483.72 92.83c-3.05-2.28-6.22-4.4-9.38-6.51 8.86-6.49 13.49-12.95 13.73-19.23.04-.76 0-1.5-.13-2.2-.67-3.82-3.5-6.68-8.39-8.48.13.04.27.08.4.13 3.92 1.39 7.74 4.23 8.5 8.56.34 1.95-.05 3.96-.98 5.69-.21.4.39.75.6.35 1.86-3.46 1.46-7.55-.97-10.63-3.53-4.47-9.76-5.88-15.16-6.16-2.32-.12-4.64-.04-6.95.19-6 .32-12.71 1.68-17.63 3.21-.37.11-.67.23-.92.35-.2-.17-.62.02-.57.37v.03c-.64.68-.18 1.64.48 3.21.38.91.67 1.89 1.15 2.58.32.76.68 1.51 1.13 2.19.14.21.38.19.53.07.19-.02.38-.05.57-.08v1.57c-.06.06-.1.13-.11.23-.27 4.18-.34 8.38-.48 12.57l-.3 9.03c-.24 3.91-.44 6.77-.46 7.26-.05.88-.11 1.95.07 2.81-.01.22-.02.43-.04.65 0 .11-.02.23-.03.35 0 .05-.03.27-.01.16-.05.4.5.59.64.28.05.04.12.08.2.08 1.75.13 3.5.28 5.25.3 1.69.02 3.38-.12 5.06-.32.08.23.36.39.55.15.06-.08.11-.17.16-.26.18-.09.24-.32.18-.48.05-.2.1-.4.13-.6.16-.86.25-1.74.33-2.62.11-1.17.17-2.34.23-3.51.15-.01.32-.03.52-.04.36-.03 1.73-.15 2.06-.15.39 0 .7-.02.95-.04 1.76 1.11 3.45 2.35 5.14 3.55 2.83 2.01 5.64 4.04 8.47 6.04 1.42 1 2.85 2 4.29 2.97.1.06.19.07.27.04.08 0 .17-.02.25-.1 1.61-1.56 3.15-3.18 4.6-4.88.75-.88 1.49-1.78 2.15-2.73.01.01.03.02.04.03.34.3.83-.2.49-.49-2.16-1.9-4.34-3.76-6.64-5.48l.03-.01Zm-6.38-3.65a55.72 55.72 0 0 0-4-2.13c.14-.1.26-.19.4-.29 1.2.81 2.4 1.61 3.6 2.42Zm-20.1 11.78c.67-.37 1.23-.91 1.67-1.6-.11.5-.24 1-.38 1.49-.43.04-.86.08-1.29.11Zm2.38-37.24c1.34-.31 2.56-.52 3.71-.69-1.03.19-2.04.41-3.04.65-.14-.07-.34-.02-.45.11-.07.02-.15.04-.22.05v-.13.01Zm.04.84c.07-.02.14-.03.2-.05.34 1.66.41 3.41.5 5.09.17 2.9.24 5.81.28 8.71l.03 3.17c-.17.07-.34.14-.51.2-.06-4.96-.21-10.58-.51-17.12h.01Zm16.04 5.62c-1.16 2.25-3.06 4.1-5.02 5.66-2.8 2.23-5.99 3.97-9.3 5.35-.01-3.56-.09-7.12-.27-10.67-.1-2.04-.16-4.16-.57-6.18 3.3-.78 6.72-1.36 10.1-1.1 1.85.14 4.23.59 5.32 2.29.92 1.43.46 3.24-.26 4.65Zm.85-.18c.6-1.37.9-2.92.28-4.32-.67-1.52-2.2-2.32-3.76-2.74.46.1.89.21 1.29.37 1.74.67 2.69 1.88 2.93 3.21.2 1.13-.05 2.25-.74 3.47V70Zm-27.47-4.14c-.12-.19-.23-.38-.34-.57.74.42.85.36.99.41v.08c-.22.03-.43.06-.65.08Zm11.21 30.46c-.08 1.08-.16 2.17-.33 3.24-.05.35-.11.69-.2 1.03 0 .04-.02.07-.03.11-.15.02-.3.04-.45.05.45-1.64.76-3.36.79-5.07.03-.29.08-.57.1-.89-.03-.31-.03-.47.24-.57-.04.69-.07 1.39-.12 2.08v.02Zm5.6-2.47c.48.11.92.52 2.49 1.72-.46-.32-.92-.65-1.38-.97-.37-.25-.73-.5-1.1-.75h-.01Zm21.23 7.24a70.76 70.76 0 0 1-4.37 4.63c-.14-.09-.27-.19-.4-.28.19-.09.37-.24.55-.47.87-1.14 5.43-5.51 5.49-7.45.31.26.62.53.92.79-.67.97-1.42 1.88-2.19 2.77v.01Z\"\n      fill=\"currentColor\"\n      transform=\"translate(-144.023 -51.76)\"\n    />\n  </svg>\n);\n\ntype LogoSize = \"xs\" | \"small\" | \"normal\" | \"large\" | \"custom\";\n\ninterface LogoProps {\n  size?: LogoSize;\n  withText?: boolean;\n  style?: React.CSSProperties;\n  /**\n   * If true, the logo will not be wrapped in a Link component.\n   * The link prop will be ignored as well.\n   * It will merely be a plain div.\n   */\n  isNotLink?: boolean;\n}\n\nexport const ExcalidrawLogo = ({\n  style,\n  size = \"small\",\n  withText,\n}: LogoProps) => {\n  return (\n    <div className={`ExcalidrawLogo is-${size}`} style={style}>\n      <LogoIcon />\n      {withText && <LogoText />}\n    </div>\n  );\n};\n",
    "import { actionLoadScene, actionShortcuts } from \"../../actions\";\nimport { getShortcutFromShortcutName } from \"../../actions/shortcuts\";\nimport { useTunnels } from \"../../context/tunnels\";\nimport { useUIAppState } from \"../../context/ui-appState\";\nimport { t, useI18n } from \"../../i18n\";\nimport { useDevice, useExcalidrawActionManager } from \"../App\";\nimport { ExcalidrawLogo } from \"../ExcalidrawLogo\";\nimport { HelpIcon, LoadIcon, usersIcon } from \"../icons\";\n\nimport type { JSX } from \"react\";\n\nconst WelcomeScreenMenuItemContent = ({\n  icon,\n  shortcut,\n  children,\n}: {\n  icon?: JSX.Element;\n  shortcut?: string | null;\n  children: React.ReactNode;\n}) => {\n  const device = useDevice();\n  return (\n    <>\n      <div className=\"welcome-screen-menu-item__icon\">{icon}</div>\n      <div className=\"welcome-screen-menu-item__text\">{children}</div>\n      {shortcut && !device.editor.isMobile && (\n        <div className=\"welcome-screen-menu-item__shortcut\">{shortcut}</div>\n      )}\n    </>\n  );\n};\nWelcomeScreenMenuItemContent.displayName = \"WelcomeScreenMenuItemContent\";\n\nconst WelcomeScreenMenuItem = ({\n  onSelect,\n  children,\n  icon,\n  shortcut,\n  className = \"\",\n  ...props\n}: {\n  onSelect: () => void;\n  children: React.ReactNode;\n  icon?: JSX.Element;\n  shortcut?: string | null;\n} & React.ButtonHTMLAttributes<HTMLButtonElement>) => {\n  return (\n    <button\n      {...props}\n      type=\"button\"\n      className={`welcome-screen-menu-item ${className}`}\n      onClick={onSelect}\n    >\n      <WelcomeScreenMenuItemContent icon={icon} shortcut={shortcut}>\n        {children}\n      </WelcomeScreenMenuItemContent>\n    </button>\n  );\n};\nWelcomeScreenMenuItem.displayName = \"WelcomeScreenMenuItem\";\n\nconst WelcomeScreenMenuItemLink = ({\n  children,\n  href,\n  icon,\n  shortcut,\n  className = \"\",\n  ...props\n}: {\n  children: React.ReactNode;\n  href: string;\n  icon?: JSX.Element;\n  shortcut?: string | null;\n} & React.AnchorHTMLAttributes<HTMLAnchorElement>) => {\n  return (\n    <a\n      {...props}\n      className={`welcome-screen-menu-item ${className}`}\n      href={href}\n      target=\"_blank\"\n      rel=\"noopener\"\n    >\n      <WelcomeScreenMenuItemContent icon={icon} shortcut={shortcut}>\n        {children}\n      </WelcomeScreenMenuItemContent>\n    </a>\n  );\n};\nWelcomeScreenMenuItemLink.displayName = \"WelcomeScreenMenuItemLink\";\n\nconst Center = ({ children }: { children?: React.ReactNode }) => {\n  const { WelcomeScreenCenterTunnel } = useTunnels();\n  return (\n    <WelcomeScreenCenterTunnel.In>\n      <div className=\"welcome-screen-center\">\n        {children || (\n          <>\n            <Logo />\n            <Heading>{t(\"welcomeScreen.defaults.center_heading\")}</Heading>\n            <Menu>\n              <MenuItemLoadScene />\n              <MenuItemHelp />\n            </Menu>\n          </>\n        )}\n      </div>\n    </WelcomeScreenCenterTunnel.In>\n  );\n};\nCenter.displayName = \"Center\";\n\nconst Logo = ({ children }: { children?: React.ReactNode }) => {\n  return (\n    <div className=\"welcome-screen-center__logo excalifont welcome-screen-decor\">\n      {children || <ExcalidrawLogo withText />}\n    </div>\n  );\n};\nLogo.displayName = \"Logo\";\n\nconst Heading = ({ children }: { children: React.ReactNode }) => {\n  return (\n    <div className=\"welcome-screen-center__heading welcome-screen-decor excalifont\">\n      {children}\n    </div>\n  );\n};\nHeading.displayName = \"Heading\";\n\nconst Menu = ({ children }: { children?: React.ReactNode }) => {\n  return <div className=\"welcome-screen-menu\">{children}</div>;\n};\nMenu.displayName = \"Menu\";\n\nconst MenuItemHelp = () => {\n  const actionManager = useExcalidrawActionManager();\n\n  return (\n    <WelcomeScreenMenuItem\n      onSelect={() => actionManager.executeAction(actionShortcuts)}\n      shortcut=\"?\"\n      icon={HelpIcon}\n    >\n      {t(\"helpDialog.title\")}\n    </WelcomeScreenMenuItem>\n  );\n};\nMenuItemHelp.displayName = \"MenuItemHelp\";\n\nconst MenuItemLoadScene = () => {\n  const appState = useUIAppState();\n  const actionManager = useExcalidrawActionManager();\n\n  if (appState.viewModeEnabled) {\n    return null;\n  }\n\n  return (\n    <WelcomeScreenMenuItem\n      onSelect={() => actionManager.executeAction(actionLoadScene)}\n      shortcut={getShortcutFromShortcutName(\"loadScene\")}\n      icon={LoadIcon}\n    >\n      {t(\"buttons.load\")}\n    </WelcomeScreenMenuItem>\n  );\n};\nMenuItemLoadScene.displayName = \"MenuItemLoadScene\";\n\nconst MenuItemLiveCollaborationTrigger = ({\n  onSelect,\n}: {\n  onSelect: () => any;\n}) => {\n  const { t } = useI18n();\n  return (\n    <WelcomeScreenMenuItem shortcut={null} onSelect={onSelect} icon={usersIcon}>\n      {t(\"labels.liveCollaboration\")}\n    </WelcomeScreenMenuItem>\n  );\n};\nMenuItemLiveCollaborationTrigger.displayName =\n  \"MenuItemLiveCollaborationTrigger\";\n\n// -----------------------------------------------------------------------------\n\nCenter.Logo = Logo;\nCenter.Heading = Heading;\nCenter.Menu = Menu;\nCenter.MenuItem = WelcomeScreenMenuItem;\nCenter.MenuItemLink = WelcomeScreenMenuItemLink;\nCenter.MenuItemHelp = MenuItemHelp;\nCenter.MenuItemLoadScene = MenuItemLoadScene;\nCenter.MenuItemLiveCollaborationTrigger = MenuItemLiveCollaborationTrigger;\n\nexport { Center };\n",
    "import { useTunnels } from \"../../context/tunnels\";\nimport { t } from \"../../i18n\";\nimport {\n  WelcomeScreenHelpArrow,\n  WelcomeScreenMenuArrow,\n  WelcomeScreenTopToolbarArrow,\n} from \"../icons\";\n\nconst MenuHint = ({ children }: { children?: React.ReactNode }) => {\n  const { WelcomeScreenMenuHintTunnel } = useTunnels();\n  return (\n    <WelcomeScreenMenuHintTunnel.In>\n      <div className=\"excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--menu\">\n        {WelcomeScreenMenuArrow}\n        <div className=\"welcome-screen-decor-hint__label\">\n          {children || t(\"welcomeScreen.defaults.menuHint\")}\n        </div>\n      </div>\n    </WelcomeScreenMenuHintTunnel.In>\n  );\n};\nMenuHint.displayName = \"MenuHint\";\n\nconst ToolbarHint = ({ children }: { children?: React.ReactNode }) => {\n  const { WelcomeScreenToolbarHintTunnel } = useTunnels();\n  return (\n    <WelcomeScreenToolbarHintTunnel.In>\n      <div className=\"excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--toolbar\">\n        <div className=\"welcome-screen-decor-hint__label\">\n          {children || t(\"welcomeScreen.defaults.toolbarHint\")}\n        </div>\n        {WelcomeScreenTopToolbarArrow}\n      </div>\n    </WelcomeScreenToolbarHintTunnel.In>\n  );\n};\nToolbarHint.displayName = \"ToolbarHint\";\n\nconst HelpHint = ({ children }: { children?: React.ReactNode }) => {\n  const { WelcomeScreenHelpHintTunnel } = useTunnels();\n  return (\n    <WelcomeScreenHelpHintTunnel.In>\n      <div className=\"excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--help\">\n        <div>{children || t(\"welcomeScreen.defaults.helpHint\")}</div>\n        {WelcomeScreenHelpArrow}\n      </div>\n    </WelcomeScreenHelpHintTunnel.In>\n  );\n};\nHelpHint.displayName = \"HelpHint\";\n\nexport { HelpHint, MenuHint, ToolbarHint };\n",
    "import { Center } from \"./WelcomeScreen.Center\";\nimport { MenuHint, ToolbarHint, HelpHint } from \"./WelcomeScreen.Hints\";\n\nimport \"./WelcomeScreen.scss\";\n\nconst WelcomeScreen = (props: { children?: React.ReactNode }) => {\n  return (\n    <>\n      {props.children || (\n        <>\n          <Center />\n          <MenuHint />\n          <ToolbarHint />\n          <HelpHint />\n        </>\n      )}\n    </>\n  );\n};\n\nWelcomeScreen.displayName = \"WelcomeScreen\";\n\nWelcomeScreen.Center = Center;\nWelcomeScreen.Hints = { MenuHint, ToolbarHint, HelpHint };\n\nexport default WelcomeScreen;\n",
    "const polyfill = () => {\n  if (!Array.prototype.at) {\n    // Taken from https://github.com/tc39/proposal-relative-indexing-method#polyfill so that it works in tests\n    /* eslint-disable */\n    Object.defineProperty(Array.prototype, \"at\", {\n      value: function (n: number) {\n        // ToInteger() abstract op\n        n = Math.trunc(n) || 0;\n        // Allow negative indexing from the end\n        if (n < 0) {\n          n += this.length;\n        }\n        // OOB access is guaranteed to return undefined\n        if (n < 0 || n >= this.length) {\n          return undefined;\n        }\n        // Otherwise, this is just normal property access\n        return this[n];\n      },\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n  }\n\n  if (!Element.prototype.replaceChildren) {\n    Element.prototype.replaceChildren = function (...nodes) {\n      this.innerHTML = \"\";\n      this.append(...nodes);\n    };\n  }\n};\nexport default polyfill;\n",
    "import throttle from \"lodash.throttle\";\n\nimport { arrayToMap, isDevEnv, isTestEnv } from \"@excalidraw/common\";\n\nimport {\n  orderByFractionalIndex,\n  syncInvalidIndices,\n  validateFractionalIndices,\n} from \"@excalidraw/element\";\n\nimport type { OrderedExcalidrawElement } from \"@excalidraw/element/types\";\n\nimport type { MakeBrand } from \"@excalidraw/common/utility-types\";\n\nimport type { AppState } from \"../types\";\n\nexport type ReconciledExcalidrawElement = OrderedExcalidrawElement &\n  MakeBrand<\"ReconciledElement\">;\n\nexport type RemoteExcalidrawElement = OrderedExcalidrawElement &\n  MakeBrand<\"RemoteExcalidrawElement\">;\n\nconst shouldDiscardRemoteElement = (\n  localAppState: AppState,\n  local: OrderedExcalidrawElement | undefined,\n  remote: RemoteExcalidrawElement,\n): boolean => {\n  if (\n    local &&\n    // local element is being edited\n    (local.id === localAppState.editingTextElement?.id ||\n      local.id === localAppState.resizingElement?.id ||\n      local.id === localAppState.newElement?.id || // TODO: Is this still valid? As newElement is selection element, which is never part of the elements array\n      // local element is newer\n      local.version > remote.version ||\n      // resolve conflicting edits deterministically by taking the one with\n      // the lowest versionNonce\n      (local.version === remote.version &&\n        local.versionNonce < remote.versionNonce))\n  ) {\n    return true;\n  }\n  return false;\n};\n\nconst validateIndicesThrottled = throttle(\n  (\n    orderedElements: readonly OrderedExcalidrawElement[],\n    localElements: readonly OrderedExcalidrawElement[],\n    remoteElements: readonly RemoteExcalidrawElement[],\n  ) => {\n    if (isDevEnv() || isTestEnv() || window?.DEBUG_FRACTIONAL_INDICES) {\n      // create new instances due to the mutation\n      const elements = syncInvalidIndices(\n        orderedElements.map((x) => ({ ...x })),\n      );\n\n      validateFractionalIndices(elements, {\n        // throw in dev & test only, to remain functional on `DEBUG_FRACTIONAL_INDICES`\n        shouldThrow: isTestEnv() || isDevEnv(),\n        includeBoundTextValidation: true,\n        reconciliationContext: {\n          localElements,\n          remoteElements,\n        },\n      });\n    }\n  },\n  1000 * 60,\n  { leading: true, trailing: false },\n);\n\nexport const reconcileElements = (\n  localElements: readonly OrderedExcalidrawElement[],\n  remoteElements: readonly RemoteExcalidrawElement[],\n  localAppState: AppState,\n): ReconciledExcalidrawElement[] => {\n  const localElementsMap = arrayToMap(localElements);\n  const reconciledElements: OrderedExcalidrawElement[] = [];\n  const added = new Set<string>();\n\n  // process remote elements\n  for (const remoteElement of remoteElements) {\n    if (!added.has(remoteElement.id)) {\n      const localElement = localElementsMap.get(remoteElement.id);\n      const discardRemoteElement = shouldDiscardRemoteElement(\n        localAppState,\n        localElement,\n        remoteElement,\n      );\n\n      if (localElement && discardRemoteElement) {\n        reconciledElements.push(localElement);\n        added.add(localElement.id);\n      } else {\n        reconciledElements.push(remoteElement);\n        added.add(remoteElement.id);\n      }\n    }\n  }\n\n  // process remaining local elements\n  for (const localElement of localElements) {\n    if (!added.has(localElement.id)) {\n      reconciledElements.push(localElement);\n      added.add(localElement.id);\n    }\n  }\n\n  const orderedElements = orderByFractionalIndex(reconciledElements);\n\n  validateIndicesThrottled(orderedElements, localElements, remoteElements);\n\n  // de-duplicate indices\n  syncInvalidIndices(orderedElements);\n\n  return orderedElements as ReconciledExcalidrawElement[];\n};\n",
    "import { trackEvent } from \"../../analytics\";\nimport { useTunnels } from \"../../context/tunnels\";\nimport { t } from \"../../i18n\";\nimport { useExcalidrawSetAppState } from \"../App\";\nimport DropdownMenu from \"../dropdownMenu/DropdownMenu\";\nimport { brainIcon } from \"../icons\";\n\nimport type { ReactNode } from \"react\";\nimport type { JSX } from \"react\";\n\nexport const TTDDialogTrigger = ({\n  children,\n  icon,\n}: {\n  children?: ReactNode;\n  icon?: JSX.Element;\n}) => {\n  const { TTDDialogTriggerTunnel } = useTunnels();\n  const setAppState = useExcalidrawSetAppState();\n\n  return (\n    <TTDDialogTriggerTunnel.In>\n      <DropdownMenu.Item\n        onSelect={() => {\n          trackEvent(\"ai\", \"dialog open\", \"ttd\");\n          setAppState({ openDialog: { name: \"ttd\", tab: \"text-to-diagram\" } });\n        }}\n        icon={icon ?? brainIcon}\n      >\n        {children ?? t(\"labels.textToDiagram\")}\n        <DropdownMenu.Item.Badge>AI</DropdownMenu.Item.Badge>\n      </DropdownMenu.Item>\n    </TTDDialogTriggerTunnel.In>\n  );\n};\nTTDDialogTrigger.displayName = \"TTDDialogTrigger\";\n",
    "import { useLayoutEffect } from \"react\";\n\nimport { useApp } from \"../App\";\n\nimport type { GenerateDiagramToCode } from \"../../types\";\n\nexport const DiagramToCodePlugin = (props: {\n  generate: GenerateDiagramToCode;\n}) => {\n  const app = useApp();\n\n  useLayoutEffect(() => {\n    app.setPlugins({\n      diagramToCode: { generate: props.generate },\n    });\n  }, [app, props.generate]);\n\n  return null;\n};\n"
  ],
  "mappings": "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",
  "names": [
    "React",
    "useEffect",
    "isShallowEqual",
    "clsx",
    "throttle",
    "React",
    "useContext",
    "flushSync",
    "rough",
    "clamp",
    "pointFrom",
    "pointDistance",
    "vector",
    "pointRotateRads",
    "vectorScale",
    "vectorFromPoint",
    "vectorSubtract",
    "vectorNormalize",
    "COLOR_PALETTE",
    "CODES",
    "shouldRotateWithDiscreteAngle",
    "isArrowKey",
    "KEYS",
    "APP_NAME",
    "CURSOR_TYPE",
    "DRAGGING_THRESHOLD",
    "EVENT",
    "FRAME_STYLE",
    "IMAGE_MIME_TYPES",
    "LINE_CONFIRM_THRESHOLD",
    "MIME_TYPES",
    "POINTER_BUTTON",
    "ROUNDNESS",
    "THEME",
    "VERTICAL_ALIGN",
    "ZOOM_STEP",
    "TOOL_TYPE",
    "supportsResizeObserver",
    "DEFAULT_TEXT_ALIGN",
    "ARROW_TYPE",
    "DEFAULT_REDUCED_GLOBAL_ALPHA",
    "isLocalLink",
    "normalizeLink",
    "toValidURL",
    "getGridPoint",
    "getLineHeight",
    "debounce",
    "distance",
    "getFontString",
    "isWritableElement",
    "sceneCoordsToViewportCoords",
    "tupleToCoors",
    "viewportCoordsToSceneCoords",
    "wrapEvent",
    "updateObject",
    "updateActiveTool",
    "getShortcutKey",
    "isTransparent",
    "muteFSAbortError",
    "isTestEnv",
    "isDevEnv",
    "easeOut",
    "addEventListener",
    "normalizeEOL",
    "isShallowEqual",
    "arrayToMap",
    "randomInteger",
    "CLASSES",
    "Emitter",
    "getCommonBounds",
    "maybeSuggestBindingsForLinearElementAtCoords",
    "getElementAbsoluteCoords",
    "bindOrUnbindLinearElements",
    "fixBindingsAfterDeletion",
    "getHoveredElementForBinding",
    "isBindingEnabled",
    "updateBoundElements",
    "LinearElementEditor",
    "newElementWith",
    "newFrameElement",
    "newMagicFrameElement",
    "newArrowElement",
    "newElement",
    "newImageElement",
    "newLinearElement",
    "newTextElement",
    "deepCopyElement",
    "duplicateElements",
    "hasBoundTextElement",
    "isArrowElement",
    "isBindingElement",
    "isBoundToContainer",
    "isFrameLikeElement",
    "isImageElement",
    "isEmbeddableElement",
    "isInitializedImageElement",
    "isLinearElement",
    "isLinearElementType",
    "isUsingAdaptiveRadius",
    "isIframeElement",
    "isIframeLikeElement",
    "isMagicFrameElement",
    "isTextBindableContainer",
    "isElbowArrow",
    "isFlowchartNodeElement",
    "isBindableElement",
    "isTextElement",
    "getLockedLinearCursorAlignSize",
    "isElementCompletelyInViewport",
    "isElementInViewport",
    "isInvisiblySmallElement",
    "getCornerRadius",
    "isPathALoop",
    "embeddableURLValidator",
    "getEmbedLink",
    "getBoundTextElement",
    "getContainerElement",
    "redrawTextBoundingBox",
    "shouldShowBoundingBox",
    "getFrameChildren",
    "addElementsToFrame",
    "replaceAllElementsInFrame",
    "removeElementsFromFrame",
    "getElementsInResizingFrame",
    "getContainingFrame",
    "elementOverlapsWithFrame",
    "updateFrameMembershipOfSelectedElements",
    "getElementsOverlappingFrame",
    "wrapText",
    "isElementLink",
    "normalizeText",
    "measureText",
    "getLineHeightInPx",
    "ShapeCache",
    "getElementsInGroup",
    "getSelectedGroupIds",
    "isElementInGroup",
    "isSelectedViaGroup",
    "selectGroupsForSelectedElements",
    "syncInvalidIndices",
    "syncMovedIndices",
    "getSelectionStateForElements",
    "makeNextSelectedElementIds",
    "Scene",
    "CaptureUpdateAction",
    "hitElementBoundingBox",
    "isLineElement",
    "clsx",
    "React",
    "React",
    "jsx",
    "React",
    "jsx",
    "jsxs",
    "React",
    "clsx",
    "jsx",
    "elems",
    "nextElements",
    "nextAppState",
    "KEYS",
    "CaptureUpdateAction",
    "jsx",
    "CaptureUpdateAction",
    "KEYS",
    "getNonDeletedElements",
    "LinearElementEditor",
    "KEYS",
    "selectGroupsForSelectedElements",
    "CaptureUpdateAction",
    "selectGroupsForSelectedElements",
    "getNonDeletedElements",
    "LinearElementEditor",
    "CaptureUpdateAction",
    "KEYS",
    "KEYS",
    "arrayToMap",
    "getShortcutKey",
    "getNonDeletedElements",
    "LinearElementEditor",
    "getSelectedElements",
    "CaptureUpdateAction",
    "jsx",
    "LinearElementEditor",
    "CaptureUpdateAction",
    "arrayToMap",
    "getSelectedElements",
    "getNonDeletedElements",
    "KEYS",
    "getShortcutKey",
    "useEffect",
    "useMemo",
    "useRef",
    "useState",
    "DEFAULT_ELEMENT_BACKGROUND_PICKS",
    "DEFAULT_ELEMENT_STROKE_PICKS",
    "FONT_FAMILY",
    "KEYS",
    "arrayToMap",
    "getFontFamilyString",
    "getShortcutKey",
    "isTransparent",
    "getNonDeletedElements",
    "LinearElementEditor",
    "newElementWith",
    "isBoundToContainer",
    "isElbowArrow",
    "isLinearElement",
    "isTextElement",
    "CaptureUpdateAction",
    "isDevEnv",
    "clsx",
    "clsx",
    "jsx",
    "clsx",
    "Fragment",
    "jsx",
    "jsxs",
    "clsx",
    "Popover",
    "clsx",
    "useRef",
    "COLOR_OUTLINE_CONTRAST_THRESHOLD",
    "COLOR_PALETTE",
    "jsx",
    "useEffect",
    "useRef",
    "EVENT",
    "KEYS",
    "React",
    "useState",
    "THEME",
    "useState",
    "THEME",
    "div",
    "useEffect",
    "useRef",
    "jsx",
    "useEffect",
    "onCancel",
    "onSelect",
    "KEYS",
    "EVENT",
    "useRef",
    "clsx",
    "React",
    "React",
    "clsx",
    "jsx",
    "React",
    "clsx",
    "jsx",
    "jsxs",
    "React",
    "clsx",
    "clsx",
    "useEffect",
    "useRef",
    "useState",
    "KEYS",
    "getShortcutKey",
    "palette",
    "r",
    "g",
    "b",
    "Fragment",
    "jsx",
    "jsxs",
    "useState",
    "useEffect",
    "color",
    "useRef",
    "KEYS",
    "clsx",
    "getShortcutKey",
    "React",
    "useEffect",
    "useState",
    "EVENT",
    "KEYS",
    "clsx",
    "useEffect",
    "useRef",
    "jsxs",
    "jsx",
    "jsxs",
    "useRef",
    "useEffect",
    "clsx",
    "clsx",
    "useEffect",
    "useRef",
    "jsx",
    "jsxs",
    "palette",
    "useRef",
    "useEffect",
    "color",
    "clsx",
    "jsx",
    "clsx",
    "useEffect",
    "useRef",
    "jsx",
    "jsxs",
    "palette",
    "useRef",
    "useEffect",
    "color",
    "clsx",
    "KEYS",
    "palette",
    "KEYS",
    "jsx",
    "jsxs",
    "React",
    "palette",
    "useEffect",
    "useState",
    "KEYS",
    "EVENT",
    "clsx",
    "jsx",
    "clsx",
    "jsx",
    "jsxs",
    "palette",
    "COLOR_PALETTE",
    "color",
    "useRef",
    "clsx",
    "COLOR_OUTLINE_CONTRAST_THRESHOLD",
    "Popover",
    "React",
    "useCallback",
    "useMemo",
    "FONT_FAMILY",
    "React",
    "useState",
    "useRef",
    "useEffect",
    "useCallback",
    "clsx",
    "React",
    "jsx",
    "jsxs",
    "React",
    "clsx",
    "clsx",
    "jsx",
    "clsx",
    "jsx",
    "jsxs",
    "useEffect",
    "useRef",
    "THEME",
    "Fragment",
    "jsx",
    "jsxs",
    "React",
    "EVENT",
    "jsx",
    "useRef",
    "useEffect",
    "THEME",
    "KEYS",
    "jsx",
    "jsxs",
    "React",
    "useState",
    "useRef",
    "font",
    "useCallback",
    "useEffect",
    "Popover",
    "useMemo",
    "jsx",
    "useMemo",
    "jsx",
    "jsxs",
    "FONT_FAMILY",
    "React",
    "useMemo",
    "useCallback",
    "Popover",
    "clsx",
    "React",
    "useEffect",
    "KEYS",
    "jsx",
    "Fragment",
    "jsx",
    "jsxs",
    "jsx",
    "jsxs",
    "Picker",
    "KEYS",
    "isRTL",
    "React",
    "useEffect",
    "options",
    "clsx",
    "value",
    "React",
    "useEffect",
    "jsx",
    "jsxs",
    "React",
    "useEffect",
    "Fragment",
    "jsx",
    "jsxs",
    "arrayToMap",
    "getNonDeletedElements",
    "isBoundToContainer",
    "isTextElement",
    "newElement",
    "newElementWith",
    "CaptureUpdateAction",
    "DEFAULT_ELEMENT_STROKE_PICKS",
    "isTransparent",
    "DEFAULT_ELEMENT_BACKGROUND_PICKS",
    "getShortcutKey",
    "KEYS",
    "FONT_FAMILY",
    "value",
    "getFontFamilyString",
    "useRef",
    "useState",
    "useMemo",
    "useEffect",
    "isElbowArrow",
    "isLinearElement",
    "isRTL",
    "LinearElementEditor",
    "DEFAULT_CANVAS_BACKGROUND_PICKS",
    "CURSOR_TYPE",
    "THEME",
    "getShortcutKey",
    "updateActiveTool",
    "CODES",
    "KEYS",
    "getNonDeletedElements",
    "newElementWith",
    "CaptureUpdateAction",
    "useEffect",
    "jsx",
    "useEffect",
    "THEME",
    "THEME",
    "jsx",
    "jsxs",
    "CaptureUpdateAction",
    "DEFAULT_CANVAS_BACKGROUND_PICKS",
    "newElementWith",
    "getShortcutKey",
    "CODES",
    "KEYS",
    "getNonDeletedElements",
    "THEME",
    "updateActiveTool",
    "CURSOR_TYPE",
    "updateActiveTool",
    "CaptureUpdateAction",
    "updateActiveTool",
    "CaptureUpdateAction",
    "pointFrom",
    "LinearElementEditor",
    "isLinearElement",
    "isLineElement",
    "KEYS",
    "arrayToMap",
    "updateActiveTool",
    "CaptureUpdateAction",
    "jsx",
    "LinearElementEditor",
    "element",
    "newElements",
    "CaptureUpdateAction",
    "isLineElement",
    "isLinearElement",
    "pointFrom",
    "arrayToMap",
    "updateActiveTool",
    "KEYS",
    "KEYS",
    "DEFAULT_EXPORT_PADDING",
    "THEME",
    "getNonDeletedElements",
    "CaptureUpdateAction",
    "clsx",
    "jsx",
    "jsxs",
    "clsx",
    "THEME",
    "jsx",
    "THEME",
    "useState",
    "KEYS",
    "jsx",
    "jsxs",
    "useState",
    "KEYS",
    "MIME_TYPES",
    "getNonDeletedElements",
    "isFrameLikeElement",
    "MIME_TYPES",
    "arrayToMap",
    "isPromiseLike",
    "isFrameLikeElement",
    "pointFrom",
    "COLOR_PALETTE",
    "DEFAULT_FONT_FAMILY",
    "DEFAULT_FONT_SIZE",
    "VERTICAL_ALIGN",
    "isDevEnv",
    "hasHeader",
    "index",
    "file",
    "arrayToMap",
    "isFrameLikeElement",
    "MIME_TYPES",
    "error",
    "isPromiseLike",
    "isRTL",
    "getNonDeletedElements",
    "isFrameLikeElement",
    "MIME_TYPES",
    "svg",
    "blob",
    "encodePngMetadata",
    "Fragment",
    "jsx",
    "jsxs",
    "CaptureUpdateAction",
    "getNonDeletedElements",
    "DEFAULT_EXPORT_PADDING",
    "KEYS",
    "THEME",
    "DEFAULT_FONT_SIZE",
    "DEFAULT_FONT_FAMILY",
    "CODES",
    "KEYS",
    "getLineHeight",
    "newElementWith",
    "isFrameLikeElement",
    "isArrowElement",
    "isTextElement",
    "getBoundTextElement",
    "redrawTextBoundingBox",
    "CaptureUpdateAction",
    "getBoundTextElement",
    "CaptureUpdateAction",
    "KEYS",
    "CODES",
    "isTextElement",
    "newElement",
    "newElementWith",
    "DEFAULT_FONT_SIZE",
    "DEFAULT_FONT_FAMILY",
    "getLineHeight",
    "element",
    "redrawTextBoundingBox",
    "isArrowElement",
    "isFrameLikeElement",
    "KEYS",
    "getNonDeletedElements",
    "CaptureUpdateAction",
    "jsx",
    "CaptureUpdateAction",
    "getNonDeletedElements",
    "KEYS",
    "getNonDeletedElements",
    "newElementWith",
    "isBoundToContainer",
    "KEYS",
    "randomId",
    "arrayToMap",
    "getShortcutKey",
    "selectGroupsForSelectedElements",
    "getElementsInGroup",
    "syncMovedIndices",
    "CaptureUpdateAction",
    "jsx",
    "CaptureUpdateAction",
    "getElementsInGroup",
    "randomId",
    "arrayToMap",
    "newElementWith",
    "syncMovedIndices",
    "getNonDeletedElements",
    "KEYS",
    "getShortcutKey",
    "isBoundToContainer",
    "selectGroupsForSelectedElements",
    "clsx",
    "CaptureUpdateAction",
    "THEME",
    "THEME",
    "clsx",
    "useState",
    "jsx",
    "useState",
    "clsx",
    "jsx",
    "jsxs",
    "CaptureUpdateAction",
    "clsx",
    "randomId",
    "deepCopyElement",
    "CaptureUpdateAction",
    "CaptureUpdateAction",
    "randomId",
    "deepCopyElement",
    "getNonDeletedElements",
    "isFrameLikeElement",
    "KEYS",
    "arrayToMap",
    "getShortcutKey",
    "CaptureUpdateAction",
    "jsx",
    "isFrameLikeElement",
    "arrayToMap",
    "CaptureUpdateAction",
    "KEYS",
    "getShortcutKey",
    "getNonDeletedElements",
    "getNonDeletedElements",
    "isFrameLikeElement",
    "CODES",
    "KEYS",
    "arrayToMap",
    "getShortcutKey",
    "updateFrameMembershipOfSelectedElements",
    "CaptureUpdateAction",
    "jsx",
    "enableActionGroup",
    "isFrameLikeElement",
    "arrayToMap",
    "updateFrameMembershipOfSelectedElements",
    "CaptureUpdateAction",
    "KEYS",
    "CODES",
    "getShortcutKey",
    "getNonDeletedElements",
    "getNonDeletedElements",
    "isBindingEnabled",
    "newElementWith",
    "deepCopyElement",
    "isArrowElement",
    "isElbowArrow",
    "isLinearElement",
    "updateFrameMembershipOfSelectedElements",
    "CODES",
    "KEYS",
    "arrayToMap",
    "CaptureUpdateAction",
    "updateFrameMembershipOfSelectedElements",
    "CaptureUpdateAction",
    "CODES",
    "KEYS",
    "getNonDeletedElements",
    "arrayToMap",
    "isArrowElement",
    "newElementWith",
    "deepCopyElement",
    "isLinearElement",
    "isBindingEnabled",
    "isElbowArrow",
    "isTextElement",
    "CODES",
    "KEYS",
    "isFirefox",
    "CaptureUpdateAction",
    "CaptureUpdateAction",
    "isFirefox",
    "KEYS",
    "CODES",
    "isTextElement",
    "CODES",
    "KEYS",
    "CaptureUpdateAction",
    "CaptureUpdateAction",
    "KEYS",
    "CODES",
    "CODES",
    "KEYS",
    "CaptureUpdateAction",
    "CaptureUpdateAction",
    "KEYS",
    "CODES",
    "CODES",
    "KEYS",
    "CaptureUpdateAction",
    "CaptureUpdateAction",
    "KEYS",
    "CODES",
    "CODES",
    "KEYS",
    "CaptureUpdateAction",
    "CaptureUpdateAction",
    "KEYS",
    "CODES",
    "ROUNDNESS",
    "VERTICAL_ALIGN",
    "arrayToMap",
    "getBoundTextElement",
    "redrawTextBoundingBox",
    "hasBoundTextElement",
    "isArrowElement",
    "isTextElement",
    "isUsingAdaptiveRadius",
    "syncMovedIndices",
    "newElement",
    "CaptureUpdateAction",
    "hasBoundTextElement",
    "getBoundTextElement",
    "CaptureUpdateAction",
    "isTextElement",
    "VERTICAL_ALIGN",
    "isArrowElement",
    "redrawTextBoundingBox",
    "syncMovedIndices",
    "arrayToMap",
    "newElement",
    "isUsingAdaptiveRadius",
    "ROUNDNESS",
    "isEmbeddableElement",
    "KEYS",
    "getShortcutKey",
    "CaptureUpdateAction",
    "pointFrom",
    "clsx",
    "useCallback",
    "useEffect",
    "useLayoutEffect",
    "useRef",
    "useState",
    "EVENT",
    "KEYS",
    "jsx",
    "jsxs",
    "useState",
    "useRef",
    "useCallback",
    "useLayoutEffect",
    "useEffect",
    "pointFrom",
    "EVENT",
    "clsx",
    "KEYS",
    "jsx",
    "CaptureUpdateAction",
    "KEYS",
    "isEmbeddableElement",
    "getShortcutKey",
    "KEYS",
    "arrayToMap",
    "randomId",
    "newElementWith",
    "CaptureUpdateAction",
    "arrayToMap",
    "randomId",
    "newElementWith",
    "CaptureUpdateAction",
    "KEYS",
    "LinearElementEditor",
    "isElbowArrow",
    "isLinearElement",
    "isLineElement",
    "arrayToMap",
    "toggleLinePolygonState",
    "CaptureUpdateAction",
    "clsx",
    "useEffect",
    "useRef",
    "useState",
    "DEFAULT_SIDEBAR",
    "EVENT",
    "KEYS",
    "capitalizeString",
    "getShortcutKey",
    "CaptureUpdateAction",
    "useEffect",
    "useMemo",
    "useRef",
    "useState",
    "updateElbowArrowPoints",
    "pointFrom",
    "hasBoundTextElement",
    "isArrowElement",
    "isElbowArrow",
    "isLinearElement",
    "isUsingAdaptiveRadius",
    "getCommonBoundingBox",
    "getElementAbsoluteCoords",
    "getBoundTextElement",
    "redrawTextBoundingBox",
    "getFontString",
    "reduceToCommonValue",
    "updateActiveTool",
    "measureText",
    "LinearElementEditor",
    "newElement",
    "newLinearElement",
    "jsx",
    "useRef",
    "useEffect",
    "useMemo",
    "useState",
    "elements",
    "getElementAbsoluteCoords",
    "pointFrom",
    "getCommonBoundingBox",
    "sceneCoordsToViewportCoords",
    "getBoundTextElement",
    "SHAPES",
    "getFontString",
    "measureText",
    "mutateElement",
    "redrawTextBoundingBox",
    "updateActiveTool",
    "reduceToCommonValue",
    "isLinearElement",
    "isElbowArrow",
    "updateElbowArrowPoints",
    "LinearElementEditor",
    "isArrowElement",
    "hasBoundTextElement",
    "start",
    "newElement",
    "isUsingAdaptiveRadius",
    "ROUNDNESS",
    "newLinearElement",
    "CaptureUpdateAction",
    "CaptureUpdateAction",
    "CaptureUpdateAction",
    "isDarwin",
    "getShortcutKey",
    "getShortcutKey",
    "isDarwin",
    "clsx",
    "useEffect",
    "useState",
    "KEYS",
    "useCallback",
    "useState",
    "useState",
    "useCallback",
    "useMemo",
    "useEffect",
    "memo",
    "useRef",
    "LIBRARY_DISABLED_TYPES",
    "randomId",
    "useEffect",
    "useRef",
    "EVENT",
    "arrayToMap",
    "cloneJSON",
    "getCommonBoundingBox",
    "MIME_TYPES",
    "exportToCanvas",
    "MIME_TYPES",
    "exportToSvg",
    "useEffect",
    "useState",
    "COLOR_PALETTE",
    "exportToSvg",
    "COLOR_PALETTE",
    "useState",
    "useEffect",
    "cloneJSON",
    "arrayToMap",
    "row",
    "getCommonBoundingBox",
    "index",
    "useRef",
    "useEffect",
    "libraryUrlTokens",
    "EVENT",
    "clsx",
    "jsx",
    "jsx",
    "jsxs",
    "clsx",
    "useCallback",
    "useEffect",
    "useMemo",
    "useRef",
    "useState",
    "MIME_TYPES",
    "arrayToMap",
    "duplicateElements",
    "useEffect",
    "useEffect",
    "clsx",
    "useCallback",
    "useState",
    "clsx",
    "jsx",
    "jsxs",
    "clsx",
    "jsx",
    "jsxs",
    "OpenColor",
    "useCallback",
    "useEffect",
    "useRef",
    "useState",
    "EXPORT_DATA_TYPES",
    "MIME_TYPES",
    "VERSIONS",
    "React",
    "React",
    "t",
    "jsx",
    "jsxs",
    "OpenColor",
    "exportToCanvas",
    "MIME_TYPES",
    "useRef",
    "useEffect",
    "exportToSvg",
    "useState",
    "EXPORT_DATA_TYPES",
    "VERSIONS",
    "index",
    "items",
    "useCallback",
    "clsx",
    "useEffect",
    "useRef",
    "EVENT",
    "KEYS",
    "forwardRef",
    "clsx",
    "jsx",
    "forwardRef",
    "clsx",
    "jsx",
    "useRef",
    "useEffect",
    "KEYS",
    "EVENT",
    "clsx",
    "jsx",
    "jsx",
    "jsx",
    "clsx",
    "jsx",
    "clsx",
    "React",
    "Fragment",
    "jsxs",
    "jsx",
    "jsxs",
    "useState",
    "useCallback",
    "clsx",
    "memo",
    "useEffect",
    "useState",
    "React",
    "useCallback",
    "clsx",
    "useEffect",
    "useRef",
    "useState",
    "jsx",
    "jsxs",
    "useRef",
    "useEffect",
    "useState",
    "clsx",
    "Fragment",
    "jsx",
    "memo",
    "useState",
    "useEffect",
    "Fragment",
    "jsx",
    "jsxs",
    "useRef",
    "useEffect",
    "useMemo",
    "useState",
    "useCallback",
    "id",
    "arrayToMap",
    "duplicateElements",
    "MIME_TYPES",
    "jsx",
    "jsxs",
    "memo",
    "useCallback",
    "libraryItems",
    "LIBRARY_DISABLED_TYPES",
    "randomId",
    "useMemo",
    "useState",
    "useRef",
    "useEffect",
    "clsx",
    "useRef",
    "createPortal",
    "KEYS",
    "jsx",
    "jsxs",
    "useRef",
    "KEYS",
    "createPortal",
    "clsx",
    "jsx",
    "jsxs",
    "useState",
    "useEffect",
    "KEYS",
    "focusableElements",
    "clsx",
    "clsx",
    "forwardRef",
    "useRef",
    "useImperativeHandle",
    "useLayoutEffect",
    "useState",
    "clsx",
    "composeEventHandlers",
    "jsx",
    "composeEventHandlers",
    "clsx",
    "jsx",
    "jsxs",
    "forwardRef",
    "useRef",
    "useImperativeHandle",
    "useLayoutEffect",
    "useState",
    "clsx",
    "KEYS",
    "KEYS",
    "shape",
    "clsx",
    "useState",
    "CLASSES",
    "KEYS",
    "isTransparent",
    "hasBoundTextElement",
    "isElbowArrow",
    "isLinearElement",
    "isTextElement",
    "hasStrokeColor",
    "createIsolation",
    "React",
    "Fragment",
    "jsx",
    "jsxs",
    "hasStrokeColor",
    "hasBoundTextElement",
    "isRTL",
    "isTransparent",
    "isLinearElement",
    "isElbowArrow",
    "isTextElement",
    "useState",
    "clsx",
    "KEYS",
    "CLASSES",
    "useRef",
    "jsx",
    "jsxs",
    "jsx",
    "jsxs",
    "clsx",
    "KEYS",
    "useEffect",
    "EVENT",
    "useState",
    "useRef",
    "uiAppState",
    "customCommandPaletteItems",
    "appProps",
    "action",
    "app",
    "DEFAULT_SIDEBAR",
    "capitalizeString",
    "allCommands",
    "nextItem",
    "getShortcutKey",
    "getSizeFromPoints",
    "randomInteger",
    "pointFrom",
    "pointRotateRads",
    "getElementAbsoluteCoords",
    "pointFrom",
    "pointDistance",
    "pointRotateRads",
    "isTransparent",
    "assertNever",
    "COLOR_PALETTE",
    "rough",
    "BOUND_TEXT_PADDING",
    "MIME_TYPES",
    "THEME",
    "getFontString",
    "arrayToMap",
    "invariant",
    "lineSegment",
    "pointDistance",
    "pointFrom",
    "pointFromArray",
    "pointRotateRads",
    "pointsOnBezierCurves",
    "pointFrom",
    "pointRotateRads",
    "pointsEqual",
    "pointDistance",
    "vectorFromPoint",
    "KEYS",
    "invariant",
    "tupleToCoors",
    "viewportCoordsToSceneCoords",
    "deconstructLinearOrFreeDrawElement",
    "isPathALoop",
    "KEYS",
    "arrayToMap",
    "tupleToCoors",
    "invariant",
    "isDevEnv",
    "isTestEnv",
    "lineSegment",
    "pointFrom",
    "pointRotateRads",
    "vectorFromPoint",
    "clamp",
    "pointDistance",
    "pointFromVector",
    "vectorScale",
    "vectorNormalize",
    "vectorCross",
    "pointsEqual",
    "lineSegmentIntersectionPoints",
    "PRECISION",
    "isTransparent",
    "lineSegment",
    "pointFrom",
    "pointFromVector",
    "pointRotateRads",
    "pointsEqual",
    "vectorFromPoint",
    "vectorScale",
    "ellipse",
    "ROUNDNESS",
    "curve",
    "lineSegment",
    "pointDistance",
    "pointFrom",
    "pointFromArray",
    "isPathALoop",
    "distance",
    "pointDistance",
    "ROUNDNESS",
    "ROUNDNESS",
    "assertNever",
    "isEmbeddableElement",
    "isTextElement",
    "isFrameLikeElement",
    "isLinearElement",
    "isArrowElement",
    "isElbowArrow",
    "isBoundToContainer",
    "isTextElement",
    "BOUND_TEXT_PADDING",
    "DEFAULT_FONT_SIZE",
    "TEXT_ALIGN",
    "VERTICAL_ALIGN",
    "getFontString",
    "isProdEnv",
    "invariant",
    "BOUND_TEXT_PADDING",
    "DEFAULT_FONT_SIZE",
    "DEFAULT_FONT_FAMILY",
    "getFontString",
    "isDevEnv",
    "isTestEnv",
    "pointRotateRads",
    "invariant",
    "isDevEnv",
    "isTestEnv",
    "pointFrom",
    "pointFromVector",
    "pointRotateRads",
    "pointsEqual",
    "vectorFromPoint",
    "vectorScale",
    "vectorFromPoint",
    "clamp",
    "pointDistance",
    "pointFrom",
    "pointScaleFromOrigin",
    "pointsEqual",
    "vector",
    "vectorCross",
    "vectorFromPoint",
    "vectorScale",
    "invariant",
    "tupleToCoors",
    "isDevEnv",
    "arrayToMap",
    "viewportCoordsToSceneCoords",
    "pointsEqual",
    "invariant",
    "pointFrom",
    "pointFromArray",
    "t",
    "distance",
    "x3",
    "y3",
    "pointRotateRads",
    "x4",
    "y4",
    "pointFrom",
    "pointCenter",
    "pointRotateRads",
    "vectorFromPoint",
    "vectorNormalize",
    "vectorAdd",
    "vectorScale",
    "pointFromVector",
    "clamp",
    "arrayToMap",
    "isPointWithinBounds",
    "pointFrom",
    "vectorCross",
    "vectorFromPoint",
    "arrayToMap",
    "getElementBounds",
    "isArrowElement",
    "isExcalidrawElement",
    "isFreeDrawElement",
    "isLinearElement",
    "isTextElement",
    "pointFrom",
    "pointRotateRads",
    "arrayToMap",
    "isShallowEqual",
    "selectGroupsForSelectedElements",
    "getSelectedElements",
    "isSomeElementSelected",
    "getSelectedElements",
    "isBoundToContainer",
    "isFrameLikeElement",
    "getFrameChildren",
    "isShallowEqual",
    "getFrameChildren",
    "MIME_TYPES",
    "t",
    "canChangeRoundness",
    "COLOR_PALETTE",
    "ShapeCache",
    "canChangeRoundness",
    "isLinearElement",
    "isTransparent",
    "isPathALoop",
    "isEmbeddableElement",
    "arrowheadPoints",
    "options",
    "pointFrom",
    "isElbowArrow",
    "isPathALoop",
    "assertNever",
    "pointDistance",
    "newElementWith",
    "randomInteger",
    "jsx",
    "isLinearElement",
    "isElbowArrow",
    "LinearElementEditor",
    "arrayToMap",
    "CaptureUpdateAction",
    "isLineElement",
    "newElementWith",
    "toggleLinePolygonState",
    "KEYS",
    "CLASSES",
    "DEFAULT_SIDEBAR",
    "CaptureUpdateAction",
    "DEFAULT_SIDEBAR",
    "CLASSES",
    "CaptureUpdateAction",
    "KEYS",
    "isImageElement",
    "CaptureUpdateAction",
    "jsx",
    "CaptureUpdateAction",
    "isImageElement",
    "arrayToMap",
    "newElementWith",
    "duplicateElements",
    "CaptureUpdateAction",
    "jsx",
    "CaptureUpdateAction",
    "newElementWith",
    "duplicateElements",
    "arrayToMap",
    "getNonDeletedElements",
    "mutateElement",
    "isFrameLikeElement",
    "getFrameChildren",
    "KEYS",
    "updateActiveTool",
    "getElementsInGroup",
    "getCommonBounds",
    "CaptureUpdateAction",
    "isFrameLikeElement",
    "getFrameChildren",
    "getNonDeletedElements",
    "CaptureUpdateAction",
    "updateActiveTool",
    "KEYS",
    "getCommonBounds",
    "getElementsInGroup",
    "mutateElement",
    "KEYS",
    "arrayToMap",
    "CaptureUpdateAction",
    "Emitter",
    "CaptureUpdateAction",
    "Emitter",
    "CaptureUpdateAction",
    "useEffect",
    "useState",
    "event",
    "jsx",
    "CaptureUpdateAction",
    "arrayToMap",
    "KEYS",
    "getFontString",
    "newElementWith",
    "measureText",
    "isTextElement",
    "CaptureUpdateAction",
    "isTextElement",
    "measureText",
    "getFontString",
    "newElementWith",
    "CaptureUpdateAction",
    "CODES",
    "KEYS",
    "CaptureUpdateAction",
    "CaptureUpdateAction",
    "KEYS",
    "CODES",
    "isPromiseLike",
    "jsx",
    "isPromiseLike",
    "actionResult",
    "actions",
    "action",
    "pointFrom",
    "pointRotateRads",
    "rangeInclusive",
    "KEYS",
    "getCommonBounds",
    "getElementAbsoluteCoords",
    "isBoundToContainer",
    "isFrameLikeElement",
    "getSelectedElements",
    "KEYS",
    "getElementAbsoluteCoords",
    "pointRotateRads",
    "pointFrom",
    "isFrameLikeElement",
    "isBoundToContainer",
    "getCommonBounds",
    "rangeInclusive",
    "getSelectedElements",
    "newElement",
    "pointFrom",
    "DEFAULT_FONT_FAMILY",
    "DEFAULT_FONT_SIZE",
    "TEXT_ALIGN",
    "VERTICAL_ALIGN",
    "getSizeFromPoints",
    "randomId",
    "arrayToMap",
    "assertNever",
    "cloneJSON",
    "getFontString",
    "isDevEnv",
    "getLineHeight",
    "bindLinearElement",
    "newArrowElement",
    "newElement",
    "newFrameElement",
    "newLinearElement",
    "newTextElement",
    "measureText",
    "isArrowElement",
    "redrawTextBoundingBox",
    "LinearElementEditor",
    "getCommonBounds",
    "newTextElement",
    "TEXT_ALIGN",
    "VERTICAL_ALIGN",
    "redrawTextBoundingBox",
    "start",
    "newElement",
    "assertNever",
    "bindLinearElement",
    "cloneJSON",
    "LinearElementEditor",
    "arrayToMap",
    "randomId",
    "newLinearElement",
    "pointFrom",
    "newArrowElement",
    "getSizeFromPoints",
    "DEFAULT_FONT_FAMILY",
    "DEFAULT_FONT_SIZE",
    "getLineHeight",
    "measureText",
    "getFontString",
    "newFrameElement",
    "isArrowElement",
    "id",
    "getCommonBounds",
    "isDevEnv",
    "isElementInViewport",
    "toBrandedType",
    "pointFrom",
    "pointsEqual",
    "oc",
    "arrayToMap",
    "FRAME_STYLE",
    "invariant",
    "THEME",
    "FIXED_BINDING_DISTANCE",
    "LinearElementEditor",
    "isElbowArrow",
    "isFrameLikeElement",
    "isImageElement",
    "isLinearElement",
    "isLineElement",
    "isTextElement",
    "getElementsInGroup",
    "getSelectedGroupIds",
    "selectGroupsFromGivenElements",
    "getCommonBounds",
    "getElementAbsoluteCoords",
    "pointFrom",
    "THEME",
    "getCommonBounds",
    "getCommonBounds",
    "isRTL",
    "invariant",
    "LinearElementEditor",
    "getElementAbsoluteCoords",
    "FIXED_BINDING_DISTANCE",
    "FRAME_STYLE",
    "elements",
    "getCommonBounds",
    "getElementsInGroup",
    "selectGroupsFromGivenElements",
    "isElbowArrow",
    "isLineElement",
    "pointsEqual",
    "pointFrom",
    "midPoints",
    "isTextElement",
    "isFrameLikeElement",
    "isLinearElement",
    "oc",
    "arrayToMap",
    "isImageElement",
    "getSelectedGroupIds",
    "THEME",
    "throttle",
    "isElementInViewport",
    "toBrandedType",
    "sceneCoordsToViewportCoords",
    "getElementAbsoluteCoords",
    "jsx",
    "getContainerCoords",
    "getElementAbsoluteCoords",
    "sceneCoordsToViewportCoords",
    "getSvgPathFromStroke",
    "sceneCoordsToViewportCoords",
    "sceneCoordsToViewportCoords",
    "getSvgPathFromStroke",
    "t",
    "throttleRAF",
    "CODES",
    "KEYS",
    "CLASSES",
    "isWritableElement",
    "getFontString",
    "getFontFamilyString",
    "isTestEnv",
    "updateOriginalContainerCache",
    "LinearElementEditor",
    "bumpVersion",
    "getContainerElement",
    "redrawTextBoundingBox",
    "getBoundTextMaxHeight",
    "getBoundTextMaxWidth",
    "computeContainerDimensionForBoundText",
    "computeBoundTextPosition",
    "getBoundTextElement",
    "normalizeText",
    "wrapText",
    "isArrowElement",
    "isBoundToContainer",
    "isTextElement",
    "editable",
    "getFontFamilyString",
    "isTextElement",
    "getContainerElement",
    "isArrowElement",
    "LinearElementEditor",
    "updateOriginalContainerCache",
    "getBoundTextMaxWidth",
    "getBoundTextMaxHeight",
    "computeContainerDimensionForBoundText",
    "computeBoundTextPosition",
    "getFontString",
    "isTestEnv",
    "isBoundToContainer",
    "normalizeText",
    "getBoundTextElement",
    "wrapText",
    "KEYS",
    "CODES",
    "bumpVersion",
    "redrawTextBoundingBox",
    "CLASSES",
    "isWritableElement",
    "pointFrom",
    "getElementLineSegments",
    "LinearElementEditor",
    "isFrameLikeElement",
    "isLinearElement",
    "isTextElement",
    "getFrameChildren",
    "selectGroupsForSelectedElements",
    "getContainerElement",
    "arrayToMap",
    "easeOut",
    "isShallowEqual",
    "simplify",
    "polygonFromPoints",
    "lineSegment",
    "computeBoundTextPosition",
    "doBoundsIntersect",
    "getBoundTextElement",
    "getElementBounds",
    "intersectElementWithLineSegment",
    "t",
    "easeOut",
    "isTextElement",
    "getContainerElement",
    "isFrameLikeElement",
    "getFrameChildren",
    "selectGroupsForSelectedElements",
    "isLinearElement",
    "LinearElementEditor",
    "pointFrom",
    "isShallowEqual",
    "arrayToMap",
    "getElementLineSegments",
    "arrayToMap",
    "easeOut",
    "THEME",
    "computeBoundTextPosition",
    "getBoundTextElement",
    "intersectElementWithLineSegment",
    "lineSegment",
    "pointFrom",
    "getElementsInGroup",
    "shouldTestInside",
    "hasBoundTextElement",
    "isBoundToContainer",
    "getBoundTextElementId",
    "t",
    "easeOut",
    "THEME",
    "restore",
    "pointFrom",
    "lineSegment",
    "arrayToMap",
    "getElementsInGroup",
    "isBoundToContainer",
    "hasBoundTextElement",
    "getBoundTextElementId",
    "shouldTestInside",
    "getBoundTextElement",
    "intersectElementWithLineSegment",
    "computeBoundTextPosition",
    "jsx",
    "jsxs",
    "clsx",
    "React",
    "useLayoutEffect",
    "useRef",
    "useEffect",
    "unstable_batchedUpdates",
    "KEYS",
    "queryFocusableElements",
    "jsx",
    "Popover",
    "useRef",
    "useEffect",
    "KEYS",
    "queryFocusableElements",
    "useLayoutEffect",
    "unstable_batchedUpdates",
    "jsx",
    "jsxs",
    "React",
    "Popover",
    "clsx",
    "jsx",
    "jsxs",
    "clsx",
    "React",
    "CLASSES",
    "DEFAULT_SIDEBAR",
    "TOOL_TYPE",
    "arrayToMap",
    "capitalizeString",
    "isShallowEqual",
    "mutateElement",
    "showSelectedShapeActions",
    "ShapeCache",
    "clsx",
    "useState",
    "useEffect",
    "THEME",
    "jsx",
    "jsxs",
    "useState",
    "useEffect",
    "clsx",
    "THEME",
    "clsx",
    "jsx",
    "jsxs",
    "ICONS",
    "clsx",
    "showSelectedShapeActions",
    "clsx",
    "jsx",
    "clsx",
    "clsx",
    "KEYS",
    "jsx",
    "clsx",
    "KEYS",
    "CANVAS_SEARCH_TAB",
    "DEFAULT_SIDEBAR",
    "isImageElement",
    "isLinearElement",
    "isLineElement",
    "isTextBindableContainer",
    "isTextElement",
    "getShortcutKey",
    "jsx",
    "DEFAULT_SIDEBAR",
    "CANVAS_SEARCH_TAB",
    "getShortcutKey",
    "isLinearElement",
    "isImageElement",
    "isTextElement",
    "isLineElement",
    "isTextBindableContainer",
    "hint",
    "clsx",
    "jsx",
    "jsxs",
    "DEFAULT_SIZE",
    "clsx",
    "Fragment",
    "jsx",
    "jsxs",
    "Fragment",
    "jsx",
    "jsxs",
    "showSelectedShapeActions",
    "appState",
    "oc",
    "React",
    "useLayoutEffect",
    "useRef",
    "useState",
    "jsx",
    "jsxs",
    "useRef",
    "useState",
    "useLayoutEffect",
    "oc",
    "React",
    "Popover",
    "clsx",
    "React",
    "useLayoutEffect",
    "isShallowEqual",
    "Fragment",
    "jsx",
    "jsxs",
    "React",
    "useLayoutEffect",
    "maxAvatars",
    "clsx",
    "isShallowEqual",
    "clsx",
    "jsx",
    "jsx",
    "jsxs",
    "clsx",
    "clsx",
    "useEffect",
    "useLayoutEffect",
    "useRef",
    "useState",
    "forwardRef",
    "useImperativeHandle",
    "useCallback",
    "EVENT",
    "isDevEnv",
    "KEYS",
    "clsx",
    "useContext",
    "React",
    "jsx",
    "jsxs",
    "useContext",
    "clsx",
    "jsx",
    "RadixTabs",
    "jsx",
    "clsx",
    "jsx",
    "jsxs",
    "clsx",
    "RadixTabs",
    "jsx",
    "RadixTabs",
    "jsx",
    "jsx",
    "forwardRef",
    "isDevEnv",
    "useLayoutEffect",
    "useRef",
    "useImperativeHandle",
    "useCallback",
    "useEffect",
    "KEYS",
    "EVENT",
    "clsx",
    "useState",
    "composeEventHandlers",
    "useLayoutEffect",
    "useRef",
    "jsx",
    "useAtom",
    "useRef",
    "useLayoutEffect",
    "CommandPalette",
    "clsx",
    "THEME",
    "clsx",
    "jsx",
    "jsxs",
    "clsx",
    "Fragment",
    "jsx",
    "jsxs",
    "Fragment",
    "jsx",
    "jsxs",
    "t",
    "CommandPalette",
    "THEME",
    "clsx",
    "jsx",
    "jsxs",
    "composeEventHandlers",
    "clsx",
    "forwardRef",
    "useState",
    "isPromiseLike",
    "jsx",
    "jsxs",
    "forwardRef",
    "useState",
    "isPromiseLike",
    "clsx",
    "jsx",
    "jsxs",
    "t",
    "jsx",
    "jsxs",
    "clsx",
    "CANVAS_SEARCH_TAB",
    "DEFAULT_SIDEBAR",
    "LIBRARY_SIDEBAR_TAB",
    "composeEventHandlers",
    "round",
    "clsx",
    "debounce",
    "Fragment",
    "memo",
    "useEffect",
    "useMemo",
    "useRef",
    "useState",
    "CLASSES",
    "EVENT",
    "FONT_FAMILY",
    "FRAME_STYLE",
    "getLineHeight",
    "measureText",
    "KEYS",
    "randomInteger",
    "getFontString",
    "newTextElement",
    "isTextElement",
    "isFrameLikeElement",
    "Fragment",
    "jsx",
    "jsxs",
    "SearchMenu",
    "useRef",
    "useState",
    "useEffect",
    "randomInteger",
    "focusIndex",
    "newTextElement",
    "isFrameLikeElement",
    "FRAME_STYLE",
    "FONT_FAMILY",
    "round",
    "KEYS",
    "EVENT",
    "CLASSES",
    "searchQuery",
    "clsx",
    "useMemo",
    "isTextElement",
    "memo",
    "startIndex",
    "measureText",
    "getFontString",
    "getLineHeight",
    "debounce",
    "jsx",
    "jsxs",
    "createElement",
    "DEFAULT_SIDEBAR",
    "CANVAS_SEARCH_TAB",
    "clsx",
    "composeEventHandlers",
    "docked",
    "LIBRARY_SIDEBAR_TAB",
    "SearchMenu",
    "useEffect",
    "useRef",
    "useState",
    "useState",
    "useRef",
    "useEffect",
    "EDITOR_LS_KEYS",
    "debounce",
    "isDevEnv",
    "useEffect",
    "useRef",
    "EVENT",
    "KEYS",
    "jsx",
    "jsx",
    "jsxs",
    "clsx",
    "jsx",
    "jsxs",
    "clsx",
    "jsx",
    "getShortcutKey",
    "jsx",
    "jsxs",
    "DEFAULT_EXPORT_PADDING",
    "EDITOR_LS_KEYS",
    "exportToCanvas",
    "DEFAULT_EXPORT_PADDING",
    "EDITOR_LS_KEYS",
    "Fragment",
    "jsx",
    "jsxs",
    "debounce",
    "useState",
    "EDITOR_LS_KEYS",
    "useRef",
    "useEffect",
    "isDevEnv",
    "RadixTabs",
    "useRef",
    "isMemberOf",
    "jsx",
    "useRef",
    "isMemberOf",
    "RadixTabs",
    "jsx",
    "RadixTabs",
    "jsx",
    "RadixTabs",
    "jsx",
    "jsx",
    "jsxs",
    "useRef",
    "useState",
    "error",
    "useEffect",
    "round",
    "clsx",
    "throttle",
    "useEffect",
    "useMemo",
    "useState",
    "memo",
    "getCommonBounds",
    "getUncroppedWidthAndHeight",
    "isElbowArrow",
    "isImageElement",
    "frameAndChildrenSelectedTogether",
    "elementsAreInSameGroup",
    "degreesToRadians",
    "getBoundTextElement",
    "isArrowElement",
    "isElbowArrow",
    "updateBindings",
    "clsx",
    "useEffect",
    "useRef",
    "useState",
    "EVENT",
    "KEYS",
    "cloneJSON",
    "deepCopyElement",
    "CaptureUpdateAction",
    "pointFrom",
    "pointRotateRads",
    "getBoundTextElement",
    "isFrameLikeElement",
    "getSelectedGroupIds",
    "getElementsInGroup",
    "getFrameChildren",
    "updateBindings",
    "pointRotateRads",
    "pointFrom",
    "updateBindings",
    "getBoundTextElement",
    "isFrameLikeElement",
    "getFrameChildren",
    "getSelectedGroupIds",
    "getElementsInGroup",
    "jsx",
    "jsxs",
    "useRef",
    "useState",
    "cloneJSON",
    "useEffect",
    "inputValue",
    "elements",
    "appState",
    "value",
    "CaptureUpdateAction",
    "EVENT",
    "clsx",
    "deepCopyElement",
    "event",
    "KEYS",
    "jsx",
    "STEP_SIZE",
    "isElbowArrow",
    "nextAngle",
    "degreesToRadians",
    "updateBindings",
    "boundTextElement",
    "getBoundTextElement",
    "isArrowElement",
    "jsx",
    "STEP_SIZE",
    "clamp",
    "round",
    "isImageElement",
    "isFrameLikeElement",
    "getElementsInResizingFrame",
    "replaceAllElementsInFrame",
    "jsx",
    "STEP_SIZE",
    "isImageElement",
    "nextCropWidth",
    "clamp",
    "nextCropHeight",
    "isFrameLikeElement",
    "getElementsInResizingFrame",
    "replaceAllElementsInFrame",
    "round",
    "getBoundTextElement",
    "redrawTextBoundingBox",
    "hasBoundTextElement",
    "isTextElement",
    "jsx",
    "STEP_SIZE",
    "isTextElement",
    "redrawTextBoundingBox",
    "hasBoundTextElement",
    "getBoundTextElement",
    "degreesToRadians",
    "radiansToDegrees",
    "getBoundTextElement",
    "isArrowElement",
    "isInGroup",
    "jsx",
    "STEP_SIZE",
    "handleDegreeChange",
    "isInGroup",
    "degreesToRadians",
    "getBoundTextElement",
    "isArrowElement",
    "radiansToDegrees",
    "pointFrom",
    "useMemo",
    "MIN_WIDTH_OR_HEIGHT",
    "getElementsInResizingFrame",
    "isFrameLikeElement",
    "replaceAllElementsInFrame",
    "updateBoundElements",
    "resizeSingleElement",
    "getBoundTextElement",
    "handleBindTextResize",
    "isTextElement",
    "getCommonBounds",
    "jsx",
    "STEP_SIZE",
    "isTextElement",
    "getBoundTextElement",
    "updateBoundElements",
    "handleBindTextResize",
    "handleDimensionChange",
    "originalElements",
    "getCommonBounds",
    "MIN_WIDTH_OR_HEIGHT",
    "pointFrom",
    "resizeSingleElement",
    "isFrameLikeElement",
    "getElementsInResizingFrame",
    "replaceAllElementsInFrame",
    "handleDragFinished",
    "useMemo",
    "el",
    "getBoundTextElement",
    "redrawTextBoundingBox",
    "hasBoundTextElement",
    "isTextElement",
    "isInGroup",
    "jsx",
    "MIN_FONT_SIZE",
    "STEP_SIZE",
    "isInGroup",
    "isTextElement",
    "hasBoundTextElement",
    "getBoundTextElement",
    "handleFontSizeChange",
    "redrawTextBoundingBox",
    "nextFontSize",
    "pointFrom",
    "pointRotateRads",
    "useMemo",
    "isTextElement",
    "getCommonBounds",
    "jsx",
    "pointRotateRads",
    "pointFrom",
    "getCommonBounds",
    "isTextElement",
    "useMemo",
    "el",
    "clamp",
    "pointFrom",
    "pointRotateRads",
    "round",
    "getUncroppedWidthAndHeight",
    "isImageElement",
    "jsx",
    "handlePositionChange",
    "pointRotateRads",
    "pointFrom",
    "isImageElement",
    "getUncroppedWidthAndHeight",
    "clamp",
    "newTopLeftX",
    "newTopLeftY",
    "round",
    "Fragment",
    "jsx",
    "jsxs",
    "clsx",
    "memo",
    "isImageElement",
    "getUncroppedWidthAndHeight",
    "useState",
    "useMemo",
    "throttle",
    "elements",
    "getCommonBounds",
    "useEffect",
    "frameAndChildrenSelectedTogether",
    "round",
    "isElbowArrow",
    "elementsAreInSameGroup",
    "useCallback",
    "useEffect",
    "useState",
    "normalizeLink",
    "KEYS",
    "defaultGetElementLinkFromSelection",
    "getLinkIdAndTypeFromSelection",
    "jsx",
    "jsxs",
    "defaultGetElementLinkFromSelection",
    "useState",
    "useEffect",
    "nextLink",
    "getLinkIdAndTypeFromSelection",
    "normalizeLink",
    "useCallback",
    "KEYS",
    "React",
    "useState",
    "Fragment",
    "jsx",
    "useState",
    "React",
    "React",
    "isDarwin",
    "isFirefox",
    "isWindows",
    "KEYS",
    "getShortcutKey",
    "Fragment",
    "jsx",
    "jsxs",
    "Section",
    "React",
    "KEYS",
    "getShortcutKey",
    "isFirefox",
    "isDarwin",
    "isWindows",
    "useEffect",
    "useRef",
    "useState",
    "DEFAULT_EXPORT_PADDING",
    "isFirefox",
    "EXPORT_SCALES",
    "cloneJSON",
    "useCallback",
    "useRef",
    "useState",
    "clsx",
    "jsx",
    "clsx",
    "jsx",
    "jsxs",
    "useState",
    "useRef",
    "useEffect",
    "exportToCanvas",
    "DEFAULT_EXPORT_PADDING",
    "EXPORT_SCALES",
    "isFirefox",
    "cloneJSON",
    "React",
    "OpenColor",
    "jsx",
    "OpenColor",
    "Fragment",
    "jsx",
    "jsxs",
    "React",
    "clsx",
    "jsx",
    "jsxs",
    "DEFAULT_SIZE",
    "clsx",
    "Fragment",
    "jsx",
    "jsxs",
    "clsx",
    "CLASSES",
    "showSelectedShapeActions",
    "TOOL_TYPE",
    "DEFAULT_SIDEBAR",
    "capitalizeString",
    "mutateElement",
    "arrayToMap",
    "ShapeCache",
    "appState",
    "areEqual",
    "isShallowEqual",
    "React",
    "clsx",
    "jsx",
    "jsxs",
    "DEFAULT_SIZE",
    "clsx",
    "sceneCoordsToViewportCoords",
    "getElementAbsoluteCoords",
    "jsx",
    "jsxs",
    "HighlightIcon",
    "getElementAbsoluteCoords",
    "x2",
    "y2",
    "sceneCoordsToViewportCoords",
    "x",
    "y",
    "useEffect",
    "useRef",
    "jsx",
    "useRef",
    "useEffect",
    "React",
    "useEffect",
    "useRef",
    "CURSOR_TYPE",
    "isShallowEqual",
    "sceneCoordsToViewportCoords",
    "jsx",
    "useRef",
    "useEffect",
    "sceneCoordsToViewportCoords",
    "CURSOR_TYPE",
    "areEqual",
    "isShallowEqual",
    "React",
    "React",
    "useEffect",
    "useRef",
    "isShallowEqual",
    "jsx",
    "useRef",
    "useEffect",
    "getRelevantAppStateProps",
    "areEqual",
    "isShallowEqual",
    "React",
    "useEffect",
    "useRef",
    "throttleRAF",
    "newElement",
    "throttleRAF",
    "throttle",
    "jsx",
    "useRef",
    "useEffect",
    "useCallback",
    "useEffect",
    "useRef",
    "jsx",
    "jsxs",
    "useRef",
    "useCallback",
    "useEffect",
    "getCommonBounds",
    "getElementsInGroup",
    "selectGroupsFromGivenElements",
    "sceneCoordsToViewportCoords",
    "flushSync",
    "jsx",
    "getElementsInGroup",
    "getCommonBounds",
    "sceneCoordsToViewportCoords",
    "flushSync",
    "selectGroupsFromGivenElements",
    "element",
    "Fragment",
    "jsx",
    "jsxs",
    "React",
    "useContext",
    "Emitter",
    "atom",
    "ShapeCache",
    "isEmbeddableElement",
    "embeddableURLValidator",
    "isIframeElement",
    "viewportCoordsToSceneCoords",
    "THEME",
    "isFrameLikeElement",
    "isElementInViewport",
    "sceneCoordsToViewportCoords",
    "KEYS",
    "FRAME_STYLE",
    "CURSOR_TYPE",
    "muteFSAbortError",
    "TOOL_TYPE",
    "isMagicFrameElement",
    "getCommonBounds",
    "newMagicFrameElement",
    "CaptureUpdateAction",
    "newElementWith",
    "isTextElement",
    "isElementLink",
    "updateObject",
    "supportsResizeObserver",
    "debounce",
    "isWritableElement",
    "makeNextSelectedElementIds",
    "file",
    "normalizeEOL",
    "getEmbedLink",
    "normalizeLink",
    "distance",
    "getGridPoint",
    "duplicateElements",
    "syncMovedIndices",
    "arrayToMap",
    "addElementsToFrame",
    "newElement",
    "isBoundToContainer",
    "getContainerElement",
    "redrawTextBoundingBox",
    "selectGroupsForSelectedElements",
    "updateActiveTool",
    "easeOut",
    "scrollX",
    "scrollY",
    "zoom",
    "APP_NAME",
    "MIME_TYPES",
    "isImageElement",
    "CLASSES",
    "isArrowKey",
    "selectedElements",
    "isFlowchartNodeElement",
    "isElementCompletelyInViewport",
    "CODES",
    "isElbowArrow",
    "updateBoundElements",
    "isLineElement",
    "isLinearElement",
    "LinearElementEditor",
    "ARROW_TYPE",
    "getBoundTextElement",
    "bindOrUnbindLinearElements",
    "isBindingEnabled",
    "isLinearElementType",
    "getLineHeight",
    "isArrowElement",
    "getFontString",
    "newTextElement",
    "VERTICAL_ALIGN",
    "getSelectedGroupIds",
    "isIframeLikeElement",
    "hasBoundTextElement",
    "isTransparent",
    "pointFrom",
    "pointDistance",
    "DRAGGING_THRESHOLD",
    "wrapEvent",
    "EVENT",
    "isLocalLink",
    "flushSync",
    "isBindingElement",
    "maybeSuggestBindingsForLinearElementAtCoords",
    "LINE_CONFIRM_THRESHOLD",
    "shouldRotateWithDiscreteAngle",
    "getLockedLinearCursorAlignSize",
    "isPathALoop",
    "POINTER_BUTTON",
    "onPointerUp",
    "addEventListener",
    "event",
    "tupleToCoors",
    "isElementInGroup",
    "getFrameChildren",
    "getElementsInGroup",
    "element",
    "getHoveredElementForBinding",
    "newImageElement",
    "newArrowElement",
    "ROUNDNESS",
    "newLinearElement",
    "newFrameElement",
    "IMAGE_MIME_TYPES",
    "isInitializedImageElement",
    "throttle",
    "syncInvalidIndices",
    "getElementsInResizingFrame",
    "ZOOM_STEP",
    "Scene",
    "rough",
    "COLOR_PALETTE",
    "toValidURL",
    "clsx",
    "getContainingFrame",
    "DEFAULT_REDUCED_GLOBAL_ALPHA",
    "getCornerRadius",
    "getElementsOverlappingFrame",
    "isTestEnv",
    "isDevEnv",
    "error",
    "DEFAULT_TEXT_ALIGN",
    "normalizeText",
    "measureText",
    "text",
    "wrapText",
    "getLineHeightInPx",
    "getShortcutKey",
    "fixBindingsAfterDeletion",
    "shouldShowBoundingBox",
    "hitElementBoundingBox",
    "isTextBindableContainer",
    "getElementAbsoluteCoords",
    "deepCopyElement",
    "isUsingAdaptiveRadius",
    "gridX",
    "gridY",
    "vectorScale",
    "vector",
    "vectorFromPoint",
    "pointRotateRads",
    "vectorNormalize",
    "vectorSubtract",
    "clamp",
    "randomInteger",
    "getSelectionStateForElements",
    "isBindableElement",
    "isInvisiblySmallElement",
    "sceneCoords",
    "elementOverlapsWithFrame",
    "removeElementsFromFrame",
    "updateFrameMembershipOfSelectedElements",
    "replaceAllElementsInFrame",
    "hitElements",
    "hitElement",
    "isSelectedViaGroup",
    "isShallowEqual",
    "currentLang",
    "useEffect",
    "useState",
    "jsx",
    "useState",
    "useEffect",
    "currentLang",
    "clsx",
    "jsx",
    "clsx",
    "clsx",
    "jsx",
    "jsxs",
    "LiveCollaborationTrigger",
    "clsx",
    "jsx",
    "jsxs",
    "Fragment",
    "jsx",
    "jsxs",
    "t",
    "jsx",
    "jsxs",
    "Fragment",
    "jsx",
    "jsxs",
    "hashElementsVersion",
    "hashString",
    "getNonDeletedElements",
    "getTextFromElements",
    "isInvisiblySmallElement",
    "throttle",
    "arrayToMap",
    "isDevEnv",
    "isTestEnv",
    "orderByFractionalIndex",
    "syncInvalidIndices",
    "getFreeDrawSvgPath",
    "isLinearElement",
    "FONT_FAMILY",
    "THEME",
    "MIME_TYPES",
    "ROUNDNESS",
    "DEFAULT_LASER_COLOR",
    "UserIdleState",
    "normalizeLink",
    "mutateElement",
    "newElementWith",
    "CaptureUpdateAction",
    "sceneCoordsToViewportCoords",
    "viewportCoordsToSceneCoords",
    "jsx",
    "jsxs",
    "getCommonBounds",
    "getVisibleSceneBounds",
    "useLayoutEffect",
    "useLayoutEffect",
    "isElementLink",
    "jsx",
    "useEffect",
    "areEqual",
    "key",
    "isShallowEqual",
    "React"
  ]
}
