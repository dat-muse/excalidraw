import {
  $ as d1,
  A as hm,
  B as Jf,
  C as Qf,
  D as e1,
  E as Al,
  F as Xi,
  G as Dl,
  H as _l,
  I as t1,
  J as o1,
  K as Ki,
  L as r1,
  M as n1,
  N as i1,
  O as Rl,
  P as yn,
  Q as a1,
  R as gm,
  S as JI,
  T as wn,
  U as Zi,
  W as l1,
  Y as s1,
  Z as c1,
  _ as Nl,
  a as Zf,
  aa as Bl,
  b as zr,
  ba as fm,
  c as go,
  ca as Fl,
  d as $f,
  da as m1,
  e as Ee,
  ea as bm,
  f as jf,
  fa as Lo,
  g as Z,
  ga as p1,
  h as Ml,
  ha as xm,
  i as jo,
  ia as u1,
  j as sm,
  ja as h1,
  k as cm,
  ka as Ol,
  l as bn,
  la as Em,
  m as dm,
  ma as g1,
  n as xn,
  na as f1,
  o as qf,
  oa as b1,
  p as mm,
  pa as x1,
  q as qo,
  r as Jo,
  s as bt,
  t as qt,
  u as En,
  v as Ll,
  w as pm,
  x as Vi,
  y as Pl,
  z as um,
} from "./chunk-IRHK23LL.js";
import { a as T } from "./chunk-A66AFZZU.js";
import { J as lm } from "./chunk-I4UNSFV6.js";
import { c as Kf } from "./chunk-Z3N5DIM6.js";
import { b as Vf, c as Xf, d as I } from "./chunk-SRAX5OIU.js";
import GG, { useEffect as UG } from "react";
import { DEFAULT_UI_OPTIONS as $I, isShallowEqual as YG } from "@excalidraw/common";
import LT from "clsx";
import Tz from "lodash.throttle";
import Mo, { useContext as Fr } from "react";
import { flushSync as Ko } from "react-dom";
import Iz from "roughjs/bin/rough";
import { nanoid as Cz } from "nanoid";
import {
  clamp as PT,
  pointFrom as se,
  pointDistance as Oi,
  vector as AT,
  pointRotateRads as qg,
  vectorScale as Sz,
  vectorFromPoint as Jg,
  vectorSubtract as DT,
  vectorDot as _T,
  vectorNormalize as RT,
} from "@excalidraw/math";
import {
  COLOR_PALETTE as kz,
  CODES as NT,
  shouldResizeFromCenter as BT,
  shouldMaintainAspectRatio as ml,
  shouldRotateWithDiscreteAngle as Qg,
  isArrowKey as Kd,
  KEYS as Y,
  APP_NAME as Mz,
  CURSOR_TYPE as De,
  DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT as Lz,
  DEFAULT_VERTICAL_ALIGN as FT,
  DRAGGING_THRESHOLD as OT,
  ELEMENT_SHIFT_TRANSLATE_AMOUNT as Pz,
  ELEMENT_TRANSLATE_AMOUNT as zT,
  EVENT as ee,
  FRAME_STYLE as Dr,
  IMAGE_MIME_TYPES as Az,
  IMAGE_RENDER_TIMEOUT as Dz,
  isBrave as _z,
  LINE_CONFIRM_THRESHOLD as ef,
  MAX_ALLOWED_FILE_BYTES as HT,
  MIME_TYPES as _r,
  MQ_MAX_HEIGHT_LANDSCAPE as Rz,
  MQ_MAX_WIDTH_LANDSCAPE as Nz,
  MQ_MAX_WIDTH_PORTRAIT as Bz,
  MQ_RIGHT_SIDEBAR_MIN_WIDTH as Fz,
  POINTER_BUTTON as dn,
  ROUNDNESS as Zd,
  SCROLL_TIMEOUT as Oz,
  TAP_TWICE_TIMEOUT as zz,
  TEXT_TO_CENTER_SNAP_THRESHOLD as Hz,
  THEME as $d,
  THEME_FILTER as Gz,
  TOUCH_CTX_MENU_TIMEOUT as Uz,
  VERTICAL_ALIGN as Yz,
  YOUTUBE_STATES as jd,
  ZOOM_STEP as Wz,
  POINTER_EVENTS as zi,
  TOOL_TYPE as ko,
  isIOS as Vz,
  supportsResizeObserver as GT,
  DEFAULT_COLLISION_THRESHOLD as UT,
  DEFAULT_TEXT_ALIGN as Xz,
  ARROW_TYPE as Rr,
  DEFAULT_REDUCED_GLOBAL_ALPHA as Kz,
  isSafari as Zz,
  isLocalLink as $z,
  normalizeLink as tf,
  toValidURL as jz,
  getGridPoint as nt,
  getLineHeight as YT,
  debounce as WT,
  distance as Hi,
  getFontString as of,
  getNearestScrollableContainer as qz,
  isInputLike as VT,
  isToolIcon as Jz,
  isWritableElement as pl,
  sceneCoordsToViewportCoords as qd,
  tupleToCoors as rf,
  viewportCoordsToSceneCoords as Oe,
  wrapEvent as Qz,
  updateObject as nf,
  updateActiveTool as Zo,
  getShortcutKey as eH,
  isTransparent as tH,
  easeToValuesRAF as oH,
  muteFSAbortError as rH,
  isTestEnv as Sf,
  isDevEnv as kI,
  easeOut as nH,
  updateStable as ul,
  addEventListener as _e,
  normalizeEOL as iH,
  getDateTime as XT,
  isShallowEqual as aH,
  arrayToMap as KT,
  randomInteger as lH,
  CLASSES as sH,
  Emitter as mn,
} from "@excalidraw/common";
import {
  getObservedAppState as cH,
  getCommonBounds as Gi,
  maybeSuggestBindingsForLinearElementAtCoords as ZT,
  getElementAbsoluteCoords as $T,
  bindOrUnbindLinearElements as jT,
  fixBindingsAfterDeletion as dH,
  getHoveredElementForBinding as af,
  isBindingEnabled as lf,
  shouldEnableBindingForPointerEvent as mH,
  updateBoundElements as sf,
  getSuggestedBindingsForArrows as cf,
  LinearElementEditor as ve,
  newElementWith as pn,
  newFrameElement as pH,
  newFreeDrawElement as uH,
  newEmbeddableElement as qT,
  newMagicFrameElement as JT,
  newIframeElement as hH,
  newArrowElement as gH,
  newElement as fH,
  newImageElement as bH,
  newLinearElement as xH,
  newTextElement as QT,
  refreshTextDimensions as EH,
  deepCopyElement as eI,
  duplicateElements as tI,
  hasBoundTextElement as oI,
  isArrowElement as df,
  isBindingElement as mf,
  isBindingElementType as yH,
  isBoundToContainer as pf,
  isFrameLikeElement as Zt,
  isImageElement as un,
  isEmbeddableElement as Nr,
  isInitializedImageElement as hl,
  isLinearElement as $t,
  isLinearElementType as wH,
  isUsingAdaptiveRadius as vH,
  isIframeElement as Ui,
  isIframeLikeElement as gl,
  isMagicFrameElement as uf,
  isTextBindableContainer as rI,
  isElbowArrow as We,
  isFlowchartNodeElement as TH,
  isBindableElement as IH,
  isTextElement as po,
  getLockedLinearCursorAlignSize as nI,
  getNormalizedDimensions as CH,
  isElementCompletelyInViewport as hf,
  isElementInViewport as iI,
  isInvisiblySmallElement as aI,
  getCornerRadius as SH,
  isPathALoop as lI,
  createSrcDoc as sI,
  embeddableURLValidator as gf,
  maybeParseEmbedSrc as kH,
  getEmbedLink as Jd,
  getInitializedImageElements as MH,
  normalizeSVG as cI,
  updateImageCache as LH,
  getBoundTextElement as ff,
  getContainerCenter as bf,
  getContainerElement as dI,
  isValidTextContainer as PH,
  redrawTextBoundingBox as AH,
  shouldShowBoundingBox as DH,
  getFrameChildren as mI,
  isCursorInFrame as pI,
  addElementsToFrame as xf,
  replaceAllElementsInFrame as _H,
  removeElementsFromFrame as RH,
  getElementsInResizingFrame as Ef,
  getElementsInNewFrame as NH,
  getContainingFrame as yf,
  elementOverlapsWithFrame as BH,
  updateFrameMembershipOfSelectedElements as uI,
  isElementInFrame as hI,
  getFrameLikeTitle as FH,
  getElementsOverlappingFrame as OH,
  filterElementsEligibleAsFrameChildren as zH,
  hitElementBoundText as HH,
  hitElementBoundingBoxOnly as GH,
  hitElementItself as fl,
  getVisibleSceneBounds as UH,
  FlowChartCreator as YH,
  FlowChartNavigator as WH,
  getLinkDirectionFromKey as gI,
  cropElement as VH,
  wrapText as XH,
  isElementLink as wf,
  parseElementLinkFromURL as KH,
  isMeasureTextSupported as ZH,
  normalizeText as $H,
  measureText as fI,
  getLineHeightInPx as jH,
  getApproxMinLineWidth as qH,
  getApproxMinLineHeight as JH,
  getMinTextElementWidth as QH,
  ShapeCache as bl,
  getRenderOpacity as eG,
  editGroupForSelectedElement as tG,
  getElementsInGroup as xl,
  getSelectedGroupIdForElement as oG,
  getSelectedGroupIds as rG,
  isElementInGroup as bI,
  isSelectedViaGroup as nG,
  selectGroupsForSelectedElements as uo,
  syncInvalidIndices as MI,
  syncMovedIndices as xI,
  excludeElementsInFramesFromSelection as iG,
  getSelectionStateForElements as aG,
  makeNextSelectedElementIds as ye,
  getResizeOffsetXY as lG,
  getResizeArrowDirection as sG,
  transformElements as cG,
  getCursorForResizingElement as EI,
  getElementWithTransformHandleType as yI,
  getTransformHandleTypeFromCoords as wI,
  dragNewElement as vI,
  dragSelectedElements as dG,
  getDragOffsetXY as mG,
  isNonDeletedElement as TI,
  Scene as II,
  Store as pG,
  CaptureUpdateAction as dt,
  hitElementBoundingBox as uG,
  isLineElement as vf,
  isSimpleArrow as hG,
} from "@excalidraw/element";
import { KEYS as Vm, updateActiveTool as pC } from "@excalidraw/common";
import { getNonDeletedElements as Xm } from "@excalidraw/element";
import { fixBindingsAfterDeletion as uC } from "@excalidraw/element";
import { LinearElementEditor as mb } from "@excalidraw/element";
import { newElementWith as ps } from "@excalidraw/element";
import { getContainerElement as pb } from "@excalidraw/element";
import {
  isBoundToContainer as ds,
  isElbowArrow as hC,
  isFrameLikeElement as gC,
} from "@excalidraw/element";
import { getFrameChildren as fC } from "@excalidraw/element";
import {
  getElementsInGroup as Km,
  selectGroupsForSelectedElements as bC,
} from "@excalidraw/element";
import { CaptureUpdateAction as ms } from "@excalidraw/element";
import { isDevEnv as oC } from "@excalidraw/common";
import { atom as me, createStore as QI } from "jotai";
import { createIsolation as eC } from "jotai-scope";
var E1 = eC();
var { useAtom: ne, useSetAtom: Qo, useAtomValue: zl, useStore: $G } = E1,
  y1 = E1.Provider,
  He = QI();
var tC = Vf({
  "./locales/ar-SA.json": () => import("./locales/ar-SA-G6X2FPQ2.js"),
  "./locales/az-AZ.json": () => import("./locales/az-AZ-76LH7QW2.js"),
  "./locales/bg-BG.json": () => import("./locales/bg-BG-XCXSNQG7.js"),
  "./locales/bn-BD.json": () => import("./locales/bn-BD-2XOGV67Q.js"),
  "./locales/ca-ES.json": () => import("./locales/ca-ES-6MX7JW3Y.js"),
  "./locales/cs-CZ.json": () => import("./locales/cs-CZ-2BRQDIVT.js"),
  "./locales/da-DK.json": () => import("./locales/da-DK-5WZEPLOC.js"),
  "./locales/de-DE.json": () => import("./locales/de-DE-XR44H4JA.js"),
  "./locales/el-GR.json": () => import("./locales/el-GR-BZB4AONW.js"),
  "./locales/en.json": () => import("./locales/en-TYY6KWIJ.js"),
  "./locales/es-ES.json": () => import("./locales/es-ES-U4NZUMDT.js"),
  "./locales/eu-ES.json": () => import("./locales/eu-ES-A7QVB2H4.js"),
  "./locales/fa-IR.json": () => import("./locales/fa-IR-HGAKTJCU.js"),
  "./locales/fi-FI.json": () => import("./locales/fi-FI-Z5N7JZ37.js"),
  "./locales/fr-FR.json": () => import("./locales/fr-FR-RHASNOE6.js"),
  "./locales/gl-ES.json": () => import("./locales/gl-ES-HMX3MZ6V.js"),
  "./locales/he-IL.json": () => import("./locales/he-IL-6SHJWFNN.js"),
  "./locales/hi-IN.json": () => import("./locales/hi-IN-IWLTKZ5I.js"),
  "./locales/hu-HU.json": () => import("./locales/hu-HU-A5ZG7DT2.js"),
  "./locales/id-ID.json": () => import("./locales/id-ID-SAP4L64H.js"),
  "./locales/it-IT.json": () => import("./locales/it-IT-JPQ66NNP.js"),
  "./locales/ja-JP.json": () => import("./locales/ja-JP-DBVTYXUO.js"),
  "./locales/kaa.json": () => import("./locales/kaa-6HZHGXH3.js"),
  "./locales/kab-KAB.json": () => import("./locales/kab-KAB-ZGHBKWFO.js"),
  "./locales/kk-KZ.json": () => import("./locales/kk-KZ-P5N5QNE5.js"),
  "./locales/km-KH.json": () => import("./locales/km-KH-HSX4SM5Z.js"),
  "./locales/ko-KR.json": () => import("./locales/ko-KR-MTYHY66A.js"),
  "./locales/ku-TR.json": () => import("./locales/ku-TR-6OUDTVRD.js"),
  "./locales/lt-LT.json": () => import("./locales/lt-LT-XHIRWOB4.js"),
  "./locales/lv-LV.json": () => import("./locales/lv-LV-5QDEKY6T.js"),
  "./locales/mr-IN.json": () => import("./locales/mr-IN-CRQNXWMA.js"),
  "./locales/my-MM.json": () => import("./locales/my-MM-5M5IBNSE.js"),
  "./locales/nb-NO.json": () => import("./locales/nb-NO-T6EIAALU.js"),
  "./locales/nl-NL.json": () => import("./locales/nl-NL-IS3SIHDZ.js"),
  "./locales/nn-NO.json": () => import("./locales/nn-NO-6E72VCQL.js"),
  "./locales/oc-FR.json": () => import("./locales/oc-FR-POXYY2M6.js"),
  "./locales/pa-IN.json": () => import("./locales/pa-IN-N4M65BXN.js"),
  "./locales/percentages.json": () => import("./locales/percentages-BXMCSKIN.js"),
  "./locales/pl-PL.json": () => import("./locales/pl-PL-T2D74RX3.js"),
  "./locales/pt-BR.json": () => import("./locales/pt-BR-5N22H2LF.js"),
  "./locales/pt-PT.json": () => import("./locales/pt-PT-UZXXM6DQ.js"),
  "./locales/ro-RO.json": () => import("./locales/ro-RO-JPDTUUEW.js"),
  "./locales/ru-RU.json": () => import("./locales/ru-RU-B4JR7IUQ.js"),
  "./locales/si-LK.json": () => import("./locales/si-LK-N5RQ5JYF.js"),
  "./locales/sk-SK.json": () => import("./locales/sk-SK-C5VTKIMK.js"),
  "./locales/sl-SI.json": () => import("./locales/sl-SI-NN7IZMDC.js"),
  "./locales/sv-SE.json": () => import("./locales/sv-SE-XGPEYMSR.js"),
  "./locales/ta-IN.json": () => import("./locales/ta-IN-2NMHFXQM.js"),
  "./locales/th-TH.json": () => import("./locales/th-TH-HPSO5L25.js"),
  "./locales/tr-TR.json": () => import("./locales/tr-TR-DEFEU3FU.js"),
  "./locales/uk-UA.json": () => import("./locales/uk-UA-QMV73CPH.js"),
  "./locales/vi-VN.json": () => import("./locales/vi-VN-M7AON7JQ.js"),
  "./locales/zh-CN.json": () => import("./locales/zh-CN-LNUGB5OW.js"),
  "./locales/zh-HK.json": () => import("./locales/zh-HK-E62DVLB3.js"),
  "./locales/zh-TW.json": () => import("./locales/zh-TW-RAJ6MFWO.js"),
});
var rC = 85,
  fo = { code: "en", label: "English" },
  Tn = [
    fo,
    ...[
      { code: "ar-SA", label: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629", rtl: !0 },
      { code: "bg-BG", label: "\u0411\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438" },
      { code: "ca-ES", label: "Catal\xE0" },
      { code: "cs-CZ", label: "\u010Cesky" },
      { code: "de-DE", label: "Deutsch" },
      { code: "el-GR", label: "\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC" },
      { code: "es-ES", label: "Espa\xF1ol" },
      { code: "eu-ES", label: "Euskara" },
      { code: "fa-IR", label: "\u0641\u0627\u0631\u0633\u06CC", rtl: !0 },
      { code: "fi-FI", label: "Suomi" },
      { code: "fr-FR", label: "Fran\xE7ais" },
      { code: "gl-ES", label: "Galego" },
      { code: "he-IL", label: "\u05E2\u05D1\u05E8\u05D9\u05EA", rtl: !0 },
      { code: "hi-IN", label: "\u0939\u093F\u0928\u094D\u0926\u0940" },
      { code: "hu-HU", label: "Magyar" },
      { code: "id-ID", label: "Bahasa Indonesia" },
      { code: "it-IT", label: "Italiano" },
      { code: "ja-JP", label: "\u65E5\u672C\u8A9E" },
      { code: "kab-KAB", label: "Taqbaylit" },
      { code: "kk-KZ", label: "\u049A\u0430\u0437\u0430\u049B \u0442\u0456\u043B\u0456" },
      { code: "ko-KR", label: "\uD55C\uAD6D\uC5B4" },
      { code: "ku-TR", label: "Kurd\xEE" },
      { code: "lt-LT", label: "Lietuvi\u0173" },
      { code: "lv-LV", label: "Latvie\u0161u" },
      { code: "my-MM", label: "Burmese" },
      { code: "nb-NO", label: "Norsk bokm\xE5l" },
      { code: "nl-NL", label: "Nederlands" },
      { code: "nn-NO", label: "Norsk nynorsk" },
      { code: "oc-FR", label: "Occitan" },
      { code: "pa-IN", label: "\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40" },
      { code: "pl-PL", label: "Polski" },
      { code: "pt-BR", label: "Portugu\xEAs Brasileiro" },
      { code: "pt-PT", label: "Portugu\xEAs" },
      { code: "ro-RO", label: "Rom\xE2n\u0103" },
      { code: "ru-RU", label: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
      { code: "sk-SK", label: "Sloven\u010Dina" },
      { code: "sv-SE", label: "Svenska" },
      { code: "sl-SI", label: "Sloven\u0161\u010Dina" },
      { code: "tr-TR", label: "T\xFCrk\xE7e" },
      { code: "uk-UA", label: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430" },
      { code: "zh-CN", label: "\u7B80\u4F53\u4E2D\u6587" },
      { code: "zh-TW", label: "\u7E41\u9AD4\u4E2D\u6587" },
      { code: "vi-VN", label: "Ti\u1EBFng Vi\u1EC7t" },
      { code: "mr-IN", label: "\u092E\u0930\u093E\u0920\u0940" },
    ]
      .filter((e) => Kf[e.code] >= rC)
      .sort((e, o) => (e.label > o.label ? 1 : -1)),
  ],
  Gl = "__test__";
oC() &&
  Tn.unshift(
    { code: Gl, label: "test language" },
    { code: `${Gl}.rtl`, label: "\u202Atest language (rtl)\u202C", rtl: !0 }
  );
var vn = fo,
  Hl = {},
  Ul = async (e) => {
    if (
      ((vn = e),
      (document.documentElement.dir = vn.rtl ? "rtl" : "ltr"),
      (document.documentElement.lang = vn.code),
      e.code.startsWith(Gl))
    )
      Hl = {};
    else
      try {
        Hl = await tC(`./locales/${vn.code}.json`);
      } catch (o) {
        console.error(`Failed to load language ${e.code}:`, o.message), (Hl = lm);
      }
    He.set(v1, e.code);
  },
  Po = () => vn,
  w1 = (e, o) => {
    for (let t = 0; t < o.length; ++t) {
      let r = o[t];
      if (e[r] === void 0) return;
      e = e[r];
    }
    if (typeof e == "string") return e;
  },
  g = (e, o, t) => {
    if (vn.code.startsWith(Gl))
      return `\u202A[[${o ? `${e}(${JSON.stringify(o).slice(1, -1)})` : e}]]\u202C`;
    let r = e.split("."),
      n = w1(Hl, r) || w1(lm, r) || t;
    if (n === void 0) {
      let i = `Can't find translation for ${e}`;
      if (T.PROD) return console.warn(i), "";
      throw new Error(i);
    }
    if (o) for (let i in o) n = n.replace(`{{${i}}}`, String(o[i]));
    return n;
  },
  v1 = me(fo.code),
  ze = () => {
    let e = zl(v1);
    return { t: g, langCode: e };
  };
import nC from "clsx";
import iC from "open-color";
import et from "react";
import { THEME as aC } from "@excalidraw/common";
import { Fragment as be, jsx as h, jsxs as D } from "react/jsx-runtime";
var Jt = (e) => "var(--icon-fill-color)",
  T1 = (e) => (e === aC.LIGHT ? iC.white : "#1e1e1e"),
  L = (e, o = 512) => {
    let {
      width: t = 512,
      height: r = t,
      mirror: n,
      style: i,
      ...a
    } = typeof o == "number" ? { width: o } : o;
    return h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      role: "img",
      viewBox: `0 0 ${t} ${r}`,
      className: nC({ "rtl-mirror": n }),
      style: i,
      ...a,
      children: typeof e == "string" ? h("path", { fill: "currentColor", d: e }) : e,
    });
  },
  z = {
    width: 24,
    height: 24,
    fill: "none",
    strokeWidth: 2,
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
  },
  te = {
    width: 20,
    height: 20,
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
  },
  mU = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("rect", { x: 3, y: 8, width: 18, height: 4, rx: 1 }),
        h("line", { x1: 12, y1: 8, x2: 12, y2: 21 }),
        h("path", { d: "M19 12v7a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-7" }),
        h("path", {
          d: "M7.5 8a2.5 2.5 0 0 1 0 -5a4.8 8 0 0 1 4.5 5a4.8 8 0 0 1 4.5 -5a2.5 2.5 0 0 1 0 5",
        }),
      ],
    }),
    z
  ),
  In = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }),
        h("path", { d: "M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }),
        h("line", { x1: "3", y1: "6", x2: "3", y2: "19" }),
        h("line", { x1: "12", y1: "6", x2: "12", y2: "19" }),
        h("line", { x1: "21", y1: "6", x2: "21", y2: "19" }),
      ],
    }),
    z
  ),
  I1 = L(
    D("svg", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
        h("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
      ],
    }),
    z
  ),
  C1 = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("circle", { cx: "12", cy: "12", r: "1" }),
        h("circle", { cx: "12", cy: "19", r: "1" }),
        h("circle", { cx: "12", cy: "5", r: "1" }),
      ],
    }),
    z
  ),
  S1 = L(
    D("svg", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M9 4v6l-2 4v2h10v-2l-2 -4v-6" }),
        h("line", { x1: "12", y1: "16", x2: "12", y2: "21" }),
        h("line", { x1: "8", y1: "4", x2: "16", y2: "4" }),
      ],
    }),
    z
  ),
  ym = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M12 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
        h("path", { d: "M19 8m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
        h("path", { d: "M5 11m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
        h("path", { d: "M15 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
        h("path", { d: "M6.5 9.5l3.5 -3" }),
        h("path", { d: "M14 5.5l3 1.5" }),
        h("path", { d: "M18.5 10l-2.5 7" }),
        h("path", { d: "M13.5 17.5l-7 -5" }),
      ],
    }),
    z
  ),
  Hr = L(
    D("g", {
      children: [
        h("path", {
          d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z",
          stroke: "currentColor",
          strokeWidth: "1.25",
        }),
        h("path", {
          d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z",
          stroke: "currentColor",
          strokeWidth: "1.25",
        }),
        h("mask", {
          id: "UnlockedIcon",
          style: { maskType: "alpha" },
          maskUnits: "userSpaceOnUse",
          x: 6,
          y: 1,
          width: 9,
          height: 9,
          children: h("path", {
            stroke: "none",
            d: "M6.399 9.561V5.175c0-.93.401-1.823 1.116-2.48a3.981 3.981 0 0 1 2.693-1.028c1.01 0 1.98.37 2.694 1.027.715.658 1.116 1.55 1.116 2.481",
            fill: "#fff",
          }),
        }),
        h("g", {
          mask: "url(#UnlockedIcon)",
          children: h("path", {
            stroke: "none",
            d: "M5.149 9.561v1.25h2.5v-1.25h-2.5Zm5.06-7.894V.417v1.25Zm2.559 3.508v1.25h2.5v-1.25h-2.5ZM7.648 8.51V5.175h-2.5V8.51h2.5Zm0-3.334c0-.564.243-1.128.713-1.561L6.668 1.775c-.959.883-1.52 2.104-1.52 3.4h2.5Zm.713-1.561a2.732 2.732 0 0 1 1.847-.697v-2.5c-1.31 0-2.585.478-3.54 1.358L8.36 3.614Zm1.847-.697c.71 0 1.374.26 1.847.697l1.694-1.839a5.231 5.231 0 0 0-3.54-1.358v2.5Zm1.847.697c.47.433.713.997.713 1.561h2.5c0-1.296-.56-2.517-1.52-3.4l-1.693 1.839Z",
            fill: "currentColor",
          }),
        }),
      ],
    }),
    te
  ),
  Cn = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", {
          d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z",
        }),
        h("path", { d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z" }),
        h("path", {
          d: "M6.667 8.333V5.417C6.667 3.806 8.159 2.5 10 2.5c1.841 0 3.333 1.306 3.333 2.917v2.916",
        }),
      ],
    }),
    te
  ),
  k1 = L(
    h("g", {
      fill: "currentColor",
      children: h("path", {
        d: "M12 2a5 5 0 0 1 5 5v3a3 3 0 0 1 3 3v6a3 3 0 0 1 -3 3h-10a3 3 0 0 1 -3 -3v-6a3 3 0 0 1 3 -3v-3a5 5 0 0 1 5 -5m0 12a2 2 0 0 0 -1.995 1.85l-.005 .15a2 2 0 1 0 2 -2m0 -10a3 3 0 0 0 -3 3v3h6v-3a3 3 0 0 0 -3 -3",
      }),
    }),
    { width: 24, height: 24 }
  ),
  M1 = L(
    D(be, {
      children: [
        h("path", {
          d: "M38.5 83.5c-14-2-17.833-10.473-21-22.5C14.333 48.984 12 22 12 12.5",
          stroke: "currentColor",
          strokeWidth: 2,
          strokeLinecap: "round",
        }),
        h("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "m12.005 10.478 7.905 14.423L6 25.75l6.005-15.273Z",
          fill: "currentColor",
        }),
        h("path", {
          d: "M12.005 10.478c1.92 3.495 3.838 7 7.905 14.423m-7.905-14.423c3.11 5.683 6.23 11.368 7.905 14.423m0 0c-3.68.226-7.35.455-13.91.85m13.91-.85c-5.279.33-10.566.647-13.91.85m0 0c1.936-4.931 3.882-9.86 6.005-15.273M6 25.75c2.069-5.257 4.135-10.505 6.005-15.272",
          stroke: "currentColor",
          strokeWidth: 2,
          strokeLinecap: "round",
        }),
      ],
    }),
    { width: 41, height: 94, fill: "none" }
  ),
  L1 = L(
    D(be, {
      children: [
        h("path", {
          d: "M18.026 1.232c-5.268 13.125-5.548 33.555 3.285 42.311 8.823 8.75 33.31 12.304 42.422 13.523",
          stroke: "currentColor",
          strokeWidth: 2,
          strokeLinecap: "round",
        }),
        h("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "m72.181 59.247-13.058-10-2.948 13.62 16.006-3.62Z",
          fill: "currentColor",
        }),
        h("path", {
          d: "M72.181 59.247c-3.163-2.429-6.337-4.856-13.058-10m13.058 10c-5.145-3.936-10.292-7.882-13.058-10m0 0c-.78 3.603-1.563 7.196-2.948 13.62m2.948-13.62c-1.126 5.168-2.24 10.346-2.948 13.62m0 0c5.168-1.166 10.334-2.343 16.006-3.62m-16.006 3.62c5.51-1.248 11.01-2.495 16.006-3.62",
          stroke: "currentColor",
          strokeWidth: 2,
          strokeLinecap: "round",
        }),
      ],
    }),
    { width: 85, height: 71, fill: "none" }
  ),
  P1 = L(
    D(be, {
      children: [
        h("path", {
          d: "M1 77c14-2 31.833-11.973 35-24 3.167-12.016-6-35-9.5-43.5",
          stroke: "currentColor",
          strokeWidth: 2,
          strokeLinecap: "round",
        }),
        h("path", {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "m24.165 1.093-2.132 16.309 13.27-4.258-11.138-12.05Z",
          fill: "currentColor",
        }),
        h("path", {
          d: "M24.165 1.093c-.522 3.953-1.037 7.916-2.132 16.309m2.131-16.309c-.835 6.424-1.68 12.854-2.13 16.308m0 0c3.51-1.125 7.013-2.243 13.27-4.257m-13.27 4.257c5.038-1.608 10.08-3.232 13.27-4.257m0 0c-3.595-3.892-7.197-7.777-11.14-12.05m11.14 12.05c-3.837-4.148-7.667-8.287-11.14-12.05",
          stroke: "currentColor",
          strokeWidth: 2,
          strokeLinecap: "round",
        }),
      ],
    }),
    { width: 38, height: 78, fill: "none" }
  ),
  pU = L(
    h("g", {
      fill: "currentColor",
      children: h("path", {
        d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
        fill: "currentColor",
      }),
    }),
    { width: 40, height: 40, fill: "none" }
  ),
  A1 = L(
    D("g", {
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M6 6l4.153 11.793a0.365 .365 0 0 0 .331 .207a0.366 .366 0 0 0 .332 -.207l2.184 -4.793l4.787 -1.994a0.355 .355 0 0 0 .213 -.323a0.355 .355 0 0 0 -.213 -.323l-11.787 -4.36z",
        }),
        h("path", { d: "M13.5 13.5l4.5 4.5" }),
      ],
    }),
    { fill: "none", width: 22, height: 22, strokeWidth: 1.25 }
  ),
  $i = L(
    D("g", {
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: 1.5,
      children: [
        h("path", {
          d: "M4.028 13.252c-.657 -.972 -1.028 -2.078 -1.028 -3.252c0 -3.866 4.03 -7 9 -7s9 3.134 9 7s-4.03 7 -9 7c-1.913 0 -3.686 -.464 -5.144 -1.255",
        }),
        h("path", { d: "M5 15m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
        h("path", { d: "M5 17c0 1.42 .316 2.805 1 4" }),
      ],
    }),
    { fill: "none", width: 22, height: 22, strokeWidth: 1.25 }
  ),
  Yl = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2" }),
      ],
    }),
    z
  ),
  Wl = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M10.5 20.4l-6.9 -6.9c-.781 -.781 -.781 -2.219 0 -3l6.9 -6.9c.781 -.781 2.219 -.781 3 0l6.9 6.9c.781 .781 .781 2.219 0 3l-6.9 6.9c-.781 .781 -2.219 .781 -3 0z",
        }),
      ],
    }),
    z
  ),
  Vl = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("circle", { cx: "12", cy: "12", r: "9" }),
      ],
    }),
    z
  ),
  D1 = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
        h("line", { x1: "15", y1: "16", x2: "19", y2: "12" }),
        h("line", { x1: "15", y1: "8", x2: "19", y2: "12" }),
      ],
    }),
    z
  ),
  Xl = L(h("path", { d: "M4.167 10h11.666", strokeWidth: "1.5" }), te),
  _1 = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M20 17v-12c0 -1.121 -.879 -2 -2 -2s-2 .879 -2 2v12l2 2l2 -2z" }),
        h("path", { d: "M16 7h4" }),
        h("path", { d: "M18 19h-13a2 2 0 1 1 0 -4h4a2 2 0 1 0 0 -4h-3" }),
      ],
    }),
    z
  ),
  er = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", {
          clipRule: "evenodd",
          d: "m7.643 15.69 7.774-7.773a2.357 2.357 0 1 0-3.334-3.334L4.31 12.357a3.333 3.333 0 0 0-.977 2.357v1.953h1.953c.884 0 1.732-.352 2.357-.977Z",
        }),
        h("path", { d: "m11.25 5.417 3.333 3.333" }),
      ],
    }),
    te
  ),
  Sn = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("line", { x1: "4", y1: "20", x2: "7", y2: "20" }),
        h("line", { x1: "14", y1: "20", x2: "21", y2: "20" }),
        h("line", { x1: "6.9", y1: "15", x2: "13.8", y2: "15" }),
        h("line", { x1: "10.2", y1: "6.3", x2: "16", y2: "20" }),
        h("polyline", { points: "5 20 11 4 13 4 20 20" }),
      ],
    }),
    z
  ),
  R1 = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", { d: "M12.5 6.667h.01" }),
        h("path", {
          d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z",
        }),
        h("path", { d: "m3.333 12.5 3.334-3.333c.773-.745 1.726-.745 2.5 0l4.166 4.166" }),
        h("path", { d: "m11.667 11.667.833-.834c.774-.744 1.726-.744 2.5 0l1.667 1.667" }),
      ],
    }),
    te
  ),
  N1 = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M19 20h-10.5l-4.21 -4.3a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9.2 9.3",
        }),
        h("path", { d: "M18 13.3l-6.3 -6.3" }),
      ],
    }),
    z
  ),
  wm = L(h("path", { strokeWidth: "1.25", d: "M10 4.167v11.666M4.167 10h11.666" }), te),
  vm = L(h("path", { d: "M5 10h10", strokeWidth: "1.25" }), te),
  B1 = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M21 21l-6 -6" }),
        h("path", {
          d: "M3.268 12.043a7.017 7.017 0 0 0 6.634 4.957a7.012 7.012 0 0 0 7.043 -6.131a7 7 0 0 0 -5.314 -7.672a7.021 7.021 0 0 0 -8.241 4.403",
        }),
        h("path", { d: "M3 4v4h4" }),
      ],
    }),
    z
  ),
  kt = L(
    h("path", {
      strokeWidth: "1.25",
      d: "M3.333 5.833h13.334M8.333 9.167v5M11.667 9.167v5M4.167 5.833l.833 10c0 .92.746 1.667 1.667 1.667h6.666c.92 0 1.667-.746 1.667-1.667l.833-10M7.5 5.833v-2.5c0-.46.373-.833.833-.833h3.334c.46 0 .833.373.833.833v2.5",
    }),
    te
  ),
  Tm = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("polyline", { points: "12 16 18 10 12 4" }),
        h("polyline", { points: "8 4 2 10 8 16" }),
      ],
    }),
    te
  ),
  ji = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", {
          d: "M14.375 6.458H8.958a2.5 2.5 0 0 0-2.5 2.5v5.417a2.5 2.5 0 0 0 2.5 2.5h5.417a2.5 2.5 0 0 0 2.5-2.5V8.958a2.5 2.5 0 0 0-2.5-2.5Z",
        }),
        h("path", {
          clipRule: "evenodd",
          d: "M11.667 3.125c.517 0 .986.21 1.325.55.34.338.55.807.55 1.325v1.458H8.333c-.485 0-.927.185-1.26.487-.343.312-.57.75-.609 1.24l-.005 5.357H5a1.87 1.87 0 0 1-1.326-.55 1.87 1.87 0 0 1-.549-1.325V5c0-.518.21-.987.55-1.326.338-.34.807-.549 1.325-.549h6.667Z",
        }),
      ],
    }),
    te
  ),
  qi = L(
    h("path", {
      clipRule: "evenodd",
      d: "M10 2.5h.328a6.25 6.25 0 0 0 6.6 10.372A7.5 7.5 0 1 1 10 2.493V2.5Z",
      stroke: "currentColor",
    }),
    te
  ),
  Ji = L(
    h("g", {
      stroke: "currentColor",
      strokeLinejoin: "round",
      children: h("path", {
        d: "M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM10 4.167V2.5M14.167 5.833l1.166-1.166M15.833 10H17.5M14.167 14.167l1.166 1.166M10 15.833V17.5M5.833 14.167l-1.166 1.166M5 10H3.333M5.833 5.833 4.667 4.667",
      }),
    }),
    { ...te, strokeWidth: 1.5 }
  ),
  Kl = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("line", { x1: "4", y1: "6", x2: "20", y2: "6" }),
        h("line", { x1: "4", y1: "12", x2: "20", y2: "12" }),
        h("line", { x1: "4", y1: "18", x2: "20", y2: "18" }),
      ],
    }),
    z
  ),
  Gr = L(
    h("path", {
      strokeWidth: "1.25",
      d: "M3.333 14.167v1.666c0 .92.747 1.667 1.667 1.667h10c.92 0 1.667-.746 1.667-1.667v-1.666M5.833 9.167 10 13.333l4.167-4.166M10 3.333v10",
    }),
    te
  ),
  kn = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("circle", { cx: "12", cy: "12", r: "9" }),
        h("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }),
        h("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" }),
      ],
    }),
    z
  ),
  F1 = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("circle", { cx: "12", cy: "12", r: "9" }),
        h("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }),
        h("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" }),
      ],
    }),
    z
  ),
  Im = L(
    h("path", {
      strokeWidth: "1.25",
      d: "M9.167 5.833H5.833c-1.254 0-2.5 1.282-2.5 2.5v5.834c0 1.283 1.252 2.5 2.5 2.5h5.834c1.251 0 2.5-1.25 2.5-2.5v-3.334M8.333 11.667l8.334-8.334M12.5 3.333h4.167V7.5",
    }),
    te
  ),
  Zl = L(
    h("path", {
      d: "M7.5 15.833c-3.583 1.167-3.583-2.083-5-2.5m10 4.167v-2.917c0-.833.083-1.166-.417-1.666 2.334-.25 4.584-1.167 4.584-5a3.833 3.833 0 0 0-1.084-2.667 3.5 3.5 0 0 0-.083-2.667s-.917-.25-2.917 1.084a10.25 10.25 0 0 0-5.166 0C5.417 2.333 4.5 2.583 4.5 2.583a3.5 3.5 0 0 0-.083 2.667 3.833 3.833 0 0 0-1.084 2.667c0 3.833 2.25 4.75 4.584 5-.5.5-.5 1-.417 1.666V17.5",
      strokeWidth: "1.25",
    }),
    te
  ),
  O1 = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", {
          d: "M7.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM12.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM6.25 6.25c2.917-.833 4.583-.833 7.5 0M5.833 13.75c2.917.833 5.417.833 8.334 0",
        }),
        h("path", {
          d: "M12.917 14.167c0 .833 1.25 2.5 1.666 2.5 1.25 0 2.361-1.39 2.917-2.5.556-1.39.417-4.861-1.25-9.584-1.214-.846-2.5-1.116-3.75-1.25l-.833 2.084M7.083 14.167c0 .833-1.13 2.5-1.526 2.5-1.191 0-2.249-1.39-2.778-2.5-.529-1.39-.397-4.861 1.19-9.584 1.157-.846 2.318-1.116 3.531-1.25l.833 2.084",
        }),
      ],
    }),
    te
  ),
  z1 = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M4 4l11.733 16h4.267l-11.733 -16z" }),
        h("path", { d: "M4 20l6.768 -6.768m2.46 -2.46l6.772 -6.772" }),
      ],
    }),
    z
  ),
  H1 = L(h("polyline", { fill: "none", stroke: "currentColor", points: "20 6 9 17 4 12" }), {
    width: 24,
    height: 24,
  }),
  Qi = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", {
          d: "M8.333 11.667a2.917 2.917 0 0 0 4.167 0l3.333-3.334a2.946 2.946 0 1 0-4.166-4.166l-.417.416",
        }),
        h("path", {
          d: "M11.667 8.333a2.917 2.917 0 0 0-4.167 0l-3.333 3.334a2.946 2.946 0 0 0 4.166 4.166l.417-.416",
        }),
      ],
    }),
    te
  ),
  G1 = L(
    "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z",
    { width: 448, height: 512 }
  ),
  U1 = L(
    "M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z",
    { width: 448, height: 512 }
  ),
  Mn = L(
    h("path", {
      d: "m9.257 6.351.183.183H15.819c.34 0 .727.182 1.051.506.323.323.505.708.505 1.05v5.819c0 .316-.183.7-.52 1.035-.337.338-.723.522-1.037.522H4.182c-.352 0-.74-.181-1.058-.5-.318-.318-.499-.705-.499-1.057V5.182c0-.351.181-.736.5-1.054.32-.321.71-.503 1.057-.503H6.53l2.726 2.726Z",
      strokeWidth: "1.25",
    }),
    te
  ),
  uU = L(
    "M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z",
    { width: 384, height: 512 }
  ),
  Y1 = L(
    "M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"
  ),
  $l = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M5 16l1.465 1.638a2 2 0 1 1 -3.015 .099l1.55 -1.737z" }),
        h("path", {
          d: "M13.737 9.737c2.299 -2.3 3.23 -5.095 2.081 -6.245c-1.15 -1.15 -3.945 -.217 -6.244 2.082c-2.3 2.299 -3.231 5.095 -2.082 6.244c1.15 1.15 3.946 .218 6.245 -2.081z",
        }),
        h("path", {
          d: "M7.492 11.818c.362 .362 .768 .676 1.208 .934l6.895 4.047c1.078 .557 2.255 -.075 3.692 -1.512c1.437 -1.437 2.07 -2.614 1.512 -3.692c-.372 -.718 -1.72 -3.017 -4.047 -6.895a6.015 6.015 0 0 0 -.934 -1.208",
        }),
      ],
    }),
    z
  ),
  W1 = L(h("g", { strokeWidth: 1.5, children: h("path", { d: "M6 18l12 -12" }) }), z),
  jl = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M15 8h.01" }),
        h("path", { d: "M12 20h-5a3 3 0 0 1 -3 -3v-10a3 3 0 0 1 3 -3h10a3 3 0 0 1 3 3v5" }),
        h("path", { d: "M4 15l4 -4c.928 -.893 2.072 -.893 3 0l4 4" }),
        h("path", { d: "M14 14l1 -1c.617 -.593 1.328 -.793 2.009 -.598" }),
        h("path", { d: "M19 16v6" }),
        h("path", { d: "M22 19l-3 3l-3 -3" }),
      ],
    }),
    z
  ),
  V1 = L(
    "M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z",
    { width: 512, height: 512 }
  ),
  hU = L(
    "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
    { width: 448, height: 512 }
  ),
  gU = L(
    "M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
    { width: 448, height: 512 }
  ),
  X1 = L(
    "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"
  ),
  fU = L(
    "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
  ),
  Cm = L(
    h("path", {
      d: "M7.5 10.833 4.167 7.5 7.5 4.167M4.167 7.5h9.166a3.333 3.333 0 0 1 0 6.667H12.5",
      strokeWidth: "1.25",
    }),
    te
  ),
  Sm = L(
    h("path", {
      d: "M12.5 10.833 15.833 7.5 12.5 4.167M15.833 7.5H6.667a3.333 3.333 0 1 0 0 6.667H7.5",
      strokeWidth: "1.25",
    }),
    te
  ),
  K1 = L(
    "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z",
    { mirror: !0 }
  ),
  Z1 = L(
    h("path", {
      d: "M5 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 7.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 17.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM7.25 8.917l5.5-2.834M7.25 11.083l5.5 2.834",
      strokeWidth: "1.5",
    }),
    te
  ),
  bU = L(
    "M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"
  ),
  xU = L(
    "M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.11 0-2-.9-2-2V10c0-1.11.89-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .89 2 2z",
    { width: 24, height: 24 }
  ),
  EU = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1",
        }),
        h("path", { d: "M12 14v-11" }),
        h("path", { d: "M9 6l3 -3l3 3" }),
      ],
    }),
    z
  ),
  yU = L(
    D(be, {
      children: [
        h("path", {
          fill: "currentColor",
          d: "M40 5.6v6.1l-4.1.7c-8.9 1.4-16.5 6.9-20.6 15C13 32 10.9 43 12.4 43c.4 0 2.4-1.3 4.4-3 5-3.9 12.1-7 18.2-7.7l5-.6v12.8l11.2-11.3L62.5 22 51.2 10.8 40-.5v6.1zm10.2 22.6L44 34.5v-6.8l-6.9.6c-3.9.3-9.8 1.7-13.2 3.1-3.5 1.4-6.5 2.4-6.7 2.2-.9-1 3-7.5 6.4-10.8C28 18.6 34.4 16 40.1 16c3.7 0 3.9-.1 3.9-3.2V9.5l6.2 6.3 6.3 6.2-6.3 6.2z",
        }),
        h("path", {
          stroke: "currentColor",
          fill: "currentColor",
          d: "M0 36v20h48v-6.2c0-6 0-6.1-2-4.3-1.1 1-2 2.9-2 4.2V52H4V34c0-17.3-.1-18-2-18s-2 .7-2 20z",
        }),
      ],
    }),
    { width: 64, height: 64 }
  ),
  wU = L(
    h("path", {
      stroke: "currentColor",
      strokeWidth: "40",
      fill: "currentColor",
      d: "M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z",
    }),
    { width: 1024 }
  ),
  $1 = D("g", {
    strokeWidth: 1.5,
    children: [
      h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
      h("path", { d: "M12 10l0 10" }),
      h("path", { d: "M12 10l4 4" }),
      h("path", { d: "M12 10l-4 4" }),
      h("path", { d: "M4 4l16 0" }),
    ],
  }),
  j1 = D("g", {
    strokeWidth: 1.5,
    children: [
      h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
      h("path", { d: "M12 5l0 14" }),
      h("path", { d: "M16 9l-4 -4" }),
      h("path", { d: "M8 9l4 -4" }),
    ],
  }),
  km = L(j1, z),
  Mm = L(j1, { ...z, style: { transform: "rotate(180deg)" } }),
  Lm = L($1, z),
  Pm = L($1, { ...z, style: { transform: "rotate(180deg)" } }),
  Am = L(
    D(be, {
      children: [
        D("g", {
          clipPath: "url(#a)",
          stroke: "currentColor",
          strokeWidth: "1.25",
          children: [
            h("path", {
              d: "M3.333 3.333h13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round",
            }),
            h("path", {
              d: "M13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v7.083c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V8.125c0-.92-.746-1.667-1.666-1.667ZM6.875 6.458h-.417c-.92 0-1.666.747-1.666 1.667v3.75c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667v-3.75c0-.92-.747-1.667-1.667-1.667Z",
            }),
          ],
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  Dm = L(
    D(be, {
      children: [
        D("g", {
          clipPath: "url(#a)",
          stroke: "currentColor",
          strokeWidth: "1.25",
          children: [
            h("path", {
              d: "M3.333 16.667h13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round",
            }),
            h("path", {
              d: "M6.875 3.125h-.417c-.92 0-1.666.746-1.666 1.667v7.083c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667V4.792c0-.92-.747-1.667-1.667-1.667ZM13.542 5.817h-.417c-.92 0-1.667.747-1.667 1.667v4.391c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V7.484c0-.92-.746-1.667-1.666-1.667Z",
            }),
          ],
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  _m = L(
    D(be, {
      children: [
        D("g", {
          clipPath: "url(#a)",
          stroke: "currentColor",
          strokeWidth: "1.25",
          children: [
            h("path", {
              d: "M3.333 3.333v13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round",
            }),
            h("path", {
              d: "M15.208 4.792H8.125c-.92 0-1.667.746-1.667 1.666v.417c0 .92.747 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM12.516 11.458H8.125c-.92 0-1.667.746-1.667 1.667v.417c0 .92.747 1.666 1.667 1.666h4.391c.92 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.667-1.667Z",
            }),
          ],
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  Rm = L(
    D(be, {
      children: [
        D("g", {
          clipPath: "url(#a)",
          stroke: "currentColor",
          strokeWidth: "1.25",
          children: [
            h("path", {
              d: "M16.667 3.333v13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round",
            }),
            h("path", {
              d: "M11.875 4.792H4.792c-.92 0-1.667.746-1.667 1.666v.417c0 .92.746 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM11.683 11.458H7.292c-.92 0-1.667.746-1.667 1.667v.417c0 .92.746 1.666 1.667 1.666h4.39c.921 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.666-1.667Z",
            }),
          ],
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  q1 = L(
    D(be, {
      children: [
        D("g", {
          clipPath: "url(#a)",
          stroke: "currentColor",
          strokeWidth: "1.25",
          children: [
            h("path", {
              d: "M16.667 3.333v13.334M3.333 3.333v13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round",
            }),
            h("path", {
              d: "M14.375 10.208v-.416c0-.92-.746-1.667-1.667-1.667H7.292c-.92 0-1.667.746-1.667 1.667v.416c0 .92.746 1.667 1.667 1.667h5.416c.92 0 1.667-.746 1.667-1.667Z",
            }),
          ],
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  J1 = L(
    D(be, {
      children: [
        D("g", {
          clipPath: "url(#a)",
          stroke: "currentColor",
          strokeWidth: "1.25",
          children: [
            h("path", {
              d: "M3.333 3.333h13.334M3.333 16.667h13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round",
            }),
            h("path", {
              d: "M10.208 5.625h-.416c-.92 0-1.667.746-1.667 1.667v5.416c0 .92.746 1.667 1.667 1.667h.416c.92 0 1.667-.746 1.667-1.667V7.292c0-.92-.746-1.667-1.667-1.667Z",
            }),
          ],
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  Nm = L(
    D("g", {
      stroke: "currentColor",
      strokeWidth: "1.25",
      children: [
        h("path", { d: "M1.667 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
        h("path", { d: "M8.333 10h3.334", strokeLinejoin: "round" }),
        h("path", { d: "M15.417 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
        h("path", {
          d: "M6.875 4.792h-.417c-.92 0-1.666.746-1.666 1.666v7.084c0 .92.746 1.666 1.666 1.666h.417c.92 0 1.667-.746 1.667-1.666V6.458c0-.92-.747-1.666-1.667-1.666ZM13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v3.75c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667v-3.75c0-.92-.746-1.667-1.666-1.667Z",
        }),
      ],
    }),
    te
  ),
  Bm = L(
    D("g", {
      stroke: "currentColor",
      strokeWidth: "1.25",
      children: [
        h("path", { d: "M10 18.333v-2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
        h("path", { d: "M10 11.667V8.333", strokeLinejoin: "round" }),
        h("path", { d: "M10 4.583V1.667", strokeLinecap: "round", strokeLinejoin: "round" }),
        h("path", {
          d: "M4.792 13.125v.417c0 .92.746 1.666 1.666 1.666h7.084c.92 0 1.666-.746 1.666-1.666v-.417c0-.92-.746-1.667-1.666-1.667H6.458c-.92 0-1.666.746-1.666 1.667ZM6.458 6.458v.417c0 .92.747 1.667 1.667 1.667h3.75c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666h-3.75c-.92 0-1.667.746-1.667 1.666Z",
        }),
      ],
    }),
    te
  ),
  ql = L(
    D("g", {
      strokeWidth: "1.5",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("circle", { cx: "9", cy: "7", r: "4" }),
        h("path", { d: "M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" }),
        h("path", { d: "M16 3.13a4 4 0 0 1 0 7.75" }),
        h("path", { d: "M21 21v-2a4 4 0 0 0 -3 -3.85" }),
      ],
    }),
    z
  ),
  vU = L(
    "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z"
  ),
  TU = L(
    "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z"
  ),
  Bt = L(
    D(be, {
      children: [
        h("g", {
          clipPath: "url(#a)",
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: h("path", { d: "M15 5 5 15M5 5l10 10" }),
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  IU = L(
    "M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z",
    { mirror: !0 }
  ),
  CU = L(
    "M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z",
    { width: 24 }
  ),
  SU = L(
    "M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm32-48h224V288l-23.5-23.5c-4.7-4.7-12.3-4.7-17 0L176 352l-39.5-39.5c-4.7-4.7-12.3-4.7-17 0L80 352v64zm48-240c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48z",
    { width: 384, height: 512 }
  ),
  Fm = et.memo(({ theme: e }) =>
    L(
      D(be, {
        children: [
          h("path", { d: "M25 26H111V111H25", fill: Jt(e) }),
          h("path", {
            d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z",
            stroke: Jt(e),
            strokeWidth: "2",
          }),
          h("path", { d: "M100 100H160V160H100", fill: Jt(e) }),
          h("path", {
            d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z",
            stroke: Jt(e),
            strokeWidth: "2",
          }),
          D("g", {
            fill: T1(e),
            stroke: Jt(e),
            strokeWidth: "6",
            children: [
              h("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }),
              h("rect", { x: "2.5", y: "149.5", width: "30", height: "30" }),
              h("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }),
              h("rect", { x: "147.5", y: "2.5", width: "30", height: "30" }),
            ],
          }),
        ],
      }),
      { width: 182, height: 182, mirror: !0 }
    )
  ),
  Om = et.memo(({ theme: e }) =>
    L(
      D(be, {
        children: [
          h("path", { d: "M25 26H111V111H25", fill: Jt(e) }),
          h("path", {
            d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z",
            stroke: Jt(e),
            strokeWidth: "2",
          }),
          h("path", { d: "M100 100H160V160H100", fill: Jt(e) }),
          h("path", {
            d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z",
            stroke: Jt(e),
            strokeWidth: "2",
          }),
          D("g", {
            fill: T1(e),
            stroke: Jt(e),
            strokeWidth: "6",
            children: [
              h("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }),
              h("rect", { x: "78.5", y: "149.5", width: "30", height: "30" }),
              h("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }),
              h("rect", { x: "147.5", y: "78.5", width: "30", height: "30" }),
              h("rect", { x: "105.5", y: "2.5", width: "30", height: "30" }),
              h("rect", { x: "2.5", y: "102.5", width: "30", height: "30" }),
            ],
          }),
        ],
      }),
      { width: 182, height: 182, mirror: !0 }
    )
  ),
  Q1 = L(
    h("g", {
      strokeWidth: 1.25,
      children: h("path", {
        d: "M5.879 2.625h8.242a3.27 3.27 0 0 1 3.254 3.254v8.242a3.27 3.27 0 0 1-3.254 3.254H5.88a3.27 3.27 0 0 1-3.254-3.254V5.88A3.27 3.27 0 0 1 5.88 2.626l-.001-.001ZM4.518 16.118l7.608-12.83m.198 13.934 5.051-9.897M2.778 9.675l9.348-6.387m-7.608 12.83 12.857-8.793",
      }),
    }),
    te
  ),
  e0 = L(
    D(be, {
      children: [
        h("path", {
          d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
          stroke: "currentColor",
          strokeWidth: "1.25",
        }),
        h("mask", {
          id: "FillHachureIcon",
          style: { maskType: "alpha" },
          maskUnits: "userSpaceOnUse",
          x: 2,
          y: 2,
          width: 16,
          height: 16,
          children: h("path", {
            d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
            fill: "currentColor",
            stroke: "currentColor",
            strokeWidth: "1.25",
          }),
        }),
        h("g", {
          mask: "url(#FillHachureIcon)",
          children: h("path", {
            d: "M2.258 15.156 15.156 2.258M7.324 20.222 20.222 7.325m-20.444 5.35L12.675-.222m-8.157 18.34L17.416 5.22",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
        }),
      ],
    }),
    te
  ),
  t0 = L(
    D(be, {
      children: [
        D("g", {
          clipPath: "url(#a)",
          children: [
            h("path", {
              d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
              stroke: "currentColor",
              strokeWidth: "1.25",
            }),
            h("mask", {
              id: "FillCrossHatchIcon",
              style: { maskType: "alpha" },
              maskUnits: "userSpaceOnUse",
              x: -1,
              y: -1,
              width: 22,
              height: 22,
              children: h("path", {
                d: "M2.426 15.044 15.044 2.426M7.383 20 20 7.383M0 12.617 12.617 0m-7.98 17.941L17.256 5.324m-2.211 12.25L2.426 4.956M20 12.617 7.383 0m5.234 20L0 7.383m17.941 7.98L5.324 2.745",
                stroke: "currentColor",
                strokeWidth: "1.25",
                strokeLinecap: "round",
                strokeLinejoin: "round",
              }),
            }),
            h("g", {
              mask: "url(#FillCrossHatchIcon)",
              children: h("path", {
                d: "M14.121 2H5.88A3.879 3.879 0 0 0 2 5.879v8.242A3.879 3.879 0 0 0 5.879 18h8.242A3.879 3.879 0 0 0 18 14.121V5.88A3.879 3.879 0 0 0 14.121 2Z",
                fill: "currentColor",
              }),
            }),
          ],
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  o0 = L(
    D(be, {
      children: [
        h("g", {
          clipPath: "url(#a)",
          children: h("path", {
            d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z",
            stroke: "currentColor",
            strokeWidth: "1.25",
          }),
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    { ...te, fill: "currentColor" }
  ),
  zm = L(
    h(be, {
      children: h("path", {
        d: "M4.167 10h11.666",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round",
      }),
    }),
    te
  ),
  r0 = L(
    h("path", {
      d: "M5 10h10",
      stroke: "currentColor",
      strokeWidth: "2.5",
      strokeLinecap: "round",
      strokeLinejoin: "round",
    }),
    te
  ),
  n0 = L(
    h("path", {
      d: "M5 10h10",
      stroke: "currentColor",
      strokeWidth: "3.75",
      strokeLinecap: "round",
      strokeLinejoin: "round",
    }),
    te
  ),
  kU = et.memo(({ theme: e }) =>
    L(
      h("path", {
        d: "M6 10H34",
        stroke: Jt(e),
        strokeWidth: 2,
        fill: "none",
        strokeLinecap: "round",
      }),
      { width: 40, height: 20 }
    )
  ),
  i0 = L(
    D("g", {
      strokeWidth: "2",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M5 12h2" }),
        h("path", { d: "M17 12h2" }),
        h("path", { d: "M11 12h2" }),
      ],
    }),
    z
  ),
  a0 = L(
    D("g", {
      strokeWidth: "2",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M4 12v.01" }),
        h("path", { d: "M8 12v.01" }),
        h("path", { d: "M12 12v.01" }),
        h("path", { d: "M16 12v.01" }),
        h("path", { d: "M20 12v.01" }),
      ],
    }),
    z
  ),
  l0 = L(
    h("path", {
      d: "M2.5 12.038c1.655-.885 5.9-3.292 8.568-4.354 2.668-1.063.101 2.821 1.32 3.104 1.218.283 5.112-1.814 5.112-1.814",
      strokeWidth: "1.25",
    }),
    te
  ),
  s0 = L(
    h("path", {
      d: "M2.5 12.563c1.655-.886 5.9-3.293 8.568-4.355 2.668-1.062.101 2.822 1.32 3.105 1.218.283 5.112-1.814 5.112-1.814m-13.469 2.23c2.963-1.586 6.13-5.62 7.468-4.998 1.338.623-1.153 4.11-.132 5.595 1.02 1.487 6.133-1.43 6.133-1.43",
      strokeWidth: "1.25",
    }),
    te
  ),
  c0 = L(
    h("path", {
      d: "M2.5 11.936c1.737-.879 8.627-5.346 10.42-5.268 1.795.078-.418 5.138.345 5.736.763.598 3.53-1.789 4.235-2.147M2.929 9.788c1.164-.519 5.47-3.28 6.987-3.114 1.519.165 1 3.827 2.121 4.109 1.122.281 3.839-2.016 4.606-2.42",
      strokeWidth: "1.25",
    }),
    te
  ),
  d0 = L(
    D("svg", {
      strokeWidth: "1.5",
      children: [
        h("path", {
          d: "M3.33334 9.99998V6.66665C3.33334 6.04326 3.33403 4.9332 3.33539 3.33646C4.95233 3.33436 6.06276 3.33331 6.66668 3.33331H10",
        }),
        h("path", { d: "M13.3333 3.33331V3.34331" }),
        h("path", { d: "M16.6667 3.33331V3.34331" }),
        h("path", { d: "M16.6667 6.66669V6.67669" }),
        h("path", { d: "M16.6667 10V10.01" }),
        h("path", { d: "M3.33334 13.3333V13.3433" }),
        h("path", { d: "M16.6667 13.3333V13.3433" }),
        h("path", { d: "M3.33334 16.6667V16.6767" }),
        h("path", { d: "M6.66666 16.6667V16.6767" }),
        h("path", { d: "M10 16.6667V16.6767" }),
        h("path", { d: "M13.3333 16.6667V16.6767" }),
        h("path", { d: "M16.6667 16.6667V16.6767" }),
      ],
    }),
    te
  ),
  m0 = L(
    D("g", {
      strokeWidth: "1.5",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M4 12v-4a4 4 0 0 1 4 -4h4" }),
        h("line", { x1: "16", y1: "4", x2: "16", y2: "4.01" }),
        h("line", { x1: "20", y1: "4", x2: "20", y2: "4.01" }),
        h("line", { x1: "20", y1: "8", x2: "20", y2: "8.01" }),
        h("line", { x1: "20", y1: "12", x2: "20", y2: "12.01" }),
        h("line", { x1: "4", y1: "16", x2: "4", y2: "16.01" }),
        h("line", { x1: "20", y1: "16", x2: "20", y2: "16.01" }),
        h("line", { x1: "4", y1: "20", x2: "4", y2: "20.01" }),
        h("line", { x1: "8", y1: "20", x2: "8", y2: "20.01" }),
        h("line", { x1: "12", y1: "20", x2: "12", y2: "20.01" }),
        h("line", { x1: "16", y1: "20", x2: "16", y2: "20.01" }),
        h("line", { x1: "20", y1: "20", x2: "20", y2: "20.01" }),
      ],
    }),
    z
  ),
  p0 = L(
    D("g", {
      stroke: "currentColor",
      opacity: 0.3,
      strokeWidth: 2,
      children: [
        h("path", { d: "M12 12l9 0" }),
        h("path", { d: "M3 9l6 6" }),
        h("path", { d: "M3 15l6 -6" }),
      ],
    }),
    z
  ),
  u0 = et.memo(({ flip: e = !1 }) =>
    L(
      D("g", {
        transform: e ? "translate(40, 0) scale(-1, 1)" : "",
        stroke: "currentColor",
        strokeWidth: 2,
        fill: "none",
        children: [
          h("path", { d: "M34 10H6M34 10L27 5M34 10L27 15" }),
          h("path", { d: "M27.5 5L34.5 10L27.5 15" }),
        ],
      }),
      { width: 40, height: 20 }
    )
  ),
  h0 = et.memo(({ flip: e = !1 }) =>
    L(
      D("g", {
        stroke: "currentColor",
        fill: "currentColor",
        transform: e ? "translate(40, 0) scale(-1, 1)" : "",
        children: [
          h("path", { d: "M32 10L6 10", strokeWidth: 2 }),
          h("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" }),
        ],
      }),
      { width: 40, height: 20 }
    )
  ),
  g0 = et.memo(({ flip: e = !1 }) =>
    L(
      D("g", {
        stroke: "currentColor",
        fill: "none",
        transform: e ? "translate(40, 0) scale(-1, 1)" : "",
        strokeWidth: 2,
        children: [
          h("path", { d: "M26 10L6 10" }),
          h("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" }),
        ],
      }),
      { width: 40, height: 20 }
    )
  ),
  f0 = et.memo(({ flip: e = !1 }) =>
    L(
      h("g", {
        transform: e ? "translate(40, 0) scale(-1, 1)" : "",
        children: h("path", {
          d: "M34 10H5.99996M34 10L34 5M34 10L34 15",
          stroke: "currentColor",
          strokeWidth: 2,
          fill: "none",
        }),
      }),
      { width: 40, height: 20 }
    )
  ),
  b0 = et.memo(({ flip: e = !1 }) =>
    L(
      D("g", {
        stroke: "currentColor",
        fill: "currentColor",
        transform: e ? "translate(40, 0) scale(-1, 1)" : "",
        children: [
          h("path", { d: "M32 10L6 10", strokeWidth: 2 }),
          h("path", { d: "M27.5 5.5L34.5 10L27.5 14.5L27.5 5.5" }),
        ],
      }),
      { width: 40, height: 20 }
    )
  ),
  x0 = et.memo(({ flip: e = !1 }) =>
    L(
      D("g", {
        stroke: "currentColor",
        fill: "none",
        transform: e ? "translate(40, 0) scale(-1, 1)" : "",
        strokeWidth: 2,
        strokeLinejoin: "round",
        children: [
          h("path", { d: "M6,9.5H27" }),
          h("path", { d: "M27,5L34,10L27,14Z", fill: "none" }),
        ],
      }),
      { width: 40, height: 20 }
    )
  ),
  E0 = et.memo(({ flip: e = !1 }) =>
    L(
      D("g", {
        stroke: "currentColor",
        fill: "currentColor",
        transform: e ? "translate(40, 0) scale(-1, 1)" : "",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: [h("path", { d: "M6,9.5H20" }), h("path", { d: "M27,5L34,10L27,14L20,9.5Z" })],
      }),
      { width: 40, height: 20 }
    )
  ),
  y0 = et.memo(({ flip: e = !1 }) =>
    L(
      D("g", {
        stroke: "currentColor",
        fill: "none",
        transform: e ? "translate(40, 0) scale(-1, 1)" : "",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: [h("path", { d: "M6,9.5H20" }), h("path", { d: "M27,5L34,10L27,14L20,9.5Z" })],
      }),
      { width: 40, height: 20 }
    )
  ),
  w0 = et.memo(({ flip: e = !1 }) =>
    L(
      h("g", {
        stroke: "currentColor",
        fill: "none",
        transform: e ? "" : "translate(40, 0) scale(-1, 1)",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: h("path", { d: "M34,10 H6 M15,10 L7,5 M15,10 L7,15" }),
      }),
      { width: 40, height: 20 }
    )
  ),
  v0 = et.memo(({ flip: e = !1 }) =>
    L(
      h("g", {
        stroke: "currentColor",
        fill: "none",
        transform: e ? "" : "translate(40, 0) scale(-1, 1)",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: h("path", { d: "M34,10 H6 M15,10 L15,15 L15,5" }),
      }),
      { width: 40, height: 20 }
    )
  ),
  T0 = et.memo(({ flip: e = !1 }) =>
    L(
      h("g", {
        stroke: "currentColor",
        fill: "none",
        transform: e ? "" : "translate(40, 0) scale(-1, 1)",
        strokeLinejoin: "round",
        strokeWidth: 2,
        children: h("path", { d: "M34,10 H6 M15,10 L15,16 L15,4 M15,10 L7,5 M15,10 L7,15" }),
      }),
      { width: 40, height: 20 }
    )
  ),
  I0 = L(
    D(be, {
      children: [
        h("g", {
          clipPath: "url(#a)",
          children: h("path", {
            d: "M14.167 6.667a3.333 3.333 0 0 0-3.334-3.334H9.167a3.333 3.333 0 0 0 0 6.667h1.666a3.333 3.333 0 0 1 0 6.667H9.167a3.333 3.333 0 0 1-3.334-3.334",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  C0 = L(
    D(be, {
      children: [
        h("g", {
          clipPath: "url(#a)",
          children: h("path", {
            d: "M5 16.667V3.333L10 15l5-11.667v13.334",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  S0 = L(
    D(be, {
      children: [
        h("g", {
          clipPath: "url(#a)",
          children: h("path", {
            d: "M5.833 3.333v13.334h8.334",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          }),
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  k0 = L(
    h(be, {
      children: h("path", {
        d: "m1.667 3.333 6.666 13.334M8.333 3.333 1.667 16.667M11.667 3.333v13.334h6.666",
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round",
      }),
    }),
    te
  ),
  Ur = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M3 7v-2h13v2" }),
        h("path", { d: "M10 5v14" }),
        h("path", { d: "M12 19h-4" }),
        h("path", { d: "M15 13v-1h6v1" }),
        h("path", { d: "M18 12v7" }),
        h("path", { d: "M17 19h2" }),
      ],
    }),
    z
  ),
  M0 = L(
    h(be, {
      children: D("g", {
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          h("path", { d: "M7 12h10" }),
          h("path", { d: "M7 5v14" }),
          h("path", { d: "M17 5v14" }),
          h("path", { d: "M15 19h4" }),
          h("path", { d: "M15 5h4" }),
          h("path", { d: "M5 19h4" }),
          h("path", { d: "M5 5h4" }),
        ],
      }),
    }),
    z
  ),
  ea = L(
    h(be, {
      children: h("g", {
        stroke: "currentColor",
        strokeWidth: "1.25",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: h("path", {
          d: "M5.833 16.667v-10a3.333 3.333 0 0 1 3.334-3.334h1.666a3.333 3.333 0 0 1 3.334 3.334v10M5.833 10.833h8.334",
        }),
      }),
    }),
    te
  ),
  Jl = L(
    D(be, {
      children: [
        h("g", {
          clipPath: "url(#a)",
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: h("path", {
            d: "M5.833 6.667 2.5 10l3.333 3.333M14.167 6.667 17.5 10l-3.333 3.333M11.667 3.333 8.333 16.667",
          }),
        }),
        h("defs", {
          children: h("clipPath", {
            id: "a",
            children: h("path", { fill: "#fff", d: "M0 0h20v20H0z" }),
          }),
        }),
      ],
    }),
    te
  ),
  L0 = L(
    D("g", {
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: 2,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
        h("line", { x1: "4", y1: "12", x2: "12", y2: "12" }),
        h("line", { x1: "4", y1: "16", x2: "16", y2: "16" }),
      ],
    }),
    z
  ),
  P0 = L(
    D("g", {
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
        h("line", { x1: "8", y1: "12", x2: "16", y2: "12" }),
        h("line", { x1: "6", y1: "16", x2: "18", y2: "16" }),
      ],
    }),
    z
  ),
  A0 = L(
    D("g", {
      stroke: "currentColor",
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
        h("line", { x1: "10", y1: "12", x2: "20", y2: "12" }),
        h("line", { x1: "8", y1: "16", x2: "20", y2: "16" }),
      ],
    }),
    z
  ),
  D0 = et.memo(({ theme: e }) =>
    L(
      D("g", {
        strokeWidth: "1.5",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          h("line", { x1: "4", y1: "4", x2: "20", y2: "4" }),
          h("rect", { x: "9", y: "8", width: "6", height: "12", rx: "2" }),
        ],
      }),
      z
    )
  ),
  _0 = et.memo(({ theme: e }) =>
    L(
      D("g", {
        strokeWidth: "2",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          h("line", { x1: "4", y1: "20", x2: "20", y2: "20" }),
          h("rect", { x: "9", y: "4", width: "6", height: "12", rx: "2" }),
        ],
      }),
      z
    )
  ),
  R0 = et.memo(({ theme: e }) =>
    L(
      D("g", {
        strokeWidth: "1.5",
        stroke: "currentColor",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [
          h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
          h("line", { x1: "4", y1: "12", x2: "9", y2: "12" }),
          h("line", { x1: "15", y1: "12", x2: "20", y2: "12" }),
          h("rect", { x: "9", y: "6", width: "6", height: "12", rx: "2" }),
        ],
      }),
      z
    )
  ),
  Ql = L(
    D("g", {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M21 19h-18l9 -15" }),
        h("path", { d: "M20.615 15.171h.015" }),
        h("path", { d: "M19.515 11.771h.015" }),
        h("path", { d: "M17.715 8.671h.015" }),
        h("path", { d: "M15.415 5.971h.015" }),
      ],
    }),
    z
  ),
  N0 = L(
    h("path", {
      d: "M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zM393.4 288H328v112c0 8.8-7.2 16-16 16h-48c-8.8 0-16-7.2-16-16V288h-65.4c-14.3 0-21.4-17.2-11.3-27.3l105.4-105.4c6.2-6.2 16.4-6.2 22.6 0l105.4 105.4c10.1 10.1 2.9 27.3-11.3 27.3z",
      fill: "currentColor",
    }),
    { width: 640, height: 512 }
  ),
  MU = L(
    h("path", {
      d: "M480 416C497.7 416 512 430.3 512 448C512 465.7 497.7 480 480 480H150.6C133.7 480 117.4 473.3 105.4 461.3L25.37 381.3C.3786 356.3 .3786 315.7 25.37 290.7L258.7 57.37C283.7 32.38 324.3 32.38 349.3 57.37L486.6 194.7C511.6 219.7 511.6 260.3 486.6 285.3L355.9 416H480zM265.4 416L332.7 348.7L195.3 211.3L70.63 336L150.6 416L265.4 416z",
    })
  ),
  es = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M8 13v-7.5a1.5 1.5 0 0 1 3 0v6.5" }),
        h("path", { d: "M11 5.5v-2a1.5 1.5 0 1 1 3 0v8.5" }),
        h("path", { d: "M14 5.5a1.5 1.5 0 0 1 3 0v6.5" }),
        h("path", {
          d: "M17 7.5a1.5 1.5 0 0 1 3 0v8.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47",
        }),
      ],
    }),
    z
  ),
  Hm = L(
    D(be, {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" }),
        h("path", { d: "M7 11l5 5l5 -5" }),
        h("path", { d: "M12 4l0 12" }),
      ],
    }),
    z
  ),
  Ln = L(
    D(be, {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z",
        }),
        h("path", { d: "M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" }),
      ],
    }),
    z
  ),
  B0 = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M7 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
        h("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
        h("path", { d: "M9.15 14.85l8.85 -10.85" }),
        h("path", { d: "M6 4l8.85 10.85" }),
      ],
    }),
    z
  ),
  F0 = L(
    D(be, {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }),
        h("path", { d: "M12 17l0 .01" }),
        h("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" }),
      ],
    }),
    z
  ),
  LU = L(
    D(be, {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M7 4v16l13 -8z" }),
      ],
    }),
    z
  ),
  PU = L(
    D(be, {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z",
          strokeWidth: "0",
          fill: "currentColor",
        }),
      ],
    }),
    z
  ),
  O0 = L(
    D(be, {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M5 12l5 5l10 -10" }),
      ],
    }),
    z
  ),
  z0 = L(
    D(be, {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M10.24 3.957l-8.422 14.06a1.989 1.989 0 0 0 1.7 2.983h16.845a1.989 1.989 0 0 0 1.7 -2.983l-8.423 -14.06a1.989 1.989 0 0 0 -3.4 0z",
        }),
        h("path", { d: "M12 9v4" }),
        h("path", { d: "M12 17h.01" }),
      ],
    }),
    z
  ),
  H0 = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M11 7l6 6" }),
        h("path", {
          d: "M4 16l11.7 -11.7a1 1 0 0 1 1.4 0l2.6 2.6a1 1 0 0 1 0 1.4l-11.7 11.7h-4v-4z",
        }),
      ],
    }),
    z
  ),
  G0 = L(
    D("g", {
      strokeWidth: 1.5,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M12 3l-4 7h8z" }),
        h("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
        h("path", {
          d: "M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z",
        }),
      ],
    }),
    z
  ),
  Yr = L(
    D("g", {
      strokeWidth: 1.5,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M4 7l16 0" }),
        h("path", { d: "M4 17l16 0" }),
        h("path", { d: "M7 4l0 16" }),
        h("path", { d: "M17 4l0 16" }),
      ],
    }),
    z
  ),
  ts = L(
    h("path", {
      fill: "currentColor",
      d: "M407.48,111.18C335.587,108.103 269.573,152.338 245.08,220C220.587,152.338 154.573,108.103 82.68,111.18C80.285,168.229 107.577,222.632 154.74,254.82C178.908,271.419 193.35,298.951 193.27,328.27L193.27,379.13L296.9,379.13L296.9,328.27C296.816,298.953 311.255,271.42 335.42,254.82C382.596,222.644 409.892,168.233 407.48,111.18Z",
    })
  ),
  Pn = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", { d: "M4.16602 10H15.8327" }),
        h("path", { d: "M12.5 13.3333L15.8333 10" }),
        h("path", { d: "M12.5 6.66666L15.8333 9.99999" }),
      ],
    }),
    te
  ),
  ta = L(
    D("g", {
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.25",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      transform: "rotate(90 10 10)",
      children: [
        h("path", {
          clipRule: "evenodd",
          d: "m9.644 13.69 7.774-7.773a2.357 2.357 0 0 0-3.334-3.334l-7.773 7.774L8 12l1.643 1.69Z",
        }),
        h("path", {
          d: "m13.25 3.417 3.333 3.333M10 10l2-2M5 15l3-3M2.156 17.894l1-1M5.453 19.029l-.144-1.407M2.377 11.887l.866 1.118M8.354 17.273l-1.194-.758M.953 14.652l1.408.13",
        }),
      ],
    }),
    20
  ),
  os = L(
    D("g", {
      stroke: "currentColor",
      fill: "none",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z" }),
        h("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }),
        h("path", { d: "M15 6l3 3" }),
        h("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
        h("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
      ],
    }),
    z
  ),
  AU = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z" }),
        h("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }),
        h("path", { d: "M15 6l3 3" }),
        h("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
        h("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
      ],
    }),
    z
  ),
  DU = L(
    D("g", {
      stroke: "currentColor",
      fill: "none",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M11.217 19.384a3.501 3.501 0 0 0 6.783 -1.217v-5.167l-6 -3.35" }),
        h("path", { d: "M5.214 15.014a3.501 3.501 0 0 0 4.446 5.266l4.34 -2.534v-6.946" }),
        h("path", {
          d: "M6 7.63c-1.391 -.236 -2.787 .395 -3.534 1.689a3.474 3.474 0 0 0 1.271 4.745l4.263 2.514l6 -3.348",
        }),
        h("path", { d: "M12.783 4.616a3.501 3.501 0 0 0 -6.783 1.217v5.067l6 3.45" }),
        h("path", { d: "M18.786 8.986a3.501 3.501 0 0 0 -4.446 -5.266l-4.34 2.534v6.946" }),
        h("path", {
          d: "M18 16.302c1.391 .236 2.787 -.395 3.534 -1.689a3.474 3.474 0 0 0 -1.271 -4.745l-4.308 -2.514l-5.955 3.42",
        }),
      ],
    }),
    z
  ),
  U0 = L(
    D("g", {
      stroke: "currentColor",
      fill: "none",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2" }),
        h("path", { d: "M4 16v2a2 2 0 0 0 2 2h2" }),
        h("path", { d: "M16 4h2a2 2 0 0 1 2 2v2" }),
        h("path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2" }),
      ],
    }),
    z
  ),
  An = L(
    D("g", {
      stroke: "currentColor",
      fill: "none",
      strokeWidth: 1.5,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" }),
        h("path", {
          d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6",
        }),
      ],
    }),
    z
  ),
  Y0 = L(
    D("g", {
      stroke: "currentColor",
      fill: "none",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M10.585 10.587a2 2 0 0 0 2.829 2.828" }),
        h("path", {
          d: "M16.681 16.673a8.717 8.717 0 0 1 -4.681 1.327c-3.6 0 -6.6 -2 -9 -6c1.272 -2.12 2.712 -3.678 4.32 -4.674m2.86 -1.146a9.055 9.055 0 0 1 1.82 -.18c3.6 0 6.6 2 9 6c-.666 1.11 -1.379 2.067 -2.138 2.87",
        }),
        h("path", { d: "M3 3l18 18" }),
      ],
    }),
    z
  ),
  W0 = L(
    D("g", {
      stroke: "currentColor",
      fill: "none",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }),
        h("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }),
        h("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }),
        h("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }),
        h("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }),
        h("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" }),
      ],
    }),
    z
  ),
  V0 = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }),
        h("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }),
        h("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }),
        h("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }),
        h("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }),
        h("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" }),
      ],
    }),
    z
  ),
  Mt = L(
    D("g", {
      strokeWidth: 1.5,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" }),
        h("path", { d: "M21 21l-6 -6" }),
      ],
    }),
    z
  ),
  X0 = L(
    D("g", {
      strokeWidth: 1.5,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M20.984 12.53a9 9 0 1 0 -7.552 8.355" }),
        h("path", { d: "M12 7v5l3 3" }),
        h("path", { d: "M19 16l-2 3h4l-2 3" }),
      ],
    }),
    z
  ),
  K0 = L(
    D("g", {
      strokeWidth: 1.5,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M9 2m0 3a3 3 0 0 1 3 -3h0a3 3 0 0 1 3 3v5a3 3 0 0 1 -3 3h0a3 3 0 0 1 -3 -3z",
        }),
        h("path", { d: "M5 10a7 7 0 0 0 14 0" }),
        h("path", { d: "M8 21l8 0" }),
        h("path", { d: "M12 17l0 4" }),
      ],
    }),
    z
  ),
  Z0 = L(
    D("g", {
      strokeWidth: 1.5,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M3 3l18 18" }),
        h("path", { d: "M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1" }),
        h("path", { d: "M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85" }),
        h("path", { d: "M8 21l8 0" }),
        h("path", { d: "M12 17l0 4" }),
      ],
    }),
    z
  ),
  oa = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M13 3l0 7l6 0l-8 11l0 -7l-6 0l8 -11" }),
      ],
    }),
    z
  ),
  $0 = L(
    D("g", {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M8 8m0 1a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-6a1 1 0 0 1 -1 -1z",
        }),
        h("path", { d: "M12 20v.01" }),
        h("path", { d: "M16 20v.01" }),
        h("path", { d: "M8 20v.01" }),
        h("path", { d: "M4 20v.01" }),
        h("path", { d: "M4 16v.01" }),
        h("path", { d: "M4 12v.01" }),
        h("path", { d: "M4 8v.01" }),
        h("path", { d: "M4 4v.01" }),
        h("path", { d: "M8 4v.01" }),
        h("path", { d: "M12 4v.01" }),
        h("path", { d: "M16 4v.01" }),
        h("path", { d: "M20 4v.01" }),
        h("path", { d: "M20 8v.01" }),
        h("path", { d: "M20 12v.01" }),
        h("path", { d: "M20 16v.01" }),
        h("path", { d: "M20 20v.01" }),
      ],
    }),
    z
  ),
  j0 = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M5 3v18" }),
        h("path", { d: "M19 21v-18" }),
        h("path", { d: "M5 7h14" }),
        h("path", { d: "M5 15h14" }),
        h("path", { d: "M8 13v4" }),
        h("path", { d: "M11 13v4" }),
        h("path", { d: "M16 13v4" }),
        h("path", { d: "M14 5v4" }),
        h("path", { d: "M11 5v4" }),
        h("path", { d: "M8 5v4" }),
        h("path", { d: "M3 21h18" }),
      ],
    }),
    z
  ),
  q0 = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M3 12l18 0" }),
        h("path", { d: "M7 16l10 0l-10 5l0 -5" }),
        h("path", { d: "M7 8l10 0l-10 -5l0 5" }),
      ],
    }),
    z
  ),
  J0 = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M12 3l0 18" }),
        h("path", { d: "M16 7l0 10l5 0l-5 -10" }),
        h("path", { d: "M8 7l0 10l-5 0l5 -10" }),
      ],
    }),
    z
  ),
  Gm = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M5 3m0 2a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z",
        }),
        h("path", { d: "M19 6h1a2 2 0 0 1 2 2a5 5 0 0 1 -5 5l-5 0v2" }),
        h("path", {
          d: "M10 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z",
        }),
      ],
    }),
    z
  ),
  rs = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M15 15m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0" }),
        h("path", { d: "M22 22l-3 -3" }),
        h("path", { d: "M6 18h-1a2 2 0 0 1 -2 -2v-1" }),
        h("path", { d: "M3 11v-1" }),
        h("path", { d: "M3 6v-1a2 2 0 0 1 2 -2h1" }),
        h("path", { d: "M10 3h1" }),
        h("path", { d: "M15 3h1a2 2 0 0 1 2 2v1" }),
      ],
    }),
    z
  ),
  Q0 = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
        h("path", { d: "M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" }),
        h("path", {
          d: "M4 20.25c0 .414 .336 .75 .75 .75h1.25a1 1 0 0 0 1 -1v-1a1 1 0 0 0 -1 -1h-1a1 1 0 0 1 -1 -1v-1a1 1 0 0 1 1 -1h1.25a.75 .75 0 0 1 .75 .75",
        }),
        h("path", { d: "M10 15l2 6l2 -6" }),
        h("path", { d: "M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3" }),
      ],
    }),
    z
  ),
  eb = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
        h("path", { d: "M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" }),
        h("path", { d: "M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3" }),
        h("path", { d: "M5 18h1.5a1.5 1.5 0 0 0 0 -3h-1.5v6" }),
        h("path", { d: "M11 21v-6l3 6v-6" }),
      ],
    }),
    z
  ),
  tb = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M4 13v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a2 2 0 0 0 6 0v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a8 8 0 0 1 -16 0",
        }),
        h("path", { d: "M4 8l5 0" }),
        h("path", { d: "M15 8l4 0" }),
      ],
    }),
    z
  ),
  ob = L(
    D("g", {
      strokeWidth: 1.25,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M3 14c.83 .642 2.077 1.017 3.5 1c1.423 .017 2.67 -.358 3.5 -1c.83 -.642 2.077 -1.017 3.5 -1c1.423 -.017 2.67 .358 3.5 1",
        }),
        h("path", { d: "M8 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2" }),
        h("path", { d: "M12 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2" }),
        h("path", { d: "M3 10h14v5a6 6 0 0 1 -6 6h-2a6 6 0 0 1 -6 -6v-5z" }),
        h("path", { d: "M16.746 16.726a3 3 0 1 0 .252 -5.555" }),
      ],
    }),
    z
  ),
  rb = L(
    D("g", {
      stroke: "currentColor",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M3 5a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1h-16a1 1 0 0 1-1-1v-10zM7 20h10M9 16v4M15 16v4",
        }),
      ],
    }),
    { ...z, strokeWidth: 1.5 }
  ),
  _U = L(
    D("g", {
      strokeWidth: 1.5,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M15 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2",
        }),
        h("path", { d: "M21 12h-13l3 -3" }),
        h("path", { d: "M11 15l-3 -3" }),
      ],
    }),
    z
  ),
  nb = L(
    D("g", {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M2 8a4 4 0 0 1 4 -4h12a4 4 0 0 1 4 4v8a4 4 0 0 1 -4 4h-12a4 4 0 0 1 -4 -4v-8z",
        }),
        h("path", { d: "M10 9l5 3l-5 3z" }),
      ],
    }),
    z
  ),
  ib = L(
    D("g", {
      strokeWidth: 1.5,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M3 6h18" }),
        h("path", { d: "M3 12h18" }),
        h("path", { d: "M3 18h18" }),
        h("path", { d: "M6 3v18" }),
        h("path", { d: "M12 3v18" }),
        h("path", { d: "M18 3v18" }),
      ],
    }),
    z
  ),
  ab = L(
    D("g", {
      strokeWidth: 1.5,
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", {
          d: "M17 3m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z",
        }),
        h("path", {
          d: "M3 17m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z",
        }),
        h("path", { d: "M17 5c-6.627 0 -12 5.373 -12 12" }),
      ],
    }),
    z
  ),
  ns = L(
    D("g", {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M6 18l12 -12" }),
        h("path", { d: "M18 10v-4h-4" }),
      ],
    }),
    z
  ),
  is = L(
    D("g", {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M4,19L10,19C11.097,19 12,18.097 12,17L12,9C12,7.903 12.903,7 14,7L21,7" }),
        h("path", { d: "M18 4l3 3l-3 3" }),
      ],
    }),
    z
  ),
  as = L(
    D("g", {
      children: [
        h("path", { d: "M16,12L20,9L16,6" }),
        h("path", { d: "M6 20c0 -6.075 4.925 -11 11 -11h3" }),
      ],
    }),
    z
  ),
  ls = L(
    D("g", {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M6 9l6 6l6 -6" }),
      ],
    }),
    z
  ),
  lb = L(
    D("g", {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M6 15l6 -6l6 6" }),
      ],
    }),
    z
  ),
  sb = L(
    D("g", {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M6 15l6 -6l6 6" }),
      ],
    }),
    z
  ),
  Um = L(
    D("g", {
      strokeWidth: "1.25",
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M8 5v10a1 1 0 0 0 1 1h10" }),
        h("path", { d: "M5 8h10a1 1 0 0 1 1 1v10" }),
      ],
    }),
    z
  ),
  ss = L(
    D("g", {
      children: [
        h("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        h("path", { d: "M5 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
        h("path", { d: "M19 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
        h("path", { d: "M5 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
        h("path", { d: "M19 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }),
        h("path", { d: "M5 7l0 10" }),
        h("path", { d: "M7 5l10 0" }),
        h("path", { d: "M7 19l10 0" }),
        h("path", { d: "M19 7l0 10" }),
      ],
    }),
    z
  );
import cb from "clsx";
import Wm, { useEffect as cC, useRef as db, useState as dC } from "react";
import { isPromiseLike as mC } from "@excalidraw/common";
import lC from "react";
import { jsx as Ym } from "react/jsx-runtime";
var sC = ({ size: e = "1em", circleWidth: o = 8, synchronized: t = !1, className: r = "" }) => {
    let i = -(lC.useRef(Date.now()).current % 1600);
    return Ym("div", {
      className: `Spinner ${r}`,
      children: Ym("svg", {
        viewBox: "0 0 100 100",
        style: { width: e, height: e, "--spinner-delay": t ? `${i}ms` : 0 },
        children: Ym("circle", {
          cx: "50",
          cy: "50",
          r: 50 - o / 2,
          strokeWidth: o,
          fill: "none",
          strokeMiterlimit: "10",
        }),
      }),
    });
  },
  tt = sC;
import { jsx as ra, jsxs as na } from "react/jsx-runtime";
var V = Wm.forwardRef(({ size: e = "medium", visible: o = !0, className: t = "", ...r }, n) => {
  let { id: i } = Ge(),
    a = Wm.useRef(null);
  Wm.useImperativeHandle(n, () => a.current);
  let l = `ToolIcon_size_${e}`,
    [s, d] = dC(!1),
    m = db(!0),
    c = async (u) => {
      let f = "onClick" in r && r.onClick?.(u);
      if (mC(f))
        try {
          d(!0), await f;
        } catch (b) {
          if (b instanceof xn) console.warn(b);
          else throw b;
        } finally {
          m.current && d(!1);
        }
    };
  cC(
    () => (
      (m.current = !0),
      () => {
        m.current = !1;
      }
    ),
    []
  );
  let p = db(null);
  if (r.type === "button" || r.type === "icon" || r.type === "submit") {
    let u = r.type === "icon" ? "button" : r.type;
    return na("button", {
      className: cb(
        "ToolIcon_type_button",
        l,
        t,
        o && !r.hidden ? "ToolIcon_type_button--show" : "ToolIcon_type_button--hide",
        {
          ToolIcon: !r.hidden,
          "ToolIcon--selected": r.selected,
          "ToolIcon--plain": r.type === "icon",
        }
      ),
      style: r.style,
      "data-testid": r["data-testid"],
      hidden: r.hidden,
      title: r.title,
      "aria-label": r["aria-label"],
      type: u,
      onClick: c,
      ref: a,
      disabled: s || r.isLoading || !!r.disabled,
      children: [
        (r.icon || r.label) &&
          na("div", {
            className: "ToolIcon__icon",
            "aria-hidden": "true",
            "aria-disabled": !!r.disabled,
            children: [
              r.icon || r.label,
              r.keyBindingLabel &&
                ra("span", { className: "ToolIcon__keybinding", children: r.keyBindingLabel }),
              r.isLoading && ra(tt, {}),
            ],
          }),
        r.showAriaLabel &&
          na("div", {
            className: "ToolIcon__label",
            children: [r["aria-label"], " ", s && ra(tt, {})],
          }),
        r.children,
      ],
    });
  }
  return na("label", {
    className: cb("ToolIcon", t),
    title: r.title,
    onPointerDown: (u) => {
      (p.current = u.pointerType || null),
        r.onPointerDown?.({ pointerType: u.pointerType || null });
    },
    onPointerUp: () => {
      requestAnimationFrame(() => {
        p.current = null;
      });
    },
    children: [
      ra("input", {
        className: `ToolIcon_type_radio ${l}`,
        type: "radio",
        name: r.name,
        "aria-label": r["aria-label"],
        "aria-keyshortcuts": r["aria-keyshortcuts"],
        "data-testid": r["data-testid"],
        id: `${i}-${r.id}`,
        onChange: () => {
          r.onChange?.({ pointerType: p.current });
        },
        checked: r.checked,
        ref: a,
      }),
      na("div", {
        className: "ToolIcon__icon",
        children: [
          r.icon,
          r.keyBindingLabel &&
            ra("span", { className: "ToolIcon__keybinding", children: r.keyBindingLabel }),
        ],
      }),
    ],
  });
});
V.displayName = "ToolButton";
var cs = [],
  B = (e) => ((cs = cs.concat(e)), e);
import { jsx as EC } from "react/jsx-runtime";
var xC = (e, o, t) => {
    let r = new Set(
        Z(
          e.filter((m) => gC(m)),
          o
        ).map((m) => m.id)
      ),
      n = {},
      i = t.scene.getNonDeletedElementsMap(),
      a = new Set();
    for (let m of r) {
      let c = fC(e, m);
      for (let p of c)
        if (!a.has(p.id)) {
          if (ds(p)) {
            let u = pb(p, i);
            u && (n[u.id] = !0);
          } else n[p.id] = !0;
          a.add(p.id);
        }
    }
    let l = !0,
      s = e.map((m) => {
        if (o.selectedElementIds[m.id]) {
          let c = ds(m) ? pb(m, i) : null;
          return m.frameId && r.has(m.frameId)
            ? ((l = !1), (n[m.id] = !0), m)
            : c?.frameId && r.has(c?.frameId)
            ? m
            : (m.boundElements &&
                m.boundElements.forEach((p) => {
                  let u = t.scene.getNonDeletedElementsMap().get(p.id);
                  u &&
                    hC(u) &&
                    t.scene.mutateElement(u, {
                      startBinding: m.id === u.startBinding?.elementId ? null : u.startBinding,
                      endBinding: m.id === u.endBinding?.elementId ? null : u.endBinding,
                    });
                }),
              ps(m, { isDeleted: !0 }));
        }
        return m.frameId && r.has(m.frameId)
          ? ((l = !1), ds(m) || (n[m.id] = !0), ps(m, { frameId: null }))
          : ds(m) && o.selectedElementIds[m.containerId]
          ? ps(m, { isDeleted: !0 })
          : m;
      }),
      d = o.editingGroupId;
    if (l && o.editingGroupId) {
      let m = Km(s, o.editingGroupId).filter((c) => !c.isDeleted);
      if (m.length > 1) m[0] && (n[m[0].id] = !0);
      else {
        (d = null), m[0] && (n[m[0].id] = !0);
        let c = m[0];
        if (c) {
          let p = c.groupIds.findIndex((f) => f === o.editingGroupId),
            u = c.groupIds[p + 1];
          if (u) {
            let f = Km(s, u).filter((b) => !b.isDeleted);
            f.length > 1 &&
              ((d = u),
              f.forEach((b) => {
                n[b.id] = !0;
              }));
          }
        }
      }
    }
    return {
      elements: s,
      appState: { ...o, ...bC({ selectedElementIds: n, editingGroupId: d }, s, o, null) },
    };
  },
  ub = (e, o) => {
    if (e.editingGroupId) {
      let t = Km(Xm(o), e.editingGroupId);
      if (t.length) return { ...e, selectedElementIds: { [t[0].id]: !0 } };
    }
    return e;
  },
  ia = B({
    name: "deleteSelectedElements",
    label: "labels.delete",
    icon: kt,
    trackEvent: { category: "element", action: "delete" },
    perform: (e, o, t, r) => {
      if (o.editingLinearElement) {
        let {
            elementId: a,
            selectedPointsIndices: l,
            startBindingElement: s,
            endBindingElement: d,
          } = o.editingLinearElement,
          m = r.scene.getNonDeletedElementsMap(),
          c = mb.getElement(a, m);
        if (!c || l == null) return !1;
        if (c.points.length < 2) {
          let u = e.map((b) => (b.id === c.id ? ps(b, { isDeleted: !0 }) : b)),
            f = ub(o, u);
          return {
            elements: u,
            appState: { ...f, editingLinearElement: null },
            captureUpdate: ms.IMMEDIATELY,
          };
        }
        let p = {
          startBindingElement: l?.includes(0) ? null : s,
          endBindingElement: l?.includes(c.points.length - 1) ? null : d,
        };
        return (
          mb.deletePoints(c, r, l),
          {
            elements: e,
            appState: {
              ...o,
              editingLinearElement: {
                ...o.editingLinearElement,
                ...p,
                selectedPointsIndices: l?.[0] > 0 ? [l[0] - 1] : [0],
              },
            },
            captureUpdate: ms.IMMEDIATELY,
          }
        );
      }
      let { elements: n, appState: i } = xC(e, o, r);
      return (
        uC(
          n,
          n.filter((a) => a.isDeleted)
        ),
        (i = ub(i, n)),
        {
          elements: n,
          appState: {
            ...i,
            activeTool: pC(o, { type: "selection" }),
            multiElement: null,
            activeEmbeddable: null,
            selectedLinearElement: null,
          },
          captureUpdate: Ee(Xm(e), o) ? ms.IMMEDIATELY : ms.EVENTUALLY,
        }
      );
    },
    keyTest: (e, o, t) => (e.key === Vm.BACKSPACE || e.key === Vm.DELETE) && !e[Vm.CTRL_OR_CMD],
    PanelComponent: ({ elements: e, appState: o, updateData: t }) =>
      EC(V, {
        type: "button",
        icon: kt,
        title: g("labels.delete"),
        "aria-label": g("labels.delete"),
        onClick: () => t(null),
        visible: Ee(Xm(e), o),
      }),
  });
import { KEYS as Dn, CODES as _n, getShortcutKey as Rn, isDarwin as us } from "@excalidraw/common";
import {
  moveOneLeft as yC,
  moveOneRight as wC,
  moveAllLeft as vC,
  moveAllRight as TC,
} from "@excalidraw/element";
import { CaptureUpdateAction as hs } from "@excalidraw/element";
import { jsx as gs } from "react/jsx-runtime";
var Zm = B({
    name: "sendBackward",
    label: "labels.sendBackward",
    keywords: ["move down", "zindex", "layer"],
    icon: Mm,
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => ({
      elements: yC(e, o, r.scene),
      appState: o,
      captureUpdate: hs.IMMEDIATELY,
    }),
    keyPriority: 40,
    keyTest: (e) => e[Dn.CTRL_OR_CMD] && !e.shiftKey && e.code === _n.BRACKET_LEFT,
    PanelComponent: ({ updateData: e, appState: o }) =>
      gs("button", {
        type: "button",
        className: "zIndexButton",
        onClick: () => e(null),
        title: `${g("labels.sendBackward")} \u2014 ${Rn("CtrlOrCmd+[")}`,
        children: Mm,
      }),
  }),
  $m = B({
    name: "bringForward",
    label: "labels.bringForward",
    keywords: ["move up", "zindex", "layer"],
    icon: km,
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => ({
      elements: wC(e, o, r.scene),
      appState: o,
      captureUpdate: hs.IMMEDIATELY,
    }),
    keyPriority: 40,
    keyTest: (e) => e[Dn.CTRL_OR_CMD] && !e.shiftKey && e.code === _n.BRACKET_RIGHT,
    PanelComponent: ({ updateData: e, appState: o }) =>
      gs("button", {
        type: "button",
        className: "zIndexButton",
        onClick: () => e(null),
        title: `${g("labels.bringForward")} \u2014 ${Rn("CtrlOrCmd+]")}`,
        children: km,
      }),
  }),
  jm = B({
    name: "sendToBack",
    label: "labels.sendToBack",
    keywords: ["move down", "zindex", "layer"],
    icon: Pm,
    trackEvent: { category: "element" },
    perform: (e, o) => ({ elements: vC(e, o), appState: o, captureUpdate: hs.IMMEDIATELY }),
    keyTest: (e) =>
      us
        ? e[Dn.CTRL_OR_CMD] && e.altKey && e.code === _n.BRACKET_LEFT
        : e[Dn.CTRL_OR_CMD] && e.shiftKey && e.code === _n.BRACKET_LEFT,
    PanelComponent: ({ updateData: e, appState: o }) =>
      gs("button", {
        type: "button",
        className: "zIndexButton",
        onClick: () => e(null),
        title: `${g("labels.sendToBack")} \u2014 ${
          us ? Rn("CtrlOrCmd+Alt+[") : Rn("CtrlOrCmd+Shift+[")
        }`,
        children: Pm,
      }),
  }),
  qm = B({
    name: "bringToFront",
    label: "labels.bringToFront",
    keywords: ["move up", "zindex", "layer"],
    icon: Lm,
    trackEvent: { category: "element" },
    perform: (e, o) => ({ elements: TC(e, o), appState: o, captureUpdate: hs.IMMEDIATELY }),
    keyTest: (e) =>
      us
        ? e[Dn.CTRL_OR_CMD] && e.altKey && e.code === _n.BRACKET_RIGHT
        : e[Dn.CTRL_OR_CMD] && e.shiftKey && e.code === _n.BRACKET_RIGHT,
    PanelComponent: ({ updateData: e, appState: o }) =>
      gs("button", {
        type: "button",
        className: "zIndexButton",
        onClick: (t) => e(null),
        title: `${g("labels.bringToFront")} \u2014 ${
          us ? Rn("CtrlOrCmd+Alt+]") : Rn("CtrlOrCmd+Shift+]")
        }`,
        children: Lm,
      }),
  });
import { getNonDeletedElements as IC } from "@excalidraw/element";
import { LinearElementEditor as CC } from "@excalidraw/element";
import { isLinearElement as SC, isTextElement as kC } from "@excalidraw/element";
import { arrayToMap as MC, KEYS as hb } from "@excalidraw/common";
import { selectGroupsForSelectedElements as LC } from "@excalidraw/element";
import { CaptureUpdateAction as PC } from "@excalidraw/element";
var Jm = B({
  name: "selectAll",
  label: "labels.selectAll",
  icon: $0,
  trackEvent: { category: "canvas" },
  viewMode: !1,
  perform: (e, o, t, r) => {
    if (o.editingLinearElement) return !1;
    let n = e
      .filter((i) => !i.isDeleted && !(kC(i) && i.containerId) && !i.locked)
      .reduce((i, a) => ((i[a.id] = !0), i), {});
    return {
      appState: {
        ...o,
        ...LC({ editingGroupId: null, selectedElementIds: n }, IC(e), o, r),
        selectedLinearElement: Object.keys(n).length === 1 && SC(e[0]) ? new CC(e[0], MC(e)) : null,
      },
      captureUpdate: PC.IMMEDIATELY,
    };
  },
  keyTest: (e) => e[hb.CTRL_OR_CMD] && e.key === hb.A,
});
import {
  DEFAULT_GRID_SIZE as gb,
  KEYS as fb,
  arrayToMap as bb,
  getShortcutKey as AC,
} from "@excalidraw/common";
import { getNonDeletedElements as xb } from "@excalidraw/element";
import { LinearElementEditor as DC } from "@excalidraw/element";
import { getSelectedElements as _C, getSelectionStateForElements as RC } from "@excalidraw/element";
import { syncMovedIndices as NC } from "@excalidraw/element";
import { duplicateElements as BC } from "@excalidraw/element";
import { CaptureUpdateAction as Eb } from "@excalidraw/element";
import { jsx as FC } from "react/jsx-runtime";
var Qm = B({
  name: "duplicateSelection",
  label: "labels.duplicateSelection",
  icon: ji,
  trackEvent: { category: "element" },
  perform: (e, o, t, r) => {
    if (o.selectedElementsAreBeingDragged) return !1;
    if (o.editingLinearElement)
      try {
        let a = DC.duplicateSelectedPoints(o, r.scene);
        return { elements: e, appState: a, captureUpdate: Eb.IMMEDIATELY };
      } catch {
        return !1;
      }
    let { duplicatedElements: n, elementsWithDuplicates: i } = BC({
      type: "in-place",
      elements: e,
      idsOfElementsToDuplicate: bb(
        _C(e, o, { includeBoundTextElement: !0, includeElementsInFrames: !0 })
      ),
      appState: o,
      randomizeSeed: !0,
      overrides: ({ origElement: a, origIdToDuplicateId: l }) => {
        let s = a.frameId && l.get(a.frameId);
        return { x: a.x + gb / 2, y: a.y + gb / 2, frameId: s ?? a.frameId };
      },
    });
    if (r.props.onDuplicate && i) {
      let a = r.props.onDuplicate(i, e);
      a && (i = a);
    }
    return {
      elements: NC(i, bb(n)),
      appState: { ...o, ...RC(n, xb(i), o) },
      captureUpdate: Eb.IMMEDIATELY,
    };
  },
  keyTest: (e) => e[fb.CTRL_OR_CMD] && e.key === fb.D,
  PanelComponent: ({ elements: e, appState: o, updateData: t }) =>
    FC(V, {
      type: "button",
      icon: ji,
      title: `${g("labels.duplicateSelection")} \u2014 ${AC("CtrlOrCmd+D")}`,
      "aria-label": g("labels.duplicateSelection"),
      onClick: () => t(null),
      visible: Ee(xb(e), o),
    }),
});
import { pointFrom as FS } from "@excalidraw/math";
import { useEffect as vp, useMemo as OS, useRef as Tp, useState as zS } from "react";
import {
  DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE as HS,
  DEFAULT_ELEMENT_BACKGROUND_PICKS as GS,
  DEFAULT_ELEMENT_STROKE_COLOR_PALETTE as US,
  DEFAULT_ELEMENT_STROKE_PICKS as YS,
  ARROW_TYPE as Do,
  DEFAULT_FONT_FAMILY as WS,
  DEFAULT_FONT_SIZE as VS,
  FONT_FAMILY as XS,
  ROUNDNESS as As,
  STROKE_WIDTH as Ip,
  VERTICAL_ALIGN as Ps,
  KEYS as Vn,
  randomInteger as KS,
  arrayToMap as kp,
  getFontFamilyString as ZS,
  getShortcutKey as $S,
  getLineHeight as jS,
  isTransparent as qS,
  reduceToCommonValue as JS,
} from "@excalidraw/common";
import { canBecomePolygon as QS, getNonDeletedElements as ax } from "@excalidraw/element";
import {
  bindLinearElement as ox,
  calculateFixedPointForElbowArrowBinding as rx,
  updateBoundElements as e4,
} from "@excalidraw/element";
import { LinearElementEditor as Cp } from "@excalidraw/element";
import { newElementWith as Ke } from "@excalidraw/element";
import { getBoundTextElement as sr, redrawTextBoundingBox as ha } from "@excalidraw/element";
import {
  isArrowElement as Ds,
  isBoundToContainer as t4,
  isElbowArrow as lx,
  isLinearElement as Sp,
  isLineElement as nx,
  isTextElement as xt,
  isUsingAdaptiveRadius as o4,
} from "@excalidraw/element";
import { hasStrokeColor as r4 } from "@excalidraw/element";
import {
  updateElbowArrowPoints as n4,
  CaptureUpdateAction as Ze,
  toggleLinePolygonState as i4,
} from "@excalidraw/element";
import { isDevEnv as OC } from "@excalidraw/common";
var zC = new Set(["command_palette", "export"]),
  re = (e, o, t, r) => {
    try {
      if (
        typeof window > "u" ||
        T.VITE_WORKER_ID ||
        T.VITE_APP_ENABLE_TRACKING !== "true" ||
        !zC.has(e) ||
        OC()
      )
        return;
      T.PROD || console.info("trackEvent", { category: e, action: o, label: t, value: r }),
        window.sa_event && window.sa_event(o, { category: e, label: t, value: r });
    } catch (n) {
      console.error("error during analytics", n);
    }
  };
import YC from "clsx";
import HC from "clsx";
import { forwardRef as GC } from "react";
import { jsx as UC } from "react/jsx-runtime";
var Nn = GC((e, o) => {
  let { title: t, className: r, testId: n, active: i, standalone: a, icon: l, onClick: s } = e;
  return UC(
    "button",
    {
      type: "button",
      ref: o,
      title: t,
      "data-testid": n,
      className: HC(r, { standalone: a, active: i }),
      onClick: s,
      style: e.style,
      children: l,
    },
    t
  );
});
import { Fragment as VC, jsx as ep, jsxs as WC } from "react/jsx-runtime";
var Ft = (e) =>
  ep(VC, {
    children: e.options.map((o) =>
      e.type === "button"
        ? ep(
            Nn,
            {
              icon: o.icon,
              title: o.text,
              testId: o.testId,
              active: o.active ?? e.value === o.value,
              onClick: (t) => e.onClick(o.value, t),
            },
            o.text
          )
        : WC(
            "label",
            {
              className: YC({ active: e.value === o.value }),
              title: o.text,
              children: [
                ep("input", {
                  type: "radio",
                  name: e.group,
                  onChange: () => e.onChange(o.value),
                  checked: e.value === o.value,
                  "data-testid": o.testId,
                }),
                o.icon,
              ],
            },
            o.text
          )
    ),
  });
import * as vs from "@radix-ui/react-popover";
import W6 from "clsx";
import { useRef as V6 } from "react";
import {
  COLOR_OUTLINE_CONTRAST_THRESHOLD as X6,
  COLOR_PALETTE as Ob,
  isTransparent as K6,
} from "@excalidraw/common";
import { jsx as XC } from "react/jsx-runtime";
var fs = () =>
  XC("div", {
    style: {
      width: 1,
      height: "1rem",
      backgroundColor: "var(--default-border-color)",
      margin: "0 auto",
    },
  });
import { useEffect as qC, useRef as JC } from "react";
import { createPortal as QC } from "react-dom";
import { EVENT as or, KEYS as e6, rgbToHex as t6 } from "@excalidraw/common";
import yb from "react";
var tp = yb.createContext(null),
  ge = () => yb.useContext(tp);
import { useState as KC, useLayoutEffect as wb } from "react";
import { THEME as ZC } from "@excalidraw/common";
var bs = (e) => {
  let [o, t] = KC(null),
    r = ae(),
    { theme: n } = ge(),
    { container: i } = Ge();
  return (
    wb(() => {
      o &&
        ((o.className = ""),
        o.classList.add("excalidraw", ...(e?.className?.split(/\s+/) || [])),
        o.classList.toggle("excalidraw--mobile", r.editor.isMobile),
        o.classList.toggle("theme--dark", n === ZC.DARK));
    }, [o, n, r.editor.isMobile, e?.className]),
    wb(() => {
      let a = e?.parentSelector ? i?.querySelector(e.parentSelector) : document.body;
      if (!a) return;
      let l = document.createElement("div");
      return (
        a.appendChild(l),
        t(l),
        () => {
          a.removeChild(l);
        }
      );
    }, [i, e?.parentSelector]),
    o
  );
};
import { useEffect as $C } from "react";
import { EVENT as xs } from "@excalidraw/common";
function Bn(e, o, t) {
  $C(() => {
    function r(n) {
      let i = n;
      if (!e.current) return;
      let a = t?.(i, e.current);
      if (a === !0) return;
      if (a === !1) return o(i);
      e.current.contains(i.target) ||
        !document.documentElement.contains(i.target) ||
        i.target.closest("[data-radix-portal]") ||
        (i.target === document.documentElement && document.body.style.pointerEvents === "none") ||
        i.target.closest("[data-prevent-outside-click]") ||
        o(i);
    }
    return (
      document.addEventListener(xs.POINTER_DOWN, r),
      document.addEventListener(xs.TOUCH_START, r),
      () => {
        document.removeEventListener(xs.POINTER_DOWN, r),
          document.removeEventListener(xs.TOUCH_START, r);
      }
    );
  }, [e, o, t]);
}
import { useRef as jC } from "react";
var tr = (e) => {
  let o = jC(e);
  return Object.assign(o.current, e), o.current;
};
import { jsx as o6 } from "react/jsx-runtime";
var rr = me(null),
  vb = ({ onCancel: e, onChange: o, onSelect: t, colorPickerType: r }) => {
    let n = bs({
        className: "excalidraw-eye-dropper-backdrop",
        parentSelector: ".excalidraw-eye-dropper-container",
      }),
      i = ge(),
      a = nr(),
      l = Re(),
      s = Z(a, i),
      d = tr({ app: l, onCancel: e, onChange: o, onSelect: t, selectedElements: s }),
      { container: m } = Ge();
    qC(() => {
      let p = c.current;
      if (!p || !l.canvas || !n) return;
      let u = !1,
        f = l.canvas.getContext("2d"),
        b = ({ clientX: S, clientY: M }) => {
          let k = f.getImageData(
            (S - i.offsetLeft) * window.devicePixelRatio,
            (M - i.offsetTop) * window.devicePixelRatio,
            1,
            1
          ).data;
          return t6(k[0], k[1], k[2]);
        },
        x = ({ clientX: S, clientY: M, altKey: k }) => {
          (p.style.top = `${M + 20}px`), (p.style.left = `${S + 20}px`);
          let A = b({ clientX: S, clientY: M });
          u && d.onChange(r, A, d.selectedElements, { altKey: k }), (p.style.background = A);
        },
        w = () => {
          d.onCancel();
        },
        E = (S, M) => {
          d.onSelect(S, M);
        },
        y = (S) => {
          (u = !0), S.stopImmediatePropagation();
        },
        v = (S) => {
          (u = !1), m?.focus(), S.stopImmediatePropagation(), S.preventDefault(), E(b(S), S);
        },
        C = (S) => {
          S.key === e6.ESCAPE && (S.preventDefault(), S.stopImmediatePropagation(), w());
        };
      return (
        (n.tabIndex = -1),
        n.focus(),
        x({
          clientX: d.app.lastViewportPosition.x,
          clientY: d.app.lastViewportPosition.y,
          altKey: !1,
        }),
        n.addEventListener(or.KEYDOWN, C),
        n.addEventListener(or.POINTER_DOWN, y),
        n.addEventListener(or.POINTER_UP, v),
        window.addEventListener("pointermove", x, { passive: !0 }),
        window.addEventListener(or.BLUR, w),
        () => {
          (u = !1),
            n.removeEventListener(or.KEYDOWN, C),
            n.removeEventListener(or.POINTER_DOWN, y),
            n.removeEventListener(or.POINTER_UP, v),
            window.removeEventListener("pointermove", x),
            window.removeEventListener(or.BLUR, w);
        }
      );
    }, [d, l.canvas, n, r, m, i.offsetLeft, i.offsetTop]);
    let c = JC(null);
    return (
      Bn(
        c,
        () => {
          e();
        },
        (p) =>
          !!p.target.closest(".excalidraw-eye-dropper-trigger, .excalidraw-eye-dropper-backdrop")
      ),
      n ? QC(o6("div", { ref: c, className: "excalidraw-eye-dropper-preview" }), n) : null
    );
  };
import * as Fn from "@radix-ui/react-popover";
import a6 from "clsx";
import l6 from "react";
import { isInteractive as s6 } from "@excalidraw/common";
import r6 from "react";
import n6 from "clsx";
import { jsx as i6 } from "react/jsx-runtime";
var Xe = r6.forwardRef(({ children: e, padding: o, className: t, style: r }, n) =>
  i6("div", { className: n6("Island", t), style: { "--padding": o, ...r }, ref: n, children: e })
);
import { jsx as op, jsxs as c6 } from "react/jsx-runtime";
var Es = l6.forwardRef(
  (
    {
      className: e,
      container: o,
      children: t,
      style: r,
      onClose: n,
      onKeyDown: i,
      onFocusOutside: a,
      onPointerLeave: l,
      onPointerDownOutside: s,
    },
    d
  ) => {
    let m = ae();
    return op(Fn.Portal, {
      container: o,
      children: c6(Fn.Content, {
        ref: d,
        className: a6("focus-visible-none", e),
        "data-prevent-outside-click": !0,
        side: m.editor.isMobile && !m.viewport.isLandscape ? "bottom" : "right",
        align: m.editor.isMobile && !m.viewport.isLandscape ? "center" : "start",
        alignOffset: -16,
        sideOffset: 20,
        style: { zIndex: "var(--zIndex-popup)" },
        onPointerLeave: l,
        onKeyDown: i,
        onFocusOutside: a,
        onPointerDownOutside: s,
        onCloseAutoFocus: (c) => {
          c.stopPropagation(),
            c.preventDefault(),
            o && !s6(document.activeElement) && o.focus(),
            n();
        },
        children: [
          op(Xe, { padding: 3, style: r, children: t }),
          op(Fn.Arrow, {
            width: 20,
            height: 10,
            style: {
              fill: "var(--popup-bg-color)",
              filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)",
            },
          }),
        ],
      }),
    });
  }
);
import m6 from "clsx";
import { useCallback as p6, useEffect as np, useRef as Cb, useState as u6 } from "react";
import { KEYS as ip, getShortcutKey as h6 } from "@excalidraw/common";
import { MAX_CUSTOM_COLORS_USED_IN_CANVAS as d6 } from "@excalidraw/common";
var ir = ({ palette: e, color: o }) => {
    if (!o) return null;
    for (let [t, r] of Object.entries(e))
      if (Array.isArray(r)) {
        let n = r.indexOf(o);
        if (n > -1) return { colorName: t, shade: n };
      } else if (r === o) return { colorName: t, shade: null };
    return null;
  },
  aa = [
    ["q", "w", "e", "r", "t"],
    ["a", "s", "d", "f", "g"],
    ["z", "x", "c", "v", "b"],
  ].flat(),
  rp = ({ color: e, palette: o }) => !Object.values(o).flat().includes(e),
  Ib = (e, o, t) => {
    let r = { elementBackground: "backgroundColor", elementStroke: "strokeColor" },
      n = e.filter((a) => {
        if (a.isDeleted) return !1;
        let l = a[r[o]];
        return rp({ color: l, palette: t });
      }),
      i = new Map();
    return (
      n.forEach((a) => {
        let l = a[r[o]];
        i.has(l) ? i.set(l, i.get(l) + 1) : i.set(l, 1);
      }),
      [...i.entries()]
        .sort((a, l) => l[1] - a[1])
        .map((a) => a[0])
        .slice(0, d6)
    );
  },
  Ot = me(null),
  Tb = (e, o, t) => (e * 299 + o * 587 + t * 114) / 1e3,
  On = (e, o = 160) => {
    if (!e) return !0;
    if (e === "transparent") return !1;
    if (!e.startsWith("#")) {
      let i = document.createElement("div");
      if (((i.style.color = e), i.style.color)) {
        (i.style.position = "absolute"),
          (i.style.visibility = "hidden"),
          (i.style.width = "0"),
          (i.style.height = "0"),
          document.body.appendChild(i);
        let a = getComputedStyle(i).color;
        document.body.removeChild(i);
        let l = a
            .replace(/^(rgb|rgba)\(/, "")
            .replace(/\)$/, "")
            .replace(/\s/g, "")
            .split(","),
          s = parseInt(l[0]),
          d = parseInt(l[1]),
          m = parseInt(l[2]);
        return Tb(s, d, m) < o;
      }
      return !0;
    }
    let t = parseInt(e.slice(1, 3), 16),
      r = parseInt(e.slice(3, 5), 16),
      n = parseInt(e.slice(5, 7), 16);
    return Tb(t, r, n) < o;
  };
import { Fragment as g6, jsx as ys, jsxs as Sb } from "react/jsx-runtime";
var kb = ({ color: e, onChange: o, label: t, colorPickerType: r, placeholder: n }) => {
  let i = ae(),
    [a, l] = u6(e),
    [s, d] = ne(Ot);
  np(() => {
    l(e);
  }, [e]);
  let m = p6(
      (b) => {
        let x = b.toLowerCase(),
          w = Mb(x);
        w && o(w), l(x);
      },
      [o]
    ),
    c = Cb(null),
    p = Cb(null);
  np(() => {
    c.current && c.current.focus();
  }, [s]);
  let [u, f] = ne(rr);
  return (
    np(
      () => () => {
        f(null);
      },
      [f]
    ),
    Sb("div", {
      className: "color-picker__input-label",
      children: [
        ys("div", { className: "color-picker__input-hash", children: "#" }),
        ys("input", {
          ref: s === "hex" ? c : void 0,
          style: { border: 0, padding: 0 },
          spellCheck: !1,
          className: "color-picker-input",
          "aria-label": t,
          onChange: (b) => {
            m(b.target.value);
          },
          value: (a || "").replace(/^#/, ""),
          onBlur: () => {
            l(e);
          },
          tabIndex: -1,
          onFocus: () => d("hex"),
          onKeyDown: (b) => {
            b.key !== ip.TAB && (b.key === ip.ESCAPE && p.current?.focus(), b.stopPropagation());
          },
          placeholder: n,
        }),
        !i.editor.isMobile &&
          Sb(g6, {
            children: [
              ys("div", {
                style: {
                  width: "1px",
                  height: "1.25rem",
                  backgroundColor: "var(--default-border-color)",
                },
              }),
              ys("div", {
                ref: p,
                className: m6("excalidraw-eye-dropper-trigger", { selected: u }),
                onClick: () =>
                  f((b) =>
                    b ? null : { keepOpenOnAlt: !1, onSelect: (x) => o(x), colorPickerType: r }
                  ),
                title: `${g("labels.eyeDropper")} \u2014 ${ip.I.toLocaleUpperCase()} or ${h6(
                  "Alt"
                )} `,
                children: H0,
              }),
            ],
          }),
      ],
    })
  );
};
import cp, { useEffect as dp, useImperativeHandle as R6, useState as N6 } from "react";
import { EVENT as Rb } from "@excalidraw/common";
import {
  DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX as B6,
  DEFAULT_ELEMENT_STROKE_COLOR_INDEX as F6,
  KEYS as O6,
} from "@excalidraw/common";
import x6 from "clsx";
import { useEffect as E6, useRef as y6 } from "react";
import { jsxs as b6 } from "react/jsx-runtime";
var f6 = ({ color: e, keyLabel: o, isShade: t = !1 }) =>
    b6("div", {
      className: "color-picker__button__hotkey-label",
      style: { color: On(e) ? "#fff" : "#000" },
      children: [t && "\u21E7", o],
    }),
  zn = f6;
import { jsx as ap, jsxs as w6 } from "react/jsx-runtime";
var Lb = ({ colors: e, color: o, onChange: t, label: r }) => {
  let [n, i] = ne(Ot),
    a = y6(null);
  return (
    E6(() => {
      a.current && a.current.focus();
    }, [o, n]),
    ap("div", {
      className: "color-picker-content--default",
      children: e.map((l, s) =>
        w6(
          "button",
          {
            ref: o === l ? a : void 0,
            tabIndex: -1,
            type: "button",
            className: x6("color-picker__button color-picker__button--large has-outline", {
              active: o === l,
              "is-transparent": l === "transparent" || !l,
            }),
            onClick: () => {
              t(l), i("custom");
            },
            title: l,
            "aria-label": r,
            style: { "--swatch-color": l },
            children: [
              ap("div", { className: "color-picker__button-outline" }),
              ap(zn, { color: l, keyLabel: s + 1 }),
            ],
          },
          s
        )
      ),
    })
  );
};
import v6 from "clsx";
import { useEffect as T6, useRef as I6 } from "react";
import { jsx as lp, jsxs as S6 } from "react/jsx-runtime";
var C6 = ({ palette: e, color: o, onChange: t, activeShade: r }) => {
    let n = ir({ color: o, palette: e }),
      [i, a] = ne(Ot),
      l = I6(null);
    return (
      T6(() => {
        l.current && i === "baseColors" && l.current.focus();
      }, [n?.colorName, i]),
      lp("div", {
        className: "color-picker-content--default",
        children: Object.entries(e).map(([s, d], m) => {
          let c = (Array.isArray(d) ? d[r] : d) || "transparent",
            p = aa[m],
            u = g(`colors.${s.replace(/\d+/, "")}`, null, "");
          return S6(
            "button",
            {
              ref: n?.colorName === s ? l : void 0,
              tabIndex: -1,
              type: "button",
              className: v6("color-picker__button color-picker__button--large has-outline", {
                active: n?.colorName === s,
                "is-transparent": c === "transparent" || !c,
              }),
              onClick: () => {
                t(c), a("baseColors");
              },
              title: `${u}${c.startsWith("#") ? ` ${c}` : ""} \u2014 ${p}`,
              "aria-label": `${u} \u2014 ${p}`,
              style: c ? { "--swatch-color": c } : void 0,
              "data-testid": `color-${s}`,
              children: [
                lp("div", { className: "color-picker__button-outline" }),
                lp(zn, { color: c, keyLabel: p }),
              ],
            },
            s
          );
        }),
      })
    );
  },
  Pb = C6;
import { jsx as M6 } from "react/jsx-runtime";
var k6 = ({ children: e }) => M6("div", { className: "color-picker__heading", children: e }),
  Hn = k6;
import L6 from "clsx";
import { useEffect as P6, useRef as A6 } from "react";
import { jsx as la, jsxs as Ab } from "react/jsx-runtime";
var Db = ({ color: e, onChange: o, palette: t }) => {
  let r = ir({ color: e || "transparent", palette: t }),
    [n, i] = ne(Ot),
    a = A6(null);
  if (
    (P6(() => {
      a.current && n === "shades" && a.current.focus();
    }, [r, n]),
    r)
  ) {
    let { colorName: l, shade: s } = r,
      d = t[l];
    if (Array.isArray(d))
      return la("div", {
        className: "color-picker-content--default shades",
        children: d.map((m, c) =>
          Ab(
            "button",
            {
              ref: c === s && n === "shades" ? a : void 0,
              tabIndex: -1,
              type: "button",
              className: L6("color-picker__button color-picker__button--large has-outline", {
                active: c === s,
              }),
              "aria-label": "Shade",
              title: `${l} - ${c + 1}`,
              style: m ? { "--swatch-color": m } : void 0,
              onClick: () => {
                o(m), i("shades");
              },
              children: [
                la("div", { className: "color-picker__button-outline" }),
                la(zn, { color: m, keyLabel: c + 1, isShade: !0 }),
              ],
            },
            c
          )
        ),
      });
  }
  return Ab("div", {
    className: "color-picker-content--default",
    style: { position: "relative" },
    tabIndex: -1,
    children: [
      la("button", {
        type: "button",
        tabIndex: -1,
        className:
          "color-picker__button color-picker__button--large color-picker__button--no-focus-visible",
      }),
      la("div", {
        tabIndex: -1,
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          textAlign: "center",
          fontSize: "0.75rem",
        },
        children: g("colorPicker.noShades"),
      }),
    ],
  });
};
import { COLORS_PER_ROW as Gn, COLOR_PALETTE as D6, KEYS as sa } from "@excalidraw/common";
var sp = (e, o, t) => {
    let r = Math.ceil(t / Gn);
    switch (((o = o ?? -1), e)) {
      case "ArrowLeft": {
        let n = o - 1;
        return n < 0 ? t - 1 : n;
      }
      case "ArrowRight":
        return (o + 1) % t;
      case "ArrowDown": {
        let n = o + Gn;
        return n >= t ? o % Gn : n;
      }
      case "ArrowUp": {
        let n = o - Gn,
          i = n < 0 ? Gn * r + n : n;
        return i >= t ? void 0 : i;
      }
    }
  },
  _6 = ({
    e,
    colorObj: o,
    onChange: t,
    palette: r,
    customColors: n,
    setActiveColorPickerSection: i,
    activeShade: a,
  }) => {
    if (
      o?.shade != null &&
      ["Digit1", "Digit2", "Digit3", "Digit4", "Digit5"].includes(e.code) &&
      e.shiftKey
    ) {
      let l = Number(e.code.slice(-1)) - 1;
      return t(r[o.colorName][l]), i("shades"), !0;
    }
    if (["1", "2", "3", "4", "5"].includes(e.key) && n[Number(e.key) - 1])
      return t(n[Number(e.key) - 1]), i("custom"), !0;
    if (aa.includes(e.key)) {
      let l = aa.indexOf(e.key),
        s = Object.keys(r)[l],
        d = r[s],
        m = Array.isArray(d) ? d[a] : d;
      return t(m), i("baseColors"), !0;
    }
    return !1;
  },
  _b = ({
    event: e,
    activeColorPickerSection: o,
    palette: t,
    color: r,
    onChange: n,
    customColors: i,
    setActiveColorPickerSection: a,
    updateData: l,
    activeShade: s,
    onEyeDropperToggle: d,
    onEscape: m,
  }) => {
    if (e[sa.CTRL_OR_CMD]) return !1;
    if (e.key === sa.ESCAPE) return m(e), !0;
    if (e.key === sa.ALT) return d(!0), !0;
    if (e.key === sa.I) return d(), !0;
    let c = ir({ color: r, palette: t });
    if (e.key === sa.TAB) {
      let p = { custom: !!i.length, baseColors: !0, shades: c?.shade != null, hex: !0 },
        u = Object.entries(p).reduce((E, [y, v]) => (v && E.push(y), E), []),
        f = u.indexOf(o),
        b = e.shiftKey ? -1 : 1,
        x = f + b > u.length - 1 ? 0 : f + b < 0 ? u.length - 1 : f + b,
        w = u[x];
      return (
        w && a(w),
        w === "custom"
          ? n(i[0])
          : w === "baseColors" &&
            (Object.entries(t).find(([y, v]) =>
              Array.isArray(v) ? v.includes(r) : v === r ? y : null
            ) ||
              n(D6.black)),
        e.preventDefault(),
        e.stopPropagation(),
        !0
      );
    }
    if (
      _6({
        e,
        colorObj: c,
        onChange: n,
        palette: t,
        customColors: i,
        setActiveColorPickerSection: a,
        activeShade: s,
      })
    )
      return !0;
    if (o === "shades" && c) {
      let { shade: p } = c,
        u = sp(e.key, p, Gn);
      if (u !== void 0) return n(t[c.colorName][u]), !0;
    }
    if (o === "baseColors" && c) {
      let { colorName: p } = c,
        u = Object.keys(t),
        f = u.indexOf(p),
        b = sp(e.key, f, u.length);
      if (b !== void 0) {
        let x = u[b],
          w = t[x];
        return n(Array.isArray(w) ? w[s] : w), !0;
      }
    }
    if (o === "custom") {
      let p = r != null ? i.indexOf(r) : 0,
        u = sp(e.key, p, i.length);
      if (u !== void 0) {
        let f = i[u];
        return n(f), !0;
      }
    }
    return !1;
  };
import { jsx as Wr, jsxs as ws } from "react/jsx-runtime";
var Nb = cp.forwardRef(
  (
    {
      color: e,
      onChange: o,
      type: t,
      elements: r,
      palette: n,
      updateData: i,
      children: a,
      onEyeDropperToggle: l,
      onEscape: s,
    },
    d
  ) => {
    let [m] = cp.useState(() => (t === "canvasBackground" ? [] : Ib(r, t, n))),
      [c, p] = ne(Ot),
      u = ir({ color: e, palette: n });
    dp(() => {
      if (!c) {
        let w = !!e && rp({ color: e, palette: n }),
          E = w && !m.includes(e);
        p(E ? null : w ? "custom" : u?.shade != null ? "shades" : "baseColors");
      }
    }, [c, e, n, p, u, m]);
    let [f, b] = N6(u?.shade ?? (t === "elementBackground" ? B6 : F6));
    dp(() => {
      u?.shade != null && b(u.shade);
      let w = (E) => {
        E.key === O6.ALT && l(!1);
      };
      return (
        document.addEventListener(Rb.KEYUP, w, { capture: !0 }),
        () => {
          document.removeEventListener(Rb.KEYUP, w, { capture: !0 });
        }
      );
    }, [u, l]);
    let x = cp.useRef(null);
    return (
      R6(d, () => x.current),
      dp(() => {
        x?.current?.focus();
      }, []),
      Wr("div", {
        role: "dialog",
        "aria-modal": "true",
        "aria-label": g("labels.colorPicker"),
        children: ws("div", {
          ref: x,
          onKeyDown: (w) => {
            _b({
              event: w,
              activeColorPickerSection: c,
              palette: n,
              color: e,
              onChange: o,
              onEyeDropperToggle: l,
              customColors: m,
              setActiveColorPickerSection: p,
              updateData: i,
              activeShade: f,
              onEscape: s,
            }) && (w.preventDefault(), w.stopPropagation());
          },
          className: "color-picker-content properties-content",
          tabIndex: -1,
          children: [
            !!m.length &&
              ws("div", {
                children: [
                  Wr(Hn, { children: g("colorPicker.mostUsedCustomColors") }),
                  Wr(Lb, {
                    colors: m,
                    color: e,
                    label: g("colorPicker.mostUsedCustomColors"),
                    onChange: o,
                  }),
                ],
              }),
            ws("div", {
              children: [
                Wr(Hn, { children: g("colorPicker.colors") }),
                Wr(Pb, { color: e, palette: n, onChange: o, activeShade: f }),
              ],
            }),
            ws("div", {
              children: [
                Wr(Hn, { children: g("colorPicker.shades") }),
                Wr(Db, { color: e, onChange: o, palette: n }),
              ],
            }),
            a,
          ],
        }),
      })
    );
  }
);
import z6 from "clsx";
import {
  COLOR_OUTLINE_CONTRAST_THRESHOLD as H6,
  DEFAULT_CANVAS_BACKGROUND_PICKS as G6,
  DEFAULT_ELEMENT_BACKGROUND_PICKS as U6,
  DEFAULT_ELEMENT_STROKE_PICKS as Y6,
} from "@excalidraw/common";
import { jsx as mp } from "react/jsx-runtime";
var Bb = ({ onChange: e, type: o, activeColor: t, topPicks: r }) => {
  let n;
  return (
    o === "elementStroke" && (n = Y6),
    o === "elementBackground" && (n = U6),
    o === "canvasBackground" && (n = G6),
    r && (n = r),
    n
      ? mp("div", {
          className: "color-picker__top-picks",
          children: n.map((i) =>
            mp(
              "button",
              {
                className: z6("color-picker__button", {
                  active: i === t,
                  "is-transparent": i === "transparent" || !i,
                  "has-outline": !On(i, H6),
                }),
                style: { "--swatch-color": i },
                type: "button",
                title: i,
                onClick: () => e(i),
                "data-testid": `color-top-pick-${i}`,
                children: mp("div", { className: "color-picker__button-outline" }),
              },
              i
            )
          ),
        })
      : (console.error("Invalid type for TopPicks"), null)
  );
};
import { jsx as Qt, jsxs as pp } from "react/jsx-runtime";
var Fb = (e) => {
    let o = new Option().style;
    return (o.color = e), !!o.color;
  },
  Mb = (e) => (K6(e) ? e : Fb(`#${e}`) ? `#${e}` : Fb(e) ? e : null),
  Z6 = ({
    type: e,
    color: o,
    onChange: t,
    label: r,
    elements: n,
    palette: i = Ob,
    updateData: a,
  }) => {
    let { container: l } = Ge(),
      [, s] = ne(Ot),
      [d, m] = ne(rr),
      c = pp("div", {
        children: [
          Qt(Hn, { children: g("colorPicker.hexCode") }),
          Qt(kb, {
            color: o || "",
            label: r,
            onChange: (f) => {
              t(f);
            },
            colorPickerType: e,
            placeholder: g("colorPicker.color"),
          }),
        ],
      }),
      p = V6(null),
      u = () => {
        p.current?.focus();
      };
    return Qt(Es, {
      container: l,
      style: { maxWidth: "13rem" },
      onFocusOutside: (f) => {
        u(), f.preventDefault();
      },
      onPointerDownOutside: (f) => {
        d && f.preventDefault();
      },
      onClose: () => {
        a({ openPopup: null }), s(null);
      },
      children: i
        ? Qt(Nb, {
            ref: p,
            palette: i,
            color: o,
            onChange: (f) => {
              t(f);
            },
            onEyeDropperToggle: (f) => {
              m((b) =>
                f
                  ? ((b = b || { keepOpenOnAlt: !0, onSelect: t, colorPickerType: e }),
                    (b.keepOpenOnAlt = !0),
                    b)
                  : f === !1 || b
                  ? null
                  : { keepOpenOnAlt: !1, onSelect: t, colorPickerType: e }
              );
            },
            onEscape: (f) => {
              d ? m(null) : a({ openPopup: null });
            },
            type: e,
            elements: n,
            updateData: a,
            children: c,
          })
        : c,
    });
  },
  $6 = ({ label: e, color: o, type: t }) =>
    Qt(vs.Trigger, {
      type: "button",
      className: W6("color-picker__button active-color properties-trigger", {
        "is-transparent": !o || o === "transparent",
        "has-outline": !o || !On(o, X6),
      }),
      "aria-label": e,
      style: o ? { "--swatch-color": o } : void 0,
      title: t === "elementStroke" ? g("labels.showStroke") : g("labels.showBackground"),
      children: Qt("div", { className: "color-picker__button-outline", children: !o && W1 }),
    }),
  ca = ({
    type: e,
    color: o,
    onChange: t,
    label: r,
    elements: n,
    palette: i = Ob,
    topPicks: a,
    updateData: l,
    appState: s,
  }) =>
    Qt("div", {
      children: pp("div", {
        role: "dialog",
        "aria-modal": "true",
        className: "color-picker-container",
        children: [
          Qt(Bb, { activeColor: o, onChange: t, type: e, topPicks: a }),
          Qt(fs, {}),
          pp(vs.Root, {
            open: s.openPopup === e,
            onOpenChange: (d) => {
              l({ openPopup: d ? e : null });
            },
            children: [
              Qt($6, { color: o, label: r, type: e }),
              s.openPopup === e &&
                Qt(Z6, {
                  type: e,
                  color: o,
                  onChange: t,
                  label: r,
                  elements: n,
                  palette: i,
                  updateData: l,
                }),
            ],
          }),
        ],
      }),
    });
import * as Zb from "@radix-ui/react-popover";
import IS, { useCallback as CS, useMemo as SS } from "react";
import { FONT_FAMILY as xp } from "@excalidraw/common";
import hS, {
  useMemo as ar,
  useState as gS,
  useRef as fS,
  useEffect as bS,
  useCallback as xS,
} from "react";
import {
  arrayToList as ES,
  debounce as yS,
  FONT_FAMILY as Vr,
  getFontFamilyString as wS,
} from "@excalidraw/common";
import j6 from "clsx";
import q6 from "react";
import { jsx as J6, jsxs as Q6 } from "react/jsx-runtime";
var Ts = q6.forwardRef(({ className: e, placeholder: o, onChange: t }, r) =>
  Q6("div", {
    className: j6("QuickSearch__wrapper", e),
    children: [
      Mt,
      J6("input", {
        ref: r,
        className: "QuickSearch__input",
        type: "text",
        placeholder: o,
        onChange: (n) => t(n.target.value.trim().toLowerCase()),
      }),
    ],
  })
);
import eS from "clsx";
import { Children as tS } from "react";
import { jsx as zb } from "react/jsx-runtime";
var Is = ({ className: e, placeholder: o, children: t }) => {
  let r = !tS.count(t);
  return zb("div", {
    className: eS("ScrollableList__wrapper", e),
    role: "menu",
    children: r ? zb("div", { className: "empty", children: o }) : t,
  });
};
import { jsx as oS, jsxs as rS } from "react/jsx-runtime";
var Hb = ({ children: e, className: o = "", style: t, title: r }) =>
    rS("div", {
      className: `dropdown-menu-group ${o}`,
      style: t,
      children: [r && oS("p", { className: "dropdown-menu-group-title", children: r }), e],
    }),
  da = Hb;
Hb.displayName = "DropdownMenuGroup";
import { useEffect as mS, useRef as pS } from "react";
import { THEME as uS } from "@excalidraw/common";
import { Fragment as iS, jsx as up, jsxs as aS } from "react/jsx-runtime";
var nS = ({ textStyle: e, icon: o, shortcut: t, children: r }) => {
    let n = ae();
    return aS(iS, {
      children: [
        o && up("div", { className: "dropdown-menu-item__icon", children: o }),
        up("div", { style: e, className: "dropdown-menu-item__text", children: r }),
        t &&
          !n.editor.isMobile &&
          up("div", { className: "dropdown-menu-item__shortcut", children: t }),
      ],
    });
  },
  Cs = nS;
import lS, { useContext as sS } from "react";
import { EVENT as cS, composeEventHandlers as dS } from "@excalidraw/common";
var hp = lS.createContext({}),
  Ss = (e = "", o = !1, t = !1) =>
    `dropdown-menu-item dropdown-menu-item-base ${e}
  ${o ? "dropdown-menu-item--selected" : ""} ${t ? "dropdown-menu-item--hovered" : ""}`.trim(),
  ks = (e, o) => {
    let t = sS(hp);
    return dS(e, (r) => {
      let n = new CustomEvent(cS.MENU_ITEM_SELECT, { bubbles: !0, cancelable: !0 });
      o?.(n), n.defaultPrevented || t.onSelect?.(n);
    });
  };
import { jsx as gp } from "react/jsx-runtime";
var fp = ({
  icon: e,
  value: o,
  order: t,
  children: r,
  shortcut: n,
  className: i,
  hovered: a,
  selected: l,
  textStyle: s,
  onSelect: d,
  onClick: m,
  ...c
}) => {
  let p = ks(m, d),
    u = pS(null);
  return (
    mS(() => {
      a &&
        (t === 0
          ? u.current?.scrollIntoView({ block: "end" })
          : u.current?.scrollIntoView({ block: "nearest" }));
    }, [a, t]),
    gp("button", {
      ...c,
      ref: u,
      value: o,
      onClick: p,
      className: Ss(i, l, a),
      title: c.title ?? c["aria-label"],
      children: gp(Cs, { textStyle: s, icon: e, shortcut: n, children: r }),
    })
  );
};
fp.displayName = "DropdownMenuItem";
var Un = { GREEN: "green", RED: "red", BLUE: "blue" },
  Ms = ({ type: e = Un.BLUE, children: o }) => {
    let { theme: t } = zt(),
      r = {
        display: "inline-flex",
        marginLeft: "auto",
        padding: "2px 4px",
        borderRadius: 6,
        fontSize: 9,
        fontFamily: "Cascadia, monospace",
        border: t === uS.LIGHT ? "1.5px solid white" : "none",
      };
    switch (e) {
      case Un.GREEN:
        Object.assign(r, {
          backgroundColor: "var(--background-color-badge)",
          color: "var(--color-badge)",
        });
        break;
      case Un.RED:
        Object.assign(r, { backgroundColor: "pink", color: "darkred" });
        break;
      case Un.BLUE:
      default:
        Object.assign(r, {
          background: "var(--color-promo)",
          color: "var(--color-surface-lowest)",
        });
    }
    return gp("div", { className: "DropDownMenuItemBadge", style: r, children: o });
  };
Ms.displayName = "DropdownMenuItemBadge";
fp.Badge = Ms;
var mt = fp;
import { KEYS as Yn } from "@excalidraw/common";
var Gb = ({
  event: e,
  inputRef: o,
  hoveredFont: t,
  filteredFonts: r,
  onClose: n,
  onSelect: i,
  onHover: a,
}) => {
  if (!e[Yn.CTRL_OR_CMD] && e.shiftKey && e.key.toLowerCase() === Yn.F)
    return o.current?.focus(), !0;
  if (e.key === Yn.ESCAPE) return n(), !0;
  if (e.key === Yn.ENTER) return t?.value && i(t.value), !0;
  if (e.key === Yn.ARROW_DOWN) return t?.next ? a(t.next.value) : r[0]?.value && a(r[0].value), !0;
  if (e.key === Yn.ARROW_UP)
    return t?.prev ? a(t.prev.value) : r[r.length - 1]?.value && a(r[r.length - 1].value), !0;
};
import { jsx as ma, jsxs as Ub } from "react/jsx-runtime";
var vS = (e) => {
    switch (e) {
      case Vr.Excalifont:
      case Vr.Virgil:
        return er;
      case Vr.Nunito:
      case Vr.Helvetica:
        return ea;
      case Vr["Lilita One"]:
        return M0;
      case Vr["Comic Shanns"]:
      case Vr.Cascadia:
        return Jl;
      default:
        return ea;
    }
  },
  Yb = hS.memo(
    ({
      selectedFontFamily: e,
      hoveredFontFamily: o,
      onSelect: t,
      onHover: r,
      onLeave: n,
      onOpen: i,
      onClose: a,
    }) => {
      let { container: l } = Ge(),
        { fonts: s } = Re(),
        { showDeprecatedFonts: d } = bo(),
        [m, c] = gS(""),
        p = fS(null),
        u = ar(
          () =>
            Array.from(qo.registered.entries())
              .filter(([k, { metadata: A }]) => !A.private && !A.fallback)
              .map(([k, { metadata: A, fontFaces: P }]) => {
                let N = { value: k, icon: vS(k), text: P[0]?.fontFace?.family ?? "Unknown" };
                return (
                  A.deprecated &&
                    Object.assign(N, {
                      deprecated: A.deprecated,
                      badge: { type: Un.RED, placeholder: g("fontList.badge.old") },
                    }),
                  N
                );
              })
              .sort((k, A) => (k.text.toLowerCase() > A.text.toLowerCase() ? 1 : -1)),
          []
        ),
        f = ar(() => new Set(s.getSceneFamilies()), [e]),
        b = ar(() => u.filter((k) => f.has(k.value)), [u, f]),
        x = ar(() => u.filter((k) => !f.has(k.value) && (d || !k.deprecated)), [u, f, d]),
        w = ar(() => ES([...b, ...x].filter((k) => k.text?.toLowerCase().includes(m))), [b, x, m]),
        E = ar(() => {
          let k;
          return (
            o ? (k = w.find((A) => A.value === o)) : e && (k = w.find((A) => A.value === e)),
            !k && m && (w[0]?.value ? r(w[0].value) : n()),
            k
          );
        }, [o, e, m, w, r, n]),
        y = xS(
          (k) => {
            Gb({
              event: k,
              inputRef: p,
              hoveredFont: E,
              filteredFonts: w,
              onSelect: t,
              onHover: r,
              onClose: a,
            }) && (k.preventDefault(), k.stopPropagation());
          },
          [E, w, t, r, a]
        );
      bS(
        () => (
          i(),
          () => {
            a();
          }
        ),
        []
      );
      let v = ar(() => w.filter((k) => f.has(k.value)), [w, f]),
        C = ar(() => w.filter((k) => !f.has(k.value)), [w, f]),
        S = (k, A) =>
          Ub(
            mt,
            {
              icon: k.icon,
              value: k.value,
              order: A,
              textStyle: { fontFamily: wS({ fontFamily: k.value }) },
              hovered: k.value === E?.value,
              selected: k.value === e,
              tabIndex: k.value === e ? 0 : -1,
              onClick: (P) => {
                t(Number(P.currentTarget.value));
              },
              onMouseMove: () => {
                E?.value !== k.value && r(k.value);
              },
              children: [
                k.text,
                k.badge && ma(Ms, { type: k.badge.type, children: k.badge.placeholder }),
              ],
            },
            k.value
          ),
        M = [];
      return (
        v.length &&
          M.push(ma(da, { title: g("fontList.sceneFonts"), children: v.map(S) }, "group_1")),
        C.length &&
          M.push(
            ma(
              da,
              {
                title: g("fontList.availableFonts"),
                children: C.map((k, A) => S(k, A + v.length)),
              },
              "group_2"
            )
          ),
        Ub(Es, {
          className: "properties-content",
          container: l,
          style: { width: "15rem" },
          onClose: a,
          onPointerLeave: n,
          onKeyDown: y,
          children: [
            ma(Ts, { ref: p, placeholder: g("quickSearch.placeholder"), onChange: yS(c, 20) }),
            ma(Is, {
              className: "dropdown-menu fonts manual-hover",
              placeholder: g("fontList.empty"),
              children: M.length ? M : null,
            }),
          ],
        })
      );
    },
    (e, o) =>
      e.selectedFontFamily === o.selectedFontFamily && e.hoveredFontFamily === o.hoveredFontFamily
  );
import * as Wb from "@radix-ui/react-popover";
import { useMemo as TS } from "react";
import { jsx as bp } from "react/jsx-runtime";
var Vb = ({ selectedFontFamily: e }) => {
  let o = TS(() => !!(e && !Xb(e)), [e]);
  return bp(Wb.Trigger, {
    asChild: !0,
    children: bp("div", {
      children: bp(Nn, {
        standalone: !0,
        icon: Sn,
        title: g("labels.showFonts"),
        className: "properties-trigger",
        testId: "font-family-show-fonts",
        active: o,
        onClick: () => {},
      }),
    }),
  });
};
import { jsx as pa, jsxs as Kb } from "react/jsx-runtime";
var $b = [
    {
      value: xp.Excalifont,
      icon: er,
      text: g("labels.handDrawn"),
      testId: "font-family-hand-drawn",
    },
    { value: xp.Nunito, icon: ea, text: g("labels.normal"), testId: "font-family-normal" },
    { value: xp["Comic Shanns"], icon: Jl, text: g("labels.code"), testId: "font-family-code" },
  ],
  kS = new Set($b.map((e) => e.value)),
  Xb = (e) => (e ? kS.has(e) : !1),
  jb = IS.memo(
    ({
      isOpened: e,
      selectedFontFamily: o,
      hoveredFontFamily: t,
      onSelect: r,
      onHover: n,
      onLeave: i,
      onPopupChange: a,
    }) => {
      let l = SS(() => $b, []),
        s = CS(
          (d) => {
            d && r(d);
          },
          [r]
        );
      return Kb("div", {
        role: "dialog",
        "aria-modal": "true",
        className: "FontPicker__container",
        children: [
          pa("div", {
            className: "buttonList",
            children: pa(Ft, { type: "button", options: l, value: o, onClick: s }),
          }),
          pa(fs, {}),
          Kb(Zb.Root, {
            open: e,
            onOpenChange: a,
            children: [
              pa(Vb, { selectedFontFamily: o }),
              e &&
                pa(Yb, {
                  selectedFontFamily: o,
                  hoveredFontFamily: t,
                  onSelect: s,
                  onHover: n,
                  onLeave: i,
                  onOpen: () => a(!0),
                  onClose: () => a(!1),
                }),
            ],
          }),
        ],
      });
    },
    (e, o) =>
      e.isOpened === o.isOpened &&
      e.selectedFontFamily === o.selectedFontFamily &&
      e.hoveredFontFamily === o.hoveredFontFamily
  );
import * as Wn from "@radix-ui/react-popover";
import AS from "clsx";
import Ls, { useEffect as DS } from "react";
import { isArrowKey as _S, KEYS as Ao } from "@excalidraw/common";
import { jsx as MS } from "react/jsx-runtime";
var lr = ({ icon: e }) =>
  MS("span", {
    style: {
      width: "1em",
      margin: "0 0.5ex 0 0.5ex",
      display: "inline-block",
      lineHeight: 0,
      verticalAlign: "middle",
    },
    children: e,
  });
import { Fragment as PS, jsx as qb, jsxs as Jb } from "react/jsx-runtime";
var LS = ({
    label: e,
    open: o,
    openTrigger: t,
    children: r,
    className: n,
    showCollapsedIcon: i = !0,
  }) =>
    Jb(PS, {
      children: [
        Jb("div", {
          style: {
            cursor: "pointer",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
          },
          className: n,
          onClick: t,
          children: [e, i && qb(lr, { icon: o ? lb : ls })],
        }),
        o && qb("div", { style: { display: "flex", flexDirection: "column" }, children: r }),
      ],
    }),
  ua = LS;
import { jsx as Xr, jsxs as Ep } from "react/jsx-runtime";
var RS = me(!1);
function NS({
  options: e,
  value: o,
  label: t,
  onChange: r,
  onClose: n,
  numberOfOptionsToAlwaysShow: i = e.length,
}) {
  let a = ae(),
    l = (u) => {
      let f = e.find((b) => b.keyBinding === u.key.toLowerCase());
      if (!(u.metaKey || u.altKey || u.ctrlKey) && f) r(f.value), u.preventDefault();
      else if (u.key === Ao.TAB) {
        let b = e.findIndex((w) => w.value === o),
          x = u.shiftKey ? (e.length + b - 1) % e.length : (b + 1) % e.length;
        r(e[x].value);
      } else if (_S(u.key)) {
        let b = Po().rtl,
          x = e.findIndex((w) => w.value === o);
        if (x !== -1) {
          let w = e.length,
            E = x;
          switch (u.key) {
            case b ? Ao.ARROW_LEFT : Ao.ARROW_RIGHT:
              E = (x + 1) % w;
              break;
            case b ? Ao.ARROW_RIGHT : Ao.ARROW_LEFT:
              E = (w + x - 1) % w;
              break;
            case Ao.ARROW_DOWN: {
              E = (x + (i ?? 1)) % w;
              break;
            }
            case Ao.ARROW_UP: {
              E = (w + x - (i ?? 1)) % w;
              break;
            }
          }
          r(e[E].value);
        }
        u.preventDefault();
      } else (u.key === Ao.ESCAPE || u.key === Ao.ENTER) && (u.preventDefault(), n());
      u.nativeEvent.stopImmediatePropagation(), u.stopPropagation();
    },
    [s, d] = ne(RS),
    m = Ls.useMemo(() => e.slice(0, i), [e, i]),
    c = Ls.useMemo(() => e.slice(i), [e, i]);
  DS(() => {
    m.some((u) => u.value === o) || d(!0);
  }, [o, m, d]);
  let p = (u) =>
    Xr("div", {
      className: "picker-content",
      children: u.map((f, b) =>
        Ep(
          "button",
          {
            type: "button",
            className: AS("picker-option", { active: o === f.value }),
            onClick: (x) => {
              r(f.value);
            },
            title: `${f.text} ${f.keyBinding && `\u2014 ${f.keyBinding.toUpperCase()}`}`,
            "aria-label": f.text || "none",
            "aria-keyshortcuts": f.keyBinding || void 0,
            ref: (x) => {
              o === f.value &&
                setTimeout(() => {
                  x?.focus();
                }, 0);
            },
            children: [
              f.icon,
              f.keyBinding &&
                Xr("span", { className: "picker-keybinding", children: f.keyBinding }),
            ],
          },
          f.text
        )
      ),
    });
  return Xr(Wn.Content, {
    side: a.editor.isMobile && !a.viewport.isLandscape ? "top" : "bottom",
    align: "start",
    sideOffset: 12,
    style: { zIndex: "var(--zIndex-popup)" },
    onKeyDown: l,
    children: Ep("div", {
      className: "picker",
      role: "dialog",
      "aria-modal": "true",
      "aria-label": t,
      children: [
        p(m),
        c.length > 0 &&
          Xr(ua, {
            label: g("labels.more_options"),
            open: s,
            openTrigger: () => {
              d((u) => !u);
            },
            className: "picker-collapsible",
            children: p(c),
          }),
      ],
    }),
  });
}
function yp({
  value: e,
  label: o,
  options: t,
  onChange: r,
  group: n = "",
  numberOfOptionsToAlwaysShow: i,
}) {
  let [a, l] = Ls.useState(!1),
    s = Ls.useRef(null);
  return Xr("div", {
    children: Ep(Wn.Root, {
      open: a,
      onOpenChange: (d) => l(d),
      children: [
        Xr(Wn.Trigger, {
          name: n,
          type: "button",
          "aria-label": o,
          onClick: () => l(!a),
          ref: s,
          className: a ? "active" : "",
          children: t.find((d) => d.value === e)?.icon,
        }),
        a &&
          Xr(NS, {
            options: t,
            value: e,
            label: o,
            onChange: r,
            onClose: () => {
              l(!1);
            },
            numberOfOptionsToAlwaysShow: i,
          }),
      ],
    }),
  });
}
import Qb, { useEffect as BS } from "react";
import { jsx as wp, jsxs as ex } from "react/jsx-runtime";
var tx = ({ updateData: e, app: o, testId: t }) => {
  let r = Qb.useRef(null),
    n = Qb.useRef(null),
    i = o.scene.getSelectedElements(o.state),
    a = !0,
    l = i.at(0),
    d =
      i.reduce(
        (m, c) => (
          m != null && m !== c.opacity && (a = !1), m == null || m > c.opacity ? c.opacity : m
        ),
        l?.opacity ?? null
      ) ?? o.state.currentItemOpacity;
  return (
    BS(() => {
      if (r.current && n.current) {
        let m = r.current,
          c = n.current,
          p = m.offsetWidth,
          u = 15,
          f = (d / 100) * (p - u) + u / 2;
        (c.style.left = `${f}px`),
          (m.style.background = `linear-gradient(to right, var(--color-slider-track) 0%, var(--color-slider-track) ${d}%, var(--button-bg) ${d}%, var(--button-bg) 100%)`);
      }
    }, [d]),
    ex("label", {
      className: "control-label",
      children: [
        g("labels.opacity"),
        ex("div", {
          className: "range-wrapper",
          children: [
            wp("input", {
              style: { "--color-slider-track": a ? void 0 : "var(--button-bg)" },
              ref: r,
              type: "range",
              min: "0",
              max: "100",
              step: "10",
              onChange: (m) => {
                e(+m.target.value);
              },
              value: d,
              className: "range-input",
              "data-testid": t,
            }),
            wp("div", { className: "value-bubble", ref: n, children: d !== 0 ? d : null }),
            wp("div", { className: "zero-label", children: "0" }),
          ],
        }),
      ],
    })
  );
};
import { Fragment as cx, jsx as Q, jsxs as yt } from "react/jsx-runtime";
var sx = 0.1,
  pt = (e, o, t, r = !1) => {
    let n = kp(Z(e, o, { includeBoundTextElement: r }));
    return e.map((i) => (n.get(i.id) || i.id === o.editingTextElement?.id ? t(i) : i));
  },
  Et = function (e, o, t, r, n) {
    let i = o.state.editingTextElement,
      a = ax(e),
      l = null;
    if ((i && (l = t(i)), !l))
      if (Ee(a, o.state)) {
        let d = o.scene.getSelectedElements(o.state),
          m = r === !0 ? d : d.filter((c) => r(c));
        l = JS(m, t) ?? (typeof n == "function" ? n(!0) : n);
      } else l = typeof n == "function" ? n(!1) : n;
    return l;
  },
  a4 = (e, o, t) =>
    t4(o) || !o.autoResize
      ? o
      : t.mutateElement(o, {
          x:
            e.textAlign === "left"
              ? e.x
              : e.x + (e.width - o.width) / (e.textAlign === "center" ? 2 : 1),
          y: e.y + (e.height - o.height) / 2,
        }),
  Mp = (e, o, t, r, n) => {
    let i = new Set(),
      a = pt(
        e,
        o,
        (l) => {
          if (xt(l)) {
            let s = r(l);
            i.add(s);
            let d = Ke(l, { fontSize: s });
            return ha(d, t.scene.getContainerElement(l), t.scene), (d = a4(l, d, t.scene)), d;
          }
          return l;
        },
        !0
      );
    return (
      Z(e, o, { includeBoundTextElement: !0 }).forEach((l) => {
        xt(l) && e4(l, t.scene);
      }),
      {
        elements: a,
        appState: {
          ...o,
          currentItemFontSize: i.size === 1 ? [...i][0] : n ?? o.currentItemFontSize,
        },
        captureUpdate: Ze.IMMEDIATELY,
      }
    );
  },
  l4 = B({
    name: "changeStrokeColor",
    label: "labels.stroke",
    trackEvent: !1,
    perform: (e, o, t) => ({
      ...(t.currentItemStrokeColor && {
        elements: pt(
          e,
          o,
          (r) => (r4(r.type) ? Ke(r, { strokeColor: t.currentItemStrokeColor }) : r),
          !0
        ),
      }),
      appState: { ...o, ...t },
      captureUpdate: t.currentItemStrokeColor ? Ze.IMMEDIATELY : Ze.EVENTUALLY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      yt(cx, {
        children: [
          Q("h3", { "aria-hidden": "true", children: g("labels.stroke") }),
          Q(ca, {
            topPicks: YS,
            palette: US,
            type: "elementStroke",
            label: g("labels.stroke"),
            color: Et(
              e,
              r,
              (n) => n.strokeColor,
              !0,
              (n) => (n ? null : o.currentItemStrokeColor)
            ),
            onChange: (n) => t({ currentItemStrokeColor: n }),
            elements: e,
            appState: o,
            updateData: t,
          }),
        ],
      }),
  }),
  s4 = B({
    name: "changeBackgroundColor",
    label: "labels.changeBackground",
    trackEvent: !1,
    perform: (e, o, t, r) => {
      if (!t.currentItemBackgroundColor)
        return { appState: { ...o, ...t }, captureUpdate: Ze.EVENTUALLY };
      let n,
        i = r.scene.getSelectedElements(o);
      if (!qS(t.currentItemBackgroundColor) && i.every((l) => nx(l) && QS(l.points))) {
        let l = kp(i);
        n = e.map((s) =>
          l.has(s.id) && nx(s)
            ? Ke(s, { backgroundColor: t.currentItemBackgroundColor, ...i4(s, !0) })
            : s
        );
      } else n = pt(e, o, (l) => Ke(l, { backgroundColor: t.currentItemBackgroundColor }));
      return { elements: n, appState: { ...o, ...t }, captureUpdate: Ze.IMMEDIATELY };
    },
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      yt(cx, {
        children: [
          Q("h3", { "aria-hidden": "true", children: g("labels.background") }),
          Q(ca, {
            topPicks: GS,
            palette: HS,
            type: "elementBackground",
            label: g("labels.background"),
            color: Et(
              e,
              r,
              (n) => n.backgroundColor,
              !0,
              (n) => (n ? null : o.currentItemBackgroundColor)
            ),
            onChange: (n) => t({ currentItemBackgroundColor: n }),
            elements: e,
            appState: o,
            updateData: t,
          }),
        ],
      }),
  }),
  c4 = B({
    name: "changeFillStyle",
    label: "labels.fill",
    trackEvent: !1,
    perform: (e, o, t, r) => (
      re("element", "changeFillStyle", `${t} (${r.device.editor.isMobile ? "mobile" : "desktop"})`),
      {
        elements: pt(e, o, (n) => Ke(n, { fillStyle: t })),
        appState: { ...o, currentItemFillStyle: t },
        captureUpdate: Ze.IMMEDIATELY,
      }
    ),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) => {
      let n = Z(e, o),
        i = n.length > 0 && n.every((a) => a.fillStyle === "zigzag");
      return yt("fieldset", {
        children: [
          Q("legend", { children: g("labels.fill") }),
          Q("div", {
            className: "buttonList",
            children: Q(Ft, {
              type: "button",
              options: [
                {
                  value: "hachure",
                  text: `${i ? g("labels.zigzag") : g("labels.hachure")} (${$S("Alt-Click")})`,
                  icon: i ? Q1 : e0,
                  active: i ? !0 : void 0,
                  testId: "fill-hachure",
                },
                {
                  value: "cross-hatch",
                  text: g("labels.crossHatch"),
                  icon: t0,
                  testId: "fill-cross-hatch",
                },
                { value: "solid", text: g("labels.solid"), icon: o0, testId: "fill-solid" },
              ],
              value: Et(
                e,
                r,
                (a) => a.fillStyle,
                (a) => a.hasOwnProperty("fillStyle"),
                (a) => (a ? null : o.currentItemFillStyle)
              ),
              onClick: (a, l) => {
                let s =
                  l.altKey && a === "hachure" && n.every((d) => d.fillStyle === "hachure")
                    ? "zigzag"
                    : a;
                t(s);
              },
            }),
          }),
        ],
      });
    },
  }),
  d4 = B({
    name: "changeStrokeWidth",
    label: "labels.strokeWidth",
    trackEvent: !1,
    perform: (e, o, t) => ({
      elements: pt(e, o, (r) => Ke(r, { strokeWidth: t })),
      appState: { ...o, currentItemStrokeWidth: t },
      captureUpdate: Ze.IMMEDIATELY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      yt("fieldset", {
        children: [
          Q("legend", { children: g("labels.strokeWidth") }),
          Q("div", {
            className: "buttonList",
            children: Q(Ft, {
              group: "stroke-width",
              options: [
                { value: Ip.thin, text: g("labels.thin"), icon: zm, testId: "strokeWidth-thin" },
                { value: Ip.bold, text: g("labels.bold"), icon: r0, testId: "strokeWidth-bold" },
                {
                  value: Ip.extraBold,
                  text: g("labels.extraBold"),
                  icon: n0,
                  testId: "strokeWidth-extraBold",
                },
              ],
              value: Et(
                e,
                r,
                (n) => n.strokeWidth,
                (n) => n.hasOwnProperty("strokeWidth"),
                (n) => (n ? null : o.currentItemStrokeWidth)
              ),
              onChange: (n) => t(n),
            }),
          }),
        ],
      }),
  }),
  m4 = B({
    name: "changeSloppiness",
    label: "labels.sloppiness",
    trackEvent: !1,
    perform: (e, o, t) => ({
      elements: pt(e, o, (r) => Ke(r, { seed: KS(), roughness: t })),
      appState: { ...o, currentItemRoughness: t },
      captureUpdate: Ze.IMMEDIATELY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      yt("fieldset", {
        children: [
          Q("legend", { children: g("labels.sloppiness") }),
          Q("div", {
            className: "buttonList",
            children: Q(Ft, {
              group: "sloppiness",
              options: [
                { value: 0, text: g("labels.architect"), icon: l0 },
                { value: 1, text: g("labels.artist"), icon: s0 },
                { value: 2, text: g("labels.cartoonist"), icon: c0 },
              ],
              value: Et(
                e,
                r,
                (n) => n.roughness,
                (n) => n.hasOwnProperty("roughness"),
                (n) => (n ? null : o.currentItemRoughness)
              ),
              onChange: (n) => t(n),
            }),
          }),
        ],
      }),
  }),
  v$ = B({
    name: "changeStrokeStyle",
    label: "labels.strokeStyle",
    trackEvent: !1,
    perform: (e, o, t) => ({
      elements: pt(e, o, (r) => Ke(r, { strokeStyle: t })),
      appState: { ...o, currentItemStrokeStyle: t },
      captureUpdate: Ze.IMMEDIATELY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      yt("fieldset", {
        children: [
          Q("legend", { children: g("labels.strokeStyle") }),
          Q("div", {
            className: "buttonList",
            children: Q(Ft, {
              group: "strokeStyle",
              options: [
                { value: "solid", text: g("labels.strokeStyle_solid"), icon: zm },
                { value: "dashed", text: g("labels.strokeStyle_dashed"), icon: i0 },
                { value: "dotted", text: g("labels.strokeStyle_dotted"), icon: a0 },
              ],
              value: Et(
                e,
                r,
                (n) => n.strokeStyle,
                (n) => n.hasOwnProperty("strokeStyle"),
                (n) => (n ? null : o.currentItemStrokeStyle)
              ),
              onChange: (n) => t(n),
            }),
          }),
        ],
      }),
  }),
  p4 = B({
    name: "changeOpacity",
    label: "labels.opacity",
    trackEvent: !1,
    perform: (e, o, t) => ({
      elements: pt(e, o, (r) => Ke(r, { opacity: t }), !0),
      appState: { ...o, currentItemOpacity: t },
      captureUpdate: Ze.IMMEDIATELY,
    }),
    PanelComponent: ({ app: e, updateData: o }) =>
      Q(tx, { updateData: o, app: e, testId: "opacity" }),
  }),
  u4 = B({
    name: "changeFontSize",
    label: "labels.fontSize",
    trackEvent: !1,
    perform: (e, o, t, r) => Mp(e, o, r, () => t, t),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      yt("fieldset", {
        children: [
          Q("legend", { children: g("labels.fontSize") }),
          Q("div", {
            className: "buttonList",
            children: Q(Ft, {
              group: "font-size",
              options: [
                { value: 16, text: g("labels.small"), icon: I0, testId: "fontSize-small" },
                { value: 20, text: g("labels.medium"), icon: C0, testId: "fontSize-medium" },
                { value: 28, text: g("labels.large"), icon: S0, testId: "fontSize-large" },
                { value: 36, text: g("labels.veryLarge"), icon: k0, testId: "fontSize-veryLarge" },
              ],
              value: Et(
                e,
                r,
                (n) => {
                  if (xt(n)) return n.fontSize;
                  let i = sr(n, r.scene.getNonDeletedElementsMap());
                  return i ? i.fontSize : null;
                },
                (n) => xt(n) || sr(n, r.scene.getNonDeletedElementsMap()) !== null,
                (n) => (n ? null : o.currentItemFontSize || VS)
              ),
              onChange: (n) => t(n),
            }),
          }),
        ],
      }),
  }),
  Lp = B({
    name: "decreaseFontSize",
    label: "labels.decreaseFontSize",
    icon: Ur,
    trackEvent: !1,
    perform: (e, o, t, r) => Mp(e, o, r, (n) => Math.round((1 / (1 + sx)) * n.fontSize)),
    keyTest: (e) =>
      e[Vn.CTRL_OR_CMD] && e.shiftKey && (e.key === Vn.CHEVRON_LEFT || e.key === Vn.COMMA),
  }),
  Pp = B({
    name: "increaseFontSize",
    label: "labels.increaseFontSize",
    icon: Ur,
    trackEvent: !1,
    perform: (e, o, t, r) => Mp(e, o, r, (n) => Math.round(n.fontSize * (1 + sx))),
    keyTest: (e) =>
      e[Vn.CTRL_OR_CMD] && e.shiftKey && (e.key === Vn.CHEVRON_RIGHT || e.key === Vn.PERIOD),
  }),
  h4 = B({
    name: "changeFontFamily",
    label: "labels.fontFamily",
    trackEvent: !1,
    perform: (e, o, t, r) => {
      let { cachedElements: n, resetAll: i, resetContainers: a, ...l } = t;
      if (i)
        return {
          elements: pt(
            e,
            o,
            (b) => {
              let x = n?.get(b.id);
              return x ? Ke(b, { ...x }) : b;
            },
            !0
          ),
          appState: { ...o, ...l },
          captureUpdate: Ze.NEVER,
        };
      let { currentItemFontFamily: s, currentHoveredFontFamily: d } = t,
        m = Ze.EVENTUALLY,
        c,
        p = !1;
      if (s) (c = s), (m = Ze.IMMEDIATELY);
      else if (d) {
        (c = d), (m = Ze.EVENTUALLY);
        let f = Z(e, o, { includeBoundTextElement: !0 }).filter((b) => xt(b));
        if (f.length > 200) p = !0;
        else {
          let b = 0,
            x = 0;
          for (; b < f.length && x < 5e3; ) {
            let w = f[b];
            (x += w?.originalText.length || 0), b++;
          }
          x > 5e3 && (p = !0);
        }
      }
      let u = { appState: { ...o, ...l }, captureUpdate: m };
      if (c && !p) {
        let f = new Map(),
          b = new Set(),
          x = !1,
          w = Array.from(qo.loadedFontsCache.values()),
          E = Object.entries(XS).find(([C, S]) => S === c)?.[0];
        d && E && w.some((C) => C.startsWith(E)) && (x = !0),
          Object.assign(u, {
            elements: pt(
              e,
              o,
              (C) => {
                if (xt(C) && (C.fontFamily !== c || s)) {
                  let S = Ke(C, { fontFamily: c, lineHeight: jS(c) }),
                    M = n?.get(C.containerId || "") || {},
                    k = r.scene.getContainerElement(C);
                  return (
                    a && k && M && r.scene.mutateElement(k, { ...M }),
                    x || (b = new Set([...b, ...Array.from(S.originalText)])),
                    f.set(S, k),
                    S
                  );
                }
                return C;
              },
              !0
            ),
          });
        let y = `10px ${ZS({ fontFamily: c })}`,
          v = Array.from(b.values()).join();
        if (x || window.document.fonts.check(y, v)) for (let [C, S] of f) ha(C, S, r.scene);
        else
          window.document.fonts.load(y, v).then((C) => {
            for (let [S, M] of f) {
              let k = r.scene.getElement(S.id),
                A = M ? r.scene.getElement(M.id) : null;
              k && ha(k, A, r.scene);
            }
            r.fonts.onLoaded(C);
          });
      }
      return u;
    },
    PanelComponent: ({ elements: e, appState: o, app: t, updateData: r }) => {
      let n = Tp(new Map()),
        i = Tp(null),
        [a, l] = zS({}),
        s = Tp(!0),
        d = OS(() => {
          let m = (c, p) =>
            Et(
              c,
              t,
              (u) => {
                if (xt(u)) return u.fontFamily;
                let f = sr(u, p);
                return f ? f.fontFamily : null;
              },
              (u) => xt(u) || sr(u, p) !== null,
              (u) => (u ? null : o.currentItemFontFamily || WS)
            );
          return a.openPopup === "fontFamily" && o.openPopup === "fontFamily"
            ? m(Array.from(n.current?.values() ?? []), n.current)
            : !a.openPopup && o.openPopup !== "fontFamily"
            ? m(e, t.scene.getNonDeletedElementsMap())
            : i.current;
        }, [a.openPopup, o, e, t]);
      return (
        vp(() => {
          i.current = d;
        }, [d]),
        vp(() => {
          Object.keys(a).length && (r(a), l({}));
        }, [a]),
        vp(
          () => (
            (s.current = !1),
            () => {
              s.current = !0;
            }
          ),
          []
        ),
        yt("fieldset", {
          children: [
            Q("legend", { children: g("labels.fontFamily") }),
            Q(jb, {
              isOpened: o.openPopup === "fontFamily",
              selectedFontFamily: d,
              hoveredFontFamily: o.currentHoveredFontFamily,
              onSelect: (m) => {
                l({ openPopup: null, currentHoveredFontFamily: null, currentItemFontFamily: m }),
                  n.current.clear();
              },
              onHover: (m) => {
                l({
                  currentHoveredFontFamily: m,
                  cachedElements: new Map(n.current),
                  resetContainers: !0,
                });
              },
              onLeave: () => {
                l({
                  currentHoveredFontFamily: null,
                  cachedElements: new Map(n.current),
                  resetAll: !0,
                });
              },
              onPopupChange: (m) => {
                if (m) {
                  n.current.clear();
                  let { editingTextElement: c } = o;
                  if (c?.type === "text") {
                    let p = t.scene.getElement(c.id);
                    n.current.set(c.id, Ke(p || c, {}, !0));
                  } else {
                    let p = Z(e, o, { includeBoundTextElement: !0 });
                    for (let u of p) n.current.set(u.id, Ke(u, {}, !0));
                  }
                  l({ openPopup: "fontFamily" });
                } else {
                  let c = {
                    openPopup: null,
                    currentHoveredFontFamily: null,
                    cachedElements: new Map(n.current),
                    resetAll: !0,
                  };
                  s.current ? r({ ...a, ...c }) : l(c), n.current.clear();
                }
              },
            }),
          ],
        })
      );
    },
  }),
  g4 = B({
    name: "changeTextAlign",
    label: "Change text alignment",
    trackEvent: !1,
    perform: (e, o, t, r) => ({
      elements: pt(
        e,
        o,
        (n) => {
          if (xt(n)) {
            let i = Ke(n, { textAlign: t });
            return ha(i, r.scene.getContainerElement(n), r.scene), i;
          }
          return n;
        },
        !0
      ),
      appState: { ...o, currentItemTextAlign: t },
      captureUpdate: Ze.IMMEDIATELY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) => {
      let n = r.scene.getNonDeletedElementsMap();
      return yt("fieldset", {
        children: [
          Q("legend", { children: g("labels.textAlign") }),
          Q("div", {
            className: "buttonList",
            children: Q(Ft, {
              group: "text-align",
              options: [
                { value: "left", text: g("labels.left"), icon: L0, testId: "align-left" },
                {
                  value: "center",
                  text: g("labels.center"),
                  icon: P0,
                  testId: "align-horizontal-center",
                },
                { value: "right", text: g("labels.right"), icon: A0, testId: "align-right" },
              ],
              value: Et(
                e,
                r,
                (i) => {
                  if (xt(i)) return i.textAlign;
                  let a = sr(i, n);
                  return a ? a.textAlign : null;
                },
                (i) => xt(i) || sr(i, n) !== null,
                (i) => (i ? null : o.currentItemTextAlign)
              ),
              onChange: (i) => t(i),
            }),
          }),
        ],
      });
    },
  }),
  f4 = B({
    name: "changeVerticalAlign",
    label: "Change vertical alignment",
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => ({
      elements: pt(
        e,
        o,
        (n) => {
          if (xt(n)) {
            let i = Ke(n, { verticalAlign: t });
            return ha(i, r.scene.getContainerElement(n), r.scene), i;
          }
          return n;
        },
        !0
      ),
      appState: { ...o },
      captureUpdate: Ze.IMMEDIATELY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      Q("fieldset", {
        children: Q("div", {
          className: "buttonList",
          children: Q(Ft, {
            group: "text-align",
            options: [
              {
                value: Ps.TOP,
                text: g("labels.alignTop"),
                icon: Q(D0, { theme: o.theme }),
                testId: "align-top",
              },
              {
                value: Ps.MIDDLE,
                text: g("labels.centerVertically"),
                icon: Q(R0, { theme: o.theme }),
                testId: "align-middle",
              },
              {
                value: Ps.BOTTOM,
                text: g("labels.alignBottom"),
                icon: Q(_0, { theme: o.theme }),
                testId: "align-bottom",
              },
            ],
            value: Et(
              e,
              r,
              (n) => {
                if (xt(n) && n.containerId) return n.verticalAlign;
                let i = sr(n, r.scene.getNonDeletedElementsMap());
                return i ? i.verticalAlign : null;
              },
              (n) => xt(n) || sr(n, r.scene.getNonDeletedElementsMap()) !== null,
              (n) => (n ? null : Ps.MIDDLE)
            ),
            onChange: (n) => t(n),
          }),
        }),
      }),
  }),
  T$ = B({
    name: "changeRoundness",
    label: "Change edge roundness",
    trackEvent: !1,
    perform: (e, o, t) => ({
      elements: pt(e, o, (r) =>
        lx(r)
          ? r
          : Ke(r, {
              roundness:
                t === "round"
                  ? { type: o4(r.type) ? As.ADAPTIVE_RADIUS : As.PROPORTIONAL_RADIUS }
                  : null,
            })
      ),
      appState: { ...o, currentItemRoundness: t },
      captureUpdate: Ze.IMMEDIATELY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r, renderAction: n }) => {
      let a = Ml(ax(e), o).some((l) => l.roundness?.type === As.LEGACY);
      return yt("fieldset", {
        children: [
          Q("legend", { children: g("labels.edges") }),
          yt("div", {
            className: "buttonList",
            children: [
              Q(Ft, {
                group: "edges",
                options: [
                  { value: "sharp", text: g("labels.sharp"), icon: d0 },
                  { value: "round", text: g("labels.round"), icon: m0 },
                ],
                value: Et(
                  e,
                  r,
                  (l) => (a ? null : l.roundness ? "round" : "sharp"),
                  (l) => !Ds(l) && l.hasOwnProperty("roundness"),
                  (l) => (l ? null : o.currentItemRoundness)
                ),
                onChange: (l) => t(l),
              }),
              n("togglePolygon"),
            ],
          }),
        ],
      });
    },
  }),
  ix = (e) => [
    { value: null, text: g("labels.arrowhead_none"), keyBinding: "q", icon: p0 },
    {
      value: "arrow",
      text: g("labels.arrowhead_arrow"),
      keyBinding: "w",
      icon: Q(u0, { flip: e }),
    },
    {
      value: "triangle",
      text: g("labels.arrowhead_triangle"),
      icon: Q(b0, { flip: e }),
      keyBinding: "e",
    },
    {
      value: "triangle_outline",
      text: g("labels.arrowhead_triangle_outline"),
      icon: Q(x0, { flip: e }),
      keyBinding: "r",
    },
    {
      value: "circle",
      text: g("labels.arrowhead_circle"),
      keyBinding: "a",
      icon: Q(h0, { flip: e }),
    },
    {
      value: "circle_outline",
      text: g("labels.arrowhead_circle_outline"),
      keyBinding: "s",
      icon: Q(g0, { flip: e }),
    },
    {
      value: "diamond",
      text: g("labels.arrowhead_diamond"),
      icon: Q(E0, { flip: e }),
      keyBinding: "d",
    },
    {
      value: "diamond_outline",
      text: g("labels.arrowhead_diamond_outline"),
      icon: Q(y0, { flip: e }),
      keyBinding: "f",
    },
    { value: "bar", text: g("labels.arrowhead_bar"), keyBinding: "z", icon: Q(f0, { flip: e }) },
    {
      value: "crowfoot_one",
      text: g("labels.arrowhead_crowfoot_one"),
      icon: Q(v0, { flip: e }),
      keyBinding: "x",
    },
    {
      value: "crowfoot_many",
      text: g("labels.arrowhead_crowfoot_many"),
      icon: Q(w0, { flip: e }),
      keyBinding: "c",
    },
    {
      value: "crowfoot_one_or_many",
      text: g("labels.arrowhead_crowfoot_one_or_many"),
      icon: Q(T0, { flip: e }),
      keyBinding: "v",
    },
  ],
  I$ = B({
    name: "changeArrowhead",
    label: "Change arrowheads",
    trackEvent: !1,
    perform: (e, o, t) => ({
      elements: pt(e, o, (r) => {
        if (Sp(r)) {
          let { position: n, type: i } = t;
          if (n === "start") return Ke(r, { startArrowhead: i });
          if (n === "end") return Ke(r, { endArrowhead: i });
        }
        return r;
      }),
      appState: {
        ...o,
        [t.position === "start" ? "currentItemStartArrowhead" : "currentItemEndArrowhead"]: t.type,
      },
      captureUpdate: Ze.IMMEDIATELY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) => {
      let n = Po().rtl;
      return yt("fieldset", {
        children: [
          Q("legend", { children: g("labels.arrowheads") }),
          yt("div", {
            className: "iconSelectList buttonList",
            children: [
              Q(yp, {
                label: "arrowhead_start",
                options: ix(!n),
                value: Et(
                  e,
                  r,
                  (i) => (Sp(i) && bn(i.type) ? i.startArrowhead : o.currentItemStartArrowhead),
                  !0,
                  o.currentItemStartArrowhead
                ),
                onChange: (i) => t({ position: "start", type: i }),
                numberOfOptionsToAlwaysShow: 4,
              }),
              Q(yp, {
                label: "arrowhead_end",
                group: "arrowheads",
                options: ix(!!n),
                value: Et(
                  e,
                  r,
                  (i) => (Sp(i) && bn(i.type) ? i.endArrowhead : o.currentItemEndArrowhead),
                  !0,
                  o.currentItemEndArrowhead
                ),
                onChange: (i) => t({ position: "end", type: i }),
                numberOfOptionsToAlwaysShow: 4,
              }),
            ],
          }),
        ],
      });
    },
  }),
  C$ = B({
    name: "changeArrowType",
    label: "Change arrow types",
    trackEvent: !1,
    perform: (e, o, t, r) => {
      let n = pt(e, o, (l) => {
          if (!Ds(l)) return l;
          let s = Ke(l, {
            roundness: t === Do.round ? { type: As.PROPORTIONAL_RADIUS } : null,
            elbowed: t === Do.elbow,
            points:
              t === Do.elbow || l.elbowed ? [l.points[0], l.points[l.points.length - 1]] : l.points,
          });
          if (lx(s)) {
            s.fixedSegments = null;
            let d = r.scene.getNonDeletedElementsMap();
            r.dismissLinearEditor();
            let m = Cp.getPointAtIndexGlobalCoordinates(s, 0, d),
              c = Cp.getPointAtIndexGlobalCoordinates(s, -1, d),
              p = s.startBinding && d.get(s.startBinding.elementId),
              u = s.endBinding && d.get(s.endBinding.elementId),
              f = p && s.startBinding ? { ...s.startBinding, ...rx(s, p, "start", d) } : null,
              b = u && s.endBinding ? { ...s.endBinding, ...rx(s, u, "end", d) } : null;
            s = {
              ...s,
              startBinding: f,
              endBinding: b,
              ...n4(s, d, {
                points: [m, c].map((x) => FS(x[0] - s.x, x[1] - s.y)),
                startBinding: f,
                endBinding: b,
                fixedSegments: null,
              }),
            };
          } else {
            let d = r.scene.getNonDeletedElementsMap();
            if (s.startBinding) {
              let m = d.get(s.startBinding.elementId);
              m && ox(s, m, "start", r.scene);
            }
            if (s.endBinding) {
              let m = d.get(s.endBinding.elementId);
              m && ox(s, m, "end", r.scene);
            }
          }
          return s;
        }),
        i = { ...o, currentItemArrowType: t },
        a = o.selectedLinearElement?.elementId;
      if (a) {
        let l = n.find((s) => s.id === a);
        l && (i.selectedLinearElement = new Cp(l, kp(e)));
      }
      return { elements: n, appState: i, captureUpdate: Ze.IMMEDIATELY };
    },
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      yt("fieldset", {
        children: [
          Q("legend", { children: g("labels.arrowtypes") }),
          Q("div", {
            className: "buttonList",
            children: Q(Ft, {
              group: "arrowtypes",
              options: [
                {
                  value: Do.sharp,
                  text: g("labels.arrowtype_sharp"),
                  icon: ns,
                  testId: "sharp-arrow",
                },
                {
                  value: Do.round,
                  text: g("labels.arrowtype_round"),
                  icon: as,
                  testId: "round-arrow",
                },
                {
                  value: Do.elbow,
                  text: g("labels.arrowtype_elbowed"),
                  icon: is,
                  testId: "elbow-arrow",
                },
              ],
              value: Et(
                e,
                r,
                (n) => (Ds(n) ? (n.elbowed ? Do.elbow : n.roundness ? Do.round : Do.sharp) : null),
                (n) => Ds(n),
                (n) => (n ? null : o.currentItemArrowType)
              ),
              onChange: (n) => t(n),
            }),
          }),
        ],
      }),
  });
import { clamp as Np, roundToStep as T4 } from "@excalidraw/math";
import {
  DEFAULT_CANVAS_BACKGROUND_PICKS as I4,
  CURSOR_TYPE as hx,
  MAX_ZOOM as gx,
  MIN_ZOOM as fx,
  THEME as ga,
  ZOOM_STEP as Bp,
  getShortcutKey as bx,
  updateActiveTool as Kn,
  CODES as Eo,
  KEYS as Ro,
} from "@excalidraw/common";
import { getNonDeletedElements as C4 } from "@excalidraw/element";
import { newElementWith as S4 } from "@excalidraw/element";
import { getCommonBounds as k4 } from "@excalidraw/element";
import { CaptureUpdateAction as eo } from "@excalidraw/element";
import { useEffect as b4 } from "react";
import { jsx as E4 } from "react/jsx-runtime";
var Xn = () => {
    let e = document.querySelector(".excalidraw-tooltip");
    if (e) return e;
    let o = document.createElement("div");
    return document.body.appendChild(o), o.classList.add("excalidraw-tooltip"), o;
  },
  Ap = (e, o, t = "bottom") => {
    let r = e.getBoundingClientRect(),
      n = window.innerWidth,
      i = window.innerHeight,
      a = 5,
      l = o.left + o.width / 2 - r.width / 2;
    l < 0 ? (l = a) : l + r.width >= n && (l = n - r.width - a);
    let s;
    t === "bottom"
      ? ((s = o.top + o.height + a), s + r.height >= i && (s = o.top - r.height - a))
      : ((s = o.top - r.height - a), s < 0 && (s = o.top + o.height + a)),
      Object.assign(e.style, { top: `${s}px`, left: `${l}px` });
  },
  x4 = (e, o, t, r) => {
    o.classList.add("excalidraw-tooltip--visible"),
      (o.style.minWidth = r ? "50ch" : "10ch"),
      (o.style.maxWidth = r ? "50ch" : "15ch"),
      (o.textContent = t);
    let n = e.getBoundingClientRect();
    Ap(o, n);
  },
  Lt = ({ children: e, label: o, long: t = !1, style: r, disabled: n }) => (
    b4(() => () => Xn().classList.remove("excalidraw-tooltip--visible"), []),
    n
      ? null
      : E4("div", {
          className: "excalidraw-tooltip-wrapper",
          onPointerEnter: (i) => x4(i.currentTarget, Xn(), o, t),
          onPointerLeave: () => Xn().classList.remove("excalidraw-tooltip--visible"),
          style: r,
          children: e,
        })
  );
import _s from "open-color";
import { CURSOR_TYPE as Dp, MIME_TYPES as _p, THEME as mx } from "@excalidraw/common";
var px =
    '<svg viewBox="0 0 24 24" stroke-width="1" width="28" height="28" xmlns="http://www.w3.org/2000/svg">',
  y4 =
    '<path d="M6.164 11.755a5.314 5.314 0 0 1-4.932-5.298 5.314 5.314 0 0 1 5.311-5.311 5.314 5.314 0 0 1 5.307 5.113l8.773 8.773a3.322 3.322 0 0 1 0 4.696l-.895.895a3.322 3.322 0 0 1-4.696 0l-8.868-8.868Z" style="fill:#fff"/>',
  ux =
    '<path stroke="#1b1b1f" fill="#fff" d="m7.868 11.113 7.773 7.774a2.359 2.359 0 0 0 1.667.691 2.368 2.368 0 0 0 2.357-2.358c0-.625-.248-1.225-.69-1.667L11.201 7.78 9.558 9.469l-1.69 1.643v.001Zm10.273 3.606-3.333 3.333m-3.25-6.583 2 2m-7-7 3 3M3.664 3.625l1 1M2.529 6.922l1.407-.144m5.735-2.932-1.118.866M4.285 9.823l.758-1.194m1.863-6.207-.13 1.408"/>',
  w4 = `data:${_p.svg},${encodeURIComponent(`${px}${ux}</svg>`)}`,
  v4 = `data:${_p.svg},${encodeURIComponent(`${px}${y4}${ux}</svg>`)}`,
  Ht = (e) => {
    e && (e.style.cursor = "");
  },
  xe = (e, o) => {
    e && (e.style.cursor = o);
  },
  xo,
  dx,
  Rp = (e, o) => {
    let r = () => {
      let n = o === mx.DARK;
      (xo = document.createElement("canvas")), (xo.theme = o), (xo.height = 20), (xo.width = 20);
      let i = xo.getContext("2d");
      (i.lineWidth = 1),
        i.beginPath(),
        i.arc(xo.width / 2, xo.height / 2, 5, 0, 2 * Math.PI),
        (i.fillStyle = n ? _s.black : _s.white),
        i.fill(),
        (i.strokeStyle = n ? _s.white : _s.black),
        i.stroke(),
        (dx = xo.toDataURL(_p.svg));
    };
    (!xo || xo.theme !== o) && r(), xe(e, `url(${dx}) ${20 / 2} ${20 / 2}, auto`);
  },
  Pt = (e, o) => {
    if (e)
      if (o.activeTool.type === "selection") Ht(e);
      else if (qt(o)) e.style.cursor = Dp.GRAB;
      else if (bt(o)) Rp(e, o.theme);
      else if (o.activeTool.type === "laser") {
        let t = o.theme === mx.LIGHT ? w4 : v4;
        e.style.cursor = `url(${t}), auto`;
      } else
        ["image", "custom"].includes(o.activeTool.type)
          ? o.activeTool.type !== "image" && (e.style.cursor = Dp.AUTO)
          : (e.style.cursor = Dp.CROSSHAIR);
  };
var _o = ({ viewportX: e, viewportY: o, nextZoom: t }, r) => {
  let n = e - r.offsetLeft,
    i = o - r.offsetTop,
    a = r.zoom.value,
    l = r.scrollX + (n - n / a),
    s = r.scrollY + (i - i / a),
    d = -(n - n / t),
    m = -(i - i / t);
  return { scrollX: l + d, scrollY: s + m, zoom: { value: t } };
};
import { jsx as Fs, jsxs as A4 } from "react/jsx-runtime";
var M4 = B({
    name: "changeViewBackgroundColor",
    label: "labels.canvasBackground",
    trackEvent: !1,
    predicate: (e, o, t, r) =>
      !!r.props.UIOptions.canvasActions.changeViewBackgroundColor && !o.viewModeEnabled,
    perform: (e, o, t) => ({
      appState: { ...o, ...t },
      captureUpdate: t.viewBackgroundColor ? eo.IMMEDIATELY : eo.EVENTUALLY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, appProps: r }) =>
      Fs(ca, {
        palette: null,
        topPicks: I4,
        label: g("labels.canvasBackground"),
        type: "canvasBackground",
        color: o.viewBackgroundColor,
        onChange: (n) => t({ viewBackgroundColor: n }),
        "data-testid": "canvas-background-picker",
        elements: e,
        appState: o,
        updateData: t,
      }),
  }),
  No = B({
    name: "clearCanvas",
    label: "labels.clearCanvas",
    icon: kt,
    trackEvent: { category: "canvas" },
    predicate: (e, o, t, r) =>
      !!r.props.UIOptions.canvasActions.clearCanvas &&
      !o.viewModeEnabled &&
      o.openDialog?.name !== "elementLinkSelector",
    perform: (e, o, t, r) => (
      r.imageCache.clear(),
      {
        elements: e.map((n) => S4(n, { isDeleted: !0 })),
        appState: {
          ...Jo(),
          files: {},
          theme: o.theme,
          penMode: o.penMode,
          penDetected: o.penDetected,
          exportBackground: o.exportBackground,
          exportEmbedScene: o.exportEmbedScene,
          gridSize: o.gridSize,
          gridStep: o.gridStep,
          gridModeEnabled: o.gridModeEnabled,
          stats: o.stats,
          pasteDialog: o.pasteDialog,
          activeTool:
            o.activeTool.type === "image" ? { ...o.activeTool, type: "selection" } : o.activeTool,
        },
        captureUpdate: eo.IMMEDIATELY,
      }
    ),
  }),
  Rs = B({
    name: "zoomIn",
    label: "buttons.zoomIn",
    viewMode: !0,
    icon: wm,
    trackEvent: { category: "canvas" },
    perform: (e, o, t, r) => ({
      appState: {
        ...o,
        ..._o(
          {
            viewportX: o.width / 2 + o.offsetLeft,
            viewportY: o.height / 2 + o.offsetTop,
            nextZoom: go(o.zoom.value + Bp),
          },
          o
        ),
        userToFollow: null,
      },
      captureUpdate: eo.EVENTUALLY,
    }),
    PanelComponent: ({ updateData: e, appState: o }) =>
      Fs(V, {
        type: "button",
        className: "zoom-in-button zoom-button",
        icon: wm,
        title: `${g("buttons.zoomIn")} \u2014 ${bx("CtrlOrCmd++")}`,
        "aria-label": g("buttons.zoomIn"),
        disabled: o.zoom.value >= gx,
        onClick: () => {
          e(null);
        },
      }),
    keyTest: (e) =>
      (e.code === Eo.EQUAL || e.code === Eo.NUM_ADD) && (e[Ro.CTRL_OR_CMD] || e.shiftKey),
  }),
  Ns = B({
    name: "zoomOut",
    label: "buttons.zoomOut",
    icon: vm,
    viewMode: !0,
    trackEvent: { category: "canvas" },
    perform: (e, o, t, r) => ({
      appState: {
        ...o,
        ..._o(
          {
            viewportX: o.width / 2 + o.offsetLeft,
            viewportY: o.height / 2 + o.offsetTop,
            nextZoom: go(o.zoom.value - Bp),
          },
          o
        ),
        userToFollow: null,
      },
      captureUpdate: eo.EVENTUALLY,
    }),
    PanelComponent: ({ updateData: e, appState: o }) =>
      Fs(V, {
        type: "button",
        className: "zoom-out-button zoom-button",
        icon: vm,
        title: `${g("buttons.zoomOut")} \u2014 ${bx("CtrlOrCmd+-")}`,
        "aria-label": g("buttons.zoomOut"),
        disabled: o.zoom.value <= fx,
        onClick: () => {
          e(null);
        },
      }),
    keyTest: (e) =>
      (e.code === Eo.MINUS || e.code === Eo.NUM_SUBTRACT) && (e[Ro.CTRL_OR_CMD] || e.shiftKey),
  }),
  Bs = B({
    name: "resetZoom",
    label: "buttons.resetZoom",
    icon: B1,
    viewMode: !0,
    trackEvent: { category: "canvas" },
    perform: (e, o, t, r) => ({
      appState: {
        ...o,
        ..._o(
          {
            viewportX: o.width / 2 + o.offsetLeft,
            viewportY: o.height / 2 + o.offsetTop,
            nextZoom: go(1),
          },
          o
        ),
        userToFollow: null,
      },
      captureUpdate: eo.EVENTUALLY,
    }),
    PanelComponent: ({ updateData: e, appState: o }) =>
      Fs(Lt, {
        label: g("buttons.resetZoom"),
        style: { height: "100%" },
        children: A4(V, {
          type: "button",
          className: "reset-zoom-button zoom-button",
          title: g("buttons.resetZoom"),
          "aria-label": g("buttons.resetZoom"),
          onClick: () => {
            e(null);
          },
          children: [(o.zoom.value * 100).toFixed(0), "%"],
        }),
      }),
    keyTest: (e) =>
      (e.code === Eo.ZERO || e.code === Eo.NUM_ZERO) && (e[Ro.CTRL_OR_CMD] || e.shiftKey),
  }),
  L4 = (e, o, t = 1) => {
    let [r, n, i, a] = e,
      l = i - r,
      s = o.width / l,
      d = a - n,
      m = o.height / d,
      p = Math.min(s, m) * Np(t, 0.1, 1);
    return Math.min(p, 1);
  },
  xx = ({
    bounds: e,
    appState: o,
    canvasOffsets: t,
    fitToViewport: r = !1,
    viewportZoomFactor: n = 1,
    minZoom: i = -1 / 0,
    maxZoom: a = 1 / 0,
  }) => {
    n = Np(n, fx, gx);
    let [l, s, d, m] = e,
      c = (l + d) / 2,
      p = (s + m) / 2,
      u = t?.left ?? 0,
      f = t?.top ?? 0,
      b = t?.right ?? 0,
      x = t?.bottom ?? 0,
      w = o.width - u - b,
      E = o.height - f - x,
      y;
    if (r) {
      let S = d - l,
        M = m - s;
      y = Math.min(w / S, E / M) * n;
    } else y = L4(e, { width: w, height: E }, n);
    let v = go(Np(T4(y, Bp, "floor"), i, a)),
      C = Zf({
        scenePoint: { x: c, y: p },
        viewportDimensions: { width: o.width, height: o.height },
        offsets: t,
        zoom: { value: v },
      });
    return {
      appState: { ...o, scrollX: C.scrollX, scrollY: C.scrollY, zoom: { value: v } },
      captureUpdate: eo.EVENTUALLY,
    };
  },
  fa = ({
    canvasOffsets: e,
    targetElements: o,
    appState: t,
    fitToViewport: r,
    viewportZoomFactor: n,
    minZoom: i,
    maxZoom: a,
  }) => {
    let l = k4(C4(o));
    return xx({
      canvasOffsets: e,
      bounds: l,
      appState: t,
      fitToViewport: r,
      viewportZoomFactor: n,
      minZoom: i,
      maxZoom: a,
    });
  },
  lj = B({
    name: "zoomToFitSelectionInViewport",
    label: "labels.zoomToFitViewport",
    icon: rs,
    trackEvent: { category: "canvas" },
    perform: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o);
      return fa({
        targetElements: n.length ? n : e,
        appState: { ...o, userToFollow: null },
        fitToViewport: !1,
        canvasOffsets: r.getEditorUIOffsets(),
      });
    },
    keyTest: (e) => e.code === Eo.TWO && e.shiftKey && !e.altKey && !e[Ro.CTRL_OR_CMD],
  }),
  sj = B({
    name: "zoomToFitSelection",
    label: "helpDialog.zoomToSelection",
    icon: rs,
    trackEvent: { category: "canvas" },
    perform: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o);
      return fa({
        targetElements: n.length ? n : e,
        appState: { ...o, userToFollow: null },
        fitToViewport: !0,
        canvasOffsets: r.getEditorUIOffsets(),
      });
    },
    keyTest: (e) => e.code === Eo.THREE && e.shiftKey && !e.altKey && !e[Ro.CTRL_OR_CMD],
  }),
  P4 = B({
    name: "zoomToFit",
    label: "helpDialog.zoomToFit",
    icon: rs,
    viewMode: !0,
    trackEvent: { category: "canvas" },
    perform: (e, o, t, r) =>
      fa({
        targetElements: e,
        appState: { ...o, userToFollow: null },
        fitToViewport: !1,
        canvasOffsets: r.getEditorUIOffsets(),
      }),
    keyTest: (e) => e.code === Eo.ONE && e.shiftKey && !e.altKey && !e[Ro.CTRL_OR_CMD],
  }),
  Kr = B({
    name: "toggleTheme",
    label: (e, o) => (o.theme === ga.DARK ? "buttons.lightMode" : "buttons.darkMode"),
    keywords: ["toggle", "dark", "light", "mode", "theme"],
    icon: (e) => (e.theme === ga.LIGHT ? qi : Ji),
    viewMode: !0,
    trackEvent: { category: "canvas" },
    perform: (e, o, t) => ({
      appState: { ...o, theme: t || (o.theme === ga.LIGHT ? ga.DARK : ga.LIGHT) },
      captureUpdate: eo.EVENTUALLY,
    }),
    keyTest: (e) => e.altKey && e.shiftKey && e.code === Eo.D,
    predicate: (e, o, t, r) => !!r.props.UIOptions.canvasActions.toggleTheme,
  }),
  cj = B({
    name: "toggleEraserTool",
    label: "toolBar.eraser",
    trackEvent: { category: "toolbar" },
    perform: (e, o) => {
      let t;
      return (
        bt(o)
          ? (t = Kn(o, {
              ...(o.activeTool.lastActiveTool || { type: "selection" }),
              lastActiveToolBeforeEraser: null,
            }))
          : (t = Kn(o, { type: "eraser", lastActiveToolBeforeEraser: o.activeTool })),
        {
          appState: {
            ...o,
            selectedElementIds: {},
            selectedGroupIds: {},
            activeEmbeddable: null,
            activeTool: t,
          },
          captureUpdate: eo.IMMEDIATELY,
        }
      );
    },
    keyTest: (e) => e.key === Ro.E,
  }),
  dj = B({
    name: "toggleLassoTool",
    label: "toolBar.lasso",
    icon: $i,
    trackEvent: { category: "toolbar" },
    perform: (e, o, t, r) => {
      let n;
      return (
        o.activeTool.type !== "lasso"
          ? ((n = Kn(o, { type: "lasso", fromSelection: !1 })),
            xe(r.interactiveCanvas, hx.CROSSHAIR))
          : (n = Kn(o, { type: "selection" })),
        {
          appState: {
            ...o,
            selectedElementIds: {},
            selectedGroupIds: {},
            activeEmbeddable: null,
            activeTool: n,
          },
          captureUpdate: eo.NEVER,
        }
      );
    },
  }),
  Ex = B({
    name: "toggleHandTool",
    label: "toolBar.hand",
    trackEvent: { category: "toolbar" },
    icon: es,
    viewMode: !1,
    perform: (e, o, t, r) => {
      let n;
      return (
        qt(o)
          ? (n = Kn(o, {
              ...(o.activeTool.lastActiveTool || { type: "selection" }),
              lastActiveToolBeforeEraser: null,
            }))
          : ((n = Kn(o, { type: "hand", lastActiveToolBeforeEraser: o.activeTool })),
            xe(r.interactiveCanvas, hx.GRAB)),
        {
          appState: {
            ...o,
            selectedElementIds: {},
            selectedGroupIds: {},
            activeEmbeddable: null,
            activeTool: n,
          },
          captureUpdate: eo.IMMEDIATELY,
        }
      );
    },
    keyTest: (e) => !e.altKey && !e[Ro.CTRL_OR_CMD] && e.key === Ro.H,
  });
import { updateActiveTool as yx } from "@excalidraw/common";
import { CaptureUpdateAction as D4 } from "@excalidraw/element";
var _4 = B({
  name: "setEmbeddableAsActiveTool",
  trackEvent: { category: "toolbar" },
  target: "Tool",
  label: "toolBar.embeddable",
  perform: (e, o, t, r) => {
    let n = yx(o, { type: "embeddable" });
    return (
      Pt(r.canvas, { ...o, activeTool: n }),
      {
        elements: e,
        appState: { ...o, activeTool: yx(o, { type: "embeddable" }) },
        captureUpdate: D4.EVENTUALLY,
      }
    );
  },
});
import { pointFrom as R4 } from "@excalidraw/math";
import {
  maybeBindLinearElement as N4,
  bindOrUnbindLinearElement as wx,
  isBindingEnabled as B4,
} from "@excalidraw/element/binding";
import { isValidPolygon as vx, LinearElementEditor as Os } from "@excalidraw/element";
import {
  isBindingElement as zs,
  isFreeDrawElement as Tx,
  isLinearElement as Ix,
  isLineElement as Hs,
} from "@excalidraw/element";
import {
  KEYS as Fp,
  arrayToMap as Cx,
  tupleToCoors as F4,
  updateActiveTool as Sx,
} from "@excalidraw/common";
import { isPathALoop as O4 } from "@excalidraw/element";
import { isInvisiblySmallElement as Op } from "@excalidraw/element";
import { CaptureUpdateAction as zp } from "@excalidraw/element";
import { jsx as z4 } from "react/jsx-runtime";
var At = B({
  name: "finalize",
  label: "",
  trackEvent: !1,
  perform: (e, o, t, r) => {
    let { interactiveCanvas: n, focusContainer: i, scene: a } = r,
      { event: l, sceneCoords: s } = t ?? {},
      d = a.getNonDeletedElementsMap();
    if (l && o.selectedLinearElement) {
      let u = Os.handlePointerUp(l, o.selectedLinearElement, o, r.scene),
        { startBindingElement: f, endBindingElement: b } = u,
        x = r.scene.getElement(u.elementId);
      if ((zs(x) && wx(x, f, b, r.scene), u !== o.selectedLinearElement)) {
        let w = e;
        return (
          x && Op(x) && (w = w.filter((E) => E.id !== x.id)),
          {
            elements: w,
            appState: {
              selectedLinearElement: { ...u, selectedPointsIndices: null },
              suggestedBindings: [],
            },
            captureUpdate: zp.IMMEDIATELY,
          }
        );
      }
    }
    if (o.editingLinearElement) {
      let { elementId: u, startBindingElement: f, endBindingElement: b } = o.editingLinearElement,
        x = Os.getElement(u, d);
      if (x)
        return (
          zs(x) && wx(x, f, b, a),
          Hs(x) && !vx(x.points) && a.mutateElement(x, { polygon: !1 }),
          {
            elements: x.points.length < 2 || Op(x) ? e.filter((w) => w.id !== x.id) : void 0,
            appState: { ...o, cursorButton: "up", editingLinearElement: null },
            captureUpdate: zp.IMMEDIATELY,
          }
        );
    }
    let m = e;
    window.document.activeElement instanceof HTMLElement && i();
    let c = null;
    if (o.multiElement) c = o.multiElement;
    else if (o.newElement?.type === "freedraw" || zs(o.newElement)) c = o.newElement;
    else if (Object.keys(o.selectedElementIds).length === 1) {
      let u = d.get(Object.keys(o.selectedElementIds)[0]);
      u && (c = u);
    }
    if (c) {
      if (o.multiElement && c.type !== "freedraw" && o.lastPointerDownWith !== "touch") {
        let { points: u, lastCommittedPoint: f } = c;
        (!f || u[u.length - 1] !== f) && a.mutateElement(c, { points: c.points.slice(0, -1) });
      }
      if ((c && Op(c) && (m = m.filter((u) => u.id !== c.id)), Ix(c) || Tx(c))) {
        let u = O4(c.points, o.zoom.value);
        if (u && (Hs(c) || Tx(c))) {
          let f = c.points,
            b = f[0],
            x = f.map((w, E) => (E === f.length - 1 ? R4(b[0], b[1]) : w));
          Hs(c)
            ? a.mutateElement(c, { points: x, polygon: !0 })
            : a.mutateElement(c, { points: x });
        }
        if (
          (Hs(c) && !vx(c.points) && a.mutateElement(c, { polygon: !1 }),
          zs(c) && !u && c.points.length > 1 && B4(o))
        ) {
          let f = s ?? F4(Os.getPointAtIndexGlobalCoordinates(c, -1, Cx(e)));
          N4(c, o, f, a);
        }
      }
    }
    ((!o.activeTool.locked && o.activeTool.type !== "freedraw") || !c) && Ht(n);
    let p;
    return (
      o.activeTool.type === "eraser"
        ? (p = Sx(o, {
            ...(o.activeTool.lastActiveTool || { type: "selection" }),
            lastActiveToolBeforeEraser: null,
          }))
        : (p = Sx(o, { type: "selection" })),
      {
        elements: m,
        appState: {
          ...o,
          cursorButton: "up",
          activeTool:
            (o.activeTool.locked || o.activeTool.type === "freedraw") && c ? o.activeTool : p,
          activeEmbeddable: null,
          newElement: null,
          selectionElement: null,
          multiElement: null,
          editingTextElement: null,
          startBoundElement: null,
          suggestedBindings: [],
          selectedElementIds:
            c && !o.activeTool.locked && o.activeTool.type !== "freedraw"
              ? { ...o.selectedElementIds, [c.id]: !0 }
              : o.selectedElementIds,
          selectedLinearElement: c && Ix(c) ? new Os(c, Cx(m)) : o.selectedLinearElement,
        },
        captureUpdate: zp.IMMEDIATELY,
      }
    );
  },
  keyTest: (e, o) =>
    (e.key === Fp.ESCAPE &&
      (o.editingLinearElement !== null || (!o.newElement && o.multiElement === null))) ||
    ((e.key === Fp.ESCAPE || e.key === Fp.ENTER) && o.multiElement !== null),
  PanelComponent: ({ appState: e, updateData: o, data: t }) =>
    z4(V, {
      type: "button",
      icon: X1,
      title: g("buttons.done"),
      "aria-label": g("buttons.done"),
      onClick: o,
      visible: e.multiElement != null,
      size: t?.size || "medium",
      style: { pointerEvents: "all" },
    }),
});
import {
  KEYS as jn,
  DEFAULT_EXPORT_PADDING as Ck,
  EXPORT_SCALES as Sk,
  THEME as Up,
} from "@excalidraw/common";
import { getNonDeletedElements as kk } from "@excalidraw/element";
import { CaptureUpdateAction as no } from "@excalidraw/element";
import H4 from "clsx";
import { jsx as kx, jsxs as G4 } from "react/jsx-runtime";
var ba = ({ children: e, checked: o, onChange: t, className: r }) =>
  G4("div", {
    className: H4("Checkbox", r, { "is-checked": o }),
    onClick: (n) => {
      t(!o, n), n.currentTarget.querySelector(".Checkbox-box").focus();
    },
    children: [
      kx("button", {
        type: "button",
        className: "Checkbox-box",
        role: "checkbox",
        "aria-checked": o,
        children: H1,
      }),
      kx("div", { className: "Checkbox-label", children: e }),
    ],
  });
import { THEME as xa } from "@excalidraw/common";
import { jsx as Ea } from "react/jsx-runtime";
var Lx = (e) => {
    let o = e.title || (e.value === xa.DARK ? g("buttons.lightMode") : g("buttons.darkMode"));
    return Ea(V, {
      type: "icon",
      icon: e.value === xa.LIGHT ? Mx.MOON : Mx.SUN,
      title: o,
      "aria-label": o,
      onClick: () => e.onChange(e.value === xa.DARK ? xa.LIGHT : xa.DARK),
      "data-testid": "toggle-dark-mode",
    });
  },
  Mx = {
    SUN: Ea("svg", {
      width: "512",
      height: "512",
      className: "rtl-mirror",
      viewBox: "0 0 512 512",
      children: Ea("path", {
        fill: "currentColor",
        d: "M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z",
      }),
    }),
    MOON: Ea("svg", {
      width: "512",
      height: "512",
      className: "rtl-mirror",
      viewBox: "0 0 512 512",
      children: Ea("path", {
        fill: "currentColor",
        d: "M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z",
      }),
    }),
  };
import { useState as U4 } from "react";
import { focusNearestParent as Y4, KEYS as W4 } from "@excalidraw/common";
import { jsx as Px, jsxs as V4 } from "react/jsx-runtime";
var Ax = (e) => {
  let { id: o } = Ge(),
    [t, r] = U4(e.value),
    n = (a) => {
      e.ignoreFocus || Y4(a.target);
      let l = a.target.value;
      l !== e.value && e.onChange(l);
    },
    i = (a) => {
      if (a.key === W4.ENTER) {
        if ((a.preventDefault(), a.nativeEvent.isComposing || a.keyCode === 229)) return;
        a.currentTarget.blur();
      }
    };
  return V4("div", {
    className: "ProjectName",
    children: [
      Px("label", { className: "ProjectName-label", htmlFor: "filename", children: `${e.label}:` }),
      Px("input", {
        type: "text",
        className: "TextInput",
        onBlur: n,
        onKeyDown: i,
        id: `${o}-filename`,
        value: t,
        onChange: (a) => r(a.target.value),
      }),
    ],
  });
};
import {
  DEFAULT_EXPORT_PADDING as fk,
  DEFAULT_FILENAME as bk,
  IMAGE_MIME_TYPES as Xx,
  isFirefox as xk,
  MIME_TYPES as Ek,
  cloneJSON as yk,
  SVG_DOCUMENT_PREAMBLE as wk,
} from "@excalidraw/common";
import { getNonDeletedElements as vk } from "@excalidraw/element";
import { isFrameLikeElement as Tk } from "@excalidraw/element";
import { getElementsOverlappingFrame as Ik } from "@excalidraw/element";
import {
  ALLOWED_PASTE_MIME_TYPES as ok,
  EXPORT_DATA_TYPES as va,
  MIME_TYPES as oo,
  arrayToMap as rk,
  isMemberOf as nk,
  isPromiseLike as ik,
} from "@excalidraw/common";
import { mutateElement as ak } from "@excalidraw/element";
import { deepCopyElement as lk } from "@excalidraw/element";
import { isFrameLikeElement as sk, isInitializedImageElement as ck } from "@excalidraw/element";
import { getContainingFrame as Ux } from "@excalidraw/element";
import { pointFrom as cr } from "@excalidraw/math";
import {
  COLOR_PALETTE as _x,
  DEFAULT_CHART_COLOR_INDEX as X4,
  getAllColorsSpecificShade as K4,
  DEFAULT_FONT_FAMILY as Z4,
  DEFAULT_FONT_SIZE as Rx,
  VERTICAL_ALIGN as $4,
  randomId as Nx,
  isDevEnv as Bx,
} from "@excalidraw/common";
import {
  newTextElement as Gs,
  newLinearElement as wa,
  newElement as Gp,
} from "@excalidraw/element";
var to = 32,
  we = 12,
  dr = 256,
  Fx = 50,
  Zr = "NOT_SPREADSHEET",
  Zn = "VALID_SPREADSHEET",
  ya = (e) => {
    let o = /^([-+]?)[$€£¥₩]?([-+]?)([\d.,]+)[%]?$/.exec(e);
    return o ? parseFloat(`${(o[1] || o[2]) + o[3]}`.replace(/,/g, "")) : null;
  },
  Hp = (e, o) => e.slice(1).every((t) => ya(t[o]) !== null),
  Dx = (e) => {
    let o = e[0].length;
    if (o > 2) return { type: Zr, reason: "More than 2 columns" };
    if (o === 1) {
      if (!Hp(e, 0)) return { type: Zr, reason: "Value is not numeric" };
      let s = ya(e[0][0]) === null,
        d = (s ? e.slice(1) : e).map((m) => ya(m[0]));
      return d.length < 2
        ? { type: Zr, reason: "Less than two rows" }
        : { type: Zn, spreadsheet: { title: s ? e[0][0] : null, labels: null, values: d } };
    }
    let t = Hp(e, 0),
      r = Hp(e, 1);
    if (!t && !r) return { type: Zr, reason: "Value is not numeric" };
    let [n, i] = r ? [0, 1] : [1, 0],
      a = ya(e[0][i]) === null,
      l = a ? e.slice(1) : e;
    return l.length < 2
      ? { type: Zr, reason: "Less than 2 rows" }
      : {
          type: Zn,
          spreadsheet: {
            title: a ? e[0][i] : null,
            labels: l.map((s) => s[n]),
            values: l.map((s) => ya(s[i])),
          },
        };
  },
  j4 = (e) => {
    let o = [];
    for (let t = 0; t < e[0].length; t++) {
      let r = [];
      for (let n = 0; n < e.length; n++) r.push(e[n][t]);
      o.push(r);
    }
    return o;
  },
  Ox = (e) => {
    let o = e
      .trim()
      .split(
        `
`
      )
      .map((i) => i.trim().split("	"));
    if (
      (o.length &&
        o[0].length !== 2 &&
        (o = e
          .trim()
          .split(
            `
`
          )
          .map((i) => i.trim().split(","))),
      o.length === 0)
    )
      return { type: Zr, reason: "No values" };
    let t = o[0].length;
    if (!o.every((i) => i.length === t))
      return { type: Zr, reason: "All rows don't have same number of columns" };
    let n = Dx(o);
    if (n.type !== Zn) {
      let i = Dx(j4(o));
      if (i.type === Zn) return i;
    }
    return n;
  },
  Us = K4(X4),
  Gt = {
    fillStyle: "hachure",
    fontFamily: Z4,
    fontSize: Rx,
    opacity: 100,
    roughness: 1,
    strokeColor: _x.black,
    roundness: null,
    strokeStyle: "solid",
    strokeWidth: 1,
    verticalAlign: $4.MIDDLE,
    locked: !1,
  },
  zx = (e) => {
    let o = (to + we) * e.values.length + we,
      t = dr + we * 2;
    return { chartWidth: o, chartHeight: t };
  },
  q4 = (e, o, t, r, n) =>
    e.labels?.map((i, a) =>
      Gs({
        groupIds: [r],
        backgroundColor: n,
        ...Gt,
        text: i.length > 8 ? `${i.slice(0, 5)}...` : i,
        x: o + a * (to + we) + we * 2,
        y: t + we / 2,
        width: to,
        angle: 5.87,
        fontSize: 16,
        textAlign: "center",
        verticalAlign: "top",
      })
    ) || [],
  J4 = (e, o, t, r, n) => {
    let i = Gs({
        groupIds: [r],
        backgroundColor: n,
        ...Gt,
        x: o - we,
        y: t - we,
        text: "0",
        textAlign: "right",
      }),
      a = Gs({
        groupIds: [r],
        backgroundColor: n,
        ...Gt,
        x: o - we,
        y: t - dr - i.height / 2,
        text: Math.max(...e.values).toLocaleString(),
        textAlign: "right",
      });
    return [i, a];
  },
  Q4 = (e, o, t, r, n) => {
    let { chartWidth: i, chartHeight: a } = zx(e),
      l = wa({
        backgroundColor: n,
        groupIds: [r],
        ...Gt,
        type: "line",
        x: o,
        y: t,
        width: i,
        points: [cr(0, 0), cr(i, 0)],
      }),
      s = wa({
        backgroundColor: n,
        groupIds: [r],
        ...Gt,
        type: "line",
        x: o,
        y: t,
        height: a,
        points: [cr(0, 0), cr(0, -a)],
      }),
      d = wa({
        backgroundColor: n,
        groupIds: [r],
        ...Gt,
        type: "line",
        x: o,
        y: t - dr - we,
        strokeStyle: "dotted",
        width: i,
        opacity: Fx,
        points: [cr(0, 0), cr(i, 0)],
      });
    return [l, s, d];
  },
  Hx = (e, o, t, r, n, i) => {
    let { chartWidth: a, chartHeight: l } = zx(e),
      s = e.title
        ? Gs({
            backgroundColor: n,
            groupIds: [r],
            ...Gt,
            text: e.title,
            x: o + a / 2,
            y: t - dr - we * 2 - Rx,
            roundness: null,
            textAlign: "center",
          })
        : null,
      d = i
        ? Gp({
            backgroundColor: n,
            groupIds: [r],
            ...Gt,
            type: "rectangle",
            x: o,
            y: t - l,
            width: a,
            height: l,
            strokeColor: _x.black,
            fillStyle: "solid",
            opacity: 6,
          })
        : null;
    return [
      ...(d ? [d] : []),
      ...(s ? [s] : []),
      ...q4(e, o, t, r, n),
      ...J4(e, o, t, r, n),
      ...Q4(e, o, t, r, n),
    ];
  },
  ek = (e, o, t) => {
    let r = Math.max(...e.values),
      n = Nx(),
      i = Us[Math.floor(Math.random() * Us.length)];
    return [
      ...e.values.map((l, s) => {
        let d = (l / r) * dr;
        return Gp({
          backgroundColor: i,
          groupIds: [n],
          ...Gt,
          type: "rectangle",
          x: o + s * (to + we) + we,
          y: t - d - we,
          width: to,
          height: d,
        });
      }),
      ...Hx(e, o, t, n, i, Bx()),
    ];
  },
  tk = (e, o, t) => {
    let r = Math.max(...e.values),
      n = Nx(),
      i = Us[Math.floor(Math.random() * Us.length)],
      a = 0,
      l = [];
    for (let b of e.values) {
      let x = a * (to + we),
        w = -(b / r) * dr;
      l.push([x, w]), a++;
    }
    let s = Math.max(...l.map((b) => b[0])),
      d = Math.max(...l.map((b) => b[1])),
      m = Math.min(...l.map((b) => b[0])),
      c = Math.min(...l.map((b) => b[1])),
      p = wa({
        backgroundColor: i,
        groupIds: [n],
        ...Gt,
        type: "line",
        x: o + we + to / 2,
        y: t - we,
        height: d - c,
        width: s - m,
        strokeWidth: 2,
        points: l,
      }),
      u = e.values.map((b, x) => {
        let w = x * (to + we) + we / 2,
          E = -(b / r) * dr + we / 2;
        return Gp({
          backgroundColor: i,
          groupIds: [n],
          ...Gt,
          fillStyle: "solid",
          strokeWidth: 2,
          type: "ellipse",
          x: o + w + to / 2,
          y: t + E - we * 2,
          width: we,
          height: we,
        });
      }),
      f = e.values.map((b, x) => {
        let w = x * (to + we) + we / 2,
          E = (b / r) * dr + we / 2 + we;
        return wa({
          backgroundColor: i,
          groupIds: [n],
          ...Gt,
          type: "line",
          x: o + w + to / 2 + we / 2,
          y: t - E,
          height: E,
          strokeStyle: "dotted",
          opacity: Fx,
          points: [cr(0, 0), cr(0, E)],
        });
      });
    return [...Hx(e, o, t, n, i, Bx()), p, ...f, ...u];
  },
  Gx = (e, o, t, r) => (e === "line" ? tk(o, t, r) : ek(o, t, r));
var Tq = "clipboard" in navigator && "readText" in navigator.clipboard,
  Ys = "clipboard" in navigator && "writeText" in navigator.clipboard,
  $n =
    "clipboard" in navigator &&
    "write" in navigator.clipboard &&
    "ClipboardItem" in window &&
    "toBlob" in HTMLCanvasElement.prototype,
  dk = (e) =>
    !!(
      [va.excalidraw, va.excalidrawClipboard, va.excalidrawClipboardWithAPI].includes(e?.type) &&
      Array.isArray(e.elements)
    ),
  Yx = ({ types: e, files: o }) => {
    !e && !o && console.warn("createPasteEvent: no types or files provided");
    let t = new ClipboardEvent("paste", { clipboardData: new DataTransfer() });
    if (e)
      for (let [r, n] of Object.entries(e)) {
        if (typeof n != "string") {
          (o = o || []), o.push(n);
          continue;
        }
        try {
          if ((t.clipboardData?.setData(r, n), t.clipboardData?.getData(r) !== n))
            throw new Error(`Failed to set "${r}" as clipboardData item`);
        } catch (i) {
          throw new Error(i.message);
        }
      }
    if (o) {
      let r = -1;
      for (let n of o) {
        r++;
        try {
          if ((t.clipboardData?.items.add(n), t.clipboardData?.files[r] !== n))
            throw new Error(`Failed to set file "${n.name}" as clipboardData item`);
        } catch (i) {
          throw new Error(i.message);
        }
      }
    }
    return t;
  },
  mk = ({ elements: e, files: o }) => {
    let t = rk(e),
      r = new Set(e.filter((l) => sk(l))),
      n = !1,
      i = e.reduce(
        (l, s) => (ck(s) && ((n = !0), o && o[s.fileId] && (l[s.fileId] = o[s.fileId])), l),
        {}
      );
    n &&
      !o &&
      console.warn(
        "copyToClipboard: attempting to file element(s) without providing associated `files` object."
      );
    let a = {
      type: va.excalidrawClipboard,
      elements: e.map((l) => {
        if (Ux(l, t) && !r.has(Ux(l, t))) {
          let s = lk(l);
          return ak(s, t, { frameId: null }), s;
        }
        return l;
      }),
      files: o ? i : void 0,
    };
    return JSON.stringify(a);
  },
  Ws = async (e, o, t) => {
    await ro(mk({ elements: e, files: o }), t);
  },
  pk = (e) => {
    let o = Ox(e);
    return o.type === Zn ? { spreadsheet: o.spreadsheet } : null;
  };
function Wx(e) {
  let o = [];
  for (let t of e.childNodes)
    if (t.nodeType === 3) {
      let r = t.textContent?.trim();
      r && o.push({ type: "text", value: r });
    } else if (t instanceof HTMLImageElement) {
      let r = t.getAttribute("src");
      r && r.startsWith("http") && o.push({ type: "imageUrl", value: r });
    } else o = o.concat(Wx(t));
  return o;
}
var uk = (e) => {
    let o = e.clipboardData?.getData(oo.html);
    if (!o) return null;
    try {
      let t = new DOMParser().parseFromString(o, oo.html),
        r = Wx(t.body);
      if (r.length) return { type: "mixedContent", value: r };
    } catch (t) {
      console.error(`error in parseHTMLFromPaste: ${t.message}`);
    }
    return null;
  },
  Vx = async () => {
    let e = {},
      o;
    try {
      o = await navigator.clipboard?.read();
    } catch (t) {
      try {
        if (navigator.clipboard?.readText) {
          console.warn(
            `navigator.clipboard.readText() failed (${t.message}). Failling back to navigator.clipboard.read()`
          );
          let r = await navigator.clipboard?.readText();
          if (r) return { [oo.text]: r };
        }
      } catch (r) {
        if (navigator.clipboard?.read)
          console.warn(
            `navigator.clipboard.readText() failed (${r.message}). Failling back to navigator.clipboard.read()`
          );
        else {
          if (r.name === "DataError")
            return (
              console.warn(
                `navigator.clipboard.read() error, clipboard is probably empty: ${r.message}`
              ),
              e
            );
          throw r;
        }
      }
      throw t;
    }
    for (let t of o)
      for (let r of t.types)
        if (nk(ok, r))
          try {
            if (r === oo.text || r === oo.html) e[r] = await (await t.getType(r)).text();
            else if (d1(r)) {
              let n = await t.getType(r),
                i = b1(n, r, void 0);
              e[r] = i;
            } else throw new mm(`Unsupported clipboard type: ${r}`);
          } catch (n) {
            console.warn(
              n instanceof mm ? n.message : `Cannot retrieve ${r} from clipboardItem: ${n.message}`
            );
          }
    return (
      Object.keys(e).length === 0 && console.warn("No clipboard data found from clipboard.read()."),
      e
    );
  },
  hk = async (e, o = !1) => {
    try {
      let t = !o && e && uk(e);
      return t
        ? t.value.every((n) => n.type === "text")
          ? {
              type: "text",
              value:
                e.clipboardData?.getData(oo.text) ||
                t.value
                  .map((n) => n.value)
                  .join(
                    `
`
                  )
                  .trim(),
            }
          : t
        : { type: "text", value: (e.clipboardData?.getData(oo.text) || "").trim() };
    } catch {
      return { type: "text", value: "" };
    }
  },
  Vs = async (e, o = !1) => {
    let t = await hk(e, o);
    if (t.type === "mixedContent") return { mixedContent: t.value };
    try {
      let r = !o && pk(t.value);
      if (r) return r;
    } catch (r) {
      console.error(r);
    }
    try {
      let r = JSON.parse(t.value),
        n = r.type === va.excalidrawClipboardWithAPI;
      if (dk(r))
        return {
          elements: r.elements,
          files: r.files,
          text: o ? JSON.stringify(r.elements, null, 2) : void 0,
          programmaticAPI: n,
        };
    } catch {}
    return { text: t.value };
  },
  Xs = async (e) => {
    try {
      await navigator.clipboard.write([new window.ClipboardItem({ [oo.png]: e })]);
    } catch (o) {
      if (ik(e)) await navigator.clipboard.write([new window.ClipboardItem({ [oo.png]: await e })]);
      else throw o;
    }
  },
  ro = async (e, o) => {
    if (Ys)
      try {
        await navigator.clipboard.writeText(e || "");
        return;
      } catch (t) {
        console.error(t);
      }
    try {
      if (o) {
        if ((o.clipboardData?.setData(oo.text, e || ""), o.clipboardData?.getData(oo.text) !== e))
          throw new Error("Failed to setData on clipboardEvent");
        return;
      }
    } catch (t) {
      console.error(t);
    }
    if (!gk(e)) throw new Error("Error copying to clipboard.");
  },
  gk = (e) => {
    e || (e = " ");
    let o = document.documentElement.getAttribute("dir") === "rtl",
      t = document.createElement("textarea");
    (t.style.border = "0"),
      (t.style.padding = "0"),
      (t.style.margin = "0"),
      (t.style.position = "absolute"),
      (t.style[o ? "right" : "left"] = "-9999px");
    let r = window.pageYOffset || document.documentElement.scrollTop;
    (t.style.top = `${r}px`),
      (t.style.fontSize = "12pt"),
      t.setAttribute("readonly", ""),
      (t.value = e),
      document.body.appendChild(t);
    let n = !1;
    try {
      t.select(), t.setSelectionRange(0, t.value.length), (n = document.execCommand("copy"));
    } catch (i) {
      console.error(i);
    }
    return t.remove(), n;
  };
var $r = (e, { selectedElementIds: o }, t) => {
    e = vk(e);
    let r = t && Ee(e, { selectedElementIds: o }),
      n = null,
      i = r ? Z(e, { selectedElementIds: o }, { includeBoundTextElement: !0 }) : e;
    return (
      r &&
        (i.length === 1 && Tk(i[0])
          ? ((n = i[0]), (i = Ik(e, n)))
          : i.length > 1 &&
            (i = Z(
              e,
              { selectedElementIds: o },
              { includeBoundTextElement: !0, includeElementsInFrames: !0 }
            ))),
      { exportingFrame: n, exportedElements: yk(i) }
    );
  },
  jr = async (
    e,
    o,
    t,
    r,
    {
      exportBackground: n,
      exportPadding: i = fk,
      viewBackgroundColor: a,
      name: l = t.name || bk,
      fileHandle: s = null,
      exportingFrame: d = null,
    }
  ) => {
    if (o.length === 0) throw new Error(g("alerts.cannotExportEmptyCanvas"));
    if (e === "svg" || e === "clipboard-svg") {
      let c = yn(
        o,
        {
          exportBackground: n,
          exportWithDarkMode: t.exportWithDarkMode,
          viewBackgroundColor: a,
          exportPadding: i,
          exportScale: t.exportScale,
          exportEmbedScene: t.exportEmbedScene && e === "svg",
        },
        r,
        { exportingFrame: d }
      );
      if (e === "svg")
        return pm(
          c.then((p) => new Blob([wk + p.outerHTML], { type: Ek.svg })),
          {
            description: "Export to SVG",
            name: l,
            extension: t.exportEmbedScene ? "excalidraw.svg" : "svg",
            mimeTypes: [Xx.svg],
            fileHandle: s,
          }
        );
      if (e === "clipboard-svg") {
        let p = await c.then((u) => u.outerHTML);
        try {
          await ro(p);
        } catch {
          throw new Error(g("errors.copyToSystemClipboardFailed"));
        }
        return;
      }
    }
    let m = Rl(o, t, r, {
      exportBackground: n,
      viewBackgroundColor: a,
      exportPadding: i,
      exportingFrame: d,
    });
    if (e === "png") {
      let c = Lo(m);
      return (
        t.exportEmbedScene &&
          (c = c.then((p) =>
            import("./data/image-HXEZYJPQ.js").then(({ encodePngMetadata: u }) =>
              u({ blob: p, metadata: Vi(o, t, r, "local") })
            )
          )),
        pm(c, {
          description: "Export to PNG",
          name: l,
          extension: t.exportEmbedScene ? "excalidraw.png" : "png",
          mimeTypes: [Xx.png],
          fileHandle: s,
        })
      );
    } else if (e === "clipboard")
      try {
        let c = Lo(m);
        await Xs(c);
      } catch (c) {
        throw (
          (console.warn(c),
          c.name === "CANVAS_POSSIBLY_TOO_BIG"
            ? new Error(g("canvasError.canvasTooBig"))
            : xk && c.name === "TypeError"
            ? new Error(`${g("alerts.couldNotCopyToClipboard")}

${g("hints.firefox_clipboard_write")}`)
            : new Error(g("alerts.couldNotCopyToClipboard")))
        );
      }
    else throw new Error("Unsupported export type");
  };
var Kx = async (e, o, t, r) => {
  let { exportBackground: n, viewBackgroundColor: i, fileHandle: a } = o,
    l = s1(a);
  if (!a || !c1(l))
    throw new Error("fileHandle should exist and should be of type svg or png when resaving");
  o = { ...o, exportEmbedScene: !0 };
  let { exportedElements: s, exportingFrame: d } = $r(e, o, !1);
  return (
    await jr(l, s, o, t, {
      exportBackground: n,
      viewBackgroundColor: i,
      name: r,
      fileHandle: a,
      exportingFrame: d,
    }),
    { fileHandle: a }
  );
};
import { Fragment as Mk, jsx as Bo, jsxs as Lk } from "react/jsx-runtime";
var Yp = B({
    name: "changeProjectName",
    label: "labels.fileTitle",
    trackEvent: !1,
    perform: (e, o, t) => ({ appState: { ...o, name: t }, captureUpdate: no.EVENTUALLY }),
    PanelComponent: ({ appState: e, updateData: o, appProps: t, data: r, app: n }) =>
      Bo(Ax, {
        label: g("labels.fileTitle"),
        value: n.getName(),
        onChange: (i) => o(i),
        ignoreFocus: r?.ignoreFocus ?? !1,
      }),
  }),
  Zx = B({
    name: "changeExportScale",
    label: "imageExportDialog.scale",
    trackEvent: { category: "export", action: "scale" },
    perform: (e, o, t) => ({ appState: { ...o, exportScale: t }, captureUpdate: no.EVENTUALLY }),
    PanelComponent: ({ elements: e, appState: o, updateData: t }) => {
      let r = kk(e),
        i = Ee(r, o) ? Z(r, o) : r;
      return Bo(Mk, {
        children: Sk.map((a) => {
          let [l, s] = a1(i, Ck, a),
            d = `${g("imageExportDialog.label.scale")} ${a}x (${l}x${s})`;
          return Bo(
            V,
            {
              size: "small",
              type: "radio",
              icon: `${a}x`,
              name: "export-canvas-scale",
              title: d,
              "aria-label": d,
              id: "export-canvas-scale",
              checked: a === o.exportScale,
              onChange: () => t(a),
            },
            a
          );
        }),
      });
    },
  }),
  Wp = B({
    name: "changeExportBackground",
    label: "imageExportDialog.label.withBackground",
    trackEvent: { category: "export", action: "toggleBackground" },
    perform: (e, o, t) => ({
      appState: { ...o, exportBackground: t },
      captureUpdate: no.EVENTUALLY,
    }),
    PanelComponent: ({ appState: e, updateData: o }) =>
      Bo(ba, {
        checked: e.exportBackground,
        onChange: (t) => o(t),
        children: g("imageExportDialog.label.withBackground"),
      }),
  }),
  Ks = B({
    name: "changeExportEmbedScene",
    label: "imageExportDialog.tooltip.embedScene",
    trackEvent: { category: "export", action: "embedScene" },
    perform: (e, o, t) => ({
      appState: { ...o, exportEmbedScene: t },
      captureUpdate: no.EVENTUALLY,
    }),
    PanelComponent: ({ appState: e, updateData: o }) =>
      Lk(ba, {
        checked: e.exportEmbedScene,
        onChange: (t) => o(t),
        children: [
          g("imageExportDialog.label.embedScene"),
          Bo(Lt, {
            label: g("imageExportDialog.tooltip.embedScene"),
            long: !0,
            children: Bo("div", { className: "excalidraw-tooltip-icon", children: K1 }),
          }),
        ],
      }),
  }),
  qr = B({
    name: "saveToActiveFile",
    label: "buttons.save",
    icon: Gr,
    trackEvent: { category: "export" },
    predicate: (e, o, t, r) =>
      !!r.props.UIOptions.canvasActions.saveToActiveFile && !!o.fileHandle && !o.viewModeEnabled,
    perform: async (e, o, t, r) => {
      let n = !!o.fileHandle;
      try {
        let { fileHandle: i } = Nl(o.fileHandle)
          ? await Kx(e, o, r.files, r.getName())
          : await Pl(e, o, r.files, r.getName());
        return {
          captureUpdate: no.EVENTUALLY,
          appState: {
            ...o,
            fileHandle: i,
            toast: n
              ? {
                  message: i?.name
                    ? g("toast.fileSavedToFilename").replace("{filename}", `"${i.name}"`)
                    : g("toast.fileSaved"),
                }
              : null,
          },
        };
      } catch (i) {
        return (
          i?.name !== "AbortError" ? console.error(i) : console.warn(i),
          { captureUpdate: no.EVENTUALLY }
        );
      }
    },
    keyTest: (e) => e.key === jn.S && e[jn.CTRL_OR_CMD] && !e.shiftKey,
  }),
  Ta = B({
    name: "saveFileToDisk",
    label: "exportDialog.disk_title",
    icon: Gr,
    viewMode: !0,
    trackEvent: { category: "export" },
    perform: async (e, o, t, r) => {
      try {
        let { fileHandle: n } = await Pl(e, { ...o, fileHandle: null }, r.files, r.getName());
        return {
          captureUpdate: no.EVENTUALLY,
          appState: {
            ...o,
            openDialog: null,
            fileHandle: n,
            toast: { message: g("toast.fileSaved") },
          },
        };
      } catch (n) {
        return (
          n?.name !== "AbortError" ? console.error(n) : console.warn(n),
          { captureUpdate: no.EVENTUALLY }
        );
      }
    },
    keyTest: (e) => e.key === jn.S && e.shiftKey && e[jn.CTRL_OR_CMD],
    PanelComponent: ({ updateData: e }) =>
      Bo(V, {
        type: "button",
        icon: U1,
        title: g("buttons.saveAs"),
        "aria-label": g("buttons.saveAs"),
        showAriaLabel: ae().editor.isMobile,
        hidden: !En,
        onClick: () => e(null),
        "data-testid": "save-as-button",
      }),
  }),
  qn = B({
    name: "loadScene",
    label: "buttons.load",
    trackEvent: { category: "export" },
    predicate: (e, o, t, r) => !!r.props.UIOptions.canvasActions.loadScene && !o.viewModeEnabled,
    perform: async (e, o, t, r) => {
      try {
        let { elements: n, appState: i, files: a } = await um(o, e);
        return { elements: n, appState: i, files: a, captureUpdate: no.IMMEDIATELY };
      } catch (n) {
        return n?.name === "AbortError"
          ? (console.warn(n), !1)
          : {
              elements: e,
              appState: { ...o, errorMessage: n.message },
              files: r.files,
              captureUpdate: no.EVENTUALLY,
            };
      }
    },
    keyTest: (e) => e[jn.CTRL_OR_CMD] && e.key === jn.O,
  }),
  $x = B({
    name: "exportWithDarkMode",
    label: "imageExportDialog.label.darkMode",
    trackEvent: { category: "export", action: "toggleTheme" },
    perform: (e, o, t) => ({
      appState: { ...o, exportWithDarkMode: t },
      captureUpdate: no.EVENTUALLY,
    }),
    PanelComponent: ({ appState: e, updateData: o }) =>
      Bo("div", {
        style: {
          display: "flex",
          justifyContent: "flex-end",
          marginTop: "-45px",
          marginBottom: "10px",
        },
        children: Bo(Lx, {
          value: e.exportWithDarkMode ? Up.DARK : Up.LIGHT,
          onChange: (t) => {
            o(t === Up.DARK);
          },
          title: g("imageExportDialog.label.darkMode"),
        }),
      }),
  });
import {
  DEFAULT_FONT_SIZE as Pk,
  DEFAULT_FONT_FAMILY as Ak,
  DEFAULT_TEXT_ALIGN as Dk,
  CODES as jx,
  KEYS as qx,
  getLineHeight as _k,
} from "@excalidraw/common";
import { newElementWith as Zs } from "@excalidraw/element";
import {
  hasBoundTextElement as Rk,
  canApplyRoundnessTypeToElement as Nk,
  getDefaultRoundnessTypeForElement as Bk,
  isFrameLikeElement as Fk,
  isArrowElement as Ok,
  isExcalidrawElement as zk,
  isTextElement as Vp,
} from "@excalidraw/element";
import { getBoundTextElement as Hk, redrawTextBoundingBox as Gk } from "@excalidraw/element";
import { CaptureUpdateAction as Xp } from "@excalidraw/element";
var Jx = "{}",
  Kp = B({
    name: "copyStyles",
    label: "labels.copyStyles",
    icon: Gm,
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => {
      let n = [],
        i = e.find((a) => o.selectedElementIds[a.id]);
      if ((n.push(i), i && Rk(i))) {
        let a = Hk(i, r.scene.getNonDeletedElementsMap());
        n.push(a);
      }
      return (
        i && (Jx = JSON.stringify(n)),
        {
          appState: { ...o, toast: { message: g("toast.copyStyles") } },
          captureUpdate: Xp.EVENTUALLY,
        }
      );
    },
    keyTest: (e) => e[qx.CTRL_OR_CMD] && e.altKey && e.code === jx.C,
  }),
  Zp = B({
    name: "pasteStyles",
    label: "labels.pasteStyles",
    icon: Gm,
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => {
      let n = JSON.parse(Jx),
        i = n[0],
        a = n[1];
      if (!zk(i)) return { elements: e, captureUpdate: Xp.EVENTUALLY };
      let l = Z(e, o, { includeBoundTextElement: !0 }),
        s = l.map((d) => d.id);
      return {
        elements: e.map((d) => {
          if (s.includes(d.id)) {
            let m = i;
            if ((Vp(d) && d.containerId && (m = a), !m)) return d;
            let c = Zs(d, {
              backgroundColor: m?.backgroundColor,
              strokeWidth: m?.strokeWidth,
              strokeColor: m?.strokeColor,
              strokeStyle: m?.strokeStyle,
              fillStyle: m?.fillStyle,
              opacity: m?.opacity,
              roughness: m?.roughness,
              roundness: m.roundness ? (Nk(m.roundness.type, d) ? m.roundness : Bk(d)) : null,
            });
            if (Vp(c)) {
              let p = m.fontSize || Pk,
                u = m.fontFamily || Ak;
              c = Zs(c, {
                fontSize: p,
                fontFamily: u,
                textAlign: m.textAlign || Dk,
                lineHeight: m.lineHeight || _k(u),
              });
              let f = null;
              c.containerId && (f = l.find((b) => Vp(c) && b.id === c.containerId) || null),
                Gk(c, f, r.scene);
            }
            return (
              c.type === "arrow" &&
                Ok(m) &&
                (c = Zs(c, { startArrowhead: m.startArrowhead, endArrowhead: m.endArrowhead })),
              Fk(d) && (c = Zs(c, { roundness: null, backgroundColor: "transparent" })),
              c
            );
          }
          return d;
        }),
        captureUpdate: Xp.IMMEDIATELY,
      };
    },
    keyTest: (e) => e[qx.CTRL_OR_CMD] && e.altKey && e.code === jx.V,
  });
import { KEYS as Uk } from "@excalidraw/common";
import { getNonDeletedElements as Yk } from "@excalidraw/element";
import { showSelectedShapeActions as Wk } from "@excalidraw/element";
import { CaptureUpdateAction as $p } from "@excalidraw/element";
import { jsx as Qx } from "react/jsx-runtime";
var Vk = B({
    name: "toggleCanvasMenu",
    label: "buttons.menu",
    trackEvent: { category: "menu" },
    perform: (e, o) => ({
      appState: { ...o, openMenu: o.openMenu === "canvas" ? null : "canvas" },
      captureUpdate: $p.EVENTUALLY,
    }),
    PanelComponent: ({ appState: e, updateData: o }) =>
      Qx(V, {
        type: "button",
        icon: Kl,
        "aria-label": g("buttons.menu"),
        onClick: o,
        selected: e.openMenu === "canvas",
      }),
  }),
  Xk = B({
    name: "toggleEditMenu",
    label: "buttons.edit",
    trackEvent: { category: "menu" },
    perform: (e, o) => ({
      appState: { ...o, openMenu: o.openMenu === "shape" ? null : "shape" },
      captureUpdate: $p.EVENTUALLY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t }) =>
      Qx(V, {
        visible: Wk(o, Yk(e)),
        type: "button",
        icon: Y1,
        "aria-label": g("buttons.edit"),
        onClick: t,
        selected: o.openMenu === "shape",
      }),
  }),
  Jr = B({
    name: "toggleShortcuts",
    label: "welcomeScreen.defaults.helpHint",
    icon: F1,
    viewMode: !0,
    trackEvent: { category: "menu", action: "toggleHelpDialog" },
    perform: (e, o, t, { focusContainer: r }) => (
      o.openDialog?.name === "help" && r(),
      {
        appState: { ...o, openDialog: o.openDialog?.name === "help" ? null : { name: "help" } },
        captureUpdate: $p.EVENTUALLY,
      }
    ),
    keyTest: (e) => e.key === Uk.QUESTION_MARK,
  });
import { getNonDeletedElements as js } from "@excalidraw/element";
import { newElementWith as oE } from "@excalidraw/element";
import { isBoundToContainer as Kk } from "@excalidraw/element";
import {
  frameAndChildrenSelectedTogether as Zk,
  getElementsInResizingFrame as $k,
  getFrameLikeElements as jk,
  getRootElements as qk,
  groupByFrameLikes as Jk,
  removeElementsFromFrame as Qk,
  replaceAllElementsInFrame as eM,
} from "@excalidraw/element";
import {
  KEYS as qs,
  randomId as tM,
  arrayToMap as jp,
  getShortcutKey as rE,
} from "@excalidraw/common";
import {
  getSelectedGroupIds as $s,
  selectGroup as oM,
  selectGroupsForSelectedElements as rM,
  getElementsInGroup as eE,
  addToGroup as nM,
  removeFromSelectedGroups as iM,
  isElementInGroup as nE,
} from "@excalidraw/element";
import { syncMovedIndices as aM } from "@excalidraw/element";
import { CaptureUpdateAction as Ia } from "@excalidraw/element";
import { jsx as Jn } from "react/jsx-runtime";
var lM = (e) => {
    if (e.length >= 2) {
      let o = e[0].groupIds;
      for (let t of o) if (e.reduce((r, n) => r && nE(n, t), !0)) return !0;
    }
    return !1;
  },
  tE = (e, o, t) => {
    let r = t.scene.getSelectedElements({
      selectedElementIds: o.selectedElementIds,
      includeBoundTextElement: !0,
    });
    return r.length >= 2 && !lM(r) && !Zk(r);
  },
  qp = B({
    name: "group",
    label: "labels.group",
    icon: (e) => Jn(Fm, { theme: e.theme }),
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => {
      let n = qk(
        r.scene.getSelectedElements({
          selectedElementIds: o.selectedElementIds,
          includeBoundTextElement: !0,
        })
      );
      if (n.length < 2) return { appState: o, elements: e, captureUpdate: Ia.EVENTUALLY };
      let i = $s(o);
      if (i.length === 1) {
        let x = i[0],
          w = new Set(eE(e, x).map((v) => v.id)),
          E = new Set(n.map((v) => v.id));
        if (new Set([...Array.from(w), ...Array.from(E)]).size === w.size)
          return { appState: o, elements: e, captureUpdate: Ia.EVENTUALLY };
      }
      let a = [...e];
      new Set(n.map((x) => x.frameId)).size > 1 &&
        Jk(n).forEach((w, E) => {
          Qk(w, r.scene.getNonDeletedElementsMap());
        });
      let s = tM(),
        d = jp(n);
      a = a.map((x) =>
        d.get(x.id) ? oE(x, { groupIds: nM(x.groupIds, s, o.editingGroupId) }) : x
      );
      let m = eE(a, s),
        c = m[m.length - 1],
        p = a.lastIndexOf(c),
        u = a.slice(p + 1),
        f = a.slice(0, p).filter((x) => !nE(x, s)),
        b = aM([...f, ...m, ...u], jp(m));
      return {
        appState: { ...o, ...oM(s, { ...o, selectedGroupIds: {} }, js(a)) },
        elements: b,
        captureUpdate: Ia.IMMEDIATELY,
      };
    },
    predicate: (e, o, t, r) => tE(e, o, r),
    keyTest: (e) => !e.shiftKey && e[qs.CTRL_OR_CMD] && e.key === qs.G,
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      Jn(V, {
        hidden: !tE(e, o, r),
        type: "button",
        icon: Jn(Fm, { theme: o.theme }),
        onClick: () => t(null),
        title: `${g("labels.group")} \u2014 ${rE("CtrlOrCmd+G")}`,
        "aria-label": g("labels.group"),
        visible: Ee(js(e), o),
      }),
  }),
  Jp = B({
    name: "ungroup",
    label: "labels.ungroup",
    icon: (e) => Jn(Om, { theme: e.theme }),
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => {
      let n = $s(o),
        i = jp(e);
      if (n.length === 0) return { appState: o, elements: e, captureUpdate: Ia.EVENTUALLY };
      let a = [...e],
        l = [];
      a = a.map((p) => {
        Kk(p) && l.push(p.id);
        let u = iM(p.groupIds, o.selectedGroupIds);
        return u.length === p.groupIds.length ? p : oE(p, { groupIds: u });
      });
      let s = rM(o, js(a), o, null),
        d = r.scene.getSelectedElements(o),
        m = new Set(d.filter((p) => p.frameId).map((p) => p.frameId));
      return (
        jk(e)
          .filter((p) => m.has(p.id))
          .forEach((p) => {
            p && (a = eM(a, $k(a, p, o, i), p, r));
          }),
        (s.selectedElementIds = Object.entries(s.selectedElementIds).reduce(
          (p, [u, f]) => (f && !l.includes(u) && (p[u] = !0), p),
          {}
        )),
        { appState: { ...o, ...s }, elements: a, captureUpdate: Ia.IMMEDIATELY }
      );
    },
    keyTest: (e) => e.shiftKey && e[qs.CTRL_OR_CMD] && e.key === qs.G.toUpperCase(),
    predicate: (e, o) => $s(o).length > 0,
    PanelComponent: ({ elements: e, appState: o, updateData: t }) =>
      Jn(V, {
        type: "button",
        hidden: $s(o).length === 0,
        icon: Jn(Om, { theme: o.theme }),
        onClick: () => t(null),
        title: `${g("labels.ungroup")} \u2014 ${rE("CtrlOrCmd+Shift+G")}`,
        "aria-label": g("labels.ungroup"),
        visible: Ee(js(e), o),
      }),
  });
import hM from "clsx";
import { CaptureUpdateAction as cE } from "@excalidraw/element";
import {
  COLOR_CHARCOAL_BLACK as sM,
  COLOR_VOICE_CALL as cM,
  COLOR_WHITE as Qs,
  THEME as dM,
  UserIdleState as iE,
} from "@excalidraw/common";
var Js = (e, o, t, r, n, i, a) => {
  e.beginPath(),
    e.moveTo(o + i, t),
    e.lineTo(o + r - i, t),
    e.quadraticCurveTo(o + r, t, o + r, t + i),
    e.lineTo(o + r, t + n - i),
    e.quadraticCurveTo(o + r, t + n, o + r - i, t + n),
    e.lineTo(o + i, t + n),
    e.quadraticCurveTo(o, t + n, o, t + n - i),
    e.lineTo(o, t + i),
    e.quadraticCurveTo(o, t, o + i, t),
    e.closePath(),
    e.fill(),
    a && (e.strokeStyle = a),
    e.stroke();
};
function mM(e) {
  let o = 0;
  if (e.length === 0) return o;
  for (let t = 0; t < e.length; t++) {
    let r = e.charCodeAt(t);
    o = (o << 5) - o + r;
  }
  return o;
}
var Qr = (e, o) => `hsl(${(Math.abs(mM(o?.id || e)) % 37) * 10}, 100%, 83%)`,
  aE = (e) => {
    let o = e?.trim()?.codePointAt(0);
    return (o ? String.fromCodePoint(o) : "?").toUpperCase();
  },
  lE = ({ context: e, renderConfig: o, appState: t, normalizedWidth: r, normalizedHeight: n }) => {
    for (let [i, a] of o.remotePointerViewportCoords) {
      let { x: l, y: s } = a,
        d = t.collaborators.get(i);
      (l -= t.offsetLeft), (s -= t.offsetTop);
      let m = 11,
        c = 14,
        p = l < 0 || l > r - m || s < 0 || s > n - c;
      (l = Math.max(l, 0)),
        (l = Math.min(l, r - m)),
        (s = Math.max(s, 0)),
        (s = Math.min(s, n - c));
      let u = Qr(i, d);
      e.save(), (e.strokeStyle = u), (e.fillStyle = u);
      let f = o.remotePointerUserStates.get(i),
        b = p || f === iE.IDLE || f === iE.AWAY;
      b && (e.globalAlpha = 0.3),
        o.remotePointerButton.get(i) === "down" &&
          (e.beginPath(),
          e.arc(l, s, 15, 0, 2 * Math.PI, !1),
          (e.lineWidth = 3),
          (e.strokeStyle = "#ffffff88"),
          e.stroke(),
          e.closePath(),
          e.beginPath(),
          e.arc(l, s, 15, 0, 2 * Math.PI, !1),
          (e.lineWidth = 1),
          (e.strokeStyle = u),
          e.stroke(),
          e.closePath());
      let x = t.theme === dM.DARK ? "#2f6330" : cM,
        w = d?.isSpeaking;
      w &&
        ((e.fillStyle = x),
        (e.strokeStyle = x),
        (e.lineWidth = 10),
        (e.lineJoin = "round"),
        e.beginPath(),
        e.moveTo(l, s),
        e.lineTo(l + 0, s + 14),
        e.lineTo(l + 4, s + 9),
        e.lineTo(l + 11, s + 8),
        e.closePath(),
        e.stroke(),
        e.fill()),
        (e.fillStyle = Qs),
        (e.strokeStyle = Qs),
        (e.lineWidth = 6),
        (e.lineJoin = "round"),
        e.beginPath(),
        e.moveTo(l, s),
        e.lineTo(l + 0, s + 14),
        e.lineTo(l + 4, s + 9),
        e.lineTo(l + 11, s + 8),
        e.closePath(),
        e.stroke(),
        e.fill(),
        (e.fillStyle = u),
        (e.strokeStyle = u),
        (e.lineWidth = 2),
        (e.lineJoin = "round"),
        e.beginPath(),
        b
          ? (e.moveTo(l - 1, s - 1),
            e.lineTo(l - 1, s + 15),
            e.lineTo(l + 5, s + 10),
            e.lineTo(l + 12, s + 9),
            e.closePath(),
            e.fill())
          : (e.moveTo(l, s),
            e.lineTo(l + 0, s + 14),
            e.lineTo(l + 4, s + 9),
            e.lineTo(l + 11, s + 8),
            e.closePath(),
            e.fill(),
            e.stroke());
      let E = o.remotePointerUsernames.get(i) || "";
      if (!p && E) {
        e.font = "600 12px sans-serif";
        let y = (w ? l + 0 : l) + m / 2,
          v = (w ? s + 0 : s) + c + 2,
          C = 5,
          S = 3,
          M = e.measureText(E),
          k = M.actualBoundingBoxDescent + M.actualBoundingBoxAscent,
          A = Math.max(k, 12),
          P = y - 1,
          N = v - 1,
          O = M.width + 2 + C * 2 + 2,
          U = A + 2 + S * 2 + 2;
        if (
          (e.roundRect
            ? (e.beginPath(),
              e.roundRect(P, N, O, U, 8),
              (e.fillStyle = u),
              e.fill(),
              (e.strokeStyle = Qs),
              e.stroke(),
              w &&
                (e.beginPath(),
                e.roundRect(P - 2, N - 2, O + 4, U + 4, 8),
                (e.strokeStyle = x),
                e.stroke()))
            : Js(e, P, N, O, U, 8, Qs),
          (e.fillStyle = sM),
          e.fillText(E, y + C + 1, v + S + M.actualBoundingBoxAscent + Math.floor((A - k) / 2) + 2),
          w)
        ) {
          e.fillStyle = x;
          let J = 8,
            _ = 8,
            R = 5;
          e.fillRect(P + O + _, N + (U / 2 - J / 2), 2, J),
            e.fillRect(P + O + _ + R, N + (U / 2 - (J * 2) / 2), 2, J * 2),
            e.fillRect(P + O + _ + R * 2, N + (U / 2 - J / 2), 2, J);
        }
      }
      e.restore(), e.closePath();
    }
  };
import pM from "clsx";
import { useState as uM } from "react";
import { jsx as sE } from "react/jsx-runtime";
var Qp = ({ color: e, onClick: o, name: t, src: r, className: n }) => {
  let i = aE(t),
    [a, l] = uM(!1),
    s = !a && r,
    d = s ? void 0 : { background: e };
  return sE("div", {
    className: pM("Avatar", n),
    style: d,
    onClick: o,
    children: s
      ? sE("img", {
          className: "Avatar-img",
          src: r,
          alt: i,
          referrerPolicy: "no-referrer",
          onError: () => l(!0),
        })
      : i,
  });
};
import { jsx as yo, jsxs as ec } from "react/jsx-runtime";
var gM = B({
  name: "goToCollaborator",
  label: "Go to a collaborator",
  viewMode: !0,
  trackEvent: { category: "collab" },
  perform: (e, o, t) =>
    !t.socketId || o.userToFollow?.socketId === t.socketId || t.isCurrentUser
      ? { appState: { ...o, userToFollow: null }, captureUpdate: cE.EVENTUALLY }
      : {
          appState: {
            ...o,
            userToFollow: { socketId: t.socketId, username: t.username || "" },
            openMenu: o.openMenu === "canvas" ? null : o.openMenu,
          },
          captureUpdate: cE.EVENTUALLY,
        },
  PanelComponent: ({ updateData: e, data: o, appState: t }) => {
    let { socketId: r, collaborator: n, withName: i, isBeingFollowed: a } = o,
      l = Qr(r, n),
      s = hM({
        "is-followed": a,
        "is-current-user": n.isCurrentUser === !0,
        "is-speaking": n.isSpeaking,
        "is-in-call": n.isInCall,
        "is-muted": n.isMuted,
      }),
      d = n.isInCall
        ? n.isSpeaking
          ? ec("div", {
              className: "UserList__collaborator-status-icon-speaking-indicator",
              title: g("userList.hint.isSpeaking"),
              children: [yo("div", {}), yo("div", {}), yo("div", {})],
            })
          : n.isMuted
          ? yo("div", {
              className: "UserList__collaborator-status-icon-microphone-muted",
              title: g("userList.hint.micMuted"),
              children: Z0,
            })
          : yo("div", { title: g("userList.hint.inCall"), children: K0 })
        : null;
    return i
      ? ec("div", {
          className: `dropdown-menu-item dropdown-menu-item-base UserList__collaborator ${s}`,
          style: { "--avatar-size": "1.5rem" },
          onClick: () => e(n),
          children: [
            yo(Qp, {
              color: l,
              onClick: () => {},
              name: n.username || "",
              src: n.avatarUrl,
              className: s,
            }),
            yo("div", { className: "UserList__collaborator-name", children: n.username }),
            ec("div", {
              className: "UserList__collaborator-status-icons",
              "aria-hidden": !0,
              children: [
                a &&
                  yo("div", {
                    className: "UserList__collaborator-status-icon-is-followed",
                    title: g("userList.hint.followStatus"),
                    children: An,
                  }),
                d,
              ],
            }),
          ],
        })
      : ec("div", {
          className: `UserList__collaborator UserList__collaborator--avatar-only ${s}`,
          children: [
            yo(Qp, {
              color: l,
              onClick: () => {
                e(n);
              },
              name: n.username || "",
              src: n.avatarUrl,
              className: s,
            }),
            d && yo("div", { className: "UserList__collaborator-status-icon", children: d }),
          ],
        });
  },
});
import { LIBRARY_DISABLED_TYPES as fM, randomId as bM } from "@excalidraw/common";
import { deepCopyElement as xM } from "@excalidraw/element";
import { CaptureUpdateAction as eu } from "@excalidraw/element";
var tu = B({
  name: "addToLibrary",
  trackEvent: { category: "element" },
  perform: (e, o, t, r) => {
    let n = r.scene.getSelectedElements({
      selectedElementIds: o.selectedElementIds,
      includeBoundTextElement: !0,
      includeElementsInFrames: !0,
    });
    for (let i of fM)
      if (n.some((a) => a.type === i))
        return {
          captureUpdate: eu.EVENTUALLY,
          appState: { ...o, errorMessage: g(`errors.libraryElementTypeError.${i}`) },
        };
    return r.library
      .getLatestLibrary()
      .then((i) =>
        r.library.setLibrary([
          { id: bM(), status: "unpublished", elements: n.map(xM), created: Date.now() },
          ...i,
        ])
      )
      .then(() => ({
        captureUpdate: eu.EVENTUALLY,
        appState: { ...o, toast: { message: g("toast.addedToLibrary") } },
      }))
      .catch((i) => ({
        captureUpdate: eu.EVENTUALLY,
        appState: { ...o, errorMessage: i.message },
      }));
  },
  label: "labels.addToLibrary",
});
import { getNonDeletedElements as Qn } from "@excalidraw/element";
import { isFrameLikeElement as EM } from "@excalidraw/element";
import { updateFrameMembershipOfSelectedElements as yM } from "@excalidraw/element";
import { KEYS as mr, arrayToMap as wM, getShortcutKey as tc } from "@excalidraw/common";
import { alignElements as vM } from "@excalidraw/element";
import { CaptureUpdateAction as ei } from "@excalidraw/element";
import { jsx as oi } from "react/jsx-runtime";
var wt = (e, o) => {
    let t = o.scene.getSelectedElements(e);
    return t.length > 1 && !t.some((r) => EM(r));
  },
  ti = (e, o, t, r) => {
    let n = t.scene.getSelectedElements(o),
      i = vM(n, r, t.scene),
      a = wM(i);
    return yM(
      e.map((l) => a.get(l.id) || l),
      o,
      t
    );
  },
  TM = B({
    name: "alignTop",
    label: "labels.alignTop",
    icon: Am,
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => wt(o, r),
    perform: (e, o, t, r) => ({
      appState: o,
      elements: ti(e, o, r, { position: "start", axis: "y" }),
      captureUpdate: ei.IMMEDIATELY,
    }),
    keyTest: (e) => e[mr.CTRL_OR_CMD] && e.shiftKey && e.key === mr.ARROW_UP,
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      oi(V, {
        hidden: !wt(o, r),
        type: "button",
        icon: Am,
        onClick: () => t(null),
        title: `${g("labels.alignTop")} \u2014 ${tc("CtrlOrCmd+Shift+Up")}`,
        "aria-label": g("labels.alignTop"),
        visible: Ee(Qn(e), o),
      }),
  }),
  IM = B({
    name: "alignBottom",
    label: "labels.alignBottom",
    icon: Dm,
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => wt(o, r),
    perform: (e, o, t, r) => ({
      appState: o,
      elements: ti(e, o, r, { position: "end", axis: "y" }),
      captureUpdate: ei.IMMEDIATELY,
    }),
    keyTest: (e) => e[mr.CTRL_OR_CMD] && e.shiftKey && e.key === mr.ARROW_DOWN,
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      oi(V, {
        hidden: !wt(o, r),
        type: "button",
        icon: Dm,
        onClick: () => t(null),
        title: `${g("labels.alignBottom")} \u2014 ${tc("CtrlOrCmd+Shift+Down")}`,
        "aria-label": g("labels.alignBottom"),
        visible: Ee(Qn(e), o),
      }),
  }),
  CM = B({
    name: "alignLeft",
    label: "labels.alignLeft",
    icon: _m,
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => wt(o, r),
    perform: (e, o, t, r) => ({
      appState: o,
      elements: ti(e, o, r, { position: "start", axis: "x" }),
      captureUpdate: ei.IMMEDIATELY,
    }),
    keyTest: (e) => e[mr.CTRL_OR_CMD] && e.shiftKey && e.key === mr.ARROW_LEFT,
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      oi(V, {
        hidden: !wt(o, r),
        type: "button",
        icon: _m,
        onClick: () => t(null),
        title: `${g("labels.alignLeft")} \u2014 ${tc("CtrlOrCmd+Shift+Left")}`,
        "aria-label": g("labels.alignLeft"),
        visible: Ee(Qn(e), o),
      }),
  }),
  SM = B({
    name: "alignRight",
    label: "labels.alignRight",
    icon: Rm,
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => wt(o, r),
    perform: (e, o, t, r) => ({
      appState: o,
      elements: ti(e, o, r, { position: "end", axis: "x" }),
      captureUpdate: ei.IMMEDIATELY,
    }),
    keyTest: (e) => e[mr.CTRL_OR_CMD] && e.shiftKey && e.key === mr.ARROW_RIGHT,
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      oi(V, {
        hidden: !wt(o, r),
        type: "button",
        icon: Rm,
        onClick: () => t(null),
        title: `${g("labels.alignRight")} \u2014 ${tc("CtrlOrCmd+Shift+Right")}`,
        "aria-label": g("labels.alignRight"),
        visible: Ee(Qn(e), o),
      }),
  }),
  kM = B({
    name: "alignVerticallyCentered",
    label: "labels.centerVertically",
    icon: Nm,
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => wt(o, r),
    perform: (e, o, t, r) => ({
      appState: o,
      elements: ti(e, o, r, { position: "center", axis: "y" }),
      captureUpdate: ei.IMMEDIATELY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      oi(V, {
        hidden: !wt(o, r),
        type: "button",
        icon: Nm,
        onClick: () => t(null),
        title: g("labels.centerVertically"),
        "aria-label": g("labels.centerVertically"),
        visible: Ee(Qn(e), o),
      }),
  }),
  MM = B({
    name: "alignHorizontallyCentered",
    label: "labels.centerHorizontally",
    icon: Bm,
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => wt(o, r),
    perform: (e, o, t, r) => ({
      appState: o,
      elements: ti(e, o, r, { position: "center", axis: "x" }),
      captureUpdate: ei.IMMEDIATELY,
    }),
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      oi(V, {
        hidden: !wt(o, r),
        type: "button",
        icon: Bm,
        onClick: () => t(null),
        title: g("labels.centerHorizontally"),
        "aria-label": g("labels.centerHorizontally"),
        visible: Ee(Qn(e), o),
      }),
  });
import { getNonDeletedElements as dE } from "@excalidraw/element";
import { isFrameLikeElement as LM } from "@excalidraw/element";
import {
  CODES as mE,
  KEYS as pE,
  arrayToMap as PM,
  getShortcutKey as uE,
} from "@excalidraw/common";
import { updateFrameMembershipOfSelectedElements as AM } from "@excalidraw/element";
import { distributeElements as DM } from "@excalidraw/element";
import { CaptureUpdateAction as hE } from "@excalidraw/element";
import { jsx as bE } from "react/jsx-runtime";
var gE = (e, o) => {
    let t = o.scene.getSelectedElements(e);
    return t.length > 1 && !t.some((r) => LM(r));
  },
  fE = (e, o, t, r) => {
    let n = t.scene.getSelectedElements(o),
      i = DM(n, t.scene.getNonDeletedElementsMap(), r),
      a = PM(i);
    return AM(
      e.map((l) => a.get(l.id) || l),
      o,
      t
    );
  },
  _M = B({
    name: "distributeHorizontally",
    label: "labels.distributeHorizontally",
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => ({
      appState: o,
      elements: fE(e, o, r, { space: "between", axis: "x" }),
      captureUpdate: hE.IMMEDIATELY,
    }),
    keyTest: (e) => !e[pE.CTRL_OR_CMD] && e.altKey && e.code === mE.H,
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      bE(V, {
        hidden: !gE(o, r),
        type: "button",
        icon: q1,
        onClick: () => t(null),
        title: `${g("labels.distributeHorizontally")} \u2014 ${uE("Alt+H")}`,
        "aria-label": g("labels.distributeHorizontally"),
        visible: Ee(dE(e), o),
      }),
  }),
  RM = B({
    name: "distributeVertically",
    label: "labels.distributeVertically",
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => ({
      appState: o,
      elements: fE(e, o, r, { space: "between", axis: "y" }),
      captureUpdate: hE.IMMEDIATELY,
    }),
    keyTest: (e) => !e[pE.CTRL_OR_CMD] && e.altKey && e.code === mE.V,
    PanelComponent: ({ elements: e, appState: o, updateData: t, app: r }) =>
      bE(V, {
        hidden: !gE(o, r),
        type: "button",
        icon: J1,
        onClick: () => t(null),
        title: `${g("labels.distributeVertically")} \u2014 ${uE("Alt+V")}`,
        "aria-label": g("labels.distributeVertically"),
        visible: Ee(dE(e), o),
      }),
  });
import { getNonDeletedElements as NM } from "@excalidraw/element";
import { bindOrUnbindLinearElements as BM, isBindingEnabled as FM } from "@excalidraw/element";
import { getCommonBoundingBox as xE } from "@excalidraw/element";
import { newElementWith as OM } from "@excalidraw/element";
import { deepCopyElement as zM } from "@excalidraw/element";
import { resizeMultipleElements as HM } from "@excalidraw/element";
import {
  isArrowElement as GM,
  isElbowArrow as UM,
  isLinearElement as YM,
} from "@excalidraw/element";
import { updateFrameMembershipOfSelectedElements as EE } from "@excalidraw/element";
import { CODES as yE, KEYS as WM, arrayToMap as VM } from "@excalidraw/common";
import { CaptureUpdateAction as wE } from "@excalidraw/element";
var ou = B({
    name: "flipHorizontal",
    label: "labels.flipHorizontal",
    icon: J0,
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => ({
      elements: EE(vE(e, r.scene.getNonDeletedElementsMap(), o, "horizontal", r), o, r),
      appState: o,
      captureUpdate: wE.IMMEDIATELY,
    }),
    keyTest: (e) => e.shiftKey && e.code === yE.H,
  }),
  ru = B({
    name: "flipVertical",
    label: "labels.flipVertical",
    icon: q0,
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => ({
      elements: EE(vE(e, r.scene.getNonDeletedElementsMap(), o, "vertical", r), o, r),
      appState: o,
      captureUpdate: wE.IMMEDIATELY,
    }),
    keyTest: (e) => e.shiftKey && e.code === yE.V && !e[WM.CTRL_OR_CMD],
  }),
  vE = (e, o, t, r, n) => {
    let i = Z(NM(e), t, { includeBoundTextElement: !0, includeElementsInFrames: !0 }),
      a = XM(i, o, t, r, n),
      l = VM(a);
    return e.map((s) => l.get(s.id) || s);
  },
  XM = (e, o, t, r, n) => {
    if (e.every((u) => GM(u) && (u.startBinding || u.endBinding)))
      return e.map((u) => {
        let f = u;
        return OM(f, { startArrowhead: f.endArrowhead, endArrowhead: f.startArrowhead });
      });
    let { midX: i, midY: a } = xE(e);
    HM(e, o, "nw", n.scene, new Map(Array.from(o.values()).map((u) => [u.id, zM(u)])), {
      flipByX: r === "horizontal",
      flipByY: r === "vertical",
      shouldResizeFromCenter: !0,
      shouldMaintainAspectRatio: !0,
    }),
      BM(e.filter(YM), FM(t), [], n.scene, t.zoom);
    let { elbowArrows: l, otherElements: s } = e.reduce(
        (u, f) =>
          UM(f)
            ? { ...u, elbowArrows: u.elbowArrows.concat(f) }
            : { ...u, otherElements: u.otherElements.concat(f) },
        { elbowArrows: [], otherElements: [] }
      ),
      { midX: d, midY: m } = xE(e),
      [c, p] = [i - d, a - m];
    return (
      s.forEach((u) => n.scene.mutateElement(u, { x: u.x + c, y: u.y + p })),
      l.forEach((u) => n.scene.mutateElement(u, { x: u.x + c, y: u.y + p })),
      e
    );
  };
import { isTextElement as KM } from "@excalidraw/element";
import { getTextFromElements as ZM } from "@excalidraw/element";
import { CODES as $M, KEYS as TE, isFirefox as jM } from "@excalidraw/common";
import { CaptureUpdateAction as Dt } from "@excalidraw/element";
var ri = B({
    name: "copy",
    label: "labels.copy",
    icon: ji,
    trackEvent: { category: "element" },
    perform: async (e, o, t, r) => {
      let n = r.scene.getSelectedElements({
        selectedElementIds: o.selectedElementIds,
        includeBoundTextElement: !0,
        includeElementsInFrames: !0,
      });
      try {
        await Ws(n, r.files, t);
      } catch (i) {
        return { captureUpdate: Dt.EVENTUALLY, appState: { ...o, errorMessage: i.message } };
      }
      return { captureUpdate: Dt.EVENTUALLY };
    },
    keyTest: void 0,
  }),
  nu = B({
    name: "paste",
    label: "labels.paste",
    trackEvent: { category: "element" },
    perform: async (e, o, t, r) => {
      let n;
      try {
        n = await Vx();
      } catch (i) {
        return i.name === "AbortError" || i.name === "NotAllowedError"
          ? !1
          : (console.error(`actionPaste ${i.name}: ${i.message}`),
            jM
              ? {
                  captureUpdate: Dt.EVENTUALLY,
                  appState: { ...o, errorMessage: g("hints.firefox_clipboard_write") },
                }
              : {
                  captureUpdate: Dt.EVENTUALLY,
                  appState: { ...o, errorMessage: g("errors.asyncPasteFailedOnRead") },
                });
      }
      try {
        r.pasteFromClipboard(Yx({ types: n }));
      } catch (i) {
        return (
          console.error(i),
          {
            captureUpdate: Dt.EVENTUALLY,
            appState: { ...o, errorMessage: g("errors.asyncPasteFailedOnParse") },
          }
        );
      }
      return { captureUpdate: Dt.EVENTUALLY };
    },
    keyTest: void 0,
  }),
  oc = B({
    name: "cut",
    label: "labels.cut",
    icon: B0,
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => (ri.perform(e, o, t, r), ia.perform(e, o, null, r)),
    keyTest: (e) => e[TE.CTRL_OR_CMD] && e.key === TE.X,
  }),
  rc = B({
    name: "copyAsSvg",
    label: "labels.copyAsSvg",
    icon: Q0,
    trackEvent: { category: "element" },
    perform: async (e, o, t, r) => {
      if (!r.canvas) return { captureUpdate: Dt.EVENTUALLY };
      let { exportedElements: n, exportingFrame: i } = $r(e, o, !0);
      try {
        await jr("clipboard-svg", n, o, r.files, { ...o, exportingFrame: i, name: r.getName() });
        let a = r.scene.getSelectedElements({
          selectedElementIds: o.selectedElementIds,
          includeBoundTextElement: !0,
          includeElementsInFrames: !0,
        });
        return {
          appState: {
            toast: {
              message: g("toast.copyToClipboardAsSvg", {
                exportSelection: a.length ? g("toast.selection") : g("toast.canvas"),
                exportColorScheme: o.exportWithDarkMode
                  ? g("buttons.darkMode")
                  : g("buttons.lightMode"),
              }),
            },
          },
          captureUpdate: Dt.EVENTUALLY,
        };
      } catch (a) {
        return (
          console.error(a), { appState: { errorMessage: a.message }, captureUpdate: Dt.EVENTUALLY }
        );
      }
    },
    predicate: (e) => Ys && e.length > 0,
    keywords: ["svg", "clipboard", "copy"],
  }),
  nc = B({
    name: "copyAsPng",
    label: "labels.copyAsPng",
    icon: eb,
    trackEvent: { category: "element" },
    perform: async (e, o, t, r) => {
      if (!r.canvas) return { captureUpdate: Dt.EVENTUALLY };
      let n = r.scene.getSelectedElements({
          selectedElementIds: o.selectedElementIds,
          includeBoundTextElement: !0,
          includeElementsInFrames: !0,
        }),
        { exportedElements: i, exportingFrame: a } = $r(e, o, !0);
      try {
        return (
          await jr("clipboard", i, o, r.files, { ...o, exportingFrame: a, name: r.getName() }),
          {
            appState: {
              ...o,
              toast: {
                message: g("toast.copyToClipboardAsPng", {
                  exportSelection: n.length ? g("toast.selection") : g("toast.canvas"),
                  exportColorScheme: o.exportWithDarkMode
                    ? g("buttons.darkMode")
                    : g("buttons.lightMode"),
                }),
              },
            },
            captureUpdate: Dt.EVENTUALLY,
          }
        );
      } catch (l) {
        return (
          console.error(l),
          { appState: { ...o, errorMessage: l.message }, captureUpdate: Dt.EVENTUALLY }
        );
      }
    },
    predicate: (e) => $n && e.length > 0,
    keyTest: (e) => e.code === $M.C && e.altKey && e.shiftKey,
    keywords: ["png", "clipboard", "copy"],
  }),
  ic = B({
    name: "copyText",
    label: "labels.copyText",
    trackEvent: { category: "element" },
    perform: (e, o, t, r) => {
      let n = r.scene.getSelectedElements({
        selectedElementIds: o.selectedElementIds,
        includeBoundTextElement: !0,
      });
      try {
        ro(ZM(n));
      } catch {
        throw new Error(g("errors.copyToSystemClipboardFailed"));
      }
      return { captureUpdate: Dt.EVENTUALLY };
    },
    predicate: (e, o, t, r) =>
      Ys &&
      r.scene
        .getSelectedElements({
          selectedElementIds: o.selectedElementIds,
          includeBoundTextElement: !0,
        })
        .some(KM),
    keywords: ["text", "clipboard", "copy"],
  });
import { CODES as qM, KEYS as JM } from "@excalidraw/common";
import { CaptureUpdateAction as QM } from "@excalidraw/element";
var ac = B({
  name: "gridMode",
  icon: ib,
  keywords: ["snap"],
  label: "labels.toggleGrid",
  viewMode: !0,
  trackEvent: { category: "canvas", predicate: (e) => e.gridModeEnabled },
  perform(e, o) {
    return {
      appState: { ...o, gridModeEnabled: !this.checked(o), objectsSnapModeEnabled: !1 },
      captureUpdate: QM.EVENTUALLY,
    };
  },
  checked: (e) => e.gridModeEnabled,
  predicate: (e, o, t) => t.gridModeEnabled === void 0,
  keyTest: (e) => e[JM.CTRL_OR_CMD] && e.code === qM.QUOTE,
});
import { CODES as eL, KEYS as tL } from "@excalidraw/common";
import { CaptureUpdateAction as oL } from "@excalidraw/element";
var ni = B({
  name: "zenMode",
  label: "buttons.zenMode",
  icon: ob,
  viewMode: !0,
  trackEvent: { category: "canvas", predicate: (e) => !e.zenModeEnabled },
  perform(e, o) {
    return { appState: { ...o, zenModeEnabled: !this.checked(o) }, captureUpdate: oL.EVENTUALLY };
  },
  checked: (e) => e.zenModeEnabled,
  predicate: (e, o, t) => typeof t.zenModeEnabled > "u",
  keyTest: (e) => !e[tL.CTRL_OR_CMD] && e.altKey && e.code === eL.Z,
});
import { CODES as rL, KEYS as nL } from "@excalidraw/common";
import { CaptureUpdateAction as iL } from "@excalidraw/element";
var iu = B({
  name: "objectsSnapMode",
  label: "buttons.objectsSnapMode",
  icon: tb,
  viewMode: !1,
  trackEvent: { category: "canvas", predicate: (e) => !e.objectsSnapModeEnabled },
  perform(e, o) {
    return {
      appState: { ...o, objectsSnapModeEnabled: !this.checked(o), gridModeEnabled: !1 },
      captureUpdate: iL.EVENTUALLY,
    };
  },
  checked: (e) => e.objectsSnapModeEnabled,
  predicate: (e, o, t) => typeof t.objectsSnapModeEnabled > "u",
  keyTest: (e) => !e[nL.CTRL_OR_CMD] && e.altKey && e.code === rL.S,
});
import { CODES as aL, KEYS as lL } from "@excalidraw/common";
import { CaptureUpdateAction as sL } from "@excalidraw/element";
var ii = B({
  name: "stats",
  label: "stats.fullTitle",
  icon: j0,
  viewMode: !0,
  trackEvent: { category: "menu" },
  keywords: ["edit", "attributes", "customize"],
  perform(e, o) {
    return {
      appState: { ...o, stats: { ...o.stats, open: !this.checked(o) } },
      captureUpdate: sL.EVENTUALLY,
    };
  },
  checked: (e) => e.stats.open,
  keyTest: (e) => !e[lL.CTRL_OR_CMD] && e.altKey && e.code === aL.SLASH,
});
import {
  BOUND_TEXT_PADDING as IE,
  ROUNDNESS as CE,
  TEXT_ALIGN as kE,
  VERTICAL_ALIGN as ME,
  arrayToMap as LE,
  getFontString as cL,
} from "@excalidraw/common";
import {
  getOriginalContainerHeightFromCache as dL,
  resetOriginalContainerCache as mL,
  updateOriginalContainerCache as pL,
} from "@excalidraw/element";
import {
  computeBoundTextPosition as uL,
  computeContainerDimensionForBoundText as SE,
  getBoundTextElement as PE,
  redrawTextBoundingBox as AE,
} from "@excalidraw/element";
import {
  hasBoundTextElement as hL,
  isArrowElement as gL,
  isTextBindableContainer as au,
  isTextElement as Ca,
  isUsingAdaptiveRadius as fL,
} from "@excalidraw/element";
import { measureText as bL } from "@excalidraw/element";
import { syncMovedIndices as DE } from "@excalidraw/element";
import { newElement as xL } from "@excalidraw/element";
import { CaptureUpdateAction as lu } from "@excalidraw/element";
var su = B({
    name: "unbindText",
    label: "labels.unbindText",
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => r.scene.getSelectedElements(o).some((i) => hL(i)),
    perform: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o),
        i = r.scene.getNonDeletedElementsMap();
      return (
        n.forEach((a) => {
          let l = PE(a, i);
          if (l) {
            let { width: s, height: d } = bL(l.originalText, cL(l), l.lineHeight),
              m = dL(a.id);
            mL(a.id);
            let { x: c, y: p } = uL(a, l, i);
            r.scene.mutateElement(l, {
              containerId: null,
              width: s,
              height: d,
              text: l.originalText,
              x: c,
              y: p,
            }),
              r.scene.mutateElement(a, {
                boundElements: a.boundElements?.filter((u) => u.id !== l.id),
                height: m || a.height,
              });
          }
        }),
        { elements: e, appState: o, captureUpdate: lu.IMMEDIATELY }
      );
    },
  }),
  cu = B({
    name: "bindText",
    label: "labels.bindText",
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o);
      if (n.length === 2) {
        let i = Ca(n[0]) || Ca(n[1]),
          a;
        if (
          (au(n[0]) ? (a = n[0]) : au(n[1]) && (a = n[1]),
          i && a && PE(a, r.scene.getNonDeletedElementsMap()) === null)
        )
          return !0;
      }
      return !1;
    },
    perform: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o),
        i,
        a;
      Ca(n[0]) && au(n[1]) ? ((i = n[0]), (a = n[1])) : ((i = n[1]), (a = n[0])),
        r.scene.mutateElement(i, {
          containerId: a.id,
          verticalAlign: ME.MIDDLE,
          textAlign: kE.CENTER,
          autoResize: !0,
          angle: gL(a) ? 0 : a?.angle ?? 0,
        }),
        r.scene.mutateElement(a, {
          boundElements: (a.boundElements || []).concat({ type: "text", id: i.id }),
        });
      let l = a.height;
      return (
        AE(i, a, r.scene),
        pL(a.id, l),
        {
          elements: EL(e, a, i),
          appState: { ...o, selectedElementIds: { [a.id]: !0 } },
          captureUpdate: lu.IMMEDIATELY,
        }
      );
    },
  }),
  EL = (e, o, t) => {
    let r = e.slice(),
      n = r.findIndex((a) => a.id === t.id);
    r.splice(n, 1);
    let i = r.findIndex((a) => a.id === o.id);
    return r.splice(i + 1, 0, t), DE(r, LE([o, t])), r;
  },
  yL = (e, o, t) => {
    let r = e.slice(),
      n = r.findIndex((a) => a.id === o.id);
    r.splice(n, 1);
    let i = r.findIndex((a) => a.id === t.id);
    return r.splice(i, 0, o), DE(r, LE([o, t])), r;
  },
  _E = B({
    name: "wrapTextInContainer",
    label: "labels.createContainerFromText",
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o),
        i = n.some((a) => Ca(a));
      return n.length > 0 && i;
    },
    perform: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o),
        i = e.slice(),
        a = {};
      for (let l of n)
        if (Ca(l)) {
          let s = xL({
            type: "rectangle",
            backgroundColor: o.currentItemBackgroundColor,
            boundElements: [...(l.boundElements || []), { id: l.id, type: "text" }],
            angle: l.angle,
            fillStyle: o.currentItemFillStyle,
            strokeColor: o.currentItemStrokeColor,
            roughness: o.currentItemRoughness,
            strokeWidth: o.currentItemStrokeWidth,
            strokeStyle: o.currentItemStrokeStyle,
            roundness:
              o.currentItemRoundness === "round"
                ? { type: fL("rectangle") ? CE.ADAPTIVE_RADIUS : CE.PROPORTIONAL_RADIUS }
                : null,
            opacity: 100,
            locked: !1,
            x: l.x - IE,
            y: l.y - IE,
            width: SE(l.width, "rectangle"),
            height: SE(l.height, "rectangle"),
            groupIds: l.groupIds,
            frameId: l.frameId,
          });
          if (l.boundElements?.length) {
            let d = l.boundElements.filter((c) => c.type === "arrow").map((c) => c.id);
            i.filter((c) => d.includes(c.id)).forEach((c) => {
              let p = c.startBinding,
                u = c.endBinding;
              p?.elementId === l.id && (p = { ...p, elementId: s.id }),
                u?.elementId === l.id && (u = { ...u, elementId: s.id }),
                (p || u) && r.scene.mutateElement(c, { startBinding: p, endBinding: u });
            });
          }
          r.scene.mutateElement(l, {
            containerId: s.id,
            verticalAlign: ME.MIDDLE,
            boundElements: null,
            textAlign: kE.CENTER,
            autoResize: !0,
          }),
            AE(l, s, r.scene),
            (i = yL([...i, s], s, l)),
            (a[s.id] = !0);
        }
      return {
        elements: i,
        appState: { ...o, selectedElementIds: a },
        captureUpdate: lu.IMMEDIATELY,
      };
    },
  });
import { isEmbeddableElement as FL } from "@excalidraw/element";
import { KEYS as YE, getShortcutKey as OL } from "@excalidraw/common";
import { CaptureUpdateAction as zL } from "@excalidraw/element";
import { pointFrom as FE } from "@excalidraw/math";
import wL from "clsx";
import {
  useCallback as RE,
  useEffect as NE,
  useLayoutEffect as vL,
  useRef as TL,
  useState as IL,
} from "react";
import { EVENT as du, HYPERLINK_TOOLTIP_DELAY as CL, KEYS as lc } from "@excalidraw/common";
import { getElementAbsoluteCoords as gu } from "@excalidraw/element";
import { hitElementBoundingBox as SL } from "@excalidraw/element";
import { isElementLink as kL } from "@excalidraw/element";
import { getEmbedLink as ML, embeddableURLValidator as LL } from "@excalidraw/element";
import {
  sceneCoordsToViewportCoords as OE,
  viewportCoordsToSceneCoords as PL,
  wrapEvent as AL,
  isLocalLink as DL,
  normalizeLink as mu,
} from "@excalidraw/common";
import { isEmbeddableElement as pu } from "@excalidraw/element";
import { jsx as ai, jsxs as BE } from "react/jsx-runtime";
var fu = 380,
  _L = 42,
  uu = 5,
  zE = 85,
  RL = 500,
  hu = !1,
  sc = new Map(),
  HE = ({
    element: e,
    scene: o,
    setAppState: t,
    onLinkOpen: r,
    setToast: n,
    updateEmbedValidationStatus: i,
  }) => {
    let a = o.getNonDeletedElementsMap(),
      l = zt(),
      s = bo(),
      d = ae(),
      m = e.link || "",
      [c, p] = IL(m),
      u = TL(null),
      f = l.showHyperlinkPopup === "editor",
      b = RE(() => {
        if (!u.current) return;
        let v = mu(u.current.value) || null;
        if ((!e.link && v && re("hyperlink", "create"), pu(e))) {
          if ((l.activeEmbeddable?.element === e && t({ activeEmbeddable: null }), !v)) {
            o.mutateElement(e, { link: null }), i(e, !1);
            return;
          }
          if (!LL(v, s.validateEmbeddable))
            v && n({ message: g("toast.unableToEmbed"), closable: !0 }),
              e.link && sc.set(e.id, e.link),
              o.mutateElement(e, { link: v }),
              i(e, !1);
          else {
            let { width: C, height: S } = e,
              M = ML(v);
            M?.error instanceof URIError &&
              n({ message: g("toast.unrecognizedLinkFormat"), closable: !0 });
            let k = M ? M.intrinsicSize.w / M.intrinsicSize.h : 1,
              A = sc.get(e.id) !== e.link;
            o.mutateElement(e, {
              ...(A
                ? {
                    width: M?.type === "video" ? (C > S ? C : S * k) : C,
                    height: M?.type === "video" && C > S ? C / k : S,
                  }
                : {}),
              link: v,
            }),
              i(e, !0),
              sc.has(e.id) && sc.delete(e.id);
          }
        } else o.mutateElement(e, { link: v });
      }, [e, o, n, s.validateEmbeddable, l.activeEmbeddable, t, i]);
    vL(
      () => () => {
        b();
      },
      [b]
    ),
      NE(() => {
        f && u?.current && !(d.viewport.isMobile || d.isTouchScreen) && u.current.select();
      }, [f, d.viewport.isMobile, d.isTouchScreen]),
      NE(() => {
        let v = null,
          C = (S) => {
            if (f) return;
            v && clearTimeout(v),
              BL(e, a, l, FE(S.clientX, S.clientY)) &&
                (v = window.setTimeout(() => {
                  t({ showHyperlinkPopup: !1 });
                }, RL));
          };
        return (
          window.addEventListener(du.POINTER_MOVE, C, !1),
          () => {
            window.removeEventListener(du.POINTER_MOVE, C, !1), v && clearTimeout(v);
          }
        );
      }, [l, e, f, t, a]);
    let x = RE(() => {
        re("hyperlink", "delete"),
          o.mutateElement(e, { link: null }),
          t({ showHyperlinkPopup: !1 });
      }, [t, e, o]),
      w = () => {
        re("hyperlink", "edit", "popup-ui"), t({ showHyperlinkPopup: "editor" });
      },
      { x: E, y } = GE(e, l, a);
    return l.contextMenu ||
      l.selectedElementsAreBeingDragged ||
      l.resizingElement ||
      l.isRotating ||
      l.openMenu ||
      l.viewModeEnabled
      ? null
      : BE("div", {
          className: "excalidraw-hyperlinkContainer",
          style: { top: `${y}px`, left: `${E}px`, width: fu, padding: uu },
          children: [
            f
              ? ai("input", {
                  className: wL("excalidraw-hyperlinkContainer-input"),
                  placeholder: g("labels.link.hint"),
                  ref: u,
                  value: c,
                  onChange: (v) => p(v.target.value),
                  autoFocus: !0,
                  onKeyDown: (v) => {
                    v.stopPropagation(),
                      v[lc.CTRL_OR_CMD] && v.key === lc.K && v.preventDefault(),
                      (v.key === lc.ENTER || v.key === lc.ESCAPE) &&
                        (b(), t({ showHyperlinkPopup: "info" }));
                  },
                })
              : e.link
              ? ai("a", {
                  href: mu(e.link || ""),
                  className: "excalidraw-hyperlinkContainer-link",
                  target: DL(e.link) ? "_self" : "_blank",
                  onClick: (v) => {
                    if (e.link && r) {
                      let C = AL(du.EXCALIDRAW_LINK, v.nativeEvent);
                      r({ ...e, link: mu(e.link) }, C), C.defaultPrevented && v.preventDefault();
                    }
                  },
                  rel: "noopener noreferrer",
                  children: e.link,
                })
              : ai("div", {
                  className: "excalidraw-hyperlinkContainer-link",
                  children: g("labels.link.empty"),
                }),
            BE("div", {
              className: "excalidraw-hyperlinkContainer__buttons",
              children: [
                !f &&
                  ai(V, {
                    type: "button",
                    title: g("buttons.edit"),
                    "aria-label": g("buttons.edit"),
                    label: g("buttons.edit"),
                    onClick: w,
                    className: "excalidraw-hyperlinkContainer--edit",
                    icon: er,
                  }),
                ai(V, {
                  type: "button",
                  title: g("labels.linkToElement"),
                  "aria-label": g("labels.linkToElement"),
                  label: g("labels.linkToElement"),
                  onClick: () => {
                    t({ openDialog: { name: "elementLinkSelector", sourceElementId: e.id } });
                  },
                  icon: ss,
                }),
                m &&
                  !pu(e) &&
                  ai(V, {
                    type: "button",
                    title: g("buttons.remove"),
                    "aria-label": g("buttons.remove"),
                    label: g("buttons.remove"),
                    onClick: x,
                    className: "excalidraw-hyperlinkContainer--remove",
                    icon: kt,
                  }),
              ],
            }),
          ],
        });
  },
  GE = (e, o, t) => {
    let [r, n] = gu(e, t),
      { x: i, y: a } = OE({ sceneX: r + e.width / 2, sceneY: n }, o),
      l = i - o.offsetLeft - fu / 2,
      s = a - o.offsetTop - zE;
    return { x: l, y: s };
  },
  bu = (e, o) => {
    let t = Z(e, o);
    return pu(t[0])
      ? "labels.link.editEmbed"
      : t[0]?.link
      ? "labels.link.edit"
      : "labels.link.create";
  },
  Sa = null,
  UE = (e, o, t) => {
    Sa && clearTimeout(Sa), (Sa = window.setTimeout(() => NL(e, o, t), CL));
  },
  NL = (e, o, t) => {
    if (!e.link) return;
    let r = Xn();
    r.classList.add("excalidraw-tooltip--visible"),
      (r.style.maxWidth = "20rem"),
      (r.textContent = kL(e.link) ? g("labels.link.goToElement") : e.link);
    let [n, i, a, l] = gu(e, t),
      [s, d, m, c] = Qf([n, i, a, l], e.angle, o),
      p = OE({ sceneX: s, sceneY: d }, o);
    Ap(r, { left: p.x, top: p.y, width: m, height: c }, "top"),
      re("hyperlink", "tooltip", "link-icon"),
      (hu = !0);
  },
  xu = () => {
    Sa && clearTimeout(Sa), hu && ((hu = !1), Xn().classList.remove("excalidraw-tooltip--visible"));
  },
  BL = (e, o, t, [r, n]) => {
    let { x: i, y: a } = PL({ clientX: r, clientY: n }, t),
      l = 15 / t.zoom.value;
    if (SL(FE(i, a), e, o)) return !1;
    let [s, d, m] = gu(e, o);
    if (i >= s && i <= m && a >= d - zE && a <= d) return !1;
    let { x: c, y: p } = GE(e, t, o);
    return !(r >= c - l && r <= c + fu + uu * 2 + l && n >= p - l && n <= p + l + uu * 2 + _L);
  };
import { jsx as HL } from "react/jsx-runtime";
var ka = B({
  name: "hyperlink",
  label: (e, o) => bu(e, o),
  icon: Qi,
  perform: (e, o) =>
    o.showHyperlinkPopup === "editor"
      ? !1
      : {
          elements: e,
          appState: { ...o, showHyperlinkPopup: "editor", openMenu: null },
          captureUpdate: zL.IMMEDIATELY,
        },
  trackEvent: { category: "hyperlink", action: "click" },
  keyTest: (e) => e[YE.CTRL_OR_CMD] && e.key === YE.K,
  predicate: (e, o) => Z(e, o).length === 1,
  PanelComponent: ({ elements: e, appState: o, updateData: t }) => {
    let r = Z(e, o);
    return HL(V, {
      type: "button",
      icon: Qi,
      "aria-label": g(bu(e, o)),
      title: `${FL(e[0]) ? g("labels.link.labelEmbed") : g("labels.link.label")} - ${OL(
        "CtrlOrCmd+K"
      )}`,
      onClick: () => t(null),
      selected: r.length === 1 && !!r[0].link,
    });
  },
});
import { KEYS as WE, arrayToMap as yu, randomId as GL } from "@excalidraw/common";
import {
  elementsAreInSameGroup as UL,
  newElementWith as VE,
  selectGroupsFromGivenElements as XE,
} from "@excalidraw/element";
import { CaptureUpdateAction as KE } from "@excalidraw/element";
var Eu = (e) => e.every((o) => !o.locked),
  Ma = B({
    name: "toggleElementLock",
    label: (e, o, t) => {
      let r = t.scene.getSelectedElements({
        selectedElementIds: o.selectedElementIds,
        includeBoundTextElement: !1,
      });
      return Eu(r) ? "labels.elementLock.lock" : "labels.elementLock.unlock";
    },
    icon: (e, o) => {
      let t = Z(o, e);
      return Eu(t) ? Cn : Hr;
    },
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o);
      return n.length > 0 && !n.some((i) => i.locked && i.frameId);
    },
    perform: (e, o, t, r) => {
      let n = r.scene.getSelectedElements({
        selectedElementIds: o.selectedElementIds,
        includeBoundTextElement: !0,
        includeElementsInFrames: !0,
      });
      if (!n.length) return !1;
      let i = Eu(n),
        a = yu(n),
        l = n.length > 1 && UL(n),
        d = n.length === 1 || l ? null : GL(),
        m = { ...o.lockedMultiSelections };
      if (i) m = { ...o.lockedMultiSelections, ...(d ? { [d]: !0 } : {}) };
      else if (l) {
        let w = n[0].groupIds.at(-1);
        delete m[w];
      }
      let c = e.map((w) => {
          if (!a.has(w.id)) return w;
          let E = w.groupIds;
          return (
            i ? d && (E = [...E, d]) : (E = E.filter((y) => !o.lockedMultiSelections[y])),
            VE(w, { locked: i, groupIds: E.length !== w.groupIds.length ? E : w.groupIds })
          );
        }),
        p = yu(c),
        u = i ? {} : Object.fromEntries(n.map((w) => [w.id, !0])),
        f = n.map((w) => p.get(w.id) || w),
        b = i ? {} : XE(f, o),
        x = i ? d || (l ? n[0].groupIds.at(-1) : n[0].id) : null;
      return {
        elements: c,
        appState: {
          ...o,
          selectedElementIds: u,
          selectedGroupIds: b,
          selectedLinearElement: i ? null : o.selectedLinearElement,
          lockedMultiSelections: m,
          activeLockedId: x,
        },
        captureUpdate: KE.IMMEDIATELY,
      };
    },
    keyTest: (e, o, t, r) =>
      e.key.toLocaleLowerCase() === WE.L &&
      e[WE.CTRL_OR_CMD] &&
      e.shiftKey &&
      r.scene.getSelectedElements({
        selectedElementIds: o.selectedElementIds,
        includeBoundTextElement: !1,
      }).length > 0,
  }),
  ZE = B({
    name: "unlockAllElements",
    trackEvent: { category: "canvas" },
    viewMode: !1,
    icon: Hr,
    predicate: (e, o) => Z(e, o).length === 0 && e.some((r) => r.locked),
    perform: (e, o) => {
      let t = e.filter((a) => a.locked),
        r = e.map((a) => {
          if (a.locked) {
            let l = a.groupIds.filter((s) => !o.lockedMultiSelections[s]);
            return VE(a, { locked: !1, groupIds: a.groupIds.length !== l.length ? l : a.groupIds });
          }
          return a;
        }),
        n = yu(r),
        i = t.map((a) => n.get(a.id) || a);
      return {
        elements: r,
        appState: {
          ...o,
          selectedElementIds: Object.fromEntries(t.map((a) => [a.id, !0])),
          selectedGroupIds: XE(i, o),
          lockedMultiSelections: {},
          activeLockedId: null,
        },
        captureUpdate: KE.IMMEDIATELY,
      };
    },
    label: "labels.elementLock.unlockAll",
  });
import { LinearElementEditor as rD } from "@excalidraw/element";
import {
  isElbowArrow as nD,
  isLinearElement as iD,
  isLineElement as Ti,
} from "@excalidraw/element";
import { arrayToMap as $2 } from "@excalidraw/common";
import { toggleLinePolygonState as aD, CaptureUpdateAction as j2 } from "@excalidraw/element";
import w2 from "clsx";
import J8 from "fuzzy";
import { useEffect as Rc, useRef as Q8, useState as _c } from "react";
import {
  DEFAULT_SIDEBAR as E2,
  EVENT as Bc,
  KEYS as ao,
  capitalizeString as e7,
  getShortcutKey as t7,
  isWritableElement as o7,
} from "@excalidraw/common";
import { CaptureUpdateAction as IP } from "@excalidraw/element";
import { useEffect as Aa, useMemo as $E, useRef as Iu, useState as YL } from "react";
import { getLinearElementSubType as ci, updateElbowArrowPoints as WL } from "@excalidraw/element";
import { pointFrom as dc, pointRotateRads as VL } from "@excalidraw/math";
import {
  hasBoundTextElement as XL,
  isArrowBoundToElement as KL,
  isArrowElement as ZL,
  isElbowArrow as $L,
  isLinearElement as Mu,
  isUsingAdaptiveRadius as jL,
} from "@excalidraw/element";
import { getCommonBoundingBox as qL, getElementAbsoluteCoords as JL } from "@excalidraw/element";
import {
  getBoundTextElement as ey,
  getBoundTextMaxHeight as QL,
  getBoundTextMaxWidth as eP,
  redrawTextBoundingBox as tP,
} from "@excalidraw/element";
import { wrapText as oP } from "@excalidraw/element";
import {
  assertNever as rP,
  CLASSES as nP,
  getFontString as wu,
  isProdEnv as iP,
  mapFind as aP,
  reduceToCommonValue as lP,
  updateActiveTool as jE,
} from "@excalidraw/common";
import { measureText as qE } from "@excalidraw/element";
import { LinearElementEditor as sP } from "@excalidraw/element";
import {
  newArrowElement as vu,
  newElement as cP,
  newLinearElement as dP,
} from "@excalidraw/element";
import { ShapeCache as mP } from "@excalidraw/element";
import { updateBindings as pP } from "@excalidraw/element";
import { jsx as ku } from "react/jsx-runtime";
var uP = 8,
  hP = 10,
  La = ["rectangle", "diamond", "ellipse"],
  Pa = ["line", "sharpArrow", "curvedArrow", "elbowArrow"],
  gP = new Set(La),
  fP = new Set(Pa),
  di = (e) => gP.has(e),
  pc = (e) => e === "arrow" || fP.has(e),
  io = me(null),
  Da = new Map(),
  _a = new Map(),
  bP = ({ app: e }) => {
    let o = e.scene.getSelectedElements(e.state),
      t = Iu(null);
    return (
      Aa(() => {
        if (o.length === 0) {
          e.updateEditorAtom(io, null);
          return;
        }
        let r = mi(o);
        r && !t.current
          ? (t.current = r)
          : ((t.current && !r) || (t.current && r !== t.current)) &&
            (e.updateEditorAtom(io, null), (t.current = null));
      }, [o, e]),
      Aa(
        () => () => {
          Da.clear(), _a.clear();
        },
        []
      ),
      ku(xP, { app: e, elements: o })
    );
  },
  xP = ({ app: e, elements: o }) => {
    let t = mi(o),
      r = $E(() => (t === "generic" ? oy(o) : []), [t, o]),
      n = $E(() => (t === "linear" ? Su(o) : []), [t, o]),
      i =
        t === "generic"
          ? r.every((c) => c.type === r[0].type)
          : t === "linear"
          ? n.every((c) => ci(c) === ci(n[0]))
          : !1,
      [a, l] = YL({ x: 0, y: 0 }),
      s = Iu(""),
      d = Iu(null);
    Aa(() => {
      let c = [...r, ...n].sort((x, w) => x.id.localeCompare(w.id)),
        p = `
      ${e.state.scrollX}${e.state.scrollY}${e.state.offsetTop}${e.state.offsetLeft}${
          e.state.zoom.value
        }${c.map((x) => x.id).join(",")}`;
      if (p === s.current) return;
      s.current = p;
      let u;
      if (c.length === 1) {
        let [x, , , w, E, y] = JL(c[0], e.scene.getNonDeletedElementsMap());
        u = VL(dc(x, w), dc(E, y), c[0].angle);
      } else {
        let { minX: x, maxY: w } = qL(c);
        u = dc(x, w);
      }
      let { x: f, y: b } = ny({ sceneX: u[0], sceneY: u[1] }, e.state);
      l({ x: f, y: b });
    }, [r, n, e.scene, e.state]),
      Aa(() => {
        for (let c of n) {
          let p = Cu(c.id, TP(c));
          _a.has(p) || _a.set(p, c);
        }
      }, [n]),
      Aa(() => {
        for (let c of r)
          if (!Da.has(c.id)) {
            let p = ey(c, e.scene.getNonDeletedElementsMap());
            p && Da.set(c.id, { fontSize: p.fontSize });
          }
      }, [r, e.scene]);
    let m =
      t === "linear"
        ? [
            ["line", Xl],
            ["sharpArrow", ns],
            ["curvedArrow", as],
            ["elbowArrow", is],
          ]
        : t === "generic"
        ? [
            ["rectangle", Yl],
            ["diamond", Wl],
            ["ellipse", Vl],
          ]
        : [];
    return ku("div", {
      ref: d,
      tabIndex: -1,
      style: {
        position: "absolute",
        top: `${a.y + (hP + 8) * e.state.zoom.value - e.state.offsetTop}px`,
        left: `${a.x - e.state.offsetLeft - uP}px`,
        zIndex: 2,
      },
      className: nP.CONVERT_ELEMENT_TYPE_POPUP,
      children: m.map(([c, p]) => {
        let u = i && ((t === "generic" && r[0].type === c) || (t === "linear" && ci(n[0]) === c));
        return ku(
          V,
          {
            className: "Shape",
            type: "radio",
            icon: p,
            checked: u,
            name: "convertElementType-option",
            title: c,
            keyBindingLabel: "",
            "aria-label": c,
            "data-testid": `toolbar-${c}`,
            onChange: () => {
              e.state.activeTool.type !== c && re("convertElementType", c, "ui"),
                Lu(e, { conversionType: t, nextType: c }),
                d.current?.focus();
            },
          },
          `${o[0].id}${o[0].version}_${c}`
        );
      }),
    });
  },
  EP = (e, o, t) => {
    let r = eP(e, o),
      n = QL(e, o),
      i = oP(o.text, wu(o), r),
      a = qE(i, wu(o), o.lineHeight),
      l = o.fontSize;
    for (; (a.width > r || a.height > n) && l > 0; ) {
      l -= 1;
      let s = { ...o, fontSize: l };
      a = qE(o.text, wu(s), o.lineHeight);
    }
    uc(o, t.getNonDeletedElementsMap(), { fontSize: l, width: a.width, height: a.height }),
      tP(o, e, t);
  },
  Lu = (e, { conversionType: o, nextType: t, direction: r = "right" }) => {
    if (!o) return !1;
    let n = e.scene.getSelectedElements(e.state),
      i = n.reduce((l, s) => ({ ...l, [s.id]: !0 }), {}),
      a = r === "right" ? 1 : -1;
    if (o === "generic") {
      let l = oy(n),
        d = l.every((m) => m.type === l[0].type) ? La.indexOf(l[0].type) : -1;
      if (((t = t ?? La[(d + La.length + a) % La.length]), t && di(t))) {
        let m = {};
        for (let p of l) {
          let u = QE(p, t, e);
          m[u.id] = u;
        }
        let c = [];
        for (let p of e.scene.getElementsIncludingDeleted()) m[p.id] ? c.push(m[p.id]) : c.push(p);
        e.scene.replaceAllElements(c);
        for (let p of Object.values(m)) {
          let u = ey(p, e.scene.getNonDeletedElementsMap());
          u &&
            (Da.get(p.id) &&
              uc(u, e.scene.getNonDeletedElementsMap(), {
                fontSize: Da.get(p.id)?.fontSize ?? u.fontSize,
              }),
            EP(p, u, e.scene));
        }
        e.setState((p) => ({ selectedElementIds: i, activeTool: jE(p, { type: "selection" }) }));
      }
    }
    if (o === "linear") {
      let l = Su(n);
      if (!t) {
        let d = lP(l, ci),
          m = d ? Pa.indexOf(d) : -1;
        t = Pa[(m + Pa.length + a) % Pa.length];
      }
      if (pc(t)) {
        let d = [],
          m = e.scene.getElementsMapIncludingDeleted();
        for (let c of l) {
          let p = _a.get(Cu(c.id, t));
          if (p && ci(p) === t) m.set(p.id, p), d.push(p);
          else {
            let u = QE(c, t, e);
            m.set(u.id, u), d.push(u);
          }
        }
        e.scene.replaceAllElements(m);
        for (let c of d)
          if (Mu(c))
            if ($L(c)) {
              let p = yP(c);
              if (p.length < 2) continue;
              let u = [];
              for (let b = 1; b < p.length - 2; b++)
                u.push({ start: p[b], end: p[b + 1], index: b + 1 });
              let f = WL(c, e.scene.getNonDeletedElementsMap(), { points: p, fixedSegments: u });
              uc(c, e.scene.getNonDeletedElementsMap(), { ...f, endArrowhead: "arrow" });
            } else {
              let p = aP(["line", "sharpArrow", "curvedArrow"], (u) => _a.get(Cu(c.id, u)));
              if (p) {
                let u = p.points;
                e.scene.mutateElement(c, { points: u });
              }
            }
      }
      let s = Su(e.scene.getSelectedElements(e.state));
      e.setState((d) => ({
        selectedElementIds: i,
        selectedLinearElement:
          s.length === 1 ? new sP(s[0], e.scene.getNonDeletedElementsMap()) : null,
        activeTool: jE(d, { type: "selection" }),
      }));
    }
    return !0;
  },
  mi = (e) => {
    if (e.length === 0) return null;
    let o = !1;
    for (let t of e) {
      if (di(t.type)) return "generic";
      ty(t) && (o = !0);
    }
    return o ? "linear" : null;
  },
  ty = (e) => Mu(e) && (!ZL(e) || (!KL(e) && !XL(e))),
  Cu = (e, o) => `${e}:${o}`,
  oy = (e) => e.filter((o) => di(o.type)),
  Su = (e) => e.filter((o) => ty(o)),
  cc = 20,
  li = (e, o) => e[0] === o[0],
  Tu = (e, o) => e[1] === o[1],
  JE = (e, o) => (li(e, o) ? Math.abs(e[1] - o[1]) : Math.abs(e[0] - o[0])),
  yP = (e) => {
    let o = [e.points[0]],
      t = wP(e.points);
    for (let i = 1; i < t.length; ++i) {
      let a = o[o.length - 1],
        l = [...t[i]];
      Math.abs(l[0] - a[0]) < cc ? (l[0] = a[0]) : Math.abs(l[1] - a[1]) < cc && (l[1] = a[1]),
        li(a, l) || Tu(a, l) || o.push(dc(a[0], l[1])),
        o.push(l);
    }
    let r = [o[0]];
    for (let i = 1; i < o.length - 1; ++i)
      (li(o[i - 1], o[i]) && li(o[i], o[i + 1])) ||
        (Tu(o[i - 1], o[i]) && Tu(o[i], o[i + 1])) ||
        r.push(o[i]);
    r.push(o[o.length - 1]);
    let n = [r[0]];
    for (let i = 1; i < r.length - 1; ++i) {
      let a = n[n.length - 1],
        l = r[i],
        s = r[i + 1],
        d = li(a, l),
        m = li(l, s);
      if (d !== m) {
        let c = JE(a, l),
          p = JE(l, s);
        if (c < cc || p < cc) {
          if (p < c) d ? (s[0] = a[0]) : (s[1] = a[1]);
          else if (m) for (let u = n.length - 1; u >= 0 && n[u][0] === a[0]; --u) n[u][0] = l[0];
          else for (let u = n.length - 1; u >= 0 && n[u][1] === a[1]; --u) n[u][1] = l[1];
          continue;
        }
      }
      n.push(l);
    }
    return n.push(r[r.length - 1]), n;
  },
  wP = (e) => {
    if (e.length === 0) return [];
    let o = [e[0]];
    for (let t = 1; t < e.length; t++) {
      let [r, n] = o[o.length - 1],
        [i, a] = e[t];
      (r !== i || n !== a) && o.push(e[t]);
    }
    return o;
  },
  QE = (e, o, t) => {
    if (!vP(e.type, o)) {
      if (!iP()) throw Error(`Invalid conversion from ${e.type} to ${o}.`);
      return e;
    }
    if (e.type === o) return e;
    if ((mP.delete(e), di(o))) {
      let r = si(
        cP({
          ...e,
          type: o,
          roundness:
            o === "diamond" && e.roundness
              ? { type: jL(o) ? mc.ADAPTIVE_RADIUS : mc.PROPORTIONAL_RADIUS }
              : e.roundness,
        })
      );
      return pP(r, t.scene), r;
    }
    if (pc(o))
      switch (o) {
        case "line":
          return si(dP({ ...e, type: "line" }));
        case "sharpArrow":
          return si(
            vu({
              ...e,
              type: "arrow",
              elbowed: !1,
              roundness: null,
              startArrowhead: t.state.currentItemStartArrowhead,
              endArrowhead: t.state.currentItemEndArrowhead,
            })
          );
        case "curvedArrow":
          return si(
            vu({
              ...e,
              type: "arrow",
              elbowed: !1,
              roundness: { type: mc.PROPORTIONAL_RADIUS },
              startArrowhead: t.state.currentItemStartArrowhead,
              endArrowhead: t.state.currentItemEndArrowhead,
            })
          );
        case "elbowArrow":
          return si(vu({ ...e, type: "arrow", elbowed: !0, fixedSegments: null, roundness: null }));
      }
    return rP(o, `unhandled conversion type: ${o}`), e;
  },
  vP = (e, o) => !!((di(e) && di(o)) || (pc(e) && pc(o))),
  TP = (e) => (Mu(e) ? ci(e) : e.type),
  ry = bP;
var iy = B({
  name: "toggleShapeSwitch",
  label: "labels.shapeSwitch",
  icon: () => null,
  viewMode: !0,
  trackEvent: { category: "shape_switch", action: "toggle" },
  keywords: ["change", "switch", "swap"],
  perform(e, o, t, r) {
    return He.set(io, { type: "panel" }), { captureUpdate: IP.NEVER };
  },
  checked: (e) => e.gridModeEnabled,
  predicate: (e, o, t) => mi(e) !== null,
});
import {
  canCreateLinkFromElements as Pu,
  defaultGetElementLinkFromSelection as CP,
  getLinkIdAndTypeFromSelection as SP,
} from "@excalidraw/element";
import { CaptureUpdateAction as Ra } from "@excalidraw/element";
var hc = B({
    name: "copyElementLink",
    label: "labels.copyElementLink",
    icon: Ln,
    trackEvent: { category: "element" },
    perform: async (e, o, t, r) => {
      let n = Z(e, o);
      try {
        if (window.location) {
          let i = SP(n, o);
          return i
            ? (await ro(
                r.props.generateLinkForSelection
                  ? r.props.generateLinkForSelection(i.id, i.type)
                  : CP(i.id, i.type)
              ),
              {
                appState: { toast: { message: g("toast.elementLinkCopied"), closable: !0 } },
                captureUpdate: Ra.EVENTUALLY,
              })
            : { appState: o, elements: e, app: r, captureUpdate: Ra.EVENTUALLY };
        }
      } catch (i) {
        console.error(i);
      }
      return { appState: o, elements: e, app: r, captureUpdate: Ra.EVENTUALLY };
    },
    predicate: (e, o) => Pu(Z(e, o)),
  }),
  ay = B({
    name: "linkToElement",
    label: "labels.linkToElement",
    icon: ss,
    perform: (e, o, t, r) => {
      let n = Z(e, o);
      return n.length !== 1 || !Pu(n)
        ? { elements: e, appState: o, app: r, captureUpdate: Ra.EVENTUALLY }
        : {
            appState: {
              ...o,
              openDialog: { name: "elementLinkSelector", sourceElementId: Z(e, o)[0].id },
            },
            captureUpdate: Ra.IMMEDIATELY,
          };
    },
    predicate: (e, o, t, r) => {
      let n = Z(e, o);
      return o.openDialog?.name !== "elementLinkSelector" && n.length === 1 && Pu(n);
    },
    trackEvent: !1,
  });
import { isDarwin as ly, getShortcutKey as oe } from "@excalidraw/common";
var kP = {
    toggleTheme: [oe("Shift+Alt+D")],
    saveScene: [oe("CtrlOrCmd+S")],
    loadScene: [oe("CtrlOrCmd+O")],
    clearCanvas: [oe("CtrlOrCmd+Delete")],
    imageExport: [oe("CtrlOrCmd+Shift+E")],
    commandPalette: [oe("CtrlOrCmd+/"), oe("CtrlOrCmd+Shift+P")],
    cut: [oe("CtrlOrCmd+X")],
    copy: [oe("CtrlOrCmd+C")],
    paste: [oe("CtrlOrCmd+V")],
    copyStyles: [oe("CtrlOrCmd+Alt+C")],
    pasteStyles: [oe("CtrlOrCmd+Alt+V")],
    selectAll: [oe("CtrlOrCmd+A")],
    deleteSelectedElements: [oe("Delete")],
    duplicateSelection: [oe("CtrlOrCmd+D"), oe(`Alt+${g("helpDialog.drag")}`)],
    sendBackward: [oe("CtrlOrCmd+[")],
    bringForward: [oe("CtrlOrCmd+]")],
    sendToBack: [ly ? oe("CtrlOrCmd+Alt+[") : oe("CtrlOrCmd+Shift+[")],
    bringToFront: [ly ? oe("CtrlOrCmd+Alt+]") : oe("CtrlOrCmd+Shift+]")],
    copyAsPng: [oe("Shift+Alt+C")],
    group: [oe("CtrlOrCmd+G")],
    ungroup: [oe("CtrlOrCmd+Shift+G")],
    gridMode: [oe("CtrlOrCmd+'")],
    zenMode: [oe("Alt+Z")],
    objectsSnapMode: [oe("Alt+S")],
    stats: [oe("Alt+/")],
    addToLibrary: [],
    flipHorizontal: [oe("Shift+H")],
    flipVertical: [oe("Shift+V")],
    viewMode: [oe("Alt+R")],
    hyperlink: [oe("CtrlOrCmd+K")],
    toggleElementLock: [oe("CtrlOrCmd+Shift+L")],
    resetZoom: [oe("CtrlOrCmd+0")],
    zoomOut: [oe("CtrlOrCmd+-")],
    zoomIn: [oe("CtrlOrCmd++")],
    zoomToFitSelection: [oe("Shift+3")],
    zoomToFit: [oe("Shift+1")],
    zoomToFitSelectionInViewport: [oe("Shift+2")],
    toggleEraserTool: [oe("E")],
    toggleHandTool: [oe("H")],
    setFrameAsActiveTool: [oe("F")],
    saveFileToDisk: [oe("CtrlOrCmd+S")],
    saveToActiveFile: [oe("CtrlOrCmd+S")],
    toggleShortcuts: [oe("?")],
    searchMenu: [oe("CtrlOrCmd+F")],
    wrapSelectionInFrame: [],
  },
  Ne = (e, o = 0) => {
    let t = kP[e];
    return t && t.length > 0 ? t[o] || t[0] : "";
  };
var MP = "\\u0300-\\u036f",
  LP = "\\ufe20-\\ufe2f",
  PP = "\\u20d0-\\u20ff",
  AP = MP + LP + PP,
  DP = `[${AP}]`,
  _P = RegExp(DP, "g"),
  RP = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
  NP = {
    À: "A",
    Á: "A",
    Â: "A",
    Ã: "A",
    Ä: "A",
    Å: "A",
    à: "a",
    á: "a",
    â: "a",
    ã: "a",
    ä: "a",
    å: "a",
    Ç: "C",
    ç: "c",
    Ð: "D",
    ð: "d",
    È: "E",
    É: "E",
    Ê: "E",
    Ë: "E",
    è: "e",
    é: "e",
    ê: "e",
    ë: "e",
    Ì: "I",
    Í: "I",
    Î: "I",
    Ï: "I",
    ì: "i",
    í: "i",
    î: "i",
    ï: "i",
    Ñ: "N",
    ñ: "n",
    Ò: "O",
    Ó: "O",
    Ô: "O",
    Õ: "O",
    Ö: "O",
    Ø: "O",
    ò: "o",
    ó: "o",
    ô: "o",
    õ: "o",
    ö: "o",
    ø: "o",
    Ù: "U",
    Ú: "U",
    Û: "U",
    Ü: "U",
    ù: "u",
    ú: "u",
    û: "u",
    ü: "u",
    Ý: "Y",
    ý: "y",
    ÿ: "y",
    Æ: "E",
    æ: "e",
    Þ: "T",
    þ: "t",
    ß: "s",
    Ā: "A",
    Ă: "A",
    Ą: "A",
    ā: "a",
    ă: "a",
    ą: "a",
    Ć: "C",
    Ĉ: "C",
    Ċ: "C",
    Č: "C",
    ć: "c",
    ĉ: "c",
    ċ: "c",
    č: "c",
    Ď: "D",
    Đ: "D",
    ď: "d",
    đ: "d",
    Ē: "E",
    Ĕ: "E",
    Ė: "E",
    Ę: "E",
    Ě: "E",
    ē: "e",
    ĕ: "e",
    ė: "e",
    ę: "e",
    ě: "e",
    Ĝ: "G",
    Ğ: "G",
    Ġ: "G",
    Ģ: "G",
    ĝ: "g",
    ğ: "g",
    ġ: "g",
    ģ: "g",
    Ĥ: "H",
    Ħ: "H",
    ĥ: "h",
    ħ: "h",
    Ĩ: "I",
    Ī: "I",
    Ĭ: "I",
    Į: "I",
    İ: "I",
    ĩ: "i",
    ī: "i",
    ĭ: "i",
    į: "i",
    ı: "i",
    Ĵ: "J",
    ĵ: "j",
    Ķ: "K",
    ķ: "k",
    ĸ: "k",
    Ĺ: "L",
    Ļ: "L",
    Ľ: "L",
    Ŀ: "L",
    Ł: "L",
    ĺ: "l",
    ļ: "l",
    ľ: "l",
    ŀ: "l",
    ł: "l",
    Ń: "N",
    Ņ: "N",
    Ň: "N",
    Ŋ: "N",
    ń: "n",
    ņ: "n",
    ň: "n",
    ŋ: "n",
    Ō: "O",
    Ŏ: "O",
    Ő: "O",
    ō: "o",
    ŏ: "o",
    ő: "o",
    Ŕ: "R",
    Ŗ: "R",
    Ř: "R",
    ŕ: "r",
    ŗ: "r",
    ř: "r",
    Ś: "S",
    Ŝ: "S",
    Ş: "S",
    Š: "S",
    ś: "s",
    ŝ: "s",
    ş: "s",
    š: "s",
    Ţ: "T",
    Ť: "T",
    Ŧ: "T",
    ţ: "t",
    ť: "t",
    ŧ: "t",
    Ũ: "U",
    Ū: "U",
    Ŭ: "U",
    Ů: "U",
    Ű: "U",
    Ų: "U",
    ũ: "u",
    ū: "u",
    ŭ: "u",
    ů: "u",
    ű: "u",
    ų: "u",
    Ŵ: "W",
    ŵ: "w",
    Ŷ: "Y",
    ŷ: "y",
    Ÿ: "Y",
    Ź: "Z",
    Ż: "Z",
    Ž: "Z",
    ź: "z",
    ż: "z",
    ž: "z",
    Ĳ: "I",
    ĳ: "i",
    Œ: "E",
    œ: "e",
    ŉ: "n",
    ſ: "s",
  },
  Au = (e) => e.replace(RP, (o) => NP[o] || o).replace(_P, "");
import I8 from "clsx";
import { useEffect as C8, useState as S8 } from "react";
import { KEYS as k8, queryFocusableElements as i2 } from "@excalidraw/common";
import { useCallback as BP, useState as FP } from "react";
var sy = () => {
  let [e, o] = FP(null),
    t = BP((r) => o(r), []);
  return [e, t];
};
import {
  useState as Qy,
  useCallback as Ku,
  useMemo as e2,
  useEffect as jy,
  memo as t2,
  useRef as u8,
} from "react";
import {
  LIBRARY_DISABLED_TYPES as h8,
  randomId as g8,
  isShallowEqual as f8,
} from "@excalidraw/common";
import { useEffect as py, useRef as uy } from "react";
import {
  URL_HASH_KEYS as Ru,
  URL_QUERY_KEYS as Nu,
  APP_NAME as hy,
  EVENT as fc,
  DEFAULT_SIDEBAR as UP,
  LIBRARY_SIDEBAR_TAB as YP,
  arrayToMap as Bu,
  cloneJSON as WP,
  preventUnload as VP,
  promiseTry as gy,
  resolvablePromise as XP,
  toValidURL as KP,
  Queue as ZP,
  Emitter as $P,
} from "@excalidraw/common";
import { hashElementsVersion as jP, hashString as qP } from "@excalidraw/element";
import { getCommonBoundingBox as _u } from "@excalidraw/element";
import { MIME_TYPES as en } from "@excalidraw/common";
var pr = ({
    elements: e,
    appState: o,
    files: t,
    maxWidthOrHeight: r,
    getDimensions: n,
    exportPadding: i,
    exportingFrame: a,
  }) => {
    let { elements: l, appState: s } = wn({ elements: e, appState: o }, null, null),
      { exportBackground: d, viewBackgroundColor: m } = s;
    return Rl(
      l,
      { ...s, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 },
      t || {},
      { exportBackground: d, exportPadding: i, viewBackgroundColor: m, exportingFrame: a },
      (c, p) => {
        let u = document.createElement("canvas");
        if (r) {
          typeof n == "function" &&
            console.warn("`getDimensions()` is ignored when `maxWidthOrHeight` is supplied.");
          let b = Math.max(c, p),
            x = r < b ? r / b : o?.exportScale ?? 1;
          return (u.width = c * x), (u.height = p * x), { canvas: u, scale: x };
        }
        let f = n?.(c, p) || { width: c, height: p };
        return (u.width = f.width), (u.height = f.height), { canvas: u, scale: f.scale ?? 1 };
      }
    );
  },
  cy = async (e) => {
    let { mimeType: o = en.png, quality: t } = e;
    o === en.png &&
      typeof t == "number" &&
      console.warn(`"quality" will be ignored for "${en.png}" mimeType`),
      o === "image/jpg" && (o = en.jpg),
      o === en.jpg &&
        !e.appState?.exportBackground &&
        (console.warn(`Defaulting "exportBackground" to "true" for "${en.jpg}" mimeType`),
        (e = { ...e, appState: { ...e.appState, exportBackground: !0 } }));
    let r = await pr(e);
    return (
      (t = t || (/image\/jpe?g/.test(o) ? 0.92 : 0.8)),
      new Promise((n, i) => {
        r.toBlob(
          async (a) => {
            if (!a) return i(new Error("couldn't export to blob"));
            a &&
              o === en.png &&
              e.appState?.exportEmbedScene &&
              (a = await l1({
                blob: a,
                metadata: Vi(e.elements, e.appState, e.files || {}, "local"),
              })),
              n(a);
          },
          o,
          t
        );
      })
    );
  },
  pi = async ({
    elements: e,
    appState: o = Jo(),
    files: t = {},
    exportPadding: r,
    renderEmbeddables: n,
    exportingFrame: i,
    skipInliningFonts: a,
    reuseImages: l,
  }) => {
    let { elements: s, appState: d } = wn({ elements: e, appState: o }, null, null),
      m = { ...d, exportPadding: r };
    return yn(s, m, t, {
      exportingFrame: i,
      renderEmbeddables: n,
      skipInliningFonts: a,
      reuseImages: l,
    });
  },
  OP = async (e) => {
    if (e.type === "svg") {
      let o = await pi(e);
      await ro(o.outerHTML);
    } else if (e.type === "png") await Xs(cy(e));
    else if (e.type === "json") await Ws(e.elements, e.files);
    else throw new Error("Invalid export type");
  };
import { useEffect as zP, useState as HP } from "react";
import { COLOR_PALETTE as GP } from "@excalidraw/common";
var Du = me(new Map()),
  dy = async (e) =>
    await pi({
      elements: e,
      appState: { exportBackground: !1, viewBackgroundColor: GP.white },
      files: null,
      renderEmbeddables: !1,
      skipInliningFonts: !0,
    }),
  my = (e, o, t) => {
    let [r, n] = HP();
    return (
      zP(() => {
        if (o)
          if (e) {
            let i = t.get(e);
            i
              ? n(i)
              : (async () => {
                  let a = await dy(o);
                  a.querySelector(".style-fonts")?.remove(), a && (t.set(e, a), n(a));
                })();
          } else
            (async () => {
              let i = await dy(o);
              n(i);
            })();
      }, [e, o, t, n]),
      r
    );
  },
  gc = () => {
    let [e] = ne(Du);
    return {
      clearLibraryCache: () => e.clear(),
      deleteItemsFromLibraryCache: (r) => {
        r.forEach((n) => e.delete(n));
      },
      svgCache: e,
    };
  };
var JP = ["excalidraw.com", "raw.githubusercontent.com/excalidraw/excalidraw-libraries"],
  by = new $P(),
  tn = me({ status: "loaded", isInitialized: !1, libraryItems: [] }),
  Na = (e) => WP(e),
  QP = (e, o) =>
    !e.find((t) =>
      t.elements.length !== o.elements.length
        ? !1
        : t.elements.every(
            (r, n) => r.id === o.elements[n].id && r.versionNonce === o.elements[n].versionNonce
          )
    ),
  xy = (e, o) => {
    let t = [];
    for (let r of o) QP(e, r) && t.push(r);
    return [...t, ...e];
  },
  Ey = (e, o) => {
    let t = Bu(o),
      r = { deletedItems: new Map(), addedItems: new Map() };
    for (let i of e) t.has(i.id) || r.deletedItems.set(i.id, i);
    let n = Bu(e);
    for (let i of o) n.has(i.id) || r.addedItems.set(i.id, i);
    return r;
  },
  Fu = class {
    constructor(o) {
      I(this, "currLibraryItems", []);
      I(this, "prevLibraryItems", Na(this.currLibraryItems));
      I(this, "app");
      I(this, "updateQueue", []);
      I(this, "getLastUpdateTask", () => this.updateQueue[this.updateQueue.length - 1]);
      I(this, "notifyListeners", () => {
        if (this.updateQueue.length > 0)
          He.set(tn, (o) => ({
            status: "loading",
            libraryItems: this.currLibraryItems,
            isInitialized: o.isInitialized,
          }));
        else {
          He.set(tn, { status: "loaded", libraryItems: this.currLibraryItems, isInitialized: !0 });
          try {
            let o = this.prevLibraryItems;
            this.prevLibraryItems = Na(this.currLibraryItems);
            let t = Na(this.currLibraryItems);
            this.app.props.onLibraryChange?.(t), by.trigger(Ey(o, t), t);
          } catch (o) {
            console.error(o);
          }
        }
      });
      I(this, "destroy", () => {
        (this.updateQueue = []), (this.currLibraryItems = []), He.set(Du, new Map());
      });
      I(this, "resetLibrary", () => this.setLibrary([]));
      I(
        this,
        "getLatestLibrary",
        () =>
          new Promise(async (o) => {
            try {
              let t = await (this.getLastUpdateTask() || this.currLibraryItems);
              this.updateQueue.length > 0 ? o(this.getLatestLibrary()) : o(Na(t));
            } catch {
              return o(this.currLibraryItems);
            }
          })
      );
      I(
        this,
        "updateLibrary",
        async ({
          libraryItems: o,
          prompt: t = !1,
          merge: r = !1,
          openLibraryMenu: n = !1,
          defaultStatus: i = "unpublished",
        }) => (
          n && this.app.setState({ openSidebar: { name: UP.name, tab: YP } }),
          this.setLibrary(
            () =>
              new Promise(async (a, l) => {
                try {
                  let s = await (typeof o == "function" && !(o instanceof Blob)
                      ? o(this.currLibraryItems)
                      : o),
                    d;
                  s instanceof Blob ? (d = await bm(s, i)) : (d = Zi(s, i)),
                    !t || window.confirm(g("alerts.confirmAddLibrary", { numShapes: d.length }))
                      ? (t && this.app.focusContainer(), a(r ? xy(this.currLibraryItems, d) : d))
                      : l(new xn());
                } catch (s) {
                  l(s);
                }
              })
          )
        )
      );
      I(this, "setLibrary", (o) => {
        let t = new Promise(async (r, n) => {
          try {
            await this.getLastUpdateTask(),
              typeof o == "function" && (o = o(this.currLibraryItems)),
              (this.currLibraryItems = Na(await o)),
              r(this.currLibraryItems);
          } catch (i) {
            n(i);
          }
        })
          .catch((r) => {
            if (r.name === "AbortError")
              return console.warn("Library update aborted by user"), this.currLibraryItems;
            throw r;
          })
          .finally(() => {
            (this.updateQueue = this.updateQueue.filter((r) => r !== t)), this.notifyListeners();
          });
        return this.updateQueue.push(t), this.notifyListeners(), t;
      });
      this.app = o;
    }
  },
  yy = Fu,
  Ec = (e) => {
    let t = Math.ceil(Math.sqrt(e.length)),
      r = [],
      n = (u) =>
        e.slice(u * t, u * t + t).reduce((b, x) => {
          let { height: w } = _u(x.elements);
          return Math.max(b, w);
        }, 0),
      i = (u) => {
        let f = 0,
          b = 0,
          x = 0;
        for (let w of e) {
          if ((f % t === 0 && (b = 0), b === u)) {
            let { width: E } = _u(w.elements);
            x = Math.max(x, E);
          }
          f++, b++;
        }
        return x;
      },
      a = 0,
      l = 0,
      s = 0,
      d = 0,
      m = 0,
      c = 0,
      p = 0;
    for (let u of e) {
      m && m % t === 0 && ((l += s + 50), (a = 0), (c = 0), p++), c === 0 && (s = n(p)), (d = i(c));
      let { minX: f, minY: b, width: x, height: w } = _u(u.elements),
        E = (d - x) / 2,
        y = (s - w) / 2;
      r.push(...u.elements.map((v) => ({ ...v, x: v.x + a + E - f, y: v.y + l + y - b }))),
        (a += d + 50),
        m++,
        c++;
    }
    return r;
  },
  eA = (e, o = JP) => {
    if (
      typeof o == "function"
        ? o(e)
        : o.some((t) => {
            let r = new URL(`https://${t.replace(/^https?:\/\//, "")}`),
              { hostname: n, pathname: i } = new URL(e);
            return (
              new RegExp(`(^|\\.)${r.hostname}$`).test(n) &&
              new RegExp(`^${r.pathname.replace(/\/+$/, "")}(/+|$)`).test(i)
            );
          })
    )
      return !0;
    throw new Error(`Invalid or disallowed library URL: "${e}"`);
  },
  Ou = () => {
    let e =
        new URLSearchParams(window.location.hash.slice(1)).get(Ru.addLibrary) ||
        new URLSearchParams(window.location.search).get(Nu.addLibrary),
      o = e ? new URLSearchParams(window.location.hash.slice(1)).get("token") : null;
    return e ? { libraryUrl: e, idToken: o } : null;
  },
  ur = class ur {
    constructor(o) {
      I(this, "adapter");
      this.adapter = o;
    }
    static async getLibraryItems(o, t, r = !0) {
      let n = () =>
        new Promise(async (i, a) => {
          try {
            let l = await o.load({ source: t });
            i(Zi(l?.libraryItems || [], "published"));
          } catch (l) {
            a(l);
          }
        });
      return r ? ur.queue.push(n) : n();
    }
    getLibraryItems(o) {
      return ur.getLibraryItems(this.adapter, o, !1);
    }
  };
I(ur, "queue", new ZP()),
  I(ur, "run", async (o, t) => {
    let r = new ur(o);
    return ur.queue.push(() => t(r));
  });
var ui = ur,
  Ba = 0,
  bc = 0,
  xc = (e) =>
    qP(
      e
        .map((o) => `${o.id}:${jP(o.elements)}`)
        .sort()
        .join()
    ),
  fy = async (e, o) => {
    try {
      return (
        bc++,
        await ui.run(e, async (t) => {
          let r = Bu(await t.getLibraryItems("save"));
          for (let [l] of o.deletedItems) r.delete(l);
          let n = [];
          for (let [l, s] of o.addedItems) r.has(l) ? r.set(l, s) : n.push(s);
          let i = n.concat(Array.from(r.values())),
            a = xc(i);
          return a !== Ba && (await e.save({ libraryItems: i })), (Ba = a), i;
        })
      );
    } finally {
      bc--;
    }
  },
  tA = (e) => {
    let { excalidrawAPI: o } = e,
      t = uy(e);
    t.current = e;
    let r = uy(!1);
    py(() => {
      if (!o) return;
      r.current = !1;
      let n = async ({ libraryUrl: l, idToken: s }) => {
          let d = new Promise(async (c, p) => {
              try {
                (l = decodeURIComponent(l)), (l = KP(l)), eA(l, t.current.validateLibraryUrl);
                let f = await (await fetch(l)).blob();
                c(f);
              } catch (u) {
                p(u);
              }
            }),
            m = s !== o.id;
          await (m && document.hidden
            ? new Promise((c) => {
                window.addEventListener("focus", () => c(), { once: !0 });
              })
            : null);
          try {
            await o.updateLibrary({
              libraryItems: d,
              prompt: m,
              merge: !0,
              defaultStatus: "published",
              openLibraryMenu: !0,
            });
          } catch (c) {
            throw (o.updateScene({ appState: { errorMessage: c.message } }), c);
          } finally {
            if (window.location.hash.includes(Ru.addLibrary)) {
              let c = new URLSearchParams(window.location.hash.slice(1));
              c.delete(Ru.addLibrary), window.history.replaceState({}, hy, `#${c.toString()}`);
            } else if (window.location.search.includes(Nu.addLibrary)) {
              let c = new URLSearchParams(window.location.search);
              c.delete(Nu.addLibrary), window.history.replaceState({}, hy, `?${c.toString()}`);
            }
          }
        },
        i = (l) => {
          l.preventDefault();
          let s = Ou();
          s && (l.stopImmediatePropagation(), window.history.replaceState({}, "", l.oldURL), n(s));
        },
        a = Ou();
      if (
        (a && n(a),
        "getInitialLibraryItems" in t.current &&
          t.current.getInitialLibraryItems &&
          (console.warn(
            "useHandleLibrar `opts.getInitialLibraryItems` is deprecated. Use `opts.adapter` instead."
          ),
          Promise.resolve(t.current.getInitialLibraryItems())
            .then((l) => {
              o.updateLibrary({ libraryItems: l, merge: !0 });
            })
            .catch((l) => {
              console.error(`UseHandeLibrary getInitialLibraryItems failed: ${l?.message}`);
            })),
        "adapter" in t.current && t.current.adapter)
      ) {
        let l = t.current.adapter,
          s = t.current.migrationAdapter,
          d = XP();
        s
          ? d.resolve(
              gy(s.load)
                .then(async (m) => {
                  let c = null;
                  try {
                    if (!m) return ui.getLibraryItems(l, "load");
                    c = Zi(m.libraryItems || [], "published");
                    let p = await fy(l, Ey([], c));
                    try {
                      await s.clear();
                    } catch (u) {
                      console.error(`couldn't delete legacy library data: ${u.message}`);
                    }
                    return p;
                  } catch (p) {
                    return console.error(`couldn't migrate legacy library data: ${p.message}`), c;
                  }
                })
                .catch(
                  (m) => (
                    console.error(`error during library migration: ${m.message}`),
                    ui.getLibraryItems(l, "load")
                  )
                )
            )
          : d.resolve(gy(ui.getLibraryItems, l, "load")),
          o
            .updateLibrary({
              libraryItems: d.then((m) => {
                let c = m || [];
                return (Ba = xc(c)), c;
              }),
              merge: !0,
            })
            .finally(() => {
              r.current = !0;
            });
      }
      return (
        window.addEventListener(fc.HASHCHANGE, i),
        () => {
          window.removeEventListener(fc.HASHCHANGE, i);
        }
      );
    }, [o]),
      py(() => {
        let n = by.on(async (a, l) => {
            let s = r.current,
              d = ("adapter" in t.current && t.current.adapter) || null;
            try {
              d && Ba !== xc(l) && (await fy(d, a));
            } catch (m) {
              console.error(`couldn't persist library update: ${m.message}`, a),
                s &&
                  t.current.excalidrawAPI &&
                  t.current.excalidrawAPI.updateScene({
                    appState: { errorMessage: g("errors.saveLibraryError") },
                  });
            }
          }),
          i = (a) => {
            bc && VP(a);
          };
        return (
          window.addEventListener(fc.BEFORE_UNLOAD, i),
          () => {
            window.removeEventListener(fc.BEFORE_UNLOAD, i), n(), (Ba = 0), (bc = 0);
          }
        );
      }, []);
  };
import iA from "clsx";
import { VERSIONS as oA } from "@excalidraw/common";
import { jsx as nA } from "react/jsx-runtime";
var rA = ({ theme: e, id: o, libraryReturnUrl: t }) => {
    let r = t || window.location.origin + window.location.pathname;
    return nA("a", {
      className: "library-menu-browse-button",
      href: `${T.VITE_APP_LIBRARY_URL}?target=${
        window.name || "_blank"
      }&referrer=${r}&useHash=true&token=${o}&theme=${e}&version=${oA.excalidrawLibrary}`,
      target: "_excalidraw_libraries",
      children: g("labels.libraries"),
    });
  },
  wy = rA;
import { jsx as aA, jsxs as lA } from "react/jsx-runtime";
var yc = ({ libraryReturnUrl: e, theme: o, id: t, style: r, children: n, className: i }) =>
  lA("div", {
    className: iA("library-menu-control-buttons", i),
    style: r,
    children: [aA(wy, { id: t, libraryReturnUrl: e, theme: o }), n],
  });
import {
  useCallback as fi,
  useEffect as i8,
  useMemo as Zy,
  useRef as a8,
  useState as l8,
} from "react";
import { MIME_TYPES as s8, arrayToMap as c8 } from "@excalidraw/common";
import { duplicateElements as d8 } from "@excalidraw/element";
import sA from "lodash.throttle";
import { useEffect as cA } from "react";
var dA = me(0),
  vy = (e) => {
    let [o, t] = ne(dA);
    return (
      cA(() => {
        let { current: r } = e;
        if (!r) return;
        let n = sA(() => {
          let { scrollTop: i } = r;
          t(i);
        }, 200);
        return (
          r.addEventListener("scroll", n),
          () => {
            n.cancel(), r.removeEventListener("scroll", n);
          }
        );
      }, [e, t]),
      o
    );
  };
import UA from "clsx";
import { useCallback as YA, useState as Uu } from "react";
import { muteFSAbortError as WA } from "@excalidraw/common";
import { flushSync as Ty } from "react-dom";
import mA from "clsx";
import { jsx as wc, jsxs as uA } from "react/jsx-runtime";
var pA = ({
    label: e,
    onClick: o,
    className: t,
    children: r,
    actionType: n,
    type: i = "button",
    isLoading: a,
    ...l
  }) => {
    let s = n ? `Dialog__action-button--${n}` : "";
    return uA("button", {
      className: mA("Dialog__action-button", s, t),
      type: i,
      "aria-label": e,
      onClick: o,
      ...l,
      children: [
        r && wc("div", { style: a ? { visibility: "hidden" } : {}, children: r }),
        wc("div", { style: a ? { visibility: "hidden" } : {}, children: e }),
        a && wc("div", { style: { position: "absolute", inset: 0 }, children: wc(tt, {}) }),
      ],
    });
  },
  Fo = pA;
import { jsx as Iy, jsxs as Cy } from "react/jsx-runtime";
var hA = (e) => {
    let {
        onConfirm: o,
        onCancel: t,
        children: r,
        confirmText: n = g("buttons.confirm"),
        cancelText: i = g("buttons.cancel"),
        className: a = "",
        ...l
      } = e,
      s = le(),
      d = Qo(hi),
      { container: m } = Ge();
    return Cy(Be, {
      onCloseRequest: t,
      size: "small",
      ...l,
      className: `confirm-dialog ${a}`,
      children: [
        r,
        Cy("div", {
          className: "confirm-dialog-buttons",
          children: [
            Iy(Fo, {
              label: i,
              onClick: () => {
                s({ openMenu: null }),
                  d(!1),
                  Ty(() => {
                    t();
                  }),
                  m?.focus();
              },
            }),
            Iy(Fo, {
              label: n,
              onClick: () => {
                s({ openMenu: null }),
                  d(!1),
                  Ty(() => {
                    o();
                  }),
                  m?.focus();
              },
              actionType: "danger",
            }),
          ],
        }),
      ],
    });
  },
  vc = hA;
import Ic from "open-color";
import { useCallback as wA, useEffect as Gu, useRef as Sy, useState as zu } from "react";
import {
  EDITOR_LS_KEYS as Hu,
  EXPORT_DATA_TYPES as vA,
  MIME_TYPES as ky,
  VERSIONS as TA,
  chunk as IA,
  getExportSource as CA,
} from "@excalidraw/common";
var Ut = class {
  static has(o) {
    try {
      return !!window.localStorage.getItem(o);
    } catch (t) {
      return console.warn(`localStorage.getItem error: ${t.message}`), !1;
    }
  }
  static get(o) {
    try {
      let t = window.localStorage.getItem(o);
      return t ? JSON.parse(t) : null;
    } catch (t) {
      return console.warn(`localStorage.getItem error: ${t.message}`), null;
    }
  }
};
I(Ut, "set", (o, t) => {
  try {
    return window.localStorage.setItem(o, JSON.stringify(t)), !0;
  } catch (r) {
    return console.warn(`localStorage.setItem error: ${r.message}`), !1;
  }
}),
  I(Ut, "delete", (o) => {
    try {
      window.localStorage.removeItem(o);
    } catch (t) {
      console.warn(`localStorage.removeItem error: ${t.message}`);
    }
  });
import Tc from "react";
var gA = /({{[\w-]+}})|(<[\w-]+>)|(<\/[\w-]+>)/g,
  fA = /{{([\w-]+)}}/,
  bA = /<([\w-]+)>/,
  xA = /<\/([\w-]+)>/,
  EA = (e, o) => {
    let t = [{ name: "", children: [] }];
    return (
      e
        .split(gA)
        .filter(Boolean)
        .forEach((r) => {
          let n = r.match(bA),
            i = r.match(xA),
            a = r.match(fA);
          if (n !== null) {
            let l = n[1];
            o.hasOwnProperty(l)
              ? t.push({ name: l, children: [] })
              : console.warn(`Trans: missed to pass in prop ${l} for interpolating ${e}`);
          } else if (i !== null)
            if (i[1] === t[t.length - 1].name) {
              let s = t.pop(),
                d = Tc.createElement(Tc.Fragment, {}, ...s.children),
                m = o[s.name];
              typeof m == "function" && t[t.length - 1].children.push(m(d));
            } else console.warn(`Trans: unexpected end tag ${r} for interpolating ${e}`);
          else if (a !== null) {
            let l = a[1];
            o.hasOwnProperty(l)
              ? t[t.length - 1].children.push(o[l])
              : console.warn(`Trans: key ${l} not in props for interpolating ${e}`);
          } else t[t.length - 1].children.push(r);
        }),
      t.length !== 1 && console.warn(`Trans: stack not empty for interpolating ${e}`),
      t[0].children
    );
  },
  yA = ({ i18nKey: e, children: o, ...t }) => {
    let { t: r } = ze();
    return Tc.createElement(Tc.Fragment, {}, ...EA(r(e), t));
  },
  ut = yA;
import { jsx as ie, jsxs as at } from "react/jsx-runtime";
var SA = async (e) => {
    let r = Math.round(8),
      n = Math.max(Math.round(128 / 64), 2),
      i = IA(e, 6),
      a = document.createElement("canvas");
    (a.width = i[0].length * 128 + (i[0].length + 1) * (r * 2) - r * 2),
      (a.height = i.length * 128 + (i.length + 1) * (r * 2) - r * 2);
    let l = a.getContext("2d");
    (l.fillStyle = Ic.white), l.fillRect(0, 0, a.width, a.height);
    for (let [s, d] of e.entries()) {
      let m = await pr({ elements: d.elements, files: null, maxWidthOrHeight: 128 }),
        { width: c, height: p } = m,
        u = Math.floor(s / 6) * (128 + r * 2),
        f = (s % 6) * (128 + r * 2);
      l.drawImage(m, f + (128 - c) / 2 + r, u + (128 - p) / 2 + r),
        (l.lineWidth = n),
        (l.strokeStyle = Ic.gray[4]),
        l.strokeRect(f + r / 2, u + r / 2, 128 + r, 128 + r);
    }
    return await Ol(new File([await Lo(a)], "preview", { type: ky.png }), {
      outputType: ky.jpg,
      maxWidthOrHeight: 5e3,
    });
  },
  kA = ({ libItem: e, appState: o, index: t, onChange: r, onRemove: n }) => {
    let i = Sy(null),
      a = Sy(null);
    return (
      Gu(() => {
        let l = i.current;
        l &&
          (async () => {
            let s = await pi({
              elements: e.elements,
              appState: { ...o, viewBackgroundColor: Ic.white, exportBackground: !0 },
              files: null,
              skipInliningFonts: !0,
            });
            l.innerHTML = s.outerHTML;
          })();
      }, [e.elements, o]),
      at("div", {
        className: "single-library-item",
        children: [
          e.status === "published" &&
            ie("span", {
              className: "single-library-item-status",
              children: g("labels.statusPublished"),
            }),
          ie("div", { ref: i, className: "single-library-item__svg" }),
          ie(V, {
            "aria-label": g("buttons.remove"),
            type: "button",
            icon: Bt,
            className: "single-library-item--remove",
            onClick: n.bind(null, e.id),
            title: g("buttons.remove"),
          }),
          at("div", {
            style: {
              display: "flex",
              margin: "0.8rem 0",
              width: "100%",
              fontSize: "14px",
              fontWeight: 500,
              flexDirection: "column",
            },
            children: [
              at("label", {
                style: {
                  display: "flex",
                  justifyContent: "space-between",
                  flexDirection: "column",
                },
                children: [
                  at("div", {
                    style: { padding: "0.5em 0" },
                    children: [
                      ie("span", {
                        style: { fontWeight: 500, color: Ic.gray[6] },
                        children: g("publishDialog.itemName"),
                      }),
                      ie("span", { "aria-hidden": "true", className: "required", children: "*" }),
                    ],
                  }),
                  ie("input", {
                    type: "text",
                    ref: a,
                    style: { width: "80%", padding: "0.2rem" },
                    defaultValue: e.name,
                    placeholder: "Item name",
                    onChange: (l) => {
                      r(l.target.value, t);
                    },
                  }),
                ],
              }),
              ie("span", { className: "error", children: e.error }),
            ],
          }),
        ],
      })
    );
  },
  MA = ({
    onClose: e,
    libraryItems: o,
    appState: t,
    onSuccess: r,
    onError: n,
    updateItemsInStorage: i,
    onRemove: a,
  }) => {
    let [l, s] = zu({
        authorName: "",
        githubHandle: "",
        name: "",
        description: "",
        twitterHandle: "",
        website: "",
      }),
      [d, m] = zu(!1);
    Gu(() => {
      let y = Ut.get(Hu.PUBLISH_LIBRARY);
      y && s(y);
    }, []);
    let [c, p] = zu(o.slice());
    Gu(() => {
      p(o.slice());
    }, [o]);
    let u = (y) => {
        s({ ...l, [y.target.name]: y.target.value });
      },
      f = async (y) => {
        y.preventDefault(), m(!0);
        let v = [],
          C = !1;
        if (
          (c.forEach((N) => {
            let O = "";
            N.name || ((O = g("publishDialog.errors.required")), (C = !0)),
              v.push({ ...N, error: O });
          }),
          C)
        ) {
          p(v), m(!1);
          return;
        }
        let S = await SA(c),
          M = {
            type: vA.excalidrawLibrary,
            version: TA.excalidrawLibrary,
            source: CA(),
            libraryItems: c,
          },
          k = JSON.stringify(M, null, 2),
          A = new Blob([k], { type: "application/json" }),
          P = new FormData();
        P.append("excalidrawLib", A),
          P.append("previewImage", S),
          P.append("previewImageType", S.type),
          P.append("title", l.name),
          P.append("authorName", l.authorName),
          P.append("githubHandle", l.githubHandle),
          P.append("name", l.name),
          P.append("description", l.description),
          P.append("twitterHandle", l.twitterHandle),
          P.append("website", l.website),
          fetch(`${T.VITE_APP_LIBRARY_BACKEND}/submit`, { method: "post", body: P })
            .then(
              (N) =>
                N.ok
                  ? N.json().then(({ url: O }) => {
                      Ut.delete(Hu.PUBLISH_LIBRARY),
                        r({ url: O, authorName: l.authorName, items: c });
                    })
                  : N.json()
                      .catch(() => {
                        throw new Error(N.statusText || "something went wrong");
                      })
                      .then((O) => {
                        throw new Error(O.message || N.statusText || "something went wrong");
                      }),
              (N) => {
                console.error(N), n(N), m(!1);
              }
            )
            .catch((N) => {
              console.error(N), n(N), m(!1);
            });
      },
      b = () => {
        let y = [];
        return (
          c.forEach((v, C) => {
            y.push(
              ie(
                "div",
                {
                  className: "single-library-item-wrapper",
                  children: ie(kA, {
                    libItem: v,
                    appState: t,
                    index: C,
                    onChange: (S, M) => {
                      let k = c.slice();
                      (k[M].name = S), p(k);
                    },
                    onRemove: a,
                  }),
                },
                C
              )
            );
          }),
          ie("div", { className: "selected-library-items", children: y })
        );
      },
      x = wA(() => {
        i(c), Ut.set(Hu.PUBLISH_LIBRARY, l), e();
      }, [c, e, i, l]),
      w = !!o.length,
      E = o.some((y) => y.status === "published");
    return ie(Be, {
      onCloseRequest: x,
      title: g("publishDialog.title"),
      className: "publish-library",
      children: w
        ? at("form", {
            onSubmit: f,
            children: [
              ie("div", {
                className: "publish-library-note",
                children: ie(ut, {
                  i18nKey: "publishDialog.noteDescription",
                  link: (y) =>
                    ie("a", {
                      href: "https://libraries.excalidraw.com",
                      target: "_blank",
                      rel: "noopener",
                      children: y,
                    }),
                }),
              }),
              ie("span", {
                className: "publish-library-note",
                children: ie(ut, {
                  i18nKey: "publishDialog.noteGuidelines",
                  link: (y) =>
                    ie("a", {
                      href: "https://github.com/excalidraw/excalidraw-libraries#guidelines",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      children: y,
                    }),
                }),
              }),
              ie("div", {
                className: "publish-library-note",
                children: g("publishDialog.noteItems"),
              }),
              E &&
                ie("span", {
                  className: "publish-library-note publish-library-warning",
                  children: g("publishDialog.republishWarning"),
                }),
              b(),
              at("div", {
                className: "publish-library__fields",
                children: [
                  at("label", {
                    children: [
                      at("div", {
                        children: [
                          ie("span", { children: g("publishDialog.libraryName") }),
                          ie("span", {
                            "aria-hidden": "true",
                            className: "required",
                            children: "*",
                          }),
                        ],
                      }),
                      ie("input", {
                        type: "text",
                        name: "name",
                        required: !0,
                        value: l.name,
                        onChange: u,
                        placeholder: g("publishDialog.placeholder.libraryName"),
                      }),
                    ],
                  }),
                  at("label", {
                    style: { alignItems: "flex-start" },
                    children: [
                      at("div", {
                        children: [
                          ie("span", { children: g("publishDialog.libraryDesc") }),
                          ie("span", {
                            "aria-hidden": "true",
                            className: "required",
                            children: "*",
                          }),
                        ],
                      }),
                      ie("textarea", {
                        name: "description",
                        rows: 4,
                        required: !0,
                        value: l.description,
                        onChange: u,
                        placeholder: g("publishDialog.placeholder.libraryDesc"),
                      }),
                    ],
                  }),
                  at("label", {
                    children: [
                      at("div", {
                        children: [
                          ie("span", { children: g("publishDialog.authorName") }),
                          ie("span", {
                            "aria-hidden": "true",
                            className: "required",
                            children: "*",
                          }),
                        ],
                      }),
                      ie("input", {
                        type: "text",
                        name: "authorName",
                        required: !0,
                        value: l.authorName,
                        onChange: u,
                        placeholder: g("publishDialog.placeholder.authorName"),
                      }),
                    ],
                  }),
                  at("label", {
                    children: [
                      ie("span", { children: g("publishDialog.githubUsername") }),
                      ie("input", {
                        type: "text",
                        name: "githubHandle",
                        value: l.githubHandle,
                        onChange: u,
                        placeholder: g("publishDialog.placeholder.githubHandle"),
                      }),
                    ],
                  }),
                  at("label", {
                    children: [
                      ie("span", { children: g("publishDialog.twitterUsername") }),
                      ie("input", {
                        type: "text",
                        name: "twitterHandle",
                        value: l.twitterHandle,
                        onChange: u,
                        placeholder: g("publishDialog.placeholder.twitterHandle"),
                      }),
                    ],
                  }),
                  at("label", {
                    children: [
                      ie("span", { children: g("publishDialog.website") }),
                      ie("input", {
                        type: "text",
                        name: "website",
                        pattern: "https?://.+",
                        title: g("publishDialog.errors.website"),
                        value: l.website,
                        onChange: u,
                        placeholder: g("publishDialog.placeholder.website"),
                      }),
                    ],
                  }),
                  ie("span", {
                    className: "publish-library-note",
                    children: ie(ut, {
                      i18nKey: "publishDialog.noteLicense",
                      link: (y) =>
                        ie("a", {
                          href: "https://github.com/excalidraw/excalidraw-libraries/blob/main/LICENSE",
                          target: "_blank",
                          rel: "noopener noreferrer",
                          children: y,
                        }),
                    }),
                  }),
                ],
              }),
              at("div", {
                className: "publish-library__buttons",
                children: [
                  ie(Fo, {
                    label: g("buttons.cancel"),
                    onClick: x,
                    "data-testid": "cancel-clear-canvas-button",
                  }),
                  ie(Fo, {
                    type: "submit",
                    label: g("buttons.submit"),
                    actionType: "primary",
                    isLoading: d,
                  }),
                ],
              }),
            ],
          })
        : ie("p", {
            style: { padding: "1em", textAlign: "center", fontWeight: 500 },
            children: g("publishDialog.atleastOneLibItem"),
          }),
    });
  },
  My = MA;
import AA from "clsx";
import { useEffect as DA, useRef as _A } from "react";
import { EVENT as Dy, KEYS as RA } from "@excalidraw/common";
import { forwardRef as Ly } from "react";
import Py from "clsx";
import { jsx as Ay } from "react/jsx-runtime";
var LA = Ly(({ children: e, gap: o, align: t, justifyContent: r, className: n, style: i }, a) =>
    Ay("div", {
      className: Py("Stack Stack_horizontal", n),
      style: { "--gap": o, alignItems: t, justifyContent: r, ...i },
      ref: a,
      children: e,
    })
  ),
  PA = Ly(({ children: e, gap: o, align: t, justifyContent: r, className: n, style: i }, a) =>
    Ay("div", {
      className: Py("Stack Stack_vertical", n),
      style: { "--gap": o, justifyItems: t, justifyContent: r, ...i },
      ref: a,
      children: e,
    })
  ),
  qe = { Row: LA, Col: PA };
import { jsx as Cc } from "react/jsx-runtime";
var _y = ({ children: e, onClickOutside: o, className: t = "", onSelect: r, style: n }) => {
  let i = ae(),
    a = _A(null),
    l = tr({ onClickOutside: o });
  Bn(a, () => {
    l.onClickOutside?.();
  }),
    DA(() => {
      let d = (c) => {
          c.key === RA.ESCAPE && (c.stopImmediatePropagation(), l.onClickOutside?.());
        },
        m = { capture: !0 };
      return (
        document.addEventListener(Dy.KEYDOWN, d, m),
        () => {
          document.removeEventListener(Dy.KEYDOWN, d, m);
        }
      );
    }, [l]);
  let s = AA(`dropdown-menu ${t}`, { "dropdown-menu--mobile": i.editor.isMobile }).trim();
  return Cc(hp.Provider, {
    value: { onSelect: r },
    children: Cc("div", {
      ref: a,
      className: s,
      style: n,
      "data-testid": "dropdown-menu",
      children: i.editor.isMobile
        ? Cc(qe.Col, { className: "dropdown-menu-container", children: e })
        : Cc(Xe, {
            className: "dropdown-menu-container",
            padding: 2,
            style: { zIndex: 2 },
            children: e,
          }),
    }),
  });
};
_y.displayName = "DropdownMenuContent";
var Ry = _y;
import { jsx as BA } from "react/jsx-runtime";
var NA = ({ children: e, className: o = "", selected: t, ...r }) =>
    BA("div", {
      ...r,
      className: `dropdown-menu-item-base dropdown-menu-item-custom ${o} ${
        t ? "dropdown-menu-item--selected" : ""
      }`.trim(),
      children: e,
    }),
  Ny = NA;
import { jsx as By } from "react/jsx-runtime";
var Fy = ({
    icon: e,
    shortcut: o,
    href: t,
    children: r,
    onSelect: n,
    className: i = "",
    selected: a,
    rel: l = "noopener",
    ...s
  }) => {
    let d = ks(s.onClick, n);
    return By("a", {
      ...s,
      href: t,
      target: "_blank",
      rel: l || "noopener",
      className: Ss(i, a),
      title: s.title ?? s["aria-label"],
      onClick: d,
      children: By(Cs, { icon: e, shortcut: o, children: r }),
    });
  },
  gi = Fy;
Fy.displayName = "DropdownMenuItemLink";
import { jsx as FA } from "react/jsx-runtime";
var Oy = () =>
    FA("div", {
      style: { height: "1px", backgroundColor: "var(--default-border-color)", margin: ".5rem 0" },
    }),
  zy = Oy;
Oy.displayName = "DropdownMenuSeparator";
import OA from "clsx";
import { jsx as zA } from "react/jsx-runtime";
var Hy = ({ className: e = "", children: o, onToggle: t, title: r, ...n }) => {
    let i = ae(),
      a = OA(`dropdown-menu-button ${e}`, "zen-mode-transition", {
        "dropdown-menu-button--mobile": i.editor.isMobile,
      }).trim();
    return zA("button", {
      "data-prevent-outside-click": !0,
      className: a,
      onClick: t,
      type: "button",
      "data-testid": "dropdown-menu-button",
      title: r,
      ...n,
      children: o,
    });
  },
  Gy = Hy;
Hy.displayName = "DropdownMenuTrigger";
import Sc from "react";
var Uy = (e) => {
    let o = Sc.Children.toArray(e).find(
      (t) =>
        Sc.isValidElement(t) &&
        typeof t.type != "string" &&
        t?.type.displayName &&
        t.type.displayName === "DropdownMenuTrigger"
    );
    return o || null;
  },
  Yy = (e) => {
    let o = Sc.Children.toArray(e).find(
      (t) =>
        Sc.isValidElement(t) &&
        typeof t.type != "string" &&
        t?.type.displayName &&
        t.type.displayName === "DropdownMenuContent"
    );
    return o || null;
  };
import { Fragment as HA, jsxs as GA } from "react/jsx-runtime";
var Oo = ({ children: e, open: o }) => {
  let t = Uy(e),
    r = Yy(e);
  return GA(HA, { children: [t, o && r] });
};
Oo.Trigger = Gy;
Oo.Content = Ry;
Oo.Item = mt;
Oo.ItemLink = gi;
Oo.ItemCustom = Ny;
Oo.Group = da;
Oo.Separator = zy;
var fe = Oo;
Oo.displayName = "DropdownMenu";
import { jsx as vt, jsxs as kc } from "react/jsx-runtime";
var VA = (e, o) => e.filter((t) => o.includes(t.id)),
  XA = ({
    setAppState: e,
    selectedItems: o,
    library: t,
    onRemoveFromLibrary: r,
    resetLibrary: n,
    onSelectItems: i,
    appState: a,
    className: l,
  }) => {
    let [s] = ne(tn),
      [d, m] = ne(hi),
      c = () => {
        let P = o.length
            ? g("alerts.removeItemsFromsLibrary", { count: o.length })
            : g("alerts.resetLibrary"),
          N = o.length ? g("confirmDialog.removeItemsFromLib") : g("confirmDialog.resetLibrary");
        return vt(vc, {
          onConfirm: () => {
            o.length ? r() : n(), u(!1);
          },
          onCancel: () => {
            u(!1);
          },
          title: N,
          children: vt("p", { children: P }),
        });
      },
      [p, u] = Uu(!1),
      f = !!o.length,
      b = f ? s.libraryItems.filter((P) => o.includes(P.id)) : s.libraryItems,
      x = f ? g("buttons.remove") : g("buttons.resetLibrary"),
      [w, E] = Uu(!1),
      [y, v] = Uu(null),
      C = YA(
        () =>
          kc(Be, {
            onCloseRequest: () => v(null),
            title: g("publishSuccessDialog.title"),
            className: "publish-library-success",
            size: "small",
            children: [
              vt("p", {
                children: vt(ut, {
                  i18nKey: "publishSuccessDialog.content",
                  authorName: y.authorName,
                  link: (P) =>
                    vt("a", {
                      href: y?.url,
                      target: "_blank",
                      rel: "noopener noreferrer",
                      children: P,
                    }),
                }),
              }),
              vt(V, {
                type: "button",
                title: g("buttons.close"),
                "aria-label": g("buttons.close"),
                label: g("buttons.close"),
                onClick: () => v(null),
                "data-testid": "publish-library-success-close",
                className: "publish-library-success-close",
              }),
            ],
          }),
        [v, y]
      ),
      S = (P, N) => {
        E(!1), v({ url: P.url, authorName: P.authorName });
        let O = N.slice();
        O.forEach((U) => {
          o.includes(U.id) && (U.status = "published");
        }),
          t.setLibrary(O);
      },
      M = async () => {
        try {
          await t.updateLibrary({
            libraryItems: Ll({ description: "Excalidraw library files" }),
            merge: !0,
            openLibraryMenu: !0,
          });
        } catch (P) {
          if (P?.name === "AbortError") {
            console.warn(P);
            return;
          }
          e({ errorMessage: g("errors.importLibraryError") });
        }
      },
      k = async () => {
        let P = f ? b : await t.getLatestLibrary();
        Jf(P)
          .catch(WA)
          .catch((N) => {
            e({ errorMessage: N.message });
          });
      },
      A = () =>
        kc(fe, {
          open: d,
          children: [
            vt(fe.Trigger, { onToggle: () => m(!d), children: C1 }),
            kc(fe.Content, {
              onClickOutside: () => m(!1),
              onSelect: () => m(!1),
              className: "library-menu",
              children: [
                !f &&
                  vt(fe.Item, {
                    onSelect: M,
                    icon: Mn,
                    "data-testid": "lib-dropdown--load",
                    children: g("buttons.load"),
                  }),
                !!b.length &&
                  vt(fe.Item, {
                    onSelect: k,
                    icon: Gr,
                    "data-testid": "lib-dropdown--export",
                    children: g("buttons.export"),
                  }),
                !!b.length && vt(fe.Item, { onSelect: () => u(!0), icon: kt, children: x }),
                f &&
                  vt(fe.Item, {
                    icon: N0,
                    onSelect: () => E(!0),
                    "data-testid": "lib-dropdown--remove",
                    children: g("buttons.publishLibrary"),
                  }),
              ],
            }),
          ],
        });
    return kc("div", {
      className: UA("library-menu-dropdown-container", l),
      children: [
        A(),
        o.length > 0 && vt("div", { className: "library-actions-counter", children: o.length }),
        p && c(),
        w &&
          vt(My, {
            onClose: () => E(!1),
            libraryItems: VA(s.libraryItems, o),
            appState: a,
            onSuccess: (P) => S(P, s.libraryItems),
            onError: (P) => window.alert(P),
            updateItemsInStorage: () => t.setLibrary(s.libraryItems),
            onRemove: (P) => i(o.filter((N) => N !== P)),
          }),
        y && C(),
      ],
    });
  },
  Yu = ({ selectedItems: e, onSelectItems: o, className: t }) => {
    let { library: r } = Re(),
      { clearLibraryCache: n, deleteItemsFromLibraryCache: i } = gc(),
      a = ge(),
      l = le(),
      [s] = ne(tn),
      d = async (c) => {
        let p = c.filter((u) => !e.includes(u.id));
        r.setLibrary(p).catch(() => {
          l({ errorMessage: g("alerts.errorRemovingFromLibrary") });
        }),
          i(e),
          o([]);
      };
    return vt(XA, {
      appState: a,
      setAppState: l,
      selectedItems: e,
      onSelectItems: o,
      library: r,
      onRemoveFromLibrary: () => d(s.libraryItems),
      resetLibrary: () => {
        r.resetLibrary(), n();
      },
      className: t,
    });
  };
import { memo as t8, useEffect as o8, useState as r8 } from "react";
import KA, { useCallback as ZA } from "react";
function $A() {
  return [!1, ZA((o) => o(), [])];
}
var Wy = KA.useTransition || $A;
import Vy from "clsx";
import { memo as jA, useEffect as qA, useRef as JA, useState as QA } from "react";
import { jsx as Mc, jsxs as e8 } from "react/jsx-runtime";
var Xy = jA(
    ({
      id: e,
      elements: o,
      isPending: t,
      onClick: r,
      selected: n,
      onToggle: i,
      onDrag: a,
      svgCache: l,
    }) => {
      let s = JA(null),
        d = my(e, o, l);
      qA(() => {
        let f = s.current;
        if (f)
          return (
            d && (f.innerHTML = d.outerHTML),
            () => {
              f.innerHTML = "";
            }
          );
      }, [d]);
      let [m, c] = QA(!1),
        p = ae().editor.isMobile,
        u = t && Mc("div", { className: "library-unit__adder", children: I1 });
      return e8("div", {
        className: Vy("library-unit", {
          "library-unit__active": o,
          "library-unit--hover": o && m,
          "library-unit--selected": n,
          "library-unit--skeleton": !d,
        }),
        onMouseEnter: () => c(!0),
        onMouseLeave: () => c(!1),
        children: [
          Mc("div", {
            className: Vy("library-unit__dragger", { "library-unit__pulse": !!t }),
            ref: s,
            draggable: !!o,
            onClick:
              o || t
                ? (f) => {
                    e && f.shiftKey ? i(e, f) : r(e);
                  }
                : void 0,
            onDragStart: (f) => {
              if (!e) {
                f.preventDefault();
                return;
              }
              c(!1), a(e, f);
            },
          }),
          u,
          e &&
            o &&
            (m || p || n) &&
            Mc(ba, {
              checked: n,
              onChange: (f, b) => i(e, b),
              className: "library-unit__checkbox",
            }),
        ],
      });
    }
  ),
  Ky = () => Mc("div", { className: "library-unit library-unit--skeleton" });
import { Fragment as n8, jsx as Lc } from "react/jsx-runtime";
var Wu = ({ children: e }) =>
    Lc("div", { className: "library-menu-items-container__grid", children: e }),
  Pc = t8(
    ({
      items: e,
      onItemSelectToggle: o,
      onItemDrag: t,
      isItemSelected: r,
      onClick: n,
      svgCache: i,
      itemsRenderedPerBatch: a,
    }) => {
      let [, l] = Wy(),
        [s, d] = r8(0);
      return (
        o8(() => {
          s < e.length &&
            l(() => {
              d(s + a);
            });
        }, [s, e.length, l, a]),
        Lc(n8, {
          children: e.map((m, c) =>
            c < s
              ? Lc(
                  Xy,
                  {
                    elements: m?.elements,
                    isPending: !m?.id && !!m?.elements,
                    onClick: n,
                    svgCache: i,
                    id: m?.id,
                    selected: r(m.id),
                    onToggle: o,
                    onDrag: t,
                  },
                  m?.id ?? c
                )
              : Lc(Ky, {}, c)
          ),
        })
      );
    }
  );
import { Fragment as $y, jsx as Tt, jsxs as bi } from "react/jsx-runtime";
var m8 = 17,
  p8 = 64;
function Vu({
  isLoading: e,
  libraryItems: o,
  onAddToLibrary: t,
  onInsertLibraryItems: r,
  pendingElements: n,
  theme: i,
  id: a,
  libraryReturnUrl: l,
  onSelectItems: s,
  selectedItems: d,
}) {
  let m = a8(null),
    c = vy(m);
  i8(() => {
    c > 0 && m.current?.scrollTo(0, c);
  }, []);
  let { svgCache: p } = gc(),
    u = Zy(() => o.filter((P) => P.status !== "published"), [o]),
    f = Zy(() => o.filter((P) => P.status === "published"), [o]),
    b = !o.length && !n.length,
    x = !n.length && !u.length && !f.length,
    [w, E] = l8(null),
    y = fi(
      (P, N) => {
        let O = !d.includes(P),
          U = [...u, ...f];
        if (O) {
          if (N.shiftKey && w) {
            let J = U.findIndex(($) => $.id === w),
              _ = U.findIndex(($) => $.id === P);
            if (J === -1 || _ === -1) {
              s([...d, P]);
              return;
            }
            let R = c8(d),
              X = U.reduce(
                ($, W, ce) => (((ce >= J && ce <= _) || R.has(W.id)) && $.push(W.id), $),
                []
              );
            s(X);
          } else s([...d, P]);
          E(P);
        } else E(null), s(d.filter((J) => J !== P));
      },
      [w, s, f, d, u]
    ),
    v = fi(
      (P) => {
        let N;
        return (
          d.includes(P)
            ? (N = o.filter((O) => d.includes(O.id)))
            : (N = o.filter((O) => O.id === P)),
          N.map((O) => ({
            ...O,
            elements: d8({ type: "everything", elements: O.elements, randomizeSeed: !0 })
              .duplicatedElements,
          }))
        );
      },
      [o, d]
    ),
    C = fi(
      (P, N) => {
        N.dataTransfer.setData(s8.excalidrawlib, hm(v(P)));
      },
      [v]
    ),
    S = fi((P) => (P ? d.includes(P) : !1), [d]),
    M = fi(() => {
      t(n);
    }, [n, t]),
    k = fi(
      (P) => {
        P && r(v(P));
      },
      [v, r]
    ),
    A = p.size >= o.length ? p8 : m8;
  return bi("div", {
    className: "library-menu-items-container",
    style:
      n.length || u.length || f.length ? { justifyContent: "flex-start" } : { borderBottom: 0 },
    children: [
      !x &&
        Tt(Yu, {
          selectedItems: d,
          onSelectItems: s,
          className: "library-menu-dropdown-container--in-heading",
        }),
      bi(qe.Col, {
        className: "library-menu-items-container__items",
        align: "start",
        gap: 1,
        style: { flex: f.length > 0 ? 1 : "0 1 auto", marginBottom: 0 },
        ref: m,
        children: [
          bi($y, {
            children: [
              !x &&
                Tt("div", {
                  className: "library-menu-items-container__header",
                  children: g("labels.personalLib"),
                }),
              e &&
                Tt("div", {
                  style: {
                    position: "absolute",
                    top: "var(--container-padding-y)",
                    right: "var(--container-padding-x)",
                    transform: "translateY(50%)",
                  },
                  children: Tt(tt, {}),
                }),
              !n.length && !u.length
                ? bi("div", {
                    className: "library-menu-items__no-items",
                    children: [
                      Tt("div", {
                        className: "library-menu-items__no-items__label",
                        children: g("library.noItems"),
                      }),
                      Tt("div", {
                        className: "library-menu-items__no-items__hint",
                        children:
                          f.length > 0
                            ? g("library.hint_emptyPrivateLibrary")
                            : g("library.hint_emptyLibrary"),
                      }),
                    ],
                  })
                : bi(Wu, {
                    children: [
                      n.length > 0 &&
                        Tt(Pc, {
                          itemsRenderedPerBatch: A,
                          items: [{ id: null, elements: n }],
                          onItemSelectToggle: y,
                          onItemDrag: C,
                          onClick: M,
                          isItemSelected: S,
                          svgCache: p,
                        }),
                      Tt(Pc, {
                        itemsRenderedPerBatch: A,
                        items: u,
                        onItemSelectToggle: y,
                        onItemDrag: C,
                        onClick: k,
                        isItemSelected: S,
                        svgCache: p,
                      }),
                    ],
                  }),
            ],
          }),
          bi($y, {
            children: [
              (f.length > 0 || n.length > 0 || u.length > 0) &&
                Tt("div", {
                  className:
                    "library-menu-items-container__header library-menu-items-container__header--excal",
                  children: g("labels.excalidrawLib"),
                }),
              f.length > 0
                ? Tt(Wu, {
                    children: Tt(Pc, {
                      itemsRenderedPerBatch: A,
                      items: f,
                      onItemSelectToggle: y,
                      onItemDrag: C,
                      onClick: k,
                      isItemSelected: S,
                      svgCache: p,
                    }),
                  })
                : u.length > 0
                ? Tt("div", {
                    style: {
                      margin: "1rem 0",
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                      justifyContent: "center",
                      width: "100%",
                      fontSize: ".9rem",
                    },
                    children: g("library.noItems"),
                  })
                : null,
            ],
          }),
          b &&
            Tt(yc, {
              style: { padding: "16px 0", width: "100%" },
              id: a,
              libraryReturnUrl: l,
              theme: i,
              children: Tt(Yu, { selectedItems: d, onSelectItems: s }),
            }),
        ],
      }),
    ],
  });
}
import { jsx as hr, jsxs as Jy } from "react/jsx-runtime";
var hi = me(!1),
  qy = ({ children: e }) => hr("div", { className: "layer-ui__library", children: e }),
  b8 = t2(
    ({
      onInsertLibraryItems: e,
      pendingElements: o,
      onAddToLibrary: t,
      setAppState: r,
      libraryReturnUrl: n,
      library: i,
      id: a,
      theme: l,
      selectedItems: s,
      onSelectItems: d,
    }) => {
      let [m] = ne(tn),
        c = Ku(
          (f) => {
            (async (x, w) => {
              re("element", "addToLibrary", "ui");
              for (let y of h8)
                if (x.some((v) => v.type === y))
                  return r({ errorMessage: g(`errors.libraryElementTypeError.${y}`) });
              let E = [{ status: "unpublished", elements: x, id: g8(), created: Date.now() }, ...w];
              t(),
                i.setLibrary(E).catch(() => {
                  r({ errorMessage: g("alerts.errorAddingToLibrary") });
                });
            })(f, m.libraryItems);
          },
          [t, i, r, m.libraryItems]
        ),
        p = e2(() => m.libraryItems, [m]);
      if (m.status === "loading" && !m.isInitialized)
        return hr(qy, {
          children: hr("div", {
            className: "layer-ui__library-message",
            children: Jy("div", {
              children: [
                hr(tt, { size: "2em" }),
                hr("span", { children: g("labels.libraryLoadingMessage") }),
              ],
            }),
          }),
        });
      let u = m.libraryItems.length > 0 || o.length > 0;
      return Jy(qy, {
        children: [
          hr(Vu, {
            isLoading: m.status === "loading",
            libraryItems: p,
            onAddToLibrary: c,
            onInsertLibraryItems: e,
            pendingElements: o,
            id: a,
            libraryReturnUrl: n,
            theme: l,
            onSelectItems: d,
            selectedItems: s,
          }),
          u &&
            hr(yc, {
              className: "library-menu-control-buttons--at-bottom",
              style: { padding: "16px 12px 0 12px" },
              id: a,
              libraryReturnUrl: n,
              theme: l,
            }),
        ],
      });
    }
  ),
  Xu = (e, o) => ({
    elements: e,
    pending: Z(
      e,
      { selectedElementIds: o },
      { includeBoundTextElement: !0, includeElementsInFrames: !0 }
    ),
    selectedElementIds: o,
  }),
  x8 = (e, o) => {
    let t = nr(),
      [r, n] = Qy(() => Xu(t, e.selectedElementIds)),
      i = u8(new Map());
    return (
      jy(() => {
        for (let a of r.pending) i.current.set(a.id, a.version);
      }, [r.pending]),
      jy(() => {
        o.state.cursorButton === "up" &&
          o.state.activeTool.type === "selection" &&
          n((a) => {
            if (!f8(a.selectedElementIds, e.selectedElementIds))
              return i.current.clear(), Xu(t, e.selectedElementIds);
            let l = o.scene.getNonDeletedElementsMap();
            for (let s of Object.keys(e.selectedElementIds)) {
              let d = l.get(s)?.version;
              if (d && d !== i.current.get(s)) return Xu(t, e.selectedElementIds);
            }
            return a;
          });
      }, [o, o.state.cursorButton, o.state.activeTool.type, e.selectedElementIds, t]),
      r.pending
    );
  },
  o2 = t2(() => {
    let e = Re(),
      { onInsertElements: o } = e,
      t = bo(),
      r = ge(),
      n = le(),
      [i, a] = Qy([]),
      l = e2(() => e.library, [e.library]),
      s = x8(r, e),
      d = Ku(
        (c) => {
          o(Ec(c));
        },
        [o]
      ),
      m = Ku(() => {
        n({ selectedElementIds: {}, selectedGroupIds: {}, activeEmbeddable: null });
      }, [n]);
    return hr(b8, {
      pendingElements: s,
      onInsertLibraryItems: d,
      onAddToLibrary: m,
      setAppState: n,
      libraryReturnUrl: t.libraryReturnUrl,
      library: l,
      id: e.id,
      theme: r.theme,
      selectedItems: i,
      onSelectItems: a,
    });
  });
import E8 from "clsx";
import { useRef as y8 } from "react";
import { createPortal as w8 } from "react-dom";
import { KEYS as v8 } from "@excalidraw/common";
import { jsx as r2, jsxs as T8 } from "react/jsx-runtime";
var n2 = (e) => {
  let { closeOnClickOutside: o = !0 } = e,
    t = bs({ className: "excalidraw-modal-container" }),
    r = y8(document.body.classList.contains("excalidraw-animations-disabled"));
  if (!t) return null;
  let n = (i) => {
    i.key === v8.ESCAPE &&
      (i.nativeEvent.stopImmediatePropagation(), i.stopPropagation(), e.onCloseRequest());
  };
  return w8(
    T8("div", {
      className: E8("Modal", e.className, { "animations-disabled": r.current }),
      role: "dialog",
      "aria-modal": "true",
      onKeyDown: n,
      "aria-labelledby": e.labelledBy,
      "data-prevent-outside-click": !0,
      children: [
        r2("div", { className: "Modal__background", onClick: o ? e.onCloseRequest : void 0 }),
        r2("div", {
          className: "Modal__content",
          style: { "--max-width": `${e.maxWidth}px` },
          tabIndex: 0,
          children: e.children,
        }),
      ],
    }),
    t
  );
};
import { jsx as Fa, jsxs as L8 } from "react/jsx-runtime";
function M8(e) {
  if (e && typeof e == "number") return e;
  switch (e) {
    case "small":
      return 550;
    case "wide":
      return 1024;
    case "regular":
    default:
      return 800;
  }
}
var Be = (e) => {
  let [o, t] = sy(),
    [r] = S8(document.activeElement),
    { id: n } = Ge(),
    i = ae().viewport.isMobile;
  C8(() => {
    if (!o) return;
    let d = i2(o);
    setTimeout(() => {
      d.length > 0 && e.autofocus !== !1 && (d[1] || d[0]).focus();
    });
    let m = (c) => {
      if (c.key === k8.TAB) {
        let p = i2(o),
          { activeElement: u } = document,
          f = p.findIndex((b) => b === u);
        f === 0 && c.shiftKey
          ? (p[p.length - 1].focus(), c.preventDefault())
          : f === p.length - 1 && !c.shiftKey && (p[0].focus(), c.preventDefault());
      }
    };
    return o.addEventListener("keydown", m), () => o.removeEventListener("keydown", m);
  }, [o, e.autofocus]);
  let a = le(),
    l = Qo(hi),
    s = () => {
      a({ openMenu: null }), l(!1), r.focus(), e.onCloseRequest();
    };
  return Fa(n2, {
    className: I8("Dialog", e.className, { "Dialog--fullscreen": i }),
    labelledBy: "dialog-title",
    maxWidth: M8(e.size),
    onCloseRequest: s,
    closeOnClickOutside: e.closeOnClickOutside,
    children: L8(Xe, {
      ref: t,
      children: [
        e.title &&
          Fa("h2", {
            id: `${n}-dialog-title`,
            className: "Dialog__title",
            children: Fa("span", { className: "Dialog__titleContent", children: e.title }),
          }),
        i &&
          Fa("button", {
            className: "Dialog__close",
            onClick: s,
            title: g("buttons.close"),
            "aria-label": g("buttons.close"),
            type: "button",
            children: Bt,
          }),
        Fa("div", { className: "Dialog__content", children: e.children }),
      ],
    }),
  });
};
import Zu from "clsx";
import {
  forwardRef as _8,
  useRef as R8,
  useImperativeHandle as N8,
  useLayoutEffect as B8,
  useState as F8,
} from "react";
import P8 from "clsx";
import { composeEventHandlers as A8 } from "@excalidraw/common";
import { jsx as D8 } from "react/jsx-runtime";
var _t = ({ type: e = "button", onSelect: o, selected: t, children: r, className: n = "", ...i }) =>
  D8("button", {
    onClick: A8(i.onClick, (a) => {
      o();
    }),
    type: e,
    className: P8("excalidraw-button", n, { selected: t }),
    ...i,
    children: r,
  });
import { jsx as $u, jsxs as a2 } from "react/jsx-runtime";
var xi = _8(
  (
    {
      onChange: e,
      label: o,
      fullWidth: t,
      placeholder: r,
      readonly: n,
      selectOnRender: i,
      onKeyDown: a,
      isRedacted: l = !1,
      icon: s,
      className: d,
      ...m
    },
    c
  ) => {
    let p = R8(null);
    N8(c, () => p.current),
      B8(() => {
        i && (p.current?.focus(), p.current?.select());
      }, [i]);
    let [u, f] = F8(!1);
    return a2("div", {
      className: Zu("ExcTextField", d, {
        "ExcTextField--fullWidth": t,
        "ExcTextField--hasIcon": !!s,
      }),
      onClick: () => {
        p.current?.focus();
      },
      children: [
        s,
        o && $u("div", { className: "ExcTextField__label", children: o }),
        a2("div", {
          className: Zu("ExcTextField__input", { "ExcTextField__input--readonly": n }),
          children: [
            $u("input", {
              className: Zu({ "is-redacted": "value" in m && m.value && l && !u }),
              readOnly: n,
              value: "value" in m ? m.value : void 0,
              defaultValue: "defaultValue" in m ? m.defaultValue : void 0,
              placeholder: r,
              ref: p,
              onChange: (b) => e?.(b.target.value),
              onKeyDown: a,
            }),
            l &&
              $u(_t, {
                onSelect: () => f(!u),
                style: { border: 0, userSelect: "none" },
                children: u ? Y0 : An,
              }),
          ],
        }),
      ],
    });
  }
);
import { KEYS as Ue } from "@excalidraw/common";
var Oa = [
    { icon: A1, value: "selection", key: Ue.V, numericKey: Ue[1], fillable: !0 },
    { icon: Yl, value: "rectangle", key: Ue.R, numericKey: Ue[2], fillable: !0 },
    { icon: Wl, value: "diamond", key: Ue.D, numericKey: Ue[3], fillable: !0 },
    { icon: Vl, value: "ellipse", key: Ue.O, numericKey: Ue[4], fillable: !0 },
    { icon: D1, value: "arrow", key: Ue.A, numericKey: Ue[5], fillable: !0 },
    { icon: Xl, value: "line", key: Ue.L, numericKey: Ue[6], fillable: !0 },
    { icon: er, value: "freedraw", key: [Ue.P, Ue.X], numericKey: Ue[7], fillable: !1 },
    { icon: Sn, value: "text", key: Ue.T, numericKey: Ue[8], fillable: !1 },
    { icon: R1, value: "image", key: null, numericKey: Ue[9], fillable: !1 },
    { icon: N1, value: "eraser", key: Ue.E, numericKey: Ue[0], fillable: !1 },
  ],
  l2 = (e) =>
    Oa.find(
      (t, r) =>
        (t.numericKey != null && e === t.numericKey.toString()) ||
        (t.key && (typeof t.key == "string" ? t.key === e : t.key.includes(e)))
    )?.value || null;
import Qu from "clsx";
import { useState as H8 } from "react";
import {
  CLASSES as G8,
  KEYS as c2,
  capitalizeString as Ju,
  isTransparent as d2,
} from "@excalidraw/common";
import {
  shouldAllowVerticalAlign as U8,
  suppportsHorizontalAlign as Y8,
} from "@excalidraw/element";
import {
  hasBoundTextElement as m2,
  isElbowArrow as W8,
  isImageElement as V8,
  isLinearElement as X8,
  isTextElement as K8,
} from "@excalidraw/element";
import { hasStrokeColor as p2, toolIsArrow as u2 } from "@excalidraw/element";
import { createIsolation as O8 } from "jotai-scope";
import ju from "react";
import wo from "tunnel-rat";
var qu = ju.createContext(null),
  Ie = () => ju.useContext(qu),
  z8 = O8(),
  s2 = () =>
    ju.useMemo(
      () => ({
        MainMenuTunnel: wo(),
        WelcomeScreenMenuHintTunnel: wo(),
        WelcomeScreenToolbarHintTunnel: wo(),
        WelcomeScreenHelpHintTunnel: wo(),
        WelcomeScreenCenterTunnel: wo(),
        FooterCenterTunnel: wo(),
        DefaultSidebarTriggerTunnel: wo(),
        DefaultSidebarTabTriggersTunnel: wo(),
        OverwriteConfirmDialogTunnel: wo(),
        TTDDialogTriggerTunnel: wo(),
        tunnelsJotai: z8,
      }),
      []
    );
import { Fragment as zo, jsx as Te, jsxs as $e } from "react/jsx-runtime";
var eh = (e, o) => {
    let t = o[0]?.type || null;
    for (let r of o)
      if (r.type !== t) {
        t = null;
        break;
      }
    return (
      (p2(e.activeTool.type) && t !== "image" && t !== "frame" && t !== "magicframe") ||
      o.some((r) => p2(r.type))
    );
  },
  th = (e, o) => jo(e.activeTool.type) || o.some((t) => jo(t.type)),
  Ac = ({ appState: e, elementsMap: o, renderAction: t, app: r }) => {
    let n = Ml(o, e),
      i = !1;
    n.length === 2 && (m2(n[0]) || m2(n[1])) && (i = !0);
    let a = !!(e.editingTextElement || e.newElement),
      l = ae(),
      s = document.documentElement.getAttribute("dir") === "rtl",
      d =
        (jo(e.activeTool.type) && !d2(e.currentItemBackgroundColor)) ||
        n.some((f) => jo(f.type) && !d2(f.backgroundColor)),
      m = n.length === 1 || i,
      c = !e.editingLinearElement && n.length === 1 && X8(n[0]) && !W8(n[0]),
      p = !e.croppingElementId && n.length === 1 && V8(n[0]),
      u = !i && wt(e, r);
    return $e("div", {
      className: "selected-shape-actions",
      children: [
        Te("div", { children: eh(e, n) && t("changeStrokeColor") }),
        th(e, n) && Te("div", { children: t("changeBackgroundColor") }),
        d && t("changeFillStyle"),
        (sm(e.activeTool.type) || n.some((f) => sm(f.type))) && t("changeStrokeWidth"),
        (e.activeTool.type === "freedraw" || n.some((f) => f.type === "freedraw")) &&
          t("changeStrokeShape"),
        (cm(e.activeTool.type) || n.some((f) => cm(f.type))) &&
          $e(zo, { children: [t("changeStrokeStyle"), t("changeSloppiness")] }),
        (dm(e.activeTool.type) || n.some((f) => dm(f.type))) &&
          Te(zo, { children: t("changeRoundness") }),
        (u2(e.activeTool.type) || n.some((f) => u2(f.type))) &&
          Te(zo, { children: t("changeArrowType") }),
        (e.activeTool.type === "text" || n.some(K8)) &&
          $e(zo, {
            children: [
              t("changeFontFamily"),
              t("changeFontSize"),
              (e.activeTool.type === "text" || Y8(n, o)) && t("changeTextAlign"),
            ],
          }),
        U8(n, o) && t("changeVerticalAlign"),
        (bn(e.activeTool.type) || n.some((f) => bn(f.type))) &&
          Te(zo, { children: t("changeArrowhead") }),
        t("changeOpacity"),
        $e("fieldset", {
          children: [
            Te("legend", { children: g("labels.layers") }),
            $e("div", {
              className: "buttonList",
              children: [t("sendToBack"), t("sendBackward"), t("bringForward"), t("bringToFront")],
            }),
          ],
        }),
        u &&
          !i &&
          $e("fieldset", {
            children: [
              Te("legend", { children: g("labels.align") }),
              $e("div", {
                className: "buttonList",
                children: [
                  s
                    ? $e(zo, {
                        children: [t("alignRight"), t("alignHorizontallyCentered"), t("alignLeft")],
                      })
                    : $e(zo, {
                        children: [t("alignLeft"), t("alignHorizontallyCentered"), t("alignRight")],
                      }),
                  n.length > 2 && t("distributeHorizontally"),
                  Te("div", { style: { flexBasis: "100%", height: 0 } }),
                  $e("div", {
                    style: {
                      display: "flex",
                      flexWrap: "wrap",
                      gap: ".5rem",
                      marginTop: "-0.5rem",
                    },
                    children: [
                      t("alignTop"),
                      t("alignVerticallyCentered"),
                      t("alignBottom"),
                      n.length > 2 && t("distributeVertically"),
                    ],
                  }),
                ],
              }),
            ],
          }),
        !a &&
          n.length > 0 &&
          $e("fieldset", {
            children: [
              Te("legend", { children: g("labels.actions") }),
              $e("div", {
                className: "buttonList",
                children: [
                  !l.editor.isMobile && t("duplicateSelection"),
                  !l.editor.isMobile && t("deleteSelectedElements"),
                  t("group"),
                  t("ungroup"),
                  m && t("hyperlink"),
                  p && t("cropEditor"),
                  c && t("toggleLinearEditor"),
                ],
              }),
            ],
          }),
      ],
    });
  },
  Dc = ({ activeTool: e, appState: o, app: t, UIOptions: r }) => {
    let [n, i] = H8(!1),
      a = e.type === "frame",
      l = e.type === "laser",
      s = e.type === "lasso",
      d = e.type === "embeddable",
      { TTDDialogTriggerTunnel: m } = Ie();
    return $e(zo, {
      children: [
        Oa.map(({ value: c, icon: p, key: u, numericKey: f, fillable: b }, x) => {
          if (r.tools?.[c] === !1) return null;
          let w = g(`toolBar.${c}`),
            E = u && Ju(typeof u == "string" ? u : u[0]),
            y = E ? `${E} ${g("helpDialog.or")} ${f}` : `${f}`;
          return Te(
            V,
            {
              className: Qu("Shape", { fillable: b }),
              type: "radio",
              icon: p,
              checked: e.type === c,
              name: "editor-current-shape",
              title: `${Ju(w)} \u2014 ${y}`,
              keyBindingLabel: f || E,
              "aria-label": Ju(w),
              "aria-keyshortcuts": y,
              "data-testid": `toolbar-${c}`,
              onPointerDown: ({ pointerType: v }) => {
                !o.penDetected && v === "pen" && t.togglePenMode(!0),
                  c === "selection" &&
                    (o.activeTool.type === "selection"
                      ? t.setActiveTool({ type: "lasso" })
                      : t.setActiveTool({ type: "selection" }));
              },
              onChange: ({ pointerType: v }) => {
                o.activeTool.type !== c && re("toolbar", c, "ui"),
                  c === "image" ? t.setActiveTool({ type: c }) : t.setActiveTool({ type: c });
              },
            },
            c
          );
        }),
        Te("div", { className: "App-toolbar__divider" }),
        $e(fe, {
          open: n,
          children: [
            Te(fe.Trigger, {
              className: Qu("App-toolbar__extra-tools-trigger", {
                "App-toolbar__extra-tools-trigger--selected":
                  a || d || s || (l && !t.props.isCollaborating),
              }),
              onToggle: () => i(!n),
              title: g("toolBar.extraTools"),
              children: a ? Yr : d ? Tm : l && !t.props.isCollaborating ? ta : s ? $i : G0,
            }),
            $e(fe.Content, {
              onClickOutside: () => i(!1),
              onSelect: () => i(!1),
              className: "App-toolbar__extra-tools-dropdown",
              children: [
                Te(fe.Item, {
                  onSelect: () => t.setActiveTool({ type: "frame" }),
                  icon: Yr,
                  shortcut: c2.F.toLocaleUpperCase(),
                  "data-testid": "toolbar-frame",
                  selected: a,
                  children: g("toolBar.frame"),
                }),
                Te(fe.Item, {
                  onSelect: () => t.setActiveTool({ type: "embeddable" }),
                  icon: Tm,
                  "data-testid": "toolbar-embeddable",
                  selected: d,
                  children: g("toolBar.embeddable"),
                }),
                Te(fe.Item, {
                  onSelect: () => t.setActiveTool({ type: "laser" }),
                  icon: ta,
                  "data-testid": "toolbar-laser",
                  selected: l,
                  shortcut: c2.K.toLocaleUpperCase(),
                  children: g("toolBar.laser"),
                }),
                Te(fe.Item, {
                  onSelect: () => t.setActiveTool({ type: "lasso" }),
                  icon: $i,
                  "data-testid": "toolbar-lasso",
                  selected: s,
                  children: g("toolBar.lasso"),
                }),
                Te("div", {
                  style: { margin: "6px 0", fontSize: 14, fontWeight: 600 },
                  children: "Generate",
                }),
                t.props.aiEnabled !== !1 && Te(m.Out, {}),
                Te(fe.Item, {
                  onSelect: () => t.setOpenDialog({ name: "ttd", tab: "mermaid" }),
                  icon: ts,
                  "data-testid": "toolbar-embeddable",
                  children: g("toolBar.mermaidToExcalidraw"),
                }),
                t.props.aiEnabled !== !1 &&
                  t.plugins.diagramToCode &&
                  Te(zo, {
                    children: $e(fe.Item, {
                      onSelect: () => t.onMagicframeToolSelect(),
                      icon: os,
                      "data-testid": "toolbar-magicframe",
                      children: [g("toolBar.magicframe"), Te(fe.Item.Badge, { children: "AI" })],
                    }),
                  }),
              ],
            }),
          ],
        }),
      ],
    });
  },
  h2 = ({ renderAction: e, zoom: o }) =>
    Te(qe.Col, {
      gap: 1,
      className: G8.ZOOM_ACTIONS,
      children: $e(qe.Row, {
        align: "center",
        children: [e("zoomOut"), e("resetZoom"), e("zoomIn")],
      }),
    }),
  g2 = ({ renderAction: e, className: o }) =>
    $e("div", {
      className: `undo-redo-buttons ${o}`,
      children: [
        Te("div", {
          className: "undo-button-container",
          children: Te(Lt, { label: g("buttons.undo"), children: e("undo") }),
        }),
        Te("div", {
          className: "redo-button-container",
          children: $e(Lt, { label: g("buttons.redo"), children: [" ", e("redo")] }),
        }),
      ],
    }),
  f2 = ({ actionManager: e, showExitZenModeBtn: o }) =>
    Te("button", {
      type: "button",
      className: Qu("disable-zen-mode", { "disable-zen-mode--visible": o }),
      onClick: () => e.executeAction(ni),
      children: g("buttons.exitZenMode"),
    }),
  b2 = ({ renderAction: e, className: o }) =>
    Te("div", { className: `finalize-button ${o}`, children: e("finalize", { size: "small" }) });
import { useRef as Z8 } from "react";
var oh = (e) => {
  let o = Z8({ userFn: e });
  return (
    (o.current.userFn = e),
    o.current.stableFn || (o.current.stableFn = (...t) => o.current.userFn(...t)),
    o.current.stableFn
  );
};
import { jsx as j8, jsxs as $8 } from "react/jsx-runtime";
var on = me(null),
  x2 = () => {
    let [e, o] = ne(on),
      t = Fe();
    return e && e === "clearCanvas"
      ? j8(vc, {
          onConfirm: () => {
            t.executeAction(No), o(null);
          },
          onCancel: () => o(null),
          title: g("clearCanvasDialog.title"),
          children: $8("p", {
            className: "clear-canvas__content",
            children: [" ", g("alerts.clearReset")],
          }),
        })
      : null;
  };
var rh = {};
Xf(rh, { toggleTheme: () => q8 });
var q8 = {
  ...Kr,
  category: "App",
  label: "Toggle theme",
  perform: ({ actionManager: e }) => {
    e.executeAction(Kr, "commandPalette");
  },
};
import { jsx as ht, jsxs as vo } from "react/jsx-runtime";
var r7 = me(null),
  ke = {
    app: "App",
    export: "Export",
    tools: "Tools",
    editor: "Editor",
    elements: "Elements",
    links: "Links",
  },
  n7 = (e) => {
    switch (e) {
      case ke.app:
        return 1;
      case ke.export:
        return 2;
      case ke.editor:
        return 3;
      case ke.tools:
        return 4;
      case ke.elements:
        return 5;
      case ke.links:
        return 6;
      default:
        return 10;
    }
  },
  Nc = ({ shortcut: e, className: o, children: t }) => {
    let r = e.replace("++", "+$").split("+");
    return vo("div", {
      className: w2("shortcut", o),
      children: [
        r.map((n, i) =>
          ht(
            "div",
            {
              className: "shortcut-wrapper",
              children: ht("div", { className: "shortcut-key", children: n === "$" ? "+" : n }),
            },
            n
          )
        ),
        ht("div", { className: "shortcut-desc", children: t }),
      ],
    });
  },
  v2 = (e) =>
    !e.altKey &&
    e[ao.CTRL_OR_CMD] &&
    ((e.shiftKey && e.key.toLowerCase() === ao.P) || e.key === ao.SLASH),
  Ece = Object.assign(
    (e) => {
      let o = ge(),
        t = le();
      return (
        Rc(() => {
          let r = (n) => {
            v2(n) &&
              (n.preventDefault(),
              n.stopPropagation(),
              t((i) => {
                let a = i.openDialog?.name === "commandPalette" ? null : { name: "commandPalette" };
                return a && re("command_palette", "open", "shortcut"), { openDialog: a };
              }));
          };
          return (
            window.addEventListener(Bc.KEYDOWN, r, { capture: !0 }),
            () => window.removeEventListener(Bc.KEYDOWN, r, { capture: !0 })
          );
        }, [t]),
        o.openDialog?.name !== "commandPalette" ? null : ht(i7, { ...e })
      );
    },
    { defaultItems: rh }
  );
function i7({ customCommandPaletteItems: e }) {
  let o = Re(),
    t = ge(),
    r = le(),
    n = bo(),
    i = Fe(),
    [a, l] = ne(r7),
    [s, d] = _c(null),
    m = Q8(null),
    c = tr({ uiAppState: t, customCommandPaletteItems: e, appProps: n });
  Rc(() => {
    let { uiAppState: S, customCommandPaletteItems: M, appProps: k } = c,
      A = (U) => {
        let J = "";
        return (
          U.label &&
            (typeof U.label == "function"
              ? (J = g(U.label(o.scene.getNonDeletedElements(), S, o)))
              : (J = g(U.label))),
          J
        );
      },
      P = (U) =>
        typeof U.icon == "function" ? U.icon(S, o.scene.getNonDeletedElements()) : U.icon,
      N = [],
      O = (U, J, _) => {
        let R = {
          label: A(U),
          icon: P(U),
          category: J,
          shortcut: Ne(U.name),
          keywords: U.keywords,
          predicate: U.predicate,
          viewMode: U.viewMode,
          perform: () => {
            i.executeAction(U, "commandPalette");
          },
        };
        return _ ? _(R, U) : R;
      };
    if (S && o.scene && i) {
      let U = [
          i.actions.group,
          i.actions.ungroup,
          i.actions.cut,
          i.actions.copy,
          i.actions.deleteSelectedElements,
          i.actions.wrapSelectionInFrame,
          i.actions.copyStyles,
          i.actions.pasteStyles,
          i.actions.bringToFront,
          i.actions.bringForward,
          i.actions.sendBackward,
          i.actions.sendToBack,
          i.actions.alignTop,
          i.actions.alignBottom,
          i.actions.alignLeft,
          i.actions.alignRight,
          i.actions.alignVerticallyCentered,
          i.actions.alignHorizontallyCentered,
          i.actions.duplicateSelection,
          i.actions.flipHorizontal,
          i.actions.flipVertical,
          i.actions.zoomToFitSelection,
          i.actions.zoomToFitSelectionInViewport,
          i.actions.increaseFontSize,
          i.actions.decreaseFontSize,
          i.actions.toggleLinearEditor,
          i.actions.cropEditor,
          i.actions.togglePolygon,
          ka,
          hc,
          ay,
        ].map((W) =>
          O(W, ke.elements, (ce, he) => ({
            ...ce,
            predicate: he.predicate ? he.predicate : (de, it, ho, gn) => Z(de, it).length > 0,
          }))
        ),
        J = [
          i.actions.toggleHandTool,
          i.actions.setFrameAsActiveTool,
          i.actions.toggleLassoTool,
        ].map((W) => O(W, ke.tools)),
        _ = [
          i.actions.undo,
          i.actions.redo,
          i.actions.zoomIn,
          i.actions.zoomOut,
          i.actions.resetZoom,
          i.actions.zoomToFit,
          i.actions.zenMode,
          i.actions.viewMode,
          i.actions.gridMode,
          i.actions.objectsSnapMode,
          i.actions.toggleShortcuts,
          i.actions.selectAll,
          i.actions.toggleElementLock,
          i.actions.unlockAllElements,
          i.actions.stats,
        ].map((W) => O(W, ke.editor)),
        R = [
          i.actions.saveToActiveFile,
          i.actions.saveFileToDisk,
          i.actions.copyAsPng,
          i.actions.copyAsSvg,
        ].map((W) => O(W, ke.export));
      N = [
        ...U,
        ..._,
        {
          label: A(No),
          icon: P(No),
          shortcut: Ne(No.name),
          category: ke.editor,
          keywords: ["delete", "destroy"],
          viewMode: !1,
          perform: () => {
            He.set(on, "clearCanvas");
          },
        },
        {
          label: g("buttons.exportImage"),
          category: ke.export,
          icon: jl,
          shortcut: Ne("imageExport"),
          keywords: ["export", "image", "png", "jpeg", "svg", "clipboard", "picture"],
          perform: () => {
            r({ openDialog: { name: "imageExport" } });
          },
        },
        ...R,
      ];
      let X = [
          {
            label: g("toolBar.library"),
            category: ke.app,
            icon: In,
            viewMode: !1,
            perform: () => {
              S.openSidebar
                ? r({ openSidebar: null })
                : r({ openSidebar: { name: E2.name, tab: E2.defaultTab } });
            },
          },
          {
            label: g("search.title"),
            category: ke.app,
            icon: Mt,
            viewMode: !0,
            perform: () => {
              i.executeAction(za);
            },
          },
          {
            label: g("labels.shapeSwitch"),
            category: ke.elements,
            icon: oa,
            perform: () => {
              i.executeAction(iy);
            },
          },
          {
            label: g("labels.changeStroke"),
            keywords: ["color", "outline"],
            category: ke.elements,
            icon: $l,
            viewMode: !1,
            predicate: (W, ce) => {
              let he = Z(W, ce);
              return he.length > 0 && eh(ce, he);
            },
            perform: () => {
              r((W) => ({
                openMenu: W.openMenu === "shape" ? null : "shape",
                openPopup: "elementStroke",
              }));
            },
          },
          {
            label: g("labels.changeBackground"),
            keywords: ["color", "fill"],
            icon: $l,
            category: ke.elements,
            viewMode: !1,
            predicate: (W, ce) => {
              let he = Z(W, ce);
              return he.length > 0 && th(ce, he);
            },
            perform: () => {
              r((W) => ({
                openMenu: W.openMenu === "shape" ? null : "shape",
                openPopup: "elementBackground",
              }));
            },
          },
          {
            label: g("labels.canvasBackground"),
            keywords: ["color"],
            icon: $l,
            category: ke.editor,
            viewMode: !1,
            perform: () => {
              r((W) => ({
                openMenu: W.openMenu === "canvas" ? null : "canvas",
                openPopup: "canvasBackground",
              }));
            },
          },
          ...Oa.reduce((W, ce) => {
            let { value: he, icon: de, key: it, numericKey: ho } = ce;
            if (k.UIOptions.tools?.[he] === !1) return W;
            let fn = (it && e7(typeof it == "string" ? it : it[0])) || ho,
              Sl = {
                label: g(`toolBar.${he}`),
                category: ke.tools,
                shortcut: fn,
                icon: de,
                keywords: ["toolbar"],
                viewMode: !1,
                perform: ({ event: im }) => {
                  he === "image" ? o.setActiveTool({ type: he }) : o.setActiveTool({ type: he });
                },
              };
            return W.push(Sl), W;
          }, []),
          ...J,
          {
            label: g("toolBar.lock"),
            category: ke.tools,
            icon: S.activeTool.locked ? Cn : Hr,
            shortcut: ao.Q.toLocaleUpperCase(),
            viewMode: !1,
            perform: () => {
              o.toggleLock();
            },
          },
          {
            label: `${g("labels.textToDiagram")}...`,
            category: ke.tools,
            icon: V0,
            viewMode: !1,
            predicate: k.aiEnabled,
            perform: () => {
              r((W) => ({ ...W, openDialog: { name: "ttd", tab: "text-to-diagram" } }));
            },
          },
          {
            label: `${g("toolBar.mermaidToExcalidraw")}...`,
            category: ke.tools,
            icon: ts,
            viewMode: !1,
            predicate: k.aiEnabled,
            perform: () => {
              r((W) => ({ ...W, openDialog: { name: "ttd", tab: "mermaid" } }));
            },
          },
        ],
        $ = [...N, ...X, ...(M || [])].map((W) => ({
          ...W,
          icon: W.icon || oa,
          order: W.order ?? n7(W.category),
          haystack: `${Au(W.label.toLocaleLowerCase())} ${W.keywords?.join(" ") || ""}`,
        }));
      d($), l($.find((W) => W.label === a?.label) ?? null);
    }
  }, [c, o, i, d, a?.label, l, r]);
  let [p, u] = _c(""),
    [f, b] = _c(null),
    [x, w] = _c({}),
    E = (S) => {
      r({ openDialog: null }, S), u("");
    },
    y = (S, M) => {
      t.openDialog?.name === "commandPalette" &&
        (M.stopPropagation(),
        M.preventDefault(),
        document.body.classList.add("excalidraw-animations-disabled"),
        E(() => {
          S.perform({ actionManager: i, event: M }),
            l(S),
            requestAnimationFrame(() => {
              document.body.classList.remove("excalidraw-animations-disabled");
            });
        }));
    },
    v = oh((S) =>
      S.viewMode === !1 && t.viewModeEnabled
        ? !1
        : typeof S.predicate == "function"
        ? S.predicate(o.scene.getNonDeletedElements(), t, n, o)
        : S.predicate === void 0 || S.predicate
    ),
    C = oh((S) => {
      let M = o7(S.target) || v2(S) || S.key === ao.ESCAPE;
      if (M && S.key !== ao.ARROW_UP && S.key !== ao.ARROW_DOWN && S.key !== ao.ENTER) return;
      let k = Object.values(x).flat(),
        A = a && !p && v(a);
      if (S.key === ao.ARROW_UP) {
        S.preventDefault();
        let P = k.findIndex((U) => U.label === f?.label);
        if (A) {
          if (P === 0) {
            b(a);
            return;
          }
          if (f === a) {
            let U = k[k.length - 1];
            U && b(U);
            return;
          }
        }
        let N;
        P === -1 ? (N = k.length - 1) : (N = P === 0 ? k.length - 1 : (P - 1) % k.length);
        let O = k[N];
        O && b(O);
        return;
      }
      if (S.key === ao.ARROW_DOWN) {
        S.preventDefault();
        let P = k.findIndex((U) => U.label === f?.label);
        if (A) {
          if (!f || P === k.length - 1) {
            b(a);
            return;
          }
          if (f === a) {
            let U = k[0];
            U && b(U);
            return;
          }
        }
        let N = (P + 1) % k.length,
          O = k[N];
        O && b(O);
        return;
      }
      if (
        (S.key === ao.ENTER &&
          f &&
          setTimeout(() => {
            y(f, S);
          }),
        !M)
      ) {
        if ((S.stopPropagation(), /^[a-zA-Z0-9]$/.test(S.key))) {
          m?.current?.focus();
          return;
        }
        S.preventDefault();
      }
    });
  return (
    Rc(
      () => (
        window.addEventListener(Bc.KEYDOWN, C, { capture: !0 }),
        () => window.removeEventListener(Bc.KEYDOWN, C, { capture: !0 })
      ),
      [C]
    ),
    Rc(() => {
      if (!s) return;
      let S = (P) => {
          let N = {};
          for (let O of P) N[O.category] ? N[O.category].push(O) : (N[O.category] = [O]);
          return N;
        },
        M = s.filter(v).sort((P, N) => P.order - N.order),
        k = !p && a && v(a);
      if (!p) {
        w(S(k ? M.filter((P) => P.label !== a?.label) : M)), b(k ? a : M[0] || null);
        return;
      }
      let A = Au(p.toLocaleLowerCase().replace(/[<>_| -]/g, ""));
      (M = J8.filter(A, M, { extract: (P) => P.haystack })
        .sort((P, N) => N.score - P.score)
        .map((P) => P.original)),
        w(S(M)),
        b(M[0] ?? null);
    }, [p, s, v, a]),
    vo(Be, {
      onCloseRequest: () => E(),
      closeOnClickOutside: !0,
      title: !1,
      size: 720,
      autofocus: !0,
      className: "command-palette-dialog",
      children: [
        ht(xi, {
          value: p,
          placeholder: g("commandPalette.search.placeholder"),
          onChange: (S) => {
            u(S);
          },
          selectOnRender: !0,
          ref: m,
        }),
        !o.device.viewport.isMobile &&
          vo("div", {
            className: "shortcuts-wrapper",
            children: [
              ht(Nc, { shortcut: "\u2191\u2193", children: g("commandPalette.shortcuts.select") }),
              ht(Nc, { shortcut: "\u21B5", children: g("commandPalette.shortcuts.confirm") }),
              ht(Nc, { shortcut: t7("Esc"), children: g("commandPalette.shortcuts.close") }),
            ],
          }),
        vo("div", {
          className: "commands",
          children: [
            a &&
              !p &&
              vo("div", {
                className: "command-category",
                children: [
                  vo("div", {
                    className: "command-category-title",
                    children: [
                      g("commandPalette.recents"),
                      ht("div", { className: "icon", style: { marginLeft: "6px" }, children: X0 }),
                    ],
                  }),
                  ht(y2, {
                    command: a,
                    isSelected: a.label === f?.label,
                    onClick: (S) => y(a, S),
                    disabled: !v(a),
                    onMouseMove: () => b(a),
                    showShortcut: !o.device.viewport.isMobile,
                    appState: t,
                  }),
                ],
              }),
            Object.keys(x).length > 0
              ? Object.keys(x).map((S, M) =>
                  vo(
                    "div",
                    {
                      className: "command-category",
                      children: [
                        ht("div", { className: "command-category-title", children: S }),
                        x[S].map((k) =>
                          ht(
                            y2,
                            {
                              command: k,
                              isSelected: k.label === f?.label,
                              onClick: (A) => y(k, A),
                              onMouseMove: () => b(k),
                              showShortcut: !o.device.viewport.isMobile,
                              appState: t,
                            },
                            k.label
                          )
                        ),
                      ],
                    },
                    S
                  )
                )
              : s
              ? vo("div", {
                  className: "no-match",
                  children: [
                    ht("div", { className: "icon", children: Mt }),
                    " ",
                    g("commandPalette.search.noMatch"),
                  ],
                })
              : null,
          ],
        }),
      ],
    })
  );
}
var y2 = ({
  command: e,
  isSelected: o,
  disabled: t,
  onMouseMove: r,
  onClick: n,
  showShortcut: i,
  appState: a,
}) => {
  let l = () => {};
  return vo("div", {
    className: w2("command-item", { "item-selected": o, "item-disabled": t }),
    ref: (s) => {
      o && !t && s?.scrollIntoView?.({ block: "nearest" });
    },
    onClick: t ? l : n,
    onMouseMove: t ? l : r,
    title: t ? g("commandPalette.itemNotAvailable") : "",
    children: [
      vo("div", {
        className: "name",
        children: [
          e.icon && ht(lr, { icon: typeof e.icon == "function" ? e.icon(a) : e.icon }),
          e.label,
        ],
      }),
      i && e.shortcut && ht(Nc, { shortcut: e.shortcut }),
    ],
  });
};
import {
  getSizeFromPoints as l1e,
  randomInteger as tD,
  getUpdatedTimestamp as oD,
} from "@excalidraw/common";
import { simplify as V7 } from "points-on-curve";
import { pointsOnBezierCurves as Ice } from "points-on-curve";
import { invariant as Sce } from "@excalidraw/common";
import {
  curve as Mce,
  lineSegment as Lce,
  pointFrom as Pce,
  pointDistance as Ace,
  pointFromArray as Dce,
  pointFromVector as _ce,
  pointRotateRads as Rce,
  polygon as Nce,
  polygonFromPoints as Bce,
  PRECISION as Fce,
  segmentsIntersectAt as Oce,
  vector as zce,
  vectorAdd as Hce,
  vectorFromPoint as Gce,
  vectorScale as Uce,
} from "@excalidraw/math";
import { getElementAbsoluteCoords as Wce } from "@excalidraw/element";
var nh = (e) => {
  if (!e) return [];
  for (let o of e.sets) if (o.type === "path") return o.ops;
  return e.sets[0].ops;
};
import { pointFrom as X7, pointDistance as W2, pointRotateRads as Vfe } from "@excalidraw/math";
import {
  ROUGHNESS as K7,
  isTransparent as Va,
  assertNever as Z7,
  COLOR_PALETTE as $7,
  LINE_POLYGON_POINT_MERGE_DISTANCE as Kfe,
} from "@excalidraw/common";
import { RoughGenerator as j7 } from "roughjs/bin/generator";
import sfe from "roughjs/bin/rough";
import { getStroke as O7 } from "perfect-freehand";
import { isRightAngleRads as mfe } from "@excalidraw/math";
import {
  BOUND_TEXT_PADDING as ufe,
  DEFAULT_REDUCED_GLOBAL_ALPHA as hfe,
  ELEMENT_READY_TO_ERASE_OPACITY as gfe,
  FRAME_STYLE as ffe,
  MIME_TYPES as H2,
  THEME as bfe,
  distance as xfe,
  getFontString as Efe,
  isRTL as yfe,
  getVerticalOffset as wfe,
} from "@excalidraw/common";
import whe from "roughjs/bin/rough";
import {
  arrayToMap as The,
  invariant as D2,
  rescalePoints as Ihe,
  sizeOf as Che,
} from "@excalidraw/common";
import {
  degreesToRadians as fh,
  lineSegment as khe,
  pointDistance as Mhe,
  pointFrom as ot,
  pointFromArray as v7,
  pointRotateRads as vi,
} from "@excalidraw/math";
import { pointsOnBezierCurves as Ahe } from "points-on-curve";
import {
  pointCenter as zue,
  pointFrom as Hue,
  pointRotateRads as Gue,
  pointsEqual as Uue,
  pointDistance as Yue,
  vectorFromPoint as Wue,
  curveLength as Vue,
  curvePointAtLength as Xue,
} from "@excalidraw/math";
import {
  DRAGGING_THRESHOLD as $ue,
  KEYS as jue,
  shouldRotateWithDiscreteAngle as que,
  getGridPoint as Jue,
  invariant as Que,
  tupleToCoors as ehe,
  viewportCoordsToSceneCoords as the,
} from "@excalidraw/common";
import { deconstructLinearOrFreeDrawElement as rhe, isPathALoop as nhe } from "@excalidraw/element";
import {
  KEYS as Ope,
  arrayToMap as zpe,
  isBindingFallthroughEnabled as Hpe,
  tupleToCoors as Gpe,
  invariant as Upe,
  isDevEnv as Ype,
  isTestEnv as Wpe,
} from "@excalidraw/common";
import {
  lineSegment as Xpe,
  pointFrom as Kpe,
  pointRotateRads as Zpe,
  vectorFromPoint as $pe,
  pointDistanceSq as jpe,
  clamp as qpe,
  pointDistance as Jpe,
  pointFromVector as Qpe,
  vectorScale as eue,
  vectorNormalize as tue,
  vectorCross as oue,
  pointsEqual as rue,
  lineSegmentIntersectionPoints as nue,
  PRECISION as iue,
} from "@excalidraw/math";
import { isTransparent as hme } from "@excalidraw/common";
import {
  curveIntersectLineSegment as fme,
  isPointWithinBounds as bme,
  lineSegment as xme,
  lineSegmentIntersectionPoints as Eme,
  pointFrom as yme,
  pointFromVector as wme,
  pointRotateRads as vme,
  pointsEqual as Tme,
  vectorFromPoint as Ime,
  vectorNormalize as Cme,
  vectorScale as Sme,
} from "@excalidraw/math";
import { ellipse as Mme, ellipseSegmentInterceptPoints as Lme } from "@excalidraw/math/ellipse";
import {
  DEFAULT_ADAPTIVE_RADIUS as a7,
  DEFAULT_PROPORTIONAL_RADIUS as ih,
  LINE_CONFIRM_THRESHOLD as l7,
  ROUNDNESS as ah,
} from "@excalidraw/common";
import {
  curve as $ce,
  curveCatmullRomCubicApproxPoints as jce,
  curveOffsetPoints as qce,
  lineSegment as Jce,
  pointDistance as s7,
  pointFrom as Qce,
  pointFromArray as ede,
  rectangle as tde,
} from "@excalidraw/math";
var Fc = (e, o = 1) => {
    if (e.length >= 3) {
      let [t, r] = [e[0], e[e.length - 1]];
      return s7(t, r) <= l7 / o;
    }
    return !1;
  },
  Ha = (e, o) => {
    if (o.roundness?.type === ah.PROPORTIONAL_RADIUS || o.roundness?.type === ah.LEGACY)
      return e * ih;
    if (o.roundness?.type === ah.ADAPTIVE_RADIUS) {
      let t = o.roundness?.value ?? a7,
        r = t / ih;
      return e <= r ? e * ih : t;
    }
    return 0;
  };
import { ROUNDNESS as sde, assertNever as cde } from "@excalidraw/common";
import { pointsEqual as mde } from "@excalidraw/math";
var T2 = (e) => !!e && e.type === "embeddable",
  I2 = (e) => !!e && e.type === "iframe",
  sh = (e) => !!e && (e.type === "iframe" || e.type === "embeddable"),
  rn = (e) => e != null && e.type === "text";
var Oc = (e) => e != null && (e.type === "frame" || e.type === "magicframe");
var gr = (e) => e != null && c7(e.type);
var Ei = (e) => e != null && e.type === "arrow",
  Ga = (e) => Ei(e) && e.elbowed;
var c7 = (e) => e === "arrow" || e === "line";
var Ua = (e) => e !== null && "containerId" in e && e.containerId !== null && rn(e);
import {
  ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO as Hde,
  ARROW_LABEL_WIDTH_FRACTION as Gde,
  BOUND_TEXT_PADDING as Ude,
  DEFAULT_FONT_SIZE as Yde,
  TEXT_ALIGN as Wde,
  VERTICAL_ALIGN as Vde,
  getFontString as Xde,
  isProdEnv as Kde,
  invariant as Zde,
} from "@excalidraw/common";
import {
  BOUND_TEXT_PADDING as bde,
  DEFAULT_FONT_SIZE as xde,
  DEFAULT_FONT_FAMILY as Ede,
  getFontString as yde,
  isTestEnv as wde,
  normalizeEOL as vde,
} from "@excalidraw/common";
var Tde = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".toLocaleUpperCase();
import { isDevEnv as Pde, isTestEnv as Ade } from "@excalidraw/common";
import {
  curvePointDistance as rme,
  distanceToLineSegment as nme,
  pointRotateRads as ime,
} from "@excalidraw/math";
import { ellipse as lme, ellipseDistanceFromPoint as sme } from "@excalidraw/math/ellipse";
import { invariant as Gme, isDevEnv as Ume, isTestEnv as Yme } from "@excalidraw/common";
import {
  pointFrom as Vme,
  pointFromVector as Xme,
  pointRotateRads as Kme,
  pointScaleFromOrigin as Zme,
  pointsEqual as $me,
  triangleIncludesPoint as jme,
  vectorCross as qme,
  vectorFromPoint as h7,
  vectorScale as Jme,
} from "@excalidraw/math";
var hh = [1, 0],
  M2 = [0, 1],
  gh = [-1, 0],
  L2 = [0, -1],
  zc = (e) => {
    let [o, t] = e,
      r = Math.abs(o),
      n = Math.abs(t);
    return o > n ? hh : o <= -n ? gh : t > r ? M2 : L2;
  },
  P2 = (e, o) => zc(h7(e, o)),
  Hc = (e, o) => Gc(P2(e, o)),
  uh = (e, o) => e[0] === o[0] && e[1] === o[1],
  Gc = (e) => uh(e, hh) || uh(e, gh);
import {
  clamp as npe,
  pointDistance as ipe,
  pointFrom as ape,
  pointScaleFromOrigin as lpe,
  pointsEqual as spe,
  pointTranslate as cpe,
  vector as dpe,
  vectorCross as mpe,
  vectorFromPoint as ppe,
  vectorScale as upe,
} from "@excalidraw/math";
import {
  BinaryHeap as gpe,
  invariant as fpe,
  isAnyTrue as bpe,
  tupleToCoors as xpe,
  getSizeFromPoints as Epe,
  isDevEnv as ype,
  arrayToMap as wpe,
} from "@excalidraw/common";
import { SHIFT_LOCKING_ANGLE as yue, viewportCoordsToSceneCoords as wue } from "@excalidraw/common";
import {
  normalizeRadians as Tue,
  radiansBetweenAngles as Iue,
  radiansDifference as Cue,
} from "@excalidraw/math";
import { pointsEqual as kue } from "@excalidraw/math";
var lh = (e) => {
  let o = Math.floor(e.width / 2) + 1,
    t = 0,
    r = e.width,
    n = Math.floor(e.height / 2) + 1,
    i = o,
    a = e.height;
  return [o, t, r, n, i, a, 0, n];
};
var T7 = (e) => {
    switch (e) {
      case "arrow":
        return 25;
      case "diamond":
      case "diamond_outline":
        return 12;
      case "crowfoot_many":
      case "crowfoot_one":
      case "crowfoot_one_or_many":
        return 20;
      default:
        return 15;
    }
  },
  I7 = (e) => {
    switch (e) {
      case "bar":
        return 90;
      case "arrow":
        return 20;
      default:
        return 25;
    }
  },
  bh = (e, o, t, r) => {
    if (o.length < 1) return null;
    let n = nh(o[0]);
    if (n.length < 1) return null;
    let i = t === "start" ? 1 : n.length - 1,
      a = n[i].data;
    D2(a.length === 6, "Op data length is not 6");
    let l = ot(a[4], a[5]),
      s = ot(a[2], a[3]),
      d = ot(a[0], a[1]),
      m = n[i - 1],
      c = ot(0, 0);
    if (m.op === "move") {
      let _ = v7(m.data);
      D2(_ != null, "Op data is not a point"), (c = _);
    } else m.op === "bcurveTo" && (c = ot(m.data[4], m.data[5]));
    let p = (_, R) =>
        Math.pow(1 - _, 3) * l[R] +
        3 * _ * Math.pow(1 - _, 2) * s[R] +
        3 * Math.pow(_, 2) * (1 - _) * d[R] +
        c[R] * Math.pow(_, 3),
      [u, f] = t === "start" ? c : l,
      [b, x] = [p(0.3, 0), p(0.3, 1)],
      w = Math.hypot(u - b, f - x),
      E = (u - b) / w,
      y = (f - x) / w,
      v = T7(r),
      C = 0;
    {
      let [_, R] = t === "end" ? e.points[e.points.length - 1] : e.points[0],
        [X, $] =
          e.points.length > 1
            ? t === "end"
              ? e.points[e.points.length - 2]
              : e.points[1]
            : [0, 0];
      C = Math.hypot(_ - X, R - $);
    }
    let M = Math.min(v, C * (r === "diamond" || r === "diamond_outline" ? 0.25 : 0.5)),
      k = u - E * M,
      A = f - y * M;
    if (r === "dot" || r === "circle" || r === "circle_outline") {
      let _ = Math.hypot(A - f, k - u) + e.strokeWidth - 2;
      return [u, f, _];
    }
    let P = I7(r);
    if (r === "crowfoot_many" || r === "crowfoot_one_or_many") {
      let [_, R] = vi(ot(u, f), ot(k, A), fh(-P)),
        [X, $] = vi(ot(u, f), ot(k, A), fh(P));
      return [k, A, _, R, X, $];
    }
    let [N, O] = vi(ot(k, A), ot(u, f), (-P * Math.PI) / 180),
      [U, J] = vi(ot(k, A), ot(u, f), fh(P));
    if (r === "diamond" || r === "diamond_outline") {
      let _, R;
      if (t === "start") {
        let [X, $] = e.points.length > 1 ? e.points[1] : [0, 0];
        [_, R] = vi(ot(u + M * 2, f), ot(u, f), Math.atan2($ - f, X - u));
      } else {
        let [X, $] = e.points.length > 1 ? e.points[e.points.length - 2] : [0, 0];
        [_, R] = vi(ot(u - M * 2, f), ot(u, f), Math.atan2(f - $, u - X));
      }
      return [u, f, N, O, _, R, U, J];
    }
    return [u, f, N, O, U, J];
  };
import {
  pointFrom as Vhe,
  pointCenter as Xhe,
  pointRotateRads as Khe,
  vectorFromPoint as Zhe,
  vectorNormalize as $he,
  vectorSubtract as jhe,
  vectorAdd as qhe,
  vectorScale as Jhe,
  pointFromVector as Qhe,
  clamp as ege,
  isCloseTo as tge,
} from "@excalidraw/math";
import { arrayToMap as Hge } from "@excalidraw/common";
import { isPointWithinBounds as Uge, pointFrom as Yge } from "@excalidraw/math";
import { vectorCross as age, vectorFromPoint as lge } from "@excalidraw/math";
import { arrayToMap as C7 } from "@excalidraw/common";
import { getElementBounds as S7 } from "@excalidraw/element";
import {
  isArrowElement as k7,
  isExcalidrawElement as M7,
  isFreeDrawElement as L7,
  isLinearElement as P7,
  isTextElement as A7,
} from "@excalidraw/element";
import {
  rangeIncludesValue as Uc,
  pointFrom as Go,
  pointRotateRads as D7,
  rangeInclusive as Yc,
} from "@excalidraw/math";
var _7 = (e) =>
    e.type === "diamond"
      ? [
          Go(e.width / 2, 0),
          Go(e.width, e.height / 2),
          Go(e.width / 2, e.height),
          Go(0, e.height / 2),
        ]
      : [Go(0, 0), Go(0 + e.width, 0), Go(0 + e.width, e.height), Go(0, e.height)],
  R7 = (e) => (P7(e) || L7(e) ? e.points : _7(e)),
  R2 = (e) => {
    let o = e.reduce(
      (t, [r, n]) => (
        (t.minY = Math.min(t.minY, n)),
        (t.minX = Math.min(t.minX, r)),
        (t.maxX = Math.max(t.maxX, r)),
        (t.maxY = Math.max(t.maxY, n)),
        t
      ),
      { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0, cx: 0, cy: 0 }
    );
    return (o.cx = (o.maxX + o.minX) / 2), (o.cy = (o.maxY + o.minY) / 2), o;
  },
  N2 = (e) => {
    let o = R7(e),
      { cx: t, cy: r } = R2(o),
      n = Go(t, r),
      i = o.map((m) => D7(m, n, e.angle)),
      { minX: a, minY: l, maxX: s, maxY: d } = R2(i);
    return [a + e.x, l + e.y, s + e.x, d + e.y];
  },
  xh = (e, o, t = !1) => {
    let r = N2(e),
      n = o[0] <= r[0] && o[2] >= r[2] && o[1] <= r[1] && o[3] >= r[3];
    return t ? (n ? !0 : r[0] <= o[0] && r[2] >= o[2] && r[1] <= o[1] && r[3] >= o[3]) : n;
  },
  B2 = (e, o) => {
    let t = N2(e);
    return (
      (Uc(t[0], Yc(o[0], o[2])) || Uc(o[0], Yc(t[0], t[2]))) &&
      (Uc(t[1], Yc(o[1], o[3])) || Uc(o[1], Yc(t[1], t[3])))
    );
  },
  F2 = ({ elements: e, bounds: o, type: t, errorMargin: r = 0 }) => {
    M7(o) && (o = S7(o, C7(e)));
    let n = [o[0] - r, o[1] - r, o[2] + r, o[3] + r],
      i = new Set();
    for (let a of e) {
      if (i.has(a.id)) continue;
      if (t === "overlap" ? B2(a, n) : t === "inside" ? xh(a, n) : xh(a, n, !0)) {
        if ((i.add(a.id), a.boundElements)) for (let s of a.boundElements) i.add(s.id);
        A7(a) && a.containerId && i.add(a.containerId),
          k7(a) &&
            (a.startBinding && i.add(a.startBinding.elementId),
            a.endBinding && i.add(a.endBinding?.elementId));
      }
    }
    return e.filter((a) => i.has(a.id));
  };
import { arrayToMap as vge, isShallowEqual as B7 } from "@excalidraw/common";
var N7 = (function () {
  let e = null,
    o = null,
    t = null,
    r = (i, a, l, s) => {
      if (t !== void 0 && a === o && i === e && l.editingGroupId === t?.editingGroupId) return t;
      let d = {};
      for (let p of i) {
        let u = p.groupIds;
        if (l.editingGroupId) {
          let f = u.indexOf(l.editingGroupId);
          f > -1 && (u = u.slice(0, f));
        }
        if (u.length > 0) {
          let f = u[u.length - 1];
          d[f] = !0;
        }
      }
      let m = {},
        c = a.reduce((p, u) => {
          if (u.isDeleted) return p;
          let f = u.groupIds.find((b) => d[b]);
          return f && ((p[u.id] = !0), Array.isArray(m[f]) ? m[f].push(u.id) : (m[f] = [u.id])), p;
        }, {});
      for (let p of Object.keys(m)) m[p].length < 2 && d[p] && (d[p] = !1);
      return (
        (o = a),
        (e = i),
        (t = {
          editingGroupId: l.editingGroupId,
          selectedGroupIds: d,
          selectedElementIds: Eh({ ...l.selectedElementIds, ...c }, s),
        }),
        t
      );
    },
    n = (i, a, l, s) => {
      let d = s
        ? s.scene.getSelectedElements({ selectedElementIds: i.selectedElementIds, elements: a })
        : yh(a, i);
      return d.length
        ? r(d, a, i, l)
        : {
            selectedGroupIds: {},
            editingGroupId: null,
            selectedElementIds: Eh(i.selectedElementIds, l),
          };
    };
  return (
    (n.clearCache = () => {
      (o = null), (e = null), (t = null);
    }),
    n
  );
})();
var Lge = (function () {
    let e = null,
      o = null,
      t = null,
      r = (n, i) => (
        (t != null && n === e && i.selectedElementIds === o) ||
          ((t = n.some((a) => i.selectedElementIds[a.id])), (e = n), (o = i.selectedElementIds)),
        t
      );
    return (
      (r.clearCache = () => {
        (e = null), (o = null), (t = null);
      }),
      r
    );
  })(),
  yh = (e, o, t) => {
    let r = new Set(),
      n = [];
    for (let i of e.values()) {
      if (o.selectedElementIds[i.id]) {
        n.push(i), r.add(i.id);
        continue;
      }
      if (t?.includeBoundTextElement && Ua(i) && o.selectedElementIds[i?.containerId]) {
        n.push(i), r.add(i.id);
        continue;
      }
    }
    if (t?.includeElementsInFrames) {
      let i = [];
      return (
        n.forEach((a) => {
          Oc(a) && O2(e, a.id).forEach((l) => !r.has(l.id) && i.push(l)), i.push(a);
        }),
        i
      );
    }
    return n;
  };
var Eh = (e, o) => (B7(o.selectedElementIds, e) ? o.selectedElementIds : e);
var O2 = (e, o) => {
  let t = [];
  for (let r of e.values()) r.frameId === o && t.push(r);
  return t;
};
var z7 = typeof document < "u" ? document.createElement("img") : { src: "" };
z7.src = `data:${H2.svg},${encodeURIComponent(
  '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="image" class="svg-inline--fa fa-image fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="#888" d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"></path></svg>'
)}`;
var H7 = typeof document < "u" ? document.createElement("img") : { src: "" };
H7.src = `data:${H2.svg},${encodeURIComponent(
  '<svg viewBox="0 0 668 668" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.81709 0 0 .81709 124.825 145.825)"/><path d="M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.30366 0 0 .30366 506.822 60.065)"/></svg>'
)}`;
var G2 = new WeakMap();
var G7 = new WeakMap([]);
function U2(e) {
  let o = U7(e),
    t = new Path2D(o);
  return G7.set(e, t), t;
}
function U7(e) {
  let o = e.simulatePressure
      ? e.points
      : e.points.length
      ? e.points.map(([r, n], i) => [r, n, e.pressures[i]])
      : [[0, 0, 0.5]],
    t = {
      simulatePressure: e.simulatePressure,
      size: e.strokeWidth * 4.25,
      thinning: 0.6,
      smoothing: 0.5,
      streamline: 0.5,
      easing: (r) => Math.sin((r * Math.PI) / 2),
      last: !!e.lastCommittedPoint,
    };
  return W7(O7(o, t));
}
function z2(e, o) {
  return [(e[0] + o[0]) / 2, (e[1] + o[1]) / 2];
}
var Y7 = /(\s?[A-Z]?,?-?[0-9]*\.[0-9]{0,2})(([0-9]|e|-)*)/g;
function W7(e) {
  if (!e.length) return "";
  let o = e.length - 1;
  return e
    .reduce(
      (t, r, n, i) => (
        n === o ? t.push(r, z2(r, i[0]), "L", i[0], "Z") : t.push(r, z2(r, i[n + 1])), t
      ),
      ["M", e[0], "Q"]
    )
    .join(" ")
    .replace(Y7, "$1");
}
var Y2 = (e) =>
  e === "rectangle" ||
  e === "iframe" ||
  e === "embeddable" ||
  e === "line" ||
  e === "diamond" ||
  e === "image";
var lt = class lt {};
I(lt, "rg", new j7()),
  I(lt, "cache", new WeakMap()),
  I(lt, "get", (o) => lt.cache.get(o)),
  I(lt, "set", (o, t) => lt.cache.set(o, t)),
  I(lt, "delete", (o) => lt.cache.delete(o)),
  I(lt, "destroy", () => {
    lt.cache = new WeakMap();
  }),
  I(lt, "generateElementShape", (o, t) => {
    let r = t?.isExporting ? void 0 : lt.get(o);
    if (r !== void 0) return r;
    G2.delete(o);
    let n = Q7(
      o,
      lt.rg,
      t || { isExporting: !1, canvasBackgroundColor: $7.white, embedsValidationStatus: null }
    );
    return lt.cache.set(o, n), n;
  });
var wi = lt,
  q7 = (e) => [8, 8 + e],
  K2 = (e) => [1.5, 6 + e];
function J7(e) {
  let o = e.roughness,
    t = Math.max(e.width, e.height),
    r = Math.min(e.width, e.height);
  return (r >= 20 && t >= 50) || (r >= 15 && e.roundness && Y2(e.type)) || (gr(e) && t >= 50)
    ? o
    : Math.min(o / (t < 10 ? 3 : 2), 2.5);
}
var Ho = (e, o = !1) => {
    let t = {
      seed: e.seed,
      strokeLineDash:
        e.strokeStyle === "dashed"
          ? q7(e.strokeWidth)
          : e.strokeStyle === "dotted"
          ? K2(e.strokeWidth)
          : void 0,
      disableMultiStroke: e.strokeStyle !== "solid",
      strokeWidth: e.strokeStyle !== "solid" ? e.strokeWidth + 0.5 : e.strokeWidth,
      fillWeight: e.strokeWidth / 2,
      hachureGap: e.strokeWidth * 4,
      roughness: J7(e),
      stroke: e.strokeColor,
      preserveVertices: o || e.roughness < K7.cartoonist,
    };
    switch (e.type) {
      case "rectangle":
      case "iframe":
      case "embeddable":
      case "diamond":
      case "ellipse":
        return (
          (t.fillStyle = e.fillStyle),
          (t.fill = Va(e.backgroundColor) ? void 0 : e.backgroundColor),
          e.type === "ellipse" && (t.curveFitting = 1),
          t
        );
      case "line":
      case "freedraw":
        return (
          Fc(e.points) &&
            ((t.fillStyle = e.fillStyle),
            (t.fill = e.backgroundColor === "transparent" ? void 0 : e.backgroundColor)),
          t
        );
      case "arrow":
        return t;
      default:
        throw new Error(`Unimplemented type ${e.type}`);
    }
  },
  V2 = (e, o, t) =>
    sh(e) && (o || (T2(e) && t?.get(e.id) !== !0)) && Va(e.backgroundColor) && Va(e.strokeColor)
      ? { ...e, roughness: 0, backgroundColor: "#d3d3d3", fillStyle: "solid" }
      : I2(e)
      ? {
          ...e,
          strokeColor: Va(e.strokeColor) ? "#000000" : e.strokeColor,
          backgroundColor: Va(e.backgroundColor) ? "#f4f4f6" : e.backgroundColor,
        }
      : e,
  X2 = (e, o, t, r, n, i, a) => {
    let l = bh(e, o, t, r);
    if (l === null) return [];
    let s = (d, m) => {
      if (d === null) return [];
      let [, , c, p, u, f] = d;
      return [n.line(c, p, u, f, m)];
    };
    switch (r) {
      case "dot":
      case "circle":
      case "circle_outline": {
        let [d, m, c] = l;
        return (
          delete i.strokeLineDash,
          [
            n.circle(d, m, c, {
              ...i,
              fill: r === "circle_outline" ? a : e.strokeColor,
              fillStyle: "solid",
              stroke: e.strokeColor,
              roughness: Math.min(0.5, i.roughness || 0),
            }),
          ]
        );
      }
      case "triangle":
      case "triangle_outline": {
        let [d, m, c, p, u, f] = l;
        return (
          delete i.strokeLineDash,
          [
            n.polygon(
              [
                [d, m],
                [c, p],
                [u, f],
                [d, m],
              ],
              {
                ...i,
                fill: r === "triangle_outline" ? a : e.strokeColor,
                fillStyle: "solid",
                roughness: Math.min(1, i.roughness || 0),
              }
            ),
          ]
        );
      }
      case "diamond":
      case "diamond_outline": {
        let [d, m, c, p, u, f, b, x] = l;
        return (
          delete i.strokeLineDash,
          [
            n.polygon(
              [
                [d, m],
                [c, p],
                [u, f],
                [b, x],
                [d, m],
              ],
              {
                ...i,
                fill: r === "diamond_outline" ? a : e.strokeColor,
                fillStyle: "solid",
                roughness: Math.min(1, i.roughness || 0),
              }
            ),
          ]
        );
      }
      case "crowfoot_one":
        return s(l, i);
      case "bar":
      case "arrow":
      case "crowfoot_many":
      case "crowfoot_one_or_many":
      default: {
        let [d, m, c, p, u, f] = l;
        if (e.strokeStyle === "dotted") {
          let b = K2(e.strokeWidth - 1);
          i.strokeLineDash = [b[0], b[1] - 1];
        } else delete i.strokeLineDash;
        return (
          (i.roughness = Math.min(1, i.roughness || 0)),
          [
            n.line(c, p, d, m, i),
            n.line(u, f, d, m, i),
            ...(r === "crowfoot_one_or_many" ? s(bh(e, o, t, "crowfoot_one"), i) : []),
          ]
        );
      }
    }
  };
var Q7 = (e, o, { isExporting: t, canvasBackgroundColor: r, embedsValidationStatus: n }) => {
    switch (e.type) {
      case "rectangle":
      case "iframe":
      case "embeddable": {
        let i;
        if (e.roundness) {
          let a = e.width,
            l = e.height,
            s = Ha(Math.min(a, l), e);
          i = o.path(
            `M ${s} 0 L ${a - s} 0 Q ${a} 0, ${a} ${s} L ${a} ${l - s} Q ${a} ${l}, ${
              a - s
            } ${l} L ${s} ${l} Q 0 ${l}, 0 ${l - s} L 0 ${s} Q 0 0, ${s} 0`,
            Ho(V2(e, t, n), !0)
          );
        } else i = o.rectangle(0, 0, e.width, e.height, Ho(V2(e, t, n), !1));
        return i;
      }
      case "diamond": {
        let i,
          [a, l, s, d, m, c, p, u] = lh(e);
        if (e.roundness) {
          let f = Ha(Math.abs(a - p), e),
            b = Ha(Math.abs(d - l), e);
          i = o.path(
            `M ${a + f} ${l + b} L ${s - f} ${d - b}
            C ${s} ${d}, ${s} ${d}, ${s - f} ${d + b}
            L ${m + f} ${c - b}
            C ${m} ${c}, ${m} ${c}, ${m - f} ${c - b}
            L ${p + f} ${u + b}
            C ${p} ${u}, ${p} ${u}, ${p + f} ${u - b}
            L ${a - f} ${l + b}
            C ${a} ${l}, ${a} ${l}, ${a + f} ${l + b}`,
            Ho(e, !0)
          );
        } else
          i = o.polygon(
            [
              [a, l],
              [s, d],
              [m, c],
              [p, u],
            ],
            Ho(e)
          );
        return i;
      }
      case "ellipse":
        return o.ellipse(e.width / 2, e.height / 2, e.width, e.height, Ho(e));
      case "line":
      case "arrow": {
        let i,
          a = Ho(e),
          l = e.points.length ? e.points : [X7(0, 0)];
        if (
          (Ga(e)
            ? l.every((s) => Math.abs(s[0]) <= 1e6 && Math.abs(s[1]) <= 1e6)
              ? (i = [o.path(eD(l, 16), Ho(e, !0))])
              : (console.error(
                  "Elbow arrow with extreme point positions detected. Arrow not rendered.",
                  e.id,
                  JSON.stringify(l)
                ),
                (i = []))
            : e.roundness
            ? (i = [o.curve(l, a)])
            : a.fill
            ? (i = [o.polygon(l, a)])
            : (i = [o.linearPath(l, a)]),
          e.type === "arrow")
        ) {
          let { startArrowhead: s = null, endArrowhead: d = "arrow" } = e;
          if (s !== null) {
            let m = X2(e, i, "start", s, o, a, r);
            i.push(...m);
          }
          if (d !== null) {
            let m = X2(e, i, "end", d, o, a, r);
            i.push(...m);
          }
        }
        return i;
      }
      case "freedraw": {
        let i;
        if ((U2(e), Fc(e.points))) {
          let a = V7(e.points, 0.75);
          i = o.curve(a, { ...Ho(e), stroke: "none" });
        } else i = null;
        return i;
      }
      case "frame":
      case "magicframe":
      case "text":
      case "image":
        return null;
      default:
        return Z7(e, `generateElementShape(): Unimplemented type ${e?.type}`), null;
    }
  },
  eD = (e, o) => {
    let t = [];
    for (let n = 1; n < e.length - 1; n += 1) {
      let i = e[n - 1],
        a = e[n + 1],
        l = e[n],
        s = Hc(l, i),
        d = Hc(a, l),
        m = Math.min(o, W2(e[n], a) / 2, W2(e[n], i) / 2);
      s
        ? i[0] < l[0]
          ? t.push([e[n][0] - m, e[n][1]])
          : t.push([e[n][0] + m, e[n][1]])
        : i[1] < l[1]
        ? t.push([e[n][0], e[n][1] - m])
        : t.push([e[n][0], e[n][1] + m]),
        t.push(e[n]),
        d
          ? a[0] < l[0]
            ? t.push([e[n][0] - m, e[n][1]])
            : t.push([e[n][0] + m, e[n][1]])
          : a[1] < l[1]
          ? t.push([e[n][0], e[n][1] - m])
          : t.push([e[n][0], e[n][1] + m]);
    }
    let r = [`M ${e[0][0]} ${e[0][1]}`];
    for (let n = 0; n < t.length; n += 3)
      r.push(`L ${t[n][0]} ${t[n][1]}`),
        r.push(`Q ${t[n + 1][0]} ${t[n + 1][1]}, ${t[n + 2][0]} ${t[n + 2][1]}`);
    return r.push(`L ${e[e.length - 1][0]} ${e[e.length - 1][1]}`), r.join(" ");
  };
var Z2 = (e, o, t = !1) => {
  let r = !1;
  for (let n in o) {
    let i = o[n];
    if (typeof i < "u") {
      if (e[n] === i && (typeof i != "object" || i === null)) continue;
      r = !0;
    }
  }
  return !r && !t
    ? e
    : {
        ...e,
        ...o,
        version: o.version ?? e.version + 1,
        versionNonce: o.versionNonce ?? tD(),
        updated: oD(),
      };
};
import { jsx as q2 } from "react/jsx-runtime";
var wh = B({
    name: "toggleLinearEditor",
    category: ke.elements,
    label: (e, o, t) =>
      t.scene.getSelectedElements({ selectedElementIds: o.selectedElementIds })[0]?.type === "arrow"
        ? "labels.lineEditor.editArrow"
        : "labels.lineEditor.edit",
    keywords: ["line"],
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o);
      return !!(!o.editingLinearElement && n.length === 1 && iD(n[0]) && !nD(n[0]));
    },
    perform(e, o, t, r) {
      let n = r.scene.getSelectedElements({
          selectedElementIds: o.selectedElementIds,
          includeBoundTextElement: !0,
        })[0],
        i = o.editingLinearElement?.elementId === n.id ? null : new rD(n, $2(e));
      return { appState: { ...o, editingLinearElement: i }, captureUpdate: j2.IMMEDIATELY };
    },
    PanelComponent: ({ appState: e, updateData: o, app: t }) => {
      let r = t.scene.getSelectedElements({ selectedElementIds: e.selectedElementIds })[0],
        n = g(r.type === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit");
      return q2(V, { type: "button", icon: ab, title: n, "aria-label": n, onClick: () => o(null) });
    },
  }),
  I1e = B({
    name: "togglePolygon",
    category: ke.elements,
    icon: ym,
    keywords: ["loop"],
    label: (e, o, t) =>
      !t.scene
        .getSelectedElements({ selectedElementIds: o.selectedElementIds })
        .some((i) => !Ti(i) || !i.polygon)
        ? "labels.polygon.breakPolygon"
        : "labels.polygon.convertToPolygon",
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => {
      let n = r.scene.getSelectedElements({ selectedElementIds: o.selectedElementIds });
      return n.length > 0 && n.every((i) => Ti(i) && i.points.length >= 4);
    },
    perform(e, o, t, r) {
      let n = r.scene.getSelectedElements(o);
      if (n.some((s) => !Ti(s))) return !1;
      let i = n,
        a = i.some((s) => !s.polygon),
        l = $2(i);
      return {
        elements: e.map((s) =>
          !l.has(s.id) || !Ti(s)
            ? s
            : Z2(s, { backgroundColor: a ? s.backgroundColor : "transparent", ...aD(s, a) })
        ),
        appState: o,
        captureUpdate: j2.IMMEDIATELY,
      };
    },
    PanelComponent: ({ appState: e, updateData: o, app: t }) => {
      let r = t.scene.getSelectedElements({ selectedElementIds: e.selectedElementIds });
      if (r.length === 0 || r.some((a) => !Ti(a) || !a.polygon || a.points.length < 3)) return null;
      let n = r.every((a) => Ti(a) && a.polygon),
        i = g(n ? "labels.polygon.breakPolygon" : "labels.polygon.convertToPolygon");
      return q2(Nn, {
        icon: ym,
        title: i,
        "aria-label": i,
        active: n,
        onClick: () => o(null),
        style: { marginLeft: "auto" },
      });
    },
  });
import {
  KEYS as J2,
  CANVAS_SEARCH_TAB as Q2,
  CLASSES as lD,
  DEFAULT_SIDEBAR as ew,
} from "@excalidraw/common";
import { CaptureUpdateAction as sD } from "@excalidraw/element";
var za = B({
  name: "searchMenu",
  icon: Mt,
  keywords: ["search", "find"],
  label: "search.title",
  viewMode: !0,
  trackEvent: { category: "search_menu", action: "toggle", predicate: (e) => e.gridModeEnabled },
  perform(e, o, t, r) {
    if (o.openDialog) return !1;
    if (o.openSidebar?.name === ew.name && o.openSidebar.tab === Q2) {
      let n = r.excalidrawContainerValue.container?.querySelector(
        `.${lD.SEARCH_MENU_INPUT_WRAPPER} input`
      );
      return n?.focus(), n?.select(), !1;
    }
    return {
      appState: { ...o, openSidebar: { name: ew.name, tab: Q2 }, openDialog: null },
      captureUpdate: sD.EVENTUALLY,
    };
  },
  checked: (e) => e.gridModeEnabled,
  predicate: (e, o, t) => t.gridModeEnabled === void 0,
  keyTest: (e) => e[J2.CTRL_OR_CMD] && e.key === J2.F,
});
import { isImageElement as cD } from "@excalidraw/element";
import { CaptureUpdateAction as dD } from "@excalidraw/element";
import { jsx as mD } from "react/jsx-runtime";
var vh = B({
  name: "cropEditor",
  label: "helpDialog.cropStart",
  icon: Um,
  viewMode: !0,
  trackEvent: { category: "menu" },
  keywords: ["image", "crop"],
  perform(e, o, t, r) {
    let n = r.scene.getSelectedElements({
      selectedElementIds: o.selectedElementIds,
      includeBoundTextElement: !0,
    })[0];
    return {
      appState: { ...o, isCropping: !1, croppingElementId: n.id },
      captureUpdate: dD.IMMEDIATELY,
    };
  },
  predicate: (e, o, t, r) => {
    let n = r.scene.getSelectedElements(o);
    return !!(!o.croppingElementId && n.length === 1 && cD(n[0]));
  },
  PanelComponent: ({ appState: e, updateData: o, app: t }) => {
    let r = g("helpDialog.cropStart");
    return mD(V, { type: "button", icon: Um, title: r, "aria-label": r, onClick: () => o(null) });
  },
});
import { arrayToMap as tw } from "@excalidraw/common";
import { newElementWith as nw, duplicateElements as ow } from "@excalidraw/element";
import { CaptureUpdateAction as lo } from "@excalidraw/element";
import { jsx as nn } from "react/jsx-runtime";
var Th = async (e, o) => {
    try {
      console.log(`\u{1F310} API Call: ${e}`, o);
      let t = await fetch("https://jsonplaceholder.typicode.com/posts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: e, elementData: o, timestamp: Date.now() }),
      });
      if (!t.ok) throw new Error(`HTTP ${t.status}`);
      let r = await t.json();
      return console.log("\u2705 API Response:", r), { success: !0, data: r };
    } catch (t) {
      return (
        console.error("\u274C API Error:", t),
        { success: !1, error: t instanceof Error ? t.message : "Unknown error" }
      );
    }
  },
  rw = nn("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    children: nn("path", {
      d: "M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z",
    }),
  }),
  pD = B({
    name: "customHighlight",
    label: "Custom Highlight",
    icon: rw,
    trackEvent: { category: "element", action: "highlight" },
    perform: async (e, o, t, r) => {
      console.log("\u{1F3A8} Custom Highlight action triggered!");
      let n = Z(e, o);
      if (n.length === 0)
        return {
          elements: e,
          appState: { ...o, errorMessage: "Please select elements to highlight" },
          captureUpdate: lo.IMMEDIATELY,
        };
      let a = {
        elementIds: n.map((l) => l.id),
        action: "highlight",
        colors: { background: "#ffe066", stroke: "#ff6b6b" },
      };
      console.log("\u{1F504} Calling API...");
      try {
        let l = await Th("highlight", a);
        return l.success
          ? {
              elements: e.map((d) =>
                o.selectedElementIds[d.id]
                  ? nw(d, {
                      backgroundColor: "#ffe066",
                      strokeColor: "#ff6b6b",
                      strokeWidth: Math.max(d.strokeWidth, 2),
                    })
                  : d
              ),
              appState: {
                ...o,
                toast: {
                  message: `\u2705 Highlighted ${n.length} element(s) and saved to API!`,
                  closable: !0,
                },
              },
              captureUpdate: lo.IMMEDIATELY,
            }
          : {
              elements: e,
              appState: {
                ...o,
                errorMessage: `API Error: ${l.error}`,
                toast: { message: `\u274C API failed: ${l.error}`, closable: !0 },
              },
              captureUpdate: lo.IMMEDIATELY,
            };
      } catch (l) {
        return (
          console.error("API call failed:", l),
          {
            elements: e,
            appState: {
              ...o,
              errorMessage: "Failed to connect to server",
              toast: { message: "\u274C Network error. Highlight not saved.", closable: !0 },
            },
            captureUpdate: lo.IMMEDIATELY,
          }
        );
      }
    },
    predicate: (e, o) => Object.keys(o.selectedElementIds).length > 0,
    PanelComponent: ({ elements: e, appState: o, updateData: t }) => {
      let n = Z(e, o).some((i) => i.backgroundColor === "#ffe066" && i.strokeColor === "#ff6b6b");
      return nn(V, {
        type: "button",
        icon: rw,
        "aria-label": "Highlight selected elements",
        title: "Apply custom highlight effect to selected elements",
        onClick: () => t(null),
        selected: n,
        className: "custom-highlight-button",
      });
    },
  }),
  uD = B({
    name: "clearHighlight",
    label: "Clear Highlight",
    trackEvent: { category: "element", action: "clear-highlight" },
    perform: async (e, o, t, r) => {
      console.log("\u{1F9F9} Clear Highlight action triggered!");
      let n = Z(e, o);
      if (n.length === 0)
        return {
          elements: e,
          appState: { ...o, errorMessage: "Please select elements to clear highlight" },
          captureUpdate: lo.IMMEDIATELY,
        };
      let i = n.map((a) => a.id);
      console.log("\u{1F504} Calling clear API...");
      try {
        let a = await Th("clear", { elementIds: i });
        return a.success
          ? {
              elements: e.map((s) =>
                o.selectedElementIds[s.id]
                  ? nw(s, {
                      backgroundColor: "transparent",
                      strokeColor: "#1e1e1e",
                      strokeWidth: 1,
                    })
                  : s
              ),
              appState: {
                ...o,
                toast: {
                  message: `\u2705 Cleared ${n.length} element(s) and updated API!`,
                  closable: !0,
                },
              },
              captureUpdate: lo.IMMEDIATELY,
            }
          : {
              elements: e,
              appState: { ...o, toast: { message: `\u274C API failed: ${a.error}`, closable: !0 } },
              captureUpdate: lo.IMMEDIATELY,
            };
      } catch (a) {
        return (
          console.error("API call failed:", a),
          {
            elements: e,
            appState: {
              ...o,
              toast: { message: "\u274C Network error. Clear not saved.", closable: !0 },
            },
            captureUpdate: lo.IMMEDIATELY,
          }
        );
      }
    },
    predicate: (e, o) =>
      Z(e, o).some((r) => r.backgroundColor === "#ffe066" && r.strokeColor === "#ff6b6b"),
    PanelComponent: ({ elements: e, appState: o, updateData: t }) =>
      Z(e, o).some((i) => i.backgroundColor === "#ffe066" && i.strokeColor === "#ff6b6b")
        ? nn(V, {
            type: "button",
            icon: nn("span", { children: "\u{1F9F9}" }),
            "aria-label": "Clear highlight from selected elements",
            title: "Remove custom highlight effect",
            onClick: () => t(null),
            className: "clear-highlight-button",
          })
        : null,
  }),
  hD = B({
    name: "duplicateAndHighlight",
    label: "Duplicate & Highlight",
    trackEvent: { category: "element", action: "duplicate-highlight" },
    perform: async (e, o, t, r) => {
      console.log("\u{1F3A8} Duplicate & Highlight action triggered!");
      let n = Z(e, o);
      if (n.length === 0)
        return {
          elements: e,
          appState: { ...o, errorMessage: "Please select elements to duplicate and highlight" },
          captureUpdate: lo.IMMEDIATELY,
        };
      let i = n.map((a) => a.id);
      console.log("\u{1F504} Calling duplicate API...");
      try {
        let a = await Th("duplicate", {
            elementIds: i,
            action: "duplicate",
            colors: { background: "#66d9ef", stroke: "#a6e22e" },
          }),
          { duplicatedElements: l, elementsWithDuplicates: s } = ow({
            type: "in-place",
            elements: e,
            idsOfElementsToDuplicate: tw(n),
            appState: o,
            randomizeSeed: !0,
            overrides: ({ origElement: c }) => ({
              x: c.x + 50,
              y: c.y + 50,
              backgroundColor: "#66d9ef",
              strokeColor: "#a6e22e",
              strokeWidth: Math.max(c.strokeWidth, 2),
            }),
          }),
          d = l.reduce((c, p) => ((c[p.id] = !0), c), {}),
          m = a.success
            ? `\u2705 Duplicated ${n.length} element(s) and logged to API!`
            : `\u26A0\uFE0F Duplicated locally but API failed: ${a.error}`;
        return {
          elements: s,
          appState: { ...o, selectedElementIds: d, toast: { message: m, closable: !0 } },
          captureUpdate: lo.IMMEDIATELY,
        };
      } catch (a) {
        console.error("API call failed:", a);
        let { duplicatedElements: l, elementsWithDuplicates: s } = ow({
            type: "in-place",
            elements: e,
            idsOfElementsToDuplicate: tw(n),
            appState: o,
            randomizeSeed: !0,
            overrides: ({ origElement: m }) => ({
              x: m.x + 50,
              y: m.y + 50,
              backgroundColor: "#66d9ef",
              strokeColor: "#a6e22e",
              strokeWidth: Math.max(m.strokeWidth, 2),
            }),
          }),
          d = l.reduce((m, c) => ((m[c.id] = !0), m), {});
        return {
          elements: s,
          appState: {
            ...o,
            selectedElementIds: d,
            toast: { message: "\u26A0\uFE0F Duplicated locally but network error", closable: !0 },
          },
          captureUpdate: lo.IMMEDIATELY,
        };
      }
    },
    predicate: (e, o) => Object.keys(o.selectedElementIds).length > 0,
    PanelComponent: ({ elements: e, appState: o, updateData: t }) =>
      nn(V, {
        type: "button",
        icon: nn("span", { children: "\u{1F3A8}" }),
        "aria-label": "Duplicate and highlight selected elements",
        title: "Create highlighted duplicates of selected elements",
        onClick: () => t(null),
        className: "duplicate-highlight-button",
      }),
  });
import { getNonDeletedElements as gD } from "@excalidraw/element";
import { mutateElement as fD } from "@excalidraw/element";
import { newFrameElement as bD } from "@excalidraw/element";
import { isFrameLikeElement as Wc } from "@excalidraw/element";
import { addElementsToFrame as xD, removeAllElementsFromFrame as ED } from "@excalidraw/element";
import { getFrameChildren as yD } from "@excalidraw/element";
import { KEYS as iw, updateActiveTool as aw } from "@excalidraw/common";
import { getElementsInGroup as wD } from "@excalidraw/element";
import { getCommonBounds as vD } from "@excalidraw/element";
import { CaptureUpdateAction as an } from "@excalidraw/element";
var lw = (e, o) => {
    let t = o.scene.getSelectedElements(e);
    return t.length === 1 && Wc(t[0]);
  },
  sw = B({
    name: "selectAllElementsInFrame",
    label: "labels.selectAllElementsInFrame",
    trackEvent: { category: "canvas" },
    perform: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o).at(0) || null;
      if (Wc(n)) {
        let i = yD(gD(e), n.id).filter((a) => !(a.type === "text" && a.containerId));
        return {
          elements: e,
          appState: { ...o, selectedElementIds: i.reduce((a, l) => ((a[l.id] = !0), a), {}) },
          captureUpdate: an.IMMEDIATELY,
        };
      }
      return { elements: e, appState: o, captureUpdate: an.EVENTUALLY };
    },
    predicate: (e, o, t, r) => lw(o, r),
  }),
  cw = B({
    name: "removeAllElementsFromFrame",
    label: "labels.removeAllElementsFromFrame",
    trackEvent: { category: "history" },
    perform: (e, o, t, r) => {
      let n = r.scene.getSelectedElements(o).at(0) || null;
      return Wc(n)
        ? {
            elements: ED(e, n),
            appState: { ...o, selectedElementIds: { [n.id]: !0 } },
            captureUpdate: an.IMMEDIATELY,
          }
        : { elements: e, appState: o, captureUpdate: an.EVENTUALLY };
    },
    predicate: (e, o, t, r) => lw(o, r),
  }),
  W0e = B({
    name: "updateFrameRendering",
    label: "labels.updateFrameRendering",
    viewMode: !0,
    trackEvent: { category: "canvas" },
    perform: (e, o) => ({
      elements: e,
      appState: {
        ...o,
        frameRendering: { ...o.frameRendering, enabled: !o.frameRendering.enabled },
      },
      captureUpdate: an.EVENTUALLY,
    }),
    checked: (e) => e.frameRendering.enabled,
  }),
  V0e = B({
    name: "setFrameAsActiveTool",
    label: "toolBar.frame",
    trackEvent: { category: "toolbar" },
    icon: Yr,
    viewMode: !1,
    perform: (e, o, t, r) => {
      let n = aw(o, { type: "frame" });
      return (
        Pt(r.interactiveCanvas, { ...o, activeTool: n }),
        {
          elements: e,
          appState: { ...o, activeTool: aw(o, { type: "frame" }) },
          captureUpdate: an.EVENTUALLY,
        }
      );
    },
    keyTest: (e) =>
      !e[iw.CTRL_OR_CMD] && !e.shiftKey && !e.altKey && e.key.toLocaleLowerCase() === iw.F,
  }),
  dw = B({
    name: "wrapSelectionInFrame",
    label: "labels.wrapSelectionInFrame",
    trackEvent: { category: "element" },
    predicate: (e, o, t, r) => {
      let n = Z(e, o);
      return n.length > 0 && !n.some((i) => Wc(i));
    },
    perform: (e, o, t, r) => {
      let n = Z(e, o),
        i = r.scene.getNonDeletedElementsMap(),
        [a, l, s, d] = vD(n, i),
        m = 16,
        c = bD({ x: a - m, y: l - m, width: s - a + m * 2, height: d - l + m * 2 });
      if (o.editingGroupId) {
        let u = wD(n, o.editingGroupId);
        for (let f of u) {
          let b = f.groupIds.indexOf(o.editingGroupId);
          fD(f, i, { groupIds: f.groupIds.slice(0, b) });
        }
      }
      return {
        elements: xD([...r.scene.getElementsIncludingDeleted(), c], n, c, o),
        appState: { selectedElementIds: { [c.id]: !0 } },
        captureUpdate: an.IMMEDIATELY,
      };
    },
  });
import { isWindows as LD, KEYS as Ka, matchKey as Sh, arrayToMap as mw } from "@excalidraw/common";
import { CaptureUpdateAction as Ch } from "@excalidraw/element";
import { orderByFractionalIndex as PD } from "@excalidraw/element";
import { Emitter as TD } from "@excalidraw/common";
import {
  CaptureUpdateAction as ID,
  StoreChange as CD,
  StoreDelta as SD,
} from "@excalidraw/element";
var Ii = class extends SD {
    applyTo(o, t, r) {
      let [n, i] = this.elements.applyTo(o, r.elements, {
          excludedProperties: new Set(["version", "versionNonce"]),
        }),
        [a, l] = this.appState.applyTo(t, n);
      return [n, a, i || l];
    }
    static calculate(o, t) {
      return super.calculate(o, t);
    }
    static inverse(o) {
      return super.inverse(o);
    }
    static applyLatestChanges(o, t, r, n) {
      return super.applyLatestChanges(o, t, r, n);
    }
  },
  ln = class {
    constructor(o = !0, t = !0) {
      this.isUndoStackEmpty = o;
      this.isRedoStackEmpty = t;
    }
  },
  Xa = class e {
    constructor(o) {
      this.store = o;
      I(this, "onHistoryChangedEmitter", new TD());
      I(this, "undoStack", []);
      I(this, "redoStack", []);
    }
    get isUndoStackEmpty() {
      return this.undoStack.length === 0;
    }
    get isRedoStackEmpty() {
      return this.redoStack.length === 0;
    }
    clear() {
      (this.undoStack.length = 0), (this.redoStack.length = 0);
    }
    record(o) {
      if (o.isEmpty() || o instanceof Ii) return;
      let t = Ii.inverse(o);
      this.undoStack.push(t),
        t.elements.isEmpty() || (this.redoStack.length = 0),
        this.onHistoryChangedEmitter.trigger(new ln(this.isUndoStackEmpty, this.isRedoStackEmpty));
    }
    undo(o, t) {
      return this.perform(
        o,
        t,
        () => e.pop(this.undoStack),
        (r) => e.push(this.redoStack, r)
      );
    }
    redo(o, t) {
      return this.perform(
        o,
        t,
        () => e.pop(this.redoStack),
        (r) => e.push(this.undoStack, r)
      );
    }
    perform(o, t, r, n) {
      try {
        let i = r();
        if (i === null) return;
        let a = ID.IMMEDIATELY,
          l = this.store.snapshot,
          s = o,
          d = t,
          m = !1;
        for (; i; ) {
          try {
            [s, d, m] = i.applyTo(s, d, l);
            let c = l.elements,
              p = l.maybeClone(a, s, d),
              u = CD.create(l, p),
              f = Ii.applyLatestChanges(i, c, s);
            f.isEmpty() ||
              (this.store.scheduleMicroAction({ action: a, change: u, delta: f }), (i = f)),
              (l = p);
          } finally {
            n(i);
          }
          if (m) break;
          i = r();
        }
        return [s, d];
      } finally {
        this.onHistoryChangedEmitter.trigger(new ln(this.isUndoStackEmpty, this.isRedoStackEmpty));
      }
    }
    static pop(o) {
      if (!o.length) return null;
      let t = o.pop();
      return t !== void 0 ? t : null;
    }
    static push(o, t) {
      let r = Ii.inverse(t);
      return o.push(r);
    }
  };
import { useEffect as kD, useState as MD } from "react";
var Ih = (e, o) => {
  let [t, r] = MD(o);
  return (
    kD(() => {
      let n = e.on((i) => {
        r(i);
      });
      return () => {
        n();
      };
    }, [e]),
    t
  );
};
import { jsx as gw } from "react/jsx-runtime";
var pw = (e, o, t) => {
    if (
      !o.multiElement &&
      !o.resizingElement &&
      !o.editingTextElement &&
      !o.newElement &&
      !o.selectedElementsAreBeingDragged &&
      !o.selectionElement &&
      !e.flowChartCreator.isCreatingChart
    ) {
      let r = t();
      if (!r) return { captureUpdate: Ch.EVENTUALLY };
      let [n, i] = r,
        a = PD(Array.from(n.values()));
      return { appState: i, elements: a, captureUpdate: Ch.NEVER };
    }
    return { captureUpdate: Ch.EVENTUALLY };
  },
  uw = (e) => ({
    name: "undo",
    label: "buttons.undo",
    icon: Cm,
    trackEvent: { category: "history" },
    viewMode: !1,
    perform: (o, t, r, n) => pw(n, t, () => e.undo(mw(o), t)),
    keyTest: (o) => o[Ka.CTRL_OR_CMD] && Sh(o, Ka.Z) && !o.shiftKey,
    PanelComponent: ({ updateData: o, data: t }) => {
      let { isUndoStackEmpty: r } = Ih(
        e.onHistoryChangedEmitter,
        new ln(e.isUndoStackEmpty, e.isRedoStackEmpty)
      );
      return gw(V, {
        type: "button",
        icon: Cm,
        "aria-label": g("buttons.undo"),
        onClick: o,
        size: t?.size || "medium",
        disabled: r,
        "data-testid": "button-undo",
      });
    },
  }),
  hw = (e) => ({
    name: "redo",
    label: "buttons.redo",
    icon: Sm,
    trackEvent: { category: "history" },
    viewMode: !1,
    perform: (o, t, r, n) => pw(n, t, () => e.redo(mw(o), t)),
    keyTest: (o) =>
      (o[Ka.CTRL_OR_CMD] && o.shiftKey && Sh(o, Ka.Z)) ||
      (LD && o.ctrlKey && !o.shiftKey && Sh(o, Ka.Y)),
    PanelComponent: ({ updateData: o, data: t }) => {
      let { isRedoStackEmpty: r } = Ih(
        e.onHistoryChangedEmitter,
        new ln(e.isUndoStackEmpty, e.isRedoStackEmpty)
      );
      return gw(V, {
        type: "button",
        icon: Sm,
        "aria-label": g("buttons.redo"),
        onClick: o,
        size: t?.size || "medium",
        disabled: r,
        "data-testid": "button-redo",
      });
    },
  });
import { getFontString as AD } from "@excalidraw/common";
import { newElementWith as DD } from "@excalidraw/element";
import { measureText as _D } from "@excalidraw/element";
import { isTextElement as fw } from "@excalidraw/element";
import { CaptureUpdateAction as RD } from "@excalidraw/element";
var bw = B({
  name: "autoResize",
  label: "labels.autoResize",
  icon: null,
  trackEvent: { category: "element" },
  predicate: (e, o, t, r) => {
    let n = Z(e, o);
    return n.length === 1 && fw(n[0]) && !n[0].autoResize;
  },
  perform: (e, o, t, r) => {
    let n = Z(e, o);
    return {
      appState: o,
      elements: e.map((i) => {
        if (i.id === n[0].id && fw(i)) {
          let a = _D(i.originalText, AD(i), i.lineHeight);
          return DD(i, { autoResize: !0, width: a.width, height: a.height, text: i.originalText });
        }
        return i;
      }),
      captureUpdate: RD.IMMEDIATELY,
    };
  },
});
import { CODES as ND, KEYS as BD } from "@excalidraw/common";
import { CaptureUpdateAction as FD } from "@excalidraw/element";
var kh = B({
  name: "viewMode",
  label: "labels.viewMode",
  icon: An,
  viewMode: !0,
  trackEvent: { category: "canvas", predicate: (e) => !e.viewModeEnabled },
  perform(e, o) {
    return { appState: { ...o, viewModeEnabled: !this.checked(o) }, captureUpdate: FD.EVENTUALLY };
  },
  checked: (e) => e.viewModeEnabled,
  predicate: (e, o, t) => typeof t.viewModeEnabled > "u",
  keyTest: (e) => !e[BD.CTRL_OR_CMD] && e.altKey && e.code === ND.R,
});
import { isPromiseLike as OD } from "@excalidraw/common";
import { jsx as zD } from "react/jsx-runtime";
var Mh = (e, o, t, r, n, i) => {
    if (e.trackEvent)
      try {
        typeof e.trackEvent == "object" &&
          (!e.trackEvent.predicate || e.trackEvent.predicate(t, r, i)) &&
          re(
            e.trackEvent.category,
            e.trackEvent.action || e.name,
            `${o} (${n.device.editor.isMobile ? "mobile" : "desktop"})`
          );
      } catch (a) {
        console.error("error while logging action:", a);
      }
  },
  Vc = class {
    constructor(o, t, r, n) {
      I(this, "actions", {});
      I(this, "updater");
      I(this, "getAppState");
      I(this, "getElementsIncludingDeleted");
      I(this, "app");
      I(this, "renderAction", (o, t) => {
        let r = this.app.props.UIOptions.canvasActions;
        if (this.actions[o] && "PanelComponent" in this.actions[o] && (!(o in r) || r[o])) {
          let n = this.actions[o],
            i = n.PanelComponent;
          i.displayName = "PanelComponent";
          let a = this.getElementsIncludingDeleted(),
            l = this.getAppState(),
            s = (d) => {
              Mh(n, "ui", l, a, this.app, d),
                this.updater(
                  n.perform(this.getElementsIncludingDeleted(), this.getAppState(), d, this.app)
                );
            };
          return zD(i, {
            elements: this.getElementsIncludingDeleted(),
            appState: this.getAppState(),
            updateData: s,
            appProps: this.app.props,
            app: this.app,
            data: t,
            renderAction: this.renderAction,
          });
        }
        return null;
      });
      I(this, "isActionEnabled", (o) => {
        let t = this.getElementsIncludingDeleted(),
          r = this.getAppState();
        return !o.predicate || o.predicate(t, r, this.app.props, this.app);
      });
      (this.updater = (i) => {
        if (OD(i)) i.then((a) => o(a));
        else return o(i);
      }),
        (this.getAppState = t),
        (this.getElementsIncludingDeleted = r),
        (this.app = n);
    }
    registerAction(o) {
      this.actions[o.name] = o;
    }
    registerAll(o) {
      o.forEach((t) => this.registerAction(t));
    }
    handleKeyDown(o) {
      let t = this.app.props.UIOptions.canvasActions,
        r = Object.values(this.actions)
          .sort((s, d) => (d.keyPriority || 0) - (s.keyPriority || 0))
          .filter(
            (s) =>
              (s.name in t ? t[s.name] : !0) &&
              s.keyTest &&
              s.keyTest(o, this.getAppState(), this.getElementsIncludingDeleted(), this.app)
          );
      if (r.length !== 1)
        return (
          r.length > 1 && console.warn("Canceling as multiple actions match this shortcut", r), !1
        );
      let n = r[0];
      if (this.getAppState().viewModeEnabled && n.viewMode !== !0) return !1;
      let i = this.getElementsIncludingDeleted(),
        a = this.getAppState(),
        l = null;
      return (
        Mh(n, "keyboard", a, i, this.app, null),
        o.preventDefault(),
        o.stopPropagation(),
        this.updater(r[0].perform(i, a, l, this.app)),
        !0
      );
    }
    executeAction(o, t = "api", r = null) {
      let n = this.getElementsIncludingDeleted(),
        i = this.getAppState();
      Mh(o, t, i, n, this.app, r), this.updater(o.perform(n, i, r, this.app));
    }
  };
var Xc = class {
  constructor() {
    I(this, "targets", new WeakMap());
    I(this, "rafIds", new WeakMap());
  }
  register(o, t) {
    this.targets.set(o, { callback: t, stopped: !0 });
  }
  start(o) {
    let t = this.targets.get(o);
    t &&
      (this.rafIds.has(o) || (this.targets.set(o, { ...t, stopped: !1 }), this.scheduleFrame(o)));
  }
  stop(o) {
    let t = this.targets.get(o);
    t && !t.stopped && this.targets.set(o, { ...t, stopped: !0 }), this.cancelFrame(o);
  }
  constructFrame(o) {
    return (t) => {
      let r = this.targets.get(o);
      if (!r) return;
      let n = this.onFrame(r, t);
      !r.stopped && !n ? this.scheduleFrame(o) : this.cancelFrame(o);
    };
  }
  scheduleFrame(o) {
    let t = requestAnimationFrame(this.constructFrame(o));
    this.rafIds.set(o, t);
  }
  cancelFrame(o) {
    if (this.rafIds.has(o)) {
      let t = this.rafIds.get(o);
      cancelAnimationFrame(t);
    }
    this.rafIds.delete(o);
  }
  onFrame(o, t) {
    return o.callback(t) ?? !1;
  }
};
var Lh = (e) => {
    let o = Array.from(e.values());
    return { x: xw(o, (t) => t.x) / o.length, y: xw(o, (t) => t.y) / o.length };
  },
  Ph = ([e, o]) => Math.hypot(e.x - o.x, e.y - o.y),
  xw = (e, o) => e.reduce((t, r) => t + o(r), 0);
import {
  pointFrom as H,
  pointRotateRads as fr,
  rangeInclusive as Yt,
  rangeIntersection as Kc,
  rangesOverlap as Zc,
} from "@excalidraw/math";
import { TOOL_TYPE as sn, KEYS as Ew } from "@excalidraw/common";
import {
  getCommonBounds as Ah,
  getDraggedElementsBounds as Dh,
  getElementAbsoluteCoords as HD,
} from "@excalidraw/element";
import { isBoundToContainer as Tw, isFrameLikeElement as GD } from "@excalidraw/element";
import { getMaximumGroups as Iw } from "@excalidraw/element";
import {
  getSelectedElements as UD,
  getVisibleAndNonSelectedElements as Cw,
} from "@excalidraw/element";
var YD = 8,
  yw = 99999,
  $c = (e) => YD / e,
  gt = class gt {};
I(gt, "referenceSnapPoints", null),
  I(gt, "visibleGaps", null),
  I(gt, "setReferenceSnapPoints", (o) => {
    gt.referenceSnapPoints = o;
  }),
  I(gt, "getReferenceSnapPoints", () => gt.referenceSnapPoints),
  I(gt, "setVisibleGaps", (o) => {
    gt.visibleGaps = o;
  }),
  I(gt, "getVisibleGaps", () => gt.visibleGaps),
  I(gt, "destroy", () => {
    (gt.referenceSnapPoints = null), (gt.visibleGaps = null);
  });
var Wt = gt,
  br = (e) => e.props.gridModeEnabled ?? e.state.gridModeEnabled,
  Uo = ({ event: e, app: o, selectedElements: t }) =>
    e
      ? o.state.activeTool.type !== "lasso" &&
        ((o.state.objectsSnapModeEnabled && !e[Ew.CTRL_OR_CMD]) ||
          (!o.state.objectsSnapModeEnabled && e[Ew.CTRL_OR_CMD] && !br(o)))
      : t.length === 1 && t[0].type === "arrow"
      ? !1
      : o.state.objectsSnapModeEnabled,
  WD = (e, o, t = 0.01) => Math.abs(e - o) <= t,
  Za = (
    e,
    o,
    { omitCenter: t, boundingBoxCorners: r, dragOffset: n } = {
      omitCenter: !1,
      boundingBoxCorners: !1,
    }
  ) => {
    let i = [];
    if (e.length === 1) {
      let a = e[0],
        [l, s, d, m, c, p] = HD(a, o);
      n && ((l += n.x), (d += n.x), (c += n.x), (s += n.y), (m += n.y), (p += n.y));
      let u = (d - l) / 2,
        f = (m - s) / 2;
      if ((a.type === "diamond" || a.type === "ellipse") && !r) {
        let b = fr(H(l, s + f), H(c, p), a.angle),
          x = fr(H(l + u, s), H(c, p), a.angle),
          w = fr(H(d, s + f), H(c, p), a.angle),
          E = fr(H(l + u, m), H(c, p), a.angle),
          y = H(c, p);
        i = t ? [b, x, w, E] : [b, x, w, E, y];
      } else {
        let b = fr(H(l, s), H(c, p), a.angle),
          x = fr(H(d, s), H(c, p), a.angle),
          w = fr(H(l, m), H(c, p), a.angle),
          E = fr(H(d, m), H(c, p), a.angle),
          y = H(c, p);
        i = t ? [b, x, w, E] : [b, x, w, E, y];
      }
    } else if (e.length > 1) {
      let [a, l, s, d] = Dh(e, n ?? { x: 0, y: 0 }),
        m = s - a,
        c = d - l,
        p = H(a, l),
        u = H(s, l),
        f = H(a, d),
        b = H(s, d),
        x = H(a + m / 2, l + c / 2);
      i = t ? [p, u, f, b] : [p, u, f, b, x];
    }
    return i.map((a) => H(Le(a[0]), Le(a[1])));
  },
  Sw = (e, o, t, r) => {
    let n = o.filter((i) => GD(i)).map((i) => i.id);
    return Cw(e, o, t, r).filter((i) => !(i.frameId && n.includes(i.frameId)));
  },
  kw = (e, o, t, r) => {
    let n = Sw(e, o, t, r),
      i = Iw(n, r)
        .filter((c) => !(c.length === 1 && Tw(c[0])))
        .map((c) => Ah(c).map((p) => Le(p))),
      a = i.sort((c, p) => c[0] - p[0]),
      l = [],
      s = 0;
    e: for (let c = 0; c < a.length; c++) {
      let p = a[c];
      for (let u = c + 1; u < a.length; u++) {
        if (++s > yw) break e;
        let f = a[u],
          [, b, x, w] = p,
          [E, y, , v] = f;
        x < E &&
          Zc(Yt(b, w), Yt(y, v)) &&
          l.push({
            startBounds: p,
            endBounds: f,
            startSide: [H(x, b), H(x, w)],
            endSide: [H(E, y), H(E, v)],
            length: E - x,
            overlap: Kc(Yt(b, w), Yt(y, v)),
          });
      }
    }
    let d = i.sort((c, p) => c[1] - p[1]),
      m = [];
    s = 0;
    e: for (let c = 0; c < d.length; c++) {
      let p = d[c];
      for (let u = c + 1; u < d.length; u++) {
        if (++s > yw) break e;
        let f = d[u],
          [b, , x, w] = p,
          [E, y, v] = f;
        w < y &&
          Zc(Yt(b, x), Yt(E, v)) &&
          m.push({
            startBounds: p,
            endBounds: f,
            startSide: [H(b, w), H(x, w)],
            endSide: [H(E, y), H(v, y)],
            length: y - w,
            overlap: Kc(Yt(b, x), Yt(E, v)),
          });
      }
    }
    return { horizontalGaps: l, verticalGaps: m };
  },
  ww = (e, o, t, r, n, i, a) => {
    if (!Uo({ app: t, event: r, selectedElements: e })) return [];
    if (e.length === 0) return [];
    let l = Wt.getVisibleGaps();
    if (l) {
      let { horizontalGaps: s, verticalGaps: d } = l,
        [m, c, p, u] = Dh(e, o).map((x) => Le(x)),
        f = (m + p) / 2,
        b = (c + u) / 2;
      for (let x of s) {
        if (!Zc(Yt(c, u), x.overlap)) continue;
        let w = x.startSide[0][0] + x.length / 2,
          E = Le(w - f);
        if (x.length > p - m && Math.abs(E) <= a.x) {
          Math.abs(E) < a.x && (n.length = 0), (a.x = Math.abs(E));
          let P = { type: "gap", direction: "center_horizontal", gap: x, offset: E };
          n.push(P);
          continue;
        }
        let [, , v] = x.endBounds,
          C = m - v,
          S = Le(x.length - C);
        if (Math.abs(S) <= a.x) {
          Math.abs(S) < a.x && (n.length = 0), (a.x = Math.abs(S));
          let P = { type: "gap", direction: "side_right", gap: x, offset: S };
          n.push(P);
          continue;
        }
        let [M, , ,] = x.startBounds,
          k = M - p,
          A = Le(k - x.length);
        if (Math.abs(A) <= a.x) {
          Math.abs(A) < a.x && (n.length = 0), (a.x = Math.abs(A));
          let P = { type: "gap", direction: "side_left", gap: x, offset: A };
          n.push(P);
          continue;
        }
      }
      for (let x of d) {
        if (!Zc(Yt(m, p), x.overlap)) continue;
        let w = x.startSide[0][1] + x.length / 2,
          E = Le(w - b);
        if (x.length > u - c && Math.abs(E) <= a.y) {
          Math.abs(E) < a.y && (i.length = 0), (a.y = Math.abs(E));
          let P = { type: "gap", direction: "center_vertical", gap: x, offset: E };
          i.push(P);
          continue;
        }
        let [, v, ,] = x.startBounds,
          C = v - u,
          S = Le(C - x.length);
        if (Math.abs(S) <= a.y) {
          Math.abs(S) < a.y && (i.length = 0), (a.y = Math.abs(S));
          let P = { type: "gap", direction: "side_top", gap: x, offset: S };
          i.push(P);
          continue;
        }
        let [, , , M] = x.endBounds,
          k = Le(c - M),
          A = x.length - k;
        if (Math.abs(A) <= a.y) {
          Math.abs(A) < a.y && (i.length = 0), (a.y = Math.abs(A));
          let P = { type: "gap", direction: "side_bottom", gap: x, offset: A };
          i.push(P);
          continue;
        }
      }
    }
  },
  Mw = (e, o, t, r) => {
    let n = Sw(e, o, t, r);
    return Iw(n, r)
      .filter((i) => !(i.length === 1 && Tw(i[0])))
      .flatMap((i) => Za(i, r));
  },
  Ci = (e, o, t, r, n, i, a) => {
    if (!Uo({ app: t, event: r, selectedElements: e }) || (e.length === 0 && o.length === 0))
      return [];
    let l = Wt.getReferenceSnapPoints();
    if (l)
      for (let s of o)
        for (let d of l) {
          let m = d[0] - s[0],
            c = d[1] - s[1];
          Math.abs(m) <= a.x &&
            (Math.abs(m) < a.x && (n.length = 0),
            n.push({ type: "point", points: [s, d], offset: m }),
            (a.x = Math.abs(m))),
            Math.abs(c) <= a.y &&
              (Math.abs(c) < a.y && (i.length = 0),
              i.push({ type: "point", points: [s, d], offset: c }),
              (a.y = Math.abs(c)));
        }
  },
  Lw = (e, o, t, r, n) => {
    let i = t.state,
      a = UD(e, i);
    if (!Uo({ app: t, event: r, selectedElements: a }) || a.length === 0)
      return { snapOffset: { x: 0, y: 0 }, snapLines: [] };
    (o.x = Le(o.x)), (o.y = Le(o.y));
    let l = [],
      s = [],
      d = $c(i.zoom.value),
      m = { x: d, y: d },
      c = Za(a, n, { dragOffset: o });
    Ci(a, c, t, r, l, s, m), ww(a, o, t, r, l, s, m);
    let p = { x: l[0]?.offset ?? 0, y: s[0]?.offset ?? 0 };
    (m.x = 0), (m.y = 0), (l.length = 0), (s.length = 0);
    let u = { x: Le(o.x + p.x), y: Le(o.y + p.y) };
    Ci(a, Za(a, n, { dragOffset: u }), t, r, l, s, m), ww(a, u, t, r, l, s, m);
    let f = _h(l, s),
      b = XD(
        a,
        u,
        [...l, ...s].filter((x) => x.type === "gap")
      );
    return { snapOffset: p, snapLines: [...f, ...b] };
  },
  Le = (e) => Math.round(e * 10 ** 6) / 10 ** 6,
  vw = (e) => {
    let o = new Map();
    for (let t of e) {
      let r = t.join(",");
      o.has(r) || o.set(r, t);
    }
    return Array.from(o.values());
  },
  _h = (e, o) => {
    let t = {},
      r = {};
    if (e.length > 0) {
      for (let n of e)
        if (n.type === "point") {
          let i = Le(n.points[0][0]);
          t[i] || (t[i] = []), t[i].push(...n.points.map((a) => H(Le(a[0]), Le(a[1]))));
        }
    }
    if (o.length > 0) {
      for (let n of o)
        if (n.type === "point") {
          let i = Le(n.points[0][1]);
          r[i] || (r[i] = []), r[i].push(...n.points.map((a) => H(Le(a[0]), Le(a[1]))));
        }
    }
    return Object.entries(t)
      .map(([n, i]) => ({
        type: "points",
        points: vw(i.map((a) => H(Number(n), a[1])).sort((a, l) => a[1] - l[1])),
      }))
      .concat(
        Object.entries(r).map(([n, i]) => ({
          type: "points",
          points: vw(i.map((a) => H(a[0], Number(n))).sort((a, l) => a[0] - l[0])),
        }))
      );
  },
  VD = (e) => {
    let o = new Map();
    for (let t of e) {
      let r = t.points
        .flat()
        .map((n) => [Le(n)])
        .join(",");
      o.has(r) || o.set(r, t);
    }
    return Array.from(o.values());
  },
  XD = (e, o, t) => {
    let [r, n, i, a] = Dh(e, o),
      l = [];
    for (let s of t) {
      let [d, m, c, p] = s.gap.startBounds,
        [u, f, b, x] = s.gap.endBounds,
        w = Kc(Yt(n, a), s.gap.overlap),
        E = Kc(Yt(r, i), s.gap.overlap);
      switch (s.direction) {
        case "center_horizontal": {
          if (w) {
            let y = (w[0] + w[1]) / 2;
            l.push(
              {
                type: "gap",
                direction: "horizontal",
                points: [H(s.gap.startSide[0][0], y), H(r, y)],
              },
              { type: "gap", direction: "horizontal", points: [H(i, y), H(s.gap.endSide[0][0], y)] }
            );
          }
          break;
        }
        case "center_vertical": {
          if (E) {
            let y = (E[0] + E[1]) / 2;
            l.push(
              {
                type: "gap",
                direction: "vertical",
                points: [H(y, s.gap.startSide[0][1]), H(y, n)],
              },
              { type: "gap", direction: "vertical", points: [H(y, a), H(y, s.gap.endSide[0][1])] }
            );
          }
          break;
        }
        case "side_right": {
          if (w) {
            let y = (w[0] + w[1]) / 2;
            l.push(
              { type: "gap", direction: "horizontal", points: [H(c, y), H(u, y)] },
              { type: "gap", direction: "horizontal", points: [H(b, y), H(r, y)] }
            );
          }
          break;
        }
        case "side_left": {
          if (w) {
            let y = (w[0] + w[1]) / 2;
            l.push(
              { type: "gap", direction: "horizontal", points: [H(i, y), H(d, y)] },
              { type: "gap", direction: "horizontal", points: [H(c, y), H(u, y)] }
            );
          }
          break;
        }
        case "side_top": {
          if (E) {
            let y = (E[0] + E[1]) / 2;
            l.push(
              { type: "gap", direction: "vertical", points: [H(y, a), H(y, m)] },
              { type: "gap", direction: "vertical", points: [H(y, p), H(y, f)] }
            );
          }
          break;
        }
        case "side_bottom": {
          if (E) {
            let y = (E[0] + E[1]) / 2;
            l.push(
              { type: "gap", direction: "vertical", points: [H(y, p), H(y, f)] },
              { type: "gap", direction: "vertical", points: [H(y, x), H(y, n)] }
            );
          }
          break;
        }
      }
    }
    return VD(l.map((s) => ({ ...s, points: s.points.map((d) => H(Le(d[0]), Le(d[1]))) })));
  },
  Rh = (e, o, t, r, n, i) => {
    if (
      !Uo({ event: r, selectedElements: e, app: t }) ||
      e.length === 0 ||
      (e.length === 1 && !WD(e[0].angle, 0))
    )
      return { snapOffset: { x: 0, y: 0 }, snapLines: [] };
    let [a, l, s, d] = Ah(o);
    i &&
      (i.includes("e") ? (s += n.x) : i.includes("w") && (a += n.x),
      i.includes("n") ? (l += n.y) : i.includes("s") && (d += n.y));
    let m = [];
    if (i)
      switch (i) {
        case "e": {
          m.push(H(s, l), H(s, d));
          break;
        }
        case "w": {
          m.push(H(a, l), H(a, d));
          break;
        }
        case "n": {
          m.push(H(a, l), H(s, l));
          break;
        }
        case "s": {
          m.push(H(a, d), H(s, d));
          break;
        }
        case "ne": {
          m.push(H(s, l));
          break;
        }
        case "nw": {
          m.push(H(a, l));
          break;
        }
        case "se": {
          m.push(H(s, d));
          break;
        }
        case "sw": {
          m.push(H(a, d));
          break;
        }
      }
    let c = $c(t.state.zoom.value),
      p = { x: c, y: c },
      u = [],
      f = [];
    Ci(o, m, t, r, u, f, p);
    let b = { x: u[0]?.offset ?? 0, y: f[0]?.offset ?? 0 };
    (p.x = 0), (p.y = 0), (u.length = 0), (f.length = 0);
    let [x, w, E, y] = Ah(e).map((S) => Le(S)),
      v = [H(x, w), H(x, y), H(E, w), H(E, y)];
    Ci(e, v, t, r, u, f, p);
    let C = _h(u, f);
    return { snapOffset: b, snapLines: C };
  },
  Pw = (e, o, t, r, n, i) => {
    if (!Uo({ event: t, selectedElements: [e], app: o }))
      return { snapOffset: { x: 0, y: 0 }, snapLines: [] };
    let a = [H(r.x + n.x, r.y + n.y)],
      l = $c(o.state.zoom.value),
      s = { x: l, y: l },
      d = [],
      m = [];
    Ci([e], a, o, t, d, m, s);
    let c = { x: d[0]?.offset ?? 0, y: m[0]?.offset ?? 0 };
    (s.x = 0), (s.y = 0), (d.length = 0), (m.length = 0);
    let p = Za([e], i, { boundingBoxCorners: !0, omitCenter: !0 });
    Ci([e], p, o, t, d, m, s);
    let u = _h(d, m);
    return { snapOffset: c, snapLines: u };
  },
  Aw = (e, o, t, r, n) => {
    if (!Uo({ event: r, selectedElements: [], app: o }))
      return { originOffset: { x: 0, y: 0 }, snapLines: [] };
    let i = Cw(e, [], o.state, n),
      a = $c(o.state.zoom.value),
      l = { x: a, y: a },
      s = [],
      d = [];
    for (let m of i) {
      let c = Za([m], n);
      for (let p of c) {
        let u = p[0] - t.x;
        Math.abs(u) <= Math.abs(l.x) &&
          (Math.abs(u) < Math.abs(l.x) && (d.length = 0),
          d.push({ type: "pointer", points: [p, H(p[0], t.y)], direction: "vertical" }),
          (l.x = u));
        let f = p[1] - t.y;
        Math.abs(f) <= Math.abs(l.y) &&
          (Math.abs(f) < Math.abs(l.y) && (s.length = 0),
          s.push({ type: "pointer", points: [p, H(t.x, p[1])], direction: "horizontal" }),
          (l.y = f));
      }
    }
    return {
      originOffset: {
        x: d.length > 0 ? d[0].points[0][0] - t.x : 0,
        y: s.length > 0 ? s[0].points[0][1] - t.y : 0,
      },
      snapLines: [...d, ...s],
    };
  },
  Dw = (e) =>
    e === sn.rectangle ||
    e === sn.ellipse ||
    e === sn.diamond ||
    e === sn.frame ||
    e === sn.magicframe ||
    e === sn.image ||
    e === sn.text;
import { pointFrom as jc } from "@excalidraw/math";
import {
  DEFAULT_FONT_FAMILY as KD,
  DEFAULT_FONT_SIZE as ZD,
  TEXT_ALIGN as $D,
  VERTICAL_ALIGN as jD,
  getSizeFromPoints as qD,
  randomId as JD,
  arrayToMap as QD,
  assertNever as Nh,
  cloneJSON as Nw,
  getFontString as e_,
  isDevEnv as t_,
  toBrandedType as o_,
  getLineHeight as r_,
} from "@excalidraw/common";
import { bindLinearElement as _w } from "@excalidraw/element";
import {
  newArrowElement as n_,
  newElement as Bh,
  newFrameElement as i_,
  newImageElement as a_,
  newLinearElement as l_,
  newMagicFrameElement as s_,
  newTextElement as Jc,
} from "@excalidraw/element";
import { measureText as c_, normalizeText as d_ } from "@excalidraw/element";
import { isArrowElement as m_ } from "@excalidraw/element";
import { syncInvalidIndices as p_ } from "@excalidraw/element";
import { redrawTextBoundingBox as u_ } from "@excalidraw/element";
import { LinearElementEditor as h_ } from "@excalidraw/element";
import { getCommonBounds as g_ } from "@excalidraw/element";
import { Scene as f_ } from "@excalidraw/element";
var qc = { width: 100, height: 0 },
  xr = 100,
  b_ = (e, o, t) => {
    let r = Jc({
      x: 0,
      y: 0,
      textAlign: $D.CENTER,
      verticalAlign: jD.MIDDLE,
      ...o,
      containerId: e.id,
      strokeColor: o.strokeColor || e.strokeColor,
    });
    return (
      Object.assign(e, {
        boundElements: (e.boundElements || []).concat({ type: "text", id: r.id }),
      }),
      u_(r, e, t),
      [e, r]
    );
  },
  Rw = (e, o, t, r, n) => {
    let i, a;
    if (
      (Object.assign(e, {
        startBinding: e?.startBinding || null,
        endBinding: e.endBinding || null,
      }),
      o)
    ) {
      let m = o?.width ?? xr,
        c = o?.height ?? xr,
        p;
      o.id &&
        ((p = r.getElement(o.id)),
        p || console.error(`No element for start binding with id ${o.id} found`));
      let u = o.x || e.x - m,
        f = o.y || e.y - c / 2,
        b = p ? p.type : o.type;
      if (b) {
        if (b === "text") {
          let x = "";
          p && p.type === "text" ? (x = p.text) : o.type === "text" && (x = o.text),
            x || console.error(`No text found for start binding text element for ${e.id}`),
            (i = Jc({ x: u, y: f, type: "text", ...p, ...o, text: x })),
            Object.assign(i, { x: o.x || e.x - i.width, y: o.y || e.y - i.height / 2 });
        } else
          switch (b) {
            case "rectangle":
            case "ellipse":
            case "diamond": {
              i = Bh({ x: u, y: f, width: m, height: c, ...p, ...o, type: b });
              break;
            }
            default:
              Nh(e, `Unhandled element start type "${o.type}"`, !0);
          }
        _w(e, i, "start", n);
      }
    }
    if (t) {
      let m = t?.height ?? xr,
        c = t?.width ?? xr,
        p;
      t.id &&
        ((p = r.getElement(t.id)),
        p || console.error(`No element for end binding with id ${t.id} found`));
      let u = t.x || e.x + e.width,
        f = t.y || e.y - m / 2,
        b = p ? p.type : t.type;
      if (b) {
        if (b === "text") {
          let x = "";
          p && p.type === "text" ? (x = p.text) : t.type === "text" && (x = t.text),
            x || console.error(`No text found for end binding text element for ${e.id}`),
            (a = Jc({ x: u, y: f, type: "text", ...p, ...t, text: x })),
            Object.assign(a, { y: t.y || e.y - a.height / 2 });
        } else
          switch (b) {
            case "rectangle":
            case "ellipse":
            case "diamond": {
              a = Bh({ x: u, y: f, width: c, height: m, ...p, ...t, type: b });
              break;
            }
            default:
              Nh(e, `Unhandled element end type "${b}"`, !0);
          }
        _w(e, a, "end", n);
      }
    }
    if (e.points.length < 2) return { linearElement: e, startBoundElement: i, endBoundElement: a };
    let l = e.points.length - 1,
      s = 0.5,
      d = Nw(e.points);
    return (
      e.points[l][0] > e.points[l - 1][0] && ((d[0][0] = s), (d[l][0] -= s)),
      e.points[l][0] < e.points[l - 1][0] && ((d[0][0] = -s), (d[l][0] += s)),
      e.points[l][1] > e.points[l - 1][1] && ((d[0][1] = s), (d[l][1] -= s)),
      e.points[l][1] < e.points[l - 1][1] && ((d[0][1] = -s), (d[l][1] += s)),
      Object.assign(e, h_.getNormalizeElementPointsAndCoords({ ...e, points: d })),
      { linearElement: e, startBoundElement: i, endBoundElement: a }
    );
  },
  Fh = class {
    constructor() {
      I(this, "excalidrawElements", new Map());
      I(this, "add", (o) => {
        o && this.excalidrawElements.set(o.id, o);
      });
      I(this, "getElements", () => p_(Array.from(this.excalidrawElements.values())));
      I(this, "getElementsMap", () => o_(QD(this.getElements())));
      I(this, "getElement", (o) => this.excalidrawElements.get(o));
    }
  },
  Si = (e, o) => {
    if (!e) return [];
    let t = Nw(e),
      r = new Fh(),
      n = new Map(),
      i = new Map();
    for (let s of t) {
      let d,
        m = s.id;
      switch ((o?.regenerateIds !== !1 && Object.assign(s, { id: JD() }), s.type)) {
        case "rectangle":
        case "ellipse":
        case "diamond": {
          let p = s?.label?.text && s.width === void 0 ? 0 : s?.width || xr,
            u = s?.label?.text && s.height === void 0 ? 0 : s?.height || xr;
          d = Bh({ ...s, width: p, height: u });
          break;
        }
        case "line": {
          let p = s.width || qc.width,
            u = s.height || qc.height;
          d = l_({ width: p, height: u, points: [jc(0, 0), jc(p, u)], ...s });
          break;
        }
        case "arrow": {
          let p = s.width || qc.width,
            u = s.height || qc.height;
          (d = n_({
            width: p,
            height: u,
            endArrowhead: "arrow",
            points: [jc(0, 0), jc(p, u)],
            ...s,
            type: "arrow",
          })),
            Object.assign(d, qD(d.points));
          break;
        }
        case "text": {
          let p = s?.fontFamily || KD,
            u = s?.fontSize || ZD,
            f = s?.lineHeight || r_(p),
            b = s.text ?? "",
            x = d_(b),
            w = c_(x, e_({ fontFamily: p, fontSize: u }), f);
          d = Jc({ width: w.width, height: w.height, fontFamily: p, fontSize: u, ...s });
          break;
        }
        case "image": {
          d = a_({ width: s?.width || xr, height: s?.height || xr, ...s });
          break;
        }
        case "frame": {
          d = i_({ x: 0, y: 0, ...s });
          break;
        }
        case "magicframe": {
          d = s_({ x: 0, y: 0, ...s });
          break;
        }
        case "freedraw":
        case "iframe":
        case "embeddable": {
          d = s;
          break;
        }
        default:
          (d = s), Nh(s, `Unhandled element type "${s.type}"`, !0);
      }
      r.getElement(d.id)
        ? console.error(`Duplicate id found for ${d.id}`)
        : (r.add(d), n.set(d.id, s), m && i.set(m, d.id));
    }
    let a = r.getElementsMap(),
      l = new f_(a);
    for (let [s, d] of n) {
      let m = r.getElement(s);
      switch (d.type) {
        case "rectangle":
        case "ellipse":
        case "diamond":
        case "arrow": {
          if (d.label?.text) {
            let [c, p] = b_(m, d?.label, l);
            if ((r.add(c), r.add(p), m_(c))) {
              let u = d.type === "arrow" ? d?.start : void 0,
                f = d.type === "arrow" ? d?.end : void 0;
              if (u && u.id) {
                let E = i.get(u.id);
                E && Object.assign(u, { id: E });
              }
              if (f && f.id) {
                let E = i.get(f.id);
                E && Object.assign(f, { id: E });
              }
              let {
                linearElement: b,
                startBoundElement: x,
                endBoundElement: w,
              } = Rw(c, u, f, r, l);
              (c = b), r.add(b), r.add(x), r.add(w);
            }
          } else
            switch (d.type) {
              case "arrow": {
                let { start: c, end: p } = d;
                if (c && c.id) {
                  let x = i.get(c.id);
                  Object.assign(c, { id: x });
                }
                if (p && p.id) {
                  let x = i.get(p.id);
                  Object.assign(p, { id: x });
                }
                let {
                  linearElement: u,
                  startBoundElement: f,
                  endBoundElement: b,
                } = Rw(m, c, p, r, l);
                r.add(u), r.add(f), r.add(b);
                break;
              }
            }
          break;
        }
      }
    }
    for (let [s, d] of n) {
      if (d.type !== "frame" && d.type !== "magicframe") continue;
      let m = r.getElement(s);
      if (!m) throw new Error(`Excalidraw element with id ${s} doesn't exist`);
      let c = [];
      d.children.forEach((C) => {
        let S = i.get(C);
        if (!S) throw new Error(`Element with ${C} wasn't mapped correctly`);
        let M = r.getElement(S);
        if (!M) throw new Error(`Frame element with id ${S} doesn't exist`);
        Object.assign(M, { frameId: m.id }),
          M?.boundElements?.forEach((k) => {
            let A = r.getElement(k.id);
            if (!A) throw new Error(`Bound element with id ${k.id} doesn't exist`);
            Object.assign(A, { frameId: m.id }), c.push(A);
          }),
          c.push(M);
      });
      let [p, u, f, b] = g_(c),
        x = 10;
      (p = p - x), (u = u - x), (f = f + x), (b = b + x);
      let w = m?.x || p,
        E = m?.y || u,
        y = m?.width || f - p,
        v = m?.height || b - u;
      Object.assign(m, { x: w, y: E, width: y, height: v }),
        t_() &&
          d.children.length &&
          (m?.x || m?.y || m?.width || m?.height) &&
          console.info(
            "User provided frame attributes are being considered, if you find this inaccurate, please remove any of the attributes - x, y, width and height so frame coordinates and dimensions are calculated automatically"
          );
    }
    return r.getElements();
  };
import { isElementInViewport as K_ } from "@excalidraw/element";
import { memoize as Z_, toBrandedType as $_ } from "@excalidraw/common";
import { pointFrom as C_, pointsEqual as S_ } from "@excalidraw/math";
import ed from "open-color";
import {
  arrayToMap as k_,
  DEFAULT_TRANSFORM_HANDLE_SPACING as Vh,
  FRAME_STYLE as Uw,
  invariant as Yw,
  THEME as M_,
  throttleRAF as L_,
} from "@excalidraw/common";
import { FIXED_BINDING_DISTANCE as zh, maxBindingGap as $w } from "@excalidraw/element";
import { LinearElementEditor as Er } from "@excalidraw/element";
import {
  getOmitSidesForDevice as Hh,
  getTransformHandles as P_,
  getTransformHandlesFromCoords as A_,
  shouldShowBoundingBox as D_,
} from "@excalidraw/element";
import {
  isElbowArrow as $a,
  isFrameLikeElement as Ww,
  isImageElement as Vw,
  isLinearElement as __,
  isLineElement as R_,
  isTextElement as Xw,
} from "@excalidraw/element";
import { renderSelectionElement as N_ } from "@excalidraw/element";
import {
  getElementsInGroup as Yh,
  getSelectedGroupIds as B_,
  isSelectedViaGroup as F_,
  selectGroupsFromGivenElements as O_,
} from "@excalidraw/element";
import { getCommonBounds as Wh, getElementAbsoluteCoords as ja } from "@excalidraw/element";
import { pointFrom as st } from "@excalidraw/math";
import { THEME as x_ } from "@excalidraw/common";
var E_ = "#ff6b6b",
  y_ = "#ff0000",
  Bw = 1,
  Fw = 2,
  Ow = (e, o) => {
    if (!o.snapLines.length) return;
    let t = o.theme === x_.LIGHT || o.zenModeEnabled ? E_ : y_,
      r = (o.zenModeEnabled ? Bw * 1.5 : Bw) / o.zoom.value;
    e.save(), e.translate(o.scrollX, o.scrollY);
    for (let n of o.snapLines)
      n.type === "pointer"
        ? ((e.lineWidth = r), (e.strokeStyle = t), v_(n, e, o))
        : n.type === "gap"
        ? ((e.lineWidth = r), (e.strokeStyle = t), T_(n.points[0], n.points[1], n.direction, o, e))
        : n.type === "points" && ((e.lineWidth = r), (e.strokeStyle = t), w_(n, e, o));
    e.restore();
  },
  w_ = (e, o, t) => {
    if (!t.zenModeEnabled) {
      let r = e.points[0],
        n = e.points[e.points.length - 1];
      Vt(r, n, o);
    }
    for (let r of e.points) zw(r, t, o);
  },
  v_ = (e, o, t) => {
    zw(e.points[0], t, o), t.zenModeEnabled || Vt(e.points[0], e.points[1], o);
  },
  zw = ([e, o], t, r) => {
    r.save();
    let n = (t.zenModeEnabled ? Fw * 1.5 : Fw) / t.zoom.value;
    r.beginPath(),
      r.moveTo(e - n, o - n),
      r.lineTo(e + n, o + n),
      r.moveTo(e + n, o - n),
      r.lineTo(e - n, o + n),
      r.stroke(),
      r.restore();
  },
  Vt = (e, o, t) => {
    t.beginPath(), t.lineTo(e[0], e[1]), t.lineTo(o[0], o[1]), t.stroke();
  },
  T_ = (e, o, t, r, n) => {
    let i = 8 / r.zoom.value,
      a = i / 2,
      l = i / 4;
    if (t === "horizontal") {
      let s = [(e[0] + o[0]) / 2, e[1]];
      r.zenModeEnabled || Vt(st(e[0], e[1] - i), st(e[0], e[1] + i), n),
        Vt(st(s[0] - l, s[1] - a), st(s[0] - l, s[1] + a), n),
        Vt(st(s[0] + l, s[1] - a), st(s[0] + l, s[1] + a), n),
        r.zenModeEnabled || (Vt(st(o[0], o[1] - i), st(o[0], o[1] + i), n), Vt(e, o, n));
    } else {
      let s = [e[0], (e[1] + o[1]) / 2];
      r.zenModeEnabled || Vt(st(e[0] - i, e[1]), st(e[0] + i, e[1]), n),
        Vt(st(s[0] - a, s[1] - l), st(s[0] + a, s[1] - l), n),
        Vt(st(s[0] - a, s[1] + l), st(s[0] + a, s[1] + l), n),
        r.zenModeEnabled || (Vt(st(o[0] - i, o[1]), st(o[0] + i, o[1]), n), Vt(e, o, n));
    }
  };
import { getGlobalCSSVariable as Qc } from "@excalidraw/common";
import { getCommonBounds as I_ } from "@excalidraw/element";
var so = 4,
  It = 6,
  Hw = "rgba(0,0,0,0.3)",
  Gw = (e, o, t, r) => {
    if (!e.size) return { horizontal: null, vertical: null };
    let [n, i, a, l] = I_(e),
      s = o / r.zoom.value,
      d = t / r.zoom.value,
      m = {
        top: parseInt(Qc("sat")) || 0,
        bottom: parseInt(Qc("sab")) || 0,
        left: parseInt(Qc("sal")) || 0,
        right: parseInt(Qc("sar")) || 0,
      },
      c = Po().rtl,
      p = -r.scrollX + m.left,
      u = -r.scrollY + m.top,
      f = p + s - m.right,
      b = u + d - m.bottom,
      x = Math.min(n, p),
      w = Math.min(i, u),
      E = Math.max(a, f),
      y = Math.max(l, b),
      v = a - n,
      C = l - i,
      S = E - x,
      M = y - w,
      k = Math.max(so * 2, m.left + m.right) + It * 2,
      A = o * (s / S) - k,
      P = Math.max(so * 2, m.top + m.bottom) + It * 2,
      N = t * (d / M) - P,
      O = S > v ? (S * r.zoom.value) / (A + k) : o / (A + k),
      U = M > C ? (M * r.zoom.value) / (N + P) : t / (N + P);
    return {
      horizontal:
        p === x && f === E
          ? null
          : {
              x: Math.max(m.left, so) + It + ((p - x) / S) * o,
              y: t - It - Math.max(so, m.bottom),
              width: A,
              height: It,
              deltaMultiplier: O,
            },
      vertical:
        u === w && b === y
          ? null
          : {
              x: c ? Math.max(m.left, so) : o - It - Math.max(m.right, so),
              y: Math.max(m.top, so) + It + ((u - w) / M) * t,
              width: It,
              height: N,
              deltaMultiplier: U,
            },
    };
  },
  Oh = (e, o, t) => {
    let [r, n] = [e.horizontal, e.vertical].map(
      (a) => a != null && a.x <= o && o <= a.x + a.width && a.y <= t && t <= a.y + a.height
    );
    return { isOverEither: r || n, isOverHorizontal: r, isOverVertical: n };
  };
var z_ = (e, o) => {
    Yw(o.selectedLinearElement, "selectedLinearElement is null");
    let { segmentMidPointHoveredCoords: t } = o.selectedLinearElement;
    Yw(t, "midPointCoords is null"),
      e.save(),
      e.translate(o.scrollX, o.scrollY),
      jw(t, e, o),
      e.restore();
  },
  H_ = (e, o, t) => {
    let { elementId: r, hoverPointIndex: n } = o.selectedLinearElement;
    if (o.editingLinearElement?.selectedPointsIndices?.includes(n)) return;
    let i = Er.getElement(r, t);
    if (!i) return;
    let a = Er.getPointAtIndexGlobalCoordinates(i, n, t);
    e.save(), e.translate(o.scrollX, o.scrollY), jw(a, e, o), e.restore();
  },
  jw = (e, o, t) => {
    (o.fillStyle = "rgba(105, 101, 219, 0.4)"),
      Xi(o, e[0], e[1], Er.POINT_HANDLE_SIZE / t.zoom.value, !1);
  },
  Gh = (e, o, t, r, n, i, a) => {
    (e.strokeStyle = "#5e5ad8"),
      e.setLineDash([]),
      (e.fillStyle = "rgba(255, 255, 255, 0.9)"),
      n
        ? (e.fillStyle = "rgba(134, 131, 226, 0.9)")
        : i && (e.fillStyle = "rgba(177, 151, 252, 0.7)"),
      Xi(
        e,
        t[0],
        t[1],
        (a ? r * (o.editingLinearElement ? 1.5 : 2) : r) / o.zoom.value,
        !i,
        !a || n
      );
  },
  G_ = (e, o, t, r) => {
    let n = $w(o, o.width, o.height, r);
    switch (((e.fillStyle = "rgba(0,0,0,.05)"), o.type)) {
      case "rectangle":
      case "text":
      case "image":
      case "iframe":
      case "embeddable":
      case "frame":
      case "magicframe":
        t1(e, o, t, n);
        break;
      case "diamond":
        r1(e, n, o, t);
        break;
      case "ellipse": {
        let [i, a, l, s] = ja(o, t),
          d = l - i,
          m = s - a;
        (e.strokeStyle = "rgba(0,0,0,.05)"),
          (e.lineWidth = n - zh),
          o1(e, d + n + zh, m + n + zh, i + d / 2, a + m / 2, o.angle);
        break;
      }
    }
  },
  U_ = (e, o, t, r) => {
    let [n, i, a] = o,
      l = $w(a, a.width, a.height, r);
    (e.strokeStyle = "rgba(0,0,0,0)"),
      (e.fillStyle = "rgba(0,0,0,.05)"),
      (i === "both" ? [0, -1] : i === "start" ? [0] : [-1]).forEach((d) => {
        let [m, c] = Er.getPointAtIndexGlobalCoordinates(n, d, t);
        Xi(e, m, c, l, !0);
      });
  },
  qw = (e, o, t) => {
    let {
        angle: r,
        x1: n,
        y1: i,
        x2: a,
        y2: l,
        selectionColors: s,
        cx: d,
        cy: m,
        dashed: c,
        activeEmbeddable: p,
      } = t,
      u = a - n,
      f = l - i,
      x = (t.padding ?? Vh * 2) / o.zoom.value,
      w = 8 / o.zoom.value,
      E = 4 / o.zoom.value;
    e.save(), e.translate(o.scrollX, o.scrollY), (e.lineWidth = (p ? 4 : 1) / o.zoom.value);
    let y = s.length;
    for (let v = 0; v < y; ++v)
      (e.strokeStyle = s[v]),
        c && e.setLineDash([w, E + (w + E) * (y - 1)]),
        (e.lineDashOffset = (w + E) * v),
        Ki(e, n - x, i - x, u + x * 2, f + x * 2, d, m, r);
    e.restore();
  },
  Y_ = (e, o, t, r) => {
    let n = Array.isArray(t) ? U_ : G_;
    e.save(), e.translate(o.scrollX, o.scrollY), n(e, t, r, o.zoom), e.restore();
  },
  W_ = (e, o, t, r) => {
    let [n, i, a, l] = ja(t, r),
      s = a - n,
      d = l - i;
    (e.strokeStyle = "rgb(0,118,255)"),
      (e.lineWidth = Uw.strokeWidth / o.zoom.value),
      e.save(),
      e.translate(o.scrollX, o.scrollY),
      Ki(e, n, i, s, d, n + s / 2, i + d / 2, t.angle, !1, Uw.radius / o.zoom.value),
      e.restore();
  },
  Kw = (e, o, t, r) => {
    let { colors: n = ["rgb(0,118,255)"], dashed: i = !1 } = r || {},
      a = t.filter((m) => m.groupIds.length === 0),
      l = t.filter((m) => m.groupIds.length > 0),
      s = (m) => {
        let [c, p, u, f] = Wh(m);
        return {
          angle: 0,
          x1: c,
          x2: u,
          y1: p,
          y2: f,
          selectionColors: n,
          dashed: i,
          cx: c + (u - c) / 2,
          cy: p + (f - p) / 2,
          activeEmbeddable: !1,
        };
      },
      d = (m) => {
        let c = Yh(t, m);
        return s(c);
      };
    Object.entries(O_(l, o))
      .filter(([m, c]) => c)
      .map(([m, c]) => m)
      .map((m) => d(m))
      .concat(a.map((m) => s([m])))
      .forEach((m) => qw(e, o, m));
  },
  Uh = (e, o, t, r) => {
    if (!o.selectedLinearElement) return;
    e.save(), e.translate(o.scrollX, o.scrollY), (e.lineWidth = 1 / o.zoom.value);
    let n = Er.getPointsGlobalCoordinates(t, r),
      { POINT_HANDLE_SIZE: i } = Er,
      a = o.editingLinearElement ? i : i / 2,
      l = $a(t),
      s = R_(t);
    if (
      (n.forEach((d, m) => {
        if (l && m !== 0 && m !== n.length - 1) return;
        let c =
            m > 0 &&
            (m !== n.length - 1 || !s || !t.polygon) &&
            S_(d, m === n.length - 1 ? n[0] : n[m - 1], 2 / o.zoom.value),
          p = !!o.editingLinearElement?.selectedPointsIndices?.includes(m);
        s &&
          t.polygon &&
          !p &&
          m === t.points.length - 1 &&
          o.editingLinearElement?.selectedPointsIndices?.includes(0) &&
          (p = !0),
          Gh(e, o, d, a, p, !1, c);
      }),
      $a(t))
    ) {
      let d = t.fixedSegments?.map((m) => m.index) || [];
      n.slice(0, -1).forEach((m, c) => {
        Er.isSegmentTooShort(t, n[c + 1], n[c], c, o.zoom) ||
          Gh(
            e,
            o,
            C_((m[0] + n[c + 1][0]) / 2, (m[1] + n[c + 1][1]) / 2),
            i / 2,
            !1,
            !d.includes(c + 1),
            !1
          );
      });
    } else
      Er.getEditorMidPoints(t, r, o)
        .filter((m, c, p) => m !== null && !($a(t) && (c === 0 || c === p.length - 1)))
        .forEach((m) => {
          (o.editingLinearElement || n.length === 2) && Gh(e, o, m, i / 2, !1, !0, !1);
        });
    e.restore();
  },
  Zw = (e, o, t, r, n) => {
    Object.keys(r).forEach((i) => {
      let a = r[i];
      if (a !== void 0) {
        let [l, s, d, m] = a;
        e.save(),
          (e.lineWidth = 1 / t.zoom.value),
          o.selectionColor && (e.strokeStyle = o.selectionColor),
          i === "rotation"
            ? Xi(e, l + d / 2, s + m / 2, d / 2, !0)
            : e.roundRect
            ? (e.beginPath(), e.roundRect(l, s, d, m, 2 / t.zoom.value), e.fill(), e.stroke())
            : Ki(e, l, s, d, m, l + d / 2, s + m / 2, n, !0),
          e.restore();
      }
    });
  },
  V_ = (e, o, t, r, n) => {
    let [i, a, , , l, s] = ja(r, n),
      d = 3,
      m = 20,
      c = d / t.zoom.value,
      p = c / 2,
      u = l - i + c,
      f = s - a + c,
      b = Math.min(m / t.zoom.value, u),
      x = Math.min(m / t.zoom.value, f);
    e.save(),
      (e.fillStyle = o.selectionColor),
      (e.strokeStyle = o.selectionColor),
      (e.lineWidth = c),
      [
        [
          [-u, -f],
          [0, p],
          [b, p],
          [p, 0],
          [p, x],
        ],
        [
          [u - p, -f],
          [p, p],
          [-b + p, p],
          [0, 0],
          [0, x],
        ],
        [
          [-u, f],
          [0, -p],
          [b, -p],
          [p, 0],
          [p, -x],
        ],
        [
          [u - p, f],
          [p, -p],
          [-b + p, -p],
          [0, 0],
          [0, -x],
        ],
      ].forEach((E) => {
        let [[y, v], [C, S], [M, k], [A, P], [N, O]] = E;
        e.save(),
          e.translate(l, s),
          e.rotate(r.angle),
          e.beginPath(),
          e.moveTo(y + C, v + S),
          e.lineTo(y + M, v + k),
          e.stroke(),
          e.beginPath(),
          e.moveTo(y + A, v + P),
          e.lineTo(y + N, v + O),
          e.stroke(),
          e.restore();
      }),
      e.restore();
  },
  X_ = (e, o, t, r) => {
    o.save();
    let n = (Vh * 2) / t.zoom.value,
      i = e.width + n * 2,
      a = e.height + n * 2,
      l = e.x + i / 2,
      s = e.y + a / 2,
      d = -(i / 2 + n),
      m = -(a / 2 + n);
    o.translate(l + t.scrollX, s + t.scrollY),
      o.rotate(e.angle),
      (o.lineWidth = 1 / t.zoom.value),
      (o.strokeStyle = r),
      o.strokeRect(d, m, i, a),
      o.restore();
  },
  Jw = ({
    canvas: e,
    elementsMap: o,
    visibleElements: t,
    selectedElements: r,
    allElementsMap: n,
    scale: i,
    appState: a,
    renderConfig: l,
    device: s,
  }) => {
    if (e === null) return { atLeastOneVisibleElement: !1, elementsMap: o };
    let [d, m] = Dl(e, i),
      c = _l({ canvas: e, scale: i, normalizedWidth: d, normalizedHeight: m });
    c.save(), c.scale(a.zoom.value, a.zoom.value);
    let p;
    if (
      (t.forEach((b) => {
        a.editingLinearElement?.elementId === b.id && b && (p = b);
      }),
      p && Uh(c, a, p, o),
      a.selectionElement && !a.isCropping)
    )
      try {
        N_(a.selectionElement, c, a, l.selectionColor);
      } catch (b) {
        console.error(b);
      }
    if (a.editingTextElement && Xw(a.editingTextElement)) {
      let b = n.get(a.editingTextElement.id);
      b && !b.autoResize && X_(b, c, a, l.selectionColor);
    }
    if (
      (a.isBindingEnabled &&
        a.suggestedBindings
          .filter((b) => b != null)
          .forEach((b) => {
            Y_(c, a, b, o);
          }),
      a.frameToHighlight && W_(c, a, a.frameToHighlight, o),
      a.elementsToHighlight && Kw(c, a, a.elementsToHighlight),
      a.activeLockedId)
    ) {
      let b = n.get(a.activeLockedId),
        x = b ? [b] : Yh(n, a.activeLockedId);
      Kw(c, a, x, { colors: ["#ced4da"], dashed: !0 });
    }
    let u = r.some((b) => Ww(b));
    if (
      (r.length === 1 && a.editingLinearElement?.elementId === r[0].id && Uh(c, a, r[0], o),
      a.selectedLinearElement)
    ) {
      let b = a.selectedLinearElement,
        x = r.find((w) => w.id === b.elementId);
      b.segmentMidPointHoveredCoords
        ? z_(c, a)
        : ($a(x)
            ? b.hoverPointIndex === 0 || b.hoverPointIndex === x.points.length - 1
            : b.hoverPointIndex >= 0) && H_(c, a, o);
    }
    if (!a.multiElement && !a.editingLinearElement) {
      let b = D_(r, a),
        x = r.length === 1 && __(r[0]);
      x && a.selectedLinearElement?.elementId === r[0].id && !r[0].locked && Uh(c, a, r[0], o);
      let w = l.selectionColor || ed.black;
      if (b) {
        let E = k_(r),
          y = [];
        for (let C of o.values()) {
          let S = [],
            M = l.remoteSelectedElementIds.get(C.id);
          if (
            ((x && $a(C) && (C.startBinding || C.endBinding)) ||
              (E.has(C.id) && !F_(a, C) && S.push(w),
              M && S.push(...M.map((k) => Qr(k, a.collaborators.get(k))))),
            S.length)
          ) {
            let [k, A, P, N, O, U] = ja(C, o, !0);
            y.push({
              angle: C.angle,
              x1: k,
              y1: A,
              x2: P,
              y2: N,
              selectionColors: C.locked ? ["#ced4da"] : S,
              dashed: !!M || C.locked,
              cx: O,
              cy: U,
              activeEmbeddable:
                a.activeEmbeddable?.element === C && a.activeEmbeddable.state === "active",
              padding: C.id === a.croppingElementId || Vw(C) ? 0 : void 0,
            });
          }
        }
        let v = (C) => {
          let S = Yh(o, C),
            [M, k, A, P] = Wh(S);
          y.push({
            angle: 0,
            x1: M,
            x2: A,
            y1: k,
            y2: P,
            selectionColors: S.some((N) => N.locked) ? ["#ced4da"] : [ed.black],
            dashed: !0,
            cx: M + (A - M) / 2,
            cy: k + (P - k) / 2,
            activeEmbeddable: !1,
          });
        };
        for (let C of B_(a)) v(C);
        a.editingGroupId && v(a.editingGroupId), y.forEach((C) => qw(c, a, C));
      }
      if ((c.save(), c.translate(a.scrollX, a.scrollY), r.length === 1)) {
        c.fillStyle = ed.white;
        let E = P_(r[0], a.zoom, o, "mouse", Hh(s));
        if (
          (!a.viewModeEnabled &&
            b &&
            !Xw(a.editingTextElement) &&
            !a.croppingElementId &&
            Zw(c, l, a, E, r[0].angle),
          a.croppingElementId && !a.isCropping)
        ) {
          let y = o.get(a.croppingElementId);
          y && Vw(y) && V_(c, l, a, y, o);
        }
      } else if (r.length > 1 && !a.isRotating && !r.some((E) => E.locked)) {
        let E = (Vh * 2) / a.zoom.value;
        c.fillStyle = ed.white;
        let [y, v, C, S] = Wh(r, o),
          M = c.getLineDash();
        c.setLineDash([2 / a.zoom.value]);
        let k = c.lineWidth;
        (c.lineWidth = 1 / a.zoom.value),
          (c.strokeStyle = w),
          Ki(c, y - E, v - E, C - y + E * 2, S - v + E * 2, (y + C) / 2, (v + S) / 2, 0),
          (c.lineWidth = k),
          c.setLineDash(M);
        let A = A_(
          [y, v, C, S, (y + C) / 2, (v + S) / 2],
          0,
          a.zoom,
          "mouse",
          u ? { ...Hh(s), rotation: !0 } : Hh(s)
        );
        r.some((P) => !P.locked) && Zw(c, l, a, A, 0);
      }
      c.restore();
    }
    a.searchMatches?.matches.forEach(({ id: b, focus: x, matchedLines: w }) => {
      let E = o.get(b);
      if (E) {
        let [y, v, , , C, S] = ja(E, o, !0);
        c.save(),
          a.theme === M_.LIGHT
            ? x
              ? (c.fillStyle = "rgba(255, 124, 0, 0.4)")
              : (c.fillStyle = "rgba(255, 226, 0, 0.4)")
            : x
            ? (c.fillStyle = "rgba(229, 82, 0, 0.4)")
            : (c.fillStyle = "rgba(99, 52, 0, 0.4)");
        let M = Ww(E) ? a.zoom.value : 1;
        c.translate(a.scrollX, a.scrollY),
          c.translate(C, S),
          c.rotate(E.angle),
          w.forEach((k) => {
            (k.showOnCanvas || x) &&
              c.fillRect(y + k.offsetX / M - C, v + k.offsetY / M - S, k.width / M, k.height / M);
          }),
          c.restore();
      }
    }),
      Ow(c, a),
      c.restore(),
      lE({ context: c, renderConfig: l, appState: a, normalizedWidth: d, normalizedHeight: m });
    let f;
    return (
      l.renderScrollbars &&
        ((f = Gw(o, d, m, a)),
        c.save(),
        (c.fillStyle = Hw),
        (c.strokeStyle = "rgba(255,255,255,0.8)"),
        [f.horizontal, f.vertical].forEach((b) => {
          b && Js(c, b.x, b.y, b.width, b.height, It / 2);
        }),
        c.restore()),
      { scrollBars: f, atLeastOneVisibleElement: t.length > 0, elementsMap: o }
    );
  },
  Xh = L_(
    (e) => {
      let o = Jw(e);
      e.callback?.(o);
    },
    { trailing: !0 }
  ),
  Qw = (e, o) => {
    if (o) {
      Xh(e);
      return;
    }
    let t = Jw(e);
    return e.callback(t), t;
  };
var qa = class {
  constructor(o) {
    I(this, "scene");
    I(
      this,
      "getRenderableElements",
      (() => {
        let o = ({
            elementsMap: r,
            zoom: n,
            offsetLeft: i,
            offsetTop: a,
            scrollX: l,
            scrollY: s,
            height: d,
            width: m,
          }) => {
            let c = [];
            for (let p of r.values())
              K_(p, m, d, { zoom: n, offsetLeft: i, offsetTop: a, scrollX: l, scrollY: s }, r) &&
                c.push(p);
            return c;
          },
          t = ({ elements: r, editingTextElement: n, newElementId: i }) => {
            let a = $_(new Map());
            for (let l of r)
              i !== l.id && (!n || n.type !== "text" || l.id !== n.id) && a.set(l.id, l);
            return a;
          };
        return Z_(
          ({
            zoom: r,
            offsetLeft: n,
            offsetTop: i,
            scrollX: a,
            scrollY: l,
            height: s,
            width: d,
            editingTextElement: m,
            newElementId: c,
            sceneNonce: p,
          }) => {
            let u = this.scene.getNonDeletedElements(),
              f = t({ elements: u, editingTextElement: m, newElementId: c }),
              b = o({
                elementsMap: f,
                zoom: r,
                offsetLeft: n,
                offsetTop: i,
                scrollX: a,
                scrollY: l,
                height: s,
                width: d,
              });
            return { elementsMap: f, visibleElements: b };
          }
        );
      })()
    );
    this.scene = o;
  }
  destroy() {
    Xh.cancel(), n1.cancel(), this.getRenderableElements.clear();
  }
};
import { sceneCoordsToViewportCoords as j_ } from "@excalidraw/common";
import { getElementAbsoluteCoords as q_ } from "@excalidraw/element";
import { jsx as eR } from "react/jsx-runtime";
var J_ = 5,
  Q_ = (e, o, t) => {
    let [r, n] = q_(e, t),
      { x: i, y: a } = j_({ sceneX: r + e.width, sceneY: n }, o),
      l = i - o.offsetLeft + 10,
      s = a - o.offsetTop;
    return { x: l, y: s };
  },
  Kh = ({ children: e, element: o, elementsMap: t }) => {
    let r = zt();
    if (
      r.contextMenu ||
      r.newElement ||
      r.resizingElement ||
      r.isRotating ||
      r.openMenu ||
      r.viewModeEnabled
    )
      return null;
    let { x: n, y: i } = Q_(o, r, t);
    return eR("div", {
      className: "excalidraw-canvas-buttons",
      style: { top: `${i}px`, left: `${n}px`, padding: J_ },
      children: e,
    });
  };
import { DEFAULT_LASER_COLOR as nR, easeOut as tv } from "@excalidraw/common";
import { LaserPointer as tR } from "@excalidraw/laser-pointer";
import {
  SVG_NS as ev,
  getSvgPathFromStroke as oR,
  sceneCoordsToViewportCoords as rR,
} from "@excalidraw/common";
var Yo = class {
  constructor(o, t, r) {
    this.animationFrameHandler = o;
    this.app = t;
    this.options = r;
    I(this, "currentTrail");
    I(this, "pastTrails", []);
    I(this, "container");
    I(this, "trailElement");
    I(this, "trailAnimation");
    this.animationFrameHandler.register(this, this.onFrame.bind(this)),
      (this.trailElement = document.createElementNS(ev, "path")),
      this.options.animateTrail &&
        ((this.trailAnimation = document.createElementNS(ev, "animate")),
        this.trailAnimation.setAttribute("attributeName", "stroke-dashoffset"),
        this.trailElement.setAttribute("stroke-dasharray", "7 7"),
        this.trailElement.setAttribute("stroke-dashoffset", "10"),
        this.trailAnimation.setAttribute("from", "0"),
        this.trailAnimation.setAttribute("to", "-14"),
        this.trailAnimation.setAttribute("dur", "0.3s"),
        this.trailElement.appendChild(this.trailAnimation));
  }
  get hasCurrentTrail() {
    return !!this.currentTrail;
  }
  hasLastPoint(o, t) {
    if (this.currentTrail) {
      let r = this.currentTrail.originalPoints.length;
      return (
        this.currentTrail.originalPoints[r - 1][0] === o &&
        this.currentTrail.originalPoints[r - 1][1] === t
      );
    }
    return !1;
  }
  start(o) {
    o && (this.container = o),
      this.trailElement.parentNode !== this.container &&
        this.container &&
        this.container.appendChild(this.trailElement),
      this.animationFrameHandler.start(this);
  }
  stop() {
    this.animationFrameHandler.stop(this),
      this.trailElement.parentNode === this.container &&
        this.container?.removeChild(this.trailElement);
  }
  startPath(o, t) {
    (this.currentTrail = new tR(this.options)),
      this.currentTrail.addPoint([o, t, performance.now()]),
      this.update();
  }
  addPointToPath(o, t) {
    this.currentTrail && (this.currentTrail.addPoint([o, t, performance.now()]), this.update());
  }
  endPath() {
    this.currentTrail &&
      (this.currentTrail.close(),
      (this.currentTrail.options.keepHead = !1),
      this.pastTrails.push(this.currentTrail),
      (this.currentTrail = void 0),
      this.update());
  }
  getCurrentTrail() {
    return this.currentTrail;
  }
  clearTrails() {
    (this.pastTrails = []), (this.currentTrail = void 0), this.update();
  }
  update() {
    this.start(),
      this.trailAnimation &&
        (this.trailAnimation.setAttribute("begin", "indefinite"),
        this.trailAnimation.setAttribute("repeatCount", "indefinite"));
  }
  onFrame() {
    let o = [];
    for (let r of this.pastTrails) o.push(this.drawTrail(r, this.app.state));
    if (this.currentTrail) {
      let r = this.drawTrail(this.currentTrail, this.app.state);
      o.push(r);
    }
    (this.pastTrails = this.pastTrails.filter((r) => r.getStrokeOutline().length !== 0)),
      o.length === 0 && this.stop();
    let t = o.join(" ").trim();
    this.trailElement.setAttribute("d", t),
      this.trailAnimation
        ? (this.trailElement.setAttribute("fill", (this.options.fill ?? (() => "black"))(this)),
          this.trailElement.setAttribute("stroke", (this.options.stroke ?? (() => "black"))(this)))
        : this.trailElement.setAttribute("fill", (this.options.fill ?? (() => "black"))(this));
  }
  drawTrail(o, t) {
    let r = o.getStrokeOutline(o.options.size / t.zoom.value).map(([i, a]) => {
        let l = rR({ sceneX: i, sceneY: a }, t);
        return [l.x, l.y];
      }),
      n = this.trailAnimation ? r.slice(0, r.length / 2) : r;
    return oR(n, !0);
  }
};
var td = class {
  constructor(o, t) {
    this.animationFrameHandler = o;
    this.app = t;
    I(this, "localTrail");
    I(this, "collabTrails", new Map());
    I(this, "container");
    this.animationFrameHandler.register(this, this.onFrame.bind(this)),
      (this.localTrail = new Yo(o, t, { ...this.getTrailOptions(), fill: () => nR }));
  }
  getTrailOptions() {
    return {
      simplify: 0,
      streamline: 0.4,
      sizeMapping: (o) => {
        let n = Math.max(0, 1 - (performance.now() - o.pressure) / 1e3),
          i = (50 - Math.min(50, o.totalLength - o.currentIndex)) / 50;
        return Math.min(tv(i), tv(n));
      },
    };
  }
  startPath(o, t) {
    this.localTrail.startPath(o, t);
  }
  addPointToPath(o, t) {
    this.localTrail.addPointToPath(o, t);
  }
  endPath() {
    this.localTrail.endPath();
  }
  start(o) {
    (this.container = o), this.animationFrameHandler.start(this), this.localTrail.start(o);
  }
  stop() {
    this.animationFrameHandler.stop(this), this.localTrail.stop();
  }
  onFrame() {
    this.updateCollabTrails();
  }
  updateCollabTrails() {
    if (!(!this.container || this.app.state.collaborators.size === 0)) {
      for (let [o, t] of this.app.state.collaborators.entries()) {
        let r;
        this.collabTrails.has(o)
          ? (r = this.collabTrails.get(o))
          : ((r = new Yo(this.animationFrameHandler, this.app, {
              ...this.getTrailOptions(),
              fill: () => t.pointer?.laserColor || Qr(o, t),
            })),
            r.start(this.container),
            this.collabTrails.set(o, r)),
          t.pointer &&
            t.pointer.tool === "laser" &&
            (t.button === "down" && !r.hasCurrentTrail && r.startPath(t.pointer.x, t.pointer.y),
            t.button === "down" &&
              r.hasCurrentTrail &&
              !r.hasLastPoint(t.pointer.x, t.pointer.y) &&
              r.addPointToPath(t.pointer.x, t.pointer.y),
            t.button === "up" &&
              r.hasCurrentTrail &&
              (r.addPointToPath(t.pointer.x, t.pointer.y), r.endPath()));
      }
      for (let o of this.collabTrails.keys())
        this.app.state.collaborators.has(o) ||
          (this.collabTrails.get(o).stop(), this.collabTrails.delete(o));
    }
  }
};
import { version as iR } from "react";
import { unstable_batchedUpdates as ov } from "react-dom";
import { throttleRAF as aR } from "@excalidraw/common";
var Pe = (e) => (o) => {
    ov(e, o);
  },
  od = (e) =>
    aR((o) => {
      ov(e, o);
    }),
  ki = (() => {
    let e;
    try {
      let t = iR.split(".");
      e = Number(t[0]) > 17;
    } catch {
      e = !1;
    }
    let o = !1;
    return () =>
      window.EXCALIDRAW_THROTTLE_RENDER === !0
        ? e
          ? !0
          : (o ||
              ((o = !0),
              console.warn("Excalidraw: render throttling is disabled on React versions < 18.")),
            !1)
        : !1;
  })();
import {
  CODES as Zh,
  KEYS as Ja,
  CLASSES as rv,
  POINTER_BUTTON as lR,
  isWritableElement as sR,
  getFontString as nv,
  getFontFamilyString as iv,
  isTestEnv as av,
} from "@excalidraw/common";
import {
  originalContainerCache as cR,
  updateOriginalContainerCache as lv,
} from "@excalidraw/element";
import { LinearElementEditor as dR } from "@excalidraw/element";
import { bumpVersion as mR } from "@excalidraw/element";
import {
  getBoundTextElementId as pR,
  getContainerElement as $h,
  getTextElementAngle as uR,
  redrawTextBoundingBox as hR,
  getBoundTextMaxHeight as gR,
  getBoundTextMaxWidth as sv,
  computeContainerDimensionForBoundText as cv,
  computeBoundTextPosition as fR,
  getBoundTextElement as bR,
} from "@excalidraw/element";
import { getTextWidth as xR } from "@excalidraw/element";
import { normalizeText as dv } from "@excalidraw/element";
import { wrapText as ER } from "@excalidraw/element";
import {
  isArrowElement as rd,
  isBoundToContainer as yR,
  isTextElement as mv,
} from "@excalidraw/element";
var wR = (e, o, t, r, n, i) => {
    let { zoom: a } = r,
      l = (180 * t) / Math.PI,
      s = (e * (a.value - 1)) / 2,
      d = (o * (a.value - 1)) / 2;
    return (
      e > n && a.value !== 1 && (s = (n * (a.value - 1)) / 2),
      o > i && a.value !== 1 && (d = (i * (a.value - 1)) / 2),
      `translate(${s}px, ${d}px) scale(${a.value}) rotate(${l}deg)`
    );
  },
  pv = ({
    id: e,
    onChange: o,
    onSubmit: t,
    getViewportCoords: r,
    element: n,
    canvas: i,
    excalidrawContainer: a,
    app: l,
    autoSelect: s = !0,
  }) => {
    let d = (_, R) => {
        if (!R.style.fontFamily || !R.style.fontSize) return !1;
        let X = R.style.fontFamily.replace(/"/g, "");
        return iv({ fontFamily: _.fontFamily }) !== X || `${_.fontSize}px` !== R.style.fontSize;
      },
      m = () => {
        let _ = l.state,
          R = l.scene.getElement(e);
        if (!R) return;
        let { textAlign: X, verticalAlign: $ } = R,
          W = l.scene.getNonDeletedElementsMap();
        if (R && mv(R)) {
          let ce = R.x,
            he = R.y,
            de = $h(R, l.scene.getNonDeletedElementsMap()),
            it = R.width,
            ho = R.height,
            gn = R.width,
            fn = R.height;
          if (de && R.containerId) {
            if (rd(de)) {
              let $o = dR.getBoundTextElementPosition(de, R, W);
              (ce = $o.x), (he = $o.y);
            }
            let kl = d(R, c),
              Wi;
            if (
              (kl
                ? (Wi = lv(de.id, de.height))
                : ((Wi = cR[de.id]), Wi || (Wi = lv(de.id, de.height))),
              (gn = sv(de, R)),
              (fn = gR(de, R)),
              !rd(de) && ho > fn)
            ) {
              let $o = cv(ho, de.type);
              l.scene.mutateElement(de, { height: $o });
              return;
            } else if (!rd(de) && de.height > Wi.height && ho < fn) {
              let $o = cv(ho, de.type);
              l.scene.mutateElement(de, { height: $o });
            } else {
              let { y: $o } = fR(de, R, W);
              he = $o;
            }
          }
          let [Sl, im] = r(ce, he),
            jI = c.selectionStart,
            am = c.selectionEnd,
            Yf = c.value.length;
          if (jI === am && am !== Yf) {
            let kl = Yf - am;
            (c.selectionStart = c.value.length - kl), (c.selectionEnd = c.value.length - kl);
          }
          de ? (it += 0.5) : ((gn = (_.width - 8 - Sl) / _.zoom.value), (it = Math.min(it, gn))),
            (ho *= 1.05);
          let qI = nv(R),
            Wf = (_.height - im) / _.zoom.value;
          Object.assign(c.style, {
            font: qI,
            lineHeight: R.lineHeight,
            width: `${it}px`,
            height: `${ho}px`,
            left: `${Sl}px`,
            top: `${im}px`,
            transform: wR(it, ho, uR(R, de), _, gn, Wf),
            textAlign: X,
            verticalAlign: $,
            color: R.strokeColor,
            opacity: R.opacity / 100,
            filter: "var(--theme-filter)",
            maxHeight: `${Wf}px`,
          }),
            (c.scrollTop = 0),
            av() && (c.style.fontFamily = iv(R)),
            l.scene.mutateElement(R, { x: ce, y: he });
        }
      },
      c = document.createElement("textarea");
    (c.dir = "auto"),
      (c.tabIndex = 0),
      (c.dataset.type = "wysiwyg"),
      (c.wrap = "off"),
      c.classList.add("excalidraw-wysiwyg");
    let p = "pre",
      u = "normal";
    (yR(n) || !n.autoResize) && ((p = "pre-wrap"), (u = "break-word")),
      Object.assign(c.style, {
        position: "absolute",
        display: "inline-block",
        minHeight: "1em",
        backfaceVisibility: "hidden",
        margin: 0,
        padding: 0,
        border: 0,
        outline: 0,
        resize: "none",
        background: "transparent",
        overflow: "hidden",
        zIndex: "var(--zIndex-wysiwyg)",
        wordBreak: u,
        whiteSpace: p,
        overflowWrap: "break-word",
        boxSizing: "content-box",
      }),
      (c.value = n.originalText),
      m(),
      o &&
        ((c.onpaste = async (_) => {
          let R = await Vs(_, !0);
          if (!R.text) return;
          let X = dv(R.text);
          if (!X) return;
          let $ = $h(n, l.scene.getNonDeletedElementsMap()),
            W = nv({
              fontSize: l.state.currentItemFontSize,
              fontFamily: l.state.currentItemFontFamily,
            });
          if ($) {
            let ce = bR($, l.scene.getNonDeletedElementsMap()),
              he = ER(`${c.value}${X}`, W, sv($, ce)),
              de = xR(he, W);
            c.style.width = `${de}px`;
          }
        }),
        (c.oninput = () => {
          let _ = dv(c.value);
          if (c.value !== _) {
            let R = c.selectionStart;
            (c.value = _), (c.selectionStart = R), (c.selectionEnd = R);
          }
          o(c.value);
        })),
      (c.onkeydown = (_) => {
        if (!_.shiftKey && Rs.keyTest(_))
          _.preventDefault(), l.actionManager.executeAction(Rs), m();
        else if (!_.shiftKey && Ns.keyTest(_))
          _.preventDefault(), l.actionManager.executeAction(Ns), m();
        else if (!_.shiftKey && Bs.keyTest(_))
          _.preventDefault(), l.actionManager.executeAction(Bs), m();
        else if (Lp.keyTest(_)) l.actionManager.executeAction(Lp);
        else if (Pp.keyTest(_)) l.actionManager.executeAction(Pp);
        else if (_.key === Ja.ESCAPE) _.preventDefault(), (C = !0), S();
        else if (qr.keyTest(_)) _.preventDefault(), S(), l.actionManager.executeAction(qr);
        else if (_.key === Ja.ENTER && _[Ja.CTRL_OR_CMD]) {
          if ((_.preventDefault(), _.isComposing || _.keyCode === 229)) return;
          (C = !0), S();
        } else if (
          _.key === Ja.TAB ||
          (_[Ja.CTRL_OR_CMD] && (_.code === Zh.BRACKET_LEFT || _.code === Zh.BRACKET_RIGHT))
        ) {
          if ((_.preventDefault(), _.isComposing)) return;
          _.shiftKey || _.code === Zh.BRACKET_LEFT ? E() : w(), c.dispatchEvent(new Event("input"));
        }
      });
    let f = 4,
      b = " ".repeat(f),
      x = new RegExp(`^ {1,${f}}`),
      w = () => {
        let { selectionStart: _, selectionEnd: R } = c,
          X = y(),
          $ = c.value;
        X.forEach((W) => {
          let ce = $.slice(0, W),
            he = $.slice(W);
          $ = `${ce}${b}${he}`;
        }),
          (c.value = $),
          (c.selectionStart = _ + f),
          (c.selectionEnd = R + f * X.length);
      },
      E = () => {
        let { selectionStart: _, selectionEnd: R } = c,
          X = y(),
          $ = [],
          W = c.value;
        X.forEach((ce) => {
          let he = W.slice(ce, ce + f).match(x);
          if (he) {
            let de = W.slice(0, ce),
              it = W.slice(ce + he[0].length);
            (W = `${de}${it}`), $.push(ce);
          }
        }),
          (c.value = W),
          $.length &&
            (_ > $[$.length - 1]
              ? (c.selectionStart = Math.max(_ - f, $[$.length - 1]))
              : (c.selectionStart = _),
            (c.selectionEnd = Math.max(c.selectionStart, R - f * $.length)));
      },
      y = () => {
        let { selectionStart: _, selectionEnd: R, value: X } = c,
          $ = X.slice(0, _).match(/[^\n]*$/)[0].length;
        return (
          (_ = _ - $),
          X.slice(_, R)
            .split(
              `
`
            )
            .reduce((ce, he, de, it) => ce.concat(de ? ce[de - 1] + it[de - 1].length + 1 : _), [])
            .reverse()
        );
      },
      v = (_) => {
        _.target instanceof HTMLCanvasElement && (_.preventDefault(), _.stopPropagation());
      },
      C = !1,
      S = () => {
        if (U) return;
        (U = !0), M();
        let _ = l.scene.getElement(n.id);
        if (!_) return;
        let R = $h(_, l.scene.getNonDeletedElementsMap());
        if (R) {
          if (c.value.trim()) {
            let X = pR(R);
            !X || X !== n.id
              ? l.scene.mutateElement(R, {
                  boundElements: (R.boundElements || []).concat({ type: "text", id: n.id }),
                })
              : rd(R) && mR(R);
          } else
            l.scene.mutateElement(R, { boundElements: R.boundElements?.filter((X) => !mv(X)) });
          hR(_, R, l.scene);
        }
        t({ viaKeyboard: C, nextOriginalText: c.value });
      },
      M = () => {
        (c.onblur = null),
          (c.oninput = null),
          (c.onkeydown = null),
          J && J.disconnect(),
          window.removeEventListener("resize", m),
          window.removeEventListener("wheel", v, !0),
          window.removeEventListener("pointerdown", P),
          window.removeEventListener("pointerup", k),
          window.removeEventListener("blur", S),
          window.removeEventListener("beforeunload", S),
          N(),
          O(),
          c.remove();
      },
      k = (_) => {
        window.removeEventListener("pointerup", k);
        let R = _?.target,
          X = R instanceof HTMLElement && R.classList.contains("properties-trigger");
        setTimeout(() => {
          (c.onblur = S), X || c.focus();
        });
      },
      A = () => {
        (c.onblur = null),
          window.addEventListener("pointerup", k),
          window.addEventListener("blur", S);
      },
      P = (_) => {
        let R = _?.target;
        if (_.button === lR.WHEEL) {
          R instanceof HTMLTextAreaElement &&
            (_.preventDefault(), l.handleCanvasPanUsingWheelOrSpaceDrag(_)),
            A();
          return;
        }
        let X = R instanceof HTMLElement && R.classList.contains("properties-trigger");
        ((_.target instanceof HTMLElement || _.target instanceof SVGElement) &&
          _.target.closest(`.${rv.SHAPE_ACTIONS_MENU}, .${rv.ZOOM_ACTIONS}`) &&
          !sR(_.target)) ||
        X
          ? A()
          : _.target instanceof HTMLCanvasElement &&
            !av() &&
            requestAnimationFrame(() => {
              S();
            });
      },
      N = l.scene.onUpdate(() => {
        m(), !!document.activeElement?.closest(".properties-content") || c.focus();
      }),
      O = l.onScrollChangeEmitter.on(() => {
        m();
      }),
      U = !1;
    s && c.select(), k();
    let J = null;
    return (
      i && "ResizeObserver" in window
        ? ((J = new window.ResizeObserver(() => {
            m();
          })),
          J.observe(i))
        : window.addEventListener("resize", m),
      (c.onpointerdown = (_) => _.stopPropagation()),
      requestAnimationFrame(() => {
        window.addEventListener("pointerdown", P, { capture: !0 });
      }),
      window.addEventListener("beforeunload", S),
      a?.querySelector(".excalidraw-textEditorContainer").appendChild(c),
      S
    );
  };
var uv = (e) => {
  let o = [
    "flowchart",
    "graph",
    "sequenceDiagram",
    "classDiagram",
    "stateDiagram",
    "stateDiagram-v2",
    "erDiagram",
    "journey",
    "gantt",
    "pie",
    "quadrantChart",
    "requirementDiagram",
    "gitGraph",
    "C4Context",
    "mindmap",
    "timeline",
    "zenuml",
    "sankey",
    "xychart",
    "block",
  ];
  return new RegExp(
    `^(?:%%{.*?}%%[\\s\\n]*)?\\b(?:${o.map((r) => `\\s*${r}(-beta)?`).join("|")})\\b`
  ).test(e.trim());
};
import { pointFrom as AR } from "@excalidraw/math";
import { getElementLineSegments as DR } from "@excalidraw/element";
import { LinearElementEditor as _R } from "@excalidraw/element";
import {
  isFrameLikeElement as RR,
  isLinearElement as NR,
  isTextElement as BR,
} from "@excalidraw/element";
import { getFrameChildren as FR } from "@excalidraw/element";
import { selectGroupsForSelectedElements as OR } from "@excalidraw/element";
import { getContainerElement as zR } from "@excalidraw/element";
import { arrayToMap as HR, easeOut as bv, isShallowEqual as GR } from "@excalidraw/common";
import { simplify as vR } from "points-on-curve";
import {
  polygonFromPoints as TR,
  lineSegment as hv,
  polygonIncludesPointNonZero as IR,
} from "@excalidraw/math";
import {
  computeBoundTextPosition as CR,
  doBoundsIntersect as SR,
  getBoundTextElement as kR,
  getElementBounds as MR,
  intersectElementWithLineSegment as gv,
} from "@excalidraw/element";
var fv = (e) => {
    let {
        lassoPath: o,
        elements: t,
        elementsMap: r,
        elementsSegments: n,
        intersectedElements: i,
        enclosedElements: a,
        simplifyDistance: l,
      } = e,
      s = o;
    l && (s = vR(o, l));
    let d = t.filter((p) => !p.locked);
    a.clear(), i.clear();
    let m = o.reduce(
      (p, u) => [
        Math.min(p[0], u[0]),
        Math.min(p[1], u[1]),
        Math.max(p[2], u[0]),
        Math.max(p[3], u[1]),
      ],
      [1 / 0, 1 / 0, -1 / 0, -1 / 0]
    );
    for (let p of d) {
      let u = MR(p, r);
      SR(m, u) &&
        !i.has(p.id) &&
        !a.has(p.id) &&
        (LR(s, p, n) ? a.add(p.id) : PR(s, p, r) && i.add(p.id));
    }
    return { selectedElementIds: [...i, ...a] };
  },
  LR = (e, o, t) => {
    let r = TR(e),
      n = t.get(o.id);
    return n ? n.some((i) => i.some((a) => IR(a, r))) : !1;
  },
  PR = (e, o, t) => {
    let r = e
        .slice(1)
        .map((i, a) => hv(e[a], i))
        .concat([hv(e[e.length - 1], e[0])]),
      n = kR(o, t);
    return r.some(
      (i) =>
        gv(o, t, i, 0, !0).length > 0 ||
        (!!n && gv({ ...n, ...CR(o, n, t) }, t, i, 0, !0).length > 0)
    );
  };
var nd = class extends Yo {
  constructor(t, r) {
    super(t, r, {
      animateTrail: !0,
      streamline: 0.4,
      sizeMapping: (n) => {
        let l = Math.max(0, 1 - (performance.now() - n.pressure) / (1 / 0)),
          s = (5e3 - Math.min(5e3, n.totalLength - n.currentIndex)) / 5e3;
        return Math.min(bv(s), bv(l));
      },
      fill: () => "rgba(105,101,219,0.05)",
      stroke: () => "rgba(105,101,219)",
    });
    I(this, "intersectedElements", new Set());
    I(this, "enclosedElements", new Set());
    I(this, "elementsSegments", null);
    I(this, "canvasTranslate", null);
    I(this, "keepPreviousSelection", !1);
    I(this, "selectElementsFromIds", (t) => {
      this.app.setState((r) => {
        let n = t.reduce((s, d) => ((s[d] = !0), s), {});
        if (this.keepPreviousSelection) for (let s of Object.keys(r.selectedElementIds)) n[s] = !0;
        for (let [s] of Object.entries(n)) {
          let d = this.app.scene.getNonDeletedElement(s);
          if (d && BR(d)) {
            let m = zR(d, this.app.scene.getNonDeletedElementsMap());
            m && ((n[m.id] = !0), delete n[d.id]);
          }
        }
        for (let [s] of Object.entries(n)) {
          let d = this.app.scene.getNonDeletedElement(s);
          if (d && RR(d)) {
            let m = FR(this.app.scene.getNonDeletedElementsMap(), d.id);
            for (let c of m) delete n[c.id];
          }
        }
        let i = OR(
            { editingGroupId: r.editingGroupId, selectedElementIds: n },
            this.app.scene.getNonDeletedElements(),
            r,
            this.app
          ),
          a = [...Object.keys(i.selectedElementIds)],
          l = [...Object.keys(i.selectedGroupIds)];
        return {
          selectedElementIds: i.selectedElementIds,
          selectedGroupIds: i.selectedGroupIds,
          selectedLinearElement:
            a.length === 1 && !l.length && NR(this.app.scene.getNonDeletedElement(a[0]))
              ? new _R(
                  this.app.scene.getNonDeletedElement(a[0]),
                  this.app.scene.getNonDeletedElementsMap()
                )
              : null,
        };
      });
    });
    I(this, "addPointToPath", (t, r, n = !1) => {
      super.addPointToPath(t, r), (this.keepPreviousSelection = n), this.updateSelection();
    });
    I(this, "updateSelection", () => {
      let t = super.getCurrentTrail()?.originalPoints?.map((n) => AR(n[0], n[1])),
        r = {
          scrollX: this.app.state.scrollX,
          scrollY: this.app.state.scrollY,
          zoom: this.app.state.zoom.value,
        };
      if (!this.elementsSegments || !GR(r, this.canvasTranslate ?? {})) {
        (this.canvasTranslate = r), (this.elementsSegments = new Map());
        let n = HR(this.app.visibleElements);
        for (let i of this.app.visibleElements) {
          let a = DR(i, n);
          this.elementsSegments.set(i.id, a);
        }
      }
      if (t) {
        let { selectedElementIds: n } = fv({
          lassoPath: t,
          elements: this.app.visibleElements,
          elementsMap: this.app.scene.getNonDeletedElementsMap(),
          elementsSegments: this.elementsSegments,
          intersectedElements: this.intersectedElements,
          enclosedElements: this.enclosedElements,
          simplifyDistance: 5 / this.app.state.zoom.value,
        });
        this.selectElementsFromIds(n);
      }
    });
  }
  startPath(t, r, n = !1) {
    this.endPath(),
      super.startPath(t, r),
      this.intersectedElements.clear(),
      this.enclosedElements.clear(),
      (this.keepPreviousSelection = n),
      this.keepPreviousSelection ||
        this.app.setState({
          selectedElementIds: {},
          selectedGroupIds: {},
          selectedLinearElement: null,
        });
  }
  endPath() {
    super.endPath(),
      super.clearTrails(),
      this.intersectedElements.clear(),
      this.enclosedElements.clear(),
      (this.elementsSegments = null);
  }
};
import { arrayToMap as UR, easeOut as xv, THEME as YR } from "@excalidraw/common";
import {
  computeBoundTextPosition as WR,
  getBoundTextElement as VR,
  intersectElementWithLineSegment as Ev,
  isPointInElement as XR,
} from "@excalidraw/element";
import { lineSegment as KR, pointFrom as ZR } from "@excalidraw/math";
import { getElementsInGroup as yv } from "@excalidraw/element";
import { shouldTestInside as $R } from "@excalidraw/element";
import { hasBoundTextElement as wv, isBoundToContainer as vv } from "@excalidraw/element";
import { getBoundTextElementId as Tv } from "@excalidraw/element";
var id = class extends Yo {
    constructor(t, r) {
      super(t, r, {
        streamline: 0.2,
        size: 5,
        keepHead: !0,
        sizeMapping: (n) => {
          let l = Math.max(0, 1 - (performance.now() - n.pressure) / 200),
            s = (10 - Math.min(10, n.totalLength - n.currentIndex)) / 10;
          return Math.min(xv(s), xv(l));
        },
        fill: () =>
          r.state.theme === YR.LIGHT ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.2)",
      });
      I(this, "elementsToErase", new Set());
      I(this, "groupsToErase", new Set());
    }
    startPath(t, r) {
      this.endPath(), super.startPath(t, r), this.elementsToErase.clear();
    }
    addPointToPath(t, r, n = !1) {
      return super.addPointToPath(t, r), this.updateElementsToBeErased(n);
    }
    updateElementsToBeErased(t) {
      let r = super.getCurrentTrail()?.originalPoints?.map((l) => ZR(l[0], l[1])) || [];
      if (r.length < 2) return [];
      let n = KR(r[r.length - 1], r[r.length - 2]),
        i = this.app.visibleElements.filter((l) => !l.locked),
        a = UR(i);
      for (let l of i)
        if (t && this.elementsToErase.has(l.id)) {
          if (Iv(n, l, a)) {
            let d = l.groupIds.at(-1);
            if (this.groupsToErase.has(d)) {
              let m = yv(this.app.scene.getNonDeletedElementsMap(), d);
              for (let c of m) this.elementsToErase.delete(c.id);
              this.groupsToErase.delete(d);
            }
            if ((vv(l) && this.elementsToErase.delete(l.containerId), wv(l))) {
              let m = Tv(l);
              m && this.elementsToErase.delete(m);
            }
            this.elementsToErase.delete(l.id);
          }
        } else if (!t && !this.elementsToErase.has(l.id) && Iv(n, l, a)) {
          let d = l.groupIds.at(-1);
          if (!this.groupsToErase.has(d)) {
            let m = yv(this.app.scene.getNonDeletedElementsMap(), d);
            for (let c of m) this.elementsToErase.add(c.id);
            this.groupsToErase.add(d);
          }
          if (wv(l)) {
            let m = Tv(l);
            m && this.elementsToErase.add(m);
          }
          vv(l) && this.elementsToErase.add(l.containerId), this.elementsToErase.add(l.id);
        }
      return Array.from(this.elementsToErase);
    }
    endPath() {
      super.endPath(),
        super.clearTrails(),
        this.elementsToErase.clear(),
        this.groupsToErase.clear();
    }
  },
  Iv = (e, o, t) => {
    let r = e[1];
    if ($R(o) && XR(r, o, t)) return !0;
    let n = VR(o, t);
    return (
      Ev(o, t, e, 0, !0).length > 0 || (!!n && Ev({ ...n, ...WR(o, n, t) }, t, e, 0, !0).length > 0)
    );
  };
import { jsx as Xt, jsxs as Cv } from "react/jsx-runtime";
var jR = () =>
    Cv("div", {
      "data-testid": "brave-measure-text-error",
      children: [
        Xt("p", {
          children: Xt(ut, {
            i18nKey: "errors.brave_measure_text_error.line1",
            bold: (e) => Xt("span", { style: { fontWeight: 600 }, children: e }),
          }),
        }),
        Xt("p", {
          children: Xt(ut, {
            i18nKey: "errors.brave_measure_text_error.line2",
            bold: (e) => Xt("span", { style: { fontWeight: 600 }, children: e }),
          }),
        }),
        Xt("p", {
          children: Xt(ut, {
            i18nKey: "errors.brave_measure_text_error.line3",
            link: (e) =>
              Xt("a", {
                href: "http://docs.excalidraw.com/docs/excalidraw-custom/faq#turning-off-aggresive-block-fingerprinting-in-brave-browser",
                children: e,
              }),
          }),
        }),
        Xt("p", {
          children: Xt(ut, {
            i18nKey: "errors.brave_measure_text_error.line4",
            issueLink: (e) =>
              Xt("a", { href: "https://github.com/excalidraw/excalidraw/issues/new", children: e }),
            discordLink: (e) => Cv("a", { href: "https://discord.gg/UexuTaE", children: [e, "."] }),
          }),
        }),
      ],
    }),
  Sv = jR;
import o9 from "clsx";
import r9 from "react";
import { useLayoutEffect as qR, useRef as kv, useEffect as Mv } from "react";
import { unstable_batchedUpdates as JR } from "react-dom";
import { KEYS as QR, queryFocusableElements as e9 } from "@excalidraw/common";
import { jsx as t9 } from "react/jsx-runtime";
var Lv = ({
  children: e,
  left: o,
  top: t,
  onCloseRequest: r,
  fitInViewport: n = !1,
  offsetLeft: i = 0,
  offsetTop: a = 0,
  viewportWidth: l = window.innerWidth,
  viewportHeight: s = window.innerHeight,
}) => {
  let d = kv(null);
  Mv(() => {
    let c = d.current;
    if (!c) return;
    c.contains(document.activeElement) || c.focus();
    let p = (u) => {
      if (u.key === QR.TAB) {
        let f = e9(c),
          { activeElement: b } = document,
          x = f.findIndex((w) => w === b);
        b === c
          ? (u.shiftKey ? f[f.length - 1]?.focus() : f[0].focus(),
            u.preventDefault(),
            u.stopImmediatePropagation())
          : x === 0 && u.shiftKey
          ? (f[f.length - 1]?.focus(), u.preventDefault(), u.stopImmediatePropagation())
          : x === f.length - 1 &&
            !u.shiftKey &&
            (f[0]?.focus(), u.preventDefault(), u.stopImmediatePropagation());
      }
    };
    return c.addEventListener("keydown", p), () => c.removeEventListener("keydown", p);
  }, []);
  let m = kv(null);
  return (
    qR(() => {
      if (n && d.current && t != null && o != null) {
        let c = d.current,
          { width: p, height: u } = c.getBoundingClientRect();
        if (m.current?.top === t && m.current?.left === o) return;
        (m.current = { top: t, left: o }),
          p >= l
            ? ((c.style.width = `${l}px`), (c.style.left = "0px"), (c.style.overflowX = "scroll"))
            : o + p - i > l
            ? (c.style.left = `${l - p - 10}px`)
            : (c.style.left = `${o}px`),
          u >= s
            ? ((c.style.height = `${s - 20}px`),
              (c.style.top = "10px"),
              (c.style.overflowY = "scroll"))
            : t + u - a > s
            ? (c.style.top = `${s - u}px`)
            : (c.style.top = `${t}px`);
      }
    }, [t, o, n, l, s, i, a]),
    Mv(() => {
      if (r) {
        let c = (p) => {
          d.current?.contains(p.target) || JR(() => r(p));
        };
        return (
          document.addEventListener("pointerdown", c, !1),
          () => document.removeEventListener("pointerdown", c, !1)
        );
      }
    }, [r]),
    t9("div", { className: "popover", ref: d, tabIndex: -1, children: e })
  );
};
import { jsx as Mi, jsxs as n9 } from "react/jsx-runtime";
var Ye = "separator",
  Pv = r9.memo(({ actionManager: e, items: o, top: t, left: r, onClose: n }) => {
    let i = zt(),
      a = nr(),
      l = o.reduce(
        (s, d) => (
          d && (d === Ye || !d.predicate || d.predicate(a, i, e.app.props, e.app)) && s.push(d), s
        ),
        []
      );
    return Mi(Lv, {
      onCloseRequest: () => {
        n();
      },
      top: t,
      left: r,
      fitInViewport: !0,
      offsetLeft: i.offsetLeft,
      offsetTop: i.offsetTop,
      viewportWidth: i.width,
      viewportHeight: i.height,
      children: Mi("ul", {
        className: "context-menu",
        onContextMenu: (s) => s.preventDefault(),
        children: l.map((s, d) => {
          if (s === Ye)
            return !l[d - 1] || l[d - 1] === Ye
              ? null
              : Mi("hr", { className: "context-menu-item-separator" }, d);
          let m = s.name,
            c = "";
          return (
            s.label &&
              (typeof s.label == "function" ? (c = g(s.label(a, i, e.app))) : (c = g(s.label))),
            Mi(
              "li",
              {
                "data-testid": m,
                onClick: () => {
                  n(() => {
                    e.executeAction(s, "contextMenu");
                  });
                },
                children: n9("button", {
                  type: "button",
                  className: o9("context-menu-item", {
                    dangerous: m === "deleteSelectedElements",
                    checkmark: s.checked?.(i),
                  }),
                  children: [
                    Mi("div", { className: "context-menu-item__label", children: c }),
                    Mi("kbd", {
                      className: "context-menu-item__shortcut",
                      children: m ? Ne(m) : "",
                    }),
                  ],
                }),
              },
              d
            )
          );
        }),
      }),
    });
  });
import { jsx as jh, jsxs as Av } from "react/jsx-runtime";
var i9 = ({ height: e, width: o, userToFollow: t, onDisconnect: r }) =>
    jh("div", {
      className: "follow-mode",
      style: { width: o, height: e },
      children: Av("div", {
        className: "follow-mode__badge",
        children: [
          Av("div", {
            className: "follow-mode__badge__label",
            children: [
              "Following",
              " ",
              jh("span", {
                className: "follow-mode__badge__username",
                title: t.username,
                children: t.username,
              }),
            ],
          }),
          jh("button", {
            type: "button",
            onClick: r,
            className: "follow-mode__disconnect-btn",
            children: Bt,
          }),
        ],
      }),
    }),
  Dv = i9;
import dl from "clsx";
import IO from "react";
import {
  CLASSES as CO,
  DEFAULT_SIDEBAR as Kg,
  TOOL_TYPE as dT,
  arrayToMap as SO,
  capitalizeString as kO,
  isShallowEqual as Xd,
} from "@excalidraw/common";
import { mutateElement as MO } from "@excalidraw/element";
import { showSelectedShapeActions as LO } from "@excalidraw/element";
import { ShapeCache as PO } from "@excalidraw/element";
import a9 from "clsx";
import { useState as l9, useEffect as s9 } from "react";
import { THEME as c9 } from "@excalidraw/common";
import { jsx as qh, jsxs as d9 } from "react/jsx-runtime";
var ad = ({ delay: e, theme: o }) => {
  let [t, r] = l9(!!e);
  return (
    s9(() => {
      if (!e) return;
      let n = setTimeout(() => {
        r(!1);
      }, e);
      return () => clearTimeout(n);
    }, [e]),
    t
      ? null
      : d9("div", {
          className: a9("LoadingMessage", { "LoadingMessage--dark": o === c9.DARK }),
          children: [
            qh("div", { children: qh(tt, {}) }),
            qh("div", { className: "LoadingMessage-text", children: g("labels.loadingScene") }),
          ],
        })
  );
};
import m9 from "clsx";
import { jsx as Rv, jsxs as u9 } from "react/jsx-runtime";
var p9 = "medium",
  _v = { CHECKED: Cn, UNCHECKED: Hr },
  ld = (e) =>
    u9("label", {
      className: m9("ToolIcon ToolIcon__lock", `ToolIcon_size_${p9}`, { "is-mobile": e.isMobile }),
      title: `${e.title} \u2014 Q`,
      children: [
        Rv("input", {
          className: "ToolIcon_type_checkbox",
          type: "checkbox",
          name: e.name,
          onChange: e.onChange,
          checked: e.checked,
          "aria-label": e.title,
          "data-testid": "toolbar-lock",
        }),
        Rv("div", { className: "ToolIcon__icon", children: e.checked ? _v.CHECKED : _v.UNCHECKED }),
      ],
    });
import { showSelectedShapeActions as A9 } from "@excalidraw/element";
import h9 from "clsx";
import { jsx as g9 } from "react/jsx-runtime";
var sd = ({ children: e, side: o, className: t }) =>
  g9("div", {
    className: h9("FixedSideContainer", `FixedSideContainer_side_${o}`, t),
    children: e,
  });
import f9 from "clsx";
import { KEYS as Nv } from "@excalidraw/common";
import { jsx as b9 } from "react/jsx-runtime";
var cd = (e) =>
  b9(V, {
    className: f9("Shape", { fillable: !1 }),
    type: "radio",
    icon: es,
    name: "editor-current-shape",
    checked: e.checked,
    title: `${e.title} \u2014 H`,
    keyBindingLabel: e.isMobile ? void 0 : Nv.H.toLocaleUpperCase(),
    "aria-label": `${e.title} \u2014 H`,
    "aria-keyshortcuts": Nv.H,
    "data-testid": "toolbar-hand",
    onChange: () => e.onChange?.(),
  });
import { CANVAS_SEARCH_TAB as x9, DEFAULT_SIDEBAR as E9 } from "@excalidraw/common";
import {
  isFlowchartNodeElement as y9,
  isImageElement as Bv,
  isLinearElement as Fv,
  isLineElement as w9,
  isTextBindableContainer as v9,
  isTextElement as T9,
} from "@excalidraw/element";
import { getShortcutKey as Jh } from "@excalidraw/common";
import { isNodeInFlowchart as I9 } from "@excalidraw/element";
import { jsx as Ov } from "react/jsx-runtime";
var C9 = ({ appState: e, isMobile: o, device: t, app: r }) => {
    let { activeTool: n, isResizing: i, isRotating: a, lastPointerDownWith: l } = e,
      s = e.multiElement !== null;
    if (
      e.openSidebar?.name === E9.name &&
      e.openSidebar.tab === x9 &&
      e.searchMatches?.matches.length
    )
      return g("hints.dismissSearch");
    if (e.openSidebar && !t.editor.canFitSidebar) return null;
    if (bt(e)) return g("hints.eraserRevert");
    if (n.type === "arrow" || n.type === "line")
      return s
        ? g("hints.linearElementMulti")
        : n.type === "arrow"
        ? g("hints.arrowTool", { arrowShortcut: Jh("A") })
        : g("hints.linearElement");
    if (n.type === "freedraw") return g("hints.freeDraw");
    if (n.type === "text") return g("hints.text");
    if (n.type === "embeddable") return g("hints.embeddable");
    let d = r.scene.getSelectedElements(e);
    if (i && l === "mouse" && d.length === 1) {
      let m = d[0];
      return Fv(m) && m.points.length === 2
        ? g("hints.lockAngle")
        : Bv(m)
        ? g("hints.resizeImage")
        : g("hints.resize");
    }
    if (a && l === "mouse") return g("hints.rotate");
    if (d.length === 1 && T9(d[0])) return g("hints.text_selected");
    if (e.editingTextElement) return g("hints.text_editing");
    if (e.croppingElementId) return g("hints.leaveCropEditor");
    if (d.length === 1 && Bv(d[0])) return g("hints.enterCropEditor");
    if (n.type === "selection") {
      if (e.selectionElement && !d.length && !e.editingTextElement && !e.editingLinearElement)
        return [g("hints.deepBoxSelect")];
      if (br(r) && e.selectedElementsAreBeingDragged) return g("hints.disableSnapping");
      if (!d.length && !o) return [g("hints.canvasPanning")];
      if (d.length === 1) {
        if (Fv(d[0]))
          return e.editingLinearElement
            ? e.editingLinearElement.selectedPointsIndices
              ? g("hints.lineEditor_pointSelected")
              : g("hints.lineEditor_nothingSelected")
            : w9(d[0])
            ? g("hints.lineEditor_line_info")
            : g("hints.lineEditor_info");
        if (!e.newElement && !e.selectedElementsAreBeingDragged && v9(d[0]))
          return y9(d[0])
            ? I9(d[0], r.scene.getNonDeletedElementsMap())
              ? [g("hints.bindTextToElement"), g("hints.createFlowchart")]
              : [g("hints.bindTextToElement"), g("hints.createFlowchart")]
            : g("hints.bindTextToElement");
      }
    }
    return null;
  },
  dd = ({ appState: e, isMobile: o, device: t, app: r }) => {
    let n = C9({ appState: e, isMobile: o, device: t, app: r });
    if (!n) return null;
    let i = Array.isArray(n) ? n.map((a) => Jh(a).replace(/\. ?$/, "")).join(". ") : Jh(n);
    return Ov("div", { className: "HintViewer", children: Ov("span", { children: i }) });
  };
import S9 from "clsx";
import { jsx as zv, jsxs as M9 } from "react/jsx-runtime";
var k9 = "medium",
  md = (e) =>
    e.penDetected
      ? M9("label", {
          className: S9("ToolIcon ToolIcon__penMode", `ToolIcon_size_${k9}`, {
            "is-mobile": e.isMobile,
          }),
          title: `${e.title}`,
          children: [
            zv("input", {
              className: "ToolIcon_type_checkbox",
              type: "checkbox",
              name: e.name,
              onChange: e.onChange,
              checked: e.checked,
              "aria-label": e.title,
            }),
            zv("div", { className: "ToolIcon__icon", children: _1 }),
          ],
        })
      : null;
import { Fragment as L9, jsx as Hv, jsxs as P9 } from "react/jsx-runtime";
var yr = ({ heading: e, children: o, ...t }) => {
  let { id: r } = Ge(),
    n = Hv("h2", {
      className: "visually-hidden",
      id: `${r}-${e}-title`,
      children: g(`headings.${e}`),
    });
  return Hv("section", {
    ...t,
    "aria-labelledby": `${r}-${e}-title`,
    children: typeof o == "function" ? o(n) : P9(L9, { children: [n, o] }),
  });
};
import { Fragment as D9, jsx as rt, jsxs as Wo } from "react/jsx-runtime";
var Gv = ({
  appState: e,
  elements: o,
  actionManager: t,
  setAppState: r,
  onLockToggle: n,
  onHandToolToggle: i,
  onPenModeToggle: a,
  renderTopRightUI: l,
  renderCustomStats: s,
  renderSidebars: d,
  device: m,
  renderWelcomeScreen: c,
  UIOptions: p,
  app: u,
}) => {
  let { WelcomeScreenCenterTunnel: f, MainMenuTunnel: b, DefaultSidebarTriggerTunnel: x } = Ie(),
    w = () =>
      Wo(sd, {
        side: "top",
        className: "App-top-bar",
        children: [
          c && rt(f.Out, {}),
          rt(yr, {
            heading: "shapes",
            children: (y) =>
              rt(qe.Col, {
                gap: 4,
                align: "center",
                children: Wo(qe.Row, {
                  gap: 1,
                  className: "App-toolbar-container",
                  children: [
                    Wo(Xe, {
                      padding: 1,
                      className: "App-toolbar App-toolbar--mobile",
                      children: [
                        y,
                        rt(qe.Row, {
                          gap: 1,
                          children: rt(Dc, {
                            appState: e,
                            activeTool: e.activeTool,
                            UIOptions: p,
                            app: u,
                          }),
                        }),
                      ],
                    }),
                    l && l(!0, e),
                    Wo("div", {
                      className: "mobile-misc-tools-container",
                      children: [
                        !e.viewModeEnabled &&
                          e.openDialog?.name !== "elementLinkSelector" &&
                          rt(x.Out, {}),
                        rt(md, {
                          checked: e.penMode,
                          onChange: () => a(null),
                          title: g("toolBar.penMode"),
                          isMobile: !0,
                          penDetected: e.penDetected,
                        }),
                        rt(ld, {
                          checked: e.activeTool.locked,
                          onChange: n,
                          title: g("toolBar.lock"),
                          isMobile: !0,
                        }),
                        rt(cd, {
                          checked: qt(e),
                          onChange: () => i(),
                          title: g("toolBar.hand"),
                          isMobile: !0,
                        }),
                      ],
                    }),
                  ],
                }),
              }),
          }),
          rt(dd, { appState: e, isMobile: !0, device: m, app: u }),
        ],
      }),
    E = () =>
      e.viewModeEnabled || e.openDialog?.name === "elementLinkSelector"
        ? rt("div", { className: "App-toolbar-content", children: rt(b.Out, {}) })
        : Wo("div", {
            className: "App-toolbar-content",
            children: [
              rt(b.Out, {}),
              t.renderAction("toggleEditMenu"),
              t.renderAction(e.multiElement ? "finalize" : "duplicateSelection"),
              t.renderAction("deleteSelectedElements"),
              Wo("div", { children: [t.renderAction("undo"), t.renderAction("redo")] }),
            ],
          });
  return Wo(D9, {
    children: [
      d(),
      !e.viewModeEnabled && e.openDialog?.name !== "elementLinkSelector" && w(),
      rt("div", {
        className: "App-bottom-bar",
        style: { marginBottom: It + so * 2, marginLeft: It + so * 2, marginRight: It + so * 2 },
        children: Wo(Xe, {
          padding: 0,
          children: [
            e.openMenu === "shape" &&
            !e.viewModeEnabled &&
            e.openDialog?.name !== "elementLinkSelector" &&
            A9(e, o)
              ? rt(yr, {
                  className: "App-mobile-menu",
                  heading: "selectedShapeActions",
                  children: rt(Ac, {
                    appState: e,
                    elementsMap: u.scene.getNonDeletedElementsMap(),
                    renderAction: t.renderAction,
                    app: u,
                  }),
                })
              : null,
            Wo("footer", {
              className: "App-toolbar",
              children: [
                E(),
                e.scrolledOutside &&
                  !e.openMenu &&
                  !e.openSidebar &&
                  rt("button", {
                    type: "button",
                    className: "scroll-back-to-content",
                    onClick: () => {
                      r((y) => ({ ...zr(o, y) }));
                    },
                    children: g("buttons.scrollBackToContent"),
                  }),
              ],
            }),
          ],
        }),
      }),
    ],
  });
};
import _9 from "open-color";
import R9, { useLayoutEffect as N9, useRef as B9, useState as F9 } from "react";
import { jsx as Qa, jsxs as O9 } from "react/jsx-runtime";
var Uv = (e) => {
    let o = B9(null),
      [t, r] = F9(null);
    return (
      N9(() => {
        if (!e.spreadsheet) return;
        let n = Gx(e.chartType, e.spreadsheet, 0, 0);
        r(n);
        let i,
          a = o.current;
        return (
          (async () => (
            (i = await yn(n, { exportBackground: !1, viewBackgroundColor: _9.white }, null, {
              skipInliningFonts: !0,
            })),
            i.querySelector(".style-fonts")?.remove(),
            a.replaceChildren(),
            a.appendChild(i),
            e.selected && a.parentNode.focus()
          ))(),
          () => {
            a.replaceChildren();
          }
        );
      }, [e.spreadsheet, e.chartType, e.selected]),
      Qa("button", {
        type: "button",
        className: "ChartPreview",
        onClick: () => {
          t && e.onClick(e.chartType, t);
        },
        children: Qa("div", { ref: o }),
      })
    );
  },
  Yv = ({ setAppState: e, appState: o, onClose: t }) => {
    let { onInsertElements: r } = Re(),
      n = R9.useCallback(() => {
        t && t();
      }, [t]),
      i = (a, l) => {
        r(l),
          re("paste", "chart", a),
          e({ currentChartType: a, pasteDialog: { shown: !1, data: null } });
      };
    return Qa(Be, {
      size: "small",
      onCloseRequest: n,
      title: g("labels.pasteCharts"),
      className: "PasteChartDialog",
      autofocus: !1,
      children: O9("div", {
        className: "container",
        children: [
          Qa(Uv, {
            chartType: "bar",
            spreadsheet: o.pasteDialog.data,
            selected: o.currentChartType === "bar",
            onClick: i,
          }),
          Qa(Uv, {
            chartType: "line",
            spreadsheet: o.pasteDialog.data,
            selected: o.currentChartType === "line",
            onClick: i,
          }),
        ],
      }),
    });
  };
import * as wr from "@radix-ui/react-popover";
import Wv from "clsx";
import pd, { useLayoutEffect as z9 } from "react";
import { supportsResizeObserver as H9, isShallowEqual as G9 } from "@excalidraw/common";
import { Fragment as X9, jsx as To, jsxs as ud } from "react/jsx-runtime";
var U9 = 4,
  Y9 = 8,
  W9 = ({ shouldWrap: e, children: o, username: t }) =>
    e ? To(Lt, { label: t || "Unknown user", children: o }) : To(X9, { children: o }),
  Qh = ({
    actionManager: e,
    collaborator: o,
    socketId: t,
    withName: r = !1,
    shouldWrapWithTooltip: n = !1,
    isBeingFollowed: i,
  }) => {
    let a = { socketId: t, collaborator: o, withName: r, isBeingFollowed: i },
      l = e.renderAction("goToCollaborator", a);
    return To(W9, { username: o.username, shouldWrap: n, children: l }, t);
  },
  V9 = ["avatarUrl", "id", "socketId", "username", "isInCall", "isSpeaking", "isMuted"],
  hd = pd.memo(
    ({ className: e, mobile: o, collaborators: t, userToFollow: r }) => {
      let n = Fe(),
        i = new Map();
      t.forEach((b, x) => {
        let w = b.id || x;
        i.set(w, { ...b, socketId: x });
      });
      let a = Array.from(i.values()).filter((b) => b.username?.trim()),
        [l, s] = pd.useState(""),
        d = a.filter((b) => b.username?.toLowerCase().includes(l)),
        m = pd.useRef(null);
      z9(() => {
        if (m.current) {
          let b = (w) => {
            let E = Math.max(1, Math.min(8, Math.floor(w / 38)));
            p(E);
          };
          if ((b(m.current.clientWidth), !H9)) return;
          let x = new ResizeObserver((w) => {
            for (let E of w) {
              let { width: y } = E.contentRect;
              b(y);
            }
          });
          return (
            x.observe(m.current),
            () => {
              x.disconnect();
            }
          );
        }
      }, []);
      let [c, p] = pd.useState(U9),
        f = a
          .slice(0, c - 1)
          .map((b) =>
            Qh({
              actionManager: n,
              collaborator: b,
              socketId: b.socketId,
              shouldWrapWithTooltip: !0,
              isBeingFollowed: b.socketId === r,
            })
          );
      return o
        ? To("div", {
            className: Wv("UserList UserList_mobile", e),
            children: a.map((b) =>
              Qh({
                actionManager: n,
                collaborator: b,
                socketId: b.socketId,
                shouldWrapWithTooltip: !0,
                isBeingFollowed: b.socketId === r,
              })
            ),
          })
        : To("div", {
            className: "UserList__wrapper",
            ref: m,
            children: ud("div", {
              className: Wv("UserList", e),
              style: { "--max-avatars": c },
              children: [
                f,
                a.length > c - 1 &&
                  ud(wr.Root, {
                    children: [
                      ud(wr.Trigger, {
                        className: "UserList__more",
                        children: ["+", a.length - c + 1],
                      }),
                      To(wr.Content, {
                        style: { zIndex: 2, width: "15rem", textAlign: "left" },
                        align: "end",
                        sideOffset: 10,
                        children: ud(Xe, {
                          padding: 2,
                          children: [
                            a.length >= Y9 &&
                              To(Ts, { placeholder: g("quickSearch.placeholder"), onChange: s }),
                            To(Is, {
                              className: "dropdown-menu UserList__collaborators",
                              placeholder: g("userList.empty"),
                              children:
                                d.length > 0
                                  ? [
                                      To("div", {
                                        className: "hint",
                                        children: g("userList.hint.text"),
                                      }),
                                      d.map((b) =>
                                        Qh({
                                          actionManager: n,
                                          collaborator: b,
                                          socketId: b.socketId,
                                          withName: !0,
                                          isBeingFollowed: b.socketId === r,
                                        })
                                      ),
                                    ]
                                  : [],
                            }),
                            To(wr.Arrow, {
                              width: 20,
                              height: 10,
                              style: {
                                fill: "var(--popup-bg-color)",
                                filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)",
                              },
                            }),
                          ],
                        }),
                      }),
                    ],
                  }),
              ],
            }),
          });
    },
    (e, o) => {
      if (
        e.collaborators.size !== o.collaborators.size ||
        e.mobile !== o.mobile ||
        e.className !== o.className ||
        e.userToFollow !== o.userToFollow
      )
        return !1;
      let t = o.collaborators.keys();
      for (let [r, n] of e.collaborators) {
        let i = o.collaborators.get(r);
        if (!i || r !== t.next().value || !G9(n, i, V9)) return !1;
      }
      return !0;
    }
  );
import gd from "clsx";
import { jsx as K9 } from "react/jsx-runtime";
var Vv = (e) =>
  K9("button", {
    className: "help-icon",
    onClick: e.onClick,
    type: "button",
    title: `${g("helpDialog.title")} \u2014 ?`,
    "aria-label": g("helpDialog.title"),
    children: kn,
  });
import { jsx as Io, jsxs as eg } from "react/jsx-runtime";
var Xv = ({ appState: e, actionManager: o, showExitZenModeBtn: t, renderWelcomeScreen: r }) => {
    let { FooterCenterTunnel: n, WelcomeScreenHelpHintTunnel: i } = Ie(),
      a = ae(),
      l = !e.viewModeEnabled && e.multiElement && a.isTouchScreen;
    return eg("footer", {
      role: "contentinfo",
      className: "layer-ui__wrapper__footer App-menu App-menu_bottom",
      children: [
        Io("div", {
          className: gd("layer-ui__wrapper__footer-left zen-mode-transition", {
            "layer-ui__wrapper__footer-left--transition-left": e.zenModeEnabled,
          }),
          children: Io(qe.Col, {
            gap: 2,
            children: eg(yr, {
              heading: "canvasActions",
              children: [
                Io(h2, { renderAction: o.renderAction, zoom: e.zoom }),
                !e.viewModeEnabled &&
                  Io(g2, {
                    renderAction: o.renderAction,
                    className: gd("zen-mode-transition", {
                      "layer-ui__wrapper__footer-left--transition-bottom": e.zenModeEnabled,
                    }),
                  }),
                l &&
                  Io(b2, {
                    renderAction: o.renderAction,
                    className: gd("zen-mode-transition", {
                      "layer-ui__wrapper__footer-left--transition-left": e.zenModeEnabled,
                    }),
                  }),
              ],
            }),
          }),
        }),
        Io(n.Out, {}),
        Io("div", {
          className: gd("layer-ui__wrapper__footer-right zen-mode-transition", {
            "transition-right": e.zenModeEnabled,
          }),
          children: eg("div", {
            style: { position: "relative" },
            children: [r && Io(i.Out, {}), Io(Vv, { onClick: () => o.executeAction(Jr) })],
          }),
        }),
        Io(f2, { actionManager: o, showExitZenModeBtn: t }),
      ],
    });
  },
  Kv = Xv;
Xv.displayName = "Footer";
import tN from "clsx";
import {
  useEffect as n3,
  useLayoutEffect as i3,
  useRef as cg,
  useState as oN,
  forwardRef as a3,
  useImperativeHandle as rN,
  useCallback as t3,
} from "react";
import { EVENT as o3, isDevEnv as nN, KEYS as iN, updateObject as aN } from "@excalidraw/common";
import $9 from "clsx";
import { useContext as j9 } from "react";
import Z9 from "react";
var fd = Z9.createContext({});
import { jsx as tg, jsxs as Zv } from "react/jsx-runtime";
var og = ({ children: e, className: o }) => {
  let t = ae(),
    r = j9(fd),
    n = !!(t.editor.canFitSidebar && r.shouldRenderDockButton);
  return Zv("div", {
    className: $9("sidebar__header", o),
    "data-testid": "sidebar-header",
    children: [
      e,
      Zv("div", {
        className: "sidebar__header__buttons",
        children: [
          n &&
            tg(Lt, {
              label: g("labels.sidebarLock"),
              children: tg(_t, {
                onSelect: () => r.onDock?.(!r.docked),
                selected: !!r.docked,
                className: "sidebar__dock",
                "data-testid": "sidebar-dock",
                "aria-label": g("labels.sidebarLock"),
                children: S1,
              }),
            }),
          tg(_t, {
            "data-testid": "sidebar-close",
            className: "sidebar__close",
            onSelect: r.onCloseRequest,
            "aria-label": g("buttons.close"),
            children: Bt,
          }),
        ],
      }),
    ],
  });
};
og.displayName = "SidebarHeader";
import * as jv from "@radix-ui/react-tabs";
import { jsx as $v } from "react/jsx-runtime";
var rg = ({ children: e, tab: o, onSelect: t, ...r }) =>
  $v(jv.Trigger, {
    value: o,
    asChild: !0,
    onSelect: t,
    children: $v("button", {
      type: "button",
      className: "excalidraw-button sidebar-tab-trigger",
      ...r,
      children: e,
    }),
  });
rg.displayName = "SidebarTabTrigger";
import * as qv from "@radix-ui/react-tabs";
import { jsx as q9 } from "react/jsx-runtime";
var ng = ({ children: e, ...o }) =>
  q9(qv.List, { className: "sidebar-triggers", ...o, children: e });
ng.displayName = "SidebarTabTriggers";
import J9 from "clsx";
import { jsx as ig, jsxs as Jv } from "react/jsx-runtime";
var ag = ({
  name: e,
  tab: o,
  icon: t,
  title: r,
  children: n,
  onToggle: i,
  className: a,
  style: l,
}) => {
  let s = le(),
    d = ge();
  return Jv("label", {
    title: r,
    className: "sidebar-trigger__label-element",
    children: [
      ig("input", {
        className: "ToolIcon_type_checkbox",
        type: "checkbox",
        onChange: (m) => {
          document.querySelector(".layer-ui__wrapper")?.classList.remove("animate");
          let c = m.target.checked;
          s({ openSidebar: c ? { name: e, tab: o } : null }), i?.(c);
        },
        checked: d.openSidebar?.name === e,
        "aria-label": r,
        "aria-keyshortcuts": "0",
      }),
      Jv("div", {
        className: J9("sidebar-trigger", a),
        style: l,
        children: [
          t && ig("div", { children: t }),
          n && ig("div", { className: "sidebar-trigger__label", children: n }),
        ],
      }),
    ],
  });
};
ag.displayName = "SidebarTrigger";
import * as Qv from "@radix-ui/react-tabs";
import { jsx as Q9 } from "react/jsx-runtime";
var lg = ({ children: e, ...o }) => {
  let t = ge(),
    r = le();
  if (!t.openSidebar) return null;
  let { name: n } = t.openSidebar;
  return Q9(Qv.Root, {
    className: "sidebar-tabs-root",
    value: t.openSidebar.tab,
    onValueChange: (i) => r((a) => ({ ...a, openSidebar: { ...a.openSidebar, name: n, tab: i } })),
    ...o,
    children: e,
  });
};
lg.displayName = "SidebarTabs";
import * as e3 from "@radix-ui/react-tabs";
import { jsx as eN } from "react/jsx-runtime";
var sg = ({ tab: e, children: o, ...t }) =>
  eN(e3.Content, { ...t, value: e, "data-testid": e, children: o });
sg.displayName = "SidebarTab";
import { jsx as r3 } from "react/jsx-runtime";
import { createElement as lN } from "react";
var el = me(!1),
  l3 = a3(({ name: e, children: o, onDock: t, docked: r, className: n, ...i }, a) => {
    nN() &&
      t &&
      r == null &&
      console.warn(
        "Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`"
      );
    let l = le(),
      s = Qo(el);
    i3(
      () => (
        s(!!r),
        () => {
          s(!1);
        }
      ),
      [s, r]
    );
    let d = cg({});
    (d.current.onCloseRequest = () => {
      l({ openSidebar: null });
    }),
      (d.current.onDock = (u) => t?.(u)),
      (d.current = aN(d.current, { docked: r, shouldRenderDockButton: !!t && r != null }));
    let m = cg(null);
    rN(a, () => m.current);
    let c = ae(),
      p = t3(() => {
        document.querySelector(".Dialog") || l({ openSidebar: null });
      }, [l]);
    return (
      Bn(
        m,
        t3(
          (u) => {
            u.target.closest(".sidebar-trigger") || ((!r || !c.editor.canFitSidebar) && p());
          },
          [p, r, c.editor.canFitSidebar]
        )
      ),
      n3(() => {
        let u = (f) => {
          f.key === iN.ESCAPE && (!r || !c.editor.canFitSidebar) && p();
        };
        return (
          document.addEventListener(o3.KEYDOWN, u),
          () => {
            document.removeEventListener(o3.KEYDOWN, u);
          }
        );
      }, [p, r, c.editor.canFitSidebar]),
      r3(Xe, {
        ...i,
        className: tN("sidebar", { "sidebar--docked": r }, n),
        ref: m,
        children: r3(fd.Provider, { value: d.current, children: o }),
      })
    );
  });
l3.displayName = "SidebarInner";
var Kt = Object.assign(
  a3((e, o) => {
    let t = ge(),
      { onStateChange: r } = e,
      n = cg(t.openSidebar);
    n3(() => {
      ((!t.openSidebar && n?.current?.name === e.name) ||
        (t.openSidebar?.name === e.name && n?.current?.name !== e.name) ||
        n.current?.name === e.name) &&
        t.openSidebar !== n.current &&
        r?.(t.openSidebar?.name !== e.name ? null : t.openSidebar),
        (n.current = t.openSidebar);
    }, [t.openSidebar, r, e.name]);
    let [i, a] = oN(!1);
    return (
      i3(() => (a(!0), () => a(!1)), []),
      i && t.openSidebar?.name === e.name ? lN(l3, { ...e, ref: o, key: e.name }) : null
    );
  }),
  { Header: og, TabTriggers: ng, TabTrigger: rg, Tabs: lg, Tab: sg, Trigger: ag }
);
Kt.displayName = "Sidebar";
import { composeEventHandlers as fN } from "@excalidraw/common";
import { useLayoutEffect as sN, useRef as cN } from "react";
import { jsx as dN } from "react/jsx-runtime";
var Vo = (e, o) => {
  let t = me(0),
    r = (n) => {
      let {
          tunnelsJotai: { useAtom: i },
        } = Ie(),
        [, a] = i(t),
        l = cN({ preferHost: !1, counter: 0 });
      return (
        sN(() => {
          let s = l.current;
          return (
            a((d) => {
              let m = d + 1;
              return (s.counter = m), m;
            }),
            () => {
              a((d) => {
                let m = d - 1;
                return (s.counter = m), m || (s.preferHost = !1), m;
              });
            }
          );
        }, [a]),
        n.__fallback || (l.current.preferHost = !0),
        (!l.current.counter && n.__fallback && l.current.preferHost) ||
        (l.current.counter > 1 && n.__fallback)
          ? null
          : dN(o, { ...n })
      );
    };
  return (r.displayName = e), r;
};
var pg = {};
Xf(pg, {
  ChangeCanvasBackground: () => w3,
  ClearCanvas: () => E3,
  CommandPalette: () => f3,
  Export: () => v3,
  Help: () => x3,
  LiveCollaborationTrigger: () => I3,
  LoadScene: () => u3,
  SaveAsImage: () => g3,
  SaveToActiveFile: () => h3,
  SearchMenu: () => b3,
  Socials: () => T3,
  ToggleTheme: () => y3,
});
import hN from "clsx";
import { THEME as vr } from "@excalidraw/common";
var dg = me({ active: !1 });
async function s3({ title: e, description: o, actionLabel: t, color: r }) {
  return new Promise((n) => {
    He.set(dg, {
      active: !0,
      onConfirm: () => n(!0),
      onClose: () => n(!1),
      onReject: () => n(!1),
      title: e,
      description: o,
      actionLabel: t,
      color: r,
    });
  });
}
import mN from "clsx";
import { jsx as c3, jsxs as pN } from "react/jsx-runtime";
var bd = function ({ onChange: e, value: o, choices: t, name: r }) {
  return c3("div", {
    className: "RadioGroup",
    children: t.map((n) =>
      pN(
        "div",
        {
          className: mN("RadioGroup__choice", { active: n.value === o }),
          title: n.ariaLabel,
          children: [
            c3("input", {
              name: r,
              type: "radio",
              checked: n.value === o,
              onChange: () => e(n.value),
              "aria-label": n.ariaLabel,
            }),
            n.label,
          ],
        },
        String(n.value)
      )
    ),
  });
};
import { Fragment as uN, jsx as mg, jsxs as d3 } from "react/jsx-runtime";
var m3 = ({ value: e, shortcut: o, onChange: t, choices: r, children: n, name: i }) => {
  let a = ae();
  return d3(uN, {
    children: [
      d3("div", {
        className: "dropdown-menu-item-base dropdown-menu-item-bare",
        children: [
          mg("label", { className: "dropdown-menu-item__text", htmlFor: i, children: n }),
          mg(bd, { name: i, value: e, onChange: t, choices: r }),
        ],
      }),
      o &&
        !a.editor.isMobile &&
        mg("div", {
          className: "dropdown-menu-item__shortcut dropdown-menu-item__shortcut--orphaned",
          children: o,
        }),
    ],
  });
};
m3.displayName = "DropdownMenuItemContentRadio";
var p3 = m3;
import { Fragment as gN, jsx as je, jsxs as C3 } from "react/jsx-runtime";
var u3 = () => {
  let { t: e } = ze(),
    o = Fe(),
    t = nr();
  return o.isActionEnabled(qn)
    ? je(mt, {
        icon: Mn,
        onSelect: async () => {
          (!t.length ||
            (await s3({
              title: e("overwriteConfirm.modal.loadFromFile.title"),
              actionLabel: e("overwriteConfirm.modal.loadFromFile.button"),
              color: "warning",
              description: je(ut, {
                i18nKey: "overwriteConfirm.modal.loadFromFile.description",
                bold: (n) => je("strong", { children: n }),
                br: () => je("br", {}),
              }),
            }))) &&
            o.executeAction(qn);
        },
        "data-testid": "load-button",
        shortcut: Ne("loadScene"),
        "aria-label": e("buttons.load"),
        children: e("buttons.load"),
      })
    : null;
};
u3.displayName = "LoadScene";
var h3 = () => {
  let { t: e } = ze(),
    o = Fe();
  return o.isActionEnabled(qr)
    ? je(mt, {
        shortcut: Ne("saveScene"),
        "data-testid": "save-button",
        onSelect: () => o.executeAction(qr),
        icon: G1,
        "aria-label": `${e("buttons.save")}`,
        children: `${e("buttons.save")}`,
      })
    : null;
};
h3.displayName = "SaveToActiveFile";
var g3 = () => {
  let e = le(),
    { t: o } = ze();
  return je(mt, {
    icon: jl,
    "data-testid": "image-export-button",
    onSelect: () => e({ openDialog: { name: "imageExport" } }),
    shortcut: Ne("imageExport"),
    "aria-label": o("buttons.exportImage"),
    children: o("buttons.exportImage"),
  });
};
g3.displayName = "SaveAsImage";
var f3 = (e) => {
  let o = le(),
    { t } = ze();
  return je(mt, {
    icon: oa,
    "data-testid": "command-palette-button",
    onSelect: () => {
      re("command_palette", "open", "menu"), o({ openDialog: { name: "commandPalette" } });
    },
    shortcut: Ne("commandPalette"),
    "aria-label": t("commandPalette.title"),
    className: e?.className,
    children: t("commandPalette.title"),
  });
};
f3.displayName = "CommandPalette";
var b3 = (e) => {
  let { t: o } = ze(),
    t = Fe();
  return je(mt, {
    icon: Mt,
    "data-testid": "search-menu-button",
    onSelect: () => {
      t.executeAction(za);
    },
    shortcut: Ne("searchMenu"),
    "aria-label": o("search.title"),
    className: e?.className,
    children: o("search.title"),
  });
};
b3.displayName = "SearchMenu";
var x3 = () => {
  let { t: e } = ze(),
    o = Fe();
  return je(mt, {
    "data-testid": "help-menu-item",
    icon: kn,
    onSelect: () => o.executeAction(Jr),
    shortcut: "?",
    "aria-label": e("helpDialog.title"),
    children: e("helpDialog.title"),
  });
};
x3.displayName = "Help";
var E3 = () => {
  let { t: e } = ze(),
    o = Qo(on);
  return Fe().isActionEnabled(No)
    ? je(mt, {
        icon: kt,
        onSelect: () => o("clearCanvas"),
        "data-testid": "clear-canvas-button",
        "aria-label": e("buttons.clearReset"),
        children: e("buttons.clearReset"),
      })
    : null;
};
E3.displayName = "ClearCanvas";
var y3 = (e) => {
  let { t: o } = ze(),
    t = ge(),
    r = Fe(),
    n = Ne("toggleTheme");
  return r.isActionEnabled(Kr)
    ? e?.allowSystemTheme
      ? je(p3, {
          name: "theme",
          value: e.theme,
          onChange: (i) => e.onSelect(i),
          choices: [
            { value: vr.LIGHT, label: Ji, ariaLabel: `${o("buttons.lightMode")} - ${n}` },
            { value: vr.DARK, label: qi, ariaLabel: `${o("buttons.darkMode")} - ${n}` },
            { value: "system", label: rb, ariaLabel: o("buttons.systemMode") },
          ],
          children: o("labels.theme"),
        })
      : je(mt, {
          onSelect: (i) => {
            if ((i.preventDefault(), e?.onSelect))
              e.onSelect(t.theme === vr.DARK ? vr.LIGHT : vr.DARK);
            else return r.executeAction(Kr);
          },
          icon: t.theme === vr.DARK ? Ji : qi,
          "data-testid": "toggle-dark-mode",
          shortcut: n,
          "aria-label": t.theme === vr.DARK ? o("buttons.lightMode") : o("buttons.darkMode"),
          children: t.theme === vr.DARK ? o("buttons.lightMode") : o("buttons.darkMode"),
        })
    : null;
};
y3.displayName = "ToggleTheme";
var w3 = () => {
  let { t: e } = ze(),
    o = ge(),
    t = Fe(),
    r = bo();
  return o.viewModeEnabled || !r.UIOptions.canvasActions.changeViewBackgroundColor
    ? null
    : C3("div", {
        style: { marginTop: "0.5rem" },
        children: [
          je("div", {
            "data-testid": "canvas-background-label",
            style: { fontSize: ".75rem", marginBottom: ".5rem" },
            children: e("labels.canvasBackground"),
          }),
          je("div", {
            style: { padding: "0 0.625rem" },
            children: t.renderAction("changeViewBackgroundColor"),
          }),
        ],
      });
};
w3.displayName = "ChangeCanvasBackground";
var v3 = () => {
  let { t: e } = ze(),
    o = le();
  return je(mt, {
    icon: Gr,
    onSelect: () => {
      o({ openDialog: { name: "jsonExport" } });
    },
    "data-testid": "json-export-button",
    "aria-label": e("buttons.export"),
    children: e("buttons.export"),
  });
};
v3.displayName = "Export";
var T3 = () => {
  let { t: e } = ze();
  return C3(gN, {
    children: [
      je(gi, {
        icon: Zl,
        href: "https://github.com/excalidraw/excalidraw",
        "aria-label": "GitHub",
        children: "GitHub",
      }),
      je(gi, {
        icon: z1,
        href: "https://x.com/excalidraw",
        "aria-label": "X",
        children: e("labels.followUs"),
      }),
      je(gi, {
        icon: O1,
        href: "https://discord.gg/UexuTaE",
        "aria-label": "Discord",
        children: e("labels.discordChat"),
      }),
    ],
  });
};
T3.displayName = "Socials";
var I3 = ({ onSelect: e, isCollaborating: o }) => {
  let { t } = ze();
  return je(mt, {
    "data-testid": "collab-button",
    icon: ql,
    className: hN({ "active-collab": o }),
    onSelect: e,
    children: t("labels.liveCollaboration"),
  });
};
I3.displayName = "LiveCollaborationTrigger";
import { jsx as xd, jsxs as ug } from "react/jsx-runtime";
var bN = Object.assign(
    Vo("MainMenu", ({ children: e, onSelect: o }) => {
      let { MainMenuTunnel: t } = Ie(),
        r = ae(),
        n = ge(),
        i = le(),
        a = r.editor.isMobile ? void 0 : () => i({ openMenu: null });
      return xd(t.In, {
        children: ug(fe, {
          open: n.openMenu === "canvas",
          children: [
            xd(fe.Trigger, {
              onToggle: () => {
                i({ openMenu: n.openMenu === "canvas" ? null : "canvas" });
              },
              "data-testid": "main-menu-trigger",
              className: "main-menu-trigger",
              children: Kl,
            }),
            ug(fe.Content, {
              onClickOutside: a,
              onSelect: fN(o, () => {
                i({ openMenu: null });
              }),
              children: [
                e,
                r.editor.isMobile &&
                  n.collaborators.size > 0 &&
                  ug("fieldset", {
                    className: "UserList-Wrapper",
                    children: [
                      xd("legend", { children: g("labels.collaborators") }),
                      xd(hd, {
                        mobile: !0,
                        collaborators: n.collaborators,
                        userToFollow: n.userToFollow?.socketId || null,
                      }),
                    ],
                  }),
              ],
            }),
          ],
        }),
      });
    }),
    {
      Trigger: fe.Trigger,
      Item: fe.Item,
      ItemLink: fe.ItemLink,
      ItemCustom: fe.ItemCustom,
      Group: fe.Group,
      Separator: fe.Separator,
      DefaultItems: pg,
    }
  ),
  ct = bN;
import xN from "clsx";
import { forwardRef as EN, useState as yN } from "react";
import { isPromiseLike as wN } from "@excalidraw/common";
import { jsx as Ed, jsxs as vN } from "react/jsx-runtime";
var Tr = EN(
  (
    {
      children: e,
      icon: o,
      onClick: t,
      label: r,
      variant: n = "filled",
      color: i = "primary",
      size: a = "medium",
      fullWidth: l,
      className: s,
      status: d,
    },
    m
  ) => {
    let [c, p] = yN(!1),
      u = async (b) => {
        let x = t?.(b);
        if (wN(x)) {
          let w = window.setTimeout(() => {
            p(!0);
          }, 50);
          try {
            await x;
          } catch (E) {
            if (E instanceof xn) console.warn(E);
            else throw E;
          } finally {
            clearTimeout(w), p(!1);
          }
        }
      },
      f = c ? "loading" : d;
    return (
      (i = f === "success" ? "success" : i),
      Ed("button", {
        className: xN(
          "ExcButton",
          `ExcButton--color-${i}`,
          `ExcButton--variant-${n}`,
          `ExcButton--size-${a}`,
          `ExcButton--status-${f}`,
          { "ExcButton--fullWidth": l },
          s
        ),
        onClick: u,
        type: "button",
        "aria-label": r,
        ref: m,
        disabled: f === "loading" || f === "success",
        children: vN("div", {
          className: "ExcButton__contents",
          children: [
            f === "loading"
              ? Ed(tt, { className: "ExcButton__statusIcon" })
              : f === "success" && Ed("div", { className: "ExcButton__statusIcon", children: O0 }),
            o && Ed("div", { className: "ExcButton__icon", "aria-hidden": !0, children: o }),
            n !== "icon" && (e ?? r),
          ],
        }),
      })
    );
  }
);
import { jsx as Li, jsxs as CN } from "react/jsx-runtime";
var yd = ({ title: e, children: o, actionLabel: t, onClick: r }) =>
    CN("div", {
      className: "OverwriteConfirm__Actions__Action",
      children: [
        Li("h4", { children: e }),
        Li("div", { className: "OverwriteConfirm__Actions__Action__content", children: o }),
        Li(Tr, {
          variant: "outlined",
          color: "muted",
          label: t,
          size: "large",
          fullWidth: !0,
          onClick: r,
        }),
      ],
    }),
  TN = () => {
    let { t: e } = ze(),
      o = Fe(),
      t = le();
    return Li(yd, {
      title: e("overwriteConfirm.action.exportToImage.title"),
      actionLabel: e("overwriteConfirm.action.exportToImage.button"),
      onClick: () => {
        o.executeAction(Ks, "ui", !0), t({ openDialog: { name: "imageExport" } });
      },
      children: e("overwriteConfirm.action.exportToImage.description"),
    });
  },
  IN = () => {
    let { t: e } = ze(),
      o = Fe();
    return Li(yd, {
      title: e("overwriteConfirm.action.saveToDisk.title"),
      actionLabel: e("overwriteConfirm.action.saveToDisk.button"),
      onClick: () => {
        o.executeAction(Ta, "ui");
      },
      children: e("overwriteConfirm.action.saveToDisk.description"),
    });
  },
  hg = Object.assign(
    ({ children: e }) => Li("div", { className: "OverwriteConfirm__Actions", children: e }),
    { ExportToImage: TN, SaveToDisk: IN }
  );
import { jsx as Ir, jsxs as S3 } from "react/jsx-runtime";
var wd = Object.assign(
  Vo("OverwriteConfirmDialog", ({ children: e }) => {
    let { OverwriteConfirmDialogTunnel: o } = Ie(),
      [t, r] = ne(dg);
    if (!t.active) return null;
    let n = () => {
        t.onClose(), r((a) => ({ ...a, active: !1 }));
      },
      i = () => {
        t.onConfirm(), r((a) => ({ ...a, active: !1 }));
      };
    return Ir(o.In, {
      children: Ir(Be, {
        onCloseRequest: n,
        title: !1,
        size: 916,
        children: S3("div", {
          className: "OverwriteConfirm",
          children: [
            Ir("h3", { children: t.title }),
            S3("div", {
              className: `OverwriteConfirm__Description OverwriteConfirm__Description--color-${t.color}`,
              children: [
                Ir("div", { className: "OverwriteConfirm__Description__icon", children: z0 }),
                Ir("div", { children: t.description }),
                Ir("div", { className: "OverwriteConfirm__Description__spacer" }),
                Ir(Tr, { color: t.color, size: "large", label: t.actionLabel, onClick: i }),
              ],
            }),
            Ir(hg, { children: e }),
          ],
        }),
      }),
    });
  }),
  { Actions: hg, Action: yd }
);
import KN from "clsx";
import {
  CANVAS_SEARCH_TAB as Eg,
  DEFAULT_SIDEBAR as ZN,
  LIBRARY_SIDEBAR_TAB as B3,
  composeEventHandlers as $N,
} from "@excalidraw/common";
import { round as SN } from "@excalidraw/math";
import kN from "clsx";
import MN from "lodash.debounce";
import {
  Fragment as LN,
  memo as PN,
  useEffect as tl,
  useMemo as k3,
  useRef as gg,
  useState as M3,
} from "react";
import {
  CLASSES as AN,
  EVENT as DN,
  FONT_FAMILY as fg,
  FRAME_STYLE as bg,
  getLineHeight as _N,
} from "@excalidraw/common";
import { isElementCompletelyInViewport as RN } from "@excalidraw/element";
import { measureText as ol } from "@excalidraw/element";
import {
  KEYS as Pi,
  randomInteger as L3,
  addEventListener as NN,
  getFontString as vd,
} from "@excalidraw/common";
import { newTextElement as BN } from "@excalidraw/element";
import { isTextElement as _3, isFrameLikeElement as Td } from "@excalidraw/element";
import { getDefaultFrameName as R3 } from "@excalidraw/element/frame";
import { Fragment as XN, jsx as Je, jsxs as Co } from "react/jsx-runtime";
var FN = me(""),
  xg = me(null),
  ON = 350,
  N3 = () => {
    let e = Re(),
      o = le(),
      t = gg(null),
      [r, n] = ne(FN),
      i = r.trim(),
      [a, l] = M3(!1),
      [s, d] = M3({ nonce: null, items: [] }),
      m = gg(null),
      c = gg(void 0),
      [p, u] = ne(xg),
      f = e.scene.getNonDeletedElementsMap();
    tl(() => {
      a ||
        ((i !== m.current || e.scene.getSceneNonce() !== c.current) &&
          ((m.current = null),
          D3(i, e, (y, v) => {
            d({ nonce: L3(), items: y }),
              (m.current = i),
              (c.current = e.scene.getSceneNonce()),
              o({
                searchMatches: y.length
                  ? {
                      focusedId: null,
                      matches: y.map((C) => ({
                        id: C.element.id,
                        focus: !1,
                        matchedLines: C.matchedLines,
                      })),
                    }
                  : null,
              });
          })));
    }, [a, i, f, e, o, u, c]);
    let b = () => {
        s.items.length > 0 && u((y) => (y === null ? 0 : (y + 1) % s.items.length));
      },
      x = () => {
        s.items.length > 0 && u((y) => (y === null ? 0 : y - 1 < 0 ? s.items.length - 1 : y - 1));
      };
    tl(() => {
      o((y) =>
        y.searchMatches
          ? {
              searchMatches: {
                focusedId: (p !== null && y.searchMatches?.matches[p]?.id) || null,
                matches: y.searchMatches.matches.map((C, S) =>
                  S === p ? { ...C, focus: !0 } : { ...C, focus: !1 }
                ),
              },
            }
          : null
      );
    }, [p, o]),
      tl(() => {
        if (s.items.length > 0 && p !== null) {
          let y = s.items[p];
          if (y) {
            let v = e.state.zoom.value,
              C = BN({
                text: y.searchQuery,
                x: y.element.x + (y.matchedLines[0]?.offsetX ?? 0),
                y: y.element.y + (y.matchedLines[0]?.offsetY ?? 0),
                width: y.matchedLines[0]?.width,
                height: y.matchedLines[0]?.height,
                fontSize: Td(y.element) ? bg.nameFontSize : y.element.fontSize,
                fontFamily: Td(y.element) ? fg.Assistant : y.element.fontFamily,
              }),
              S = 14,
              M = C.fontSize,
              k = M * v < S;
            if (
              !RN(
                [C],
                e.canvas.width / window.devicePixelRatio,
                e.canvas.height / window.devicePixelRatio,
                {
                  offsetLeft: e.state.offsetLeft,
                  offsetTop: e.state.offsetTop,
                  scrollX: e.state.scrollX,
                  scrollY: e.state.scrollY,
                  zoom: e.state.zoom,
                },
                e.scene.getNonDeletedElementsMap(),
                e.getEditorUIOffsets()
              ) ||
              k
            ) {
              let A;
              k
                ? M >= S
                  ? (A = { fitToContent: !0 })
                  : (A = { fitToViewport: !0, maxZoom: SN(S / M, 1) })
                : (A = { fitToContent: !0 }),
                e.scrollToContent(C, {
                  animate: !0,
                  duration: 300,
                  ...A,
                  canvasOffsets: e.getEditorUIOffsets(),
                });
            }
          }
        }
      }, [p, s, e]),
      tl(
        () => () => {
          u(null), (m.current = null), (c.current = void 0), o({ searchMatches: null }), l(!1);
        },
        [o, u]
      );
    let w = tr({ goToNextItem: b, goToPreviousItem: x, searchMatches: s });
    tl(() => {
      let y = (v) => {
        if (v.key === Pi.ESCAPE && !e.state.openDialog && !e.state.openPopup) {
          v.preventDefault(), v.stopPropagation(), o({ openSidebar: null });
          return;
        }
        if (v[Pi.CTRL_OR_CMD] && v.key === Pi.F) {
          if ((v.preventDefault(), v.stopPropagation(), e.state.openDialog)) return;
          t.current?.matches(":focus") ||
            (e.state.openDialog && o({ openDialog: null }),
            t.current?.focus(),
            t.current?.select());
        }
        v.target instanceof HTMLElement &&
          v.target.closest(".layer-ui__search") &&
          w.searchMatches.items.length &&
          (v.key === Pi.ENTER && (v.stopPropagation(), w.goToNextItem()),
          v.key === Pi.ARROW_UP
            ? (v.stopPropagation(), w.goToPreviousItem())
            : v.key === Pi.ARROW_DOWN && (v.stopPropagation(), w.goToNextItem()));
      };
      return NN(window, DN.KEYDOWN, y, { capture: !0, passive: !1 });
    }, [o, w, e]);
    let E = `${s.items.length} ${
      s.items.length === 1 ? g("search.singleResult") : g("search.multipleResults")
    }`;
    return Co("div", {
      className: "layer-ui__search",
      children: [
        Je("div", {
          className: "layer-ui__search-header",
          children: Je(xi, {
            className: AN.SEARCH_MENU_INPUT_WRAPPER,
            value: r,
            ref: t,
            placeholder: g("search.placeholder"),
            icon: Mt,
            onChange: (y) => {
              n(y), l(!0);
              let v = y.trim();
              D3(v, e, (C, S) => {
                d({ nonce: L3(), items: C }),
                  u(S),
                  (m.current = v),
                  (c.current = e.scene.getSceneNonce()),
                  o({
                    searchMatches: C.length
                      ? {
                          focusedId: null,
                          matches: C.map((M) => ({
                            id: M.element.id,
                            focus: !1,
                            matchedLines: M.matchedLines,
                          })),
                        }
                      : null,
                  }),
                  l(!1);
              });
            },
            selectOnRender: !0,
          }),
        }),
        Co("div", {
          className: "layer-ui__search-count",
          children: [
            s.items.length > 0 &&
              Co(XN, {
                children: [
                  p !== null && p > -1
                    ? Co("div", { children: [p + 1, " / ", E] })
                    : Je("div", { children: E }),
                  Co("div", {
                    className: "result-nav",
                    children: [
                      Je(_t, {
                        onSelect: () => {
                          b();
                        },
                        className: "result-nav-btn",
                        children: ls,
                      }),
                      Je(_t, {
                        onSelect: () => {
                          x();
                        },
                        className: "result-nav-btn",
                        children: sb,
                      }),
                    ],
                  }),
                ],
              }),
            s.items.length === 0 &&
              i &&
              m.current &&
              Je("div", { style: { margin: "1rem auto" }, children: g("search.noMatch") }),
          ],
        }),
        Je(GN, { matches: s, onItemClick: u, focusIndex: p, searchQuery: i }),
      ],
    });
  },
  P3 = (e) => {
    let o = [
      e.preview.moreBefore ? "..." : "",
      e.preview.previewText.slice(0, e.preview.indexInSearchQuery),
      e.preview.previewText.slice(
        e.preview.indexInSearchQuery,
        e.preview.indexInSearchQuery + e.searchQuery.length
      ),
      e.preview.previewText.slice(e.preview.indexInSearchQuery + e.searchQuery.length),
      e.preview.moreAfter ? "..." : "",
    ];
    return Je("div", {
      tabIndex: -1,
      className: kN("layer-ui__result-item", { active: e.highlighted }),
      onClick: e.onClick,
      ref: (t) => {
        e.highlighted && t?.scrollIntoView({ behavior: "auto", block: "nearest" });
      },
      children: Je("div", {
        className: "preview-text",
        children: o.flatMap((t, r) =>
          Je(LN, { children: r === 2 ? Je("b", { children: t }) : t }, r)
        ),
      }),
    });
  },
  zN = (e) => {
    let o = k3(() => e.matches.items.filter((r) => Td(r.element)), [e.matches]),
      t = k3(() => e.matches.items.filter((r) => _3(r.element)), [e.matches]);
    return Co("div", {
      children: [
        o.length > 0 &&
          Co("div", {
            className: "layer-ui__search-result-container",
            children: [
              Co("div", {
                className: "layer-ui__search-result-title",
                children: [
                  Je("div", { className: "title-icon", children: Yr }),
                  Je("div", { children: g("search.frames") }),
                ],
              }),
              o.map((r, n) =>
                Je(
                  P3,
                  {
                    searchQuery: e.searchQuery,
                    preview: r.preview,
                    highlighted: n === e.focusIndex,
                    onClick: () => e.onItemClick(n),
                  },
                  r.element.id + r.index
                )
              ),
              t.length > 0 && Je("div", { className: "layer-ui__divider" }),
            ],
          }),
        t.length > 0 &&
          Co("div", {
            className: "layer-ui__search-result-container",
            children: [
              Co("div", {
                className: "layer-ui__search-result-title",
                children: [
                  Je("div", { className: "title-icon", children: Sn }),
                  Je("div", { children: g("search.texts") }),
                ],
              }),
              t.map((r, n) =>
                Je(
                  P3,
                  {
                    searchQuery: e.searchQuery,
                    preview: r.preview,
                    highlighted: n + o.length === e.focusIndex,
                    onClick: () => e.onItemClick(n + o.length),
                  },
                  r.element.id + r.index
                )
              ),
            ],
          }),
      ],
    });
  },
  HN = (e, o) => e.matches.nonce === o.matches.nonce && e.focusIndex === o.focusIndex,
  GN = PN(zN, HN),
  A3 = (e, o, t) => {
    let i = e.slice(0, o),
      a = i.split(/\s+/),
      l = i.endsWith(" "),
      s = a.length - 2 - 1 - (l ? 0 : 1),
      d = a.slice(s <= 0 ? 0 : s).join(" ") + (l ? " " : ""),
      m = 20;
    d = d.length > m ? d.slice(-m) : d;
    let c = e.slice(o + t.length),
      p = c.split(/\s+/),
      u = !c.startsWith(" "),
      f = u ? 6 : 5,
      b = (u ? "" : " ") + p.slice(0, f).join(" ");
    return {
      indexInSearchQuery: d.length,
      previewText: d + t + b,
      moreBefore: s > 0,
      moreAfter: p.length > f,
    };
  },
  UN = (e, o) => {
    let t = e.split(`
`),
      r = [],
      n = 0;
    for (let i = 0; i < t.length; i++) {
      let a = t[i],
        l = t[i + 1];
      if (l) {
        let s = o.indexOf(l, n);
        if (s > a.length + n) {
          let d = s - (a.length + n);
          for (; d > 0; ) (a += " "), d--;
        }
      }
      r.push(a), (n = n + a.length);
    }
    return r.join(`
`);
  },
  YN = (e, o, t) => {
    let n = UN(e.text, e.originalText).split(`
`),
      i = [],
      a = 0,
      l = 0;
    for (let c of n) {
      let p = a,
        u = p + c.length - 1;
      i.push({ line: c, startIndex: p, endIndex: u, lineNumber: l }), (a = u + 1), l++;
    }
    let s = t,
      d = e.originalText.slice(t, t + o.length),
      m = [];
    for (let c of i) {
      if (d === "") break;
      if (s >= c.startIndex && s <= c.endIndex) {
        let p = c.endIndex + 1 - s,
          u = c.line.slice(0, s - c.startIndex),
          f = d.slice(0, p);
        d = d.slice(p);
        let b = ol(u, vd(e), e.lineHeight);
        if ((u === "" && (b.width = 0), e.textAlign !== "left" && c.line.length > 0)) {
          let v = ol(c.line, vd(e), e.lineHeight),
            C = e.textAlign === "center" ? (e.width - v.width) / 2 : e.width - v.width;
          b.width += C;
        }
        let { width: x, height: w } = ol(f, vd(e), e.lineHeight),
          E = b.width,
          y = c.lineNumber * b.height;
        m.push({ offsetX: E, offsetY: y, width: x, height: w, showOnCanvas: !0 }), (s += p);
      }
    }
    return m;
  },
  WN = (e, o, t, r) => {
    let n = e.name ?? R3(e),
      i = n.slice(t, t + o.length),
      a = n.slice(0, t),
      l = vd({ fontSize: bg.nameFontSize, fontFamily: fg.Assistant }),
      s = _N(fg.Assistant),
      d = ol(a, l, s);
    a === "" && (d.width = 0);
    let m = ol(i, l, s),
      c = d.width,
      p = -d.height - bg.strokeWidth,
      u = m.width;
    return [
      { offsetX: c, offsetY: p, width: u, height: m.height, showOnCanvas: c + u <= e.width * r },
    ];
  },
  VN = (e) => e.replace(/[.*+?^${}()|[\]\\-]/g, "\\$&"),
  D3 = MN((e, o, t) => {
    if (!e || e === "") {
      t([], null);
      return;
    }
    let r = o.scene.getNonDeletedElements(),
      n = r.filter((p) => _3(p)),
      i = r.filter((p) => Td(p));
    n.sort((p, u) => p.y - u.y), i.sort((p, u) => p.y - u.y);
    let a = [],
      l = new RegExp(VN(e), "gi");
    for (let p of n) {
      let u = null,
        f = p.originalText;
      for (; (u = l.exec(f)) !== null; ) {
        let b = A3(f, u.index, e),
          x = YN(p, e, u.index);
        x.length > 0 &&
          a.push({ element: p, searchQuery: e, preview: b, index: u.index, matchedLines: x });
      }
    }
    let s = [];
    for (let p of i) {
      let u = null,
        f = p.name ?? R3(p);
      for (; (u = l.exec(f)) !== null; ) {
        let b = A3(f, u.index, e),
          x = WN(p, e, u.index, o.state.zoom.value);
        x.length > 0 &&
          s.push({ element: p, searchQuery: e, preview: b, index: u.index, matchedLines: x });
      }
    }
    let d = new Set(o.visibleElements.map((p) => p.id)),
      m = [...s, ...a],
      c = m.findIndex((p) => d.has(p.element.id)) ?? null;
    t(m, c);
  }, ON);
import { jsx as co, jsxs as F3 } from "react/jsx-runtime";
import { createElement as jN } from "react";
var O3 = Vo("DefaultSidebarTrigger", (e) => {
  let { DefaultSidebarTriggerTunnel: o } = Ie();
  return co(o.In, {
    children: co(Kt.Trigger, { ...e, className: "default-sidebar-trigger", name: ZN.name }),
  });
});
O3.displayName = "DefaultSidebarTrigger";
var z3 = ({ children: e }) => {
  let { DefaultSidebarTabTriggersTunnel: o } = Ie();
  return co(o.In, { children: e });
};
z3.displayName = "DefaultTabTriggers";
var Id = Object.assign(
  Vo("DefaultSidebar", ({ children: e, className: o, onDock: t, docked: r, ...n }) => {
    let i = ge(),
      a = le(),
      { DefaultSidebarTabTriggersTunnel: l } = Ie(),
      s = i.openSidebar?.tab === Eg;
    return jN(
      Kt,
      {
        ...n,
        name: "default",
        key: "default",
        className: KN("default-sidebar", o),
        docked: s || (r ?? i.defaultSidebarDockedPreference),
        onDock:
          s || t === !1 || (!t && r != null)
            ? void 0
            : $N(t, (d) => {
                a({ defaultSidebarDockedPreference: d });
              }),
      },
      F3(Kt.Tabs, {
        children: [
          co(Kt.Header, {
            children: F3(Kt.TabTriggers, {
              children: [
                co(Kt.TabTrigger, { tab: Eg, children: Mt }),
                co(Kt.TabTrigger, { tab: B3, children: In }),
                co(l.Out, {}),
              ],
            }),
          }),
          co(Kt.Tab, { tab: B3, children: co(o2, {}) }),
          co(Kt.Tab, { tab: Eg, children: co(N3, {}) }),
          e,
        ],
      })
    );
  }),
  { Trigger: O3, TabTriggers: z3 }
);
import { useEffect as fB, useRef as vg, useState as Rd } from "react";
import { isFiniteNumber as l5 } from "@excalidraw/math";
import { useState as K3, useRef as Z3, useEffect as $3, useDeferredValue as iB } from "react";
import { EDITOR_LS_KEYS as aB, debounce as lB, isDevEnv as sB } from "@excalidraw/common";
import { useEffect as qN, useRef as H3 } from "react";
import { EVENT as G3, KEYS as U3 } from "@excalidraw/common";
import { jsx as JN } from "react/jsx-runtime";
var Cd = ({ input: e, placeholder: o, onChange: t, onKeyboardSubmit: r }) => {
  let n = H3(null),
    i = H3(r);
  return (
    (i.current = r),
    qN(() => {
      if (!i.current) return;
      let a = n.current;
      if (a) {
        let l = (s) => {
          s[U3.CTRL_OR_CMD] && s.key === U3.ENTER && (s.preventDefault(), i.current?.());
        };
        return (
          a.focus(),
          a.addEventListener(G3.KEYDOWN, l),
          () => {
            a.removeEventListener(G3.KEYDOWN, l);
          }
        );
      }
    }, []),
    JN("textarea", { className: "ttd-dialog-input", onChange: t, value: e, placeholder: o, ref: n })
  );
};
import { jsx as Sd, jsxs as Y3 } from "react/jsx-runtime";
var QN = ({ error: e }) =>
    Y3("div", {
      "data-testid": "ttd-dialog-output-error",
      className: "ttd-dialog-output-error",
      children: ["Error! ", Sd("p", { children: e })],
    }),
  kd = ({ error: e, canvasRef: o, loaded: t }) =>
    Y3("div", {
      className: "ttd-dialog-output-wrapper",
      children: [
        e && Sd(QN, { error: e.message }),
        t
          ? Sd("div", {
              ref: o,
              style: { opacity: e ? "0.15" : 1 },
              className: "ttd-dialog-output-canvas-container",
            })
          : Sd(tt, { size: "2rem" }),
      ],
    });
import W3 from "clsx";
import { jsx as yg, jsxs as rl } from "react/jsx-runtime";
var Ai = ({
  label: e,
  children: o,
  panelAction: t,
  panelActionDisabled: r = !1,
  onTextSubmitInProgess: n,
  renderTopRight: i,
  renderSubmitShortcut: a,
  renderBottomRight: l,
}) =>
  rl("div", {
    className: "ttd-dialog-panel",
    children: [
      rl("div", {
        className: "ttd-dialog-panel__header",
        children: [yg("label", { children: e }), i?.()],
      }),
      o,
      rl("div", {
        className: W3("ttd-dialog-panel-button-container", { invisible: !t }),
        style: { display: "flex", alignItems: "center" },
        children: [
          rl(_t, {
            className: "ttd-dialog-panel-button",
            onSelect: t ? t.action : () => {},
            disabled: r || n,
            children: [
              rl("div", {
                className: W3({ invisible: n }),
                children: [t?.label, t?.icon && yg("span", { children: t.icon })],
              }),
              n && yg(tt, {}),
            ],
          }),
          !r && !n && a?.(),
          l?.(),
        ],
      }),
    ],
  });
import { jsx as eB } from "react/jsx-runtime";
var Md = ({ children: e }) => eB("div", { className: "ttd-dialog-panels", children: e });
import { getShortcutKey as V3 } from "@excalidraw/common";
import { jsx as X3, jsxs as tB } from "react/jsx-runtime";
var Ld = () =>
  tB("div", {
    className: "ttd-dialog-submit-shortcut",
    children: [
      X3("div", { className: "ttd-dialog-submit-shortcut__key", children: V3("CtrlOrCmd") }),
      X3("div", { className: "ttd-dialog-submit-shortcut__key", children: V3("Enter") }),
    ],
  });
import { DEFAULT_EXPORT_PADDING as oB, EDITOR_LS_KEYS as rB } from "@excalidraw/common";
var nB = ({ canvasRef: e, setError: o }) => {
    let t = e.current;
    if (!t) return;
    let r = t.parentElement;
    r && ((r.style.background = ""), o(null), t.replaceChildren());
  },
  Pd = async ({
    canvasRef: e,
    mermaidToExcalidrawLib: o,
    mermaidDefinition: t,
    setError: r,
    data: n,
  }) => {
    let i = e.current,
      a = i?.parentElement;
    if (!(!i || !a)) {
      if (!t) {
        nB({ canvasRef: e, setError: r });
        return;
      }
      try {
        let l = await o.api,
          s;
        try {
          s = await l.parseMermaidToExcalidraw(t);
        } catch {
          s = await l.parseMermaidToExcalidraw(t.replace(/"/g, "'"));
        }
        let { elements: d, files: m } = s;
        r(null), (n.current = { elements: Si(d, { regenerateIds: !0 }), files: m });
        let c = await pr({
          elements: n.current.elements,
          files: n.current.files,
          exportPadding: oB,
          maxWidthOrHeight: Math.max(a.offsetWidth, a.offsetHeight) * window.devicePixelRatio,
        });
        try {
          await Lo(c);
        } catch (p) {
          throw p.name === "CANVAS_POSSIBLY_TOO_BIG" ? new Error(g("canvasError.canvasTooBig")) : p;
        }
        (a.style.background = "var(--default-bg-color)"), i.replaceChildren(c);
      } catch (l) {
        throw ((a.style.background = "var(--default-bg-color)"), t && r(l), l);
      }
    }
  },
  nl = (e) => {
    Ut.set(rB.MERMAID_TO_EXCALIDRAW, e);
  },
  Ad = ({ app: e, data: o, text: t, shouldSaveMermaidDataToStorage: r }) => {
    let { elements: n, files: i } = o.current;
    n.length &&
      (e.addElementsFromPasteOrLibrary({
        elements: n,
        files: i,
        position: "center",
        fitToContent: !0,
      }),
      e.setOpenDialog(null),
      r && t && nl(t));
  };
import { Fragment as mB, jsx as So, jsxs as q3 } from "react/jsx-runtime";
var cB = `flowchart TD
 A[Christmas] -->|Get money| B(Go shopping)
 B --> C{Let me think}
 C -->|One| D[Laptop]
 C -->|Two| E[iPhone]
 C -->|Three| F[Car]`,
  j3 = lB(nl, 300),
  dB = ({ mermaidToExcalidrawLib: e }) => {
    let [o, t] = K3(() => Ut.get(aB.MERMAID_TO_EXCALIDRAW) || cB),
      r = iB(o.trim()),
      [n, i] = K3(null),
      a = Z3(null),
      l = Z3({ elements: [], files: null }),
      s = Re();
    $3(() => {
      Pd({
        canvasRef: a,
        data: l,
        mermaidToExcalidrawLib: e,
        setError: i,
        mermaidDefinition: r,
      }).catch((m) => {
        sB() && console.error("Failed to parse mermaid definition", m);
      }),
        j3(r);
    }, [r, e]),
      $3(
        () => () => {
          j3.flush();
        },
        []
      );
    let d = () => {
      Ad({ app: s, data: l, text: o, shouldSaveMermaidDataToStorage: !0 });
    };
    return q3(mB, {
      children: [
        So("div", {
          className: "ttd-dialog-desc",
          children: So(ut, {
            i18nKey: "mermaid.description",
            flowchartLink: (m) =>
              So("a", { href: "https://mermaid.js.org/syntax/flowchart.html", children: m }),
            sequenceLink: (m) =>
              So("a", { href: "https://mermaid.js.org/syntax/sequenceDiagram.html", children: m }),
            classLink: (m) =>
              So("a", { href: "https://mermaid.js.org/syntax/classDiagram.html", children: m }),
          }),
        }),
        q3(Md, {
          children: [
            So(Ai, {
              label: g("mermaid.syntax"),
              children: So(Cd, {
                input: o,
                placeholder: "Write Mermaid diagram defintion here...",
                onChange: (m) => t(m.target.value),
                onKeyboardSubmit: () => {
                  d();
                },
              }),
            }),
            So(Ai, {
              label: g("mermaid.preview"),
              panelAction: {
                action: () => {
                  d();
                },
                label: g("mermaid.button"),
                icon: Pn,
              },
              renderSubmitShortcut: () => So(Ld, {}),
              children: So(kd, { canvasRef: a, loaded: e.loaded, error: n }),
            }),
          ],
        }),
      ],
    });
  },
  J3 = dB;
import * as e5 from "@radix-ui/react-tabs";
import { useRef as Q3 } from "react";
import { isMemberOf as pB } from "@excalidraw/common";
import { jsx as uB } from "react/jsx-runtime";
var t5 = (e) => {
  let o = le(),
    t = Q3(null),
    r = Q3(0);
  return uB(e5.Root, {
    ref: t,
    className: "ttd-dialog-tabs-root",
    value: e.tab,
    onValueChange: (n) => {
      if (!n) return;
      let i = t.current?.closest(".Modal__content");
      if (i) {
        let a = i.offsetHeight || 0;
        a > r.current && ((r.current = a), (i.style.minHeight = `min(${r.current}px, 100%)`));
      }
      e.dialog === "ttd" &&
        pB(["text-to-diagram", "mermaid"], n) &&
        o({ openDialog: { name: e.dialog, tab: n } });
    },
    children: e.children,
  });
};
t5.displayName = "TTDDialogTabs";
var o5 = t5;
import * as r5 from "@radix-ui/react-tabs";
import { jsx as hB } from "react/jsx-runtime";
var wg = ({ children: e, ...o }) =>
  hB(r5.List, { className: "ttd-dialog-triggers", ...o, children: e });
wg.displayName = "TTDDialogTabTriggers";
import * as i5 from "@radix-ui/react-tabs";
import { jsx as n5 } from "react/jsx-runtime";
var Dd = ({ children: e, tab: o, onSelect: t, ...r }) =>
  n5(i5.Trigger, {
    value: o,
    asChild: !0,
    onSelect: t,
    children: n5("button", {
      type: "button",
      className: "ttd-dialog-tab-trigger",
      ...r,
      children: e,
    }),
  });
Dd.displayName = "TTDDialogTabTrigger";
import * as a5 from "@radix-ui/react-tabs";
import { jsx as gB } from "react/jsx-runtime";
var _d = ({ tab: e, children: o, ...t }) => gB(a5.Content, { ...t, value: e, children: o });
_d.displayName = "TTDDialogTab";
import { jsx as ft, jsxs as Cr } from "react/jsx-runtime";
var Tg = 3,
  Di = 1e3,
  bB = me(null),
  xB = me(null),
  Ig = (e) => {
    let o = ge();
    return o.openDialog?.name !== "ttd" ? null : ft(EB, { ...e, tab: o.openDialog.tab });
  },
  EB = Vo("TTDDialogBase", ({ tab: e, ...o }) => {
    let t = Re(),
      r = le(),
      n = vg(null),
      [i, a] = ne(xB),
      [l, s] = Rd(i?.prompt ?? ""),
      d = l.trim(),
      m = (S) => {
        s(S.target.value),
          a((M) => ({ generatedResponse: M?.generatedResponse ?? null, prompt: S.target.value }));
      },
      [c, p] = Rd(!1),
      [u, f] = ne(bB),
      b = async () => {
        if (
          d.length > Di ||
          d.length < Tg ||
          c ||
          u?.rateLimitRemaining === 0 ||
          "__fallback" in o
        ) {
          d.length < Tg && C(new Error(`Prompt is too short (min ${Tg} characters)`)),
            d.length > Di && C(new Error(`Prompt is too long (max ${Di} characters)`));
          return;
        }
        try {
          p(!0), re("ai", "generate", "ttd");
          let {
            generatedResponse: S,
            error: M,
            rateLimit: k,
            rateLimitRemaining: A,
          } = await o.onTextSubmit(d);
          if (
            (typeof S == "string" &&
              a((P) => ({ generatedResponse: S, prompt: P?.prompt ?? null })),
            l5(k) && l5(A) && f({ rateLimit: k, rateLimitRemaining: A }),
            M)
          ) {
            C(M);
            return;
          }
          if (!S) {
            C(new Error("Generation failed"));
            return;
          }
          try {
            await Pd({
              canvasRef: n,
              data: y,
              mermaidToExcalidrawLib: w,
              setError: C,
              mermaidDefinition: S,
            }),
              re("ai", "mermaid parse success", "ttd");
          } catch (P) {
            console.info(`%cTTD mermaid render errror: ${P.message}`, "color: red"),
              console.info(
                `>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TTD mermaid definition render errror: ${P.message}`,
                "color: yellow"
              ),
              re("ai", "mermaid parse failed", "ttd"),
              C(new Error("Generated an invalid diagram :(. You may also try a different prompt."));
          }
        } catch (S) {
          let M = S.message;
          (!M || M === "Failed to fetch") && (M = "Request failed"), C(new Error(M));
        } finally {
          p(!1);
        }
      },
      x = vg(b);
    x.current = b;
    let [w, E] = Rd({ loaded: !1, api: import("@excalidraw/mermaid-to-excalidraw") });
    fB(() => {
      (async () => {
        await w.api, E((M) => ({ ...M, loaded: !0 }));
      })();
    }, [w.api]);
    let y = vg({ elements: [], files: null }),
      [v, C] = Rd(null);
    return ft(Be, {
      className: "ttd-dialog",
      onCloseRequest: () => {
        t.setOpenDialog(null);
      },
      size: 1200,
      title: !1,
      ...o,
      autofocus: !1,
      children: Cr(o5, {
        dialog: "ttd",
        tab: e,
        children: [
          "__fallback" in o && o.__fallback
            ? ft("p", { className: "dialog-mermaid-title", children: g("mermaid.title") })
            : Cr(wg, {
                children: [
                  ft(Dd, {
                    tab: "text-to-diagram",
                    children: Cr("div", {
                      style: { display: "flex", alignItems: "center" },
                      children: [
                        g("labels.textToDiagram"),
                        ft("div", {
                          style: {
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            padding: "1px 6px",
                            marginLeft: "10px",
                            fontSize: 10,
                            borderRadius: "12px",
                            background: "var(--color-promo)",
                            color: "var(--color-surface-lowest)",
                          },
                          children: "AI Beta",
                        }),
                      ],
                    }),
                  }),
                  ft(Dd, { tab: "mermaid", children: "Mermaid" }),
                ],
              }),
          ft(_d, {
            className: "ttd-dialog-content",
            tab: "mermaid",
            children: ft(J3, { mermaidToExcalidrawLib: w }),
          }),
          !("__fallback" in o) &&
            Cr(_d, {
              className: "ttd-dialog-content",
              tab: "text-to-diagram",
              children: [
                ft("div", {
                  className: "ttd-dialog-desc",
                  children:
                    "Currently we use Mermaid as a middle step, so you'll get best results if you describe a diagram, workflow, flow chart, and similar.",
                }),
                Cr(Md, {
                  children: [
                    ft(Ai, {
                      label: g("labels.prompt"),
                      panelAction: { action: b, label: "Generate", icon: Pn },
                      onTextSubmitInProgess: c,
                      panelActionDisabled: d.length > Di || u?.rateLimitRemaining === 0,
                      renderTopRight: () =>
                        u
                          ? Cr("div", {
                              className: "ttd-dialog-rate-limit",
                              style: {
                                fontSize: 12,
                                marginLeft: "auto",
                                color: u.rateLimitRemaining === 0 ? "var(--color-danger)" : void 0,
                              },
                              children: [u.rateLimitRemaining, " requests left today"],
                            })
                          : null,
                      renderSubmitShortcut: () => ft(Ld, {}),
                      renderBottomRight: () => {
                        if (typeof i?.generatedResponse == "string")
                          return Cr("div", {
                            className: "excalidraw-link",
                            style: { marginLeft: "auto", fontSize: 14 },
                            onClick: () => {
                              typeof i?.generatedResponse == "string" &&
                                (nl(i.generatedResponse),
                                r({ openDialog: { name: "ttd", tab: "mermaid" } }));
                            },
                            children: ["View as Mermaid", ft(lr, { icon: Pn })],
                          });
                        let S = d.length / Di;
                        return S > 0.8
                          ? Cr("div", {
                              style: {
                                marginLeft: "auto",
                                fontSize: 12,
                                fontFamily: "monospace",
                                color: S > 1 ? "var(--color-danger)" : void 0,
                              },
                              children: ["Length: ", d.length, "/", Di],
                            })
                          : null;
                      },
                      children: ft(Cd, {
                        onChange: m,
                        input: l,
                        placeholder: "Describe what you want to see...",
                        onKeyboardSubmit: () => {
                          x.current();
                        },
                      }),
                    }),
                    ft(Ai, {
                      label: "Preview",
                      panelAction: {
                        action: () => {
                          console.info("Panel action clicked"), Ad({ app: t, data: y });
                        },
                        label: "Insert",
                        icon: Pn,
                      },
                      children: ft(kd, { canvasRef: n, error: v, loaded: w.loaded }),
                    }),
                  ],
                }),
              ],
            }),
        ],
      }),
    });
  });
import { round as X5 } from "@excalidraw/math";
import DF from "clsx";
import _F from "lodash.throttle";
import { useEffect as K5, useMemo as Og, useState as RF, memo as NF } from "react";
import { STATS_PANELS as Ud } from "@excalidraw/common";
import { getCommonBounds as BF } from "@excalidraw/element";
import { getUncroppedWidthAndHeight as FF } from "@excalidraw/element";
import { isElbowArrow as OF, isImageElement as zg } from "@excalidraw/element";
import { frameAndChildrenSelectedTogether as zF } from "@excalidraw/element";
import { elementsAreInSameGroup as HF } from "@excalidraw/element";
import { degreesToRadians as u5, radiansToDegrees as b5 } from "@excalidraw/math";
import { getBoundTextElement as h5 } from "@excalidraw/element";
import { isArrowElement as g5, isElbowArrow as AB } from "@excalidraw/element";
import { updateBindings as f5 } from "@excalidraw/element";
import CB from "clsx";
import { useEffect as m5, useRef as Bd, useState as SB } from "react";
import { EVENT as Ni, KEYS as kB, cloneJSON as Cg } from "@excalidraw/common";
import { deepCopyElement as MB } from "@excalidraw/element";
import { CaptureUpdateAction as p5 } from "@excalidraw/element";
import { pointFrom as Sr, pointRotateRads as Nd } from "@excalidraw/math";
import { getBoundTextElement as yB } from "@excalidraw/element";
import { isFrameLikeElement as c5 } from "@excalidraw/element";
import {
  getSelectedGroupIds as wB,
  getElementsInGroup as vB,
  isInGroup as TB,
} from "@excalidraw/element";
import { getFrameChildren as IB } from "@excalidraw/element";
import { updateBindings as s5 } from "@excalidraw/element";
var d5 = 0.01,
  il = 10,
  Ct = (e, o) => !(o === "angle" && c5(e)),
  Me = (e, o) => {
    let t = e + o / 2;
    return t - (t % o);
  },
  _i = (e, o, t) =>
    Object.keys(e)
      .map((r) => ({ original: (t ?? o).get(r), latest: o.get(r) }))
      .filter((r) => r.original !== void 0 && r.latest !== void 0);
var cn = (e, o, t, r, n, i = !0) => {
    let a = r.getNonDeletedElementsMap(),
      l = a.get(t.id);
    if (!l) return;
    let [s, d] = [t.x + t.width / 2, t.y + t.height / 2],
      [m, c] = Nd(Sr(t.x, t.y), Sr(s, d), t.angle),
      p = e - m,
      u = o - c,
      [f, b] = Nd(Sr(e, o), Sr(s + p, d + u), -t.angle);
    r.mutateElement(l, { x: f, y: b }, { informMutation: i, isDragging: !1 }), s5(l, r);
    let x = yB(t, n);
    if (x) {
      let w = a.get(x.id);
      w && r.mutateElement(w, { x: x.x + p, y: x.y + u }, { informMutation: i, isDragging: !1 });
    }
    if (c5(t)) {
      let w = IB(n, t.id);
      w.forEach((E) => {
        let y = a.get(E.id);
        if (!y) return;
        let [v, C] = [E.x + E.width / 2, E.y + E.height / 2],
          [S, M] = Nd(Sr(E.x, E.y), Sr(v, C), E.angle),
          k = Math.round(S + p),
          A = Math.round(M + u),
          [P, N] = Nd(Sr(k, A), Sr(v + p, C + u), -E.angle);
        r.mutateElement(y, { x: P, y: N }, { informMutation: i, isDragging: !1 }),
          s5(y, r, { simultaneouslyUpdated: w });
      });
    }
  },
  Ri = (e, o) => {
    let r = wB(o).map((n) => vB(e, n).reduce((i, a) => ((i[a.id] = !0), i), {}));
    return (
      e
        .filter((n) => !TB(n))
        .forEach((n) => {
          r.push({ [n.id]: !0 });
        }),
      r
    );
  };
import { jsx as Sg, jsxs as PB } from "react/jsx-runtime";
var LB = ({
    label: e,
    icon: o,
    dragInputCallback: t,
    value: r,
    elements: n,
    editable: i = !0,
    shouldKeepAspectRatio: a,
    property: l,
    scene: s,
    appState: d,
    sensitivity: m = 1,
    dragFinishedCallback: c,
  }) => {
    let p = Re(),
      u = le(),
      f = Bd(null),
      b = Bd(null),
      [x, w] = SB(r.toString()),
      E = Bd(null);
    E.current ||
      (E.current = {
        originalAppState: Cg(d),
        originalElements: n,
        lastUpdatedValue: x,
        updatePending: !1,
      }),
      m5(() => {
        let C = r.toString();
        w(C), (E.current.lastUpdatedValue = C);
      }, [r]);
    let y = (C, S, M) => {
        if (!E.current.updatePending) return !1;
        E.current.updatePending = !1;
        let k = Number(C);
        if (isNaN(k)) {
          w(r.toString());
          return;
        }
        let A = Number(k.toFixed(2)),
          P = Number(r);
        (isNaN(P) || Math.abs(A - P) >= d5) &&
          ((E.current.lastUpdatedValue = C),
          t({
            accumulatedChange: 0,
            instantChange: 0,
            originalElements: S,
            originalElementsMap: p.scene.getNonDeletedElementsMap(),
            shouldKeepAspectRatio: a,
            shouldChangeByStepSize: !1,
            scene: s,
            nextValue: A,
            property: l,
            originalAppState: M,
            setInputValue: (N) => w(String(N)),
            app: p,
            setAppState: u,
          }),
          p.syncActionResult({ captureUpdate: p5.IMMEDIATELY }));
      },
      v = Bd({});
    return (
      (v.current.handleInputValue = y),
      m5(() => {
        let C = f.current,
          S = v.current;
        return () => {
          let M = C?.value;
          M && S.handleInputValue?.(M, E.current.originalElements, E.current.originalAppState),
            window.removeEventListener(Ni.POINTER_MOVE, S.onPointerMove, !1),
            window.removeEventListener(Ni.POINTER_UP, S.onPointerUp, !1);
        };
      }, [i]),
      i
        ? PB("div", {
            className: CB("drag-input-container", !i && "disabled"),
            "data-testid": e,
            children: [
              Sg("div", {
                className: "drag-input-label",
                ref: b,
                onPointerDown: (C) => {
                  if (f.current && i) {
                    document.body.classList.add("excalidraw-cursor-resize");
                    let S = Number(f.current.value);
                    isNaN(S) && (S = 0);
                    let M = null,
                      k = p.scene
                        .getNonDeletedElements()
                        .reduce((_, R) => (_.set(R.id, MB(R)), _), new Map()),
                      A = n.map((_) => k.get(_.id)),
                      P = Cg(d),
                      N = 0,
                      O = 0,
                      U = (_) => {
                        if (M && k !== null && A !== null) {
                          let R = _.clientX - M.x;
                          R !== 0 &&
                            ((O += R),
                            Math.abs(O) >= m &&
                              ((O = Math.sign(O) * Math.floor(Math.abs(O) / m)),
                              (N += O),
                              t({
                                accumulatedChange: N,
                                instantChange: O,
                                originalElements: A,
                                originalElementsMap: k,
                                shouldKeepAspectRatio: a,
                                shouldChangeByStepSize: _.shiftKey,
                                property: l,
                                scene: s,
                                originalAppState: P,
                                setInputValue: (X) => w(String(X)),
                                app: p,
                                setAppState: u,
                              }),
                              (O = 0)));
                        }
                        M = { x: _.clientX, y: _.clientY };
                      },
                      J = () => {
                        window.removeEventListener(Ni.POINTER_MOVE, U, !1),
                          p.syncActionResult({ captureUpdate: p5.IMMEDIATELY }),
                          c?.({ app: p, setAppState: u, originalElements: A, originalAppState: P }),
                          (M = null),
                          (N = 0),
                          (O = 0),
                          (A = null),
                          (k = null),
                          document.body.classList.remove("excalidraw-cursor-resize"),
                          window.removeEventListener(Ni.POINTER_UP, J, !1);
                      };
                    (v.current.onPointerMove = U),
                      (v.current.onPointerUp = J),
                      window.addEventListener(Ni.POINTER_MOVE, U, !1),
                      window.addEventListener(Ni.POINTER_UP, J, !1);
                  }
                },
                onPointerEnter: () => {
                  b.current && (b.current.style.cursor = "ew-resize");
                },
                children: o ? Sg(lr, { icon: o }) : e,
              }),
              Sg("input", {
                className: "drag-input",
                autoComplete: "off",
                spellCheck: "false",
                onKeyDown: (C) => {
                  if (i) {
                    let S = C.target;
                    S instanceof HTMLInputElement &&
                      C.key === kB.ENTER &&
                      (y(S.value, n, d), p.focusContainer());
                  }
                },
                ref: f,
                value: x,
                onChange: (C) => {
                  (E.current.updatePending = !0), w(C.target.value);
                },
                onFocus: (C) => {
                  C.target.select(),
                    (E.current.originalElements = n),
                    (E.current.originalAppState = Cg(d));
                },
                onBlur: (C) => {
                  x
                    ? i && y(C.target.value, E.current.originalElements, E.current.originalAppState)
                    : w(r.toString());
                },
                disabled: !i,
              }),
            ],
          })
        : null
    );
  },
  Qe = LB;
import { jsx as NB } from "react/jsx-runtime";
var DB = 15,
  _B = ({
    accumulatedChange: e,
    originalElements: o,
    shouldChangeByStepSize: t,
    nextValue: r,
    scene: n,
  }) => {
    let i = n.getNonDeletedElementsMap(),
      a = o[0];
    if (a && !AB(a)) {
      let l = i.get(a.id);
      if (!l) return;
      if (r !== void 0) {
        let u = u5(r);
        n.mutateElement(l, { angle: u }), f5(l, n);
        let f = h5(l, i);
        f && !g5(l) && n.mutateElement(f, { angle: u });
        return;
      }
      let s = Math.round(b5(a.angle) * 100) / 100,
        d = Math.round(e),
        m = (s + d) % 360;
      t && (m = Me(m, DB)), (m = m < 0 ? m + 360 : m);
      let c = u5(m);
      n.mutateElement(l, { angle: c }), f5(l, n);
      let p = h5(l, i);
      p && !g5(l) && n.mutateElement(p, { angle: c });
    }
  },
  RB = ({ element: e, scene: o, appState: t, property: r }) =>
    NB(Qe, {
      label: "A",
      icon: Ql,
      value: Math.round((b5(e.angle) % 360) * 100) / 100,
      elements: [e],
      dragInputCallback: _B,
      editable: Ct(e, "angle"),
      scene: o,
      appState: t,
      property: r,
    }),
  x5 = RB;
import { jsx as FB } from "react/jsx-runtime";
var E5 = 5,
  BB = ({ property: e, scene: o, appState: t, setAppState: r }) =>
    FB(Qe, {
      label: "Grid step",
      sensitivity: 8,
      elements: [],
      dragInputCallback: ({
        nextValue: n,
        instantChange: i,
        shouldChangeByStepSize: a,
        setInputValue: l,
      }) => {
        r((s) => {
          let d;
          return (
            n ? (d = n) : i && (d = a ? Me(s.gridStep + E5 * Math.sign(i), E5) : s.gridStep + i),
            d ? ((d = $f(d)), l(d), { gridStep: d }) : (l(s.gridStep), null)
          );
        });
      },
      scene: o,
      value: t.gridStep,
      property: e,
      appState: t,
    }),
  y5 = BB;
import { clamp as Fd, round as kg } from "@excalidraw/math";
import { MIN_WIDTH_OR_HEIGHT as Od } from "@excalidraw/common";
import { MINIMAL_CROP_SIZE as w5, getUncroppedWidthAndHeight as I5 } from "@excalidraw/element";
import { resizeSingleElement as v5 } from "@excalidraw/element";
import { isImageElement as C5 } from "@excalidraw/element";
import { isFrameLikeElement as Mg } from "@excalidraw/element";
import { getElementsInResizingFrame as Lg } from "@excalidraw/element";
import { replaceAllElementsInFrame as S5 } from "@excalidraw/element";
import { jsx as UB } from "react/jsx-runtime";
var T5 = 10,
  OB = (e) => e.type === "image",
  zB = ({
    accumulatedChange: e,
    originalElements: o,
    originalElementsMap: t,
    shouldKeepAspectRatio: r,
    shouldChangeByStepSize: n,
    nextValue: i,
    property: a,
    originalAppState: l,
    instantChange: s,
    scene: d,
    app: m,
    setAppState: c,
  }) => {
    let p = d.getNonDeletedElementsMap(),
      u = o[0],
      f = p.get(u.id);
    if (u && f) {
      let b = r || OB(u),
        x = u.width / u.height;
      if (l.croppingElementId === u.id) {
        let w = p.get(u.id);
        if (!w || !C5(w) || !w.crop) return;
        let E = w.crop,
          y = { ...E },
          v = w.scale[0] === -1,
          C = w.scale[1] === -1,
          { width: S, height: M } = I5(w),
          k = E.naturalWidth / S,
          A = E.naturalHeight / M,
          P = v ? E.width + E.x : E.naturalWidth - E.x,
          N = C ? E.height + E.y : E.naturalHeight - E.y,
          O = w5 * k,
          U = w5 * A;
        if (i !== void 0) {
          if (a === "width") {
            let $ = i * k,
              W = Fd($, O, P);
            y = { ...y, width: W, x: v ? E.x + E.width - W : E.x };
          } else if (a === "height") {
            let $ = i * A,
              W = Fd($, U, N);
            y = { ...y, height: W, y: C ? E.y + E.height - W : E.y };
          }
          d.mutateElement(w, {
            crop: y,
            width: y.width / (E.naturalWidth / S),
            height: y.height / (E.naturalHeight / M),
          });
          return;
        }
        let J = a === "width" ? s : 0,
          _ = a === "height" ? s : 0,
          R = Fd(E.width + J, O, P),
          X = Fd(E.height + _, O, N);
        (y = {
          ...E,
          x: v ? E.x + E.width - R : E.x,
          y: C ? E.y + E.height - X : E.y,
          width: R,
          height: X,
        }),
          d.mutateElement(w, {
            crop: y,
            width: y.width / (E.naturalWidth / S),
            height: y.height / (E.naturalHeight / M),
          });
        return;
      }
      if (i !== void 0) {
        let w = Math.max(a === "width" ? i : b ? i * x : u.width, Od),
          E = Math.max(a === "height" ? i : b ? i / x : u.height, Od);
        if (
          (v5(w, E, f, u, t, d, a === "width" ? "e" : "s", { shouldMaintainAspectRatio: b }), Mg(f))
        ) {
          let y = Lg(d.getElementsIncludingDeleted(), f, l, d.getNonDeletedElementsMap()),
            v = S5(d.getElementsIncludingDeleted(), y, f, m);
          d.replaceAllElements(v);
        }
        return;
      }
      {
        let w = a === "width" ? e : 0,
          E = a === "height" ? e : 0,
          y = Math.max(0, u.width + w);
        a === "width" && (n ? (y = Me(y, T5)) : (y = Math.round(y)));
        let v = Math.max(0, u.height + E);
        if (
          (a === "height" && (n ? (v = Me(v, T5)) : (v = Math.round(v))),
          b &&
            (a === "width"
              ? (v = Math.round((y / x) * 100) / 100)
              : (y = Math.round(v * x * 100) / 100)),
          (v = Math.max(Od, v)),
          (y = Math.max(Od, y)),
          v5(y, v, f, u, t, d, a === "width" ? "e" : "s", { shouldMaintainAspectRatio: b }),
          Mg(f))
        ) {
          let C = Lg(d.getElementsIncludingDeleted(), f, l, d.getNonDeletedElementsMap());
          c({ elementsToHighlight: C });
        }
      }
    }
  },
  HB = ({ setAppState: e, app: o, originalElements: t, originalAppState: r }) => {
    let n = o.scene.getNonDeletedElementsMap(),
      i = t?.[0],
      a = i && n.get(i.id);
    if (a && Mg(a)) {
      let l = Lg(o.scene.getElementsIncludingDeleted(), a, r, o.scene.getNonDeletedElementsMap()),
        s = S5(o.scene.getElementsIncludingDeleted(), l, a, o);
      o.scene.replaceAllElements(s), e({ elementsToHighlight: null });
    }
  },
  GB = ({ property: e, element: o, scene: t, appState: r }) => {
    let n = kg(e === "width" ? o.width : o.height, 2);
    if (r.croppingElementId && r.croppingElementId === o.id && C5(o) && o.crop) {
      let { width: i, height: a } = I5(o);
      if (e === "width") {
        let l = i / o.crop.naturalWidth;
        n = kg(o.crop.width * l, 2);
      }
      if (e === "height") {
        let l = a / o.crop.naturalHeight;
        n = kg(o.crop.height * l, 2);
      }
    }
    return UB(Qe, {
      label: e === "width" ? "W" : "H",
      elements: [o],
      dragInputCallback: zB,
      value: n,
      editable: Ct(o, e),
      scene: t,
      appState: r,
      property: e,
      dragFinishedCallback: HB,
    });
  },
  Pg = GB;
import { getBoundTextElement as YB, redrawTextBoundingBox as WB } from "@excalidraw/element";
import { hasBoundTextElement as VB, isTextElement as M5 } from "@excalidraw/element";
import { jsx as $B } from "react/jsx-runtime";
var k5 = 4,
  XB = 4,
  KB = ({
    accumulatedChange: e,
    originalElements: o,
    shouldChangeByStepSize: t,
    nextValue: r,
    scene: n,
  }) => {
    let i = n.getNonDeletedElementsMap(),
      a = o[0];
    if (a) {
      let l = i.get(a.id);
      if (!l || !M5(l)) return;
      let s;
      if (r !== void 0) s = Math.max(Math.round(r), k5);
      else if (a.type === "text") {
        let d = Math.round(a.fontSize),
          m = Math.round(e);
        (s = Math.max(d + m, k5)), t && (s = Me(s, XB));
      }
      s && (n.mutateElement(l, { fontSize: s }), WB(l, n.getContainerElement(l), n));
    }
  },
  ZB = ({ element: e, scene: o, appState: t, property: r }) => {
    let n = M5(e) ? e : VB(e) ? YB(e, o.getNonDeletedElementsMap()) : null;
    return n
      ? $B(Qe, {
          label: "F",
          value: Math.round(n.fontSize * 10) / 10,
          elements: [n],
          dragInputCallback: KB,
          icon: Ur,
          appState: t,
          scene: o,
          property: r,
        })
      : null;
  },
  L5 = ZB;
import { degreesToRadians as P5, radiansToDegrees as _5 } from "@excalidraw/math";
import { getBoundTextElement as A5 } from "@excalidraw/element";
import { isArrowElement as D5 } from "@excalidraw/element";
import { isInGroup as Ag } from "@excalidraw/element";
import { jsx as QB } from "react/jsx-runtime";
var jB = 15,
  qB = ({
    accumulatedChange: e,
    originalElements: o,
    shouldChangeByStepSize: t,
    nextValue: r,
    property: n,
    scene: i,
  }) => {
    let a = i.getNonDeletedElementsMap(),
      l = o.map((d) => a.get(d.id)).filter((d) => d && !Ag(d) && Ct(d, n)),
      s = o.filter((d) => !Ag(d) && Ct(d, n));
    if (r !== void 0) {
      let d = P5(r);
      for (let m of l) {
        if (!m) continue;
        i.mutateElement(m, { angle: d });
        let c = A5(m, a);
        c && !D5(m) && i.mutateElement(c, { angle: d });
      }
      i.triggerUpdate();
      return;
    }
    for (let d = 0; d < l.length; d++) {
      let m = l[d];
      if (!m) continue;
      let c = s[d],
        p = Math.round(_5(c.angle) * 100) / 100,
        u = Math.round(e),
        f = (p + u) % 360;
      t && (f = Me(f, jB)), (f = f < 0 ? f + 360 : f);
      let b = P5(f);
      i.mutateElement(m, { angle: b });
      let x = A5(m, a);
      x && !D5(m) && i.mutateElement(x, { angle: b });
    }
    i.triggerUpdate();
  },
  JB = ({ elements: e, scene: o, appState: t, property: r }) => {
    let n = e.filter((s) => !Ag(s) && Ct(s, "angle")),
      i = n.map((s) => Math.round((_5(s.angle) % 360) * 100) / 100),
      a = new Set(i).size === 1 ? i[0] : "Mixed",
      l = n.some((s) => Ct(s, "angle"));
    return QB(Qe, {
      label: "A",
      icon: Ql,
      value: a,
      elements: e,
      dragInputCallback: qB,
      editable: l,
      appState: t,
      scene: o,
      property: r,
    });
  },
  R5 = JB;
import { pointFrom as N5 } from "@excalidraw/math";
import { useMemo as eF } from "react";
import { MIN_WIDTH_OR_HEIGHT as kr } from "@excalidraw/common";
import {
  getElementsInResizingFrame as Dg,
  isFrameLikeElement as _g,
  replaceAllElementsInFrame as O5,
  updateBoundElements as tF,
} from "@excalidraw/element";
import { rescalePointsInElement as oF, resizeSingleElement as B5 } from "@excalidraw/element";
import { getBoundTextElement as rF, handleBindTextResize as nF } from "@excalidraw/element";
import { isTextElement as z5 } from "@excalidraw/element";
import { getCommonBounds as zd } from "@excalidraw/element";
import { jsx as dF } from "react/jsx-runtime";
var Bi = 10,
  iF = (e, o, t, r) => {
    let n = r.x - e,
      i = r.y - o,
      a = r.width * t,
      l = r.height * t,
      s = e + n * t,
      d = o + i * t;
    return {
      width: a,
      height: l,
      x: s,
      y: d,
      ...oF(r, a, l, !1),
      ...(z5(r) ? { fontSize: r.fontSize * t } : {}),
    };
  },
  aF = (e, o, t, r, n, i, a, l) => {
    let s = l.getNonDeletedElementsMap(),
      d = iF(e, o, r, i);
    l.mutateElement(n, d);
    let m = rF(i, a);
    if (m) {
      let c = m.fontSize * r;
      tF(n, l, { newSize: { width: d.width, height: d.height } });
      let p = s.get(m.id);
      p && z5(p) && (l.mutateElement(p, { fontSize: c }), nF(n, l, t === "width" ? "e" : "s", !0));
    }
  },
  F5 = (e, o, t, r, n, i, a, l, s, d) => {
    i === "width" ? (o = Math.round((e / r) * 100) / 100) : (e = Math.round(o * r * 100) / 100);
    let m = o / t;
    for (let c = 0; c < l.length; c++) {
      let p = l[c],
        u = a[c];
      aF(n[0], n[1], i, m, u, p, s, d);
    }
  },
  lF = ({
    accumulatedChange: e,
    originalElements: o,
    originalElementsMap: t,
    originalAppState: r,
    shouldChangeByStepSize: n,
    nextValue: i,
    scene: a,
    property: l,
    setAppState: s,
    app: d,
  }) => {
    let m = a.getNonDeletedElementsMap(),
      c = Ri(o, r);
    if (i !== void 0) {
      for (let b of c) {
        let x = _i(b, m, t);
        if (x.length > 1) {
          let w = x.map((O) => O.latest),
            E = x.map((O) => O.original),
            [y, v, C, S] = zd(E),
            M = C - y,
            k = S - v,
            A = M / k,
            P = Math.max(kr, l === "width" ? Math.max(0, i) : M),
            N = Math.max(kr, l === "height" ? Math.max(0, i) : k);
          F5(P, N, k, A, N5(y, v), l, w, E, t, a);
        } else {
          let [w] = x,
            E = w?.latest,
            y = w?.original;
          if (E && y && Ct(E, l)) {
            let v = l === "width" ? Math.max(0, i) : E.width;
            l === "width" && (n ? (v = Me(v, Bi)) : (v = Math.round(v)));
            let C = l === "height" ? Math.max(0, i) : E.height;
            if (
              (l === "height" && (n ? (C = Me(C, Bi)) : (C = Math.round(C))),
              (v = Math.max(kr, v)),
              (C = Math.max(kr, C)),
              B5(v, C, E, y, t, a, l === "width" ? "e" : "s", { shouldInformMutation: !1 }),
              _g(E))
            ) {
              let S = Dg(a.getElementsIncludingDeleted(), E, r, a.getNonDeletedElementsMap()),
                M = O5(a.getElementsIncludingDeleted(), S, E, d);
              a.replaceAllElements(M);
            }
          }
        }
      }
      a.triggerUpdate();
      return;
    }
    let p = l === "width" ? e : 0,
      u = l === "height" ? e : 0,
      f = [];
    for (let b of c) {
      let x = _i(b, m, t);
      if (x.length > 1) {
        let w = x.map((O) => O.latest),
          E = x.map((O) => O.original),
          [y, v, C, S] = zd(E),
          M = C - y,
          k = S - v,
          A = M / k,
          P = Math.max(0, M + p);
        l === "width" && (n ? (P = Me(P, Bi)) : (P = Math.round(P)));
        let N = Math.max(0, k + u);
        l === "height" && (n ? (N = Me(N, Bi)) : (N = Math.round(N))),
          (P = Math.max(kr, P)),
          (N = Math.max(kr, N)),
          F5(P, N, k, A, N5(y, v), l, w, E, t, a);
      } else {
        let [w] = x,
          E = w?.latest,
          y = w?.original;
        if (E && y && Ct(E, l)) {
          let v = Math.max(0, y.width + p);
          l === "width" && (n ? (v = Me(v, Bi)) : (v = Math.round(v)));
          let C = Math.max(0, y.height + u);
          if (
            (l === "height" && (n ? (C = Me(C, Bi)) : (C = Math.round(C))),
            (v = Math.max(kr, v)),
            (C = Math.max(kr, C)),
            B5(v, C, E, y, t, a, l === "width" ? "e" : "s", { shouldInformMutation: !1 }),
            _g(E))
          ) {
            let S = Dg(a.getElementsIncludingDeleted(), E, r, a.getNonDeletedElementsMap());
            f.push(...S);
          }
        }
      }
    }
    s({ elementsToHighlight: f }), a.triggerUpdate();
  },
  sF = ({ setAppState: e, app: o, originalElements: t, originalAppState: r }) => {
    let n = o.scene.getNonDeletedElementsMap(),
      i = t?.[0],
      a = i && n.get(i.id);
    if (a && _g(a)) {
      let l = Dg(o.scene.getElementsIncludingDeleted(), a, r, o.scene.getNonDeletedElementsMap()),
        s = O5(o.scene.getElementsIncludingDeleted(), l, a, o);
      o.scene.replaceAllElements(s), e({ elementsToHighlight: null });
    }
  },
  cF = ({ property: e, elements: o, elementsMap: t, atomicUnits: r, scene: n, appState: i }) => {
    let a = eF(
        () =>
          r.map((d) => {
            let m = _i(d, t);
            if (m.length > 1) {
              let [p, u, f, b] = zd(m.map((x) => x.latest));
              return Math.round((e === "width" ? f - p : b - u) * 100) / 100;
            }
            let [c] = m;
            return Math.round((e === "width" ? c.latest.width : c.latest.height) * 100) / 100;
          }),
        [t, r, e]
      ),
      l = new Set(a).size === 1 ? Math.round(a[0] * 100) / 100 : "Mixed",
      s = a.length > 0;
    return dF(Qe, {
      label: e === "width" ? "W" : "H",
      elements: o,
      dragInputCallback: lF,
      value: l,
      editable: s,
      appState: i,
      property: e,
      scene: n,
      dragFinishedCallback: sF,
    });
  },
  Rg = cF;
import { getBoundTextElement as mF, redrawTextBoundingBox as H5 } from "@excalidraw/element";
import { hasBoundTextElement as pF, isTextElement as uF } from "@excalidraw/element";
import { isInGroup as hF } from "@excalidraw/element";
import { jsx as EF } from "react/jsx-runtime";
var G5 = 4,
  gF = 4,
  fF = (e, o) =>
    e.reduce((t, r) => {
      if (!r || hF(r)) return t;
      if (uF(r)) return t.push(r), t;
      if (pF(r)) {
        let n = mF(r, o);
        if (n) return t.push(n), t;
      }
      return t;
    }, []),
  bF = ({
    accumulatedChange: e,
    originalElements: o,
    shouldChangeByStepSize: t,
    nextValue: r,
    scene: n,
  }) => {
    let i = n.getNonDeletedElementsMap(),
      a = o.map((s) => i.get(s.id)),
      l;
    if (r) {
      l = Math.max(Math.round(r), G5);
      for (let s of a) n.mutateElement(s, { fontSize: l }), H5(s, n.getContainerElement(s), n);
      n.triggerUpdate();
    } else {
      let s = o;
      for (let d = 0; d < a.length; d++) {
        let m = a[d],
          c = s[d],
          p = Math.round(c.fontSize),
          u = Math.round(e),
          f = Math.max(p + u, G5);
        t && (f = Me(f, gF)),
          n.mutateElement(m, { fontSize: f }),
          H5(m, n.getContainerElement(m), n);
      }
      n.triggerUpdate();
    }
  },
  xF = ({ elements: e, scene: o, appState: t, property: r, elementsMap: n }) => {
    let i = fF(e, n);
    if (!i.length) return null;
    let a = i.map((d) => Math.round(d.fontSize * 10) / 10),
      l = new Set(a).size === 1 ? a[0] : "Mixed",
      s = a.length > 0;
    return EF(Qe, {
      label: "F",
      icon: Ur,
      elements: i,
      dragInputCallback: bF,
      value: l,
      editable: s,
      scene: o,
      property: r,
      appState: t,
    });
  },
  U5 = xF;
import { pointFrom as Mr, pointRotateRads as Hd } from "@excalidraw/math";
import { useMemo as yF } from "react";
import { isTextElement as wF } from "@excalidraw/element";
import { getCommonBounds as Ng } from "@excalidraw/element";
import { jsx as SF } from "react/jsx-runtime";
var vF = (e, o, t, r, n, i) => {
    for (let a = 0; a < r.length; a++) {
      let l = r[a],
        [s, d] = [l.x + l.width / 2, l.y + l.height / 2],
        [m, c] = Hd(Mr(l.x, l.y), Mr(s, d), l.angle),
        p = e === "x" ? Math.round(m + o) : m,
        u = e === "y" ? Math.round(c + t) : c;
      cn(p, u, l, i, n, !1);
    }
  },
  TF = (e, o, t, r, n) => {
    let i = n.getNonDeletedElementsMap(),
      [a, l, ,] = Ng(t),
      s = e - a,
      d = o - l;
    for (let m = 0; m < t.length; m++) {
      let c = t[m],
        p = i.get(c.id);
      if (p && (!wF(p) || !p.containerId)) {
        let [u, f] = [p.x + p.width / 2, p.y + p.height / 2],
          [b, x] = Hd(Mr(p.x, p.y), Mr(u, f), p.angle);
        cn(b + s, x + d, c, n, r, !1);
      }
    }
  },
  IF = ({
    accumulatedChange: e,
    originalElements: o,
    originalElementsMap: t,
    shouldChangeByStepSize: r,
    nextValue: n,
    property: i,
    scene: a,
    originalAppState: l,
  }) => {
    let s = a.getNonDeletedElementsMap();
    if (n !== void 0) {
      for (let p of Ri(o, l)) {
        let u = _i(p, s, t);
        if (u.length > 1) {
          let [f, b, ,] = Ng(u.map((E) => E.latest));
          TF(
            i === "x" ? n : f,
            i === "y" ? n : b,
            u.map((E) => E.original),
            t,
            a
          );
        } else {
          let f = u[0]?.original,
            b = u[0]?.latest;
          if (f && b && Ct(b, i)) {
            let [x, w] = [f.x + f.width / 2, f.y + f.height / 2],
              [E, y] = Hd(Mr(f.x, f.y), Mr(x, w), f.angle);
            cn(i === "x" ? n : E, i === "y" ? n : y, f, a, t, !1);
          }
        }
      }
      a.triggerUpdate();
      return;
    }
    let d = r ? Me(e, il) : e;
    vF(i, i === "x" ? d : 0, i === "y" ? d : 0, o, t, a), a.triggerUpdate();
  },
  CF = ({ property: e, elements: o, elementsMap: t, atomicUnits: r, scene: n, appState: i }) => {
    let a = yF(
        () =>
          r.map((s) => {
            let d = Object.keys(s)
              .map((b) => t.get(b))
              .filter((b) => b !== void 0);
            if (d.length > 1) {
              let [b, x] = Ng(d);
              return Math.round((e === "x" ? b : x) * 100) / 100;
            }
            let [m] = d,
              [c, p] = [m.x + m.width / 2, m.y + m.height / 2],
              [u, f] = Hd(Mr(m.x, m.y), Mr(c, p), m.angle);
            return Math.round((e === "x" ? u : f) * 100) / 100;
          }),
        [r, t, e]
      ),
      l = new Set(a).size === 1 ? a[0] : "Mixed";
    return SF(Qe, {
      label: e === "x" ? "X" : "Y",
      elements: o,
      dragInputCallback: IF,
      value: l,
      property: e,
      scene: n,
      appState: i,
    });
  },
  Bg = CF;
import { clamp as al, pointFrom as Gd, pointRotateRads as W5, round as Y5 } from "@excalidraw/math";
import {
  getFlipAdjustedCropPosition as kF,
  getUncroppedWidthAndHeight as MF,
} from "@excalidraw/element";
import { isImageElement as V5 } from "@excalidraw/element";
import { jsx as AF } from "react/jsx-runtime";
var LF = ({
    accumulatedChange: e,
    instantChange: o,
    originalElements: t,
    originalElementsMap: r,
    shouldChangeByStepSize: n,
    nextValue: i,
    property: a,
    scene: l,
    originalAppState: s,
  }) => {
    let d = l.getNonDeletedElementsMap(),
      m = t[0],
      [c, p] = [m.x + m.width / 2, m.y + m.height / 2],
      [u, f] = W5(Gd(m.x, m.y), Gd(c, p), m.angle);
    if (s.croppingElementId === m.id) {
      let y = d.get(m.id);
      if (!y || !V5(y) || !y.crop) return;
      let v = y.crop,
        C = v,
        S = y.scale[0] === -1,
        M = y.scale[1] === -1,
        { width: k, height: A } = MF(y);
      if (i !== void 0) {
        if (a === "x") {
          let O = i * (v.naturalWidth / k);
          S
            ? (C = { ...v, x: al(v.naturalWidth - O - v.width, 0, v.naturalWidth - v.width) })
            : (C = { ...v, x: al(i * (v.naturalWidth / k), 0, v.naturalWidth - v.width) });
        }
        a === "y" &&
          (C = { ...v, y: al(i * (v.naturalHeight / A), 0, v.naturalHeight - v.height) }),
          l.mutateElement(y, { crop: C });
        return;
      }
      let P = (a === "x" ? o : 0) * (S ? -1 : 1),
        N = (a === "y" ? o : 0) * (M ? -1 : 1);
      (C = {
        ...v,
        x: al(v.x + P, 0, v.naturalWidth - v.width),
        y: al(v.y + N, 0, v.naturalHeight - v.height),
      }),
        l.mutateElement(y, { crop: C });
      return;
    }
    if (i !== void 0) {
      cn(a === "x" ? i : u, a === "y" ? i : f, m, l, r);
      return;
    }
    let b = a === "x" ? e : 0,
      x = a === "y" ? e : 0,
      w = a === "x" ? Math.round(n ? Me(m.x + b, il) : u + b) : u,
      E = a === "y" ? Math.round(n ? Me(m.y + x, il) : f + x) : f;
    cn(w, E, m, l, r);
  },
  PF = ({ property: e, element: o, elementsMap: t, scene: r, appState: n }) => {
    let [i, a] = W5(Gd(o.x, o.y), Gd(o.x + o.width / 2, o.y + o.height / 2), o.angle),
      l = Y5(e === "x" ? i : a, 2);
    if (n.croppingElementId === o.id && V5(o) && o.crop) {
      let s = kF(o);
      s && (l = Y5(e === "x" ? s.x : s.y, 2));
    }
    return AF(Qe, {
      label: e === "x" ? "X" : "Y",
      elements: [o],
      dragInputCallback: LF,
      scene: r,
      value: l,
      property: e,
      appState: n,
    });
  },
  Fg = PF;
import { Fragment as Hg, jsx as q, jsxs as St } from "react/jsx-runtime";
var GF = 50,
  ll = (e) => {
    let o = zt(),
      t = e.app.scene.getSceneNonce() || 1,
      r = e.app.scene.getSelectedElements({
        selectedElementIds: o.selectedElementIds,
        includeBoundTextElement: !1,
      }),
      n = br(e.app);
    return q(UF, { ...e, appState: o, sceneNonce: t, selectedElements: r, gridModeEnabled: n });
  },
  Ce = ({ children: e, columns: o = 1, heading: t, style: r, ...n }) =>
    q("div", {
      className: DF("exc-stats__row", { "exc-stats__row--heading": t }),
      style: { gridTemplateColumns: `repeat(${o}, 1fr)`, ...r },
      ...n,
      children: e,
    });
Ce.displayName = "StatsRow";
var Yd = ({ children: e, order: o, style: t, ...r }) =>
  q("div", { className: "exc-stats__rows", style: { order: o, ...t }, ...r, children: e });
Yd.displayName = "StatsRows";
ll.StatsRow = Ce;
ll.StatsRows = Yd;
var UF = NF(
  ({
    app: e,
    onClose: o,
    renderCustomStats: t,
    selectedElements: r,
    appState: n,
    sceneNonce: i,
    gridModeEnabled: a,
  }) => {
    let l = e.scene,
      s = l.getNonDeletedElements(),
      d = l.getNonDeletedElementsMap(),
      m = le(),
      c = r.length === 1 ? r[0] : null,
      p = r.length > 1 ? r : null,
      u = n.croppingElementId && zg(c),
      f = u ? FF(c) : null,
      [b, x] = RF({ width: 0, height: 0 }),
      w = Og(
        () =>
          _F((v) => {
            let C = BF(v);
            x({
              width: Math.round(C[2]) - Math.round(C[0]),
              height: Math.round(C[3]) - Math.round(C[1]),
            });
          }, GF),
        []
      );
    K5(() => {
      w(s);
    }, [i, s, w]),
      K5(() => () => w.cancel(), [w]);
    let E = Og(() => Ri(r, n), [r, n]),
      y = Og(() => zF(r), [r]);
    return q("div", {
      className: "exc-stats",
      children: St(Xe, {
        padding: 3,
        children: [
          St("div", {
            className: "title",
            children: [
              q("h2", { children: g("stats.title") }),
              q("div", { className: "close", onClick: o, children: Bt }),
            ],
          }),
          St(ua, {
            label: q("h3", { children: g("stats.generalStats") }),
            open: !!(n.stats.panels & Ud.generalStats),
            openTrigger: () =>
              m((v) => ({ stats: { open: !0, panels: v.stats.panels ^ Ud.generalStats } })),
            children: [
              St(Yd, {
                children: [
                  q(Ce, { heading: !0, children: g("stats.scene") }),
                  St(Ce, {
                    columns: 2,
                    children: [
                      q("div", { children: g("stats.shapes") }),
                      q("div", { children: s.length }),
                    ],
                  }),
                  St(Ce, {
                    columns: 2,
                    children: [
                      q("div", { children: g("stats.width") }),
                      q("div", { children: b.width }),
                    ],
                  }),
                  St(Ce, {
                    columns: 2,
                    children: [
                      q("div", { children: g("stats.height") }),
                      q("div", { children: b.height }),
                    ],
                  }),
                  a &&
                    St(Hg, {
                      children: [
                        q(Ce, { heading: !0, children: "Canvas" }),
                        q(Ce, {
                          children: q(y5, {
                            property: "gridStep",
                            scene: l,
                            appState: n,
                            setAppState: m,
                          }),
                        }),
                      ],
                    }),
                ],
              }),
              t?.(s, n),
            ],
          }),
          !y &&
            r.length > 0 &&
            q("div", {
              id: "elementStats",
              style: { marginTop: 12 },
              children: q(ua, {
                label: q("h3", { children: g("stats.elementProperties") }),
                open: !!(n.stats.panels & Ud.elementProperties),
                openTrigger: () =>
                  m((v) => ({
                    stats: { open: !0, panels: v.stats.panels ^ Ud.elementProperties },
                  })),
                children: St(Yd, {
                  children: [
                    c &&
                      St(Hg, {
                        children: [
                          u && q(Ce, { heading: !0, children: g("labels.unCroppedDimension") }),
                          n.croppingElementId &&
                            zg(c) &&
                            f &&
                            St(Ce, {
                              columns: 2,
                              children: [
                                q("div", { children: g("stats.width") }),
                                q("div", { children: X5(f.width, 2) }),
                              ],
                            }),
                          n.croppingElementId &&
                            zg(c) &&
                            f &&
                            St(Ce, {
                              columns: 2,
                              children: [
                                q("div", { children: g("stats.height") }),
                                q("div", { children: X5(f.height, 2) }),
                              ],
                            }),
                          q(Ce, {
                            heading: !0,
                            "data-testid": "stats-element-type",
                            style: { margin: "0.3125rem 0" },
                            children: n.croppingElementId
                              ? g("labels.imageCropping")
                              : g(`element.${c.type}`),
                          }),
                          q(Ce, {
                            children: q(Fg, {
                              element: c,
                              property: "x",
                              elementsMap: d,
                              scene: l,
                              appState: n,
                            }),
                          }),
                          q(Ce, {
                            children: q(Fg, {
                              element: c,
                              property: "y",
                              elementsMap: d,
                              scene: l,
                              appState: n,
                            }),
                          }),
                          q(Ce, {
                            children: q(Pg, {
                              property: "width",
                              element: c,
                              scene: l,
                              appState: n,
                            }),
                          }),
                          q(Ce, {
                            children: q(Pg, {
                              property: "height",
                              element: c,
                              scene: l,
                              appState: n,
                            }),
                          }),
                          !OF(c) &&
                            q(Ce, {
                              children: q(x5, {
                                property: "angle",
                                element: c,
                                scene: l,
                                appState: n,
                              }),
                            }),
                          q(Ce, {
                            children: q(L5, {
                              property: "fontSize",
                              element: c,
                              scene: l,
                              appState: n,
                            }),
                          }),
                        ],
                      }),
                    p &&
                      St(Hg, {
                        children: [
                          HF(p) && q(Ce, { heading: !0, children: g("element.group") }),
                          St(Ce, {
                            columns: 2,
                            style: { margin: "0.3125rem 0" },
                            children: [
                              q("div", { children: g("stats.shapes") }),
                              q("div", { children: r.length }),
                            ],
                          }),
                          q(Ce, {
                            children: q(Bg, {
                              property: "x",
                              elements: p,
                              elementsMap: d,
                              atomicUnits: E,
                              scene: l,
                              appState: n,
                            }),
                          }),
                          q(Ce, {
                            children: q(Bg, {
                              property: "y",
                              elements: p,
                              elementsMap: d,
                              atomicUnits: E,
                              scene: l,
                              appState: n,
                            }),
                          }),
                          q(Ce, {
                            children: q(Rg, {
                              property: "width",
                              elements: p,
                              elementsMap: d,
                              atomicUnits: E,
                              scene: l,
                              appState: n,
                            }),
                          }),
                          q(Ce, {
                            children: q(Rg, {
                              property: "height",
                              elements: p,
                              elementsMap: d,
                              atomicUnits: E,
                              scene: l,
                              appState: n,
                            }),
                          }),
                          q(Ce, {
                            children: q(R5, {
                              property: "angle",
                              elements: p,
                              scene: l,
                              appState: n,
                            }),
                          }),
                          q(Ce, {
                            children: q(U5, {
                              property: "fontSize",
                              elements: p,
                              scene: l,
                              appState: n,
                              elementsMap: d,
                            }),
                          }),
                        ],
                      }),
                  ],
                }),
              }),
            }),
        ],
      }),
    });
  },
  (e, o) =>
    e.sceneNonce === o.sceneNonce &&
    e.selectedElements === o.selectedElements &&
    e.appState.stats.panels === o.appState.stats.panels &&
    e.gridModeEnabled === o.gridModeEnabled &&
    e.appState.gridStep === o.appState.gridStep &&
    e.appState.croppingElementId === o.appState.croppingElementId
);
import { useCallback as YF, useEffect as Z5, useState as $5 } from "react";
import { normalizeLink as WF, KEYS as Gg } from "@excalidraw/common";
import {
  defaultGetElementLinkFromSelection as VF,
  getLinkIdAndTypeFromSelection as XF,
} from "@excalidraw/element";
import { jsx as Fi, jsxs as Wd } from "react/jsx-runtime";
var KF = ({
    sourceElementId: e,
    onClose: o,
    appState: t,
    scene: r,
    generateLinkForSelection: n = VF,
  }) => {
    let i = r.getNonDeletedElementsMap(),
      a = i.get(e)?.link ?? null,
      [l, s] = $5(a),
      [d, m] = $5(!1);
    Z5(() => {
      let p = Z(i, t),
        u = a;
      if (p.length > 0 && n) {
        let f = XF(p, t);
        f && (u = WF(n(f.id, f.type)));
      }
      s(u);
    }, [i, t, t.selectedElementIds, a, n]);
    let c = YF(() => {
      if (l && l !== i.get(e)?.link) {
        let p = i.get(e);
        p && r.mutateElement(p, { link: l });
      }
      if (!l && d && e) {
        let p = i.get(e);
        p && r.mutateElement(p, { link: null });
      }
      o?.();
    }, [e, l, i, d, r, o]);
    return (
      Z5(() => {
        let p = (u) => {
          t.openDialog?.name === "elementLinkSelector" && u.key === Gg.ENTER && c(),
            t.openDialog?.name === "elementLinkSelector" && u.key === Gg.ESCAPE && o?.();
        };
        return (
          window.addEventListener("keydown", p),
          () => {
            window.removeEventListener("keydown", p);
          }
        );
      }, [t, o, c]),
      Wd("div", {
        className: "ElementLinkDialog",
        children: [
          Wd("div", {
            className: "ElementLinkDialog__header",
            children: [
              Fi("h2", { children: g("elementLink.title") }),
              Fi("p", { children: g("elementLink.desc") }),
            ],
          }),
          Wd("div", {
            className: "ElementLinkDialog__input",
            children: [
              Fi(xi, {
                value: l ?? "",
                onChange: (p) => {
                  d || m(!0), s(p);
                },
                onKeyDown: (p) => {
                  p.key === Gg.ENTER && c();
                },
                className: "ElementLinkDialog__input-field",
                selectOnRender: !0,
              }),
              a &&
                l &&
                Fi(V, {
                  type: "button",
                  title: g("buttons.remove"),
                  "aria-label": g("buttons.remove"),
                  label: g("buttons.remove"),
                  onClick: () => {
                    s(null), m(!0);
                  },
                  className: "ElementLinkDialog__remove",
                  icon: kt,
                }),
            ],
          }),
          Wd("div", {
            className: "ElementLinkDialog__actions",
            children: [
              Fi(Fo, {
                label: g("buttons.cancel"),
                onClick: () => {
                  o?.();
                },
                style: { marginRight: 10 },
              }),
              Fi(Fo, { label: g("buttons.confirm"), onClick: c, actionType: "primary" }),
            ],
          }),
        ],
      })
    );
  },
  j5 = KF;
import ZF, { useState as $F } from "react";
import { Fragment as jF, jsx as Ug } from "react/jsx-runtime";
var q5 = ({ children: e, onClose: o }) => {
  let [t, r] = $F(!!e),
    { container: n } = Ge(),
    i = ZF.useCallback(() => {
      r(!1), o && o(), n?.focus();
    }, [o, n]);
  return Ug(jF, {
    children:
      t &&
      Ug(Be, {
        size: "small",
        onCloseRequest: i,
        title: g("errorDialog.title"),
        children: Ug("div", { style: { whiteSpace: "pre-wrap" }, children: e }),
      }),
  });
};
import qF from "react";
import { isDarwin as J5, isFirefox as Q5, isWindows as JF } from "@excalidraw/common";
import { KEYS as Ae, getShortcutKey as K } from "@excalidraw/common";
import { Fragment as tT, jsx as F, jsxs as Rt } from "react/jsx-runtime";
var QF = () =>
    Rt("div", {
      className: "HelpDialog__header",
      children: [
        Rt("a", {
          className: "HelpDialog__btn",
          href: "https://docs.excalidraw.com",
          target: "_blank",
          rel: "noopener",
          children: [
            F("div", { className: "HelpDialog__link-icon", children: Im }),
            g("helpDialog.documentation"),
          ],
        }),
        Rt("a", {
          className: "HelpDialog__btn",
          href: "https://plus.excalidraw.com/blog",
          target: "_blank",
          rel: "noopener",
          children: [
            F("div", { className: "HelpDialog__link-icon", children: Im }),
            g("helpDialog.blog"),
          ],
        }),
        Rt("a", {
          className: "HelpDialog__btn",
          href: "https://github.com/excalidraw/excalidraw/issues",
          target: "_blank",
          rel: "noopener noreferrer",
          children: [
            F("div", { className: "HelpDialog__link-icon", children: Zl }),
            g("helpDialog.github"),
          ],
        }),
        Rt("a", {
          className: "HelpDialog__btn",
          href: "https://youtube.com/@excalidraw",
          target: "_blank",
          rel: "noopener noreferrer",
          children: [F("div", { className: "HelpDialog__link-icon", children: nb }), "YouTube"],
        }),
      ],
    }),
  eO = (e) =>
    Rt(tT, {
      children: [
        F("h3", { children: e.title }),
        F("div", { className: "HelpDialog__islands-container", children: e.children }),
      ],
    }),
  Yg = (e) =>
    Rt("div", {
      className: `HelpDialog__island ${e.className}`,
      children: [
        F("h4", { className: "HelpDialog__island-title", children: e.caption }),
        F("div", { className: "HelpDialog__island-content", children: e.children }),
      ],
    });
function* tO(e, o) {
  let t = !0;
  for (let r of e) t || (yield o), (t = !1), yield r;
}
var oO = (e) => e.replace(/\b[a-z]\b/, (o) => o.toUpperCase()),
  G = ({ label: e, shortcuts: o, isOr: t = !0 }) => {
    let r = o.map((n) =>
      (n.endsWith("++") ? [...n.slice(0, -2).split("+"), "+"] : n.split("+")).map((a) =>
        F(rO, { children: oO(a) }, a)
      )
    );
    return Rt("div", {
      className: "HelpDialog__shortcut",
      children: [
        F("div", { children: e }),
        F("div", {
          className: "HelpDialog__key-container",
          children: [...tO(r, t ? g("helpDialog.or") : null)],
        }),
      ],
    });
  },
  rO = (e) => F("kbd", { className: "HelpDialog__key", ...e }),
  eT = ({ onClose: e }) => {
    let o = qF.useCallback(() => {
      e && e();
    }, [e]);
    return F(tT, {
      children: Rt(Be, {
        onCloseRequest: o,
        title: g("helpDialog.title"),
        className: "HelpDialog",
        children: [
          F(QF, {}),
          Rt(eO, {
            title: g("helpDialog.shortcuts"),
            children: [
              Rt(Yg, {
                className: "HelpDialog__island--tools",
                caption: g("helpDialog.tools"),
                children: [
                  F(G, { label: g("toolBar.hand"), shortcuts: [Ae.H] }),
                  F(G, { label: g("toolBar.selection"), shortcuts: [Ae.V, Ae[1]] }),
                  F(G, { label: g("toolBar.rectangle"), shortcuts: [Ae.R, Ae[2]] }),
                  F(G, { label: g("toolBar.diamond"), shortcuts: [Ae.D, Ae[3]] }),
                  F(G, { label: g("toolBar.ellipse"), shortcuts: [Ae.O, Ae[4]] }),
                  F(G, { label: g("toolBar.arrow"), shortcuts: [Ae.A, Ae[5]] }),
                  F(G, { label: g("toolBar.line"), shortcuts: [Ae.L, Ae[6]] }),
                  F(G, { label: g("toolBar.freedraw"), shortcuts: [Ae.P, Ae[7]] }),
                  F(G, { label: g("toolBar.text"), shortcuts: [Ae.T, Ae[8]] }),
                  F(G, { label: g("toolBar.image"), shortcuts: [Ae[9]] }),
                  F(G, { label: g("toolBar.eraser"), shortcuts: [Ae.E, Ae[0]] }),
                  F(G, { label: g("toolBar.frame"), shortcuts: [Ae.F] }),
                  F(G, { label: g("toolBar.laser"), shortcuts: [Ae.K] }),
                  F(G, { label: g("labels.eyeDropper"), shortcuts: [Ae.I, "Shift+S", "Shift+G"] }),
                  F(G, {
                    label: g("helpDialog.editLineArrowPoints"),
                    shortcuts: [K("CtrlOrCmd+Enter")],
                  }),
                  F(G, { label: g("helpDialog.editText"), shortcuts: [K("Enter")] }),
                  F(G, {
                    label: g("helpDialog.textNewLine"),
                    shortcuts: [K("Enter"), K("Shift+Enter")],
                  }),
                  F(G, {
                    label: g("helpDialog.textFinish"),
                    shortcuts: [K("Esc"), K("CtrlOrCmd+Enter")],
                  }),
                  F(G, {
                    label: g("helpDialog.curvedArrow"),
                    shortcuts: [
                      "A",
                      g("helpDialog.click"),
                      g("helpDialog.click"),
                      g("helpDialog.click"),
                    ],
                    isOr: !1,
                  }),
                  F(G, {
                    label: g("helpDialog.curvedLine"),
                    shortcuts: [
                      "L",
                      g("helpDialog.click"),
                      g("helpDialog.click"),
                      g("helpDialog.click"),
                    ],
                    isOr: !1,
                  }),
                  F(G, {
                    label: g("helpDialog.cropStart"),
                    shortcuts: [g("helpDialog.doubleClick"), K("Enter")],
                    isOr: !0,
                  }),
                  F(G, {
                    label: g("helpDialog.cropFinish"),
                    shortcuts: [K("Enter"), K("Escape")],
                    isOr: !0,
                  }),
                  F(G, { label: g("toolBar.lock"), shortcuts: [Ae.Q] }),
                  F(G, { label: g("helpDialog.preventBinding"), shortcuts: [K("CtrlOrCmd")] }),
                  F(G, { label: g("toolBar.link"), shortcuts: [K("CtrlOrCmd+K")] }),
                  F(G, {
                    label: g("toolBar.convertElementType"),
                    shortcuts: ["Tab", "Shift+Tab"],
                    isOr: !0,
                  }),
                ],
              }),
              Rt(Yg, {
                className: "HelpDialog__island--view",
                caption: g("helpDialog.view"),
                children: [
                  F(G, { label: g("buttons.zoomIn"), shortcuts: [K("CtrlOrCmd++")] }),
                  F(G, { label: g("buttons.zoomOut"), shortcuts: [K("CtrlOrCmd+-")] }),
                  F(G, { label: g("buttons.resetZoom"), shortcuts: [K("CtrlOrCmd+0")] }),
                  F(G, { label: g("helpDialog.zoomToFit"), shortcuts: ["Shift+1"] }),
                  F(G, { label: g("helpDialog.zoomToSelection"), shortcuts: ["Shift+2"] }),
                  F(G, { label: g("helpDialog.movePageUpDown"), shortcuts: ["PgUp/PgDn"] }),
                  F(G, {
                    label: g("helpDialog.movePageLeftRight"),
                    shortcuts: ["Shift+PgUp/PgDn"],
                  }),
                  F(G, { label: g("buttons.zenMode"), shortcuts: [K("Alt+Z")] }),
                  F(G, { label: g("buttons.objectsSnapMode"), shortcuts: [K("Alt+S")] }),
                  F(G, { label: g("labels.toggleGrid"), shortcuts: [K("CtrlOrCmd+'")] }),
                  F(G, { label: g("labels.viewMode"), shortcuts: [K("Alt+R")] }),
                  F(G, { label: g("labels.toggleTheme"), shortcuts: [K("Alt+Shift+D")] }),
                  F(G, { label: g("stats.fullTitle"), shortcuts: [K("Alt+/")] }),
                  F(G, { label: g("search.title"), shortcuts: [Ne("searchMenu")] }),
                  F(G, {
                    label: g("commandPalette.title"),
                    shortcuts: Q5
                      ? [Ne("commandPalette")]
                      : [Ne("commandPalette"), Ne("commandPalette", 1)],
                  }),
                ],
              }),
              Rt(Yg, {
                className: "HelpDialog__island--editor",
                caption: g("helpDialog.editor"),
                children: [
                  F(G, {
                    label: g("helpDialog.createFlowchart"),
                    shortcuts: [K("CtrlOrCmd+Arrow Key")],
                    isOr: !0,
                  }),
                  F(G, {
                    label: g("helpDialog.navigateFlowchart"),
                    shortcuts: [K("Alt+Arrow Key")],
                    isOr: !0,
                  }),
                  F(G, {
                    label: g("labels.moveCanvas"),
                    shortcuts: [
                      K(`Space+${g("helpDialog.drag")}`),
                      K(`Wheel+${g("helpDialog.drag")}`),
                    ],
                    isOr: !0,
                  }),
                  F(G, { label: g("buttons.clearReset"), shortcuts: [K("CtrlOrCmd+Delete")] }),
                  F(G, { label: g("labels.delete"), shortcuts: [K("Delete")] }),
                  F(G, { label: g("labels.cut"), shortcuts: [K("CtrlOrCmd+X")] }),
                  F(G, { label: g("labels.copy"), shortcuts: [K("CtrlOrCmd+C")] }),
                  F(G, { label: g("labels.paste"), shortcuts: [K("CtrlOrCmd+V")] }),
                  F(G, {
                    label: g("labels.pasteAsPlaintext"),
                    shortcuts: [K("CtrlOrCmd+Shift+V")],
                  }),
                  F(G, { label: g("labels.selectAll"), shortcuts: [K("CtrlOrCmd+A")] }),
                  F(G, {
                    label: g("labels.multiSelect"),
                    shortcuts: [K(`Shift+${g("helpDialog.click")}`)],
                  }),
                  F(G, {
                    label: g("helpDialog.deepSelect"),
                    shortcuts: [K(`CtrlOrCmd+${g("helpDialog.click")}`)],
                  }),
                  F(G, {
                    label: g("helpDialog.deepBoxSelect"),
                    shortcuts: [K(`CtrlOrCmd+${g("helpDialog.drag")}`)],
                  }),
                  ($n || Q5) &&
                    F(G, { label: g("labels.copyAsPng"), shortcuts: [K("Shift+Alt+C")] }),
                  F(G, { label: g("labels.copyStyles"), shortcuts: [K("CtrlOrCmd+Alt+C")] }),
                  F(G, { label: g("labels.pasteStyles"), shortcuts: [K("CtrlOrCmd+Alt+V")] }),
                  F(G, {
                    label: g("labels.sendToBack"),
                    shortcuts: [J5 ? K("CtrlOrCmd+Alt+[") : K("CtrlOrCmd+Shift+[")],
                  }),
                  F(G, {
                    label: g("labels.bringToFront"),
                    shortcuts: [J5 ? K("CtrlOrCmd+Alt+]") : K("CtrlOrCmd+Shift+]")],
                  }),
                  F(G, { label: g("labels.sendBackward"), shortcuts: [K("CtrlOrCmd+[")] }),
                  F(G, { label: g("labels.bringForward"), shortcuts: [K("CtrlOrCmd+]")] }),
                  F(G, { label: g("labels.alignTop"), shortcuts: [K("CtrlOrCmd+Shift+Up")] }),
                  F(G, { label: g("labels.alignBottom"), shortcuts: [K("CtrlOrCmd+Shift+Down")] }),
                  F(G, { label: g("labels.alignLeft"), shortcuts: [K("CtrlOrCmd+Shift+Left")] }),
                  F(G, { label: g("labels.alignRight"), shortcuts: [K("CtrlOrCmd+Shift+Right")] }),
                  F(G, {
                    label: g("labels.duplicateSelection"),
                    shortcuts: [K("CtrlOrCmd+D"), K(`Alt+${g("helpDialog.drag")}`)],
                  }),
                  F(G, {
                    label: g("helpDialog.toggleElementLock"),
                    shortcuts: [K("CtrlOrCmd+Shift+L")],
                  }),
                  F(G, { label: g("buttons.undo"), shortcuts: [K("CtrlOrCmd+Z")] }),
                  F(G, {
                    label: g("buttons.redo"),
                    shortcuts: JF
                      ? [K("CtrlOrCmd+Y"), K("CtrlOrCmd+Shift+Z")]
                      : [K("CtrlOrCmd+Shift+Z")],
                  }),
                  F(G, { label: g("labels.group"), shortcuts: [K("CtrlOrCmd+G")] }),
                  F(G, { label: g("labels.ungroup"), shortcuts: [K("CtrlOrCmd+Shift+G")] }),
                  F(G, { label: g("labels.flipHorizontal"), shortcuts: [K("Shift+H")] }),
                  F(G, { label: g("labels.flipVertical"), shortcuts: [K("Shift+V")] }),
                  F(G, { label: g("labels.showStroke"), shortcuts: [K("S")] }),
                  F(G, { label: g("labels.showBackground"), shortcuts: [K("G")] }),
                  F(G, { label: g("labels.showFonts"), shortcuts: [K("Shift+F")] }),
                  F(G, {
                    label: g("labels.decreaseFontSize"),
                    shortcuts: [K("CtrlOrCmd+Shift+<")],
                  }),
                  F(G, {
                    label: g("labels.increaseFontSize"),
                    shortcuts: [K("CtrlOrCmd+Shift+>")],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
    });
  };
import { useEffect as nT, useRef as cO, useState as Lr } from "react";
import {
  DEFAULT_EXPORT_PADDING as dO,
  EXPORT_IMAGE_TYPES as Wg,
  isFirefox as mO,
  EXPORT_SCALES as pO,
  cloneJSON as iT,
} from "@excalidraw/common";
import { useCallback as nO, useRef as iO, useState as aO } from "react";
var lO = 2e3,
  oT = () => {
    let [e, o] = aO(null),
      t = iO(0),
      r = () => {
        clearTimeout(t.current),
          o("success"),
          (t.current = window.setTimeout(() => {
            o(null);
          }, lO));
      },
      n = nO(() => {
        o(null);
      }, []);
    return { copyStatus: e, resetCopyStatus: n, onCopy: r };
  };
import sO from "clsx";
import { jsx as rT } from "react/jsx-runtime";
var sl = ({ title: e, name: o, checked: t, onChange: r, disabled: n = !1 }) =>
  rT("div", {
    className: sO("Switch", { toggled: t, disabled: n }),
    children: rT("input", {
      name: o,
      id: o,
      title: e,
      type: "checkbox",
      checked: t,
      disabled: n,
      onChange: () => r(!t),
      onKeyDown: (i) => {
        i.key === " " && r(!t);
      },
    }),
  });
import { jsx as Se, jsxs as Pr } from "react/jsx-runtime";
var uO = "filter" in document.createElement("canvas").getContext("2d"),
  hO = () =>
    Pr("div", {
      children: [
        Se("h3", { children: g("canvasError.cannotShowPreview") }),
        Se("p", { children: Se("span", { children: g("canvasError.canvasTooBig") }) }),
        Pr("em", { children: ["(", g("canvasError.canvasTooBigTip"), ")"] }),
      ],
    }),
  gO = ({
    appStateSnapshot: e,
    elementsSnapshot: o,
    files: t,
    actionManager: r,
    onExportImage: n,
    name: i,
  }) => {
    let a = Ee(o, e),
      [l, s] = Lr(i),
      [d, m] = Lr(a),
      [c, p] = Lr(e.exportBackground),
      [u, f] = Lr(e.exportWithDarkMode),
      [b, x] = Lr(e.exportEmbedScene),
      [w, E] = Lr(e.exportScale),
      y = cO(null),
      [v, C] = Lr(null),
      { onCopy: S, copyStatus: M, resetCopyStatus: k } = oT();
    nT(() => {
      k();
    }, [l, c, u, w, b, k]);
    let { exportedElements: A, exportingFrame: P } = $r(o, e, d);
    return (
      nT(() => {
        let N = y.current;
        if (!N) return;
        let O = N.offsetWidth,
          U = N.offsetHeight;
        O &&
          pr({
            elements: A,
            appState: {
              ...e,
              name: l,
              exportBackground: c,
              exportWithDarkMode: u,
              exportScale: w,
              exportEmbedScene: b,
            },
            files: t,
            exportPadding: dO,
            maxWidthOrHeight: Math.max(O, U),
            exportingFrame: P,
          })
            .then(
              (J) => (
                C(null),
                Lo(J)
                  .then(() => {
                    N.replaceChildren(J);
                  })
                  .catch((_) => {
                    throw _.name === "CANVAS_POSSIBLY_TOO_BIG"
                      ? new Error(g("canvasError.canvasTooBig"))
                      : _;
                  })
              )
            )
            .catch((J) => {
              console.error(J), C(J);
            });
      }, [e, t, A, P, l, c, u, w, b]),
      Pr("div", {
        className: "ImageExportModal",
        children: [
          Se("h3", { children: g("imageExportDialog.header") }),
          Pr("div", {
            className: "ImageExportModal__preview",
            children: [
              Se("div", {
                className: "ImageExportModal__preview__canvas",
                ref: y,
                children: v && Se(hO, {}),
              }),
              Se("div", {
                className: "ImageExportModal__preview__filename",
                children:
                  !En &&
                  Se("input", {
                    type: "text",
                    className: "TextInput",
                    value: l,
                    style: { width: "30ch" },
                    onChange: (N) => {
                      s(N.target.value), r.executeAction(Yp, "ui", N.target.value);
                    },
                  }),
              }),
            ],
          }),
          Pr("div", {
            className: "ImageExportModal__settings",
            children: [
              Se("h3", { children: g("imageExportDialog.header") }),
              a &&
                Se(cl, {
                  label: g("imageExportDialog.label.onlySelected"),
                  name: "exportOnlySelected",
                  children: Se(sl, {
                    name: "exportOnlySelected",
                    checked: d,
                    onChange: (N) => {
                      m(N);
                    },
                  }),
                }),
              Se(cl, {
                label: g("imageExportDialog.label.withBackground"),
                name: "exportBackgroundSwitch",
                children: Se(sl, {
                  name: "exportBackgroundSwitch",
                  checked: c,
                  onChange: (N) => {
                    p(N), r.executeAction(Wp, "ui", N);
                  },
                }),
              }),
              uO &&
                Se(cl, {
                  label: g("imageExportDialog.label.darkMode"),
                  name: "exportDarkModeSwitch",
                  children: Se(sl, {
                    name: "exportDarkModeSwitch",
                    checked: u,
                    onChange: (N) => {
                      f(N), r.executeAction($x, "ui", N);
                    },
                  }),
                }),
              Se(cl, {
                label: g("imageExportDialog.label.embedScene"),
                tooltip: g("imageExportDialog.tooltip.embedScene"),
                name: "exportEmbedSwitch",
                children: Se(sl, {
                  name: "exportEmbedSwitch",
                  checked: b,
                  onChange: (N) => {
                    x(N), r.executeAction(Ks, "ui", N);
                  },
                }),
              }),
              Se(cl, {
                label: g("imageExportDialog.label.scale"),
                name: "exportScale",
                children: Se(bd, {
                  name: "exportScale",
                  value: w,
                  onChange: (N) => {
                    E(N), r.executeAction(Zx, "ui", N);
                  },
                  choices: pO.map((N) => ({ value: N, label: `${N}\xD7` })),
                }),
              }),
              Pr("div", {
                className: "ImageExportModal__settings__buttons",
                children: [
                  Se(Tr, {
                    className: "ImageExportModal__settings__buttons__button",
                    label: g("imageExportDialog.title.exportToPng"),
                    onClick: () => n(Wg.png, A, { exportingFrame: P }),
                    icon: Hm,
                    children: g("imageExportDialog.button.exportToPng"),
                  }),
                  Se(Tr, {
                    className: "ImageExportModal__settings__buttons__button",
                    label: g("imageExportDialog.title.exportToSvg"),
                    onClick: () => n(Wg.svg, A, { exportingFrame: P }),
                    icon: Hm,
                    children: g("imageExportDialog.button.exportToSvg"),
                  }),
                  ($n || mO) &&
                    Se(Tr, {
                      className: "ImageExportModal__settings__buttons__button",
                      label: g("imageExportDialog.title.copyPngToClipboard"),
                      status: M,
                      onClick: async () => {
                        await n(Wg.clipboard, A, { exportingFrame: P }), S();
                      },
                      icon: Ln,
                      children: g("imageExportDialog.button.copyPngToClipboard"),
                    }),
                ],
              }),
            ],
          }),
        ],
      })
    );
  },
  cl = ({ label: e, children: o, tooltip: t, name: r }) =>
    Pr("div", {
      className: "ImageExportModal__settings__setting",
      title: e,
      children: [
        Pr("label", {
          htmlFor: r,
          className: "ImageExportModal__settings__setting__label",
          children: [e, t && Se(Lt, { label: t, long: !0, children: F0 })],
        }),
        Se("div", { className: "ImageExportModal__settings__setting__content", children: o }),
      ],
    }),
  aT = ({
    elements: e,
    appState: o,
    files: t,
    actionManager: r,
    onExportImage: n,
    onCloseRequest: i,
    name: a,
  }) => {
    let [{ appStateSnapshot: l, elementsSnapshot: s }] = Lr(() => ({
      appStateSnapshot: iT(o),
      elementsSnapshot: iT(e),
    }));
    return Se(Be, {
      onCloseRequest: i,
      size: "wide",
      title: !1,
      children: Se(gO, {
        elementsSnapshot: s,
        appStateSnapshot: l,
        files: t,
        actionManager: r,
        onExportImage: n,
        name: a,
      }),
    });
  };
import bO from "react";
import { getFrame as xO } from "@excalidraw/common";
import Vg from "open-color";
import { jsx as fO } from "react/jsx-runtime";
var Xg = ({ children: e, color: o }) =>
  fO("div", {
    className: "Card",
    style: {
      "--card-color": o === "primary" ? "var(--color-primary)" : Vg[o][7],
      "--card-color-darker": o === "primary" ? "var(--color-primary-darker)" : Vg[o][8],
      "--card-color-darkest": o === "primary" ? "var(--color-primary-darkest)" : Vg[o][9],
    },
    children: e,
  });
import { Fragment as yO, jsx as mo, jsxs as Vd } from "react/jsx-runtime";
var EO = ({
    elements: e,
    appState: o,
    setAppState: t,
    files: r,
    actionManager: n,
    exportOpts: i,
    canvas: a,
    onCloseRequest: l,
  }) => {
    let { onExportToBackend: s } = i;
    return mo("div", {
      className: "ExportDialog ExportDialog--json",
      children: Vd("div", {
        className: "ExportDialog-cards",
        children: [
          i.saveFileToDisk &&
            Vd(Xg, {
              color: "lime",
              children: [
                mo("div", { className: "Card-icon", children: V1 }),
                mo("h2", { children: g("exportDialog.disk_title") }),
                Vd("div", {
                  className: "Card-details",
                  children: [
                    g("exportDialog.disk_details"),
                    !En && n.renderAction("changeProjectName"),
                  ],
                }),
                mo(V, {
                  className: "Card-button",
                  type: "button",
                  title: g("exportDialog.disk_button"),
                  "aria-label": g("exportDialog.disk_button"),
                  showAriaLabel: !0,
                  onClick: () => {
                    n.executeAction(Ta, "ui");
                  },
                }),
              ],
            }),
          s &&
            Vd(Xg, {
              color: "pink",
              children: [
                mo("div", { className: "Card-icon", children: Qi }),
                mo("h2", { children: g("exportDialog.link_title") }),
                mo("div", { className: "Card-details", children: g("exportDialog.link_details") }),
                mo(V, {
                  className: "Card-button",
                  type: "button",
                  title: g("exportDialog.link_button"),
                  "aria-label": g("exportDialog.link_button"),
                  showAriaLabel: !0,
                  onClick: async () => {
                    try {
                      re("export", "link", `ui (${xO()})`), await s(e, o, r), l();
                    } catch (d) {
                      t({ errorMessage: d.message });
                    }
                  },
                }),
              ],
            }),
          i.renderCustomUI && i.renderCustomUI(e, o, r, a),
        ],
      }),
    });
  },
  lT = ({
    elements: e,
    appState: o,
    files: t,
    actionManager: r,
    exportOpts: n,
    canvas: i,
    setAppState: a,
  }) => {
    let l = bO.useCallback(() => {
      a({ openDialog: null });
    }, [a]);
    return mo(yO, {
      children:
        o.openDialog?.name === "jsonExport" &&
        mo(Be, {
          onCloseRequest: l,
          title: g("buttons.export"),
          children: mo(EO, {
            elements: e,
            appState: o,
            setAppState: a,
            files: t,
            actionManager: r,
            onCloseRequest: l,
            exportOpts: n,
            canvas: i,
          }),
        }),
    });
  };
import wO from "clsx";
import { jsx as sT, jsxs as TO } from "react/jsx-runtime";
var vO = "small",
  cT = (e) =>
    TO("label", {
      className: wO("ToolIcon ToolIcon__LaserPointer", `ToolIcon_size_${vO}`, {
        "is-mobile": e.isMobile,
      }),
      title: `${e.title}`,
      children: [
        sT("input", {
          className: "ToolIcon_type_checkbox",
          type: "checkbox",
          name: e.name,
          onChange: e.onChange,
          checked: e.checked,
          "aria-label": e.title,
          "data-testid": "toolbar-LaserPointer",
        }),
        sT("div", { className: "ToolIcon__icon", children: ta }),
      ],
    });
import { Fragment as pT, jsx as j, jsxs as Nt } from "react/jsx-runtime";
var AO = ({ UIOptions: e }) =>
    Nt(ct, {
      __fallback: !0,
      children: [
        j(ct.DefaultItems.LoadScene, {}),
        j(ct.DefaultItems.SaveToActiveFile, {}),
        e.canvasActions.export && j(ct.DefaultItems.Export, {}),
        e.canvasActions.saveAsImage && j(ct.DefaultItems.SaveAsImage, {}),
        j(ct.DefaultItems.SearchMenu, {}),
        j(ct.DefaultItems.Help, {}),
        j(ct.DefaultItems.ClearCanvas, {}),
        j(ct.Separator, {}),
        j(ct.Group, { title: "Excalidraw links", children: j(ct.DefaultItems.Socials, {}) }),
        j(ct.Separator, {}),
        j(ct.DefaultItems.ToggleTheme, {}),
        j(ct.DefaultItems.ChangeCanvasBackground, {}),
      ],
    }),
  DO = () =>
    Nt(wd, {
      __fallback: !0,
      children: [j(wd.Actions.SaveToDisk, {}), j(wd.Actions.ExportToImage, {})],
    }),
  _O = ({
    actionManager: e,
    appState: o,
    files: t,
    setAppState: r,
    elements: n,
    canvas: i,
    onLockToggle: a,
    onHandToolToggle: l,
    onPenModeToggle: s,
    showExitZenModeBtn: d,
    renderTopRightUI: m,
    renderCustomStats: c,
    UIOptions: p,
    onExportImage: u,
    renderWelcomeScreen: f,
    children: b,
    app: x,
    isCollaborating: w,
    generateLinkForSelection: E,
  }) => {
    let y = ae(),
      v = s2(),
      C = v.tunnelsJotai.Provider,
      [S, M] = ne(rr),
      k = () =>
        p.canvasActions.export
          ? j(lT, {
              elements: n,
              appState: o,
              files: t,
              actionManager: e,
              exportOpts: p.canvasActions.export,
              canvas: i,
              setAppState: r,
            })
          : null,
      A = () =>
        !p.canvasActions.saveAsImage || o.openDialog?.name !== "imageExport"
          ? null
          : j(aT, {
              elements: n,
              appState: o,
              files: t,
              actionManager: e,
              onExportImage: u,
              onCloseRequest: () => r({ openDialog: null }),
              name: x.getName(),
            }),
      P = () =>
        Nt("div", {
          style: { position: "relative" },
          children: [j(v.MainMenuTunnel.Out, {}), f && j(v.WelcomeScreenMenuHintTunnel.Out, {})],
        }),
      N = () =>
        j(yr, {
          heading: "selectedShapeActions",
          className: dl("selected-shape-actions zen-mode-transition", {
            "transition-left": o.zenModeEnabled,
          }),
          children: j(Xe, {
            className: CO.SHAPE_ACTIONS_MENU,
            padding: 2,
            style: { maxHeight: `${o.height - 166}px` },
            children: j(Ac, {
              appState: o,
              elementsMap: x.scene.getNonDeletedElementsMap(),
              renderAction: e.renderAction,
              app: x,
            }),
          }),
        }),
      O = () => {
        let R = LO(o, n),
          X =
            o.stats.open &&
            !o.zenModeEnabled &&
            !o.viewModeEnabled &&
            o.openDialog?.name !== "elementLinkSelector";
        return j(sd, {
          side: "top",
          children: Nt("div", {
            className: "App-menu App-menu_top",
            children: [
              Nt(qe.Col, {
                gap: 6,
                className: dl("App-menu_top__left"),
                children: [P(), R && N()],
              }),
              !o.viewModeEnabled &&
                o.openDialog?.name !== "elementLinkSelector" &&
                j(yr, {
                  heading: "shapes",
                  className: "shapes-section",
                  children: ($) =>
                    Nt("div", {
                      style: { position: "relative" },
                      children: [
                        f && j(v.WelcomeScreenToolbarHintTunnel.Out, {}),
                        j(qe.Col, {
                          gap: 4,
                          align: "start",
                          children: Nt(qe.Row, {
                            gap: 1,
                            className: dl("App-toolbar-container", {
                              "zen-mode": o.zenModeEnabled,
                            }),
                            children: [
                              Nt(Xe, {
                                padding: 1,
                                className: dl("App-toolbar", { "zen-mode": o.zenModeEnabled }),
                                children: [
                                  j(dd, {
                                    appState: o,
                                    isMobile: y.editor.isMobile,
                                    device: y,
                                    app: x,
                                  }),
                                  $,
                                  Nt(qe.Row, {
                                    gap: 1,
                                    children: [
                                      j(md, {
                                        zenModeEnabled: o.zenModeEnabled,
                                        checked: o.penMode,
                                        onChange: () => s(null),
                                        title: g("toolBar.penMode"),
                                        penDetected: o.penDetected,
                                      }),
                                      j(ld, {
                                        checked: o.activeTool.locked,
                                        onChange: a,
                                        title: g("toolBar.lock"),
                                      }),
                                      j("div", { className: "App-toolbar__divider" }),
                                      j(cd, {
                                        checked: qt(o),
                                        onChange: () => l(),
                                        title: g("toolBar.hand"),
                                        isMobile: !0,
                                      }),
                                      j(Dc, {
                                        appState: o,
                                        activeTool: o.activeTool,
                                        UIOptions: p,
                                        app: x,
                                      }),
                                    ],
                                  }),
                                ],
                              }),
                              w &&
                                j(Xe, {
                                  style: {
                                    marginLeft: 8,
                                    alignSelf: "center",
                                    height: "fit-content",
                                  },
                                  children: j(cT, {
                                    title: g("toolBar.laser"),
                                    checked: o.activeTool.type === dT.laser,
                                    onChange: () => x.setActiveTool({ type: dT.laser }),
                                    isMobile: !0,
                                  }),
                                }),
                            ],
                          }),
                        }),
                      ],
                    }),
                }),
              Nt("div", {
                className: dl("layer-ui__wrapper__top-right zen-mode-transition", {
                  "transition-right": o.zenModeEnabled,
                }),
                children: [
                  o.collaborators.size > 0 &&
                    j(hd, {
                      collaborators: o.collaborators,
                      userToFollow: o.userToFollow?.socketId || null,
                    }),
                  m?.(y.editor.isMobile, o),
                  !o.viewModeEnabled &&
                    o.openDialog?.name !== "elementLinkSelector" &&
                    (!J || o.openSidebar?.name !== Kg.name) &&
                    j(v.DefaultSidebarTriggerTunnel.Out, {}),
                  X &&
                    j(ll, {
                      app: x,
                      onClose: () => {
                        e.executeAction(ii);
                      },
                      renderCustomStats: c,
                    }),
                ],
              }),
            ],
          }),
        });
      },
      U = () =>
        j(Id, {
          __fallback: !0,
          onDock: (R) => {
            re(
              "sidebar",
              `toggleDock (${R ? "dock" : "undock"})`,
              `(${y.editor.isMobile ? "mobile" : "desktop"})`
            );
          },
        }),
      J = zl(el),
      _ = Nt(pT, {
        children: [
          b,
          j(AO, { UIOptions: p }),
          j(Id.Trigger, {
            __fallback: !0,
            icon: In,
            title: kO(g("toolBar.library")),
            onToggle: (R) => {
              R &&
                re(
                  "sidebar",
                  `${Kg.name} (open)`,
                  `button (${y.editor.isMobile ? "mobile" : "desktop"})`
                );
            },
            tab: Kg.defaultTab,
            children: g("toolBar.library"),
          }),
          j(DO, {}),
          o.openDialog?.name === "ttd" && j(Ig, { __fallback: !0 }),
          o.isLoading && j(ad, { delay: 250 }),
          o.errorMessage &&
            j(q5, { onClose: () => r({ errorMessage: null }), children: o.errorMessage }),
          S &&
            !y.editor.isMobile &&
            j(vb, {
              colorPickerType: S.colorPickerType,
              onCancel: () => {
                M(null);
              },
              onChange: (R, X, $, { altKey: W }) => {
                if (!(R !== "elementBackground" && R !== "elementStroke"))
                  if ($.length) {
                    for (let ce of $)
                      MO(ce, SO(n), {
                        [W && S.swapPreviewOnAlt
                          ? R === "elementBackground"
                            ? "strokeColor"
                            : "backgroundColor"
                          : R === "elementBackground"
                          ? "backgroundColor"
                          : "strokeColor"]: X,
                      }),
                        PO.delete(ce);
                    x.scene.triggerUpdate();
                  } else
                    r(
                      R === "elementBackground"
                        ? { currentItemBackgroundColor: X }
                        : { currentItemStrokeColor: X }
                    );
              },
              onSelect: (R, X) => {
                M(($) => ($?.keepOpenOnAlt && X.altKey ? $ : null)), S?.onSelect?.(R, X);
              },
            }),
          o.openDialog?.name === "help" &&
            j(eT, {
              onClose: () => {
                r({ openDialog: null });
              },
            }),
          j(x2, {}),
          o.openDialog?.name === "elementLinkSelector" &&
            j(j5, {
              sourceElementId: o.openDialog.sourceElementId,
              onClose: () => {
                r({ openDialog: null });
              },
              scene: x.scene,
              appState: o,
              generateLinkForSelection: E,
            }),
          j(v.OverwriteConfirmDialogTunnel.Out, {}),
          A(),
          k(),
          o.pasteDialog.shown &&
            j(Yv, {
              setAppState: r,
              appState: o,
              onClose: () => r({ pasteDialog: { shown: !1, data: null } }),
            }),
          y.editor.isMobile &&
            j(Gv, {
              app: x,
              appState: o,
              elements: n,
              actionManager: e,
              renderJSONExportDialog: k,
              renderImageExportDialog: A,
              setAppState: r,
              onLockToggle: a,
              onHandToolToggle: l,
              onPenModeToggle: s,
              renderTopRightUI: m,
              renderCustomStats: c,
              renderSidebars: U,
              device: y,
              renderWelcomeScreen: f,
              UIOptions: p,
            }),
          !y.editor.isMobile &&
            Nt(pT, {
              children: [
                Nt("div", {
                  className: "layer-ui__wrapper",
                  style:
                    o.openSidebar && J && y.editor.canFitSidebar
                      ? { width: "calc(100% - var(--right-sidebar-width))" }
                      : {},
                  children: [
                    f && j(v.WelcomeScreenCenterTunnel.Out, {}),
                    O(),
                    j(Kv, {
                      appState: o,
                      actionManager: e,
                      showExitZenModeBtn: d,
                      renderWelcomeScreen: f,
                    }),
                    o.scrolledOutside &&
                      j("button", {
                        type: "button",
                        className: "scroll-back-to-content",
                        onClick: () => {
                          r((R) => ({ ...zr(n, R) }));
                        },
                        children: g("buttons.scrollBackToContent"),
                      }),
                  ],
                }),
                U(),
              ],
            }),
        ],
      });
    return j(tp.Provider, {
      value: o,
      children: j(C, { children: j(qu.Provider, { value: v, children: _ }) }),
    });
  },
  mT = (e) => {
    let {
      suggestedBindings: o,
      startBoundElement: t,
      cursorButton: r,
      scrollX: n,
      scrollY: i,
      ...a
    } = e;
    return a;
  },
  RO = (e, o) => {
    if (e.children !== o.children) return !1;
    let { canvas: t, appState: r, ...n } = e,
      { canvas: i, appState: a, ...l } = o;
    return Xd(mT(r), mT(a), { selectedElementIds: Xd, selectedGroupIds: Xd }) && Xd(n, l);
  },
  uT = IO.memo(_O, RO);
import NO from "clsx";
import { jsx as hT, jsxs as FO } from "react/jsx-runtime";
var BO = "small",
  Ar = (e) =>
    FO("label", {
      className: NO("ToolIcon ToolIcon__MagicButton", `ToolIcon_size_${BO}`, {
        "is-mobile": e.isMobile,
      }),
      title: `${e.title}`,
      children: [
        hT("input", {
          className: "ToolIcon_type_checkbox",
          type: "checkbox",
          name: e.name,
          onChange: e.onChange,
          checked: e.checked,
          "aria-label": e.title,
        }),
        hT("div", { className: "ToolIcon__icon", children: e.icon }),
      ],
    });
import { sceneCoordsToViewportCoords as OO } from "@excalidraw/common";
import { getElementAbsoluteCoords as zO } from "@excalidraw/element";
import { jsx as Xo, jsxs as Zg } from "react/jsx-runtime";
var HO = Xo("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    children: Xo("path", {
      d: "M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z",
    }),
  }),
  GO = Xo("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    children: Xo("path", {
      d: "M9 3v1H4v2h1v13a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V6h1V4h-5V3H9zM7 6h10v13H7V6zm2 2v9h2V8H9zm4 0v9h2V8h-2z",
    }),
  }),
  UO = Xo("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    children: Xo("path", {
      d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z",
    }),
  }),
  gT = ({ elements: e, elementsMap: o, app: t }) => {
    let r = zt(),
      n = Fe(),
      i = Z(e, r);
    if (
      i.length === 0 ||
      r.contextMenu ||
      r.newElement ||
      r.resizingElement ||
      r.isRotating ||
      r.openMenu ||
      r.viewModeEnabled ||
      r.editingTextElement ||
      !(i.length <= 1
        ? !1
        : i.some((f) => f.type === "arrow" && f.startBinding !== null && f.endBinding !== null))
    )
      return null;
    let l = i[0],
      s = i.some((u) => u.backgroundColor === "#ffe066" && u.strokeColor === "#ff6b6b"),
      d = (u) => {
        console.log(`\u{1F3A8} Executing custom action: ${u}`);
        let f = n.actions[u];
        f && n.executeAction(f, "ui");
      },
      m = () => {
        let u = 1 / 0,
          f = 1 / 0,
          b = -1 / 0,
          x = -1 / 0;
        i.forEach((M) => {
          let [k, A] = zO(M, o),
            P = k + M.width,
            N = A + M.height;
          (u = Math.min(u, k)), (f = Math.min(f, A)), (b = Math.max(b, P)), (x = Math.max(x, N));
        });
        let w = (u + b) / 2,
          E = x,
          { x: y, y: v } = OO({ sceneX: w, sceneY: E }, r),
          C = y - r.offsetLeft,
          S = v - r.offsetTop + 10;
        return { x: C, y: S };
      },
      { x: c, y: p } = m();
    return Zg("div", {
      className: "excalidraw-canvas-buttons",
      style: {
        position: "absolute",
        top: `${p}px`,
        left: `${c}px`,
        background: "transparent",
        boxShadow: "none",
        display: "flex",
        flexDirection: "row",
        gap: "1rem",
        transform: "translateX(-50%)",
      },
      children: [
        Zg("div", {
          style: {
            display: "flex",
            flexDirection: "row",
            alignItems: "center",
            justifyContent: "center",
            gap: "0.375rem",
            padding: "5px",
            boxShadow: "0px 2px 4px 0 rgb(0 0 0 / 30%)",
            zIndex: "var(--zIndex-canvasButtons)",
            background: "var(--island-bg-color)",
            borderRadius: "var(--border-radius-lg)",
          },
          children: [
            Xo(Ar, {
              title: "Apply custom highlight effect",
              icon: HO,
              checked: s,
              onChange: () => d("customHighlight"),
            }),
            "Ask Arisa",
          ],
        }),
        Zg("div", {
          style: {
            display: "flex",
            flexDirection: "row",
            alignItems: "center",
            justifyContent: "center",
            gap: "0.375rem",
            padding: "5px",
            boxShadow: "0px 2px 4px 0 rgb(0 0 0 / 30%)",
            zIndex: "var(--zIndex-canvasButtons)",
            background: "var(--island-bg-color)",
            borderRadius: "var(--border-radius-lg)",
          },
          children: [
            Xo(Ar, {
              title: "Duplicate and highlight",
              icon: UO,
              checked: !1,
              onChange: () => d("duplicateAndHighlight"),
            }),
            "Duplicate & Highlight",
          ],
        }),
        s &&
          Xo(Ar, {
            title: "Clear highlight effect",
            icon: GO,
            checked: !1,
            onChange: () => d("clearHighlight"),
          }),
      ],
    });
  };
import { useEffect as YO, useRef as WO } from "react";
import { jsx as fT } from "react/jsx-runtime";
var bT = ({ trails: e }) => {
  let o = WO(null);
  return (
    YO(() => {
      if (o.current) for (let t of e) t.start(o.current);
      return () => {
        for (let t of e) t.stop();
      };
    }, e),
    fT("div", { className: "SVGLayer", children: fT("svg", { ref: o }) })
  );
};
import VO, { useEffect as XO, useRef as KO } from "react";
import {
  CURSOR_TYPE as xT,
  isShallowEqual as ZO,
  sceneCoordsToViewportCoords as $O,
} from "@excalidraw/common";
import { jsx as JO } from "react/jsx-runtime";
var jO = (e) => {
    let o = KO(!1);
    return (
      XO(() => {
        if (!o.current) {
          o.current = !0;
          return;
        }
        let t = new Map(),
          r = new Map(),
          n = new Map(),
          i = new Map(),
          a = new Map();
        e.appState.collaborators.forEach((s, d) => {
          if (s.selectedElementIds)
            for (let m of Object.keys(s.selectedElementIds))
              n.has(m) || n.set(m, []), n.get(m).push(d);
          !s.pointer ||
            s.pointer.renderCursor === !1 ||
            (s.username && i.set(d, s.username),
            s.userState && a.set(d, s.userState),
            r.set(d, $O({ sceneX: s.pointer.x, sceneY: s.pointer.y }, e.appState)),
            t.set(d, s.button));
        });
        let l =
          (e.containerRef?.current &&
            getComputedStyle(e.containerRef.current).getPropertyValue("--color-selection")) ||
          "#6965db";
        Qw(
          {
            canvas: e.canvas,
            elementsMap: e.elementsMap,
            visibleElements: e.visibleElements,
            selectedElements: e.selectedElements,
            allElementsMap: e.allElementsMap,
            scale: window.devicePixelRatio,
            appState: e.appState,
            renderConfig: {
              remotePointerViewportCoords: r,
              remotePointerButton: t,
              remoteSelectedElementIds: n,
              remotePointerUsernames: i,
              remotePointerUserStates: a,
              selectionColor: l,
              renderScrollbars: e.renderScrollbars,
            },
            device: e.device,
            callback: e.renderInteractiveSceneCallback,
          },
          ki()
        );
      }),
      JO("canvas", {
        className: "excalidraw__canvas interactive",
        style: {
          width: e.appState.width,
          height: e.appState.height,
          cursor: e.appState.viewModeEnabled ? xT.GRAB : xT.AUTO,
        },
        width: e.appState.width * e.scale,
        height: e.appState.height * e.scale,
        ref: e.handleCanvasRef,
        onContextMenu: e.onContextMenu,
        onPointerMove: e.onPointerMove,
        onPointerUp: e.onPointerUp,
        onPointerCancel: e.onPointerCancel,
        onTouchMove: e.onTouchMove,
        onPointerDown: e.onPointerDown,
        onDoubleClick: e.appState.viewModeEnabled ? void 0 : e.onDoubleClick,
        children: g("labels.drawingCanvas"),
      })
    );
  },
  ET = (e) => ({
    zoom: e.zoom,
    scrollX: e.scrollX,
    scrollY: e.scrollY,
    width: e.width,
    height: e.height,
    viewModeEnabled: e.viewModeEnabled,
    openDialog: e.openDialog,
    editingGroupId: e.editingGroupId,
    editingLinearElement: e.editingLinearElement,
    selectedElementIds: e.selectedElementIds,
    frameToHighlight: e.frameToHighlight,
    offsetLeft: e.offsetLeft,
    offsetTop: e.offsetTop,
    theme: e.theme,
    selectionElement: e.selectionElement,
    selectedGroupIds: e.selectedGroupIds,
    selectedLinearElement: e.selectedLinearElement,
    multiElement: e.multiElement,
    isBindingEnabled: e.isBindingEnabled,
    suggestedBindings: e.suggestedBindings,
    isRotating: e.isRotating,
    elementsToHighlight: e.elementsToHighlight,
    collaborators: e.collaborators,
    activeEmbeddable: e.activeEmbeddable,
    snapLines: e.snapLines,
    zenModeEnabled: e.zenModeEnabled,
    editingTextElement: e.editingTextElement,
    isCropping: e.isCropping,
    croppingElementId: e.croppingElementId,
    searchMatches: e.searchMatches,
    activeLockedId: e.activeLockedId,
  }),
  qO = (e, o) =>
    e.selectionNonce !== o.selectionNonce ||
    e.sceneNonce !== o.sceneNonce ||
    e.scale !== o.scale ||
    e.elementsMap !== o.elementsMap ||
    e.visibleElements !== o.visibleElements ||
    e.selectedElements !== o.selectedElements ||
    e.renderScrollbars !== o.renderScrollbars
      ? !1
      : ZO(ET(e.appState), ET(o.appState)),
  $g = VO.memo(jO, qO);
import QO, { useEffect as ez, useRef as yT } from "react";
import { isShallowEqual as wT } from "@excalidraw/common";
import { jsx as rz } from "react/jsx-runtime";
var tz = (e) => {
    let o = yT(null),
      t = yT(!1);
    return (
      ez(() => {
        let r = o.current;
        if (!r) return;
        let n = e.canvas;
        t.current ||
          ((t.current = !0), r.replaceChildren(n), n.classList.add("excalidraw__canvas", "static"));
        let i = `${e.appState.width}px`,
          a = `${e.appState.height}px`;
        n.style.width !== i && (n.style.width = i), n.style.height !== a && (n.style.height = a);
        let l = e.appState.width * e.scale,
          s = e.appState.height * e.scale;
        n.width !== l && (n.width = l),
          n.height !== s && (n.height = s),
          i1(
            {
              canvas: n,
              rc: e.rc,
              scale: e.scale,
              elementsMap: e.elementsMap,
              allElementsMap: e.allElementsMap,
              visibleElements: e.visibleElements,
              appState: e.appState,
              renderConfig: e.renderConfig,
            },
            ki()
          );
      }),
      rz("div", { className: "excalidraw__canvas-wrapper", ref: o })
    );
  },
  vT = (e) => ({
    zoom: e.zoom,
    scrollX: e.scrollX,
    scrollY: e.scrollY,
    width: e.width,
    height: e.height,
    viewModeEnabled: e.viewModeEnabled,
    openDialog: e.openDialog,
    hoveredElementIds: e.hoveredElementIds,
    offsetLeft: e.offsetLeft,
    offsetTop: e.offsetTop,
    theme: e.theme,
    shouldCacheIgnoreZoom: e.shouldCacheIgnoreZoom,
    viewBackgroundColor: e.viewBackgroundColor,
    exportScale: e.exportScale,
    selectedElementsAreBeingDragged: e.selectedElementsAreBeingDragged,
    gridSize: e.gridSize,
    gridStep: e.gridStep,
    frameRendering: e.frameRendering,
    selectedElementIds: e.selectedElementIds,
    frameToHighlight: e.frameToHighlight,
    editingGroupId: e.editingGroupId,
    currentHoveredFontFamily: e.currentHoveredFontFamily,
    croppingElementId: e.croppingElementId,
  }),
  oz = (e, o) =>
    e.sceneNonce !== o.sceneNonce ||
    e.scale !== o.scale ||
    e.elementsMap !== o.elementsMap ||
    e.visibleElements !== o.visibleElements
      ? !1
      : wT(vT(e.appState), vT(o.appState)) && wT(e.renderConfig, o.renderConfig),
  jg = QO.memo(tz, oz);
import { useEffect as lz, useRef as sz } from "react";
import { throttleRAF as nz } from "@excalidraw/common";
import { renderElement as iz } from "@excalidraw/element";
var TT = ({
    canvas: e,
    rc: o,
    newElement: t,
    elementsMap: r,
    allElementsMap: n,
    scale: i,
    appState: a,
    renderConfig: l,
  }) => {
    if (e) {
      let [s, d] = Dl(e, i),
        m = _l({ canvas: e, scale: i, normalizedWidth: s, normalizedHeight: d });
      m.save(),
        m.scale(a.zoom.value, a.zoom.value),
        t && t.type !== "selection" ? iz(t, r, n, o, m, l, a) : m.clearRect(0, 0, s, d);
    }
  },
  az = nz(
    (e) => {
      TT(e);
    },
    { trailing: !0 }
  ),
  IT = (e, o) => {
    if (o) {
      az(e);
      return;
    }
    TT(e);
  };
import { jsx as dz } from "react/jsx-runtime";
var cz = (e) => {
    let o = sz(null);
    return (
      lz(() => {
        o.current &&
          IT(
            {
              canvas: o.current,
              scale: e.scale,
              newElement: e.appState.newElement,
              elementsMap: e.elementsMap,
              allElementsMap: e.allElementsMap,
              rc: e.rc,
              renderConfig: e.renderConfig,
              appState: e.appState,
            },
            ki()
          );
      }),
      dz("canvas", {
        className: "excalidraw__canvas",
        style: { width: e.appState.width, height: e.appState.height },
        width: e.appState.width * e.scale,
        height: e.appState.height * e.scale,
        ref: o,
      })
    );
  },
  CT = cz;
import { useCallback as mz, useEffect as pz, useRef as uz } from "react";
import { jsx as ST, jsxs as gz } from "react/jsx-runtime";
var hz = 5e3,
  kT = ({ message: e, onClose: o, closable: t = !1, duration: r = hz, style: n }) => {
    let i = uz(0),
      a = r !== 1 / 0,
      l = mz(() => {
        a && (i.current = window.setTimeout(() => o(), r));
      }, [o, r, a]);
    return (
      pz(() => {
        if (a) return l(), () => clearTimeout(i.current);
      }, [l, e, r, a]),
      gz("div", {
        className: "Toast",
        onMouseEnter: a ? () => clearTimeout(i?.current) : void 0,
        onMouseLeave: a ? l : void 0,
        style: n,
        children: [
          ST("p", { className: "Toast__message", children: e }),
          t &&
            ST(V, {
              icon: Bt,
              "aria-label": "close",
              type: "icon",
              onClick: o,
              className: "close",
            }),
        ],
      })
    );
  };
import {
  getCommonBounds as fz,
  getElementsInGroup as bz,
  selectGroupsFromGivenElements as xz,
} from "@excalidraw/element";
import { sceneCoordsToViewportCoords as Ez } from "@excalidraw/common";
import { flushSync as yz } from "react-dom";
import { jsx as vz } from "react/jsx-runtime";
var wz = ({ app: e, activeLockedId: o }) => {
    let t = e.scene.getElement(o),
      r = t ? [t] : bz(e.scene.getNonDeletedElementsMap(), o);
    if (r.length === 0) return null;
    let [n, i] = fz(r),
      { x: a, y: l } = Ez({ sceneX: n, sceneY: i }, e.state);
    return vz("div", {
      className: "UnlockPopup",
      style: {
        bottom: `${e.state.height + 12 - l + e.state.offsetTop}px`,
        left: `${a - e.state.offsetLeft}px`,
      },
      onClick: () => {
        yz(() => {
          let s = xz(r, e.state);
          e.setState({
            selectedElementIds: r.reduce((d, m) => ({ ...d, [m.id]: !0 }), {}),
            selectedGroupIds: s,
            activeLockedId: null,
          });
        }),
          e.actionManager.executeAction(Ma);
      },
      title: g("labels.elementLock.unlock"),
      children: k1,
    });
  },
  MT = wz;
import { Fragment as fG, jsx as pe, jsxs as em } from "react/jsx-runtime";
var LI = Mo.createContext(null),
  PI = Mo.createContext(null),
  AI = {
    viewport: { isMobile: !1, isLandscape: !1 },
    editor: { isMobile: !1, canFitSidebar: !1 },
    isTouchScreen: !1,
  },
  Mf = Mo.createContext(AI);
Mf.displayName = "DeviceContext";
var Lf = Mo.createContext({ container: null, id: null });
Lf.displayName = "ExcalidrawContainerContext";
var Pf = Mo.createContext([]);
Pf.displayName = "ExcalidrawElementsContext";
var Af = Mo.createContext({ ...Jo(), width: 0, height: 0, offsetLeft: 0, offsetTop: 0 });
Af.displayName = "ExcalidrawAppStateContext";
var Df = Mo.createContext(() => {
  console.warn("Uninitialized ExcalidrawSetAppStateContext context!");
});
Df.displayName = "ExcalidrawSetAppStateContext";
var _f = Mo.createContext(null);
_f.displayName = "ExcalidrawActionManagerContext";
var Re = () => Fr(LI),
  bo = () => Fr(PI),
  ae = () => Fr(Mf),
  Ge = () => Fr(Lf),
  nr = () => Fr(Pf),
  zt = () => Fr(Af),
  le = () => Fr(Df),
  Fe = () => Fr(_f),
  El = !1,
  Tf = 0,
  hn = !1,
  yl = !1,
  If = !1,
  wl = { horizontal: null, vertical: null },
  Br = 0,
  vl = !1,
  Cf = new Map(),
  Qd = !1,
  CI = 0,
  SI = !1,
  Tl = null,
  ue = { pointers: new Map(), lastCenter: null, initialDistance: null, initialScale: null },
  kf = class e extends Mo.Component {
    constructor(t) {
      super(t);
      I(this, "canvas");
      I(this, "interactiveCanvas", null);
      I(this, "rc");
      I(this, "unmounted", !1);
      I(this, "actionManager");
      I(this, "device", AI);
      I(this, "excalidrawContainerRef", Mo.createRef());
      I(this, "scene");
      I(this, "fonts");
      I(this, "renderer");
      I(this, "visibleElements");
      I(this, "resizeObserver");
      I(this, "nearestScrollableContainer");
      I(this, "library");
      I(this, "libraryItemsFromStorage");
      I(this, "id");
      I(this, "store");
      I(this, "history");
      I(this, "excalidrawContainerValue");
      I(this, "files", {});
      I(this, "imageCache", new Map());
      I(this, "iFrameRefs", new Map());
      I(this, "embedsValidationStatus", new Map());
      I(this, "initializedEmbeds", new Set());
      I(this, "handleToastClose", () => {
        this.setToast(null);
      });
      I(this, "elementsPendingErasure", new Set());
      I(this, "flowChartCreator", new YH());
      I(this, "flowChartNavigator", new WH());
      I(this, "hitLinkElement");
      I(this, "lastPointerDownEvent", null);
      I(this, "lastPointerUpEvent", null);
      I(this, "lastPointerMoveEvent", null);
      I(this, "lastPointerMoveCoords", null);
      I(this, "lastViewportPosition", { x: 0, y: 0 });
      I(this, "animationFrameHandler", new Xc());
      I(this, "laserTrails", new td(this.animationFrameHandler, this));
      I(this, "eraserTrail", new id(this.animationFrameHandler, this));
      I(this, "lassoTrail", new nd(this.animationFrameHandler, this));
      I(this, "onChangeEmitter", new mn());
      I(this, "onPointerDownEmitter", new mn());
      I(this, "onPointerUpEmitter", new mn());
      I(this, "onUserFollowEmitter", new mn());
      I(this, "onScrollChangeEmitter", new mn());
      I(this, "missingPointerEventCleanupEmitter", new mn());
      I(this, "onRemoveEventListenersEmitter", new mn());
      I(this, "updateEditorAtom", (t, ...r) => {
        let n = He.set(t, ...r);
        return this.triggerRender(), n;
      });
      I(this, "getEffectiveGridSize", () => (br(this) ? this.state.gridSize : null));
      I(this, "updateEmbedValidationStatus", (t, r) => {
        this.embedsValidationStatus.set(t.id, r), bl.delete(t);
      });
      I(this, "updateEmbeddables", () => {
        let t = new Set(),
          r = !1;
        this.scene.getNonDeletedElements().filter((n) => {
          if (Nr(n)) {
            if ((t.add(n.id), !this.embedsValidationStatus.has(n.id))) {
              r = !0;
              let i = gf(n.link, this.props.validateEmbeddable);
              this.updateEmbedValidationStatus(n, i);
            }
          } else Ui(n) && t.add(n.id);
          return !1;
        }),
          r && this.scene.triggerUpdate(),
          this.iFrameRefs.forEach((n, i) => {
            t.has(i) || this.iFrameRefs.delete(i);
          });
      });
      I(this, "getFrameNameDOMId", (t) => `${this.id}-frame-name-${t.id}`);
      I(this, "frameNameBoundsCache", {
        get: (t) => {
          let r = this.frameNameBoundsCache._cache.get(t.id);
          if (!r || r.zoom !== this.state.zoom.value || r.versionNonce !== t.versionNonce) {
            let n = document.getElementById(this.getFrameNameDOMId(t));
            if (n) {
              let i = n.getBoundingClientRect(),
                a = Oe({ clientX: i.x, clientY: i.y }, this.state),
                l = Oe({ clientX: i.right, clientY: i.bottom }, this.state);
              return (
                (r = {
                  x: a.x,
                  y: a.y,
                  width: l.x - a.x,
                  height: l.y - a.y,
                  angle: 0,
                  zoom: this.state.zoom.value,
                  versionNonce: t.versionNonce,
                }),
                this.frameNameBoundsCache._cache.set(t.id, r),
                r
              );
            }
            return null;
          }
          return r;
        },
        _cache: new Map(),
      });
      I(this, "resetEditingFrame", (t) => {
        t && this.scene.mutateElement(t, { name: t.name?.trim() || null }),
          this.setState({ editingFrame: null });
      });
      I(this, "renderFrameNames", () => {
        if (!this.state.frameRendering.enabled || !this.state.frameRendering.name)
          return this.state.editingFrame && this.resetEditingFrame(null), null;
        let t = this.state.theme === $d.DARK,
          r = this.scene.getNonDeletedFramesLikes(),
          n =
            r.length > 0 &&
            this.state.searchMatches?.focusedId &&
            Zt(this.scene.getElement(this.state.searchMatches.focusedId))
              ? this.state.searchMatches.matches.find((i) => i.focus)
              : null;
        return r.map((i) => {
          if (
            !iI(
              i,
              this.canvas.width / window.devicePixelRatio,
              this.canvas.height / window.devicePixelRatio,
              {
                offsetLeft: this.state.offsetLeft,
                offsetTop: this.state.offsetTop,
                scrollX: this.state.scrollX,
                scrollY: this.state.scrollY,
                zoom: this.state.zoom,
              },
              this.scene.getNonDeletedElementsMap()
            )
          )
            return this.state.editingFrame === i.id && this.resetEditingFrame(i), null;
          let { x: a, y: l } = qd({ sceneX: i.x, sceneY: i.y }, this.state),
            s = 6,
            d,
            m = FH(i);
          if (i.id === this.state.editingFrame) {
            let c = m;
            d = pe("input", {
              autoFocus: !0,
              value: c,
              onChange: (p) => {
                this.scene.mutateElement(i, { name: p.target.value });
              },
              onFocus: (p) => p.target.select(),
              onBlur: () => this.resetEditingFrame(i),
              onKeyDown: (p) => {
                (p.key === Y.ESCAPE || p.key === Y.ENTER) && this.resetEditingFrame(i);
              },
              style: {
                background: this.state.viewBackgroundColor,
                filter: t ? Gz : "none",
                zIndex: 2,
                border: "none",
                display: "block",
                padding: `${s}px`,
                borderRadius: 4,
                boxShadow: "inset 0 0 0 1px var(--color-primary)",
                fontFamily: "Assistant",
                fontSize: `${Dr.nameFontSize}px`,
                transform: `translate(-${s}px, ${s}px)`,
                color: "var(--color-gray-80)",
                overflow: "hidden",
                maxWidth: `${document.body.clientWidth - a - s}px`,
              },
              size: c.length + 1 || 1,
              dir: "auto",
              autoComplete: "off",
              autoCapitalize: "off",
              autoCorrect: "off",
            });
          } else d = m;
          return pe(
            "div",
            {
              id: this.getFrameNameDOMId(i),
              style: {
                position: "absolute",
                bottom: `${this.state.height + Dr.nameOffsetY - l + this.state.offsetTop}px`,
                left: `${a - this.state.offsetLeft}px`,
                zIndex: 2,
                fontSize: Dr.nameFontSize,
                color: t ? Dr.nameColorDarkTheme : Dr.nameColorLightTheme,
                lineHeight: Dr.nameLineHeight,
                width: "max-content",
                maxWidth:
                  n?.id === i.id && n?.focus ? "none" : `${i.width * this.state.zoom.value}px`,
                overflow: i.id === this.state.editingFrame ? "visible" : "hidden",
                whiteSpace: "nowrap",
                textOverflow: "ellipsis",
                cursor: De.MOVE,
                pointerEvents: this.state.viewModeEnabled ? zi.disabled : zi.enabled,
              },
              onPointerDown: (c) => this.handleCanvasPointerDown(c),
              onWheel: (c) => this.handleWheel(c),
              onContextMenu: this.handleCanvasContextMenu,
              onDoubleClick: () => {
                this.setState({ editingFrame: i.id });
              },
              children: d,
            },
            i.id
          );
        });
      });
      I(this, "focusContainer", () => {
        this.excalidrawContainerRef.current?.focus();
      });
      I(this, "getSceneElementsIncludingDeleted", () => this.scene.getElementsIncludingDeleted());
      I(this, "getSceneElementsMapIncludingDeleted", () =>
        this.scene.getElementsMapIncludingDeleted()
      );
      I(this, "getSceneElements", () => this.scene.getNonDeletedElements());
      I(this, "onInsertElements", (t) => {
        this.addElementsFromPasteOrLibrary({ elements: t, position: "center", files: null });
      });
      I(this, "onExportImage", async (t, r, n) => {
        re("export", t, "ui");
        let i = await jr(t, r, this.state, this.files, {
          exportBackground: this.state.exportBackground,
          name: this.getName(),
          viewBackgroundColor: this.state.viewBackgroundColor,
          exportingFrame: n.exportingFrame,
        })
          .catch(rH)
          .catch((a) => {
            console.error(a), this.setState({ errorMessage: a.message });
          });
        this.state.exportEmbedScene && i && Nl(i) && this.setState({ fileHandle: i });
      });
      I(this, "magicGenerations", new Map());
      I(this, "updateMagicGeneration", ({ frameElement: t, data: r }) => {
        r.status === "pending"
          ? this.scene.mutateElement(
              t,
              { customData: { generationData: void 0 } },
              { informMutation: !1, isDragging: !1 }
            )
          : this.scene.mutateElement(
              t,
              { customData: { generationData: r } },
              { informMutation: !1, isDragging: !1 }
            ),
          this.magicGenerations.set(t.id, r),
          this.triggerRender();
      });
      I(this, "plugins", {});
      I(this, "onMagicframeToolSelect", () => {
        let t = this.scene.getSelectedElements({
          selectedElementIds: this.state.selectedElementIds,
        });
        if (t.length === 0)
          this.setActiveTool({ type: ko.magicframe }),
            re("ai", "tool-select (empty-selection)", "d2c");
        else {
          let r = t.length === 1 && uf(t[0]) && t[0];
          if (!r && t.some((i) => Zt(i) || i.frameId)) {
            this.setActiveTool({ type: ko.magicframe });
            return;
          }
          re("ai", "tool-select (existing selection)", "d2c");
          let n;
          if (r) n = r;
          else {
            let [i, a, l, s] = Gi(t),
              d = 50;
            (n = JT({
              ...Dr,
              x: i - d,
              y: a - d,
              width: l - i + d * 2,
              height: s - a + d * 2,
              opacity: 100,
              locked: !1,
            })),
              this.scene.insertElement(n);
            for (let m of t) this.scene.mutateElement(m, { frameId: n.id });
            this.setState({ selectedElementIds: { [n.id]: !0 } });
          }
          this.onMagicFrameGenerate(n, "upstream");
        }
      });
      I(this, "openEyeDropper", ({ type: t }) => {
        this.updateEditorAtom(rr, {
          swapPreviewOnAlt: !0,
          colorPickerType: t === "stroke" ? "elementStroke" : "elementBackground",
          onSelect: (r, n) => {
            let i = (t === "background" && n.altKey) || (t === "stroke" && !n.altKey);
            !this.scene.getSelectedElements(this.state).length ||
            this.state.activeTool.type !== "selection"
              ? i
                ? this.syncActionResult({
                    appState: { ...this.state, currentItemStrokeColor: r },
                    captureUpdate: dt.IMMEDIATELY,
                  })
                : this.syncActionResult({
                    appState: { ...this.state, currentItemBackgroundColor: r },
                    captureUpdate: dt.IMMEDIATELY,
                  })
              : this.updateScene({
                  elements: this.scene
                    .getElementsIncludingDeleted()
                    .map((l) =>
                      this.state.selectedElementIds[l.id]
                        ? pn(l, { [i ? "strokeColor" : "backgroundColor"]: r })
                        : l
                    ),
                  captureUpdate: dt.IMMEDIATELY,
                });
          },
          keepOpenOnAlt: !1,
        });
      });
      I(this, "dismissLinearEditor", () => {
        setTimeout(() => {
          this.setState({ editingLinearElement: null });
        });
      });
      I(
        this,
        "syncActionResult",
        Pe((t) => {
          if (this.unmounted || t === !1) return;
          this.store.scheduleAction(t.captureUpdate);
          let r = !1,
            n = null;
          if (
            (t.elements && (this.scene.replaceAllElements(t.elements), (r = !0)),
            t.files &&
              (this.addMissingFiles(t.files, t.replaceFiles), this.addNewImagesToImageCache()),
            t.appState || n || this.state.contextMenu)
          ) {
            let i = t?.appState?.viewModeEnabled || !1,
              a = t?.appState?.zenModeEnabled || !1,
              l = t?.appState?.theme || this.props.theme || $d.LIGHT,
              s = t?.appState?.name ?? this.state.name,
              d = t?.appState?.errorMessage ?? this.state.errorMessage;
            typeof this.props.viewModeEnabled < "u" && (i = this.props.viewModeEnabled),
              typeof this.props.zenModeEnabled < "u" && (a = this.props.zenModeEnabled),
              (n = t.appState?.editingTextElement || null),
              t.elements &&
                n &&
                t.elements.forEach((m) => {
                  n?.id === m.id && n !== m && TI(m) && po(m) && (n = m);
                }),
              n?.isDeleted && (n = null),
              this.setState((m) => {
                let c = t.appState || {};
                return {
                  ...m,
                  ...c,
                  contextMenu: null,
                  editingTextElement: n,
                  viewModeEnabled: i,
                  zenModeEnabled: a,
                  theme: l,
                  name: s,
                  errorMessage: d,
                };
              }),
              (r = !0);
          }
          r || this.scene.triggerUpdate();
        })
      );
      I(
        this,
        "onBlur",
        Pe(() => {
          (hn = !1), this.setState({ isBindingEnabled: !0 });
        })
      );
      I(this, "onUnload", () => {
        this.onBlur();
      });
      I(this, "disableEvent", (t) => {
        t.preventDefault();
      });
      I(this, "resetHistory", () => {
        this.history.clear();
      });
      I(this, "resetStore", () => {
        this.store.clear();
      });
      I(
        this,
        "resetScene",
        Pe((t) => {
          this.scene.replaceAllElements([]),
            this.setState((r) => ({
              ...Jo(),
              isLoading: t?.resetLoadingState ? !1 : r.isLoading,
              theme: this.state.theme,
            })),
            this.resetStore(),
            this.resetHistory();
        })
      );
      I(this, "initializeScene", async () => {
        "launchQueue" in window &&
          "LaunchParams" in window &&
          window.launchQueue.setConsumer(async (n) => {
            if (!n.files.length) return;
            let i = n.files[0],
              a = await i.getFile();
            this.loadFileToCanvas(new File([a], a.name || "", { type: a.type }), i);
          }),
          this.props.theme && this.setState({ theme: this.props.theme }),
          this.state.isLoading || this.setState({ isLoading: !0 });
        let t = null;
        try {
          typeof this.props.initialData == "function"
            ? (t = (await this.props.initialData()) || null)
            : (t = (await this.props.initialData) || null),
            t?.libraryItems &&
              this.library.updateLibrary({ libraryItems: t.libraryItems, merge: !0 }).catch((n) => {
                console.error(n);
              });
        } catch (n) {
          console.error(n),
            (t = {
              appState: {
                errorMessage:
                  n.message || "Encountered an error during importing or restoring scene data",
              },
            });
        }
        let r = wn(t, null, null, { repairBindings: !0 });
        (r.appState = {
          ...r.appState,
          theme: this.props.theme || r.appState.theme,
          openSidebar: r.appState?.openSidebar || this.state.openSidebar,
          activeTool:
            r.appState.activeTool.type === "image"
              ? { ...r.appState.activeTool, type: "selection" }
              : r.appState.activeTool,
          isLoading: !1,
          toast: this.state.toast,
        }),
          t?.scrollToContent &&
            (r.appState = {
              ...r.appState,
              ...zr(r.elements, {
                ...r.appState,
                width: this.state.width,
                height: this.state.height,
                offsetTop: this.state.offsetTop,
                offsetLeft: this.state.offsetLeft,
              }),
            }),
          this.resetStore(),
          this.resetHistory(),
          this.syncActionResult({ ...r, captureUpdate: dt.NEVER }),
          this.clearImageShapeCache(),
          this.fonts.loadSceneFonts().then((n) => {
            this.fonts.onLoaded(n);
          }),
          wf(window.location.href) && this.scrollToContent(window.location.href, { animate: !1 });
      });
      I(this, "isMobileBreakpoint", (t, r) => t < Bz || (r < Rz && t < Nz));
      I(this, "refreshViewportBreakpoints", () => {
        if (!this.excalidrawContainerRef.current) return;
        let { clientWidth: r, clientHeight: n } = document.body,
          i = this.device.viewport,
          a = nf(i, { isLandscape: r > n, isMobile: this.isMobileBreakpoint(r, n) });
        return i !== a ? ((this.device = { ...this.device, viewport: a }), !0) : !1;
      });
      I(this, "refreshEditorBreakpoints", () => {
        let t = this.excalidrawContainerRef.current;
        if (!t) return;
        let { width: r, height: n } = t.getBoundingClientRect(),
          i =
            this.props.UIOptions.dockedSidebarBreakpoint != null
              ? this.props.UIOptions.dockedSidebarBreakpoint
              : Fz,
          a = this.device.editor,
          l = nf(a, { isMobile: this.isMobileBreakpoint(r, n), canFitSidebar: r > i });
        return a !== l ? ((this.device = { ...this.device, editor: l }), !0) : !1;
      });
      I(
        this,
        "onResize",
        Pe(() => {
          this.scene.getElementsIncludingDeleted().forEach((t) => bl.delete(t)),
            this.refreshViewportBreakpoints(),
            this.updateDOMRect(),
            GT || this.refreshEditorBreakpoints(),
            this.setState({});
        })
      );
      I(this, "onFullscreenChange", () => {
        !document.fullscreenElement &&
          this.state.activeEmbeddable?.state === "active" &&
          this.setState({ activeEmbeddable: null });
      });
      I(
        this,
        "renderInteractiveSceneCallback",
        ({ atLeastOneVisibleElement: t, scrollBars: r, elementsMap: n }) => {
          r && (wl = r);
          let i = this.state.editingTextElement ? !1 : !t && n.size > 0;
          this.state.scrolledOutside !== i && this.setState({ scrolledOutside: i }),
            this.scheduleImageRefresh();
        }
      );
      I(
        this,
        "onScroll",
        WT(() => {
          let { offsetTop: t, offsetLeft: r } = this.getCanvasOffsets();
          this.setState((n) =>
            n.offsetLeft === r && n.offsetTop === t ? null : { offsetTop: t, offsetLeft: r }
          );
        }, Oz)
      );
      I(
        this,
        "onCut",
        Pe((t) => {
          !this.excalidrawContainerRef.current?.contains(document.activeElement) ||
            pl(t.target) ||
            (this.actionManager.executeAction(oc, "keyboard", t),
            t.preventDefault(),
            t.stopPropagation());
        })
      );
      I(
        this,
        "onCopy",
        Pe((t) => {
          !this.excalidrawContainerRef.current?.contains(document.activeElement) ||
            pl(t.target) ||
            (this.actionManager.executeAction(ri, "keyboard", t),
            t.preventDefault(),
            t.stopPropagation());
        })
      );
      I(this, "onTouchStart", (t) => {
        if ((Vz && t.preventDefault(), !El)) {
          (El = !0), clearTimeout(Tf), (Tf = window.setTimeout(e.resetTapTwice, zz));
          return;
        }
        if (El && t.touches.length === 1) {
          let r = t.touches[0];
          this.handleCanvasDoubleClick({ clientX: r.clientX, clientY: r.clientY }),
            (El = !1),
            clearTimeout(Tf);
        }
        t.touches.length === 2 &&
          this.setState({ selectedElementIds: ye({}, this.state), activeEmbeddable: null });
      });
      I(this, "onTouchEnd", (t) => {
        this.resetContextMenuTimer(),
          t.touches.length > 0
            ? this.setState({
                previousSelectedElementIds: {},
                selectedElementIds: ye(this.state.previousSelectedElementIds, this.state),
              })
            : ue.pointers.clear();
      });
      I(
        this,
        "pasteFromClipboard",
        Pe(async (t) => {
          let r = !!Qd,
            n = document.activeElement,
            i = this.excalidrawContainerRef.current?.contains(n);
          if (t && !i) return;
          let a = document.elementFromPoint(
            this.lastViewportPosition.x,
            this.lastViewportPosition.y
          );
          if (t && (!(a instanceof HTMLCanvasElement) || pl(n))) return;
          let { x: l, y: s } = Oe(
              { clientX: this.lastViewportPosition.x, clientY: this.lastViewportPosition.y },
              this.state
            ),
            d = t?.clipboardData?.files[0],
            m = await Vs(t, r);
          if (!d && !r) {
            if (m.mixedContent)
              return this.addElementsFromMixedContentPaste(m.mixedContent, {
                isPlainPaste: r,
                sceneX: l,
                sceneY: s,
              });
            if (m.text) {
              let c = m.text.trim();
              c.startsWith("<svg") && c.endsWith("</svg>") && (d = Em(c));
            }
          }
          if (Bl(d) && !m.spreadsheet) {
            if (!this.isToolSupported("image")) {
              this.setState({ errorMessage: g("errors.imageToolNotSupported") });
              return;
            }
            this.createImageElement({ sceneX: l, sceneY: s, imageFile: d });
            return;
          }
          if (this.props.onPaste)
            try {
              if ((await this.props.onPaste(m, t)) === !1) return;
            } catch (c) {
              console.error(c);
            }
          if (m.errorMessage) this.setState({ errorMessage: m.errorMessage });
          else if (m.spreadsheet && !r)
            this.setState({ pasteDialog: { data: m.spreadsheet, shown: !0 } });
          else if (m.elements) {
            let c = m.programmaticAPI ? Si(m.elements) : m.elements;
            this.addElementsFromPasteOrLibrary({
              elements: c,
              files: m.files || null,
              position: "cursor",
              retainSeed: r,
            });
          } else if (m.text) {
            if (m.text && uv(m.text)) {
              let u = await import("@excalidraw/mermaid-to-excalidraw");
              try {
                let { elements: f, files: b } = await u.parseMermaidToExcalidraw(m.text),
                  x = Si(f, { regenerateIds: !0 });
                this.addElementsFromPasteOrLibrary({ elements: x, files: b, position: "cursor" });
                return;
              } catch (f) {
                console.warn(`parsing pasted text as mermaid definition failed: ${f.message}`);
              }
            }
            let c = iH(m.text)
                .split(/\n+/)
                .map((u) => u.trim())
                .filter(Boolean),
              p = c
                .map((u) => kH(u))
                .filter(
                  (u) =>
                    gf(u, this.props.validateEmbeddable) &&
                    (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(u) || Jd(u)?.type === "video")
                );
            if (!Qd && p.length > 0 && p.length === c.length) {
              let u = [];
              for (let f of p) {
                let b = u[u.length - 1],
                  x = this.insertEmbeddableElement({
                    sceneX: b ? b.x + b.width + 20 : l,
                    sceneY: s,
                    link: tf(f),
                  });
                x && u.push(x);
              }
              u.length &&
                (this.store.scheduleCapture(),
                this.setState({
                  selectedElementIds: Object.fromEntries(u.map((f) => [f.id, !0])),
                }));
              return;
            }
            this.addTextFromPaste(m.text, r);
          }
          this.setActiveTool({ type: "selection" }), t?.preventDefault();
        })
      );
      I(this, "addElementsFromPasteOrLibrary", (t) => {
        let r = gm(t.elements, null, void 0),
          [n, i, a, l] = Gi(r),
          s = Hi(n, a) / 2,
          d = Hi(i, l) / 2,
          m =
            typeof t.position == "object"
              ? t.position.clientX
              : t.position === "cursor"
              ? this.lastViewportPosition.x
              : this.state.width / 2 + this.state.offsetLeft,
          c =
            typeof t.position == "object"
              ? t.position.clientY
              : t.position === "cursor"
              ? this.lastViewportPosition.y
              : this.state.height / 2 + this.state.offsetTop,
          { x: p, y: u } = Oe({ clientX: m, clientY: c }, this.state),
          f = p - s,
          b = u - d,
          [x, w] = nt(f, b, this.getEffectiveGridSize()),
          { duplicatedElements: E } = tI({
            type: "everything",
            elements: r.map((k) => pn(k, { x: k.x + x - n, y: k.y + w - i })),
            randomizeSeed: !t.retainSeed,
          }),
          y = this.scene.getElementsIncludingDeleted(),
          v = [...y, ...E];
        (v = this.props.onDuplicate?.(v, y) || v), xI(v, KT(E));
        let S = this.getTopLayerFrameAtSceneCoords({ x: p, y: u });
        if (S) {
          let k = zH(E, S);
          xf(v, k, S, this.state);
        }
        this.scene.replaceAllElements(v),
          E.forEach((k) => {
            if (po(k) && pf(k)) {
              let A = dI(k, this.scene.getElementsMapIncludingDeleted());
              AH(k, A, this.scene);
            }
          }),
          Zz &&
            qo.loadElementsFonts(E).then((k) => {
              this.fonts.onLoaded(k);
            }),
          t.files && this.addMissingFiles(t.files);
        let M = iG(E);
        this.store.scheduleCapture(),
          this.setState(
            {
              ...this.state,
              openSidebar:
                this.state.openSidebar && this.device.editor.canFitSidebar && He.get(el)
                  ? this.state.openSidebar
                  : null,
              ...uo(
                {
                  editingGroupId: null,
                  selectedElementIds: M.reduce((k, A) => (pf(A) || (k[A.id] = !0), k), {}),
                },
                this.scene.getNonDeletedElements(),
                this.state,
                this
              ),
            },
            () => {
              t.files && this.addNewImagesToImageCache();
            }
          ),
          this.setActiveTool({ type: "selection" }),
          t.fitToContent &&
            this.scrollToContent(E, { fitToContent: !0, canvasOffsets: this.getEditorUIOffsets() });
      });
      I(this, "setAppState", (t, r) => {
        this.setState(t, r);
      });
      I(this, "removePointer", (t) => {
        Br && this.resetContextMenuTimer(), ue.pointers.delete(t.pointerId);
      });
      I(this, "toggleLock", (t = "ui") => {
        this.state.activeTool.locked ||
          re(
            "toolbar",
            "toggleLock",
            `${t} (${this.device.editor.isMobile ? "mobile" : "desktop"})`
          ),
          this.setState((r) => ({
            activeTool: {
              ...r.activeTool,
              ...Zo(this.state, r.activeTool.locked ? { type: "selection" } : r.activeTool),
              locked: !r.activeTool.locked,
            },
          }));
      });
      I(this, "updateFrameRendering", (t) => {
        this.setState((r) => {
          let n = typeof t == "function" ? t(r.frameRendering) : t;
          return {
            frameRendering: {
              enabled: n?.enabled ?? r.frameRendering.enabled,
              clip: n?.clip ?? r.frameRendering.clip,
              name: n?.name ?? r.frameRendering.name,
              outline: n?.outline ?? r.frameRendering.outline,
            },
          };
        });
      });
      I(this, "togglePenMode", (t) => {
        this.setState((r) => ({ penMode: t ?? !r.penMode, penDetected: !0 }));
      });
      I(this, "onHandToolToggle", () => {
        this.actionManager.executeAction(Ex);
      });
      I(this, "zoomCanvas", (t) => {
        this.setState({
          ..._o(
            {
              viewportX: this.state.width / 2 + this.state.offsetLeft,
              viewportY: this.state.height / 2 + this.state.offsetTop,
              nextZoom: go(t),
            },
            this.state
          ),
        });
      });
      I(this, "cancelInProgressAnimation", null);
      I(this, "scrollToContent", (t = this.scene.getNonDeletedElements(), r) => {
        if (typeof t == "string") {
          let s;
          if ((wf(t) ? (s = KH(t)) : (s = t), s)) {
            let d = this.scene.getElementsFromId(s);
            d?.length
              ? this.scrollToContent(d, {
                  fitToContent: r?.fitToContent ?? !0,
                  animate: r?.animate ?? !0,
                })
              : wf(t) &&
                this.setState({
                  toast: { message: g("elementLink.notFound"), duration: 3e3, closable: !0 },
                });
          }
          return;
        }
        this.cancelInProgressAnimation?.();
        let n = Array.isArray(t) ? t : [t],
          i = this.state.zoom,
          a = this.state.scrollX,
          l = this.state.scrollY;
        if (r?.fitToContent || r?.fitToViewport) {
          let { appState: s } = fa({
            canvasOffsets: r.canvasOffsets,
            targetElements: n,
            appState: this.state,
            fitToViewport: !!r?.fitToViewport,
            viewportZoomFactor: r?.viewportZoomFactor,
            minZoom: r?.minZoom,
            maxZoom: r?.maxZoom,
          });
          (i = s.zoom), (a = s.scrollX), (l = s.scrollY);
        } else {
          let s = zr(n, this.state);
          (a = s.scrollX), (l = s.scrollY);
        }
        if (r?.animate) {
          let s = this.state.scrollX,
            d = this.state.scrollY,
            m = this.state.zoom.value,
            c = oH({
              fromValues: { scrollX: s, scrollY: d, zoom: m },
              toValues: { scrollX: a, scrollY: l, zoom: i.value },
              interpolateValue: (p, u, f, b) => {
                if (b === "zoom") return p * Math.pow(u / p, nH(f));
              },
              onStep: ({ scrollX: p, scrollY: u, zoom: f }) => {
                this.setState({ scrollX: p, scrollY: u, zoom: { value: f } });
              },
              onStart: () => {
                this.setState({ shouldCacheIgnoreZoom: !0 });
              },
              onEnd: () => {
                this.setState({ shouldCacheIgnoreZoom: !1 });
              },
              onCancel: () => {
                this.setState({ shouldCacheIgnoreZoom: !1 });
              },
              duration: r?.duration ?? 500,
            });
          this.cancelInProgressAnimation = () => {
            c(), (this.cancelInProgressAnimation = null);
          };
        } else this.setState({ scrollX: a, scrollY: l, zoom: i });
      });
      I(this, "maybeUnfollowRemoteUser", () => {
        this.state.userToFollow && this.setState({ userToFollow: null });
      });
      I(this, "translateCanvas", (t) => {
        this.cancelInProgressAnimation?.(), this.maybeUnfollowRemoteUser(), this.setState(t);
      });
      I(this, "setToast", (t) => {
        this.setState({ toast: t });
      });
      I(this, "restoreFileFromShare", async () => {
        try {
          let t = await caches.open("web-share-target"),
            r = await t.match("shared-file");
          if (r) {
            let n = await r.blob(),
              i = new File([n], n.name || "", { type: n.type });
            this.loadFileToCanvas(i, null),
              await t.delete("shared-file"),
              window.history.replaceState(null, Mz, window.location.pathname);
          }
        } catch (t) {
          this.setState({ errorMessage: t.message });
        }
      });
      I(
        this,
        "addFiles",
        Pe((t) => {
          let { addedFiles: r } = this.addMissingFiles(t);
          this.clearImageShapeCache(r), this.scene.triggerUpdate(), this.addNewImagesToImageCache();
        })
      );
      I(this, "addMissingFiles", (t, r = !1) => {
        let n = r ? {} : { ...this.files },
          i = {},
          a = Array.isArray(t) ? t : Object.values(t);
        for (let l of a)
          if (!n[l.id] && ((i[l.id] = l), (n[l.id] = l), l.mimeType === _r.svg))
            try {
              let s = u1(cI(h1(l.dataURL)), _r.svg);
              l.dataURL !== s && ((l.version = (l.version ?? 1) + 1), (l.dataURL = s));
            } catch (s) {
              console.error(s);
            }
        return (this.files = n), { addedFiles: i };
      });
      I(
        this,
        "updateScene",
        Pe((t) => {
          let { elements: r, appState: n, collaborators: i, captureUpdate: a } = t;
          if (a) {
            let l = r || void 0,
              s = n ? cH({ ...this.store.snapshot.appState, ...n }) : void 0;
            this.store.scheduleMicroAction({ action: a, elements: l, appState: s });
          }
          n && this.setState(n),
            r && this.scene.replaceAllElements(r),
            i && this.setState({ collaborators: i });
        })
      );
      I(this, "mutateElement", (t, r, n = !0) =>
        this.scene.mutateElement(t, r, { informMutation: n, isDragging: !1 })
      );
      I(this, "triggerRender", (t) => {
        t === !0 ? this.scene.triggerUpdate() : this.setState({});
      });
      I(this, "toggleSidebar", ({ name: t, tab: r, force: n }) => {
        let i;
        n === void 0
          ? (i = this.state.openSidebar?.name === t && this.state.openSidebar?.tab === r ? null : t)
          : (i = n ? t : null);
        let a = i ? { name: i } : null;
        return a && r && (a.tab = r), this.setState({ openSidebar: a }), !!i;
      });
      I(
        this,
        "updateCurrentCursorPosition",
        Pe((t) => {
          (this.lastViewportPosition.x = t.clientX), (this.lastViewportPosition.y = t.clientY);
        })
      );
      I(this, "getEditorUIOffsets", () => {
        let t =
            this.excalidrawContainerRef?.current
              ?.querySelector(".App-toolbar")
              ?.getBoundingClientRect()?.bottom ?? 0,
          r = this.excalidrawContainerRef?.current
            ?.querySelector(".sidebar")
            ?.getBoundingClientRect(),
          n = this.excalidrawContainerRef?.current
            ?.querySelector(".App-menu__left")
            ?.getBoundingClientRect(),
          i = 16;
        return Po().rtl
          ? {
              top: t + i,
              right: Math.max(this.state.width - (n?.left ?? this.state.width), 0) + i,
              bottom: i,
              left: Math.max(r?.right ?? 0, 0) + i,
            }
          : {
              top: t + i,
              right: Math.max(this.state.width - (r?.left ?? this.state.width) + i, 0),
              bottom: i,
              left: Math.max(n?.right ?? 0, 0) + i,
            };
      });
      I(
        this,
        "onKeyDown",
        Pe((t) => {
          if (
            ("Proxy" in window &&
              ((!t.shiftKey && /^[A-Z]$/.test(t.key)) || (t.shiftKey && /^[a-z]$/.test(t.key))) &&
              (t = new Proxy(t, {
                get(a, l) {
                  let s = a[l];
                  return typeof s == "function"
                    ? s.bind(a)
                    : l === "key"
                    ? t.shiftKey
                      ? a.key.toUpperCase()
                      : a.key.toLowerCase()
                    : s;
                },
              })),
            !VT(t.target))
          ) {
            if ((t.key === Y.ESCAPE || t.key === Y.ENTER) && this.state.croppingElementId) {
              this.finishImageCropping();
              return;
            }
            let a = Z(this.scene.getNonDeletedElementsMap(), this.state);
            if (a.length === 1 && un(a[0]) && t.key === Y.ENTER) {
              this.startImageCropping(a[0]);
              return;
            }
            if (t.key === Y.ESCAPE) this.updateEditorAtom(io, null);
            else if (
              t.key === Y.TAB &&
              (document.activeElement === this.excalidrawContainerRef?.current ||
                document.activeElement?.classList.contains(sH.CONVERT_ELEMENT_TYPE_POPUP))
            ) {
              t.preventDefault();
              let s = mi(a);
              He.get(io)?.type === "panel" &&
                Lu(this, { conversionType: s, direction: t.shiftKey ? "left" : "right" }) &&
                this.store.scheduleCapture(),
                s && this.updateEditorAtom(io, { type: "panel" });
            }
            if (t.key === Y.ESCAPE && this.flowChartCreator.isCreatingChart) {
              this.flowChartCreator.clear(), this.triggerRender(!0);
              return;
            }
            let l = Kd(t.key);
            if (t[Y.CTRL_OR_CMD] && l && !t.shiftKey) {
              t.preventDefault();
              let s = Z(this.scene.getNonDeletedElementsMap(), this.state);
              s.length === 1 &&
                TH(s[0]) &&
                this.flowChartCreator.createNodes(s[0], this.state, gI(t.key), this.scene),
                this.flowChartCreator.pendingNodes?.length &&
                  !hf(
                    this.flowChartCreator.pendingNodes,
                    this.canvas.width / window.devicePixelRatio,
                    this.canvas.height / window.devicePixelRatio,
                    {
                      offsetLeft: this.state.offsetLeft,
                      offsetTop: this.state.offsetTop,
                      scrollX: this.state.scrollX,
                      scrollY: this.state.scrollY,
                      zoom: this.state.zoom,
                    },
                    this.scene.getNonDeletedElementsMap(),
                    this.getEditorUIOffsets()
                  ) &&
                  this.scrollToContent(this.flowChartCreator.pendingNodes, {
                    animate: !0,
                    duration: 300,
                    fitToContent: !0,
                    canvasOffsets: this.getEditorUIOffsets(),
                  });
              return;
            }
            if (t.altKey) {
              let s = Z(this.scene.getNonDeletedElementsMap(), this.state);
              if (s.length === 1 && l) {
                t.preventDefault();
                let d = this.flowChartNavigator.exploreByDirection(
                  s[0],
                  this.scene.getNonDeletedElementsMap(),
                  gI(t.key)
                );
                if (d) {
                  this.setState((c) => ({ selectedElementIds: ye({ [d]: !0 }, c) }));
                  let m = this.scene.getNonDeletedElementsMap().get(d);
                  m &&
                    !hf(
                      [m],
                      this.canvas.width / window.devicePixelRatio,
                      this.canvas.height / window.devicePixelRatio,
                      {
                        offsetLeft: this.state.offsetLeft,
                        offsetTop: this.state.offsetTop,
                        scrollX: this.state.scrollX,
                        scrollY: this.state.scrollY,
                        zoom: this.state.zoom,
                      },
                      this.scene.getNonDeletedElementsMap(),
                      this.getEditorUIOffsets()
                    ) &&
                    this.scrollToContent(m, {
                      animate: !0,
                      duration: 300,
                      canvasOffsets: this.getEditorUIOffsets(),
                    });
                }
                return;
              }
            }
          }
          if (t[Y.CTRL_OR_CMD] && t.key === Y.P && !t.shiftKey && !t.altKey) {
            this.setToast({
              message: g("commandPalette.shortcutHint", { shortcut: Ne("commandPalette") }),
            }),
              t.preventDefault();
            return;
          }
          if (
            (t[Y.CTRL_OR_CMD] &&
              t.key.toLowerCase() === Y.V &&
              ((Qd = t.shiftKey),
              clearTimeout(CI),
              (CI = window.setTimeout(() => {
                Qd = !1;
              }, 100))),
            t[Y.CTRL_OR_CMD] && pl(t.target) && (t.code === NT.MINUS || t.code === NT.EQUAL))
          ) {
            t.preventDefault();
            return;
          }
          if ((pl(t.target) && t.key !== Y.ESCAPE) || (Kd(t.key) && VT(t.target))) return;
          if (t.key === Y.QUESTION_MARK) {
            this.setState({ openDialog: { name: "help" } });
            return;
          } else if (t.key.toLowerCase() === Y.E && t.shiftKey && t[Y.CTRL_OR_CMD]) {
            t.preventDefault(), this.setState({ openDialog: { name: "imageExport" } });
            return;
          }
          if (t.key === Y.PAGE_UP || t.key === Y.PAGE_DOWN) {
            let a = (t.shiftKey ? this.state.width : this.state.height) / this.state.zoom.value;
            t.key === Y.PAGE_DOWN && (a = -a),
              t.shiftKey
                ? this.translateCanvas((l) => ({ scrollX: l.scrollX + a }))
                : this.translateCanvas((l) => ({ scrollY: l.scrollY + a }));
          }
          if (
            this.state.openDialog?.name === "elementLinkSelector" ||
            this.actionManager.handleKeyDown(t) ||
            this.state.viewModeEnabled
          )
            return;
          if (
            (t[Y.CTRL_OR_CMD] &&
              this.state.isBindingEnabled &&
              this.setState({ isBindingEnabled: !1 }),
            Kd(t.key))
          ) {
            let a = this.scene.getSelectedElements({
                selectedElementIds: this.state.selectedElementIds,
                includeBoundTextElement: !0,
                includeElementsInFrames: !0,
              }),
              l = a.find(We),
              s = new Set();
            a
              .filter(We)
              .filter((p) => {
                let u = p.startBinding && !a.some((b) => b.id === p.startBinding?.elementId),
                  f = p.endBinding && !a.some((b) => b.id === p.endBinding?.elementId);
                return u || f;
              })
              .forEach((p) => s.add(p.id)),
              (a = a.filter((p) => !s.has(p.id)));
            let d =
                (this.getEffectiveGridSize() && (t.shiftKey ? zT : this.getEffectiveGridSize())) ||
                (t.shiftKey ? Pz : zT),
              m = 0,
              c = 0;
            t.key === Y.ARROW_LEFT
              ? (m = -d)
              : t.key === Y.ARROW_RIGHT
              ? (m = d)
              : t.key === Y.ARROW_UP
              ? (c = -d)
              : t.key === Y.ARROW_DOWN && (c = d),
              a.forEach((p) => {
                this.scene.mutateElement(
                  p,
                  { x: p.x + m, y: p.y + c },
                  { informMutation: !1, isDragging: !1 }
                ),
                  sf(p, this.scene, { simultaneouslyUpdated: a });
              }),
              this.setState({
                suggestedBindings: cf(
                  a.filter((p) => p.id !== l?.id || d !== 0),
                  this.scene.getNonDeletedElementsMap(),
                  this.state.zoom
                ),
              }),
              this.scene.triggerUpdate(),
              t.preventDefault();
          } else if (t.key === Y.ENTER) {
            let a = this.scene.getSelectedElements(this.state);
            if (a.length === 1) {
              let l = a[0];
              if (t[Y.CTRL_OR_CMD] || vf(l))
                $t(l) &&
                  (!this.state.editingLinearElement ||
                    this.state.editingLinearElement.elementId !== l.id) &&
                  (this.store.scheduleCapture(),
                  We(l) ||
                    this.setState({
                      editingLinearElement: new ve(l, this.scene.getNonDeletedElementsMap()),
                    }));
              else if (po(l) || PH(l)) {
                let s;
                po(l) || (s = l);
                let d = bf(l, this.state, this.scene.getNonDeletedElementsMap()),
                  m = d.x,
                  c = d.y;
                this.startTextEditing({ sceneX: m, sceneY: c, container: s }), t.preventDefault();
                return;
              } else Zt(l) && this.setState({ editingFrame: l.id });
            }
          } else if (
            !t.ctrlKey &&
            !t.altKey &&
            !t.metaKey &&
            !this.state.newElement &&
            !this.state.selectionElement &&
            !this.state.selectedElementsAreBeingDragged
          ) {
            let a = l2(t.key);
            a
              ? (this.state.activeTool.type !== a &&
                  re(
                    "toolbar",
                    a,
                    `keyboard (${this.device.editor.isMobile ? "mobile" : "desktop"})`
                  ),
                a === "arrow" &&
                  this.state.activeTool.type === "arrow" &&
                  this.setState((l) => ({
                    currentItemArrowType:
                      l.currentItemArrowType === Rr.sharp
                        ? Rr.round
                        : l.currentItemArrowType === Rr.round
                        ? Rr.elbow
                        : Rr.sharp,
                  })),
                this.setActiveTool({ type: a }),
                t.stopPropagation())
              : t.key === Y.Q && (this.toggleLock("keyboard"), t.stopPropagation());
          }
          if (
            (t.key === Y.SPACE &&
              ue.pointers.size === 0 &&
              ((hn = !0), xe(this.interactiveCanvas, De.GRAB), t.preventDefault()),
            (t.key === Y.G || t.key === Y.S) && !t.altKey && !t[Y.CTRL_OR_CMD])
          ) {
            let a = this.scene.getSelectedElements(this.state);
            if (this.state.activeTool.type === "selection" && !a.length) return;
            t.key === Y.G &&
              (jo(this.state.activeTool.type) || a.some((l) => jo(l.type))) &&
              (this.setState({ openPopup: "elementBackground" }), t.stopPropagation()),
              t.key === Y.S && (this.setState({ openPopup: "elementStroke" }), t.stopPropagation());
          }
          if (!t[Y.CTRL_OR_CMD] && t.shiftKey && t.key.toLowerCase() === Y.F) {
            let a = this.scene.getSelectedElements(this.state);
            if (this.state.activeTool.type === "selection" && !a.length) return;
            (this.state.activeTool.type === "text" ||
              a.find((l) => po(l) || ff(l, this.scene.getNonDeletedElementsMap()))) &&
              (t.preventDefault(), this.setState({ openPopup: "fontFamily" }));
          }
          if (t.key === Y.K && !t.altKey && !t[Y.CTRL_OR_CMD]) {
            this.state.activeTool.type === "laser"
              ? this.setActiveTool({ type: "selection" })
              : this.setActiveTool({ type: "laser" });
            return;
          }
          t[Y.CTRL_OR_CMD] &&
            (t.key === Y.BACKSPACE || t.key === Y.DELETE) &&
            this.updateEditorAtom(on, "clearCanvas");
          let r = t.key.toLocaleLowerCase(),
            n = r === Y.S && t.shiftKey,
            i = t.key === Y.I || (r === Y.G && t.shiftKey);
          (n || i) && this.openEyeDropper({ type: n ? "stroke" : "background" });
        })
      );
      I(
        this,
        "onKeyUp",
        Pe((t) => {
          if (
            (t.key === Y.SPACE &&
              (this.state.viewModeEnabled || this.state.openDialog?.name === "elementLinkSelector"
                ? xe(this.interactiveCanvas, De.GRAB)
                : this.state.activeTool.type === "selection" ||
                  this.state.activeTool.type === "lasso"
                ? Ht(this.interactiveCanvas)
                : (Pt(this.interactiveCanvas, this.state),
                  this.setState({
                    selectedElementIds: ye({}, this.state),
                    selectedGroupIds: {},
                    editingGroupId: null,
                    activeEmbeddable: null,
                  })),
              (hn = !1)),
            !t[Y.CTRL_OR_CMD] &&
              !this.state.isBindingEnabled &&
              this.setState({ isBindingEnabled: !0 }),
            Kd(t.key) &&
              (jT(
                this.scene.getSelectedElements(this.state).filter($t),
                lf(this.state),
                this.state.selectedLinearElement?.selectedPointsIndices ?? [],
                this.scene,
                this.state.zoom
              ),
              this.setState({ suggestedBindings: [] })),
            t.altKey ||
              (this.flowChartNavigator.isExploring &&
                (this.flowChartNavigator.clear(),
                this.syncActionResult({ captureUpdate: dt.IMMEDIATELY }))),
            !t[Y.CTRL_OR_CMD] && this.flowChartCreator.isCreatingChart)
          ) {
            this.flowChartCreator.pendingNodes?.length &&
              this.scene.insertElements(this.flowChartCreator.pendingNodes);
            let r = this.flowChartCreator.pendingNodes?.[0];
            r &&
              (this.setState((n) => ({ selectedElementIds: ye({ [r.id]: !0 }, n) })),
              hf(
                [r],
                this.canvas.width / window.devicePixelRatio,
                this.canvas.height / window.devicePixelRatio,
                {
                  offsetLeft: this.state.offsetLeft,
                  offsetTop: this.state.offsetTop,
                  scrollX: this.state.scrollX,
                  scrollY: this.state.scrollY,
                  zoom: this.state.zoom,
                },
                this.scene.getNonDeletedElementsMap(),
                this.getEditorUIOffsets()
              ) ||
                this.scrollToContent(r, {
                  animate: !0,
                  duration: 300,
                  canvasOffsets: this.getEditorUIOffsets(),
                })),
              this.flowChartCreator.clear(),
              this.syncActionResult({ captureUpdate: dt.IMMEDIATELY });
          }
        })
      );
      I(this, "isToolSupported", (t) => this.props.UIOptions.tools?.[t] !== !1);
      I(this, "setActiveTool", (t, r = !1) => {
        if (!this.isToolSupported(t.type)) {
          console.warn(
            `"${t.type}" tool is disabled via "UIOptions.canvasActions.tools.${t.type}"`
          );
          return;
        }
        let n = Zo(this.state, t);
        n.type === "hand"
          ? xe(this.interactiveCanvas, De.GRAB)
          : hn || Pt(this.interactiveCanvas, { ...this.state, activeTool: n }),
          Jz(document.activeElement) && this.focusContainer(),
          wH(n.type) || this.setState({ suggestedBindings: [] }),
          n.type === "image" && this.onImageAction(),
          this.setState((i) => {
            let a = {
              snapLines: i.snapLines.length ? [] : i.snapLines,
              originSnapOffset: null,
              activeEmbeddable: null,
            };
            return (
              n.type === "freedraw" && this.store.scheduleCapture(),
              n.type === "lasso"
                ? {
                    ...i,
                    activeTool: n,
                    ...(r
                      ? {}
                      : {
                          selectedElementIds: ye({}, i),
                          selectedGroupIds: ye({}, i),
                          editingGroupId: null,
                          multiElement: null,
                        }),
                    ...a,
                  }
                : n.type !== "selection"
                ? {
                    ...i,
                    activeTool: n,
                    selectedElementIds: ye({}, i),
                    selectedGroupIds: ye({}, i),
                    editingGroupId: null,
                    multiElement: null,
                    ...a,
                  }
                : { ...i, activeTool: n, ...a }
            );
          });
      });
      I(this, "setOpenDialog", (t) => {
        this.setState({ openDialog: t });
      });
      I(this, "setCursor", (t) => {
        xe(this.interactiveCanvas, t);
      });
      I(this, "resetCursor", () => {
        Ht(this.interactiveCanvas);
      });
      I(this, "isTouchScreenMultiTouchGesture", () => ue.pointers.size >= 2);
      I(
        this,
        "getName",
        () => this.state.name || this.props.name || `${g("labels.untitled")}-${XT()}`
      );
      I(
        this,
        "onGestureStart",
        Pe((t) => {
          t.preventDefault(),
            this.isTouchScreenMultiTouchGesture() &&
              this.setState({ selectedElementIds: ye({}, this.state), activeEmbeddable: null }),
            (ue.initialScale = this.state.zoom.value);
        })
      );
      I(
        this,
        "onGestureChange",
        Pe((t) => {
          if ((t.preventDefault(), this.isTouchScreenMultiTouchGesture())) return;
          let r = ue.initialScale;
          r &&
            this.setState((n) => ({
              ..._o(
                {
                  viewportX: this.lastViewportPosition.x,
                  viewportY: this.lastViewportPosition.y,
                  nextZoom: go(r * t.scale),
                },
                n
              ),
            }));
        })
      );
      I(
        this,
        "onGestureEnd",
        Pe((t) => {
          t.preventDefault(),
            this.isTouchScreenMultiTouchGesture() &&
              this.setState({
                previousSelectedElementIds: {},
                selectedElementIds: ye(this.state.previousSelectedElementIds, this.state),
              }),
            (ue.initialScale = null);
        })
      );
      I(
        this,
        "startTextEditing",
        ({
          sceneX: t,
          sceneY: r,
          insertAtParentCenter: n = !0,
          container: i,
          autoEdit: a = !0,
        }) => {
          let l = !1,
            s = n && this.getTextWysiwygSnappedToCenterPosition(t, r, this.state, i);
          i && s && (ff(i, this.scene.getNonDeletedElementsMap()) || (l = !0));
          let d = null,
            m = this.scene.getSelectedElements(this.state);
          m.length === 1
            ? po(m[0])
              ? (d = m[0])
              : i
              ? (d = ff(m[0], this.scene.getNonDeletedElementsMap()))
              : (d = this.getTextElementAtPosition(t, r))
            : (d = this.getTextElementAtPosition(t, r));
          let c = d?.fontFamily || this.state.currentItemFontFamily,
            p = d?.lineHeight || YT(c),
            u = this.state.currentItemFontSize;
          if (!d && l && i && !df(i)) {
            let w = qH(of({ fontSize: u, fontFamily: c }), p),
              E = JH(u, p),
              y = Math.max(i.height, E),
              v = Math.max(i.width, w);
            this.scene.mutateElement(i, { height: y, width: v }),
              (t = i.x + v / 2),
              (r = i.y + y / 2),
              s && (s = this.getTextWysiwygSnappedToCenterPosition(t, r, this.state, i));
          }
          let f = this.getTopLayerFrameAtSceneCoords({ x: t, y: r }),
            b =
              d ||
              QT({
                x: s ? s.elementCenterX : t,
                y: s ? s.elementCenterY : r,
                strokeColor: this.state.currentItemStrokeColor,
                backgroundColor: this.state.currentItemBackgroundColor,
                fillStyle: this.state.currentItemFillStyle,
                strokeWidth: this.state.currentItemStrokeWidth,
                strokeStyle: this.state.currentItemStrokeStyle,
                roughness: this.state.currentItemRoughness,
                opacity: this.state.currentItemOpacity,
                text: "",
                fontSize: u,
                fontFamily: c,
                textAlign: s ? "center" : this.state.currentItemTextAlign,
                verticalAlign: s ? Yz.MIDDLE : FT,
                containerId: l ? i?.id : void 0,
                groupIds: i?.groupIds ?? [],
                lineHeight: p,
                angle: i ? (df(i) ? 0 : i.angle) : 0,
                frameId: f ? f.id : null,
              });
          if (
            (!d &&
              l &&
              i &&
              this.scene.mutateElement(i, {
                boundElements: (i.boundElements || []).concat({ type: "text", id: b.id }),
              }),
            this.setState({ editingTextElement: b }),
            !d)
          )
            if (i && l) {
              let x = this.scene.getElementIndex(i.id);
              this.scene.insertElementAtIndex(b, x + 1);
            } else this.scene.insertElement(b);
          a || d || i
            ? this.handleTextWysiwyg(b, { isExistingElement: !!d })
            : this.setState({ newElement: b, multiElement: null });
        }
      );
      I(this, "startImageCropping", (t) => {
        this.store.scheduleCapture(), this.setState({ croppingElementId: t.id });
      });
      I(this, "finishImageCropping", () => {
        this.state.croppingElementId &&
          (this.store.scheduleCapture(), this.setState({ croppingElementId: null }));
      });
      I(this, "handleCanvasDoubleClick", (t) => {
        if (this.state.multiElement || this.state.activeTool.type !== "selection") return;
        let r = this.scene.getSelectedElements(this.state),
          { x: n, y: i } = Oe(t, this.state);
        if (r.length === 1 && $t(r[0])) {
          let l = r[0];
          if (
            ((t[Y.CTRL_OR_CMD] && hG(l)) || vf(l)) &&
            this.state.editingLinearElement?.elementId !== l.id
          ) {
            this.store.scheduleCapture(),
              this.setState({
                editingLinearElement: new ve(l, this.scene.getNonDeletedElementsMap()),
              });
            return;
          } else if (this.state.selectedLinearElement && We(r[0])) {
            let s = ve.getSegmentMidpointHitCoords(
                this.state.selectedLinearElement,
                { x: n, y: i },
                this.state,
                this.scene.getNonDeletedElementsMap()
              ),
              d = s
                ? ve.getSegmentMidPointIndex(
                    this.state.selectedLinearElement,
                    this.state,
                    s,
                    this.scene.getNonDeletedElementsMap()
                  )
                : -1;
            if (d && d > -1) {
              this.store.scheduleCapture(), ve.deleteFixedSegment(r[0], this.scene, d);
              let m = ve.getSegmentMidpointHitCoords(
                  { ...this.state.selectedLinearElement, segmentMidPointHoveredCoords: null },
                  { x: n, y: i },
                  this.state,
                  this.scene.getNonDeletedElementsMap()
                ),
                c = m
                  ? ve.getSegmentMidPointIndex(
                      this.state.selectedLinearElement,
                      this.state,
                      m,
                      this.scene.getNonDeletedElementsMap()
                    )
                  : null;
              this.setState({
                selectedLinearElement: {
                  ...this.state.selectedLinearElement,
                  pointerDownState: {
                    ...this.state.selectedLinearElement.pointerDownState,
                    segmentMidpoint: { index: c, value: s, added: !1 },
                  },
                  segmentMidPointHoveredCoords: m,
                },
              });
              return;
            }
          } else if (
            this.state.editingLinearElement &&
            this.state.editingLinearElement.elementId === l.id &&
            vf(l)
          )
            return;
        }
        if (r.length === 1 && un(r[0])) {
          this.startImageCropping(r[0]);
          return;
        }
        if ((Ht(this.interactiveCanvas), rG(this.state).length > 0)) {
          let l = this.getElementAtPosition(n, i),
            s = l && oG(l, this.state.selectedGroupIds);
          if (s) {
            this.store.scheduleCapture(),
              this.setState((d) => ({
                ...d,
                ...uo(
                  { editingGroupId: s, selectedElementIds: { [l.id]: !0 } },
                  this.scene.getNonDeletedElements(),
                  d,
                  this
                ),
              }));
            return;
          }
        }
        if ((Ht(this.interactiveCanvas), !t[Y.CTRL_OR_CMD] && !this.state.viewModeEnabled)) {
          let l = this.getElementAtPosition(n, i);
          if (gl(l)) {
            this.setState({ activeEmbeddable: { element: l, state: "active" } });
            return;
          }
          if (!this.state.editingLinearElement) {
            let s = this.getTextBindableContainerAtPosition(n, i);
            if (
              s &&
              (oI(s) ||
                !tH(s.backgroundColor) ||
                fl({
                  point: se(n, i),
                  element: s,
                  elementsMap: this.scene.getNonDeletedElementsMap(),
                  threshold: this.getElementHitThreshold(s),
                }))
            ) {
              let d = bf(s, this.state, this.scene.getNonDeletedElementsMap());
              (n = d.x), (i = d.y);
            }
            this.startTextEditing({
              sceneX: n,
              sceneY: i,
              insertAtParentCenter: !t.altKey,
              container: s,
            });
          }
        }
      });
      I(this, "getElementLinkAtPosition", (t, r) => {
        if (r && r.locked) return;
        let n = this.scene.getNonDeletedElements(),
          i = -1;
        for (let a = n.length - 1; a >= 0; a--) {
          let l = n[a];
          if (
            (r && l.id === r.id && (i = a),
            l.link &&
              a >= i &&
              Al(
                l,
                this.scene.getNonDeletedElementsMap(),
                this.state,
                se(t.x, t.y),
                this.device.editor.isMobile
              ))
          )
            return l;
        }
      });
      I(this, "redirectToLink", (t, r) => {
        let n = Oi(
          se(this.lastPointerDownEvent.clientX, this.lastPointerDownEvent.clientY),
          se(this.lastPointerUpEvent.clientX, this.lastPointerUpEvent.clientY)
        );
        if (!this.hitLinkElement || n > OT) return;
        let i = Oe(this.lastPointerDownEvent, this.state),
          a = this.scene.getNonDeletedElementsMap(),
          l = Al(this.hitLinkElement, a, this.state, se(i.x, i.y), this.device.editor.isMobile),
          s = Oe(this.lastPointerUpEvent, this.state),
          d = Al(this.hitLinkElement, a, this.state, se(s.x, s.y), this.device.editor.isMobile);
        if (l && d) {
          xu();
          let m = this.hitLinkElement.link;
          if (m) {
            m = tf(m);
            let c;
            if (
              (this.props.onLinkOpen &&
                ((c = Qz(ee.EXCALIDRAW_LINK, t.nativeEvent)),
                this.props.onLinkOpen({ ...this.hitLinkElement, link: m }, c)),
              !c?.defaultPrevented)
            ) {
              let p = $z(m) ? "_self" : "_blank",
                u = window.open(void 0, p);
              u && ((u.opener = null), (u.location = m));
            }
          }
        }
      });
      I(this, "getTopLayerFrameAtSceneCoords", (t) => {
        let r = this.scene.getNonDeletedElementsMap(),
          n = this.scene.getNonDeletedFramesLikes().filter((i) => pI(t, i, r));
        return n.length ? n[n.length - 1] : null;
      });
      I(this, "handleCanvasPointerMove", (t) => {
        this.savePointer(t.clientX, t.clientY, this.state.cursorButton),
          (this.lastPointerMoveEvent = t.nativeEvent),
          ue.pointers.has(t.pointerId) &&
            ue.pointers.set(t.pointerId, { x: t.clientX, y: t.clientY });
        let r = ue.initialScale;
        if (ue.pointers.size === 2 && ue.lastCenter && r && ue.initialDistance) {
          let f = Lh(ue.pointers),
            b = f.x - ue.lastCenter.x,
            x = f.y - ue.lastCenter.y;
          ue.lastCenter = f;
          let w = Ph(Array.from(ue.pointers.values())),
            E =
              this.state.activeTool.type === "freedraw" && this.state.penMode
                ? 1
                : w / ue.initialDistance,
            y = E ? go(r * E) : this.state.zoom.value;
          this.setState((v) => {
            let C = _o({ viewportX: f.x, viewportY: f.y, nextZoom: y }, v);
            this.translateCanvas({
              zoom: C.zoom,
              scrollX: C.scrollX + 2 * (b / y),
              scrollY: C.scrollY + 2 * (x / y),
              shouldCacheIgnoreZoom: !0,
            });
          }),
            this.resetShouldCacheIgnoreZoomDebounced();
        } else ue.lastCenter = ue.initialDistance = ue.initialScale = null;
        if (hn || yl || If || qt(this.state)) return;
        let i = Oh(
          wl,
          t.clientX - this.state.offsetLeft,
          t.clientY - this.state.offsetTop
        ).isOverEither;
        !this.state.newElement &&
          !this.state.selectionElement &&
          !this.state.selectedElementsAreBeingDragged &&
          !this.state.multiElement &&
          (i ? Ht(this.interactiveCanvas) : Pt(this.interactiveCanvas, this.state));
        let a = Oe(t, this.state),
          { x: l, y: s } = a;
        if (!this.state.newElement && Dw(this.state.activeTool.type)) {
          let { originOffset: f, snapLines: b } = Aw(
            this.scene.getNonDeletedElements(),
            this,
            { x: l, y: s },
            t,
            this.scene.getNonDeletedElementsMap()
          );
          this.setState((x) => {
            let w = ul(x.snapLines, b),
              E = x.originSnapOffset ? ul(x.originSnapOffset, f) : f;
            return x.snapLines === w && x.originSnapOffset === E
              ? null
              : { snapLines: w, originSnapOffset: E };
          });
        } else
          !this.state.newElement &&
            !this.state.selectedElementsAreBeingDragged &&
            !this.state.selectionElement &&
            this.setState((f) => (f.snapLines.length ? { snapLines: [] } : null));
        if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
          let f = ve.handlePointerMove(t, l, s, this);
          f &&
            f !== this.state.editingLinearElement &&
            Ko(() => {
              this.setState({ editingLinearElement: f });
            }),
            f?.lastUncommittedPoint != null
              ? this.maybeSuggestBindingAtCursor(a, f.elbowed)
              : Ko(() => {
                  this.setState({ suggestedBindings: [] });
                });
        }
        if (yH(this.state.activeTool.type)) {
          let { newElement: f } = this.state;
          mf(f, !1)
            ? this.setState({
                suggestedBindings: ZT(
                  f,
                  [a],
                  this.scene,
                  this.state.zoom,
                  this.state.startBoundElement
                ),
              })
            : this.maybeSuggestBindingAtCursor(a, !1);
        }
        if (this.state.multiElement) {
          let { multiElement: f } = this.state,
            { x: b, y: x } = f,
            { points: w, lastCommittedPoint: E } = f,
            y = w[w.length - 1];
          if ((Pt(this.interactiveCanvas, this.state), y === E))
            Oi(se(l - b, s - x), y) >= ef
              ? this.scene.mutateElement(
                  f,
                  { points: [...w, se(l - b, s - x)] },
                  { informMutation: !1, isDragging: !1 }
                )
              : xe(this.interactiveCanvas, De.POINTER);
          else if (w.length > 2 && E && Oi(se(l - b, s - x), E) < ef)
            xe(this.interactiveCanvas, De.POINTER),
              this.scene.mutateElement(
                f,
                { points: w.slice(0, -1) },
                { informMutation: !1, isDragging: !1 }
              );
          else {
            let [v, C] = nt(l, s, t[Y.CTRL_OR_CMD] || We(f) ? null : this.getEffectiveGridSize()),
              [S, M] = f?.lastCommittedPoint ?? [0, 0],
              k = v - b - S,
              A = C - x - M;
            Qg(t) && ({ width: k, height: A } = nI(S + b, M + x, v, C)),
              lI(w, this.state.zoom.value) && xe(this.interactiveCanvas, De.POINTER),
              this.scene.mutateElement(
                f,
                { points: [...w.slice(0, -1), se(S + k, M + A)] },
                { isDragging: !0, informMutation: !1 }
              ),
              this.triggerRender(!1);
          }
          return;
        }
        if (
          !!t.buttons ||
          (this.state.activeTool.type !== "selection" &&
            this.state.activeTool.type !== "text" &&
            this.state.activeTool.type !== "eraser")
        )
          return;
        let m = this.scene.getNonDeletedElements(),
          c = this.scene.getSelectedElements(this.state);
        if (c.length === 1 && !i && !this.state.editingLinearElement) {
          if (
            (this.state.selectedLinearElement &&
              this.handleHoverSelectedLinearElement(this.state.selectedLinearElement, l, s),
            (!this.state.selectedLinearElement ||
              this.state.selectedLinearElement.hoverPointIndex === -1) &&
              this.state.openDialog?.name !== "elementLinkSelector" &&
              !(c.length === 1 && We(c[0])))
          ) {
            let f = yI(
              m,
              this.state,
              l,
              s,
              this.state.zoom,
              t.pointerType,
              this.scene.getNonDeletedElementsMap(),
              this.device
            );
            if (f && f.transformHandleType) {
              xe(this.interactiveCanvas, EI(f));
              return;
            }
          }
        } else if (c.length > 1 && !i && this.state.openDialog?.name !== "elementLinkSelector") {
          let f = wI(Gi(c), l, s, this.state.zoom, t.pointerType, this.device);
          if (f) {
            xe(this.interactiveCanvas, EI({ transformHandleType: f }));
            return;
          }
        }
        let p = this.getElementAtPosition(l, s, { preferSelected: !0, includeLockedElements: !0 }),
          u = null;
        p && p.locked ? (u = null) : (u = p),
          (this.hitLinkElement = this.getElementLinkAtPosition(a, p)),
          !bt(this.state) &&
            (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]
              ? (xe(this.interactiveCanvas, De.POINTER),
                UE(this.hitLinkElement, this.state, this.scene.getNonDeletedElementsMap()))
              : (xu(),
                u &&
                (u.link || Nr(u)) &&
                this.state.selectedElementIds[u.id] &&
                !this.state.contextMenu &&
                !this.state.showHyperlinkPopup
                  ? this.setState({ showHyperlinkPopup: "info" })
                  : this.state.activeTool.type === "text"
                  ? xe(this.interactiveCanvas, po(u) ? De.TEXT : De.CROSSHAIR)
                  : this.state.viewModeEnabled
                  ? xe(this.interactiveCanvas, De.GRAB)
                  : this.state.openDialog?.name === "elementLinkSelector"
                  ? xe(this.interactiveCanvas, De.AUTO)
                  : i
                  ? xe(this.interactiveCanvas, De.AUTO)
                  : this.state.selectedLinearElement &&
                    u?.id === this.state.selectedLinearElement.elementId
                  ? this.handleHoverSelectedLinearElement(this.state.selectedLinearElement, l, s)
                  : t[Y.CTRL_OR_CMD]
                  ? xe(this.interactiveCanvas, De.AUTO)
                  : (u || this.isHittingCommonBoundingBoxOfSelectedElements(a, c)) &&
                    !u?.locked &&
                    (u && gl(u) && this.isIframeLikeElementCenter(u, t, l, s)
                      ? (xe(this.interactiveCanvas, De.POINTER),
                        this.setState({ activeEmbeddable: { element: u, state: "hover" } }))
                      : (!u || !We(u) || !(u.startBinding || u.endBinding)) &&
                        (xe(this.interactiveCanvas, De.MOVE),
                        this.state.activeEmbeddable?.state === "hover" &&
                          this.setState({ activeEmbeddable: null })))),
            this.state.openDialog?.name === "elementLinkSelector" && u
              ? this.setState((f) => ({
                  hoveredElementIds: ul(
                    f.hoveredElementIds,
                    uo(
                      { editingGroupId: f.editingGroupId, selectedElementIds: { [u.id]: !0 } },
                      this.scene.getNonDeletedElements(),
                      f,
                      this
                    ).selectedElementIds
                  ),
                }))
              : this.state.openDialog?.name === "elementLinkSelector" &&
                !u &&
                this.setState((f) => ({ hoveredElementIds: ul(f.hoveredElementIds, {}) })));
      });
      I(this, "handleEraser", (t, r) => {
        let n = this.eraserTrail.addPointToPath(r.x, r.y, t.altKey);
        (this.elementsPendingErasure = new Set(n)), this.triggerRender();
      });
      I(this, "handleTouchMove", (t) => {
        vl = !0;
      });
      I(this, "handleCanvasPointerDown", (t) => {
        let r = t.target;
        if (
          (r.setPointerCapture && r.setPointerCapture(t.pointerId),
          this.maybeCleanupAfterMissingPointerUp(t.nativeEvent),
          this.maybeUnfollowRemoteUser(),
          this.state.searchMatches &&
            (this.setState((c) => ({
              searchMatches: c.searchMatches && {
                focusedId: null,
                matches: c.searchMatches.matches.map((p) => ({ ...p, focus: !1 })),
              },
            })),
            this.updateEditorAtom(xg, null)),
          He.get(io) && this.updateEditorAtom(io, null),
          this.state.contextMenu && this.setState({ contextMenu: null }),
          this.state.snapLines && this.setAppState({ snapLines: [] }),
          this.updateGestureOnPointerDown(t),
          t.pointerType === "touch" &&
            this.state.newElement &&
            this.state.newElement.type === "freedraw")
        ) {
          let c = this.state.newElement;
          this.updateScene({
            ...(c.points.length < 10
              ? { elements: this.scene.getElementsIncludingDeleted().filter((p) => p.id !== c.id) }
              : {}),
            appState: {
              newElement: null,
              editingTextElement: null,
              startBoundElement: null,
              suggestedBindings: [],
              selectedElementIds: ye(
                Object.keys(this.state.selectedElementIds)
                  .filter((p) => p !== c.id)
                  .reduce((p, u) => ((p[u] = this.state.selectedElementIds[u]), p), {}),
                this.state
              ),
            },
            captureUpdate:
              this.state.openDialog?.name === "elementLinkSelector" ? dt.EVENTUALLY : dt.NEVER,
          });
          return;
        }
        let n = document.getSelection();
        if (
          (n?.anchorNode && n.removeAllRanges(),
          this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(t),
          !this.state.penDetected &&
            t.pointerType === "pen" &&
            this.setState((c) => ({ penMode: !0, penDetected: !0 })),
          !this.device.isTouchScreen &&
            ["pen", "touch"].includes(t.pointerType) &&
            (this.device = nf(this.device, { isTouchScreen: !0 })),
          yl || ((this.lastPointerDownEvent = t), this.handleCanvasPanUsingWheelOrSpaceDrag(t)))
        )
          return;
        if (
          (this.setState({ lastPointerDownWith: t.pointerType, cursorButton: "down" }),
          this.savePointer(t.clientX, t.clientY, "down"),
          t.button === dn.ERASER && this.state.activeTool.type !== ko.eraser)
        ) {
          this.setState(
            {
              activeTool: Zo(this.state, {
                type: ko.eraser,
                lastActiveToolBeforeEraser: this.state.activeTool,
              }),
            },
            () => {
              this.handleCanvasPointerDown(t);
              let c = () => {
                  p(),
                    u?.(),
                    bt(this.state) &&
                      this.setState({
                        activeTool: Zo(this.state, {
                          ...(this.state.activeTool.lastActiveTool || { type: ko.selection }),
                          lastActiveToolBeforeEraser: null,
                        }),
                      });
                },
                p = _e(window, ee.POINTER_UP, c, { once: !0 }),
                u;
              requestAnimationFrame(() => {
                u = this.missingPointerEventCleanupEmitter.once(c);
              });
            }
          );
          return;
        }
        if (
          (t.button !== dn.MAIN && t.button !== dn.TOUCH && t.button !== dn.ERASER) ||
          ue.pointers.size > 1
        )
          return;
        let i = this.initialPointerDownState(t);
        if (
          (this.setState({ selectedElementsAreBeingDragged: !1 }),
          this.handleDraggingScrollBar(t, i) ||
            (this.clearSelectionIfNotUsingSelection(),
            this.updateBindingEnabledOnPointerMove(t),
            this.handleSelectionOnPointerDown(t, i)) ||
            !(
              !this.state.penMode ||
              t.pointerType !== "touch" ||
              this.state.activeTool.type === "selection" ||
              this.state.activeTool.type === "lasso" ||
              this.state.activeTool.type === "text" ||
              this.state.activeTool.type === "image"
            ))
        )
          return;
        this.state.activeTool.type === "lasso"
          ? this.lassoTrail.startPath(i.origin.x, i.origin.y, t.shiftKey)
          : this.state.activeTool.type === "text"
          ? this.handleTextOnPointerDown(t, i)
          : this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line"
          ? this.handleLinearElementOnPointerDown(t, this.state.activeTool.type, i)
          : this.state.activeTool.type === "freedraw"
          ? this.handleFreeDrawElementOnPointerDown(t, this.state.activeTool.type, i)
          : this.state.activeTool.type === "custom"
          ? Pt(this.interactiveCanvas, this.state)
          : this.state.activeTool.type === ko.frame || this.state.activeTool.type === ko.magicframe
          ? this.createFrameElementOnPointerDown(i, this.state.activeTool.type)
          : this.state.activeTool.type === "laser"
          ? this.laserTrails.startPath(i.lastCoords.x, i.lastCoords.y)
          : this.state.activeTool.type !== "eraser" &&
            this.state.activeTool.type !== "hand" &&
            this.state.activeTool.type !== "image" &&
            this.createGenericElementOnPointerDown(this.state.activeTool.type, i),
          this.props?.onPointerDown?.(this.state.activeTool, i),
          this.onPointerDownEmitter.trigger(this.state.activeTool, i, t),
          this.state.activeTool.type === "eraser" &&
            this.eraserTrail.startPath(i.lastCoords.x, i.lastCoords.y);
        let l = this.onPointerMoveFromPointerDownHandler(i),
          s = this.onPointerUpFromPointerDownHandler(i),
          d = this.onKeyDownFromPointerDownHandler(i),
          m = this.onKeyUpFromPointerDownHandler(i);
        this.missingPointerEventCleanupEmitter.once((c) => s(c || t.nativeEvent)),
          (!this.state.viewModeEnabled || this.state.activeTool.type === "laser") &&
            (window.addEventListener(ee.POINTER_MOVE, l),
            window.addEventListener(ee.POINTER_UP, s),
            window.addEventListener(ee.KEYDOWN, d),
            window.addEventListener(ee.KEYUP, m),
            (i.eventListeners.onMove = l),
            (i.eventListeners.onUp = s),
            (i.eventListeners.onKeyUp = m),
            (i.eventListeners.onKeyDown = d));
      });
      I(this, "handleCanvasPointerUp", (t) => {
        this.removePointer(t), (this.lastPointerUpEvent = t);
        let r = Oe({ clientX: t.clientX, clientY: t.clientY }, this.state),
          n = t.timeStamp - (this.lastPointerDownEvent?.timeStamp ?? 0);
        if (this.device.editor.isMobile && n < 300) {
          let i = this.getElementAtPosition(r.x, r.y);
          if (gl(i) && this.isIframeLikeElementCenter(i, t, r.x, r.y)) {
            this.handleEmbeddableCenterClick(i);
            return;
          }
        }
        if (this.device.isTouchScreen) {
          let i = this.getElementAtPosition(r.x, r.y, { includeLockedElements: !0 });
          this.hitLinkElement = this.getElementLinkAtPosition(r, i);
        }
        this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]
          ? n < 300 &&
            gl(this.hitLinkElement) &&
            !e1(
              this.hitLinkElement,
              this.scene.getNonDeletedElementsMap(),
              this.state,
              se(r.x, r.y)
            )
            ? this.handleEmbeddableCenterClick(this.hitLinkElement)
            : this.redirectToLink(t, this.device.isTouchScreen)
          : this.state.viewModeEnabled &&
            this.setState({ activeEmbeddable: null, selectedElementIds: {} });
      });
      I(this, "maybeOpenContextMenuAfterPointerDownOnTouchDevices", (t) => {
        t.pointerType === "touch" &&
          ((vl = !1),
          Br
            ? (vl = !0)
            : (Br = window.setTimeout(() => {
                (Br = 0), vl || this.handleCanvasContextMenu(t);
              }, Uz)));
      });
      I(this, "resetContextMenuTimer", () => {
        clearTimeout(Br), (Br = 0), (vl = !1);
      });
      I(this, "maybeCleanupAfterMissingPointerUp", (t) => {
        Tl?.(), this.missingPointerEventCleanupEmitter.trigger(t).clear();
      });
      I(this, "handleCanvasPanUsingWheelOrSpaceDrag", (t) => {
        if (
          !(
            ue.pointers.size <= 1 &&
            (t.button === dn.WHEEL ||
              (t.button === dn.MAIN && hn) ||
              qt(this.state) ||
              this.state.viewModeEnabled)
          )
        )
          return !1;
        (yl = !0), this.focusContainer(), this.state.editingTextElement || t.preventDefault();
        let r = !1,
          n = typeof window === void 0 ? !1 : /Linux/.test(window.navigator.platform);
        xe(this.interactiveCanvas, De.GRABBING);
        let { clientX: i, clientY: a } = t,
          l = od((d) => {
            let m = i - d.clientX,
              c = a - d.clientY;
            if (
              ((i = d.clientX), (a = d.clientY), n && !r && (Math.abs(m) > 1 || Math.abs(c) > 1))
            ) {
              r = !0;
              let p = (f) => {
                  document.body.removeEventListener(ee.PASTE, p), f.stopPropagation();
                },
                u = () => {
                  setTimeout(() => {
                    document.body.removeEventListener(ee.PASTE, p),
                      window.removeEventListener(ee.POINTER_UP, u);
                  }, 100);
                };
              document.body.addEventListener(ee.PASTE, p),
                window.addEventListener(ee.POINTER_UP, u);
            }
            this.translateCanvas({
              scrollX: this.state.scrollX - m / this.state.zoom.value,
              scrollY: this.state.scrollY - c / this.state.zoom.value,
            });
          }),
          s = Pe(
            (Tl = () => {
              (Tl = null),
                (yl = !1),
                hn ||
                  (this.state.viewModeEnabled
                    ? xe(this.interactiveCanvas, De.GRAB)
                    : Pt(this.interactiveCanvas, this.state)),
                this.setState({ cursorButton: "up" }),
                this.savePointer(t.clientX, t.clientY, "up"),
                window.removeEventListener(ee.POINTER_MOVE, l),
                window.removeEventListener(ee.POINTER_UP, s),
                window.removeEventListener(ee.BLUR, s),
                l.flush();
            })
          );
        return (
          window.addEventListener(ee.BLUR, s),
          window.addEventListener(ee.POINTER_MOVE, l, { passive: !0 }),
          window.addEventListener(ee.POINTER_UP, s),
          !0
        );
      });
      I(this, "clearSelectionIfNotUsingSelection", () => {
        this.state.activeTool.type !== "selection" &&
          this.state.activeTool.type !== "lasso" &&
          this.setState({
            selectedElementIds: ye({}, this.state),
            selectedGroupIds: {},
            editingGroupId: null,
            activeEmbeddable: null,
          });
      });
      I(this, "handleSelectionOnPointerDown", (t, r) => {
        if (this.state.activeTool.type === "selection") {
          let n = this.scene.getNonDeletedElements(),
            i = this.scene.getNonDeletedElementsMap(),
            a = this.scene.getSelectedElements(this.state);
          if (
            a.length === 1 &&
            !this.state.editingLinearElement &&
            !We(a[0]) &&
            !(
              this.state.selectedLinearElement &&
              this.state.selectedLinearElement.hoverPointIndex !== -1
            )
          ) {
            let l = yI(
              n,
              this.state,
              r.origin.x,
              r.origin.y,
              this.state.zoom,
              t.pointerType,
              this.scene.getNonDeletedElementsMap(),
              this.device
            );
            l != null &&
              (l.transformHandleType === "rotation"
                ? (this.setState({ resizingElement: l.element }),
                  (r.resize.handleType = l.transformHandleType))
                : (this.state.croppingElementId || this.setState({ resizingElement: l.element }),
                  (r.resize.handleType = l.transformHandleType)));
          } else
            a.length > 1 &&
              (r.resize.handleType = wI(
                Gi(a),
                r.origin.x,
                r.origin.y,
                this.state.zoom,
                t.pointerType,
                this.device
              ));
          if (r.resize.handleType)
            (r.resize.isResizing = !0),
              (r.resize.offset = rf(lG(r.resize.handleType, a, i, r.origin.x, r.origin.y))),
              a.length === 1 &&
                $t(a[0]) &&
                a[0].points.length === 2 &&
                (r.resize.arrowDirection = sG(r.resize.handleType, a[0]));
          else {
            if (this.state.selectedLinearElement) {
              let p = this.state.editingLinearElement || this.state.selectedLinearElement,
                u = ve.handlePointerDown(t, this, this.store, r.origin, p, this.scene);
              if (
                (u.hitElement && (r.hit.element = u.hitElement),
                u.linearElementEditor &&
                  (this.setState({ selectedLinearElement: u.linearElementEditor }),
                  this.state.editingLinearElement &&
                    this.setState({ editingLinearElement: u.linearElementEditor })),
                u.didAddPoint)
              )
                return !0;
            }
            let l = this.getElementsAtPosition(r.origin.x, r.origin.y, {
                includeLockedElements: !0,
              }),
              s = l.filter((p) => !p.locked),
              d = this.getElementAtPosition(r.origin.x, r.origin.y, { allHitElements: l });
            if (
              ((!d || d.id !== this.state.activeLockedId) &&
                this.setState({ activeLockedId: null }),
              d && d.locked && !s.some((p) => this.state.selectedElementIds[p.id])
                ? (r.hit.element = null)
                : (r.hit.element =
                    r.hit.element ?? this.getElementAtPosition(r.origin.x, r.origin.y)),
              (this.hitLinkElement = this.getElementLinkAtPosition(r.origin, d)),
              this.hitLinkElement)
            )
              return !0;
            if (
              (this.state.croppingElementId &&
                r.hit.element?.id !== this.state.croppingElementId &&
                this.finishImageCropping(),
              r.hit.element &&
                this.getElementLinkAtPosition({ x: r.origin.x, y: r.origin.y }, r.hit.element))
            )
              return !1;
            r.hit.allHitElements = s;
            let m = r.hit.element,
              c = r.hit.allHitElements.some((p) => this.isASelectedElement(p));
            if (
              ((m === null || !c) &&
                !t.shiftKey &&
                !r.hit.hasHitCommonBoundingBoxOfSelectedElements &&
                this.clearSelection(m),
              this.state.editingLinearElement)
            )
              this.setState({
                selectedElementIds: ye(
                  { [this.state.editingLinearElement.elementId]: !0 },
                  this.state
                ),
              });
            else if (m != null) {
              if (t[Y.CTRL_OR_CMD])
                return (
                  t.altKey ||
                    (this.state.selectedElementIds[m.id] || (r.hit.wasAddedToSelection = !0),
                    this.setState((p) => ({
                      ...tG(p, m),
                      previousSelectedElementIds: this.state.selectedElementIds,
                    }))),
                  !1
                );
              this.state.selectedElementIds[m.id] ||
                (this.state.editingGroupId &&
                  !bI(m, this.state.editingGroupId) &&
                  this.setState({
                    selectedElementIds: ye({}, this.state),
                    selectedGroupIds: {},
                    editingGroupId: null,
                    activeEmbeddable: null,
                  }),
                !c &&
                  !r.hit.hasHitCommonBoundingBoxOfSelectedElements &&
                  (this.setState((p) => {
                    let u = { ...p.selectedElementIds, [m.id]: !0 },
                      f = [];
                    if (
                      (Object.keys(p.selectedElementIds).forEach((b) => {
                        let x = this.scene.getElement(b);
                        x && f.push(x);
                      }),
                      Zt(m))
                    )
                      mI(f, m.id).forEach((b) => {
                        delete u[b.id];
                      });
                    else if (m.frameId) u[m.frameId] && delete u[m.id];
                    else {
                      let b = m.groupIds,
                        x = new Set(
                          b
                            .flatMap((w) => xl(this.scene.getNonDeletedElements(), w))
                            .filter((w) => Zt(w))
                            .map((w) => w.id)
                        );
                      x.size > 0 &&
                        f.forEach((w) => {
                          w.frameId &&
                            x.has(w.frameId) &&
                            (delete u[w.id],
                            w.groupIds
                              .flatMap((E) => xl(this.scene.getNonDeletedElements(), E))
                              .forEach((E) => {
                                delete u[E.id];
                              }));
                        });
                    }
                    return (
                      p.openDialog?.name === "elementLinkSelector" &&
                        (m.groupIds.some((b) => p.selectedGroupIds[b]) || (u = { [m.id]: !0 })),
                      {
                        ...uo(
                          { editingGroupId: p.editingGroupId, selectedElementIds: u },
                          this.scene.getNonDeletedElements(),
                          p,
                          this
                        ),
                        showHyperlinkPopup: m.link || Nr(m) ? "info" : !1,
                      }
                    );
                  }),
                  (r.hit.wasAddedToSelection = !0)));
            }
            this.setState({ previousSelectedElementIds: this.state.selectedElementIds });
          }
        }
        return !1;
      });
      I(this, "handleTextOnPointerDown", (t, r) => {
        if (this.state.editingTextElement) return;
        let n = r.origin.x,
          i = r.origin.y,
          a = this.getElementAtPosition(n, i, { includeBoundTextElement: !0 }),
          l = this.getTextBindableContainerAtPosition(n, i);
        oI(a) && ((l = a), (n = a.x + a.width / 2), (i = a.y + a.height / 2)),
          this.startTextEditing({
            sceneX: n,
            sceneY: i,
            insertAtParentCenter: !t.altKey,
            container: l,
            autoEdit: !1,
          }),
          Ht(this.interactiveCanvas),
          this.state.activeTool.locked ||
            this.setState({ activeTool: Zo(this.state, { type: "selection" }) });
      });
      I(this, "handleFreeDrawElementOnPointerDown", (t, r, n) => {
        let [i, a] = nt(n.origin.x, n.origin.y, null),
          l = this.getTopLayerFrameAtSceneCoords({ x: i, y: a }),
          s = t.pressure === 0.5,
          d = uH({
            type: r,
            x: i,
            y: a,
            strokeColor: this.state.currentItemStrokeColor,
            backgroundColor: this.state.currentItemBackgroundColor,
            fillStyle: this.state.currentItemFillStyle,
            strokeWidth: this.state.currentItemStrokeWidth,
            strokeStyle: this.state.currentItemStrokeStyle,
            roughness: this.state.currentItemRoughness,
            opacity: this.state.currentItemOpacity,
            roundness: null,
            simulatePressure: s,
            locked: !1,
            frameId: l ? l.id : null,
            points: [se(0, 0)],
            pressures: s ? [] : [t.pressure],
          });
        this.scene.insertElement(d),
          this.setState((c) => {
            let p = { ...c.selectedElementIds };
            return delete p[d.id], { selectedElementIds: ye(p, c) };
          });
        let m = af(
          n.origin,
          this.scene.getNonDeletedElements(),
          this.scene.getNonDeletedElementsMap(),
          this.state.zoom
        );
        this.setState({ newElement: d, startBoundElement: m, suggestedBindings: [] });
      });
      I(this, "insertIframeElement", ({ sceneX: t, sceneY: r, width: n, height: i }) => {
        let [a, l] = nt(
            t,
            r,
            this.lastPointerDownEvent?.[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
          ),
          s = hH({
            type: "iframe",
            x: a,
            y: l,
            strokeColor: "transparent",
            backgroundColor: "transparent",
            fillStyle: this.state.currentItemFillStyle,
            strokeWidth: this.state.currentItemStrokeWidth,
            strokeStyle: this.state.currentItemStrokeStyle,
            roughness: this.state.currentItemRoughness,
            roundness: this.getCurrentItemRoundness("iframe"),
            opacity: this.state.currentItemOpacity,
            locked: !1,
            width: n,
            height: i,
          });
        return this.scene.insertElement(s), s;
      });
      I(this, "insertEmbeddableElement", ({ sceneX: t, sceneY: r, link: n }) => {
        let [i, a] = nt(
            t,
            r,
            this.lastPointerDownEvent?.[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
          ),
          l = Jd(n);
        if (!l) return;
        l.error instanceof URIError &&
          this.setToast({ message: g("toast.unrecognizedLinkFormat"), closable: !0 });
        let s = qT({
          type: "embeddable",
          x: i,
          y: a,
          strokeColor: "transparent",
          backgroundColor: "transparent",
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roughness: this.state.currentItemRoughness,
          roundness: this.getCurrentItemRoundness("embeddable"),
          opacity: this.state.currentItemOpacity,
          locked: !1,
          width: l.intrinsicSize.w,
          height: l.intrinsicSize.h,
          link: n,
        });
        return this.scene.insertElement(s), s;
      });
      I(
        this,
        "createImageElement",
        async ({ sceneX: t, sceneY: r, addToFrameUnderCursor: n = !0, imageFile: i }) => {
          let [a, l] = nt(
              t,
              r,
              this.lastPointerDownEvent?.[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
            ),
            s = n ? this.getTopLayerFrameAtSceneCoords({ x: a, y: l }) : null,
            d = 100 / this.state.zoom.value,
            m = bH({
              type: "image",
              strokeColor: this.state.currentItemStrokeColor,
              backgroundColor: this.state.currentItemBackgroundColor,
              fillStyle: this.state.currentItemFillStyle,
              strokeWidth: this.state.currentItemStrokeWidth,
              strokeStyle: this.state.currentItemStrokeStyle,
              roughness: this.state.currentItemRoughness,
              roundness: null,
              opacity: this.state.currentItemOpacity,
              locked: !1,
              frameId: s ? s.id : null,
              x: a - d / 2,
              y: l - d / 2,
              width: d,
              height: d,
            });
          return await this.insertImageElement(m, i);
        }
      );
      I(this, "handleLinearElementOnPointerDown", (t, r, n) => {
        if (this.state.multiElement) {
          let { multiElement: i } = this.state;
          if (i.type === "line" && lI(i.points, this.state.zoom.value)) {
            this.scene.mutateElement(i, { lastCommittedPoint: i.points[i.points.length - 1] }),
              this.actionManager.executeAction(At);
            return;
          }
          if (We(i) && i.points.length > 1) {
            this.scene.mutateElement(i, { lastCommittedPoint: i.points[i.points.length - 1] }),
              this.actionManager.executeAction(At);
            return;
          }
          let { x: a, y: l, lastCommittedPoint: s } = i;
          if (i.points.length > 1 && s && Oi(se(n.origin.x - a, n.origin.y - l), s) < ef) {
            this.actionManager.executeAction(At);
            return;
          }
          this.setState((d) => ({
            selectedElementIds: ye({ ...d.selectedElementIds, [i.id]: !0 }, d),
          })),
            this.scene.mutateElement(i, { lastCommittedPoint: i.points[i.points.length - 1] }),
            xe(this.interactiveCanvas, De.POINTER);
        } else {
          let [i, a] = nt(
              n.origin.x,
              n.origin.y,
              t[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
            ),
            l = this.getTopLayerFrameAtSceneCoords({ x: i, y: a }),
            { currentItemStartArrowhead: s, currentItemEndArrowhead: d } = this.state,
            [m, c] = r === "arrow" ? [s, d] : [null, null],
            p =
              r === "arrow"
                ? gH({
                    type: r,
                    x: i,
                    y: a,
                    strokeColor: this.state.currentItemStrokeColor,
                    backgroundColor: this.state.currentItemBackgroundColor,
                    fillStyle: this.state.currentItemFillStyle,
                    strokeWidth: this.state.currentItemStrokeWidth,
                    strokeStyle: this.state.currentItemStrokeStyle,
                    roughness: this.state.currentItemRoughness,
                    opacity: this.state.currentItemOpacity,
                    roundness:
                      this.state.currentItemArrowType === Rr.round
                        ? { type: Zd.PROPORTIONAL_RADIUS }
                        : null,
                    startArrowhead: m,
                    endArrowhead: c,
                    locked: !1,
                    frameId: l ? l.id : null,
                    elbowed: this.state.currentItemArrowType === Rr.elbow,
                    fixedSegments: this.state.currentItemArrowType === Rr.elbow ? [] : null,
                  })
                : xH({
                    type: r,
                    x: i,
                    y: a,
                    strokeColor: this.state.currentItemStrokeColor,
                    backgroundColor: this.state.currentItemBackgroundColor,
                    fillStyle: this.state.currentItemFillStyle,
                    strokeWidth: this.state.currentItemStrokeWidth,
                    strokeStyle: this.state.currentItemStrokeStyle,
                    roughness: this.state.currentItemRoughness,
                    opacity: this.state.currentItemOpacity,
                    roundness:
                      this.state.currentItemRoundness === "round"
                        ? { type: Zd.PROPORTIONAL_RADIUS }
                        : null,
                    locked: !1,
                    frameId: l ? l.id : null,
                  });
          this.setState((f) => {
            let b = { ...f.selectedElementIds };
            return delete b[p.id], { selectedElementIds: ye(b, f) };
          }),
            this.scene.mutateElement(p, { points: [...p.points, se(0, 0)] });
          let u = af(
            n.origin,
            this.scene.getNonDeletedElements(),
            this.scene.getNonDeletedElementsMap(),
            this.state.zoom,
            We(p),
            We(p)
          );
          this.scene.insertElement(p),
            this.setState({ newElement: p, startBoundElement: u, suggestedBindings: [] });
        }
      });
      I(this, "createGenericElementOnPointerDown", (t, r) => {
        let [n, i] = nt(
            r.origin.x,
            r.origin.y,
            this.lastPointerDownEvent?.[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
          ),
          a = this.getTopLayerFrameAtSceneCoords({ x: n, y: i }),
          l = {
            x: n,
            y: i,
            strokeColor: this.state.currentItemStrokeColor,
            backgroundColor: this.state.currentItemBackgroundColor,
            fillStyle: this.state.currentItemFillStyle,
            strokeWidth: this.state.currentItemStrokeWidth,
            strokeStyle: this.state.currentItemStrokeStyle,
            roughness: this.state.currentItemRoughness,
            opacity: this.state.currentItemOpacity,
            roundness: this.getCurrentItemRoundness(t),
            locked: !1,
            frameId: a ? a.id : null,
          },
          s;
        t === "embeddable" ? (s = qT({ type: "embeddable", ...l })) : (s = fH({ type: t, ...l })),
          s.type === "selection"
            ? this.setState({ selectionElement: s })
            : (this.scene.insertElement(s), this.setState({ multiElement: null, newElement: s }));
      });
      I(this, "createFrameElementOnPointerDown", (t, r) => {
        let [n, i] = nt(
            t.origin.x,
            t.origin.y,
            this.lastPointerDownEvent?.[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
          ),
          a = { x: n, y: i, opacity: this.state.currentItemOpacity, locked: !1, ...Dr },
          l = r === ko.magicframe ? JT(a) : pH(a);
        this.scene.insertElement(l), this.setState({ multiElement: null, newElement: l });
      });
      I(this, "restoreReadyToEraseElements", () => {
        (this.elementsPendingErasure = new Set()), this.triggerRender();
      });
      I(this, "eraseElements", () => {
        let t = !1,
          r = this.scene
            .getElementsIncludingDeleted()
            .map((n) =>
              this.elementsPendingErasure.has(n.id) ||
              (n.frameId && this.elementsPendingErasure.has(n.frameId)) ||
              (pf(n) && this.elementsPendingErasure.has(n.containerId))
                ? ((t = !0), pn(n, { isDeleted: !0 }))
                : n
            );
        (this.elementsPendingErasure = new Set()),
          t && (this.store.scheduleCapture(), this.scene.replaceAllElements(r));
      });
      I(this, "initializeImage", async (t, r) => {
        if (!Bl(r)) throw new Error(g("errors.unsupportedFileType"));
        let n = r.type;
        if ((xe(this.interactiveCanvas, "wait"), n === _r.svg))
          try {
            r = Em(cI(await r.text()), r.name);
          } catch (s) {
            throw (console.warn(s), new Error(g("errors.svgImageInsertError")));
          }
        let i = await (this.props.generateIdForFile?.(r) || p1(r));
        if (!i)
          throw (
            (console.warn(
              "Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one."
            ),
            new Error(g("errors.imageInsertError")))
          );
        if (!this.files[i]?.dataURL) {
          try {
            r = await Ol(r, { maxWidthOrHeight: Lz });
          } catch (s) {
            console.error("Error trying to resizing image file on insertion", s);
          }
          if (r.size > HT)
            throw new Error(
              g("errors.fileTooBig", { maxSize: `${Math.trunc(HT / 1024 / 1024)}MB` })
            );
        }
        let l = this.files[i]?.dataURL || (await xm(r));
        return new Promise(async (s, d) => {
          try {
            let m = this.getLatestInitializedImageElement(t, i);
            if (
              (this.addMissingFiles([
                { mimeType: n, id: i, dataURL: l, created: Date.now(), lastRetrieved: Date.now() },
              ]),
              !this.imageCache.get(i))
            ) {
              this.addNewImagesToImageCache();
              let { erroredFiles: p } = await this.updateImageCache([m]);
              if (p.size) throw new Error("Image cache update resulted with an error.");
            }
            let c = await this.imageCache.get(i)?.image;
            if (c && this.state.newElement?.id !== m.id) {
              m = this.getLatestInitializedImageElement(t, i);
              let p = this.getImageNaturalDimensions(m, c);
              Object.assign(m, p);
            }
            s(m);
          } catch (m) {
            console.error(m), d(new Error(g("errors.imageInsertError")));
          }
        });
      });
      I(this, "getLatestInitializedImageElement", (t, r) => {
        let n = this.scene.getElement(t.id) ?? t;
        return pn(n, { fileId: r });
      });
      I(this, "insertImageElement", async (t, r) => {
        if (!this.isToolSupported("image")) {
          this.setState({ errorMessage: g("errors.imageToolNotSupported") });
          return;
        }
        this.scene.insertElement(t);
        try {
          let n = await this.initializeImage(t, r),
            i = this.scene.getElementsIncludingDeleted().map((a) => (a.id === n.id ? n : a));
          return (
            this.updateScene({
              captureUpdate: dt.IMMEDIATELY,
              elements: i,
              appState: { selectedElementIds: ye({ [n.id]: !0 }, this.state) },
            }),
            n
          );
        } catch (n) {
          return (
            this.store.scheduleAction(dt.NEVER),
            this.scene.mutateElement(t, { isDeleted: !0 }),
            this.actionManager.executeAction(At),
            this.setState({ errorMessage: n.message || g("errors.imageInsertError") }),
            null
          );
        }
      });
      I(this, "onImageAction", async () => {
        try {
          let t = this.state.width / 2 + this.state.offsetLeft,
            r = this.state.height / 2 + this.state.offsetTop,
            { x: n, y: i } = Oe({ clientX: t, clientY: r }, this.state),
            a = await Ll({ description: "Image", extensions: Object.keys(Az) });
          await this.createImageElement({
            sceneX: n,
            sceneY: i,
            addToFrameUnderCursor: !1,
            imageFile: a,
          }),
            this.setState({}, () => {
              this.actionManager.executeAction(At);
            });
        } catch (t) {
          t.name !== "AbortError" ? console.error(t) : console.warn(t),
            this.setState(
              { newElement: null, activeTool: Zo(this.state, { type: "selection" }) },
              () => {
                this.actionManager.executeAction(At);
              }
            );
        }
      });
      I(this, "getImageNaturalDimensions", (t, r) => {
        let n = Math.max(this.state.height - 120, 160),
          i = Math.min(n, Math.floor(this.state.height * 0.5) / this.state.zoom.value),
          a = Math.min(r.naturalHeight, i),
          l = a * (r.naturalWidth / r.naturalHeight),
          s = t.x + t.width / 2 - l / 2,
          d = t.y + t.height / 2 - a / 2;
        return { x: s, y: d, width: l, height: a, crop: null };
      });
      I(this, "updateImageCache", async (t, r = this.files) => {
        let { updatedFiles: n, erroredFiles: i } = await LH({
          imageCache: this.imageCache,
          fileIds: t.map((a) => a.fileId),
          files: r,
        });
        return (
          i.size &&
            (this.store.scheduleAction(dt.NEVER),
            this.scene.replaceAllElements(
              t.map((a) => (hl(a) && i.has(a.fileId) ? pn(a, { status: "error" }) : a))
            )),
          { updatedFiles: n, erroredFiles: i }
        );
      });
      I(
        this,
        "addNewImagesToImageCache",
        async (t = MH(this.scene.getNonDeletedElements()), r = this.files) => {
          let n = t.filter((i) => !i.isDeleted && !this.imageCache.has(i.fileId));
          if (n.length) {
            let { updatedFiles: i } = await this.updateImageCache(n, r);
            if (i.size) for (let a of n) i.has(a.fileId) && bl.delete(a);
            i.size && this.scene.triggerUpdate();
          }
        }
      );
      I(
        this,
        "scheduleImageRefresh",
        Tz(() => {
          this.addNewImagesToImageCache();
        }, Dz)
      );
      I(this, "updateBindingEnabledOnPointerMove", (t) => {
        let r = mH(t);
        this.state.isBindingEnabled !== r && this.setState({ isBindingEnabled: r });
      });
      I(this, "maybeSuggestBindingAtCursor", (t, r) => {
        let n = af(
          t,
          this.scene.getNonDeletedElements(),
          this.scene.getNonDeletedElementsMap(),
          this.state.zoom,
          !1,
          r
        );
        this.setState({ suggestedBindings: n != null ? [n] : [] });
      });
      I(this, "handleInteractiveCanvasRef", (t) => {
        t !== null
          ? ((this.interactiveCanvas = t),
            this.interactiveCanvas.addEventListener(ee.TOUCH_START, this.onTouchStart, {
              passive: !1,
            }),
            this.interactiveCanvas.addEventListener(ee.TOUCH_END, this.onTouchEnd))
          : (this.interactiveCanvas?.removeEventListener(ee.TOUCH_START, this.onTouchStart),
            this.interactiveCanvas?.removeEventListener(ee.TOUCH_END, this.onTouchEnd));
      });
      I(this, "handleAppOnDrop", async (t) => {
        let { file: r, fileHandle: n } = await f1(t),
          { x: i, y: a } = Oe(t, this.state);
        try {
          if (Bl(r) && this.isToolSupported("image")) {
            if (r?.type === _r.png || r?.type === _r.svg)
              try {
                let s = await Fl(r, this.state, this.scene.getElementsIncludingDeleted(), n);
                this.syncActionResult({
                  ...s,
                  appState: { ...(s.appState || this.state), isLoading: !1 },
                  replaceFiles: !0,
                  captureUpdate: dt.IMMEDIATELY,
                });
                return;
              } catch (s) {
                if (s.name !== "EncodingError")
                  throw new Error(g("alerts.couldNotLoadInvalidFile"));
              }
            this.createImageElement({ sceneX: i, sceneY: a, imageFile: r });
            return;
          }
        } catch (s) {
          return this.setState({ isLoading: !1, errorMessage: s.message });
        }
        let l = t.dataTransfer.getData(_r.excalidrawlib);
        if (l && typeof l == "string") {
          try {
            let s = m1(l);
            this.addElementsFromPasteOrLibrary({ elements: Ec(s), position: t, files: null });
          } catch (s) {
            this.setState({ errorMessage: s.message });
          }
          return;
        }
        if (
          (r && (await this.loadFileToCanvas(r, n)), t.dataTransfer?.types?.includes("text/plain"))
        ) {
          let s = t.dataTransfer?.getData("text");
          if (
            s &&
            gf(s, this.props.validateEmbeddable) &&
            (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(s) || Jd(s)?.type === "video")
          ) {
            let d = this.insertEmbeddableElement({ sceneX: i, sceneY: a, link: tf(s) });
            d &&
              (this.store.scheduleCapture(), this.setState({ selectedElementIds: { [d.id]: !0 } }));
          }
        }
      });
      I(this, "loadFileToCanvas", async (t, r) => {
        t = await x1(t);
        try {
          let n = this.scene.getElementsIncludingDeleted(),
            i;
          try {
            i = await fm(t, this.state, n, r);
          } catch (a) {
            let l = a instanceof qf;
            if (l && a.code === "IMAGE_NOT_CONTAINS_SCENE_DATA" && !this.isToolSupported("image")) {
              this.setState({ isLoading: !1, errorMessage: g("errors.imageToolNotSupported") });
              return;
            }
            let s = l ? g("alerts.cannotRestoreFromImage") : g("alerts.couldNotLoadInvalidFile");
            this.setState({ isLoading: !1, errorMessage: s });
          }
          if (!i) return;
          i.type === _r.excalidraw
            ? (MI(n.concat(i.data.elements)),
              this.store.scheduleMicroAction({ action: dt.NEVER, elements: n, appState: void 0 }),
              this.setState({ isLoading: !0 }),
              this.syncActionResult({
                ...i.data,
                appState: { ...(i.data.appState || this.state), isLoading: !1 },
                replaceFiles: !0,
                captureUpdate: dt.IMMEDIATELY,
              }))
            : i.type === _r.excalidrawlib &&
              (await this.library
                .updateLibrary({ libraryItems: t, merge: !0, openLibraryMenu: !0 })
                .catch((a) => {
                  console.error(a), this.setState({ errorMessage: g("errors.importLibraryError") });
                }));
        } catch (n) {
          this.setState({ isLoading: !1, errorMessage: n.message });
        }
      });
      I(this, "handleCanvasContextMenu", (t) => {
        if (
          (t.preventDefault(),
          (("pointerType" in t.nativeEvent && t.nativeEvent.pointerType === "touch") ||
            ("pointerType" in t.nativeEvent &&
              t.nativeEvent.pointerType === "pen" &&
              t.button !== dn.SECONDARY)) &&
            this.state.activeTool.type !== "selection")
        )
          return;
        let { x: r, y: n } = Oe(t, this.state),
          i = this.getElementAtPosition(r, n, { preferSelected: !0, includeLockedElements: !0 }),
          a = this.scene.getSelectedElements(this.state),
          l = this.isHittingCommonBoundingBoxOfSelectedElements({ x: r, y: n }, a),
          s = i || l ? "element" : "canvas",
          d = this.excalidrawContainerRef.current,
          { top: m, left: c } = d.getBoundingClientRect(),
          p = t.clientX - c,
          u = t.clientY - m;
        re("contextMenu", "openContextMenu", s),
          this.setState(
            {
              ...(i && !this.state.selectedElementIds[i.id]
                ? {
                    ...this.state,
                    ...uo(
                      {
                        editingGroupId: this.state.editingGroupId,
                        selectedElementIds: { [i.id]: !0 },
                      },
                      this.scene.getNonDeletedElements(),
                      this.state,
                      this
                    ),
                    selectedLinearElement: $t(i)
                      ? new ve(i, this.scene.getNonDeletedElementsMap())
                      : null,
                  }
                : this.state),
              showHyperlinkPopup: !1,
            },
            () => {
              this.setState({
                contextMenu: { top: u, left: p, items: this.getContextMenuItems(s) },
              });
            }
          );
      });
      I(this, "maybeDragNewGenericElement", (t, r, n = !0) => {
        let i = this.state.selectionElement,
          a = t.lastCoords;
        if (i && this.state.activeTool.type !== "eraser") {
          vI({
            newElement: i,
            elementType: this.state.activeTool.type,
            originX: t.origin.x,
            originY: t.origin.y,
            x: a.x,
            y: a.y,
            width: Hi(t.origin.x, a.x),
            height: Hi(t.origin.y, a.y),
            shouldMaintainAspectRatio: ml(r),
            shouldResizeFromCenter: !1,
            scene: this.scene,
            zoom: this.state.zoom.value,
            informMutation: !1,
          });
          return;
        }
        let l = this.state.newElement;
        if (!l) return;
        let [s, d] = nt(a.x, a.y, r[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()),
          m = hl(l) && this.imageCache.get(l.fileId)?.image,
          c = m && !(m instanceof Promise) ? m.width / m.height : null;
        this.maybeCacheReferenceSnapPoints(r, [l]);
        let { snapOffset: p, snapLines: u } = Pw(
          l,
          this,
          r,
          {
            x: t.originInGrid.x + (this.state.originSnapOffset?.x ?? 0),
            y: t.originInGrid.y + (this.state.originSnapOffset?.y ?? 0),
          },
          { x: s - t.originInGrid.x, y: d - t.originInGrid.y },
          this.scene.getNonDeletedElementsMap()
        );
        (s += p.x),
          (d += p.y),
          this.setState({ snapLines: u }),
          vI({
            newElement: l,
            elementType: this.state.activeTool.type,
            originX: t.originInGrid.x,
            originY: t.originInGrid.y,
            x: s,
            y: d,
            width: Hi(t.originInGrid.x, s),
            height: Hi(t.originInGrid.y, d),
            shouldMaintainAspectRatio: un(l) ? !ml(r) : ml(r),
            shouldResizeFromCenter: BT(r),
            zoom: this.state.zoom.value,
            scene: this.scene,
            widthAspectRatio: c,
            originOffset: this.state.originSnapOffset,
            informMutation: n,
          }),
          this.setState({ newElement: l }),
          (this.state.activeTool.type === ko.frame ||
            this.state.activeTool.type === ko.magicframe) &&
            this.setState({
              elementsToHighlight: Ef(
                this.scene.getNonDeletedElements(),
                l,
                this.state,
                this.scene.getNonDeletedElementsMap()
              ),
            });
      });
      I(this, "maybeHandleCrop", (t, r) => {
        if (!this.state.croppingElementId) return !1;
        let n = t.resize.handleType,
          i = t.lastCoords,
          [a, l] = nt(
            i.x - t.resize.offset.x,
            i.y - t.resize.offset.y,
            r[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
          ),
          s = this.scene.getNonDeletedElementsMap().get(this.state.croppingElementId);
        if (n && s && un(s)) {
          let d = t.originalElements.get(s.id),
            m = hl(s) && this.imageCache.get(s.fileId)?.image;
          if (d && un(d) && m && !(m instanceof Promise)) {
            let [c, p] = nt(i.x, i.y, r[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()),
              u = { x: c - t.originInGrid.x, y: p - t.originInGrid.y };
            this.maybeCacheReferenceSnapPoints(r, [s]);
            let { snapOffset: f, snapLines: b } = Rh([s], [d], this, r, u, n);
            this.scene.mutateElement(
              s,
              VH(
                s,
                this.scene.getNonDeletedElementsMap(),
                n,
                m.naturalWidth,
                m.naturalHeight,
                a + f.x,
                l + f.y,
                r.shiftKey ? d.width / d.height : void 0
              )
            ),
              sf(s, this.scene, { newSize: { width: s.width, height: s.height } }),
              this.setState({ isCropping: n && n !== "rotation", snapLines: b });
          }
          return !0;
        }
        return !1;
      });
      I(this, "maybeHandleResize", (t, r) => {
        let n = this.scene.getSelectedElements(this.state),
          i = n.filter((c) => Zt(c)),
          a = t.resize.handleType;
        if (
          (i.length > 0 && a === "rotation") ||
          (n.length === 1 && We(n[0])) ||
          this.state.croppingElementId
        )
          return !1;
        this.setState({
          isResizing: a && a !== "rotation",
          isRotating: a === "rotation",
          activeEmbeddable: null,
        });
        let l = t.lastCoords,
          [s, d] = nt(
            l.x - t.resize.offset.x,
            l.y - t.resize.offset.y,
            r[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
          ),
          m = new Map();
        if (
          (i.forEach((c) => {
            mI(this.scene.getNonDeletedElements(), c.id).forEach((u) => {
              m.set(c.id + u.id, { x: u.x - c.x, y: u.y - c.y });
            });
          }),
          !this.state.selectedElementsAreBeingDragged)
        ) {
          let [c, p] = nt(l.x, l.y, r[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()),
            u = { x: c - t.originInGrid.x, y: p - t.originInGrid.y },
            f = [...t.originalElements.values()];
          this.maybeCacheReferenceSnapPoints(r, n);
          let { snapOffset: b, snapLines: x } = Rh(n, Z(f, this.state), this, r, u, a);
          (s += b.x), (d += b.y), this.setState({ snapLines: x });
        }
        if (
          cG(
            t.originalElements,
            a,
            n,
            this.scene,
            Qg(r),
            BT(r),
            n.some((c) => un(c)) ? !ml(r) : ml(r),
            s,
            d,
            t.resize.center.x,
            t.resize.center.y
          )
        ) {
          let c = cf(n, this.scene.getNonDeletedElementsMap(), this.state.zoom),
            p = new Set();
          return (
            i.forEach((u) => {
              Ef(
                this.scene.getNonDeletedElements(),
                u,
                this.state,
                this.scene.getNonDeletedElementsMap()
              ).forEach((f) => p.add(f));
            }),
            this.setState({ elementsToHighlight: [...p], suggestedBindings: c }),
            !0
          );
        }
        return !1;
      });
      I(this, "getContextMenuItems", (t) => {
        let r = [];
        return (
          r.push(nc, rc),
          t === "canvas"
            ? this.state.viewModeEnabled
              ? [...r, ac, ni, kh, ii]
              : [nu, Ye, nc, rc, ic, Ye, Jm, ZE, Ye, ac, iu, ni, kh, ii]
            : (r.push(ic),
              this.state.viewModeEnabled
                ? [ri, ...r]
                : [
                    Ye,
                    oc,
                    ri,
                    nu,
                    Ye,
                    sw,
                    cw,
                    dw,
                    Ye,
                    vh,
                    Ye,
                    ...r,
                    Ye,
                    Kp,
                    Zp,
                    Ye,
                    qp,
                    bw,
                    su,
                    cu,
                    _E,
                    Jp,
                    Ye,
                    tu,
                    Ye,
                    Zm,
                    $m,
                    jm,
                    qm,
                    Ye,
                    ou,
                    ru,
                    Ye,
                    wh,
                    Ye,
                    ka,
                    hc,
                    Ye,
                    Qm,
                    Ma,
                    Ye,
                    ia,
                  ])
        );
      });
      I(
        this,
        "handleWheel",
        Pe((t) => {
          if (
            !(
              t.target instanceof HTMLCanvasElement ||
              t.target instanceof HTMLTextAreaElement ||
              t.target instanceof HTMLIFrameElement
            )
          ) {
            t[Y.CTRL_OR_CMD] && t.preventDefault();
            return;
          }
          if ((t.preventDefault(), yl)) return;
          let { deltaX: r, deltaY: n } = t;
          if (t.metaKey || t.ctrlKey) {
            let i = Math.sign(n),
              a = Wz * 100,
              l = Math.abs(n),
              s = n;
            l > a && (s = a * i);
            let d = this.state.zoom.value - s / 100;
            (d += Math.log10(Math.max(1, this.state.zoom.value)) * -i * Math.min(1, l / 20)),
              this.translateCanvas((m) => ({
                ..._o(
                  {
                    viewportX: this.lastViewportPosition.x,
                    viewportY: this.lastViewportPosition.y,
                    nextZoom: go(d),
                  },
                  m
                ),
                shouldCacheIgnoreZoom: !0,
              })),
              this.resetShouldCacheIgnoreZoomDebounced();
            return;
          }
          if (t.shiftKey) {
            this.translateCanvas(({ zoom: i, scrollX: a }) => ({
              scrollX: a - (n || r) / i.value,
            }));
            return;
          }
          this.translateCanvas(({ zoom: i, scrollX: a, scrollY: l }) => ({
            scrollX: a - r / i.value,
            scrollY: l - n / i.value,
          }));
        })
      );
      I(this, "savePointer", (t, r, n) => {
        if (!t || !r) return;
        let { x: i, y: a } = Oe({ clientX: t, clientY: r }, this.state);
        isNaN(i) || isNaN(a);
        let l = { x: i, y: a, tool: this.state.activeTool.type === "laser" ? "laser" : "pointer" };
        this.props.onPointerUpdate?.({ pointer: l, button: n, pointersMap: ue.pointers });
      });
      I(
        this,
        "resetShouldCacheIgnoreZoomDebounced",
        WT(() => {
          this.unmounted || this.setState({ shouldCacheIgnoreZoom: !1 });
        }, 300)
      );
      I(this, "updateDOMRect", (t) => {
        if (this.excalidrawContainerRef?.current) {
          let r = this.excalidrawContainerRef.current,
            { width: n, height: i, left: a, top: l } = r.getBoundingClientRect(),
            { width: s, height: d, offsetTop: m, offsetLeft: c } = this.state;
          if (n === s && i === d && a === c && l === m) {
            t && t();
            return;
          }
          this.setState({ width: n, height: i, offsetLeft: a, offsetTop: l }, () => {
            t && t();
          });
        }
      });
      I(this, "refresh", () => {
        this.setState({ ...this.getCanvasOffsets() });
      });
      let r = Jo(),
        {
          excalidrawAPI: n,
          viewModeEnabled: i = !1,
          zenModeEnabled: a = !1,
          gridModeEnabled: l = !1,
          objectsSnapModeEnabled: s = !1,
          theme: d = r.theme,
          name: m = `${g("labels.untitled")}-${XT()}`,
        } = t;
      if (
        ((this.state = {
          ...r,
          theme: d,
          isLoading: !0,
          ...this.getCanvasOffsets(),
          viewModeEnabled: i,
          zenModeEnabled: a,
          objectsSnapModeEnabled: s,
          gridModeEnabled: l ?? r.gridModeEnabled,
          name: m,
          width: window.innerWidth,
          height: window.innerHeight,
        }),
        (this.id = Cz()),
        (this.library = new yy(this)),
        (this.actionManager = new Vc(
          this.syncActionResult,
          () => this.state,
          () => this.scene.getElementsIncludingDeleted(),
          this
        )),
        (this.scene = new II()),
        (this.canvas = document.createElement("canvas")),
        (this.rc = Iz.canvas(this.canvas)),
        (this.renderer = new qa(this.scene)),
        (this.visibleElements = []),
        (this.store = new pG(this)),
        (this.history = new Xa(this.store)),
        n)
      ) {
        let c = {
          updateScene: this.updateScene,
          mutateElement: this.mutateElement,
          updateLibrary: this.library.updateLibrary,
          addFiles: this.addFiles,
          resetScene: this.resetScene,
          getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,
          getSceneElementsMapIncludingDeleted: this.getSceneElementsMapIncludingDeleted,
          history: { clear: this.resetHistory },
          scrollToContent: this.scrollToContent,
          getSceneElements: this.getSceneElements,
          getAppState: () => this.state,
          getFiles: () => this.files,
          getName: this.getName,
          registerAction: (p) => {
            this.actionManager.registerAction(p);
          },
          refresh: this.refresh,
          setToast: this.setToast,
          id: this.id,
          setActiveTool: this.setActiveTool,
          setCursor: this.setCursor,
          resetCursor: this.resetCursor,
          updateFrameRendering: this.updateFrameRendering,
          toggleSidebar: this.toggleSidebar,
          onChange: (p) => this.onChangeEmitter.on(p),
          onIncrement: (p) => this.store.onStoreIncrementEmitter.on(p),
          onPointerDown: (p) => this.onPointerDownEmitter.on(p),
          onPointerUp: (p) => this.onPointerUpEmitter.on(p),
          onScrollChange: (p) => this.onScrollChangeEmitter.on(p),
          onUserFollow: (p) => this.onUserFollowEmitter.on(p),
        };
        typeof n == "function" ? n(c) : console.error("excalidrawAPI should be a function!");
      }
      (this.excalidrawContainerValue = {
        container: this.excalidrawContainerRef.current,
        id: this.id,
      }),
        (this.fonts = new qo(this.scene)),
        (this.history = new Xa(this.store)),
        this.actionManager.registerAll(cs),
        this.actionManager.registerAction(uw(this.history)),
        this.actionManager.registerAction(hw(this.history));
    }
    onWindowMessage(t) {
      if (t.origin !== "https://player.vimeo.com" && t.origin !== "https://www.youtube.com") return;
      let r = null;
      try {
        r = JSON.parse(t.data);
      } catch {}
      if (r)
        switch (t.origin) {
          case "https://player.vimeo.com":
            if (r.method === "paused") {
              let n = null,
                i = document.body.querySelectorAll("iframe.excalidraw__embeddable");
              if (!i) break;
              for (let a of i) a.contentWindow === t.source && (n = a.contentWindow);
              n?.postMessage(
                JSON.stringify({ method: r.value ? "play" : "pause", value: !0 }),
                "*"
              );
            }
            break;
          case "https://www.youtube.com":
            if (
              r.event === "infoDelivery" &&
              r.info &&
              r.id &&
              typeof r.info.playerState == "number"
            ) {
              let n = r.id,
                i = r.info.playerState;
              Object.values(jd).includes(i) && Cf.set(n, i);
            }
            break;
        }
    }
    cacheEmbeddableRef(t, r) {
      r && this.iFrameRefs.set(t.id, r);
    }
    getHTMLIFrameElement(t) {
      return this.iFrameRefs.get(t.id);
    }
    handleEmbeddableCenterClick(t) {
      if (
        (this.state.activeEmbeddable?.element === t &&
          this.state.activeEmbeddable?.state === "active") ||
        (setTimeout(() => {
          this.setState({
            activeEmbeddable: { element: t, state: "active" },
            selectedElementIds: { [t.id]: !0 },
            newElement: null,
            selectionElement: null,
          });
        }, 100),
        Ui(t))
      )
        return;
      let r = this.getHTMLIFrameElement(t);
      if (r?.contentWindow) {
        if (r.src.includes("youtube")) {
          let n = Cf.get(t.id);
          switch (
            (n ||
              (Cf.set(t.id, jd.UNSTARTED),
              r.contentWindow.postMessage(JSON.stringify({ event: "listening", id: t.id }), "*")),
            n)
          ) {
            case jd.PLAYING:
            case jd.BUFFERING:
              r.contentWindow?.postMessage(
                JSON.stringify({ event: "command", func: "pauseVideo", args: "" }),
                "*"
              );
              break;
            default:
              r.contentWindow?.postMessage(
                JSON.stringify({ event: "command", func: "playVideo", args: "" }),
                "*"
              );
          }
        }
        r.src.includes("player.vimeo.com") &&
          r.contentWindow.postMessage(JSON.stringify({ method: "paused" }), "*");
      }
    }
    isIframeLikeElementCenter(t, r, n, i) {
      return (
        t &&
        !r.altKey &&
        !r.shiftKey &&
        !r.metaKey &&
        !r.ctrlKey &&
        (this.state.activeEmbeddable?.element !== t ||
          this.state.activeEmbeddable?.state === "hover" ||
          !this.state.activeEmbeddable) &&
        n >= t.x + t.width / 3 &&
        n <= t.x + (2 * t.width) / 3 &&
        i >= t.y + t.height / 3 &&
        i <= t.y + (2 * t.height) / 3
      );
    }
    renderEmbeddables() {
      let t = this.state.zoom.value,
        r = this.state.width,
        n = this.state.height,
        i = this.scene
          .getNonDeletedElements()
          .filter((a) => (Nr(a) && this.embedsValidationStatus.get(a.id) === !0) || Ui(a));
      return pe(fG, {
        children: i.map((a) => {
          let { x: l, y: s } = qd({ sceneX: a.x, sceneY: a.y }, this.state),
            d = iI(a, r, n, this.state, this.scene.getNonDeletedElementsMap()),
            m = this.initializedEmbeds.has(a.id);
          if ((d && !m && this.initializedEmbeds.add(a.id), !(d || m))) return null;
          let p;
          if (Ui(a)) {
            p = null;
            let b = (a.customData?.generationData ?? this.magicGenerations.get(a.id)) || {
              status: "error",
              message: "No generation data",
              code: "ERR_NO_GENERATION_DATA",
            };
            if (b.status === "done") {
              let x = b.html;
              p = { intrinsicSize: { w: a.width, h: a.height }, type: "document", srcdoc: () => x };
            } else if (b.status === "pending")
              p = {
                intrinsicSize: { w: a.width, h: a.height },
                type: "document",
                srcdoc: () =>
                  sI(`
                    <style>
                      html, body {
                        width: 100%;
                        height: 100%;
                        color: ${this.state.theme === $d.DARK ? "white" : "black"};
                      }
                      body {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        gap: 1rem;
                      }

                      .Spinner {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: auto;
                        margin-right: auto;
                      }

                      .Spinner svg {
                        animation: rotate 1.6s linear infinite;
                        transform-origin: center center;
                        width: 40px;
                        height: 40px;
                      }

                      .Spinner circle {
                        stroke: currentColor;
                        animation: dash 1.6s linear 0s infinite;
                        stroke-linecap: round;
                      }

                      @keyframes rotate {
                        100% {
                          transform: rotate(360deg);
                        }
                      }

                      @keyframes dash {
                        0% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: 0;
                        }
                        50% {
                          stroke-dasharray: 150, 300;
                          stroke-dashoffset: -200;
                        }
                        100% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: -280;
                        }
                      }
                    </style>
                    <div class="Spinner">
                      <svg
                        viewBox="0 0 100 100"
                      >
                        <circle
                          cx="50"
                          cy="50"
                          r="46"
                          stroke-width="8"
                          fill="none"
                          stroke-miter-limit="10"
                        />
                      </svg>
                    </div>
                    <div>Generating...</div>
                  `),
              };
            else {
              let x;
              b.code === "ERR_GENERATION_INTERRUPTED"
                ? (x = "Generation was interrupted...")
                : (x = b.message || "Generation failed"),
                (p = {
                  intrinsicSize: { w: a.width, h: a.height },
                  type: "document",
                  srcdoc: () =>
                    sI(`
                    <style>
                    html, body {
                      height: 100%;
                    }
                      body {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: ${kz.red[3]};
                      }
                      h1, h3 {
                        margin-top: 0;
                        margin-bottom: 0.5rem;
                      }
                    </style>
                    <h1>Error!</h1>
                    <h3>${x}</h3>
                  `),
                });
            }
          } else p = Jd(jz(a.link || ""));
          let u =
              this.state.activeEmbeddable?.element === a &&
              this.state.activeEmbeddable?.state === "active",
            f =
              this.state.activeEmbeddable?.element === a &&
              this.state.activeEmbeddable?.state === "hover";
          return pe(
            "div",
            {
              className: LT("excalidraw__embeddable-container", { "is-hovered": f }),
              style: {
                transform: d
                  ? `translate(${l - this.state.offsetLeft}px, ${
                      s - this.state.offsetTop
                    }px) scale(${t})`
                  : "none",
                display: d ? "block" : "none",
                opacity: eG(
                  a,
                  yf(a, this.scene.getNonDeletedElementsMap()),
                  this.elementsPendingErasure,
                  null,
                  this.state.openDialog?.name === "elementLinkSelector" ? Kz : 1
                ),
                "--embeddable-radius": `${SH(Math.min(a.width, a.height), a)}px`,
              },
              children: em("div", {
                className: "excalidraw__embeddable-container__inner",
                style: {
                  width: d ? `${a.width}px` : 0,
                  height: d ? `${a.height}px` : 0,
                  transform: d ? `rotate(${a.angle}rad)` : "none",
                  pointerEvents: u ? zi.enabled : zi.disabled,
                },
                children: [
                  f &&
                    pe("div", {
                      className: "excalidraw__embeddable-hint",
                      children: g("buttons.embeddableInteractionButton"),
                    }),
                  pe("div", {
                    className: "excalidraw__embeddable__outer",
                    style: { padding: `${a.strokeWidth}px` },
                    children:
                      (Nr(a) ? this.props.renderEmbeddable?.(a, this.state) : null) ??
                      pe("iframe", {
                        ref: (b) => this.cacheEmbeddableRef(a, b),
                        className: "excalidraw__embeddable",
                        srcDoc: p?.type === "document" ? p.srcdoc(this.state.theme) : void 0,
                        src: p?.type !== "document" ? p?.link ?? "" : void 0,
                        scrolling: "no",
                        referrerPolicy: "no-referrer-when-downgrade",
                        title: "Excalidraw Embedded Content",
                        allow:
                          "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
                        allowFullScreen: !0,
                        sandbox: `${
                          p?.sandbox?.allowSameOrigin ? "allow-same-origin" : ""
                        } allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation allow-downloads`,
                      }),
                  }),
                ],
              }),
            },
            a.id
          );
        }),
      });
    }
    toggleOverscrollBehavior(t) {
      document.documentElement.style.overscrollBehaviorX =
        t.type === "pointerenter" ? "none" : "auto";
    }
    render() {
      let t = this.scene.getSelectedElements(this.state),
        { renderTopRightUI: r, renderCustomStats: n } = this.props,
        i = this.scene.getSceneNonce(),
        { elementsMap: a, visibleElements: l } = this.renderer.getRenderableElements({
          sceneNonce: i,
          zoom: this.state.zoom,
          offsetLeft: this.state.offsetLeft,
          offsetTop: this.state.offsetTop,
          scrollX: this.state.scrollX,
          scrollY: this.state.scrollY,
          height: this.state.height,
          width: this.state.width,
          editingTextElement: this.state.editingTextElement,
          newElementId: this.state.newElement?.id,
        });
      this.visibleElements = l;
      let s = this.scene.getNonDeletedElementsMap(),
        d =
          "setPointerCapture" in HTMLElement.prototype
            ? !1
            : this.state.selectionElement ||
              this.state.newElement ||
              this.state.selectedElementsAreBeingDragged ||
              this.state.resizingElement ||
              (this.state.activeTool.type === "laser" && this.state.cursorButton === "down"),
        m = t[0],
        c = He.get(io)?.type === "panel";
      return pe("div", {
        className: LT("excalidraw excalidraw-container", {
          "excalidraw--view-mode":
            this.state.viewModeEnabled || this.state.openDialog?.name === "elementLinkSelector",
          "excalidraw--mobile": this.device.editor.isMobile,
        }),
        style: {
          "--ui-pointerEvents": d ? zi.disabled : zi.enabled,
          "--right-sidebar-width": "302px",
        },
        ref: this.excalidrawContainerRef,
        onDrop: this.handleAppOnDrop,
        tabIndex: 0,
        onKeyDown: this.props.handleKeyboardGlobally ? void 0 : this.onKeyDown,
        onPointerEnter: this.toggleOverscrollBehavior,
        onPointerLeave: this.toggleOverscrollBehavior,
        children: pe(LI.Provider, {
          value: this,
          children: pe(PI.Provider, {
            value: this.props,
            children: pe(Lf.Provider, {
              value: this.excalidrawContainerValue,
              children: pe(Mf.Provider, {
                value: this.device,
                children: pe(Df.Provider, {
                  value: this.setAppState,
                  children: pe(Af.Provider, {
                    value: this.state,
                    children: em(Pf.Provider, {
                      value: this.scene.getNonDeletedElements(),
                      children: [
                        em(_f.Provider, {
                          value: this.actionManager,
                          children: [
                            pe(uT, {
                              canvas: this.canvas,
                              appState: this.state,
                              files: this.files,
                              setAppState: this.setAppState,
                              actionManager: this.actionManager,
                              elements: this.scene.getNonDeletedElements(),
                              onLockToggle: this.toggleLock,
                              onPenModeToggle: this.togglePenMode,
                              onHandToolToggle: this.onHandToolToggle,
                              langCode: Po().code,
                              renderTopRightUI: r,
                              renderCustomStats: n,
                              showExitZenModeBtn:
                                typeof this.props?.zenModeEnabled > "u" &&
                                this.state.zenModeEnabled,
                              UIOptions: this.props.UIOptions,
                              onExportImage: this.onExportImage,
                              renderWelcomeScreen:
                                !this.state.isLoading &&
                                this.state.showWelcomeScreen &&
                                this.state.activeTool.type === "selection" &&
                                !this.state.zenModeEnabled &&
                                !this.scene.getElementsIncludingDeleted().length,
                              app: this,
                              isCollaborating: this.props.isCollaborating,
                              generateLinkForSelection: this.props.generateLinkForSelection,
                              children: this.props.children,
                            }),
                            pe("div", { className: "excalidraw-textEditorContainer" }),
                            pe("div", { className: "excalidraw-contextMenuContainer" }),
                            pe("div", { className: "excalidraw-eye-dropper-container" }),
                            pe(bT, {
                              trails: [this.laserTrails, this.lassoTrail, this.eraserTrail],
                            }),
                            t.length === 1 &&
                              this.state.openDialog?.name !== "elementLinkSelector" &&
                              this.state.showHyperlinkPopup &&
                              pe(
                                HE,
                                {
                                  element: m,
                                  scene: this.scene,
                                  setAppState: this.setAppState,
                                  onLinkOpen: this.props.onLinkOpen,
                                  setToast: this.setToast,
                                  updateEmbedValidationStatus: this.updateEmbedValidationStatus,
                                },
                                m.id
                              ),
                            this.props.aiEnabled !== !1 &&
                              t.length === 1 &&
                              uf(m) &&
                              pe(Kh, {
                                element: m,
                                elementsMap: a,
                                children: pe(Ar, {
                                  title: g("labels.convertToCode"),
                                  icon: os,
                                  checked: !1,
                                  onChange: () => this.onMagicFrameGenerate(m, "button"),
                                }),
                              }),
                            t.length === 1 &&
                              Ui(m) &&
                              m.customData?.generationData?.status === "done" &&
                              em(Kh, {
                                element: m,
                                elementsMap: a,
                                children: [
                                  pe(Ar, {
                                    title: g("labels.copySource"),
                                    icon: Ln,
                                    checked: !1,
                                    onChange: () => this.onIframeSrcCopy(m),
                                  }),
                                  pe(Ar, {
                                    title: "Enter fullscreen",
                                    icon: U0,
                                    checked: !1,
                                    onChange: () => {
                                      let p = this.getHTMLIFrameElement(m);
                                      if (p)
                                        try {
                                          p.requestFullscreen(),
                                            this.setState({
                                              activeEmbeddable: { element: m, state: "active" },
                                              selectedElementIds: { [m.id]: !0 },
                                              newElement: null,
                                              selectionElement: null,
                                            });
                                        } catch (u) {
                                          console.warn(u),
                                            this.setState({
                                              errorMessage: "Couldn't enter fullscreen",
                                            });
                                        }
                                    },
                                  }),
                                ],
                              }),
                            pe(gT, {
                              elements: this.scene.getNonDeletedElements(),
                              elementsMap: a,
                              app: this,
                            }),
                            this.state.toast !== null &&
                              pe(kT, {
                                message: this.state.toast.message,
                                onClose: this.handleToastClose,
                                duration: this.state.toast.duration,
                                closable: this.state.toast.closable,
                              }),
                            this.state.contextMenu &&
                              pe(Pv, {
                                items: this.state.contextMenu.items,
                                top: this.state.contextMenu.top,
                                left: this.state.contextMenu.left,
                                actionManager: this.actionManager,
                                onClose: (p) => {
                                  this.setState({ contextMenu: null }, () => {
                                    this.focusContainer(), p?.();
                                  });
                                },
                              }),
                            pe(jg, {
                              canvas: this.canvas,
                              rc: this.rc,
                              elementsMap: a,
                              allElementsMap: s,
                              visibleElements: l,
                              sceneNonce: i,
                              selectionNonce: this.state.selectionElement?.versionNonce,
                              scale: window.devicePixelRatio,
                              appState: this.state,
                              renderConfig: {
                                imageCache: this.imageCache,
                                isExporting: !1,
                                renderGrid: br(this),
                                canvasBackgroundColor: this.state.viewBackgroundColor,
                                embedsValidationStatus: this.embedsValidationStatus,
                                elementsPendingErasure: this.elementsPendingErasure,
                                pendingFlowchartNodes: this.flowChartCreator.pendingNodes,
                              },
                            }),
                            this.state.newElement &&
                              pe(CT, {
                                appState: this.state,
                                scale: window.devicePixelRatio,
                                rc: this.rc,
                                elementsMap: a,
                                allElementsMap: s,
                                renderConfig: {
                                  imageCache: this.imageCache,
                                  isExporting: !1,
                                  renderGrid: !1,
                                  canvasBackgroundColor: this.state.viewBackgroundColor,
                                  embedsValidationStatus: this.embedsValidationStatus,
                                  elementsPendingErasure: this.elementsPendingErasure,
                                  pendingFlowchartNodes: null,
                                },
                              }),
                            pe($g, {
                              containerRef: this.excalidrawContainerRef,
                              canvas: this.interactiveCanvas,
                              elementsMap: a,
                              visibleElements: l,
                              allElementsMap: s,
                              selectedElements: t,
                              sceneNonce: i,
                              selectionNonce: this.state.selectionElement?.versionNonce,
                              scale: window.devicePixelRatio,
                              appState: this.state,
                              renderScrollbars: this.props.renderScrollbars === !0,
                              device: this.device,
                              renderInteractiveSceneCallback: this.renderInteractiveSceneCallback,
                              handleCanvasRef: this.handleInteractiveCanvasRef,
                              onContextMenu: this.handleCanvasContextMenu,
                              onPointerMove: this.handleCanvasPointerMove,
                              onPointerUp: this.handleCanvasPointerUp,
                              onPointerCancel: this.removePointer,
                              onTouchMove: this.handleTouchMove,
                              onPointerDown: this.handleCanvasPointerDown,
                              onDoubleClick: this.handleCanvasDoubleClick,
                            }),
                            this.state.userToFollow &&
                              pe(Dv, {
                                width: this.state.width,
                                height: this.state.height,
                                userToFollow: this.state.userToFollow,
                                onDisconnect: this.maybeUnfollowRemoteUser,
                              }),
                            this.renderFrameNames(),
                            this.state.activeLockedId &&
                              pe(MT, { app: this, activeLockedId: this.state.activeLockedId }),
                            c && pe(ry, { app: this }),
                          ],
                        }),
                        this.renderEmbeddables(),
                      ],
                    }),
                  }),
                }),
              }),
            }),
          }),
        }),
      });
    }
    setPlugins(t) {
      Object.assign(this.plugins, t);
    }
    async onMagicFrameGenerate(t, r) {
      let n = this.plugins.diagramToCode?.generate;
      if (!n) {
        this.setState({ errorMessage: "No diagram to code plugin found" });
        return;
      }
      let i = OH(this.scene.getNonDeletedElements(), t).filter((l) => !uf(l));
      if (!i.length) {
        r === "button"
          ? (this.setState({ errorMessage: "Cannot generate from an empty frame" }),
            re("ai", "generate (no-children)", "d2c"))
          : this.setActiveTool({ type: "magicframe" });
        return;
      }
      let a = this.insertIframeElement({
        sceneX: t.x + t.width + 30,
        sceneY: t.y,
        width: t.width,
        height: t.height,
      });
      if (a) {
        this.updateMagicGeneration({ frameElement: a, data: { status: "pending" } }),
          this.setState({ selectedElementIds: { [a.id]: !0 } }),
          re("ai", "generate (start)", "d2c");
        try {
          let { html: l } = await n({ frame: t, children: i });
          if ((re("ai", "generate (success)", "d2c"), !l.trim())) {
            this.updateMagicGeneration({
              frameElement: a,
              data: { status: "error", code: "ERR_OAI", message: "Nothing genereated :(" },
            });
            return;
          }
          let s =
            l.includes("<!DOCTYPE html>") && l.includes("</html>")
              ? l.slice(l.indexOf("<!DOCTYPE html>"), l.indexOf("</html>") + 7)
              : l;
          this.updateMagicGeneration({ frameElement: a, data: { status: "done", html: s } });
        } catch (l) {
          re("ai", "generate (failed)", "d2c"),
            this.updateMagicGeneration({
              frameElement: a,
              data: {
                status: "error",
                code: "ERR_OAI",
                message: l.message || "Unknown error during generation",
              },
            });
        }
      }
    }
    onIframeSrcCopy(t) {
      t.customData?.generationData?.status === "done" &&
        (ro(t.customData.generationData.html),
        this.setToast({ message: "copied to clipboard", closable: !1, duration: 1500 }));
    }
    clearImageShapeCache(t) {
      let r = t ?? this.files;
      this.scene.getNonDeletedElements().forEach((n) => {
        hl(n) && r[n.fileId] && (this.imageCache.delete(n.fileId), bl.delete(n));
      });
    }
    async componentDidMount() {
      if (
        ((this.unmounted = !1),
        (this.excalidrawContainerValue.container = this.excalidrawContainerRef.current),
        Sf() || kI())
      ) {
        let n = this.setState.bind(this);
        Object.defineProperties(window.h, {
          state: { configurable: !0, get: () => this.state },
          setState: { configurable: !0, value: (...i) => this.setState(...i) },
          app: { configurable: !0, value: this },
          history: { configurable: !0, value: this.history },
          store: { configurable: !0, value: this.store },
          fonts: { configurable: !0, value: this.fonts },
        });
      }
      this.store.onDurableIncrementEmitter.on((n) => {
        this.history.record(n.delta);
      });
      let { onIncrement: t } = this.props;
      t &&
        this.store.onStoreIncrementEmitter.on((n) => {
          t(n);
        }),
        this.scene.onUpdate(this.triggerRender),
        this.addEventListeners(),
        this.props.autoFocus && this.excalidrawContainerRef.current && this.focusContainer(),
        Sf() || (this.refreshViewportBreakpoints(), this.refreshEditorBreakpoints()),
        GT &&
          this.excalidrawContainerRef.current &&
          ((this.resizeObserver = new ResizeObserver(() => {
            this.refreshEditorBreakpoints(), this.updateDOMRect();
          })),
          this.resizeObserver?.observe(this.excalidrawContainerRef.current)),
        new URLSearchParams(window.location.search.slice(1)).has("web-share-target")
          ? this.restoreFileFromShare()
          : this.updateDOMRect(this.initializeScene),
        _z() && !ZH() && this.setState({ errorMessage: pe(Sv, {}) });
    }
    componentWillUnmount() {
      window.launchQueue?.setConsumer(() => {}),
        this.renderer.destroy(),
        this.scene.destroy(),
        (this.scene = new II()),
        (this.fonts = new qo(this.scene)),
        (this.renderer = new qa(this.scene)),
        (this.files = {}),
        this.imageCache.clear(),
        this.resizeObserver?.disconnect(),
        (this.unmounted = !0),
        this.removeEventListeners(),
        this.library.destroy(),
        this.laserTrails.stop(),
        this.eraserTrail.stop(),
        this.onChangeEmitter.clear(),
        this.store.onStoreIncrementEmitter.clear(),
        this.store.onDurableIncrementEmitter.clear(),
        bl.destroy(),
        Wt.destroy(),
        clearTimeout(Br),
        Ee.clearCache(),
        uo.clearCache(),
        (Br = 0),
        (document.documentElement.style.overscrollBehaviorX = "");
    }
    removeEventListeners() {
      this.onRemoveEventListenersEmitter.trigger();
    }
    addEventListeners() {
      this.removeEventListeners(),
        this.props.handleKeyboardGlobally &&
          this.onRemoveEventListenersEmitter.once(_e(document, ee.KEYDOWN, this.onKeyDown, !1)),
        this.onRemoveEventListenersEmitter.once(
          _e(this.excalidrawContainerRef.current, ee.WHEEL, this.handleWheel, { passive: !1 }),
          _e(window, ee.MESSAGE, this.onWindowMessage, !1),
          _e(document, ee.POINTER_UP, this.removePointer, { passive: !1 }),
          _e(document, ee.COPY, this.onCopy, { passive: !1 }),
          _e(document, ee.KEYUP, this.onKeyUp, { passive: !0 }),
          _e(document, ee.POINTER_MOVE, this.updateCurrentCursorPosition, { passive: !1 }),
          _e(
            document.fonts,
            "loadingdone",
            (t) => {
              let r = t.fontfaces;
              this.fonts.onLoaded(r);
            },
            { passive: !1 }
          ),
          _e(document, ee.GESTURE_START, this.onGestureStart, !1),
          _e(document, ee.GESTURE_CHANGE, this.onGestureChange, !1),
          _e(document, ee.GESTURE_END, this.onGestureEnd, !1),
          _e(
            window,
            ee.FOCUS,
            () => {
              this.maybeCleanupAfterMissingPointerUp(null), this.triggerRender(!0);
            },
            { passive: !1 }
          )
        ),
        !this.state.viewModeEnabled &&
          (this.onRemoveEventListenersEmitter.once(
            _e(document, ee.FULLSCREENCHANGE, this.onFullscreenChange, { passive: !1 }),
            _e(document, ee.PASTE, this.pasteFromClipboard, { passive: !1 }),
            _e(document, ee.CUT, this.onCut, { passive: !1 }),
            _e(window, ee.RESIZE, this.onResize, !1),
            _e(window, ee.UNLOAD, this.onUnload, !1),
            _e(window, ee.BLUR, this.onBlur, !1),
            _e(this.excalidrawContainerRef.current, ee.WHEEL, this.handleWheel, { passive: !1 }),
            _e(this.excalidrawContainerRef.current, ee.DRAG_OVER, this.disableEvent, !1),
            _e(this.excalidrawContainerRef.current, ee.DROP, this.disableEvent, !1)
          ),
          this.props.detectScroll &&
            this.onRemoveEventListenersEmitter.once(
              _e(qz(this.excalidrawContainerRef.current), ee.SCROLL, this.onScroll, { passive: !1 })
            ));
    }
    componentDidUpdate(t, r) {
      this.updateEmbeddables();
      let n = this.scene.getElementsIncludingDeleted(),
        i = this.scene.getElementsMapIncludingDeleted();
      !this.state.showWelcomeScreen && !n.length && this.setState({ showWelcomeScreen: !0 }),
        t.UIOptions.dockedSidebarBreakpoint !== this.props.UIOptions.dockedSidebarBreakpoint &&
          this.refreshEditorBreakpoints(),
        r.userToFollow &&
          !this.state.collaborators.has(r.userToFollow.socketId) &&
          this.maybeUnfollowRemoteUser(),
        (r.zoom.value !== this.state.zoom.value ||
          r.scrollX !== this.state.scrollX ||
          r.scrollY !== this.state.scrollY) &&
          (this.props?.onScrollChange?.(this.state.scrollX, this.state.scrollY, this.state.zoom),
          this.onScrollChangeEmitter.trigger(
            this.state.scrollX,
            this.state.scrollY,
            this.state.zoom
          )),
        r.userToFollow !== this.state.userToFollow &&
          (r.userToFollow &&
            this.onUserFollowEmitter.trigger({ userToFollow: r.userToFollow, action: "UNFOLLOW" }),
          this.state.userToFollow &&
            this.onUserFollowEmitter.trigger({
              userToFollow: this.state.userToFollow,
              action: "FOLLOW",
            })),
        Object.keys(this.state.selectedElementIds).length &&
          bt(this.state) &&
          this.setState({ activeTool: Zo(this.state, { type: "selection" }) }),
        this.state.activeTool.type === "eraser" &&
          r.theme !== this.state.theme &&
          Rp(this.interactiveCanvas, this.state.theme),
        r.activeTool.type === "selection" &&
          this.state.activeTool.type !== "selection" &&
          this.state.showHyperlinkPopup &&
          this.setState({ showHyperlinkPopup: !1 }),
        t.langCode !== this.props.langCode && this.updateLanguage(),
        bt(r) && !bt(this.state) && this.eraserTrail.endPath(),
        t.viewModeEnabled !== this.props.viewModeEnabled &&
          this.setState({ viewModeEnabled: !!this.props.viewModeEnabled }),
        r.viewModeEnabled !== this.state.viewModeEnabled &&
          (this.addEventListeners(), this.deselectElements()),
        (r.openDialog?.name === "elementLinkSelector" ||
          this.state.openDialog?.name === "elementLinkSelector") &&
          r.openDialog?.name !== this.state.openDialog?.name &&
          (this.deselectElements(), this.setState({ hoveredElementIds: {} })),
        t.zenModeEnabled !== this.props.zenModeEnabled &&
          this.setState({ zenModeEnabled: !!this.props.zenModeEnabled }),
        t.theme !== this.props.theme &&
          this.props.theme &&
          this.setState({ theme: this.props.theme }),
        this.excalidrawContainerRef.current?.classList.toggle(
          "theme--dark",
          this.state.theme === $d.DARK
        ),
        this.state.editingLinearElement &&
          !this.state.selectedElementIds[this.state.editingLinearElement.elementId] &&
          setTimeout(() => {
            this.state.editingLinearElement && this.actionManager.executeAction(At);
          }),
        this.state.editingTextElement?.isDeleted && this.setState({ editingTextElement: null }),
        this.state.selectedLinearElement &&
          !this.state.selectedElementIds[this.state.selectedLinearElement.elementId] &&
          this.setState({ selectedLinearElement: null }),
        this.store.commit(i, this.state),
        this.state.isLoading ||
          (this.props.onChange?.(n, this.state, this.files),
          this.onChangeEmitter.trigger(n, this.state, this.files));
    }
    static resetTapTwice() {
      El = !1;
    }
    async addElementsFromMixedContentPaste(t, { isPlainPaste: r, sceneX: n, sceneY: i }) {
      if (!r && t.some((a) => a.type === "imageUrl") && this.isToolSupported("image")) {
        let a = t.filter((p) => p.type === "imageUrl").map((p) => p.value),
          l = await Promise.all(
            a.map(async (p) => {
              try {
                return { file: await g1(p) };
              } catch (u) {
                let f = u.message;
                return (
                  u.cause === "FETCH_ERROR"
                    ? (f = g("errors.failedToFetchImage"))
                    : u.cause === "UNSUPPORTED" && (f = g("errors.unsupportedFileType")),
                  { errorMessage: f }
                );
              }
            })
          ),
          s = i,
          d = !1,
          m = {};
        for (let p of l)
          if (p.file) {
            let u = await this.createImageElement({ sceneX: n, sceneY: s, imageFile: p.file });
            u &&
              (d || ((d = !0), (s -= u.height / 2)),
              this.scene.mutateElement(u, { y: s }, { informMutation: !1, isDragging: !1 }),
              (s = u.y + u.height + 25),
              (m[u.id] = !0));
          }
        this.setState({ selectedElementIds: ye(m, this.state) });
        let c = l.find((p) => !!p.errorMessage);
        c && c.errorMessage && this.setState({ errorMessage: c.errorMessage });
      } else {
        let a = t.filter((l) => l.type === "text");
        a.length &&
          this.addTextFromPaste(
            a.map((l) => l.value).join(`

`),
            r
          );
      }
    }
    addTextFromPaste(t, r = !1) {
      let { x: n, y: i } = Oe(
          { clientX: this.lastViewportPosition.x, clientY: this.lastViewportPosition.y },
          this.state
        ),
        a = {
          x: n,
          y: i,
          strokeColor: this.state.currentItemStrokeColor,
          backgroundColor: this.state.currentItemBackgroundColor,
          fillStyle: this.state.currentItemFillStyle,
          strokeWidth: this.state.currentItemStrokeWidth,
          strokeStyle: this.state.currentItemStrokeStyle,
          roundness: null,
          roughness: this.state.currentItemRoughness,
          opacity: this.state.currentItemOpacity,
          text: t,
          fontSize: this.state.currentItemFontSize,
          fontFamily: this.state.currentItemFontFamily,
          textAlign: Xz,
          verticalAlign: FT,
          locked: !1,
        },
        l = of({ fontSize: a.fontSize, fontFamily: a.fontFamily }),
        s = YT(a.fontFamily),
        [d, , m] = UH(this.state),
        c = Math.max(Math.min((m - d) * 0.5, 800), 200),
        p = 10,
        u = i,
        f = r
          ? [t]
          : t.split(`
`),
        b = f.reduce((x, w, E) => {
          let y = $H(w).trim();
          if (y.length) {
            let v = this.getTopLayerFrameAtSceneCoords({ x: n, y: u }),
              C = fI(y, l, s),
              S = C.width > c,
              M = S ? XH(y, l, c) : y;
            C = S ? fI(M, l, s) : C;
            let k = n - C.width / 2,
              A = u - C.height / 2,
              P = QT({
                ...a,
                x: k,
                y: A,
                text: M,
                originalText: y,
                lineHeight: s,
                autoResize: !S,
                frameId: v ? v.id : null,
              });
            x.push(P), (u += P.height + p);
          } else f[E - 1]?.trim() && (u += jH(a.fontSize, s) + p);
          return x;
        }, []);
      b.length !== 0 &&
        (this.scene.insertElements(b),
        this.store.scheduleCapture(),
        this.setState({
          selectedElementIds: ye(Object.fromEntries(b.map((x) => [x.id, !0])), this.state),
        }),
        !r &&
          b.length > 1 &&
          SI === !1 &&
          !this.device.editor.isMobile &&
          (this.setToast({
            message: g("toast.pasteAsSingleElement", { shortcut: eH("CtrlOrCmd+Shift+V") }),
            duration: 5e3,
          }),
          (SI = !0)));
    }
    handleTextWysiwyg(t, { isExistingElement: r = !1 }) {
      let n = this.scene.getElementsMapIncludingDeleted(),
        i = (a, l) => {
          this.scene.replaceAllElements([
            ...this.scene
              .getElementsIncludingDeleted()
              .map((s) =>
                s.id === t.id && po(s)
                  ? pn(s, {
                      originalText: a,
                      isDeleted: l ?? s.isDeleted,
                      ...EH(s, dI(s, n), n, a),
                    })
                  : s
              ),
          ]);
        };
      pv({
        id: t.id,
        canvas: this.canvas,
        getViewportCoords: (a, l) => {
          let { x: s, y: d } = qd({ sceneX: a, sceneY: l }, this.state);
          return [s - this.state.offsetLeft, d - this.state.offsetTop];
        },
        onChange: Pe((a) => {
          i(a, !1), TI(t) && sf(t, this.scene);
        }),
        onSubmit: Pe(({ viaKeyboard: a, nextOriginalText: l }) => {
          let s = !l.trim();
          if ((i(l, s), !s && a)) {
            let d = t.containerId ? t.containerId : t.id;
            Ko(() => {
              this.setState((m) => ({
                selectedElementIds: ye({ ...m.selectedElementIds, [d]: !0 }, m),
              }));
            });
          }
          s && dH(this.scene.getNonDeletedElements(), [t]),
            (!s || r) && this.store.scheduleCapture(),
            Ko(() => {
              this.setState({ newElement: null, editingTextElement: null });
            }),
            this.state.activeTool.locked && Pt(this.interactiveCanvas, this.state),
            this.focusContainer();
        }),
        element: t,
        excalidrawContainer: this.excalidrawContainerRef.current,
        app: this,
        autoSelect: !this.device.isTouchScreen,
      }),
        this.deselectElements(),
        i(t.originalText, !1);
    }
    deselectElements() {
      this.setState({
        selectedElementIds: ye({}, this.state),
        selectedGroupIds: {},
        editingGroupId: null,
        activeEmbeddable: null,
      });
    }
    getTextElementAtPosition(t, r) {
      let n = this.getElementAtPosition(t, r, { includeBoundTextElement: !0 });
      return n && po(n) && !n.isDeleted ? n : null;
    }
    getElementAtPosition(t, r, n) {
      let i = [];
      if (
        (n && "allHitElements" in n
          ? (i = n?.allHitElements || [])
          : (i = this.getElementsAtPosition(t, r, {
              includeBoundTextElement: n?.includeBoundTextElement,
              includeLockedElements: n?.includeLockedElements,
            })),
        i.length > 1)
      ) {
        if (n?.preferSelected) {
          for (let l = i.length - 1; l > -1; l--)
            if (this.state.selectedElementIds[i[l].id]) return i[l];
        }
        let a = i[i.length - 1];
        return fl({
          point: se(t, r),
          element: a,
          threshold: this.getElementHitThreshold(a) / 2,
          elementsMap: this.scene.getNonDeletedElementsMap(),
          frameNameBound: Zt(a) ? this.frameNameBoundsCache.get(a) : null,
        })
          ? a
          : i[i.length - 2];
      }
      return i.length === 1 ? i[0] : null;
    }
    getElementsAtPosition(t, r, n) {
      let i = [],
        a = this.scene.getNonDeletedElementsMap();
      return (
        n?.includeBoundTextElement && n?.includeLockedElements
          ? this.scene.getNonDeletedElements()
          : this.scene
              .getNonDeletedElements()
              .filter(
                (s) =>
                  (n?.includeLockedElements || !s.locked) &&
                  (n?.includeBoundTextElement || !(po(s) && s.containerId))
              )
      )
        .filter((s) => this.hitElement(t, r, s))
        .filter((s) => {
          let d = yf(s, a);
          return d && this.state.frameRendering.enabled && this.state.frameRendering.clip
            ? pI({ x: t, y: r }, d, a)
            : !0;
        })
        .filter((s) => (Ui(s) ? (i.push(s), !1) : !0))
        .concat(i);
    }
    getElementHitThreshold(t) {
      return Math.max(t.strokeWidth / 2 + 0.1, 0.85 * (UT / this.state.zoom.value));
    }
    hitElement(t, r, n, i = !0) {
      return (i &&
        this.state.selectedElementIds[n.id] &&
        DH([n], this.state) &&
        uG(se(t, r), n, this.scene.getNonDeletedElementsMap(), this.getElementHitThreshold(n))) ||
        HH(se(t, r), n, this.scene.getNonDeletedElementsMap())
        ? !0
        : fl({
            point: se(t, r),
            element: n,
            threshold: this.getElementHitThreshold(n),
            elementsMap: this.scene.getNonDeletedElementsMap(),
            frameNameBound: Zt(n) ? this.frameNameBoundsCache.get(n) : null,
          });
    }
    getTextBindableContainerAtPosition(t, r) {
      let n = this.scene.getNonDeletedElements(),
        i = this.scene.getSelectedElements(this.state);
      if (i.length === 1) return rI(i[0], !1) ? i[0] : null;
      let a = null;
      for (let l = n.length - 1; l >= 0; --l) {
        if (n[l].isDeleted) continue;
        let [s, d, m, c] = $T(n[l], this.scene.getNonDeletedElementsMap());
        if (
          df(n[l]) &&
          fl({
            point: se(t, r),
            element: n[l],
            elementsMap: this.scene.getNonDeletedElementsMap(),
            threshold: this.getElementHitThreshold(n[l]),
          })
        ) {
          a = n[l];
          break;
        } else if (s < t && t < m && d < r && r < c) {
          a = n[l];
          break;
        }
      }
      return rI(a, !1) ? a : null;
    }
    handleHoverSelectedLinearElement(t, r, n) {
      let i = this.scene.getNonDeletedElementsMap(),
        a = ve.getElement(t.elementId, i);
      if (a)
        if (this.state.selectedLinearElement) {
          let l = -1,
            s = null;
          fl({
            point: se(r, n),
            element: a,
            elementsMap: i,
            threshold: this.getElementHitThreshold(a),
          })
            ? ((l = ve.getPointIndexUnderCursor(a, i, this.state.zoom, r, n)),
              (s = ve.getSegmentMidpointHitCoords(
                t,
                { x: r, y: n },
                this.state,
                this.scene.getNonDeletedElementsMap()
              )),
              (We(a) ? l === 0 || l === a.points.length - 1 : l >= 0) || s
                ? xe(this.interactiveCanvas, De.POINTER)
                : this.hitElement(r, n, a) &&
                  (!We(a) || !(a.startBinding || a.endBinding)) &&
                  xe(this.interactiveCanvas, De.MOVE))
            : this.hitElement(r, n, a) &&
              (!We(a) || !(a.startBinding || a.endBinding)) &&
              xe(this.interactiveCanvas, De.MOVE),
            this.state.selectedLinearElement.hoverPointIndex !== l &&
              this.setState({
                selectedLinearElement: { ...this.state.selectedLinearElement, hoverPointIndex: l },
              }),
            ve.arePointsEqual(this.state.selectedLinearElement.segmentMidPointHoveredCoords, s) ||
              this.setState({
                selectedLinearElement: {
                  ...this.state.selectedLinearElement,
                  segmentMidPointHoveredCoords: s,
                },
              });
        } else xe(this.interactiveCanvas, De.AUTO);
    }
    updateGestureOnPointerDown(t) {
      ue.pointers.set(t.pointerId, { x: t.clientX, y: t.clientY }),
        ue.pointers.size === 2 &&
          ((ue.lastCenter = Lh(ue.pointers)),
          (ue.initialScale = this.state.zoom.value),
          (ue.initialDistance = Ph(Array.from(ue.pointers.values()))));
    }
    initialPointerDownState(t) {
      let r = Oe(t, this.state),
        n = this.scene.getSelectedElements(this.state),
        [i, a, l, s] = Gi(n),
        d = n.findIndex(We) === 0;
      return {
        origin: r,
        withCmdOrCtrl: t[Y.CTRL_OR_CMD],
        originInGrid: rf(nt(r.x, r.y, t[Y.CTRL_OR_CMD] || d ? null : this.getEffectiveGridSize())),
        scrollbars: Oh(wl, t.clientX - this.state.offsetLeft, t.clientY - this.state.offsetTop),
        lastCoords: { ...r },
        originalElements: this.scene
          .getNonDeletedElements()
          .reduce((m, c) => (m.set(c.id, eI(c)), m), new Map()),
        resize: {
          handleType: !1,
          isResizing: !1,
          offset: { x: 0, y: 0 },
          arrowDirection: "origin",
          center: { x: (l + i) / 2, y: (s + a) / 2 },
        },
        hit: {
          element: null,
          allHitElements: [],
          wasAddedToSelection: !1,
          hasBeenDuplicated: !1,
          hasHitCommonBoundingBoxOfSelectedElements:
            this.isHittingCommonBoundingBoxOfSelectedElements(r, n),
        },
        drag: { hasOccurred: !1, offset: null, origin: { ...r } },
        eventListeners: { onMove: null, onUp: null, onKeyUp: null, onKeyDown: null },
        boxSelection: { hasOccurred: !1 },
      };
    }
    handleDraggingScrollBar(t, r) {
      if (!(r.scrollbars.isOverEither && !this.state.multiElement)) return !1;
      (If = !0), (r.lastCoords.x = t.clientX), (r.lastCoords.y = t.clientY);
      let n = od((a) => {
          a.target instanceof HTMLElement && this.handlePointerMoveOverScrollbars(a, r);
        }),
        i = Pe(() => {
          (Tl = null),
            (If = !1),
            Pt(this.interactiveCanvas, this.state),
            this.setState({ cursorButton: "up" }),
            this.savePointer(t.clientX, t.clientY, "up"),
            window.removeEventListener(ee.POINTER_MOVE, n),
            window.removeEventListener(ee.POINTER_UP, i),
            n.flush();
        });
      return (
        (Tl = i),
        window.addEventListener(ee.POINTER_MOVE, n),
        window.addEventListener(ee.POINTER_UP, i),
        !0
      );
    }
    isASelectedElement(t) {
      return t != null && this.state.selectedElementIds[t.id];
    }
    isHittingCommonBoundingBoxOfSelectedElements(t, r) {
      if (r.length < 2) return !1;
      let n = Math.max(UT / this.state.zoom.value, 1),
        [i, a, l, s] = Gi(r);
      return t.x > i - n && t.x < l + n && t.y > a - n && t.y < s + n;
    }
    getCurrentItemRoundness(t) {
      return this.state.currentItemRoundness === "round"
        ? { type: vH(t) ? Zd.ADAPTIVE_RADIUS : Zd.PROPORTIONAL_RADIUS }
        : null;
    }
    maybeCacheReferenceSnapPoints(t, r, n = !1) {
      Uo({ event: t, app: this, selectedElements: r }) &&
        (n || !Wt.getReferenceSnapPoints()) &&
        Wt.setReferenceSnapPoints(
          Mw(
            this.scene.getNonDeletedElements(),
            r,
            this.state,
            this.scene.getNonDeletedElementsMap()
          )
        );
    }
    maybeCacheVisibleGaps(t, r, n = !1) {
      Uo({ event: t, app: this, selectedElements: r }) &&
        (n || !Wt.getVisibleGaps()) &&
        Wt.setVisibleGaps(
          kw(
            this.scene.getNonDeletedElements(),
            r,
            this.state,
            this.scene.getNonDeletedElementsMap()
          )
        );
    }
    onKeyDownFromPointerDownHandler(t) {
      return Pe((r) => {
        this.maybeHandleResize(t, r) || this.maybeDragNewGenericElement(t, r);
      });
    }
    onKeyUpFromPointerDownHandler(t) {
      return Pe((r) => {
        r.key === Y.ALT && r.preventDefault(),
          !this.maybeHandleResize(t, r) && this.maybeDragNewGenericElement(t, r);
      });
    }
    onPointerMoveFromPointerDownHandler(t) {
      return od((r) => {
        if (this.state.openDialog?.name === "elementLinkSelector") return;
        let n = Oe(r, this.state);
        if (
          (this.state.activeLockedId && this.setState({ activeLockedId: null }),
          this.state.selectedLinearElement &&
            this.state.selectedLinearElement.elbowed &&
            this.state.selectedLinearElement.pointerDownState.segmentMidpoint.index)
        ) {
          let [p, u] = nt(n.x, n.y, r[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()),
            f = this.state.selectedLinearElement.pointerDownState.segmentMidpoint.index;
          if (f < 0) {
            let x = ve.getSegmentMidpointHitCoords(
              { ...this.state.selectedLinearElement, segmentMidPointHoveredCoords: null },
              { x: p, y: u },
              this.state,
              this.scene.getNonDeletedElementsMap()
            );
            f = x
              ? ve.getSegmentMidPointIndex(
                  this.state.selectedLinearElement,
                  this.state,
                  x,
                  this.scene.getNonDeletedElementsMap()
                )
              : -1;
          }
          let b = ve.moveFixedSegment(this.state.selectedLinearElement, f, p, u, this.scene);
          Ko(() => {
            this.state.selectedLinearElement &&
              this.setState({
                selectedLinearElement: {
                  ...this.state.selectedLinearElement,
                  segmentMidPointHoveredCoords: b.segmentMidPointHoveredCoords,
                  pointerDownState: b.pointerDownState,
                },
              });
          });
          return;
        }
        let i = this.lastPointerMoveCoords ?? t.origin;
        if (
          ((this.lastPointerMoveCoords = n),
          t.drag.offset === null &&
            (t.drag.offset = rf(
              mG(this.scene.getSelectedElements(this.state), t.origin.x, t.origin.y)
            )),
          !(r.target instanceof HTMLElement) || this.handlePointerMoveOverScrollbars(r, t))
        )
          return;
        if (bt(this.state)) {
          this.handleEraser(r, n);
          return;
        }
        this.state.activeTool.type === "laser" && this.laserTrails.addPointToPath(n.x, n.y);
        let [l, s] = nt(n.x, n.y, r[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize());
        if (
          !t.drag.hasOccurred &&
          (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line") &&
          Oi(se(n.x, n.y), se(t.origin.x, t.origin.y)) < OT
        )
          return;
        if (
          t.resize.isResizing &&
          ((t.lastCoords.x = n.x),
          (t.lastCoords.y = n.y),
          this.maybeHandleCrop(t, r) || this.maybeHandleResize(t, r))
        )
          return !0;
        let d = this.scene.getNonDeletedElementsMap();
        if (this.state.selectedLinearElement) {
          let p = this.state.editingLinearElement || this.state.selectedLinearElement;
          if (ve.shouldAddMidpoint(this.state.selectedLinearElement, n, this.state, d)) {
            let f = ve.addMidpoint(
              this.state.selectedLinearElement,
              n,
              this,
              !r[Y.CTRL_OR_CMD],
              this.scene
            );
            if (!f) return;
            Ko(() => {
              this.state.selectedLinearElement &&
                this.setState({
                  selectedLinearElement: {
                    ...this.state.selectedLinearElement,
                    pointerDownState: f.pointerDownState,
                    selectedPointsIndices: f.selectedPointsIndices,
                    segmentMidPointHoveredCoords: null,
                  },
                }),
                this.state.editingLinearElement &&
                  this.setState({
                    editingLinearElement: {
                      ...this.state.editingLinearElement,
                      pointerDownState: f.pointerDownState,
                      selectedPointsIndices: f.selectedPointsIndices,
                      segmentMidPointHoveredCoords: null,
                    },
                  });
            });
            return;
          } else if (
            p.pointerDownState.segmentMidpoint.value !== null &&
            !p.pointerDownState.segmentMidpoint.added
          )
            return;
          let u = ve.handlePointDragging(r, this, n.x, n.y, p);
          if (u) {
            (t.lastCoords.x = n.x),
              (t.lastCoords.y = n.y),
              (t.drag.hasOccurred = !0),
              this.setState(u);
            return;
          }
        }
        let m = t.hit.allHitElements.some((p) => this.isASelectedElement(p)),
          c =
            this.state.editingLinearElement &&
            r.shiftKey &&
            this.state.editingLinearElement.elementId === t.hit.element?.id;
        if (
          (m || t.hit.hasHitCommonBoundingBoxOfSelectedElements) &&
          !c &&
          this.state.activeTool.type !== "lasso"
        ) {
          let p = this.scene.getSelectedElements(this.state);
          if (p.every((x) => x.locked)) return;
          let u = p.find((x) => Zt(x)),
            f = this.getTopLayerFrameAtSceneCoords(n),
            b = f && !u ? f : null;
          if (
            (this.state.frameToHighlight !== b &&
              Ko(() => {
                this.setState({ frameToHighlight: b });
              }),
            (t.drag.hasOccurred = !0),
            p.length > 0 &&
              !t.withCmdOrCtrl &&
              !this.state.editingTextElement &&
              this.state.activeEmbeddable?.state !== "active")
          ) {
            let x = { x: n.x - t.drag.origin.x, y: n.y - t.drag.origin.y },
              w = [...t.originalElements.values()],
              E = r.shiftKey;
            if (E) {
              let C = Math.abs(x.x),
                S = Math.abs(x.y),
                M = E && C < S,
                k = E && C > S;
              M && (x.x = 0), k && (x.y = 0);
            }
            if (this.state.croppingElementId) {
              let C = this.scene.getNonDeletedElementsMap().get(this.state.croppingElementId);
              if (C && un(C) && C.crop !== null && t.hit.element === C) {
                let S = C.crop,
                  M = hl(C) && this.imageCache.get(C.fileId)?.image;
                if (M && !(M instanceof Promise)) {
                  let k = Sz(AT(n.x - i.x, n.y - i.y), Math.max(this.state.zoom.value, 2)),
                    [A, P, N, O, U, J] = $T(C, d),
                    _ = Jg(qg(se(A, P), se(U, J), C.angle)),
                    R = Jg(qg(se(N, P), se(U, J), C.angle)),
                    X = Jg(qg(se(A, O), se(U, J), C.angle)),
                    $ = RT(DT(R, _)),
                    W = RT(DT(X, _)),
                    ce = AT(_T(k, $), _T(k, W)),
                    he = {
                      ...S,
                      x: PT(S.x - ce[0] * Math.sign(C.scale[0]), 0, M.naturalWidth - S.width),
                      y: PT(S.y - ce[1] * Math.sign(C.scale[1]), 0, M.naturalHeight - S.height),
                    };
                  this.scene.mutateElement(C, { crop: he });
                  return;
                }
              }
            }
            this.maybeCacheVisibleGaps(r, p), this.maybeCacheReferenceSnapPoints(r, p);
            let { snapOffset: y, snapLines: v } = Lw(
              w,
              x,
              this,
              r,
              this.scene.getNonDeletedElementsMap()
            );
            if (
              (this.setState({ snapLines: v }),
              this.state.editingFrame ||
                dG(t, p, x, this.scene, y, r[Y.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()),
              this.setState({ selectedElementsAreBeingDragged: !0, selectionElement: null }),
              (p.length !== 1 || !We(p[0])) &&
                this.setState({
                  suggestedBindings: cf(p, this.scene.getNonDeletedElementsMap(), this.state.zoom),
                }),
              r.altKey && !t.hit.hasBeenDuplicated)
            ) {
              t.hit.hasBeenDuplicated = !0;
              let C = this.scene.getElementsIncludingDeleted(),
                S = t.hit.element,
                M = this.scene.getSelectedElements({
                  selectedElementIds: this.state.selectedElementIds,
                  includeBoundTextElement: !0,
                  includeElementsInFrames: !0,
                });
              S && t.hit.wasAddedToSelection && !M.find((R) => R.id === S.id) && M.push(S);
              let k = new Map(M.map((R) => [R.id, R])),
                {
                  duplicatedElements: A,
                  duplicateElementsMap: P,
                  elementsWithDuplicates: N,
                  origIdToDuplicateId: O,
                } = tI({
                  type: "in-place",
                  elements: C,
                  appState: this.state,
                  randomizeSeed: !0,
                  idsOfElementsToDuplicate: k,
                  overrides: ({ duplicateElement: R, origElement: X }) => ({
                    frameId: R.frameId ?? X.frameId,
                    seed: lH(),
                  }),
                });
              A.forEach((R) => {
                t.originalElements.set(R.id, eI(R));
              });
              let U = N.map((R) => {
                  if (k.has(R.id)) {
                    let X = t.originalElements.get(R.id);
                    if (X) return pn(R, { x: X.x, y: X.y });
                  }
                  return R;
                }),
                J = this.props.onDuplicate?.(U, C),
                _ = xI(J || U, KT(A));
              Ko(() => {
                if (t.hit.element) {
                  let R = O.get(t.hit.element.id),
                    X = R && P.get(R);
                  t.hit.element = X || null;
                }
                (t.hit.allHitElements = t.hit.allHitElements.reduce((R, X) => {
                  let $ = O.get(X.id),
                    W = $ && P.get($);
                  return W && R.push(W), R;
                }, [])),
                  (t.drag.origin = Oe(r, this.state)),
                  this.setState((R) => ({ ...aG(A, this.scene.getNonDeletedElements(), R) })),
                  this.scene.replaceAllElements(_),
                  this.maybeCacheVisibleGaps(r, M, !0),
                  this.maybeCacheReferenceSnapPoints(r, M, !0);
              });
            }
            return;
          }
        }
        if (this.state.selectionElement)
          (t.lastCoords.x = n.x),
            (t.lastCoords.y = n.y),
            r.altKey
              ? Ko(() => {
                  this.setActiveTool({ type: "lasso", fromSelection: !0 }, r.shiftKey),
                    this.lassoTrail.startPath(t.origin.x, t.origin.y, r.shiftKey),
                    this.setAppState({ selectionElement: null });
                })
              : this.maybeDragNewGenericElement(t, r);
        else if (this.state.activeTool.type === "lasso")
          !r.altKey && this.state.activeTool.fromSelection
            ? (this.setActiveTool({ type: "selection" }),
              this.createGenericElementOnPointerDown("selection", t),
              (t.lastCoords.x = n.x),
              (t.lastCoords.y = n.y),
              this.maybeDragNewGenericElement(t, r),
              this.lassoTrail.endPath())
            : this.lassoTrail.addPointToPath(n.x, n.y, r.shiftKey);
        else {
          let p = this.state.newElement;
          if (!p) return;
          if (p.type === "freedraw") {
            let u = p.points,
              f = n.x - p.x,
              b = n.y - p.y,
              x = u.length > 0 && u[u.length - 1];
            if (!(x && x[0] === f && x[1] === b)) {
              let E = p.simulatePressure ? p.pressures : [...p.pressures, r.pressure];
              this.scene.mutateElement(
                p,
                { points: [...u, se(f, b)], pressures: E },
                { informMutation: !1, isDragging: !1 }
              ),
                this.setState({ newElement: p });
            }
          } else if ($t(p)) {
            t.drag.hasOccurred = !0;
            let u = p.points,
              f = l - p.x,
              b = s - p.y;
            Qg(r) && u.length === 2 && ({ width: f, height: b } = nI(p.x, p.y, n.x, n.y)),
              u.length === 1
                ? this.scene.mutateElement(
                    p,
                    { points: [...u, se(f, b)] },
                    { informMutation: !1, isDragging: !1 }
                  )
                : (u.length === 2 || (u.length > 1 && We(p))) &&
                  this.scene.mutateElement(
                    p,
                    { points: [...u.slice(0, -1), se(f, b)] },
                    { isDragging: !0, informMutation: !1 }
                  ),
              this.setState({ newElement: p }),
              mf(p, !1) &&
                this.setState({
                  suggestedBindings: ZT(
                    p,
                    [n],
                    this.scene,
                    this.state.zoom,
                    this.state.startBoundElement
                  ),
                });
          } else
            (t.lastCoords.x = n.x),
              (t.lastCoords.y = n.y),
              this.maybeDragNewGenericElement(t, r, !1);
        }
        if (this.state.activeTool.type === "selection") {
          t.boxSelection.hasOccurred = !0;
          let p = this.scene.getNonDeletedElements();
          if (this.state.editingLinearElement)
            ve.handleBoxSelection(
              r,
              this.state,
              this.setState.bind(this),
              this.scene.getNonDeletedElementsMap()
            );
          else {
            let u = !0;
            !r.shiftKey &&
              Ee(p, this.state) &&
              (t.withCmdOrCtrl && t.hit.element
                ? this.setState((b) =>
                    uo(
                      { ...b, selectedElementIds: { [t.hit.element.id]: !0 } },
                      this.scene.getNonDeletedElements(),
                      b,
                      this
                    )
                  )
                : (u = !1));
            let f = this.state.selectionElement
              ? jf(p, this.state.selectionElement, this.scene.getNonDeletedElementsMap(), !1)
              : [];
            this.setState((b) => {
              let x = {
                ...(u && b.selectedElementIds),
                ...f.reduce((w, E) => ((w[E.id] = !0), w), {}),
              };
              return (
                t.hit.element &&
                  (f.length ? delete x[t.hit.element.id] : (x[t.hit.element.id] = !0)),
                (b = u ? b : { ...b, selectedGroupIds: {}, editingGroupId: null }),
                {
                  ...uo(
                    { editingGroupId: b.editingGroupId, selectedElementIds: x },
                    this.scene.getNonDeletedElements(),
                    b,
                    this
                  ),
                  selectedLinearElement:
                    f.length === 1 && $t(f[0])
                      ? new ve(f[0], this.scene.getNonDeletedElementsMap())
                      : null,
                  showHyperlinkPopup: f.length === 1 && (f[0].link || Nr(f[0])) ? "info" : !1,
                }
              );
            });
          }
        }
      });
    }
    handlePointerMoveOverScrollbars(t, r) {
      if (r.scrollbars.isOverHorizontal) {
        let n = t.clientX,
          i = n - r.lastCoords.x;
        return (
          this.translateCanvas({
            scrollX:
              this.state.scrollX -
              (i * (wl.horizontal?.deltaMultiplier || 1)) / this.state.zoom.value,
          }),
          (r.lastCoords.x = n),
          !0
        );
      }
      if (r.scrollbars.isOverVertical) {
        let n = t.clientY,
          i = n - r.lastCoords.y;
        return (
          this.translateCanvas({
            scrollY:
              this.state.scrollY -
              (i * (wl.vertical?.deltaMultiplier || 1)) / this.state.zoom.value,
          }),
          (r.lastCoords.y = n),
          !0
        );
      }
      return !1;
    }
    onPointerUpFromPointerDownHandler(t) {
      return Pe((r) => {
        this.removePointer(r), t.eventListeners.onMove && t.eventListeners.onMove.flush();
        let {
          newElement: n,
          resizingElement: i,
          croppingElementId: a,
          multiElement: l,
          activeTool: s,
          isResizing: d,
          isRotating: m,
          isCropping: c,
        } = this.state;
        this.setState((E) => ({
          isResizing: !1,
          isRotating: !1,
          isCropping: !1,
          resizingElement: null,
          selectionElement: null,
          frameToHighlight: null,
          elementsToHighlight: null,
          cursorButton: "up",
          snapLines: ul(E.snapLines, []),
          originSnapOffset: null,
        })),
          this.lassoTrail.endPath(),
          (this.lastPointerMoveCoords = null),
          Wt.setReferenceSnapPoints(null),
          Wt.setVisibleGaps(null),
          this.savePointer(r.clientX, r.clientY, "up");
        let p = t.hit.allHitElements,
          u = Oe({ clientX: r.clientX, clientY: r.clientY }, this.state);
        if (
          this.state.activeTool.type === "selection" &&
          !t.boxSelection.hasOccurred &&
          !t.resize.isResizing &&
          !p.some((E) => this.state.selectedElementIds[E.id])
        ) {
          let E = this.getElementAtPosition(u.x, u.y, { includeLockedElements: !0 });
          this.store.scheduleCapture(),
            E?.locked
              ? this.setState({
                  activeLockedId: E.groupIds.length > 0 ? E.groupIds.at(-1) || "" : E.id,
                })
              : this.setState({ activeLockedId: null });
        } else this.setState({ activeLockedId: null });
        this.setState({ selectedElementsAreBeingDragged: !1 });
        let f = this.scene.getNonDeletedElementsMap();
        if (t.drag.hasOccurred && t.hit?.element?.id) {
          let E = f.get(t.hit.element.id);
          IH(E) &&
            E.boundElements
              ?.filter((y) => y.type === "arrow")
              .map((y) => f.get(y.id))
              .filter((y) => We(y))
              .forEach((y) => {
                y && this.scene.mutateElement(y, {});
              });
        }
        if (this.state.editingLinearElement)
          if (
            !t.boxSelection.hasOccurred &&
            t.hit?.element?.id !== this.state.editingLinearElement.elementId
          )
            this.actionManager.executeAction(At);
          else {
            let E = ve.handlePointerUp(r, this.state.editingLinearElement, this.state, this.scene);
            E !== this.state.editingLinearElement &&
              this.setState({ editingLinearElement: E, suggestedBindings: [] });
          }
        else if (this.state.selectedLinearElement) {
          if (this.state.selectedLinearElement.elbowed) {
            let E = ve.getElement(
              this.state.selectedLinearElement.elementId,
              this.scene.getNonDeletedElementsMap()
            );
            E && this.scene.mutateElement(E, {});
          }
          t.hit?.element?.id !== this.state.selectedLinearElement.elementId
            ? this.scene.getSelectedElements(this.state).length > 1 &&
              this.setState({ selectedLinearElement: null })
            : this.state.selectedLinearElement.isDragging &&
              this.actionManager.executeAction(At, "ui", { event: r, sceneCoords: u });
        }
        if (
          (this.missingPointerEventCleanupEmitter.clear(),
          window.removeEventListener(ee.POINTER_MOVE, t.eventListeners.onMove),
          window.removeEventListener(ee.POINTER_UP, t.eventListeners.onUp),
          window.removeEventListener(ee.KEYDOWN, t.eventListeners.onKeyDown),
          window.removeEventListener(ee.KEYUP, t.eventListeners.onKeyUp),
          this.props?.onPointerUp?.(s, t),
          this.onPointerUpEmitter.trigger(this.state.activeTool, t, r),
          n?.type === "freedraw")
        ) {
          let E = Oe(r, this.state),
            y = n.points,
            v = E.x - n.x,
            C = E.y - n.y;
          v === y[0][0] && C === y[0][1] && ((C += 1e-4), (v += 1e-4));
          let S = n.simulatePressure ? [] : [...n.pressures, r.pressure];
          this.scene.mutateElement(n, {
            points: [...y, se(v, C)],
            pressures: S,
            lastCommittedPoint: se(v, C),
          }),
            this.actionManager.executeAction(At);
          return;
        }
        if ($t(n)) {
          n.points.length > 1 && this.store.scheduleCapture();
          let E = Oe(r, this.state);
          !t.drag.hasOccurred && n && !l
            ? (this.scene.mutateElement(
                n,
                { points: [...n.points, se(E.x - n.x, E.y - n.y)] },
                { informMutation: !1, isDragging: !1 }
              ),
              this.setState({ multiElement: n, newElement: n }))
            : t.drag.hasOccurred &&
              !l &&
              (lf(this.state) &&
                mf(n, !1) &&
                this.actionManager.executeAction(At, "ui", { event: r, sceneCoords: u }),
              this.setState({ suggestedBindings: [], startBoundElement: null }),
              s.locked
                ? this.setState((y) => ({ newElement: null }))
                : (Ht(this.interactiveCanvas),
                  this.setState((y) => ({
                    newElement: null,
                    activeTool: Zo(this.state, { type: "selection" }),
                    selectedElementIds: ye({ ...y.selectedElementIds, [n.id]: !0 }, y),
                    selectedLinearElement: new ve(n, this.scene.getNonDeletedElementsMap()),
                  }))),
              this.scene.triggerUpdate());
          return;
        }
        if (po(n)) {
          let E = QH(of({ fontSize: n.fontSize, fontFamily: n.fontFamily }), n.lineHeight);
          n.width < E && this.scene.mutateElement(n, { autoResize: !0 }),
            this.resetCursor(),
            this.handleTextWysiwyg(n, { isExistingElement: !0 });
        }
        if (s.type !== "selection" && n && aI(n)) {
          this.updateScene({
            elements: this.scene.getElementsIncludingDeleted().filter((E) => E.id !== n.id),
            appState: { newElement: null },
            captureUpdate: dt.NEVER,
          });
          return;
        }
        if (Zt(n)) {
          let E = NH(
            this.scene.getElementsIncludingDeleted(),
            n,
            this.scene.getNonDeletedElementsMap()
          );
          this.scene.replaceAllElements(
            xf(this.scene.getElementsMapIncludingDeleted(), E, n, this.state)
          );
        }
        if (
          (n &&
            (this.scene.mutateElement(n, CH(n), { informMutation: !1, isDragging: !1 }),
            this.scene.triggerUpdate()),
          t.drag.hasOccurred)
        ) {
          let E = Oe(r, this.state);
          if (this.state.selectedLinearElement && this.state.selectedLinearElement.isDragging) {
            let y = this.scene.getElement(this.state.selectedLinearElement.elementId);
            if (y?.frameId) {
              let v = yf(y, f);
              v &&
                y &&
                (BH(y, v, this.scene.getNonDeletedElementsMap()) ||
                  (this.scene.mutateElement(y, { groupIds: [] }),
                  RH([y], this.scene.getNonDeletedElementsMap()),
                  this.scene.triggerUpdate()));
            }
          } else {
            let y = this.getTopLayerFrameAtSceneCoords(E),
              v = this.scene.getSelectedElements(this.state),
              C = this.scene.getElementsMapIncludingDeleted(),
              S = (M) => {
                if (M.length > 0) {
                  for (let k of M) {
                    let A = k.groupIds.indexOf(this.state.editingGroupId);
                    this.scene.mutateElement(
                      k,
                      { groupIds: k.groupIds.slice(0, A) },
                      { informMutation: !1, isDragging: !1 }
                    );
                  }
                  C.forEach((k) => {
                    k.groupIds.length &&
                      xl(C, k.groupIds[k.groupIds.length - 1]).length < 2 &&
                      this.scene.mutateElement(
                        k,
                        { groupIds: [] },
                        { informMutation: !1, isDragging: !1 }
                      );
                  }),
                    this.setState({ editingGroupId: null });
                }
              };
            if (y && !this.state.selectedElementIds[y.id]) {
              let M = v.filter((k) => k.frameId !== y.id && hI(k, C, this.state));
              this.state.editingGroupId && S(M), (C = xf(C, M, y, this.state));
            } else if (!y && this.state.editingGroupId) {
              let M = v.filter((k) => k.frameId && !hI(k, C, this.state));
              S(M);
            }
            (C = uI(C, this.state, this)), this.scene.replaceAllElements(C);
          }
        }
        if (
          (i && this.store.scheduleCapture(),
          i &&
            aI(i) &&
            this.updateScene({
              elements: this.scene.getElementsIncludingDeleted().filter((E) => E.id !== i.id),
              captureUpdate: dt.NEVER,
            }),
          t.resize.isResizing)
        ) {
          let E = uI(this.scene.getElementsIncludingDeleted(), this.state, this),
            y = this.scene.getSelectedElements(this.state).filter((v) => Zt(v));
          for (let v of y)
            E = _H(E, Ef(this.scene.getElementsIncludingDeleted(), v, this.state, f), v, this);
          this.scene.replaceAllElements(E);
        }
        let b = t.hit.element;
        this.state.selectedLinearElement?.elementId !== b?.id &&
          $t(b) &&
          this.scene.getSelectedElements(this.state).length === 1 &&
          this.setState({
            selectedLinearElement: new ve(b, this.scene.getNonDeletedElementsMap()),
          }),
          (!a || (a && ((!b && !c) || (b && b.id !== a)))) && this.finishImageCropping();
        let x = this.lastPointerDownEvent,
          w = this.lastPointerUpEvent || this.lastPointerMoveEvent;
        if (bt(this.state) && x && w) {
          if (
            (this.eraserTrail.endPath(),
            Oi(se(x.clientX, x.clientY), se(w.clientX, w.clientY)) === 0)
          ) {
            let y = Oe({ clientX: w.clientX, clientY: w.clientY }, this.state);
            this.getElementsAtPosition(y.x, y.y).forEach((C) =>
              this.elementsPendingErasure.add(C.id)
            );
          }
          this.eraseElements();
          return;
        } else this.elementsPendingErasure.size && this.restoreReadyToEraseElements();
        if (
          (b &&
            !t.drag.hasOccurred &&
            !t.hit.wasAddedToSelection &&
            (!this.state.editingLinearElement || !t.boxSelection.hasOccurred) &&
            this.state.activeTool.type !== "lasso" &&
            (r.shiftKey && !this.state.editingLinearElement
              ? this.state.selectedElementIds[b.id]
                ? nG(this.state, b)
                  ? this.setState((E) => {
                      let y = { ...E.selectedElementIds };
                      for (let v of b.groupIds.flatMap((C) =>
                        xl(this.scene.getNonDeletedElements(), C)
                      ))
                        delete y[v.id];
                      return {
                        selectedGroupIds: {
                          ...E.selectedElementIds,
                          ...b.groupIds
                            .map((v) => ({ [v]: !1 }))
                            .reduce((v, C) => ({ ...v, ...C }), {}),
                        },
                        selectedElementIds: ye(y, E),
                      };
                    })
                  : this.state.selectedLinearElement?.isDragging ||
                    this.setState((E) => {
                      let y = { ...E.selectedElementIds };
                      delete y[b.id];
                      let v = Z(this.scene.getNonDeletedElements(), { selectedElementIds: y });
                      return {
                        ...uo(
                          { editingGroupId: E.editingGroupId, selectedElementIds: y },
                          this.scene.getNonDeletedElements(),
                          E,
                          this
                        ),
                        selectedLinearElement:
                          v.length === 1 && $t(v[0])
                            ? new ve(v[0], this.scene.getNonDeletedElementsMap())
                            : E.selectedLinearElement,
                      };
                    })
                : b.frameId && this.state.selectedElementIds[b.frameId]
                ? this.setState((E) => {
                    let y = { ...E.selectedElementIds, [b.id]: !0 };
                    return (
                      delete y[b.frameId],
                      (this.scene.getElement(b.frameId)?.groupIds ?? [])
                        .flatMap((v) => xl(this.scene.getNonDeletedElements(), v))
                        .forEach((v) => {
                          delete y[v.id];
                        }),
                      {
                        ...uo(
                          { editingGroupId: E.editingGroupId, selectedElementIds: y },
                          this.scene.getNonDeletedElements(),
                          E,
                          this
                        ),
                        showHyperlinkPopup: b.link || Nr(b) ? "info" : !1,
                      }
                    );
                  })
                : this.setState((E) => ({
                    selectedElementIds: ye({ ...E.selectedElementIds, [b.id]: !0 }, E),
                  }))
              : this.setState((E) => ({
                  ...uo(
                    { editingGroupId: E.editingGroupId, selectedElementIds: { [b.id]: !0 } },
                    this.scene.getNonDeletedElements(),
                    E,
                    this
                  ),
                  selectedLinearElement:
                    $t(b) && E.selectedLinearElement?.elementId !== b.id
                      ? new ve(b, this.scene.getNonDeletedElementsMap())
                      : E.selectedLinearElement,
                }))),
          this.state.activeTool.type !== "lasso" &&
            !(b && We(b)) &&
            !t.drag.hasOccurred &&
            !this.state.isResizing &&
            ((b &&
              GH(
                {
                  point: se(t.origin.x, t.origin.y),
                  element: b,
                  elementsMap: f,
                  threshold: this.getElementHitThreshold(b),
                  frameNameBound: Zt(b) ? this.frameNameBoundsCache.get(b) : null,
                },
                f
              )) ||
              (!b && t.hit.hasHitCommonBoundingBoxOfSelectedElements)))
        ) {
          this.state.editingLinearElement
            ? this.setState({ editingLinearElement: null })
            : this.setState({
                selectedElementIds: ye({}, this.state),
                selectedGroupIds: {},
                editingGroupId: null,
                activeEmbeddable: null,
              }),
            xe(this.interactiveCanvas, De.AUTO);
          return;
        }
        if (
          (!s.locked &&
            s.type !== "freedraw" &&
            n &&
            this.setState((E) => ({
              selectedElementIds: ye({ ...E.selectedElementIds, [n.id]: !0 }, E),
              showHyperlinkPopup: Nr(n) && !n.link ? "editor" : E.showHyperlinkPopup,
            })),
          (s.type !== "selection" ||
            Ee(this.scene.getNonDeletedElements(), this.state) ||
            !aH(this.state.previousSelectedElementIds, this.state.selectedElementIds)) &&
            this.store.scheduleCapture(),
          (t.drag.hasOccurred && !this.state.selectedLinearElement) || d || m || c)
        ) {
          let E = this.scene.getSelectedElements(this.state).filter($t);
          jT(
            E,
            lf(this.state),
            this.state.selectedLinearElement?.selectedPointsIndices ?? [],
            this.scene,
            this.state.zoom
          );
        }
        if (s.type === "laser") {
          this.laserTrails.endPath();
          return;
        }
        !s.locked &&
        s.type !== "freedraw" &&
        (s.type !== "lasso" || (s.type === "lasso" && s.fromSelection))
          ? (Ht(this.interactiveCanvas),
            this.setState({
              newElement: null,
              suggestedBindings: [],
              activeTool: Zo(this.state, { type: "selection" }),
            }))
          : this.setState({ newElement: null, suggestedBindings: [] }),
          b &&
            this.lastPointerUpEvent &&
            this.lastPointerDownEvent &&
            this.lastPointerUpEvent.timeStamp - this.lastPointerDownEvent.timeStamp < 300 &&
            ue.pointers.size <= 1 &&
            gl(b) &&
            this.isIframeLikeElementCenter(b, this.lastPointerUpEvent, t.origin.x, t.origin.y) &&
            this.handleEmbeddableCenterClick(b);
      });
    }
    clearSelection(t) {
      this.setState((r) => ({
        selectedElementIds: ye({}, r),
        activeEmbeddable: null,
        selectedGroupIds: {},
        editingGroupId:
          r.editingGroupId && t != null && bI(t, r.editingGroupId) ? r.editingGroupId : null,
      })),
        this.setState({
          selectedElementIds: ye({}, this.state),
          activeEmbeddable: null,
          previousSelectedElementIds: this.state.selectedElementIds,
        });
    }
    getTextWysiwygSnappedToCenterPosition(t, r, n, i) {
      if (i) {
        let a = i.x + i.width / 2,
          l = i.y + i.height / 2,
          s = bf(i, n, this.scene.getNonDeletedElementsMap());
        if ((s && ((a = s.x), (l = s.y)), Math.hypot(t - a, r - l) < Hz)) {
          let { x: c, y: p } = qd({ sceneX: a, sceneY: l }, n);
          return { viewportX: c, viewportY: p, elementCenterX: a, elementCenterY: l };
        }
      }
    }
    getCanvasOffsets() {
      if (this.excalidrawContainerRef?.current) {
        let t = this.excalidrawContainerRef.current,
          { left: r, top: n } = t.getBoundingClientRect();
        return { offsetLeft: r, offsetTop: n };
      }
      return { offsetLeft: 0, offsetTop: 0 };
    }
    async updateLanguage() {
      let t = Tn.find((r) => r.code === this.props.langCode) || fo;
      await Ul(t), this.setAppState({});
    }
  },
  gG = () => {
    (Sf() || kI()) &&
      ((window.h = window.h || {}),
      Object.defineProperties(window.h, {
        elements: {
          configurable: !0,
          get() {
            return this.app?.scene.getElementsIncludingDeleted();
          },
          set(e) {
            return this.app?.scene.replaceAllElements(MI(e));
          },
        },
        scene: {
          configurable: !0,
          get() {
            return this.app?.scene;
          },
        },
      }));
  };
gG();
var DI = kf;
import { useEffect as bG, useState as xG } from "react";
import { jsx as EG } from "react/jsx-runtime";
var _I = (e) => {
  let [o, t] = xG(!0);
  return (
    bG(() => {
      let r = async () => {
          await Ul(n), t(!1);
        },
        n = Tn.find((i) => i.code === e.langCode) || fo;
      r();
    }, [e.langCode]),
    o ? EG(ad, { theme: e.theme }) : e.children
  );
};
import yG from "clsx";
import { jsx as RI } from "react/jsx-runtime";
var NI = ({ children: e }) => {
    let { FooterCenterTunnel: o } = Ie(),
      t = ge();
    return RI(o.In, {
      children: RI("div", {
        className: yG("footer-center zen-mode-transition", {
          "layer-ui__wrapper__footer-left--transition-bottom": t.zenModeEnabled,
        }),
        children: e,
      }),
    });
  },
  wG = NI;
NI.displayName = "FooterCenter";
import vG from "clsx";
import { jsx as IG, jsxs as CG } from "react/jsx-runtime";
var BI = ({ isCollaborating: e, onSelect: o, ...t }) => {
    let r = ge(),
      n = r.width < 830;
    return CG(_t, {
      ...t,
      className: vG("collab-button", { active: e }),
      type: "button",
      onSelect: o,
      style: { position: "relative", width: n ? void 0 : "auto" },
      title: g("labels.liveCollaboration"),
      children: [
        n ? Z1 : g("labels.share"),
        r.collaborators.size > 0 &&
          IG("div", { className: "CollabButton-collaborators", children: r.collaborators.size }),
      ],
    });
  },
  TG = BI;
BI.displayName = "LiveCollaborationTrigger";
import { jsx as Or, jsxs as OI } from "react/jsx-runtime";
var SG = () =>
    Or("svg", {
      viewBox: "0 0 40 40",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: "ExcalidrawLogo-icon",
      children: Or("path", {
        d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
        fill: "currentColor",
      }),
    }),
  kG = () =>
    OI("svg", {
      viewBox: "0 0 450 55",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      className: "ExcalidrawLogo-text",
      children: [
        Or("path", {
          d: "M429.27 96.74c2.47-1.39 4.78-3.02 6.83-4.95 1.43-1.35 2.73-2.86 3.81-4.51-.66.9-1.4 1.77-2.23 2.59-2.91 2.84-5.72 5.09-8.42 6.87h.01ZM343.6 69.36c.33 3.13.58 6.27.79 9.4.09 1.37.18 2.75.25 4.12-.12-4.46-.27-8.93-.5-13.39-.11-2.08-.24-4.16-.4-6.24-.06 1.79-.11 3.85-.13 6.11h-.01ZM378.47 98.34c.01-.37.07-1.13.01-6.51-.11 1.9-.22 3.81-.31 5.71-.07 1.42-.22 2.91-.16 4.35.39.03.78.07 1.17.1-.92-.85-.76-2.01-.72-3.66l.01.01ZM344.09 86.12c-.09-2.41-.22-4.83-.39-7.24v12.21c.15-.05.32-.09.47-.14.05-1.61-.03-3.23-.09-4.83h.01ZM440.69 66.79c-.22-.34-.45-.67-.69-.99-3.71-4.87-9.91-7.14-15.65-8.55-1.05-.26-2.12-.49-3.18-.71 2.29.59 4.48 1.26 6.64 2.02 7.19 2.54 10.57 5.41 12.88 8.23ZM305.09 72.46l1.2 3.6c.84 2.53 1.67 5.06 2.46 7.61.24.78.5 1.57.73 2.36.22-.04.44-.08.67-.12a776.9 776.9 0 0 1-5.01-13.57c-.02.04-.03.09-.05.13v-.01ZM345.49 90.25v.31c1.48-.42 3.05-.83 4.66-1.2-1.56.25-3.12.52-4.66.89ZM371.02 90.22c0-.57-.04-1.14-.11-1.71-.06-.02-.12-.04-.19-.05-.21-.05-.43-.08-.65-.11.42.16.74.88.95 1.87ZM398.93 54.23c-.13 0-.27-.01-.4-.02l.03.4c.11-.15.23-.27.37-.38ZM401.57 62.28v-.15c-1.22-.24-2.86-.61-3.23-1.25-.09-.15-.18-.51-.27-.98-.09.37-.2.73-.33 1.09 1.24.56 2.52.98 3.83 1.29ZM421.73 88.68c-2.97 1.65-6.28 3.12-9.69 3.68v.18c4.72-.14 11.63-3.85 16.33-8.38-2.04 1.75-4.33 3.24-6.63 4.53l-.01-.01ZM411.28 80.92c-.05-1.2-.09-2.4-.15-3.6-.21 5.66-.46 11.38-.47 14.51.24-.02.48-.04.71-.07.15-3.61.05-7.23-.09-10.83v-.01Z",
          transform: "translate(-144.023 -51.76)",
        }),
        Or("path", {
          d: "M425.38 67.41c-3.5-1.45-7.19-2.57-14.06-3.62.09 1.97.06 4.88-.03 8.12.03.04.06.09.06.15.19 1.36.28 2.73.37 4.1.25 3.77.39 7.55.41 11.33 0 1.38-.01 2.76-.07 4.13 1.4-.25 2.78-.65 4.12-1.15 4.07-1.5 7.94-3.78 11.28-6.54 2.33-1.92 5.13-4.49 5.88-7.58.63-3.53-2.45-6.68-7.97-8.96l.01.02ZM411.35 92.53v-.06l-.34.03c.11.01.22.03.34.03ZM314.26 64.06c-.23-.59-.47-1.17-.7-1.75.57 1.62 1.11 3.25 1.6 4.9l.15.54 2.35 6.05c.32.82.66 1.64.98 2.46-1.38-4.1-2.83-8.17-4.39-12.2h.01ZM156.82 103.07c-.18.13-.38.23-.58.33 1.32-.03 2.66-.2 3.93-.34.86-.09 1.72-.22 2.58-.33-2.12.1-4.12.17-5.94.34h.01ZM210.14 68.88s.03.04.05.07c.18-.31.39-.64.58-.96-.21.3-.42.6-.64.89h.01ZM201.65 82.8c-.5.77-1.02 1.56-1.49 2.37 1.11-1.55 2.21-3.1 3.2-4.59-.23.23-.49.51-.75.79-.32.47-.65.95-.96 1.43ZM194.03 98.66c-.33-.4-.65-.84-1.05-1.17-.24-.2-.07-.49.17-.56-.23-.26-.42-.5-.63-.75 1.51-2.55 3.93-5.87 6.4-9.28-.17-.08-.29-.28-.2-.49.04-.09.09-.17.13-.26-1.21 1.78-2.42 3.55-3.61 5.33-.87 1.31-1.74 2.64-2.54 4-.29.5-.63 1.04-.87 1.61.81.65 1.63 1.27 2.47 1.88-.09-.11-.18-.21-.27-.32v.01ZM307.79 82.93c-1-3.17-2.05-6.32-3.1-9.48-1.62 4.08-3.69 9.17-6.16 15.19 3.32-1.04 6.77-1.87 10.27-2.5-.32-1.08-.67-2.15-1.01-3.21ZM149.5 80.7c.05-1.71.04-3.43 0-5.14-.1 2.26-.16 4.51-.22 6.77-.02.73-.03 1.46-.04 2.19.14-1.27.2-2.55.24-3.82h.02ZM228.98 98.3c.39 1.25.91 3.03.94 3.91.06-.03.12-.07.17-.1.08-1.29-.55-2.65-1.11-3.81ZM307.72 53.36c.81.5 1.53 1.04 2.07 1.49-.38-.8-.78-1.58-1.21-2.35-.17.03-.34.06-.51.11-.43.12-.86.26-1.29.41.35-.01.53.1.94.34ZM283.69 96.14c3.91-7.25 6.89-13.35 8.88-18.15l1.1-2.66c-1.27 2.64-2.56 5.27-3.83 7.9-1.53 3.15-3.06 6.31-4.58 9.47-.87 1.81-1.76 3.62-2.54 5.47.04.02.07.04.11.07.05.05.1.09.15.14.05-.73.27-1.48.71-2.24ZM289.92 103.23s-.04.01-.05.03c0-.02.04-.03.05-.04.05-.05.11-.1.16-.15l.21-.21c-.55 0-1.5-.27-2.55-.72.4.26.8.51 1.22.74.24.13.48.26.73.37.05.02.1.03.14.05a.27.27 0 0 1 .08-.07h.01ZM269.23 68.49c-.39-.19-.82-.48-1.33-.87-3.06-1.56-6.31-2.78-9.36-2.35-3.5.49-5.7 1.11-7.74 2.44 5.71-2.6 12.82-2.07 18.44.79l-.01-.01ZM177.87 53.69l1.06.03c-.96-.22-2-.25-2.89-.3-4.95-.26-9.99.33-14.86 1.19-2.44.43-4.88.95-7.28 1.59 9.09-1.76 15.69-2.77 23.97-2.51ZM219.85 55.51c-.18.12-.36.27-.56.45-.45.53-.86 1.11-1.26 1.66-1.91 2.61-3.71 5.31-5.57 7.95l-.12.18 8.05-10.11c-.18-.05-.36-.1-.55-.13h.01ZM510.71 54.1c.12-.15.29-.3.53-.45.69-.4 3.72-.63 5.87-.74-.36-.02-.73-.04-1.09-.05-1.84-.03-3.67.09-5.49.35.05.3.12.59.18.88v.01ZM510.76 86.02c1.37-3.07 2.49-6.27 3.57-9.46.55-1.64 1.12-3.3 1.6-4.97-1.59 4.01-3.67 9.14-6.2 15.3.24-.08.5-.14.74-.22.1-.22.19-.44.29-.65ZM566.95 75.76c.11-.02.23.03.31.11-.05-.13-.09-.26-.14-.39-.05.09-.11.18-.17.28ZM511.33 86.41c3.08-.89 6.24-1.62 9.46-2.14-1.51-3.98-2.98-7.96-4.39-11.87-.05.15-.09.31-.14.46-1.02 3.32-2.15 6.61-3.39 9.85-.48 1.25-.98 2.49-1.53 3.7h-.01ZM578.24 74.45c.11-.44.23-.87.35-1.31-.31.7-.64 1.39-.97 2.08.09.21.19.4.28.61.12-.46.23-.92.35-1.38h-.01ZM520.62 53.11c-.09 0-.18-.01-.28-.02.38.34.29 1.08.93 2.53l6.65 17.15c2.2 5.68 4.69 11.36 7.41 16.87l1.06 2.17c-2.95-7.05-5.92-14.08-8.87-21.13-1.58-3.79-3.16-7.59-4.7-11.4-.78-1.92-1.73-3.89-2.25-5.91-.03-.1 0-.19.04-.26h.01ZM578.78 77.87c1.45-5.77 3.07-10.43 3.58-13.36.05-.34.16-.88.31-1.55-.67 1.79-1.37 3.56-2.08 5.33-.12.43-.23.86-.35 1.29-.65 2.43-1.29 4.86-1.9 7.3.14.33.29.65.43 1l.01-.01ZM545.3 94.66c.02-.44.03-.83.05-1.12.02-1.01.05-2.02.11-3.02.03-6.66-.46-14.33-1.46-22.8-.13-.42-.27-1.24-.56-2.89 0-.02 0-.04-.01-.06.62 6.61.95 13.25 1.32 19.87.17 3.08.33 6.16.52 9.23.02.25.03.52.04.78l-.01.01ZM580.77 102.81c.13.2.27.38.37.49.27-.11.53-.22.8-.32-.43.09-.82.05-1.17-.16v-.01ZM530.48 104.07h.33c-.36-.13-.71-.32-1.04-.56.14.24.3.47.45.7.06-.08.14-.13.26-.13v-.01ZM542.63 58.82c.06.23.11.47.15.71.14-.33.36-.62.7-.86-.28.05-.57.11-.85.15ZM583.81 57.87c.15-.7.29-1.41.42-2.11-.14.45-.28.9-.42 1.34-.46 1.44-.89 2.89-1.31 4.34.44-1.19.88-2.37 1.31-3.57ZM523.62 91.48c-4.66 1.17-9.05 2.89-14.02 5.27 4.65-1.84 9.48-3.29 14.28-4.63-.09-.22-.17-.41-.26-.64ZM460.64 78.3c-.04-2.9-.11-5.81-.28-8.71-.1-1.68-.17-3.43-.5-5.09-.07.02-.14.03-.2.05.3 6.54.45 12.17.51 17.12.17-.07.34-.14.51-.2 0-1.06-.01-2.11-.03-3.17h-.01ZM470.63 63.24c-3.38-.26-6.81.32-10.1 1.1.41 2.01.47 4.14.57 6.18.18 3.55.25 7.11.27 10.67 3.31-1.38 6.5-3.12 9.3-5.35 1.96-1.56 3.86-3.41 5.02-5.66.73-1.41 1.19-3.22.26-4.65-1.09-1.7-3.46-2.14-5.32-2.29ZM460.29 63.68c1-.24 2.01-.46 3.04-.65-1.15.16-2.37.38-3.71.69v.13c.07-.02.15-.04.22-.05.11-.13.3-.18.45-.11v-.01ZM457.24 100.96c.43-.03.86-.07 1.29-.11.14-.49.27-.99.38-1.49-.44.7-1 1.23-1.67 1.6ZM482.88 104.98c-.18.23-.36.38-.55.47.14.09.27.19.4.28a70.76 70.76 0 0 0 4.37-4.63c.76-.89 1.52-1.81 2.19-2.77-.3-.27-.61-.53-.92-.79-.07 1.94-4.62 6.32-5.49 7.45v-.01Z",
          transform: "translate(-144.023 -51.76)",
        }),
        Or("path", {
          d: "M474.36 63.31c-.4-.16-.84-.27-1.29-.37 1.56.42 3.08 1.22 3.76 2.74.62 1.4.32 2.95-.28 4.32.7-1.22.94-2.34.74-3.47-.24-1.33-1.19-2.54-2.93-3.21v-.01ZM477.34 89.18c-1.2-.81-2.4-1.62-3.6-2.42-.14.1-.26.19-.4.29 1.4.67 2.73 1.39 4 2.13ZM465.88 93.85c.37.25.74.5 1.1.75.46.32.92.65 1.38.97-1.57-1.2-2.01-1.61-2.49-1.72h.01ZM574.92 90.06c-2.28-5.21-4.93-11.13-5.67-12.26-.1-.15-1.57-3.01-1.63-3.08 0 0-.01.02-.02.02.4 1.37 1.09 2.69 1.65 3.99 2.14 4.95 4.36 9.86 6.67 14.73.6 1.26 1.21 2.52 1.83 3.78-.75-2.01-1.64-4.45-2.83-7.18ZM448.73 65.29c.1.2.22.38.34.57.22-.02.43-.06.65-.08v-.08c-.14-.05-.25 0-.99-.41ZM460.16 94.81c-.02.31-.06.59-.1.89-.03 1.71-.33 3.43-.79 5.07.15-.02.3-.03.45-.05.01-.04.02-.08.03-.11.09-.34.15-.69.2-1.03.17-1.07.25-2.16.33-3.24.05-.69.08-1.39.12-2.08-.27.1-.27.26-.24.57v-.02Z",
          transform: "translate(-144.023 -51.76)",
        }),
        Or("path", {
          d: "m328.67 98.12-3.22-6.58c-1.29-2.63-2.53-5.29-3.72-7.97-.25-.85-.52-1.69-.79-2.53-.81-2.57-1.67-5.12-2.55-7.67-1.92-5.53-3.9-11.08-6.32-16.41-.72-1.58-1.46-3.44-2.63-4.79-.03-.17-.16-.29-.34-.36a.282.282 0 0 0-.23-.04c-.06-.01-.12 0-.18.01-.74.06-1.5.38-2.19.61-2.22.77-4.4 1.64-6.63 2.38-.03-.08-.06-.16-.09-.25-.15-.42-.82-.24-.67.19.03.09.07.19.1.28l-.18.06c-.36.11-.28.6 0 .68.18 1.18.63 2.36.98 3.49.03.09.06.17.08.26-.08.23-.17.46-.24.64-.37.98-.79 1.94-1.21 2.9-1.27 2.89-2.62 5.75-3.98 8.6-3.18 6.67-6.44 13.31-9.64 19.97-1.08 2.25-2.2 4.5-3.15 6.81-.13.32.24.5.5.37 1.34 1.33 2.84 2.5 4.4 3.57.65.44 1.31.87 2.01 1.24.4.22.86.48 1.33.5.24.01.35-.19.33-.37.11-.1.21-.21.28-.28.41-.41.81-.84 1.2-1.26.85-.92 1.69-1.87 2.5-2.84 6.31-2.34 12.6-4.31 18.71-5.84 2.14 5.3 3.43 8.43 3.97 9.58.55 1.05 1.15 1.88 1.82 2.52 1.32.56 6.96-.03 9.23-1.96.87-1.28 1.19-2.67.93-4.15-.09-.5-.22-.95-.4-1.33l-.01-.03Zm-20.09-45.61c.43.77.83 1.56 1.21 2.35-.54-.45-1.27-.99-2.07-1.49-.42-.24-.6-.35-.94-.34.43-.15.85-.29 1.29-.41.17-.05.34-.08.51-.11Zm-25.86 45.66c.78-1.85 1.67-3.66 2.54-5.47 1.51-3.16 3.05-6.31 4.58-9.47 1.28-2.63 2.56-5.26 3.83-7.9l-1.1 2.66c-1.99 4.79-4.97 10.9-8.88 18.15-.43.76-.66 1.51-.71 2.24-.05-.05-.1-.09-.15-.14a.259.259 0 0 0-.11-.07Zm6.24 4.71c-.42-.23-.82-.48-1.22-.74 1.05.45 2 .72 2.55.72l-.21.21c-.05.05-.11.1-.16.15-.01.01-.04.03-.05.04 0-.02.03-.02.05-.03a.27.27 0 0 0-.08.07c-.05-.02-.1-.03-.14-.05-.25-.1-.49-.24-.73-.37h-.01Zm15.73-29.43c1.05 3.15 2.1 6.31 3.1 9.48.34 1.06.69 2.13 1.01 3.21-3.5.63-6.95 1.46-10.27 2.5 2.48-6.03 4.54-11.11 6.16-15.19Zm4.79 12.57c-.23-.79-.49-1.58-.73-2.36-.79-2.54-1.63-5.08-2.46-7.61l-1.2-3.6c.02-.04.04-.09.05-.13 1.6 4.45 3.28 9 5.01 13.57l-.67.12v.01Zm5.83-18.27-.15-.54c-.49-1.64-1.03-3.28-1.6-4.9.23.58.47 1.17.7 1.75 1.56 4.03 3.01 8.1 4.39 12.2-.33-.82-.67-1.64-.98-2.46l-2.35-6.05h-.01ZM390.43 79.37c-.13-10.43-.22-17.5-.24-19.97-.24-1.6.21-2.88-.65-3.65-.14-.13-.32-.23-.52-.32h.03c.45 0 .45-.69 0-.7-1.75-.03-3.5-.04-5.25-.14-1.38-.08-2.76-.21-4.15-.31-.07 0-.12.01-.17.04-.21-.07-.47.03-.45.31l.03.45c-.11.14-.19.3-.22.5-.21 1.26-.32 13.67-.36 23.59-.32 5.79-.67 11.57-.97 17.36-.09 1.73-.29 3.54-.21 5.3-.39.02-.38.64.04.69v.12c.05.44.74.45.7 0v-.06c1.1.09 2.2.21 3.3.3 1.14.19 2.44.2 3.29.17 1.73-.05 2.92-.05 3.8-.37.45-.05.9-.11 1.35-.17.44-.06.25-.73-.19-.67h-.01c.24-.32.45-.72.62-1.25.66-1.84.41-6.36.34-11.33l-.13-9.9.02.01Zm-12.26 18.17c.09-1.91.2-3.81.31-5.71.06 5.38 0 6.14-.01 6.51-.05 1.65-.21 2.81.72 3.66-.39-.04-.78-.07-1.17-.1-.06-1.44.09-2.93.16-4.35l-.01-.01ZM588.97 53.85c-2.06-.25-3.17-.51-3.76-.6a.3.3 0 0 1 .04-.08c.22-.39-.39-.75-.6-.35-.56 1.02-.9 2.19-1.26 3.29-.61 1.88-1.17 3.78-1.72 5.68-.63 2.19-1.24 4.39-1.83 6.59-.81 2.03-1.67 4.05-2.61 6.03-1.7-3.64-3.11-6.04-4.03-7.57-2.26-3.74-2.85-5.48-3.57-6.08l.31-.09c.43-.12.25-.8-.19-.67-1.06.3-2.12.6-3.17.95-.93.32-1.85.69-2.76 1.07-.13.05-.19.16-.22.27-.04.02-.08.05-.11.07-.04-.06-.07-.12-.11-.18a.354.354 0 0 0-.48-.12c-.16.09-.22.32-.13.48l.33.54c0 .09.02.18.06.28.51 1.16.78 1.38.72 1.47-2.42 3.44-5.41 7.86-6.2 9.1-1.27 1.97-2.01 3.14-2.45 3.84l-.91-6.56-.43-4.1c-.19-1.85-.37-3.23-.53-4.13-.19-1.1-.3-2.15-.45-3.16-.2-1.36-.29-2.06-.47-2.42h.04c.45.02.45-.68 0-.7-3.43-.16-6.81.94-10.17 1.48-.24-.22-.73-.04-.58.32.24.59.33 1.25.43 1.87.17 1.06.29 2.13.4 3.2.32 3.09.53 6.2.74 9.3.44 6.75.77 13.51 1.17 20.26.11 1.95.13 3.96.46 5.89.05.3.37.31.55.14.74 1.71 2.87 1.27 6.13 1.27 1.34 0 2.39.04 2.99-.11.02.32.48.53.63.18 3.61-8.26 7.41-16.46 12.05-24.2.03-.05.04-.1.05-.15.3.73.64 1.45.94 2.16.97 2.26 1.97 4.52 2.98 6.76 2.26 5.03 4.54 10.07 7.09 14.96.47.9.94 1.79 1.47 2.65.2.32.4.67.66.96-.18.25 0 .68.34.54.91-.38 1.82-.75 2.76-1.07 1.04-.35 2.11-.65 3.17-.95.39-.11.28-.66-.07-.68.62-.4.95-.96.87-1.91-.3-3.34.72-7.47.86-8.52l2.14-11.43c1.75-10.74 3.13-17.51 3.23-20.86.02-.49.08-2.84.13-3.24.17-1.25.48-1-4.96-1.65l.03-.02Zm-46.19 5.67c-.04-.24-.09-.48-.15-.71l.85-.15c-.34.24-.56.53-.7.86Zm1.95 25.12c-.36-6.63-.7-13.26-1.32-19.87 0 .02 0 .04.01.06.29 1.65.44 2.47.56 2.89 1 8.46 1.5 16.14 1.46 22.8-.06.99-.1 2-.11 3.02-.01.29-.03.68-.05 1.12-.01-.26-.03-.53-.04-.78-.19-3.08-.35-6.16-.52-9.23l.01-.01Zm36.4 18.66c-.11-.11-.24-.29-.37-.49.35.21.74.26 1.17.16-.27.11-.53.22-.8.32v.01Zm-.89-33.72c.12-.43.23-.86.35-1.29.71-1.77 1.41-3.55 2.08-5.33-.15.68-.26 1.22-.31 1.55-.5 2.94-2.13 7.59-3.58 13.36-.15-.35-.29-.66-.43-1 .61-2.44 1.25-4.87 1.9-7.3l-.01.01Zm3.56-12.48c.14-.44.28-.89.42-1.34-.13.7-.27 1.41-.42 2.11-.43 1.19-.86 2.38-1.31 3.57.42-1.45.85-2.9 1.31-4.34Zm-5.22 16.05c-.11.44-.23.87-.35 1.31-.12.46-.23.92-.35 1.38-.1-.22-.19-.4-.28-.61.34-.69.66-1.38.97-2.08h.01Zm-11.64 2.62c.06-.1.12-.19.17-.28.05.13.09.26.14.39a.398.398 0 0 0-.31-.11Zm2.3 2.98c-.56-1.3-1.25-2.63-1.65-3.99 0 0 .01-.02.02-.02.06.08 1.52 2.93 1.63 3.08.73 1.13 3.38 7.04 5.67 12.26 1.2 2.73 2.08 5.17 2.83 7.18-.62-1.25-1.23-2.51-1.83-3.78-2.31-4.87-4.53-9.78-6.67-14.73ZM275.92 87.03c-1.06-2.18-1.13-3.45-2.44-2.93-1.52.57-2.94 1.3-4.5 2.1-1.4.72-2.68 1.44-3.92 2.12.01-.25-.24-.5-.51-.34-4.8 2.93-12.41 4.7-17.28 1.31-1.98-1.77-3.32-4.15-3.97-5.78-.29-.95-.49-1.94-.63-2.93-.14-3.34 1.58-6.53 3.9-9.12.8-.79 1.68-1.51 2.66-2.12 3.7-2.3 8.22-3.07 12.51-2.51 2.71.35 5.32 1.24 7.71 2.55.39.22.75-.39.35-.6-.18-.1-.37-.18-.55-.27.56.27 1.03.33 1.51.19l-.48.39c-.15.11-.23.3-.13.48.09.15.33.24.48.13 1.3-.97 2.46-2.09 3.45-3.37.37-.29.64-.6.65-.97v-.02c.08-.33-.03-.7-.21-1.08-.31-.87-.98-2.01-2.19-3.26-2.43-2.52-3.79-3.45-5.68-4.26-1.14-.49-3.12-1.06-4.42-1.23-3.28-.42-10.64-1.21-18.18 4.11-7.74 5.46-11.94 12.3-12.23 20.61-.08 2.06.04 3.98.34 5.71.74 4.18 2.57 8 5.44 11.34 4.26 4.99 9.76 7.52 16.34 7.52 4.85 0 9.69-1.77 14.89-4.62.23-.12.45-.23.68-.35 2.19-1.1 4.37-2.23 6.46-3.5.49-.3 1.03-.61 1.5-.98 1.47-.87 1.11-1.12.49-2.95-.39-1.14-.76-2.7-2.06-5.36l.02-.01Zm-17.38-21.76c3.05-.42 6.31.79 9.36 2.35.51.39.94.68 1.33.87-5.61-2.86-12.72-3.39-18.44-.79 2.05-1.33 4.24-1.95 7.74-2.44l.01.01ZM443.67 72.67c-.4-2.2-1.15-4.33-2.37-6.22-1.49-2.32-3.58-4.19-5.91-5.64-6.17-3.81-13.75-5.11-20.83-6.01-3.23-.41-6.47-.69-9.72-.92l-1.39-.12c-.85-.07-1.52-.1-2.05-.1-1.08-.06-2.17-.12-3.25-.17-.08 0-.14.02-.19.05-.1.05-.18.14-.16.3.27 2.55-.01 5.12-.92 7.52-.15.38.4.56.62.28 1.32.59 2.68 1.05 4.08 1.37 0 2.78-.14 7.58-.33 12.91 0 0 0 .02-.01.03-.61 3.66-.79 7.42-1 11.12-.23 4.01-.43 8.03-.44 12.05 0 .64 0 1.28.03 1.93.02.31 0 .68.15.96.06.11.14.16.24.17-.2.17-.21.54.11.59 3.83.67 7.78.71 11.68.25 2.3-.19 4.87-.65 7.65-1.56 1.85-.54 3.67-1.18 5.43-1.91 7.2-3.02 14.31-8.07 17.35-15.53.76-1.86 1.17-3.8 1.31-5.75.3-1.93.28-3.82-.09-5.58l.01-.02Zm-19.32-15.42c5.74 1.41 11.94 3.68 15.65 8.55.25.32.47.65.69.99-2.3-2.82-5.68-5.69-12.88-8.23-2.16-.76-4.35-1.43-6.64-2.02 1.06.21 2.13.45 3.18.71Zm-25.82-3.04c.13 0 .27.01.4.02-.14.1-.26.23-.37.38 0-.13-.02-.26-.03-.4Zm34.82 22.17c-.75 3.09-3.55 5.66-5.88 7.58-3.35 2.76-7.21 5.03-11.28 6.54-1.33.49-2.71.9-4.12 1.15.06-1.38.08-2.76.07-4.13-.02-3.78-.16-7.56-.41-11.33-.09-1.37-.18-2.74-.37-4.1 0-.06-.03-.11-.06-.15.09-3.25.12-6.16.03-8.12 6.86 1.05 10.56 2.17 14.06 3.62 5.52 2.28 8.59 5.44 7.97 8.96l-.01-.02Zm-22 16.15c-.12 0-.23-.02-.34-.03l.34-.03v.06Zm-.69-.7c0-3.13.26-8.84.47-14.51.06 1.2.11 2.41.15 3.6.15 3.6.25 7.23.09 10.83-.24.03-.48.05-.71.07v.01Zm-12.33-30.94c.37.63 2.01 1.01 3.23 1.25v.15c-1.31-.31-2.59-.73-3.83-1.29.12-.36.23-.72.33-1.09.08.48.18.84.27.98Zm13.7 31.65v-.18c3.41-.56 6.71-2.02 9.69-3.68 2.31-1.28 4.59-2.78 6.63-4.53-4.69 4.53-11.61 8.24-16.33 8.38l.01.01Zm24.07-.75c-2.05 1.93-4.37 3.56-6.83 4.95 2.7-1.78 5.52-4.03 8.42-6.87.82-.82 1.56-1.69 2.23-2.59-1.08 1.65-2.38 3.16-3.81 4.51h-.01ZM187.16 92.14c-.79-2.47-2.1-7.12-3.1-6.87-.19-.01-2.09.77-4.08 1.54-3.06 1.18-5.91 2.13-10.09 2.82-2.74.42-5.87 1.01-10.61 1.06.04-3.34.05-6.01.05-7.99 7.97-.65 12.33-2.11 16.37-3.55 1.11-.39 2.69-1.01 2.63-1.8-.08-.35-.55-1.39-1.17-2.61-.47-1.16-.98-2.31-1.61-3.38-.42-.71-1.04-1.69-1.86-2.06-.11-.08-.22-.13-.29-.12-.02 0-.04 0-.07.01-.19-.04-.39-.05-.6-.01-.17.03-.24.15-.25.28-.04.02-.09.04-.14.05-4.33 1.48-8.85 2.33-13.24 3.61a499.1 499.1 0 0 0-.31-8.19c4.51-.99 8.88-1.38 13.11-1.82 3.68-.38 6.28.12 7.47.34.59.11.9.16 1.16.18h.1c-.1.37.44.66.62.28.02-.04.03-.08.05-.13.15.2.53.22.62-.1.17-.58.19-1.21.21-1.81v-.36c.03-.15.05-.3.07-.45.52-2.47.33-5.09-.64-7.44-.11-.27-.44-.28-.6-.14-.08-.21-.15-.42-.24-.62-.19-.41-.79-.05-.6.35.03.07.05.15.09.22-.98-.42-2.15-.54-3.17-.63-2.17-.19-4.37-.14-6.54 0-5.7.35-11.4 1.3-16.91 2.79-2.08.56-4.13 1.22-6.14 2-4.54 1.05-3.79 1.51-2.17 6.07.18.51.46 1.68.54 1.94.82 2.47 1.08 2.13 3.1 2.13s0 .05 0 .08h.52c-.48 2.66-.51 5.45-.62 8.13-.15 3.48-.22 6.96-.28 10.45 0 .41-.01.82-.02 1.23-.16.29-.33.57-.51.85-.05.38-.09.77-.14 1.18-.42 3.52-.59 6.48-.52 8.8v.34c.02.47.05.76.06.87.16 1.57-.26 3.47 1.35 3.79 1.61.32 3.5.55 4.85.55.11 0 .22-.02.33-.02 1.79.24 3.67.05 5.45-.12 2.85-.28 5.69-.7 8.51-1.19 3.03-.53 6.05-1.14 9.04-1.86 2.4-.58 4.82-1.19 7.13-2.06.51-.19 1.73-.57 2.46-1.14 1.81-.68 2.18-1 1.57-2.67-.23-.62-.48-1.49-.91-2.78l-.03-.02Zm-11.12-38.71c.89.05 1.93.08 2.89.3-.33 0-.68-.02-1.06-.03-8.28-.26-14.88.75-23.97 2.51 2.41-.64 4.85-1.16 7.28-1.59 4.87-.86 9.91-1.45 14.86-1.19Zm-26.53 22.13c.03 1.71.04 3.43 0 5.14-.04 1.27-.11 2.55-.24 3.82 0-.73.02-1.46.04-2.19.05-2.26.12-4.51.22-6.77h-.02Zm6.73 27.85c.2-.1.4-.21.58-.33 1.82-.17 3.82-.24 5.94-.34-.86.11-1.72.24-2.58.33-1.27.14-2.61.31-3.93.34h-.01ZM534.48 85.44c-3.52-8.38-7.07-16.75-10.5-25.17-.63-1.54-1.25-3.09-1.86-4.65-.31-.8-.65-1.6-.87-2.43-.04-.17-.17-.24-.31-.25.1-.2 0-.51-.29-.53-1.59-.08-3.18-.22-4.78-.25-1.96-.03-3.91.13-5.84.42-.31.05-.31.38-.13.56-.03.06-.05.14-.04.22.23 1.54.63 3.06 1.16 4.53.13.35.27.7.41 1.06l-2.68 6.18c-.11.03-.2.09-.25.22-.67 1.9-1.52 3.73-2.34 5.56a536.85 536.85 0 0 1-3.9 8.45c-2.64 5.64-5.34 11.25-7.91 16.93-.44.97-.88 1.94-1.29 2.93-.2.48-.47 1-.55 1.52v.05c-.02.12.02.26.16.34 1.19.73 2.41 1.41 3.66 2.05 1.2.62 2.45 1.25 3.76 1.61.43.12.62-.55.19-.67-1.13-.31-2.2-.83-3.24-1.36 1.09.36 2.1.69 2.75.93 2.82 1.01 2.38 1.1 4.3-3.75 2.1-1.09 4.34-1.96 6.53-2.79 4.35-1.64 8.8-3.03 13.27-4.29.82 2.01 1.77 3.97 2.72 5.92.35.83.62 1.45.79 1.82.22.42.45.8.69 1.15.17.33.33.67.5 1 .42.8.84 1.63 1.4 2.35.23.29.6 0 .55-.31 1.53-.02 3.06-.07 4.58-.27.92-.12 1.82-.32 2.71-.54 1.39-.27 3.85-1.11 3.74-1.42-.67-1.96-1.55-3.87-2.34-5.78-1.57-3.78-3.16-7.56-4.75-11.33v-.01Zm-11.65-26.16c1.54 3.81 3.12 7.6 4.7 11.4 2.94 7.05 5.91 14.09 8.87 21.13l-1.06-2.17c-2.71-5.51-5.2-11.19-7.41-16.87l-6.65-17.15c-.65-1.45-.55-2.19-.93-2.53.09 0 .18.01.28.02a.29.29 0 0 0-.04.26c.52 2.02 1.47 3.98 2.25 5.91h-.01Zm-6.58 13.58c.05-.15.09-.31.14-.46 1.41 3.92 2.88 7.9 4.39 11.87-3.22.52-6.38 1.25-9.46 2.14.55-1.22 1.05-2.46 1.53-3.7 1.24-3.24 2.37-6.53 3.39-9.85h.01Zm-.23-20c.36 0 .73.03 1.09.05-2.15.1-5.18.33-5.87.74-.24.15-.41.3-.53.45-.06-.29-.13-.58-.18-.88 1.82-.26 3.65-.39 5.49-.35v-.01Zm-.09 18.72c-.49 1.67-1.05 3.33-1.6 4.97-1.07 3.19-2.19 6.38-3.57 9.46-.09.21-.19.43-.29.65-.25.07-.5.14-.74.22 2.53-6.16 4.61-11.29 6.2-15.3Zm-6.34 25.16c4.97-2.38 9.37-4.1 14.02-5.27l.26.64c-4.8 1.35-9.63 2.8-14.28 4.63Zm20.17 6.76c.33.23.68.42 1.04.56h-.33c-.12 0-.21.06-.26.13-.15-.23-.31-.45-.45-.7v.01ZM226.57 91.75c-3.55-4.74-6.68-9.11-9.31-12.99 9.2-15.25 10.05-17.81 10.35-18.38.17-.34 1.09-2.27.64-2.53-1.13-.65-1.03-.65-2.97-1.71-1.19-.65-3.04-1.61-4.53-2.12-1.71-.59-1.24-.36-3 2.77-.06.1-.11.2-.17.3-.75 1.02-1.48 2.05-2.2 3.09-1.88 2.71-3.73 5.45-5.69 8.1-3.68-4.91-6.88-8.76-9.51-11.43-.15-.15-.3-.29-.46-.42-1.27-1.28-7.24 3.53-7.93 5.58-.09.09-.19.16-.28.25-.27.26.03.64.33.58.19.65.5 1.29.94 1.91 3.85 5.06 7.19 9.76 9.94 14-1.23 2.61-3.06 5-4.67 7.38l-2.28 3.33c-.5.66-.93 1.23-1.29 1.69-.67.93-2.09 2.61-2.3 3.87-.51.85-1.16 1.84-1.29 2.83-.06.44.61.63.67.19.01-.08.04-.15.06-.22 1.36 1.08 2.76 2.11 4.19 3.11 1.3.91 2.62 1.85 4.04 2.56.21.1.4 0 .48-.17.24.07.48.14.72.2.44.1.62-.57.19-.67-2.02-.48-3.77-1.57-5.23-3.02-.47-.46-.9-.96-1.32-1.46 1.74 1.35 4.2 2.89 5.89 4.14 1.39 1.03 2.85-2.27 4.22-4.2 1.86-2.64 3.96-5.86 5.52-8.29l10.39 14.51c.67.81 1.14 1.21 1.57 1.36-.05.24.12.51.41.4 1.53-.58 3.05-1.19 4.54-1.87 1.52-.69 3.06-1.45 4.36-2.5a.28.28 0 0 0 .12-.23c1.66-1.1.81-1.74-1.41-4.91-1.13-1.58-1.71-2.36-3.7-5.01l-.03-.02Zm2.41 6.54c.56 1.15 1.19 2.52 1.11 3.81-.06.04-.12.07-.17.1-.03-.88-.55-2.66-.94-3.91Zm-16.51-32.73c1.86-2.65 3.65-5.35 5.57-7.95.4-.55.81-1.13 1.26-1.66.19-.18.38-.33.56-.45.18.03.36.08.55.13l-8.05 10.11.12-.18h-.01ZM192.7 95.48c.79-1.37 1.66-2.69 2.54-4 1.19-1.79 2.4-3.56 3.61-5.33-.04.09-.09.17-.13.26-.1.22.03.41.2.49-2.47 3.42-4.89 6.73-6.4 9.28.21.24.4.48.63.75-.24.07-.4.36-.17.56.4.33.72.77 1.05 1.17.09.11.18.21.27.32-.84-.61-1.66-1.24-2.47-1.88.24-.57.58-1.11.87-1.61v-.01Zm7.46-10.32c.47-.81.98-1.59 1.49-2.37.31-.48.64-.95.96-1.43.26-.29.52-.56.75-.79-.99 1.48-2.09 3.03-3.2 4.59Zm10.03-16.22s-.03-.05-.05-.07c.22-.29.43-.59.64-.89-.2.32-.4.65-.58.96h-.01ZM371.54 87.96c-.01-.08-.01-.16-.03-.23-.06-.38-.58-.29-.66.03-.3-.05-.6-.08-.81-.11-1.14-.15-2.29-.19-3.44-.2 1.04-.09 2.09-.18 3.14-.23.45-.02.45-.72 0-.7-6.57.35-13.14 1.23-19.65 2.11-1.53.21-3.05.42-4.57.68-.01 0-.02.01-.04.01-.04-3.33-.13-6.66-.24-9.99-.19-5.7-.4-11.41-.88-17.1-.13-1.51-.23-3.07-.49-4.58 0-.25 0-.48-.02-.68-.06-1.19-.04-2.61-.68-2.78-.16-.07-.72-.16-1.5-.24.22-.17.16-.62-.2-.63-1.19-.04-2.39.09-3.57.23-1.2.14-2.41.32-3.59.6-.16-.1-.41-.06-.5.12-.06.02-.13.03-.19.05-.35.1-.29.55-.03.66-.26.6-.19 2.27-.21 3-.02.66-.66 33.73-.9 40.3-.03.65.06 1.12.04 1.45-.16 3.05.87 4.96 6.34 3.93 1.09-.08 2.75-.77 5.36-1.43 4.13-1.04 5.78-1.52 6.2-1.65 6.43-1.69 6.78-1.97 11.72-2.43.55-.05 4.8-.38 6.03-.3.64.04 1.19.07 1.65.1.09 0 .16-.03.24-.05.1.27.56.33.66-.02.39-1.32.61-2.71.78-4.08.2-1.61.29-3.24.15-4.86.24.03.52-.23.38-.53-.09-.2-.27-.33-.49-.43v-.02Zm-.63.56c.07.57.11 1.14.11 1.71-.21-.99-.53-1.71-.95-1.87.22.03.44.06.65.11.06.01.12.04.19.05Zm-25.41 1.73c1.54-.36 3.1-.64 4.66-.89-1.61.37-3.18.77-4.66 1.2v-.31Zm-.86-7.37c-.07-1.37-.16-2.75-.25-4.12-.21-3.13-.45-6.27-.79-9.4.02-2.25.08-4.31.13-6.11.16 2.08.29 4.16.4 6.24.23 4.46.38 8.93.5 13.39h.01Zm-.94-4c.16 2.41.29 4.83.39 7.24.06 1.6.14 3.22.09 4.83-.15.05-.32.09-.47.14V78.88h-.01ZM483.72 92.83c-3.05-2.28-6.22-4.4-9.38-6.51 8.86-6.49 13.49-12.95 13.73-19.23.04-.76 0-1.5-.13-2.2-.67-3.82-3.5-6.68-8.39-8.48.13.04.27.08.4.13 3.92 1.39 7.74 4.23 8.5 8.56.34 1.95-.05 3.96-.98 5.69-.21.4.39.75.6.35 1.86-3.46 1.46-7.55-.97-10.63-3.53-4.47-9.76-5.88-15.16-6.16-2.32-.12-4.64-.04-6.95.19-6 .32-12.71 1.68-17.63 3.21-.37.11-.67.23-.92.35-.2-.17-.62.02-.57.37v.03c-.64.68-.18 1.64.48 3.21.38.91.67 1.89 1.15 2.58.32.76.68 1.51 1.13 2.19.14.21.38.19.53.07.19-.02.38-.05.57-.08v1.57c-.06.06-.1.13-.11.23-.27 4.18-.34 8.38-.48 12.57l-.3 9.03c-.24 3.91-.44 6.77-.46 7.26-.05.88-.11 1.95.07 2.81-.01.22-.02.43-.04.65 0 .11-.02.23-.03.35 0 .05-.03.27-.01.16-.05.4.5.59.64.28.05.04.12.08.2.08 1.75.13 3.5.28 5.25.3 1.69.02 3.38-.12 5.06-.32.08.23.36.39.55.15.06-.08.11-.17.16-.26.18-.09.24-.32.18-.48.05-.2.1-.4.13-.6.16-.86.25-1.74.33-2.62.11-1.17.17-2.34.23-3.51.15-.01.32-.03.52-.04.36-.03 1.73-.15 2.06-.15.39 0 .7-.02.95-.04 1.76 1.11 3.45 2.35 5.14 3.55 2.83 2.01 5.64 4.04 8.47 6.04 1.42 1 2.85 2 4.29 2.97.1.06.19.07.27.04.08 0 .17-.02.25-.1 1.61-1.56 3.15-3.18 4.6-4.88.75-.88 1.49-1.78 2.15-2.73.01.01.03.02.04.03.34.3.83-.2.49-.49-2.16-1.9-4.34-3.76-6.64-5.48l.03-.01Zm-6.38-3.65a55.72 55.72 0 0 0-4-2.13c.14-.1.26-.19.4-.29 1.2.81 2.4 1.61 3.6 2.42Zm-20.1 11.78c.67-.37 1.23-.91 1.67-1.6-.11.5-.24 1-.38 1.49-.43.04-.86.08-1.29.11Zm2.38-37.24c1.34-.31 2.56-.52 3.71-.69-1.03.19-2.04.41-3.04.65-.14-.07-.34-.02-.45.11-.07.02-.15.04-.22.05v-.13.01Zm.04.84c.07-.02.14-.03.2-.05.34 1.66.41 3.41.5 5.09.17 2.9.24 5.81.28 8.71l.03 3.17c-.17.07-.34.14-.51.2-.06-4.96-.21-10.58-.51-17.12h.01Zm16.04 5.62c-1.16 2.25-3.06 4.1-5.02 5.66-2.8 2.23-5.99 3.97-9.3 5.35-.01-3.56-.09-7.12-.27-10.67-.1-2.04-.16-4.16-.57-6.18 3.3-.78 6.72-1.36 10.1-1.1 1.85.14 4.23.59 5.32 2.29.92 1.43.46 3.24-.26 4.65Zm.85-.18c.6-1.37.9-2.92.28-4.32-.67-1.52-2.2-2.32-3.76-2.74.46.1.89.21 1.29.37 1.74.67 2.69 1.88 2.93 3.21.2 1.13-.05 2.25-.74 3.47V70Zm-27.47-4.14c-.12-.19-.23-.38-.34-.57.74.42.85.36.99.41v.08c-.22.03-.43.06-.65.08Zm11.21 30.46c-.08 1.08-.16 2.17-.33 3.24-.05.35-.11.69-.2 1.03 0 .04-.02.07-.03.11-.15.02-.3.04-.45.05.45-1.64.76-3.36.79-5.07.03-.29.08-.57.1-.89-.03-.31-.03-.47.24-.57-.04.69-.07 1.39-.12 2.08v.02Zm5.6-2.47c.48.11.92.52 2.49 1.72-.46-.32-.92-.65-1.38-.97-.37-.25-.73-.5-1.1-.75h-.01Zm21.23 7.24a70.76 70.76 0 0 1-4.37 4.63c-.14-.09-.27-.19-.4-.28.19-.09.37-.24.55-.47.87-1.14 5.43-5.51 5.49-7.45.31.26.62.53.92.79-.67.97-1.42 1.88-2.19 2.77v.01Z",
          fill: "currentColor",
          transform: "translate(-144.023 -51.76)",
        }),
      ],
    }),
  FI = ({ style: e, size: o = "small", withText: t }) =>
    OI("div", {
      className: `ExcalidrawLogo is-${o}`,
      style: e,
      children: [Or(SG, {}), t && Or(kG, {})],
    });
import { Fragment as GI, jsx as Ve, jsxs as Rf } from "react/jsx-runtime";
var Nf = ({ icon: e, shortcut: o, children: t }) => {
  let r = ae();
  return Rf(GI, {
    children: [
      Ve("div", { className: "welcome-screen-menu-item__icon", children: e }),
      Ve("div", { className: "welcome-screen-menu-item__text", children: t }),
      o &&
        !r.editor.isMobile &&
        Ve("div", { className: "welcome-screen-menu-item__shortcut", children: o }),
    ],
  });
};
Nf.displayName = "WelcomeScreenMenuItemContent";
var Il = ({ onSelect: e, children: o, icon: t, shortcut: r, className: n = "", ...i }) =>
  Ve("button", {
    ...i,
    type: "button",
    className: `welcome-screen-menu-item ${n}`,
    onClick: e,
    children: Ve(Nf, { icon: t, shortcut: r, children: o }),
  });
Il.displayName = "WelcomeScreenMenuItem";
var zI = ({ children: e, href: o, icon: t, shortcut: r, className: n = "", ...i }) =>
  Ve("a", {
    ...i,
    className: `welcome-screen-menu-item ${n}`,
    href: o,
    target: "_blank",
    rel: "noopener",
    children: Ve(Nf, { icon: t, shortcut: r, children: e }),
  });
zI.displayName = "WelcomeScreenMenuItemLink";
var jt = ({ children: e }) => {
  let { WelcomeScreenCenterTunnel: o } = Ie();
  return Ve(o.In, {
    children: Ve("div", {
      className: "welcome-screen-center",
      children:
        e ||
        Rf(GI, {
          children: [
            Ve(Bf, {}),
            Ve(Ff, { children: g("welcomeScreen.defaults.center_heading") }),
            Rf(Of, { children: [Ve(Hf, {}), Ve(zf, {})] }),
          ],
        }),
    }),
  });
};
jt.displayName = "Center";
var Bf = ({ children: e }) =>
  Ve("div", {
    className: "welcome-screen-center__logo excalifont welcome-screen-decor",
    children: e || Ve(FI, { withText: !0 }),
  });
Bf.displayName = "Logo";
var Ff = ({ children: e }) =>
  Ve("div", {
    className: "welcome-screen-center__heading welcome-screen-decor excalifont",
    children: e,
  });
Ff.displayName = "Heading";
var Of = ({ children: e }) => Ve("div", { className: "welcome-screen-menu", children: e });
Of.displayName = "Menu";
var zf = () => {
  let e = Fe();
  return Ve(Il, {
    onSelect: () => e.executeAction(Jr),
    shortcut: "?",
    icon: kn,
    children: g("helpDialog.title"),
  });
};
zf.displayName = "MenuItemHelp";
var Hf = () => {
  let e = ge(),
    o = Fe();
  return e.viewModeEnabled
    ? null
    : Ve(Il, {
        onSelect: () => o.executeAction(qn),
        shortcut: Ne("loadScene"),
        icon: Mn,
        children: g("buttons.load"),
      });
};
Hf.displayName = "MenuItemLoadScene";
var HI = ({ onSelect: e }) => {
  let { t: o } = ze();
  return Ve(Il, { shortcut: null, onSelect: e, icon: ql, children: o("labels.liveCollaboration") });
};
HI.displayName = "MenuItemLiveCollaborationTrigger";
jt.Logo = Bf;
jt.Heading = Ff;
jt.Menu = Of;
jt.MenuItem = Il;
jt.MenuItemLink = zI;
jt.MenuItemHelp = zf;
jt.MenuItemLoadScene = Hf;
jt.MenuItemLiveCollaborationTrigger = HI;
import { jsx as Yi, jsxs as Gf } from "react/jsx-runtime";
var tm = ({ children: e }) => {
  let { WelcomeScreenMenuHintTunnel: o } = Ie();
  return Yi(o.In, {
    children: Gf("div", {
      className:
        "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--menu",
      children: [
        M1,
        Yi("div", {
          className: "welcome-screen-decor-hint__label",
          children: e || g("welcomeScreen.defaults.menuHint"),
        }),
      ],
    }),
  });
};
tm.displayName = "MenuHint";
var om = ({ children: e }) => {
  let { WelcomeScreenToolbarHintTunnel: o } = Ie();
  return Yi(o.In, {
    children: Gf("div", {
      className:
        "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--toolbar",
      children: [
        Yi("div", {
          className: "welcome-screen-decor-hint__label",
          children: e || g("welcomeScreen.defaults.toolbarHint"),
        }),
        P1,
      ],
    }),
  });
};
om.displayName = "ToolbarHint";
var rm = ({ children: e }) => {
  let { WelcomeScreenHelpHintTunnel: o } = Ie();
  return Yi(o.In, {
    children: Gf("div", {
      className:
        "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--help",
      children: [Yi("div", { children: e || g("welcomeScreen.defaults.helpHint") }), L1],
    }),
  });
};
rm.displayName = "HelpHint";
import { Fragment as UI, jsx as Cl, jsxs as LG } from "react/jsx-runtime";
var nm = (e) =>
  Cl(UI, {
    children: e.children || LG(UI, { children: [Cl(jt, {}), Cl(tm, {}), Cl(om, {}), Cl(rm, {})] }),
  });
nm.displayName = "WelcomeScreen";
nm.Center = jt;
nm.Hints = { MenuHint: tm, ToolbarHint: om, HelpHint: rm };
var MG = nm;
var PG = () => {
    Array.prototype.at ||
      Object.defineProperty(Array.prototype, "at", {
        value: function (e) {
          if (((e = Math.trunc(e) || 0), e < 0 && (e += this.length), !(e < 0 || e >= this.length)))
            return this[e];
        },
        writable: !0,
        enumerable: !1,
        configurable: !0,
      }),
      Element.prototype.replaceChildren ||
        (Element.prototype.replaceChildren = function (...e) {
          (this.innerHTML = ""), this.append(...e);
        });
  },
  YI = PG;
import {
  getSceneVersion as c7e,
  hashElementsVersion as d7e,
  hashString as m7e,
  getNonDeletedElements as p7e,
} from "@excalidraw/element";
import { getTextFromElements as h7e } from "@excalidraw/element";
import { isInvisiblySmallElement as f7e } from "@excalidraw/element";
import AG from "lodash.throttle";
import { arrayToMap as DG, isDevEnv as WI, isTestEnv as VI } from "@excalidraw/common";
import {
  orderByFractionalIndex as _G,
  syncInvalidIndices as XI,
  validateFractionalIndices as RG,
} from "@excalidraw/element";
var NG = (e, o, t) =>
    !!(
      o &&
      (o.id === e.editingTextElement?.id ||
        o.id === e.resizingElement?.id ||
        o.id === e.newElement?.id ||
        o.version > t.version ||
        (o.version === t.version && o.versionNonce < t.versionNonce))
    ),
  BG = AG(
    (e, o, t) => {
      if (WI() || VI() || window?.DEBUG_FRACTIONAL_INDICES) {
        let r = XI(e.map((n) => ({ ...n })));
        RG(r, {
          shouldThrow: VI() || WI(),
          includeBoundTextValidation: !0,
          reconciliationContext: { localElements: o, remoteElements: t },
        });
      }
    },
    1e3 * 60,
    { leading: !0, trailing: !1 }
  ),
  FG = (e, o, t) => {
    let r = DG(e),
      n = [],
      i = new Set();
    for (let l of o)
      if (!i.has(l.id)) {
        let s = r.get(l.id),
          d = NG(t, s, l);
        s && d ? (n.push(s), i.add(s.id)) : (n.push(l), i.add(l.id));
      }
    for (let l of e) i.has(l.id) || (n.push(l), i.add(l.id));
    let a = _G(n);
    return BG(a, e, o), XI(a), a;
  };
import { getFreeDrawSvgPath as I7e } from "@excalidraw/element";
import { isLinearElement as k7e } from "@excalidraw/element";
import {
  FONT_FAMILY as L7e,
  THEME as P7e,
  MIME_TYPES as A7e,
  ROUNDNESS as mc,
  DEFAULT_LASER_COLOR as D7e,
  UserIdleState as _7e,
  normalizeLink as R7e,
} from "@excalidraw/common";
import { mutateElement as uc, newElementWith as B7e, bumpVersion as si } from "@excalidraw/element";
import { CaptureUpdateAction as O7e } from "@excalidraw/element";
import {
  sceneCoordsToViewportCoords as ny,
  viewportCoordsToSceneCoords as G7e,
} from "@excalidraw/common";
import { jsx as KI, jsxs as OG } from "react/jsx-runtime";
var ZI = ({ children: e, icon: o }) => {
  let { TTDDialogTriggerTunnel: t } = Ie(),
    r = le();
  return KI(t.In, {
    children: OG(fe.Item, {
      onSelect: () => {
        re("ai", "dialog open", "ttd"), r({ openDialog: { name: "ttd", tab: "text-to-diagram" } });
      },
      icon: o ?? W0,
      children: [e ?? g("labels.textToDiagram"), KI(fe.Item.Badge, { children: "AI" })],
    }),
  });
};
ZI.displayName = "TTDDialogTrigger";
import { getCommonBounds as J7e, getVisibleSceneBounds as Q7e } from "@excalidraw/element";
import { useLayoutEffect as zG } from "react";
var HG = (e) => {
  let o = Re();
  return (
    zG(() => {
      o.setPlugins({ diagramToCode: { generate: e.generate } });
    }, [o, e.generate]),
    null
  );
};
import { isElementLink as nDe } from "@excalidraw/element";
import { setCustomTextMetricsProvider as aDe } from "@excalidraw/element";
import { jsx as Uf } from "react/jsx-runtime";
YI();
var WG = (e) => {
    let {
        onChange: o,
        onIncrement: t,
        initialData: r,
        excalidrawAPI: n,
        isCollaborating: i = !1,
        onPointerUpdate: a,
        renderTopRightUI: l,
        langCode: s = fo.code,
        viewModeEnabled: d,
        zenModeEnabled: m,
        gridModeEnabled: c,
        libraryReturnUrl: p,
        theme: u,
        name: f,
        renderCustomStats: b,
        onPaste: x,
        detectScroll: w = !0,
        handleKeyboardGlobally: E = !1,
        onLibraryChange: y,
        autoFocus: v = !1,
        generateIdForFile: C,
        onLinkOpen: S,
        generateLinkForSelection: M,
        onPointerDown: k,
        onPointerUp: A,
        onScrollChange: P,
        onDuplicate: N,
        children: O,
        validateEmbeddable: U,
        renderEmbeddable: J,
        aiEnabled: _,
        showDeprecatedFonts: R,
        renderScrollbars: X,
      } = e,
      $ = e.UIOptions?.canvasActions,
      W = {
        ...e.UIOptions,
        canvasActions: { ...$I.canvasActions, ...$ },
        tools: { image: e.UIOptions?.tools?.image ?? !0 },
      };
    return (
      $?.export &&
        (W.canvasActions.export.saveFileToDisk =
          $.export?.saveFileToDisk ?? $I.canvasActions.export.saveFileToDisk),
      W.canvasActions.toggleTheme === null && typeof u > "u" && (W.canvasActions.toggleTheme = !0),
      UG(() => {
        (async () => {
          await import("canvas-roundrect-polyfill");
        })();
        let he = (de) => {
          typeof de.scale == "number" && de.scale !== 1 && de.preventDefault();
        };
        return (
          document.addEventListener("touchmove", he, { passive: !1 }),
          () => {
            document.removeEventListener("touchmove", he);
          }
        );
      }, []),
      Uf(y1, {
        store: He,
        children: Uf(_I, {
          langCode: s,
          theme: u,
          children: Uf(DI, {
            onChange: o,
            onIncrement: t,
            initialData: r,
            excalidrawAPI: n,
            isCollaborating: i,
            onPointerUpdate: a,
            renderTopRightUI: l,
            langCode: s,
            viewModeEnabled: d,
            zenModeEnabled: m,
            gridModeEnabled: c,
            libraryReturnUrl: p,
            theme: u,
            name: f,
            renderCustomStats: b,
            UIOptions: W,
            onPaste: x,
            detectScroll: w,
            handleKeyboardGlobally: E,
            onLibraryChange: y,
            autoFocus: v,
            generateIdForFile: C,
            onLinkOpen: S,
            generateLinkForSelection: M,
            onPointerDown: k,
            onPointerUp: A,
            onScrollChange: P,
            onDuplicate: N,
            validateEmbeddable: U,
            renderEmbeddable: J,
            aiEnabled: _ !== !1,
            showDeprecatedFonts: R,
            renderScrollbars: X,
            children: O,
          }),
        }),
      })
    );
  },
  VG = (e, o) => {
    if (e.children !== o.children) return !1;
    let { initialData: t, UIOptions: r = {}, ...n } = e,
      { initialData: i, UIOptions: a = {}, ...l } = o,
      s = Object.keys(r),
      d = Object.keys(a);
    return s.length !== d.length
      ? !1
      : s.every((c) =>
          c === "canvasActions"
            ? Object.keys(r.canvasActions).every((u) =>
                u === "export" && r?.canvasActions?.export && a?.canvasActions?.export
                  ? r.canvasActions.export.saveFileToDisk === a.canvasActions.export.saveFileToDisk
                  : r?.canvasActions?.[u] === a?.canvasActions?.[u]
              )
            : r[c] === a[c]
        ) && YG(n, l);
  },
  XG = GG.memo(WG, VG);
XG.displayName = "Excalidraw";
export {
  _t as Button,
  O7e as CaptureUpdateAction,
  D7e as DEFAULT_LASER_COLOR,
  Id as DefaultSidebar,
  HG as DiagramToCodePlugin,
  XG as Excalidraw,
  L7e as FONT_FAMILY,
  wG as Footer,
  TG as LiveCollaborationTrigger,
  A7e as MIME_TYPES,
  ct as MainMenu,
  mc as ROUNDNESS,
  Kt as Sidebar,
  ll as Stats,
  P7e as THEME,
  Ig as TTDDialog,
  ZI as TTDDialogTrigger,
  _7e as UserIdleState,
  MG as WelcomeScreen,
  si as bumpVersion,
  Si as convertToExcalidrawElements,
  fo as defaultLang,
  B2 as elementPartiallyOverlapsWithOrContainsBBox,
  F2 as elementsOverlappingBBox,
  cy as exportToBlob,
  pr as exportToCanvas,
  OP as exportToClipboard,
  pi as exportToSvg,
  J7e as getCommonBounds,
  xm as getDataURL,
  I7e as getFreeDrawSvgPath,
  xc as getLibraryItemsHash,
  p7e as getNonDeletedElements,
  c7e as getSceneVersion,
  h7e as getTextFromElements,
  Q7e as getVisibleSceneBounds,
  d7e as hashElementsVersion,
  m7e as hashString,
  xh as isElementInsideBBox,
  nDe as isElementLink,
  f7e as isInvisiblySmallElement,
  k7e as isLinearElement,
  Tn as languages,
  Fl as loadFromBlob,
  bm as loadLibraryFromBlob,
  fm as loadSceneOrLibraryFromBlob,
  xy as mergeLibraryItems,
  uc as mutateElement,
  B7e as newElementWith,
  R7e as normalizeLink,
  Ou as parseLibraryTokensFromUrl,
  FG as reconcileElements,
  wn as restore,
  JI as restoreAppState,
  gm as restoreElements,
  Zi as restoreLibraryItems,
  ny as sceneCoordsToViewportCoords,
  Vi as serializeAsJSON,
  hm as serializeLibraryAsJSON,
  aDe as setCustomTextMetricsProvider,
  ae as useDevice,
  tA as useHandleLibrary,
  ze as useI18n,
  G7e as viewportCoordsToSceneCoords,
  xx as zoomToFitBounds,
};
